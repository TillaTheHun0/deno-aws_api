// Autogenerated API client for: EC2 Image Builder

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Imagebuilder {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Imagebuilder.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-12-02",
    "endpointPrefix": "imagebuilder",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "imagebuilder",
    "serviceFullName": "EC2 Image Builder",
    "serviceId": "imagebuilder",
    "signatureVersion": "v4",
    "signingName": "imagebuilder",
    "uid": "imagebuilder-2019-12-02"
  };

  async cancelImageCreation(
    {abortSignal, ...params}: RequestConfig & s.CancelImageCreationRequest,
  ): Promise<s.CancelImageCreationResponse> {
    const body: jsonP.JSONObject = {
      imageBuildVersionArn: params["imageBuildVersionArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelImageCreation",
      method: "PUT",
      requestUri: "/CancelImageCreation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imageBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async createComponent(
    {abortSignal, ...params}: RequestConfig & s.CreateComponentRequest,
  ): Promise<s.CreateComponentResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      semanticVersion: params["semanticVersion"],
      description: params["description"],
      changeDescription: params["changeDescription"],
      platform: params["platform"],
      supportedOsVersions: params["supportedOsVersions"],
      data: params["data"],
      uri: params["uri"],
      kmsKeyId: params["kmsKeyId"],
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateComponent",
      method: "PUT",
      requestUri: "/CreateComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "componentBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async createContainerRecipe(
    {abortSignal, ...params}: RequestConfig & s.CreateContainerRecipeRequest,
  ): Promise<s.CreateContainerRecipeResponse> {
    const body: jsonP.JSONObject = {
      containerType: params["containerType"],
      name: params["name"],
      description: params["description"],
      semanticVersion: params["semanticVersion"],
      components: params["components"]?.map(x => fromComponentConfiguration(x)),
      dockerfileTemplateData: params["dockerfileTemplateData"],
      dockerfileTemplateUri: params["dockerfileTemplateUri"],
      platformOverride: params["platformOverride"],
      imageOsVersionOverride: params["imageOsVersionOverride"],
      parentImage: params["parentImage"],
      tags: params["tags"],
      workingDirectory: params["workingDirectory"],
      targetRepository: fromTargetContainerRepository(params["targetRepository"]),
      kmsKeyId: params["kmsKeyId"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContainerRecipe",
      method: "PUT",
      requestUri: "/CreateContainerRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "containerRecipeArn": "s",
      },
    }, await resp.json());
  }

  async createDistributionConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionConfigurationRequest,
  ): Promise<s.CreateDistributionConfigurationResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      distributions: params["distributions"]?.map(x => fromDistribution(x)),
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistributionConfiguration",
      method: "PUT",
      requestUri: "/CreateDistributionConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "distributionConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async createImage(
    {abortSignal, ...params}: RequestConfig & s.CreateImageRequest,
  ): Promise<s.CreateImageResponse> {
    const body: jsonP.JSONObject = {
      imageRecipeArn: params["imageRecipeArn"],
      containerRecipeArn: params["containerRecipeArn"],
      distributionConfigurationArn: params["distributionConfigurationArn"],
      infrastructureConfigurationArn: params["infrastructureConfigurationArn"],
      imageTestsConfiguration: fromImageTestsConfiguration(params["imageTestsConfiguration"]),
      enhancedImageMetadataEnabled: params["enhancedImageMetadataEnabled"],
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImage",
      method: "PUT",
      requestUri: "/CreateImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imageBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async createImagePipeline(
    {abortSignal, ...params}: RequestConfig & s.CreateImagePipelineRequest,
  ): Promise<s.CreateImagePipelineResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      imageRecipeArn: params["imageRecipeArn"],
      containerRecipeArn: params["containerRecipeArn"],
      infrastructureConfigurationArn: params["infrastructureConfigurationArn"],
      distributionConfigurationArn: params["distributionConfigurationArn"],
      imageTestsConfiguration: fromImageTestsConfiguration(params["imageTestsConfiguration"]),
      enhancedImageMetadataEnabled: params["enhancedImageMetadataEnabled"],
      schedule: fromSchedule(params["schedule"]),
      status: params["status"],
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImagePipeline",
      method: "PUT",
      requestUri: "/CreateImagePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imagePipelineArn": "s",
      },
    }, await resp.json());
  }

  async createImageRecipe(
    {abortSignal, ...params}: RequestConfig & s.CreateImageRecipeRequest,
  ): Promise<s.CreateImageRecipeResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      semanticVersion: params["semanticVersion"],
      components: params["components"]?.map(x => fromComponentConfiguration(x)),
      parentImage: params["parentImage"],
      blockDeviceMappings: params["blockDeviceMappings"]?.map(x => fromInstanceBlockDeviceMapping(x)),
      tags: params["tags"],
      workingDirectory: params["workingDirectory"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImageRecipe",
      method: "PUT",
      requestUri: "/CreateImageRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imageRecipeArn": "s",
      },
    }, await resp.json());
  }

  async createInfrastructureConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateInfrastructureConfigurationRequest,
  ): Promise<s.CreateInfrastructureConfigurationResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      instanceTypes: params["instanceTypes"],
      instanceProfileName: params["instanceProfileName"],
      securityGroupIds: params["securityGroupIds"],
      subnetId: params["subnetId"],
      logging: fromLogging(params["logging"]),
      keyPair: params["keyPair"],
      terminateInstanceOnFailure: params["terminateInstanceOnFailure"],
      snsTopicArn: params["snsTopicArn"],
      resourceTags: params["resourceTags"],
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInfrastructureConfiguration",
      method: "PUT",
      requestUri: "/CreateInfrastructureConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "infrastructureConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async deleteComponent(
    {abortSignal, ...params}: RequestConfig & s.DeleteComponentRequest,
  ): Promise<s.DeleteComponentResponse> {
    const query = new URLSearchParams;
    query.set("componentBuildVersionArn", params["componentBuildVersionArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteComponent",
      method: "DELETE",
      requestUri: "/DeleteComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "componentBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async deleteContainerRecipe(
    {abortSignal, ...params}: RequestConfig & s.DeleteContainerRecipeRequest,
  ): Promise<s.DeleteContainerRecipeResponse> {
    const query = new URLSearchParams;
    query.set("containerRecipeArn", params["containerRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteContainerRecipe",
      method: "DELETE",
      requestUri: "/DeleteContainerRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "containerRecipeArn": "s",
      },
    }, await resp.json());
  }

  async deleteDistributionConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteDistributionConfigurationRequest,
  ): Promise<s.DeleteDistributionConfigurationResponse> {
    const query = new URLSearchParams;
    query.set("distributionConfigurationArn", params["distributionConfigurationArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDistributionConfiguration",
      method: "DELETE",
      requestUri: "/DeleteDistributionConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "distributionConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async deleteImage(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageRequest,
  ): Promise<s.DeleteImageResponse> {
    const query = new URLSearchParams;
    query.set("imageBuildVersionArn", params["imageBuildVersionArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteImage",
      method: "DELETE",
      requestUri: "/DeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async deleteImagePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeleteImagePipelineRequest,
  ): Promise<s.DeleteImagePipelineResponse> {
    const query = new URLSearchParams;
    query.set("imagePipelineArn", params["imagePipelineArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteImagePipeline",
      method: "DELETE",
      requestUri: "/DeleteImagePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imagePipelineArn": "s",
      },
    }, await resp.json());
  }

  async deleteImageRecipe(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageRecipeRequest,
  ): Promise<s.DeleteImageRecipeResponse> {
    const query = new URLSearchParams;
    query.set("imageRecipeArn", params["imageRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteImageRecipe",
      method: "DELETE",
      requestUri: "/DeleteImageRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageRecipeArn": "s",
      },
    }, await resp.json());
  }

  async deleteInfrastructureConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteInfrastructureConfigurationRequest,
  ): Promise<s.DeleteInfrastructureConfigurationResponse> {
    const query = new URLSearchParams;
    query.set("infrastructureConfigurationArn", params["infrastructureConfigurationArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteInfrastructureConfiguration",
      method: "DELETE",
      requestUri: "/DeleteInfrastructureConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "infrastructureConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async getComponent(
    {abortSignal, ...params}: RequestConfig & s.GetComponentRequest,
  ): Promise<s.GetComponentResponse> {
    const query = new URLSearchParams;
    query.set("componentBuildVersionArn", params["componentBuildVersionArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetComponent",
      method: "GET",
      requestUri: "/GetComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "component": toComponent,
      },
    }, await resp.json());
  }

  async getComponentPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetComponentPolicyRequest,
  ): Promise<s.GetComponentPolicyResponse> {
    const query = new URLSearchParams;
    query.set("componentArn", params["componentArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetComponentPolicy",
      method: "GET",
      requestUri: "/GetComponentPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "policy": "s",
      },
    }, await resp.json());
  }

  async getContainerRecipe(
    {abortSignal, ...params}: RequestConfig & s.GetContainerRecipeRequest,
  ): Promise<s.GetContainerRecipeResponse> {
    const query = new URLSearchParams;
    query.set("containerRecipeArn", params["containerRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetContainerRecipe",
      method: "GET",
      requestUri: "/GetContainerRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "containerRecipe": toContainerRecipe,
      },
    }, await resp.json());
  }

  async getContainerRecipePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetContainerRecipePolicyRequest,
  ): Promise<s.GetContainerRecipePolicyResponse> {
    const query = new URLSearchParams;
    query.set("containerRecipeArn", params["containerRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetContainerRecipePolicy",
      method: "GET",
      requestUri: "/GetContainerRecipePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "policy": "s",
      },
    }, await resp.json());
  }

  async getDistributionConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionConfigurationRequest,
  ): Promise<s.GetDistributionConfigurationResponse> {
    const query = new URLSearchParams;
    query.set("distributionConfigurationArn", params["distributionConfigurationArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDistributionConfiguration",
      method: "GET",
      requestUri: "/GetDistributionConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "distributionConfiguration": toDistributionConfiguration,
      },
    }, await resp.json());
  }

  async getImage(
    {abortSignal, ...params}: RequestConfig & s.GetImageRequest,
  ): Promise<s.GetImageResponse> {
    const query = new URLSearchParams;
    query.set("imageBuildVersionArn", params["imageBuildVersionArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImage",
      method: "GET",
      requestUri: "/GetImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "image": toImage,
      },
    }, await resp.json());
  }

  async getImagePipeline(
    {abortSignal, ...params}: RequestConfig & s.GetImagePipelineRequest,
  ): Promise<s.GetImagePipelineResponse> {
    const query = new URLSearchParams;
    query.set("imagePipelineArn", params["imagePipelineArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImagePipeline",
      method: "GET",
      requestUri: "/GetImagePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imagePipeline": toImagePipeline,
      },
    }, await resp.json());
  }

  async getImagePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetImagePolicyRequest,
  ): Promise<s.GetImagePolicyResponse> {
    const query = new URLSearchParams;
    query.set("imageArn", params["imageArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImagePolicy",
      method: "GET",
      requestUri: "/GetImagePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "policy": "s",
      },
    }, await resp.json());
  }

  async getImageRecipe(
    {abortSignal, ...params}: RequestConfig & s.GetImageRecipeRequest,
  ): Promise<s.GetImageRecipeResponse> {
    const query = new URLSearchParams;
    query.set("imageRecipeArn", params["imageRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImageRecipe",
      method: "GET",
      requestUri: "/GetImageRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageRecipe": toImageRecipe,
      },
    }, await resp.json());
  }

  async getImageRecipePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetImageRecipePolicyRequest,
  ): Promise<s.GetImageRecipePolicyResponse> {
    const query = new URLSearchParams;
    query.set("imageRecipeArn", params["imageRecipeArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImageRecipePolicy",
      method: "GET",
      requestUri: "/GetImageRecipePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "policy": "s",
      },
    }, await resp.json());
  }

  async getInfrastructureConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetInfrastructureConfigurationRequest,
  ): Promise<s.GetInfrastructureConfigurationResponse> {
    const query = new URLSearchParams;
    query.set("infrastructureConfigurationArn", params["infrastructureConfigurationArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetInfrastructureConfiguration",
      method: "GET",
      requestUri: "/GetInfrastructureConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "infrastructureConfiguration": toInfrastructureConfiguration,
      },
    }, await resp.json());
  }

  async importComponent(
    {abortSignal, ...params}: RequestConfig & s.ImportComponentRequest,
  ): Promise<s.ImportComponentResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      semanticVersion: params["semanticVersion"],
      description: params["description"],
      changeDescription: params["changeDescription"],
      type: params["type"],
      format: params["format"],
      platform: params["platform"],
      data: params["data"],
      uri: params["uri"],
      kmsKeyId: params["kmsKeyId"],
      tags: params["tags"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportComponent",
      method: "PUT",
      requestUri: "/ImportComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "componentBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async listComponentBuildVersions(
    {abortSignal, ...params}: RequestConfig & s.ListComponentBuildVersionsRequest,
  ): Promise<s.ListComponentBuildVersionsResponse> {
    const body: jsonP.JSONObject = {
      componentVersionArn: params["componentVersionArn"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListComponentBuildVersions",
      requestUri: "/ListComponentBuildVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "componentSummaryList": [toComponentSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listComponents(
    {abortSignal, ...params}: RequestConfig & s.ListComponentsRequest = {},
  ): Promise<s.ListComponentsResponse> {
    const body: jsonP.JSONObject = {
      owner: params["owner"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      byName: params["byName"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListComponents",
      requestUri: "/ListComponents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "componentVersionList": [toComponentVersion],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listContainerRecipes(
    {abortSignal, ...params}: RequestConfig & s.ListContainerRecipesRequest = {},
  ): Promise<s.ListContainerRecipesResponse> {
    const body: jsonP.JSONObject = {
      owner: params["owner"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContainerRecipes",
      requestUri: "/ListContainerRecipes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "containerRecipeSummaryList": [toContainerRecipeSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDistributionConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionConfigurationsRequest = {},
  ): Promise<s.ListDistributionConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDistributionConfigurations",
      requestUri: "/ListDistributionConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "distributionConfigurationSummaryList": [toDistributionConfigurationSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImageBuildVersions(
    {abortSignal, ...params}: RequestConfig & s.ListImageBuildVersionsRequest,
  ): Promise<s.ListImageBuildVersionsResponse> {
    const body: jsonP.JSONObject = {
      imageVersionArn: params["imageVersionArn"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImageBuildVersions",
      requestUri: "/ListImageBuildVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageSummaryList": [toImageSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImagePackages(
    {abortSignal, ...params}: RequestConfig & s.ListImagePackagesRequest,
  ): Promise<s.ListImagePackagesResponse> {
    const body: jsonP.JSONObject = {
      imageBuildVersionArn: params["imageBuildVersionArn"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImagePackages",
      requestUri: "/ListImagePackages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imagePackageList": [toImagePackage],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImagePipelineImages(
    {abortSignal, ...params}: RequestConfig & s.ListImagePipelineImagesRequest,
  ): Promise<s.ListImagePipelineImagesResponse> {
    const body: jsonP.JSONObject = {
      imagePipelineArn: params["imagePipelineArn"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImagePipelineImages",
      requestUri: "/ListImagePipelineImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageSummaryList": [toImageSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImagePipelines(
    {abortSignal, ...params}: RequestConfig & s.ListImagePipelinesRequest = {},
  ): Promise<s.ListImagePipelinesResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImagePipelines",
      requestUri: "/ListImagePipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imagePipelineList": [toImagePipeline],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImageRecipes(
    {abortSignal, ...params}: RequestConfig & s.ListImageRecipesRequest = {},
  ): Promise<s.ListImageRecipesResponse> {
    const body: jsonP.JSONObject = {
      owner: params["owner"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImageRecipes",
      requestUri: "/ListImageRecipes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageRecipeSummaryList": [toImageRecipeSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listImages(
    {abortSignal, ...params}: RequestConfig & s.ListImagesRequest = {},
  ): Promise<s.ListImagesResponse> {
    const body: jsonP.JSONObject = {
      owner: params["owner"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      byName: params["byName"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      includeDeprecated: params["includeDeprecated"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImages",
      requestUri: "/ListImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageVersionList": [toImageVersion],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listInfrastructureConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListInfrastructureConfigurationsRequest = {},
  ): Promise<s.ListInfrastructureConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInfrastructureConfigurations",
      requestUri: "/ListInfrastructureConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "infrastructureConfigurationSummaryList": [toInfrastructureConfigurationSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putComponentPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutComponentPolicyRequest,
  ): Promise<s.PutComponentPolicyResponse> {
    const body: jsonP.JSONObject = {
      componentArn: params["componentArn"],
      policy: params["policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutComponentPolicy",
      method: "PUT",
      requestUri: "/PutComponentPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "componentArn": "s",
      },
    }, await resp.json());
  }

  async putContainerRecipePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutContainerRecipePolicyRequest,
  ): Promise<s.PutContainerRecipePolicyResponse> {
    const body: jsonP.JSONObject = {
      containerRecipeArn: params["containerRecipeArn"],
      policy: params["policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutContainerRecipePolicy",
      method: "PUT",
      requestUri: "/PutContainerRecipePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "containerRecipeArn": "s",
      },
    }, await resp.json());
  }

  async putImagePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutImagePolicyRequest,
  ): Promise<s.PutImagePolicyResponse> {
    const body: jsonP.JSONObject = {
      imageArn: params["imageArn"],
      policy: params["policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImagePolicy",
      method: "PUT",
      requestUri: "/PutImagePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageArn": "s",
      },
    }, await resp.json());
  }

  async putImageRecipePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutImageRecipePolicyRequest,
  ): Promise<s.PutImageRecipePolicyResponse> {
    const body: jsonP.JSONObject = {
      imageRecipeArn: params["imageRecipeArn"],
      policy: params["policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImageRecipePolicy",
      method: "PUT",
      requestUri: "/PutImageRecipePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "imageRecipeArn": "s",
      },
    }, await resp.json());
  }

  async startImagePipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.StartImagePipelineExecutionRequest,
  ): Promise<s.StartImagePipelineExecutionResponse> {
    const body: jsonP.JSONObject = {
      imagePipelineArn: params["imagePipelineArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImagePipelineExecution",
      method: "PUT",
      requestUri: "/StartImagePipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imageBuildVersionArn": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDistributionConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateDistributionConfigurationRequest,
  ): Promise<s.UpdateDistributionConfigurationResponse> {
    const body: jsonP.JSONObject = {
      distributionConfigurationArn: params["distributionConfigurationArn"],
      description: params["description"],
      distributions: params["distributions"]?.map(x => fromDistribution(x)),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDistributionConfiguration",
      method: "PUT",
      requestUri: "/UpdateDistributionConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "distributionConfigurationArn": "s",
      },
    }, await resp.json());
  }

  async updateImagePipeline(
    {abortSignal, ...params}: RequestConfig & s.UpdateImagePipelineRequest,
  ): Promise<s.UpdateImagePipelineResponse> {
    const body: jsonP.JSONObject = {
      imagePipelineArn: params["imagePipelineArn"],
      description: params["description"],
      imageRecipeArn: params["imageRecipeArn"],
      containerRecipeArn: params["containerRecipeArn"],
      infrastructureConfigurationArn: params["infrastructureConfigurationArn"],
      distributionConfigurationArn: params["distributionConfigurationArn"],
      imageTestsConfiguration: fromImageTestsConfiguration(params["imageTestsConfiguration"]),
      enhancedImageMetadataEnabled: params["enhancedImageMetadataEnabled"],
      schedule: fromSchedule(params["schedule"]),
      status: params["status"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateImagePipeline",
      method: "PUT",
      requestUri: "/UpdateImagePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "imagePipelineArn": "s",
      },
    }, await resp.json());
  }

  async updateInfrastructureConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateInfrastructureConfigurationRequest,
  ): Promise<s.UpdateInfrastructureConfigurationResponse> {
    const body: jsonP.JSONObject = {
      infrastructureConfigurationArn: params["infrastructureConfigurationArn"],
      description: params["description"],
      instanceTypes: params["instanceTypes"],
      instanceProfileName: params["instanceProfileName"],
      securityGroupIds: params["securityGroupIds"],
      subnetId: params["subnetId"],
      logging: fromLogging(params["logging"]),
      keyPair: params["keyPair"],
      terminateInstanceOnFailure: params["terminateInstanceOnFailure"],
      snsTopicArn: params["snsTopicArn"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      resourceTags: params["resourceTags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInfrastructureConfiguration",
      method: "PUT",
      requestUri: "/UpdateInfrastructureConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "requestId": "s",
        "clientToken": "s",
        "infrastructureConfigurationArn": "s",
      },
    }, await resp.json());
  }

}

function fromComponentConfiguration(input?: s.ComponentConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    componentArn: input["componentArn"],
  }
}
function toComponentConfiguration(root: jsonP.JSONValue): s.ComponentConfiguration {
  return jsonP.readObj({
    required: {
      "componentArn": "s",
    },
    optional: {},
  }, root);
}

function fromTargetContainerRepository(input?: s.TargetContainerRepository | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    service: input["service"],
    repositoryName: input["repositoryName"],
  }
}
function toTargetContainerRepository(root: jsonP.JSONValue): s.TargetContainerRepository {
  return jsonP.readObj({
    required: {
      "service": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerRepositoryService>(x),
      "repositoryName": "s",
    },
    optional: {},
  }, root);
}

function fromDistribution(input?: s.Distribution | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    region: input["region"],
    amiDistributionConfiguration: fromAmiDistributionConfiguration(input["amiDistributionConfiguration"]),
    containerDistributionConfiguration: fromContainerDistributionConfiguration(input["containerDistributionConfiguration"]),
    licenseConfigurationArns: input["licenseConfigurationArns"],
  }
}
function toDistribution(root: jsonP.JSONValue): s.Distribution {
  return jsonP.readObj({
    required: {
      "region": "s",
    },
    optional: {
      "amiDistributionConfiguration": toAmiDistributionConfiguration,
      "containerDistributionConfiguration": toContainerDistributionConfiguration,
      "licenseConfigurationArns": ["s"],
    },
  }, root);
}

function fromAmiDistributionConfiguration(input?: s.AmiDistributionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    description: input["description"],
    targetAccountIds: input["targetAccountIds"],
    amiTags: input["amiTags"],
    kmsKeyId: input["kmsKeyId"],
    launchPermission: fromLaunchPermissionConfiguration(input["launchPermission"]),
  }
}
function toAmiDistributionConfiguration(root: jsonP.JSONValue): s.AmiDistributionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "targetAccountIds": ["s"],
      "amiTags": x => jsonP.readMap(String, String, x),
      "kmsKeyId": "s",
      "launchPermission": toLaunchPermissionConfiguration,
    },
  }, root);
}

function fromLaunchPermissionConfiguration(input?: s.LaunchPermissionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    userIds: input["userIds"],
    userGroups: input["userGroups"],
  }
}
function toLaunchPermissionConfiguration(root: jsonP.JSONValue): s.LaunchPermissionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "userIds": ["s"],
      "userGroups": ["s"],
    },
  }, root);
}

function fromContainerDistributionConfiguration(input?: s.ContainerDistributionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    description: input["description"],
    containerTags: input["containerTags"],
    targetRepository: fromTargetContainerRepository(input["targetRepository"]),
  }
}
function toContainerDistributionConfiguration(root: jsonP.JSONValue): s.ContainerDistributionConfiguration {
  return jsonP.readObj({
    required: {
      "targetRepository": toTargetContainerRepository,
    },
    optional: {
      "description": "s",
      "containerTags": ["s"],
    },
  }, root);
}

function fromImageTestsConfiguration(input?: s.ImageTestsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageTestsEnabled: input["imageTestsEnabled"],
    timeoutMinutes: input["timeoutMinutes"],
  }
}
function toImageTestsConfiguration(root: jsonP.JSONValue): s.ImageTestsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageTestsEnabled": "b",
      "timeoutMinutes": "n",
    },
  }, root);
}

function fromSchedule(input?: s.Schedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scheduleExpression: input["scheduleExpression"],
    timezone: input["timezone"],
    pipelineExecutionStartCondition: input["pipelineExecutionStartCondition"],
  }
}
function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "scheduleExpression": "s",
      "timezone": "s",
      "pipelineExecutionStartCondition": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStartCondition>(x),
    },
  }, root);
}

function fromInstanceBlockDeviceMapping(input?: s.InstanceBlockDeviceMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceName: input["deviceName"],
    ebs: fromEbsInstanceBlockDeviceSpecification(input["ebs"]),
    virtualName: input["virtualName"],
    noDevice: input["noDevice"],
  }
}
function toInstanceBlockDeviceMapping(root: jsonP.JSONValue): s.InstanceBlockDeviceMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "deviceName": "s",
      "ebs": toEbsInstanceBlockDeviceSpecification,
      "virtualName": "s",
      "noDevice": "s",
    },
  }, root);
}

function fromEbsInstanceBlockDeviceSpecification(input?: s.EbsInstanceBlockDeviceSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encrypted: input["encrypted"],
    deleteOnTermination: input["deleteOnTermination"],
    iops: input["iops"],
    kmsKeyId: input["kmsKeyId"],
    snapshotId: input["snapshotId"],
    volumeSize: input["volumeSize"],
    volumeType: input["volumeType"],
  }
}
function toEbsInstanceBlockDeviceSpecification(root: jsonP.JSONValue): s.EbsInstanceBlockDeviceSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "encrypted": "b",
      "deleteOnTermination": "b",
      "iops": "n",
      "kmsKeyId": "s",
      "snapshotId": "s",
      "volumeSize": "n",
      "volumeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EbsVolumeType>(x),
    },
  }, root);
}

function fromLogging(input?: s.Logging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Logs: fromS3Logs(input["s3Logs"]),
  }
}
function toLogging(root: jsonP.JSONValue): s.Logging {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Logs": toS3Logs,
    },
  }, root);
}

function fromS3Logs(input?: s.S3Logs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3BucketName: input["s3BucketName"],
    s3KeyPrefix: input["s3KeyPrefix"],
  }
}
function toS3Logs(root: jsonP.JSONValue): s.S3Logs {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3BucketName": "s",
      "s3KeyPrefix": "s",
    },
  }, root);
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

function toComponent(root: jsonP.JSONValue): s.Component {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "version": "s",
      "description": "s",
      "changeDescription": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComponentType>(x),
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "supportedOsVersions": ["s"],
      "owner": "s",
      "data": "s",
      "kmsKeyId": "s",
      "encrypted": "b",
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toContainerRecipe(root: jsonP.JSONValue): s.ContainerRecipe {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "containerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerType>(x),
      "name": "s",
      "description": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "owner": "s",
      "version": "s",
      "components": [toComponentConfiguration],
      "dockerfileTemplateData": "s",
      "kmsKeyId": "s",
      "encrypted": "b",
      "parentImage": "s",
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "workingDirectory": "s",
      "targetRepository": toTargetContainerRepository,
    },
  }, root);
}

function toDistributionConfiguration(root: jsonP.JSONValue): s.DistributionConfiguration {
  return jsonP.readObj({
    required: {
      "timeoutMinutes": "n",
    },
    optional: {
      "arn": "s",
      "name": "s",
      "description": "s",
      "distributions": [toDistribution],
      "dateCreated": "s",
      "dateUpdated": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toImage(root: jsonP.JSONValue): s.Image {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageType>(x),
      "name": "s",
      "version": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "enhancedImageMetadataEnabled": "b",
      "osVersion": "s",
      "state": toImageState,
      "imageRecipe": toImageRecipe,
      "containerRecipe": toContainerRecipe,
      "sourcePipelineName": "s",
      "sourcePipelineArn": "s",
      "infrastructureConfiguration": toInfrastructureConfiguration,
      "distributionConfiguration": toDistributionConfiguration,
      "imageTestsConfiguration": toImageTestsConfiguration,
      "dateCreated": "s",
      "outputResources": toOutputResources,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toImageState(root: jsonP.JSONValue): s.ImageState {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageStatus>(x),
      "reason": "s",
    },
  }, root);
}

function toImageRecipe(root: jsonP.JSONValue): s.ImageRecipe {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageType>(x),
      "name": "s",
      "description": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "owner": "s",
      "version": "s",
      "components": [toComponentConfiguration],
      "parentImage": "s",
      "blockDeviceMappings": [toInstanceBlockDeviceMapping],
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "workingDirectory": "s",
    },
  }, root);
}

function toInfrastructureConfiguration(root: jsonP.JSONValue): s.InfrastructureConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "description": "s",
      "instanceTypes": ["s"],
      "instanceProfileName": "s",
      "securityGroupIds": ["s"],
      "subnetId": "s",
      "logging": toLogging,
      "keyPair": "s",
      "terminateInstanceOnFailure": "b",
      "snsTopicArn": "s",
      "dateCreated": "s",
      "dateUpdated": "s",
      "resourceTags": x => jsonP.readMap(String, String, x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toOutputResources(root: jsonP.JSONValue): s.OutputResources {
  return jsonP.readObj({
    required: {},
    optional: {
      "amis": [toAmi],
      "containers": [toContainer],
    },
  }, root);
}

function toAmi(root: jsonP.JSONValue): s.Ami {
  return jsonP.readObj({
    required: {},
    optional: {
      "region": "s",
      "image": "s",
      "name": "s",
      "description": "s",
      "state": toImageState,
      "accountId": "s",
    },
  }, root);
}

function toContainer(root: jsonP.JSONValue): s.Container {
  return jsonP.readObj({
    required: {},
    optional: {
      "region": "s",
      "imageUris": ["s"],
    },
  }, root);
}

function toImagePipeline(root: jsonP.JSONValue): s.ImagePipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "description": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "enhancedImageMetadataEnabled": "b",
      "imageRecipeArn": "s",
      "containerRecipeArn": "s",
      "infrastructureConfigurationArn": "s",
      "distributionConfigurationArn": "s",
      "imageTestsConfiguration": toImageTestsConfiguration,
      "schedule": toSchedule,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineStatus>(x),
      "dateCreated": "s",
      "dateUpdated": "s",
      "dateLastRun": "s",
      "dateNextRun": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toComponentSummary(root: jsonP.JSONValue): s.ComponentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "version": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "supportedOsVersions": ["s"],
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComponentType>(x),
      "owner": "s",
      "description": "s",
      "changeDescription": "s",
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toComponentVersion(root: jsonP.JSONValue): s.ComponentVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "version": "s",
      "description": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "supportedOsVersions": ["s"],
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComponentType>(x),
      "owner": "s",
      "dateCreated": "s",
    },
  }, root);
}

function toContainerRecipeSummary(root: jsonP.JSONValue): s.ContainerRecipeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "containerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerType>(x),
      "name": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "owner": "s",
      "parentImage": "s",
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toDistributionConfigurationSummary(root: jsonP.JSONValue): s.DistributionConfigurationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "description": "s",
      "dateCreated": "s",
      "dateUpdated": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "regions": ["s"],
    },
  }, root);
}

function toImageSummary(root: jsonP.JSONValue): s.ImageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageType>(x),
      "version": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "osVersion": "s",
      "state": toImageState,
      "owner": "s",
      "dateCreated": "s",
      "outputResources": toOutputResources,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toImagePackage(root: jsonP.JSONValue): s.ImagePackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "packageName": "s",
      "packageVersion": "s",
    },
  }, root);
}

function toImageRecipeSummary(root: jsonP.JSONValue): s.ImageRecipeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "owner": "s",
      "parentImage": "s",
      "dateCreated": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toImageVersion(root: jsonP.JSONValue): s.ImageVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageType>(x),
      "version": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x),
      "osVersion": "s",
      "owner": "s",
      "dateCreated": "s",
    },
  }, root);
}

function toInfrastructureConfigurationSummary(root: jsonP.JSONValue): s.InfrastructureConfigurationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "description": "s",
      "dateCreated": "s",
      "dateUpdated": "s",
      "resourceTags": x => jsonP.readMap(String, String, x),
      "tags": x => jsonP.readMap(String, String, x),
      "instanceTypes": ["s"],
      "instanceProfileName": "s",
    },
  }, root);
}
