// Autogenerated API client for: Amazon GameLift

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class GameLift {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(GameLift.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-10-01",
    "endpointPrefix": "gamelift",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon GameLift",
    "serviceId": "GameLift",
    "signatureVersion": "v4",
    "targetPrefix": "GameLift",
    "uid": "gamelift-2015-10-01"
  };

  async acceptMatch(
    {abortSignal, ...params}: RequestConfig & s.AcceptMatchInput,
  ): Promise<s.AcceptMatchOutput> {
    const body: jsonP.JSONObject = {
      TicketId: params["TicketId"],
      PlayerIds: params["PlayerIds"],
      AcceptanceType: params["AcceptanceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptMatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async claimGameServer(
    {abortSignal, ...params}: RequestConfig & s.ClaimGameServerInput,
  ): Promise<s.ClaimGameServerOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      GameServerData: params["GameServerData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ClaimGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateAliasInput,
  ): Promise<s.CreateAliasOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      RoutingStrategy: fromRoutingStrategy(params["RoutingStrategy"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async createBuild(
    {abortSignal, ...params}: RequestConfig & s.CreateBuildInput = {},
  ): Promise<s.CreateBuildOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      OperatingSystem: params["OperatingSystem"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
        "UploadCredentials": toAwsCredentials,
        "StorageLocation": toS3Location,
      },
    }, await resp.json());
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & s.CreateFleetInput,
  ): Promise<s.CreateFleetOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      BuildId: params["BuildId"],
      ScriptId: params["ScriptId"],
      ServerLaunchPath: params["ServerLaunchPath"],
      ServerLaunchParameters: params["ServerLaunchParameters"],
      LogPaths: params["LogPaths"],
      EC2InstanceType: params["EC2InstanceType"],
      EC2InboundPermissions: params["EC2InboundPermissions"]?.map(x => fromIpPermission(x)),
      NewGameSessionProtectionPolicy: params["NewGameSessionProtectionPolicy"],
      RuntimeConfiguration: fromRuntimeConfiguration(params["RuntimeConfiguration"]),
      ResourceCreationLimitPolicy: fromResourceCreationLimitPolicy(params["ResourceCreationLimitPolicy"]),
      MetricGroups: params["MetricGroups"],
      PeerVpcAwsAccountId: params["PeerVpcAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
      FleetType: params["FleetType"],
      InstanceRoleArn: params["InstanceRoleArn"],
      CertificateConfiguration: fromCertificateConfiguration(params["CertificateConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetAttributes": toFleetAttributes,
      },
    }, await resp.json());
  }

  async createGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGameServerGroupInput,
  ): Promise<s.CreateGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      RoleArn: params["RoleArn"],
      MinSize: params["MinSize"],
      MaxSize: params["MaxSize"],
      LaunchTemplate: fromLaunchTemplateSpecification(params["LaunchTemplate"]),
      InstanceDefinitions: params["InstanceDefinitions"]?.map(x => fromInstanceDefinition(x)),
      AutoScalingPolicy: fromGameServerGroupAutoScalingPolicy(params["AutoScalingPolicy"]),
      BalancingStrategy: params["BalancingStrategy"],
      GameServerProtectionPolicy: params["GameServerProtectionPolicy"],
      VpcSubnets: params["VpcSubnets"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async createGameSession(
    {abortSignal, ...params}: RequestConfig & s.CreateGameSessionInput,
  ): Promise<s.CreateGameSessionOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      AliasId: params["AliasId"],
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      Name: params["Name"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      CreatorId: params["CreatorId"],
      GameSessionId: params["GameSessionId"],
      IdempotencyToken: params["IdempotencyToken"],
      GameSessionData: params["GameSessionData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSession": toGameSession,
      },
    }, await resp.json());
  }

  async createGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & s.CreateGameSessionQueueInput,
  ): Promise<s.CreateGameSessionQueueOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      PlayerLatencyPolicies: params["PlayerLatencyPolicies"]?.map(x => fromPlayerLatencyPolicy(x)),
      Destinations: params["Destinations"]?.map(x => fromGameSessionQueueDestination(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueue": toGameSessionQueue,
      },
    }, await resp.json());
  }

  async createMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateMatchmakingConfigurationInput,
  ): Promise<s.CreateMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      GameSessionQueueArns: params["GameSessionQueueArns"],
      RequestTimeoutSeconds: params["RequestTimeoutSeconds"],
      AcceptanceTimeoutSeconds: params["AcceptanceTimeoutSeconds"],
      AcceptanceRequired: params["AcceptanceRequired"],
      RuleSetName: params["RuleSetName"],
      NotificationTarget: params["NotificationTarget"],
      AdditionalPlayerCount: params["AdditionalPlayerCount"],
      CustomEventData: params["CustomEventData"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      GameSessionData: params["GameSessionData"],
      BackfillMode: params["BackfillMode"],
      FlexMatchMode: params["FlexMatchMode"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toMatchmakingConfiguration,
      },
    }, await resp.json());
  }

  async createMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & s.CreateMatchmakingRuleSetInput,
  ): Promise<s.CreateMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RuleSetBody: params["RuleSetBody"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {
        "RuleSet": toMatchmakingRuleSet,
      },
      optional: {},
    }, await resp.json());
  }

  async createPlayerSession(
    {abortSignal, ...params}: RequestConfig & s.CreatePlayerSessionInput,
  ): Promise<s.CreatePlayerSessionOutput> {
    const body: jsonP.JSONObject = {
      GameSessionId: params["GameSessionId"],
      PlayerId: params["PlayerId"],
      PlayerData: params["PlayerData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlayerSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSession": toPlayerSession,
      },
    }, await resp.json());
  }

  async createPlayerSessions(
    {abortSignal, ...params}: RequestConfig & s.CreatePlayerSessionsInput,
  ): Promise<s.CreatePlayerSessionsOutput> {
    const body: jsonP.JSONObject = {
      GameSessionId: params["GameSessionId"],
      PlayerIds: params["PlayerIds"],
      PlayerDataMap: params["PlayerDataMap"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlayerSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSessions": [toPlayerSession],
      },
    }, await resp.json());
  }

  async createScript(
    {abortSignal, ...params}: RequestConfig & s.CreateScriptInput = {},
  ): Promise<s.CreateScriptOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      ZipFile: serializeBlob(params["ZipFile"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async createVpcPeeringAuthorization(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcPeeringAuthorizationInput,
  ): Promise<s.CreateVpcPeeringAuthorizationOutput> {
    const body: jsonP.JSONObject = {
      GameLiftAwsAccountId: params["GameLiftAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringAuthorization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringAuthorization": toVpcPeeringAuthorization,
      },
    }, await resp.json());
  }

  async createVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcPeeringConnectionInput,
  ): Promise<s.CreateVpcPeeringConnectionOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      PeerVpcAwsAccountId: params["PeerVpcAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteAliasInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasId: params["AliasId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlias",
    });
  }

  async deleteBuild(
    {abortSignal, ...params}: RequestConfig & s.DeleteBuildInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      BuildId: params["BuildId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBuild",
    });
  }

  async deleteFleet(
    {abortSignal, ...params}: RequestConfig & s.DeleteFleetInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleet",
    });
  }

  async deleteGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGameServerGroupInput,
  ): Promise<s.DeleteGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      DeleteOption: params["DeleteOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async deleteGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & s.DeleteGameSessionQueueInput,
  ): Promise<s.DeleteGameSessionQueueOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteMatchmakingConfigurationInput,
  ): Promise<s.DeleteMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteMatchmakingRuleSetInput,
  ): Promise<s.DeleteMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteScalingPolicyInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FleetId: params["FleetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScalingPolicy",
    });
  }

  async deleteScript(
    {abortSignal, ...params}: RequestConfig & s.DeleteScriptInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ScriptId: params["ScriptId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScript",
    });
  }

  async deleteVpcPeeringAuthorization(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcPeeringAuthorizationInput,
  ): Promise<s.DeleteVpcPeeringAuthorizationOutput> {
    const body: jsonP.JSONObject = {
      GameLiftAwsAccountId: params["GameLiftAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringAuthorization",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcPeeringConnectionInput,
  ): Promise<s.DeleteVpcPeeringConnectionOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      VpcPeeringConnectionId: params["VpcPeeringConnectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterGameServer(
    {abortSignal, ...params}: RequestConfig & s.DeregisterGameServerInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterGameServer",
    });
  }

  async describeAlias(
    {abortSignal, ...params}: RequestConfig & s.DescribeAliasInput,
  ): Promise<s.DescribeAliasOutput> {
    const body: jsonP.JSONObject = {
      AliasId: params["AliasId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async describeBuild(
    {abortSignal, ...params}: RequestConfig & s.DescribeBuildInput,
  ): Promise<s.DescribeBuildOutput> {
    const body: jsonP.JSONObject = {
      BuildId: params["BuildId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
      },
    }, await resp.json());
  }

  async describeEC2InstanceLimits(
    {abortSignal, ...params}: RequestConfig & s.DescribeEC2InstanceLimitsInput = {},
  ): Promise<s.DescribeEC2InstanceLimitsOutput> {
    const body: jsonP.JSONObject = {
      EC2InstanceType: params["EC2InstanceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEC2InstanceLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EC2InstanceLimits": [toEC2InstanceLimit],
      },
    }, await resp.json());
  }

  async describeFleetAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetAttributesInput = {},
  ): Promise<s.DescribeFleetAttributesOutput> {
    const body: jsonP.JSONObject = {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetAttributes": [toFleetAttributes],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetCapacity(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetCapacityInput = {},
  ): Promise<s.DescribeFleetCapacityOutput> {
    const body: jsonP.JSONObject = {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetCapacity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetCapacity": [toFleetCapacity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetEventsInput,
  ): Promise<s.DescribeFleetEventsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Events": [toEvent],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetPortSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetPortSettingsInput,
  ): Promise<s.DescribeFleetPortSettingsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetPortSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InboundPermissions": [toIpPermission],
      },
    }, await resp.json());
  }

  async describeFleetUtilization(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetUtilizationInput = {},
  ): Promise<s.DescribeFleetUtilizationOutput> {
    const body: jsonP.JSONObject = {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetUtilization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetUtilization": [toFleetUtilization],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameServer(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameServerInput,
  ): Promise<s.DescribeGameServerOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async describeGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameServerGroupInput,
  ): Promise<s.DescribeGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async describeGameServerInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameServerInstancesInput,
  ): Promise<s.DescribeGameServerInstancesOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      InstanceIds: params["InstanceIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerInstances": [toGameServerInstance],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessionDetails(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameSessionDetailsInput = {},
  ): Promise<s.DescribeGameSessionDetailsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      GameSessionId: params["GameSessionId"],
      AliasId: params["AliasId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionDetails": [toGameSessionDetail],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameSessionPlacementInput,
  ): Promise<s.DescribeGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = {
      PlacementId: params["PlacementId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async describeGameSessionQueues(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameSessionQueuesInput = {},
  ): Promise<s.DescribeGameSessionQueuesOutput> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionQueues",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueues": [toGameSessionQueue],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessions(
    {abortSignal, ...params}: RequestConfig & s.DescribeGameSessionsInput = {},
  ): Promise<s.DescribeGameSessionsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      GameSessionId: params["GameSessionId"],
      AliasId: params["AliasId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessions": [toGameSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancesInput,
  ): Promise<s.DescribeInstancesOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      InstanceId: params["InstanceId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMatchmaking(
    {abortSignal, ...params}: RequestConfig & s.DescribeMatchmakingInput,
  ): Promise<s.DescribeMatchmakingOutput> {
    const body: jsonP.JSONObject = {
      TicketIds: params["TicketIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TicketList": [toMatchmakingTicket],
      },
    }, await resp.json());
  }

  async describeMatchmakingConfigurations(
    {abortSignal, ...params}: RequestConfig & s.DescribeMatchmakingConfigurationsInput = {},
  ): Promise<s.DescribeMatchmakingConfigurationsOutput> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      RuleSetName: params["RuleSetName"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmakingConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configurations": [toMatchmakingConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMatchmakingRuleSets(
    {abortSignal, ...params}: RequestConfig & s.DescribeMatchmakingRuleSetsInput = {},
  ): Promise<s.DescribeMatchmakingRuleSetsOutput> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmakingRuleSets",
    });
    return jsonP.readObj({
      required: {
        "RuleSets": [toMatchmakingRuleSet],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePlayerSessions(
    {abortSignal, ...params}: RequestConfig & s.DescribePlayerSessionsInput = {},
  ): Promise<s.DescribePlayerSessionsOutput> {
    const body: jsonP.JSONObject = {
      GameSessionId: params["GameSessionId"],
      PlayerId: params["PlayerId"],
      PlayerSessionId: params["PlayerSessionId"],
      PlayerSessionStatusFilter: params["PlayerSessionStatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePlayerSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSessions": [toPlayerSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeRuntimeConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeRuntimeConfigurationInput,
  ): Promise<s.DescribeRuntimeConfigurationOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRuntimeConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuntimeConfiguration": toRuntimeConfiguration,
      },
    }, await resp.json());
  }

  async describeScalingPolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribeScalingPoliciesInput,
  ): Promise<s.DescribeScalingPoliciesOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ScalingPolicies": [toScalingPolicy],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeScript(
    {abortSignal, ...params}: RequestConfig & s.DescribeScriptInput,
  ): Promise<s.DescribeScriptOutput> {
    const body: jsonP.JSONObject = {
      ScriptId: params["ScriptId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async describeVpcPeeringAuthorizations(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcPeeringAuthorizationsInput = {},
  ): Promise<s.DescribeVpcPeeringAuthorizationsOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringAuthorizations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringAuthorizations": [toVpcPeeringAuthorization],
      },
    }, await resp.json());
  }

  async describeVpcPeeringConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeVpcPeeringConnectionsInput = {},
  ): Promise<s.DescribeVpcPeeringConnectionsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringConnections": [toVpcPeeringConnection],
      },
    }, await resp.json());
  }

  async getGameSessionLogUrl(
    {abortSignal, ...params}: RequestConfig & s.GetGameSessionLogUrlInput,
  ): Promise<s.GetGameSessionLogUrlOutput> {
    const body: jsonP.JSONObject = {
      GameSessionId: params["GameSessionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGameSessionLogUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PreSignedUrl": "s",
      },
    }, await resp.json());
  }

  async getInstanceAccess(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceAccessInput,
  ): Promise<s.GetInstanceAccessOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceAccess",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceAccess": toInstanceAccess,
      },
    }, await resp.json());
  }

  async listAliases(
    {abortSignal, ...params}: RequestConfig & s.ListAliasesInput = {},
  ): Promise<s.ListAliasesOutput> {
    const body: jsonP.JSONObject = {
      RoutingStrategyType: params["RoutingStrategyType"],
      Name: params["Name"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Aliases": [toAlias],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listBuilds(
    {abortSignal, ...params}: RequestConfig & s.ListBuildsInput = {},
  ): Promise<s.ListBuildsOutput> {
    const body: jsonP.JSONObject = {
      Status: params["Status"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Builds": [toBuild],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFleets(
    {abortSignal, ...params}: RequestConfig & s.ListFleetsInput = {},
  ): Promise<s.ListFleetsOutput> {
    const body: jsonP.JSONObject = {
      BuildId: params["BuildId"],
      ScriptId: params["ScriptId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetIds": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGameServerGroups(
    {abortSignal, ...params}: RequestConfig & s.ListGameServerGroupsInput = {},
  ): Promise<s.ListGameServerGroupsOutput> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGameServerGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroups": [toGameServerGroup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGameServers(
    {abortSignal, ...params}: RequestConfig & s.ListGameServersInput,
  ): Promise<s.ListGameServersOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      SortOrder: params["SortOrder"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGameServers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServers": [toGameServer],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listScripts(
    {abortSignal, ...params}: RequestConfig & s.ListScriptsInput = {},
  ): Promise<s.ListScriptsOutput> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListScripts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Scripts": [toScript],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async putScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutScalingPolicyInput,
  ): Promise<s.PutScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FleetId: params["FleetId"],
      ScalingAdjustment: params["ScalingAdjustment"],
      ScalingAdjustmentType: params["ScalingAdjustmentType"],
      Threshold: params["Threshold"],
      ComparisonOperator: params["ComparisonOperator"],
      EvaluationPeriods: params["EvaluationPeriods"],
      MetricName: params["MetricName"],
      PolicyType: params["PolicyType"],
      TargetConfiguration: fromTargetConfiguration(params["TargetConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async registerGameServer(
    {abortSignal, ...params}: RequestConfig & s.RegisterGameServerInput,
  ): Promise<s.RegisterGameServerOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      InstanceId: params["InstanceId"],
      ConnectionInfo: params["ConnectionInfo"],
      GameServerData: params["GameServerData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async requestUploadCredentials(
    {abortSignal, ...params}: RequestConfig & s.RequestUploadCredentialsInput,
  ): Promise<s.RequestUploadCredentialsOutput> {
    const body: jsonP.JSONObject = {
      BuildId: params["BuildId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestUploadCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UploadCredentials": toAwsCredentials,
        "StorageLocation": toS3Location,
      },
    }, await resp.json());
  }

  async resolveAlias(
    {abortSignal, ...params}: RequestConfig & s.ResolveAliasInput,
  ): Promise<s.ResolveAliasOutput> {
    const body: jsonP.JSONObject = {
      AliasId: params["AliasId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResolveAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
        "FleetArn": "s",
      },
    }, await resp.json());
  }

  async resumeGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.ResumeGameServerGroupInput,
  ): Promise<s.ResumeGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      ResumeActions: params["ResumeActions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async searchGameSessions(
    {abortSignal, ...params}: RequestConfig & s.SearchGameSessionsInput = {},
  ): Promise<s.SearchGameSessionsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      AliasId: params["AliasId"],
      FilterExpression: params["FilterExpression"],
      SortExpression: params["SortExpression"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchGameSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessions": [toGameSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startFleetActions(
    {abortSignal, ...params}: RequestConfig & s.StartFleetActionsInput,
  ): Promise<s.StartFleetActionsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      Actions: params["Actions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartFleetActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & s.StartGameSessionPlacementInput,
  ): Promise<s.StartGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = {
      PlacementId: params["PlacementId"],
      GameSessionQueueName: params["GameSessionQueueName"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      GameSessionName: params["GameSessionName"],
      PlayerLatencies: params["PlayerLatencies"]?.map(x => fromPlayerLatency(x)),
      DesiredPlayerSessions: params["DesiredPlayerSessions"]?.map(x => fromDesiredPlayerSession(x)),
      GameSessionData: params["GameSessionData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async startMatchBackfill(
    {abortSignal, ...params}: RequestConfig & s.StartMatchBackfillInput,
  ): Promise<s.StartMatchBackfillOutput> {
    const body: jsonP.JSONObject = {
      TicketId: params["TicketId"],
      ConfigurationName: params["ConfigurationName"],
      GameSessionArn: params["GameSessionArn"],
      Players: params["Players"]?.map(x => fromPlayer(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMatchBackfill",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MatchmakingTicket": toMatchmakingTicket,
      },
    }, await resp.json());
  }

  async startMatchmaking(
    {abortSignal, ...params}: RequestConfig & s.StartMatchmakingInput,
  ): Promise<s.StartMatchmakingOutput> {
    const body: jsonP.JSONObject = {
      TicketId: params["TicketId"],
      ConfigurationName: params["ConfigurationName"],
      Players: params["Players"]?.map(x => fromPlayer(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MatchmakingTicket": toMatchmakingTicket,
      },
    }, await resp.json());
  }

  async stopFleetActions(
    {abortSignal, ...params}: RequestConfig & s.StopFleetActionsInput,
  ): Promise<s.StopFleetActionsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      Actions: params["Actions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopFleetActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & s.StopGameSessionPlacementInput,
  ): Promise<s.StopGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = {
      PlacementId: params["PlacementId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async stopMatchmaking(
    {abortSignal, ...params}: RequestConfig & s.StopMatchmakingInput,
  ): Promise<s.StopMatchmakingOutput> {
    const body: jsonP.JSONObject = {
      TicketId: params["TicketId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async suspendGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.SuspendGameServerGroupInput,
  ): Promise<s.SuspendGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      SuspendActions: params["SuspendActions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SuspendGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateAliasInput,
  ): Promise<s.UpdateAliasOutput> {
    const body: jsonP.JSONObject = {
      AliasId: params["AliasId"],
      Name: params["Name"],
      Description: params["Description"],
      RoutingStrategy: fromRoutingStrategy(params["RoutingStrategy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async updateBuild(
    {abortSignal, ...params}: RequestConfig & s.UpdateBuildInput,
  ): Promise<s.UpdateBuildOutput> {
    const body: jsonP.JSONObject = {
      BuildId: params["BuildId"],
      Name: params["Name"],
      Version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
      },
    }, await resp.json());
  }

  async updateFleetAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateFleetAttributesInput,
  ): Promise<s.UpdateFleetAttributesOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      Name: params["Name"],
      Description: params["Description"],
      NewGameSessionProtectionPolicy: params["NewGameSessionProtectionPolicy"],
      ResourceCreationLimitPolicy: fromResourceCreationLimitPolicy(params["ResourceCreationLimitPolicy"]),
      MetricGroups: params["MetricGroups"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateFleetCapacity(
    {abortSignal, ...params}: RequestConfig & s.UpdateFleetCapacityInput,
  ): Promise<s.UpdateFleetCapacityOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      DesiredInstances: params["DesiredInstances"],
      MinSize: params["MinSize"],
      MaxSize: params["MaxSize"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetCapacity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateFleetPortSettings(
    {abortSignal, ...params}: RequestConfig & s.UpdateFleetPortSettingsInput,
  ): Promise<s.UpdateFleetPortSettingsOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      InboundPermissionAuthorizations: params["InboundPermissionAuthorizations"]?.map(x => fromIpPermission(x)),
      InboundPermissionRevocations: params["InboundPermissionRevocations"]?.map(x => fromIpPermission(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetPortSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateGameServer(
    {abortSignal, ...params}: RequestConfig & s.UpdateGameServerInput,
  ): Promise<s.UpdateGameServerOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      GameServerData: params["GameServerData"],
      UtilizationStatus: params["UtilizationStatus"],
      HealthCheck: params["HealthCheck"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async updateGameServerGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateGameServerGroupInput,
  ): Promise<s.UpdateGameServerGroupOutput> {
    const body: jsonP.JSONObject = {
      GameServerGroupName: params["GameServerGroupName"],
      RoleArn: params["RoleArn"],
      InstanceDefinitions: params["InstanceDefinitions"]?.map(x => fromInstanceDefinition(x)),
      GameServerProtectionPolicy: params["GameServerProtectionPolicy"],
      BalancingStrategy: params["BalancingStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async updateGameSession(
    {abortSignal, ...params}: RequestConfig & s.UpdateGameSessionInput,
  ): Promise<s.UpdateGameSessionOutput> {
    const body: jsonP.JSONObject = {
      GameSessionId: params["GameSessionId"],
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      Name: params["Name"],
      PlayerSessionCreationPolicy: params["PlayerSessionCreationPolicy"],
      ProtectionPolicy: params["ProtectionPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSession": toGameSession,
      },
    }, await resp.json());
  }

  async updateGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & s.UpdateGameSessionQueueInput,
  ): Promise<s.UpdateGameSessionQueueOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      PlayerLatencyPolicies: params["PlayerLatencyPolicies"]?.map(x => fromPlayerLatencyPolicy(x)),
      Destinations: params["Destinations"]?.map(x => fromGameSessionQueueDestination(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueue": toGameSessionQueue,
      },
    }, await resp.json());
  }

  async updateMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateMatchmakingConfigurationInput,
  ): Promise<s.UpdateMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      GameSessionQueueArns: params["GameSessionQueueArns"],
      RequestTimeoutSeconds: params["RequestTimeoutSeconds"],
      AcceptanceTimeoutSeconds: params["AcceptanceTimeoutSeconds"],
      AcceptanceRequired: params["AcceptanceRequired"],
      RuleSetName: params["RuleSetName"],
      NotificationTarget: params["NotificationTarget"],
      AdditionalPlayerCount: params["AdditionalPlayerCount"],
      CustomEventData: params["CustomEventData"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      GameSessionData: params["GameSessionData"],
      BackfillMode: params["BackfillMode"],
      FlexMatchMode: params["FlexMatchMode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toMatchmakingConfiguration,
      },
    }, await resp.json());
  }

  async updateRuntimeConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateRuntimeConfigurationInput,
  ): Promise<s.UpdateRuntimeConfigurationOutput> {
    const body: jsonP.JSONObject = {
      FleetId: params["FleetId"],
      RuntimeConfiguration: fromRuntimeConfiguration(params["RuntimeConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuntimeConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuntimeConfiguration": toRuntimeConfiguration,
      },
    }, await resp.json());
  }

  async updateScript(
    {abortSignal, ...params}: RequestConfig & s.UpdateScriptInput,
  ): Promise<s.UpdateScriptOutput> {
    const body: jsonP.JSONObject = {
      ScriptId: params["ScriptId"],
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      ZipFile: serializeBlob(params["ZipFile"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async validateMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & s.ValidateMatchmakingRuleSetInput,
  ): Promise<s.ValidateMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = {
      RuleSetBody: params["RuleSetBody"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Valid": "b",
      },
    }, await resp.json());
  }

}

function fromRoutingStrategy(input?: s.RoutingStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    FleetId: input["FleetId"],
    Message: input["Message"],
  }
}
function toRoutingStrategy(root: jsonP.JSONValue): s.RoutingStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.RoutingStrategyType>(x),
      "FleetId": "s",
      "Message": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromS3Location(input?: s.S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
    RoleArn: input["RoleArn"],
    ObjectVersion: input["ObjectVersion"],
  }
}
function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "Key": "s",
      "RoleArn": "s",
      "ObjectVersion": "s",
    },
  }, root);
}

function fromIpPermission(input?: s.IpPermission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FromPort: input["FromPort"],
    ToPort: input["ToPort"],
    IpRange: input["IpRange"],
    Protocol: input["Protocol"],
  }
}
function toIpPermission(root: jsonP.JSONValue): s.IpPermission {
  return jsonP.readObj({
    required: {
      "FromPort": "n",
      "ToPort": "n",
      "IpRange": "s",
      "Protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpProtocol>(x),
    },
    optional: {},
  }, root);
}

function fromRuntimeConfiguration(input?: s.RuntimeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServerProcesses: input["ServerProcesses"]?.map(x => fromServerProcess(x)),
    MaxConcurrentGameSessionActivations: input["MaxConcurrentGameSessionActivations"],
    GameSessionActivationTimeoutSeconds: input["GameSessionActivationTimeoutSeconds"],
  }
}
function toRuntimeConfiguration(root: jsonP.JSONValue): s.RuntimeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServerProcesses": [toServerProcess],
      "MaxConcurrentGameSessionActivations": "n",
      "GameSessionActivationTimeoutSeconds": "n",
    },
  }, root);
}

function fromServerProcess(input?: s.ServerProcess | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LaunchPath: input["LaunchPath"],
    Parameters: input["Parameters"],
    ConcurrentExecutions: input["ConcurrentExecutions"],
  }
}
function toServerProcess(root: jsonP.JSONValue): s.ServerProcess {
  return jsonP.readObj({
    required: {
      "LaunchPath": "s",
      "ConcurrentExecutions": "n",
    },
    optional: {
      "Parameters": "s",
    },
  }, root);
}

function fromResourceCreationLimitPolicy(input?: s.ResourceCreationLimitPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NewGameSessionsPerCreator: input["NewGameSessionsPerCreator"],
    PolicyPeriodInMinutes: input["PolicyPeriodInMinutes"],
  }
}
function toResourceCreationLimitPolicy(root: jsonP.JSONValue): s.ResourceCreationLimitPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "NewGameSessionsPerCreator": "n",
      "PolicyPeriodInMinutes": "n",
    },
  }, root);
}

function fromCertificateConfiguration(input?: s.CertificateConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateType: input["CertificateType"],
  }
}
function toCertificateConfiguration(root: jsonP.JSONValue): s.CertificateConfiguration {
  return jsonP.readObj({
    required: {
      "CertificateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateType>(x),
    },
    optional: {},
  }, root);
}

function fromLaunchTemplateSpecification(input?: s.LaunchTemplateSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LaunchTemplateId: input["LaunchTemplateId"],
    LaunchTemplateName: input["LaunchTemplateName"],
    Version: input["Version"],
  }
}

function fromInstanceDefinition(input?: s.InstanceDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    WeightedCapacity: input["WeightedCapacity"],
  }
}
function toInstanceDefinition(root: jsonP.JSONValue): s.InstanceDefinition {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerGroupInstanceType>(x),
    },
    optional: {
      "WeightedCapacity": "s",
    },
  }, root);
}

function fromGameServerGroupAutoScalingPolicy(input?: s.GameServerGroupAutoScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EstimatedInstanceWarmup: input["EstimatedInstanceWarmup"],
    TargetTrackingConfiguration: fromTargetTrackingConfiguration(input["TargetTrackingConfiguration"]),
  }
}

function fromTargetTrackingConfiguration(input?: s.TargetTrackingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetValue: input["TargetValue"],
  }
}

function fromGameProperty(input?: s.GameProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toGameProperty(root: jsonP.JSONValue): s.GameProperty {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromPlayerLatencyPolicy(input?: s.PlayerLatencyPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumIndividualPlayerLatencyMilliseconds: input["MaximumIndividualPlayerLatencyMilliseconds"],
    PolicyDurationSeconds: input["PolicyDurationSeconds"],
  }
}
function toPlayerLatencyPolicy(root: jsonP.JSONValue): s.PlayerLatencyPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaximumIndividualPlayerLatencyMilliseconds": "n",
      "PolicyDurationSeconds": "n",
    },
  }, root);
}

function fromGameSessionQueueDestination(input?: s.GameSessionQueueDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DestinationArn: input["DestinationArn"],
  }
}
function toGameSessionQueueDestination(root: jsonP.JSONValue): s.GameSessionQueueDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationArn": "s",
    },
  }, root);
}

function fromTargetConfiguration(input?: s.TargetConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetValue: input["TargetValue"],
  }
}
function toTargetConfiguration(root: jsonP.JSONValue): s.TargetConfiguration {
  return jsonP.readObj({
    required: {
      "TargetValue": "n",
    },
    optional: {},
  }, root);
}

function fromPlayerLatency(input?: s.PlayerLatency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    RegionIdentifier: input["RegionIdentifier"],
    LatencyInMilliseconds: input["LatencyInMilliseconds"],
  }
}
function toPlayerLatency(root: jsonP.JSONValue): s.PlayerLatency {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "RegionIdentifier": "s",
      "LatencyInMilliseconds": "n",
    },
  }, root);
}

function fromDesiredPlayerSession(input?: s.DesiredPlayerSession | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    PlayerData: input["PlayerData"],
  }
}

function fromPlayer(input?: s.Player | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    PlayerAttributes: jsonP.serializeMap(input["PlayerAttributes"], x => fromAttributeValue(x)),
    Team: input["Team"],
    LatencyInMs: input["LatencyInMs"],
  }
}
function toPlayer(root: jsonP.JSONValue): s.Player {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerAttributes": x => jsonP.readMap(String, toAttributeValue, x),
      "Team": "s",
      "LatencyInMs": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function fromAttributeValue(input?: s.AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    SL: input["SL"],
    SDM: input["SDM"],
  }
}
function toAttributeValue(root: jsonP.JSONValue): s.AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "n",
      "SL": ["s"],
      "SDM": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toGameServer(root: jsonP.JSONValue): s.GameServer {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "GameServerId": "s",
      "InstanceId": "s",
      "ConnectionInfo": "s",
      "GameServerData": "s",
      "ClaimStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerClaimStatus>(x),
      "UtilizationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerUtilizationStatus>(x),
      "RegistrationTime": "d",
      "LastClaimTime": "d",
      "LastHealthCheckTime": "d",
    },
  }, root);
}

function toAlias(root: jsonP.JSONValue): s.Alias {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasId": "s",
      "Name": "s",
      "AliasArn": "s",
      "Description": "s",
      "RoutingStrategy": toRoutingStrategy,
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

function toBuild(root: jsonP.JSONValue): s.Build {
  return jsonP.readObj({
    required: {},
    optional: {
      "BuildId": "s",
      "BuildArn": "s",
      "Name": "s",
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.BuildStatus>(x),
      "SizeOnDisk": "n",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      "CreationTime": "d",
    },
  }, root);
}

function toAwsCredentials(root: jsonP.JSONValue): s.AwsCredentials {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessKeyId": "s",
      "SecretAccessKey": "s",
      "SessionToken": "s",
    },
  }, root);
}

function toFleetAttributes(root: jsonP.JSONValue): s.FleetAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "FleetArn": "s",
      "FleetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetType>(x),
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EC2InstanceType>(x),
      "Description": "s",
      "Name": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetStatus>(x),
      "BuildId": "s",
      "BuildArn": "s",
      "ScriptId": "s",
      "ScriptArn": "s",
      "ServerLaunchPath": "s",
      "ServerLaunchParameters": "s",
      "LogPaths": ["s"],
      "NewGameSessionProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtectionPolicy>(x),
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      "ResourceCreationLimitPolicy": toResourceCreationLimitPolicy,
      "MetricGroups": ["s"],
      "StoppedActions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FleetAction>(x)],
      "InstanceRoleArn": "s",
      "CertificateConfiguration": toCertificateConfiguration,
    },
  }, root);
}

function toGameServerGroup(root: jsonP.JSONValue): s.GameServerGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "RoleArn": "s",
      "InstanceDefinitions": [toInstanceDefinition],
      "BalancingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.BalancingStrategy>(x),
      "GameServerProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerProtectionPolicy>(x),
      "AutoScalingGroupArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerGroupStatus>(x),
      "StatusReason": "s",
      "SuspendedActions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerGroupAction>(x)],
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

function toGameSession(root: jsonP.JSONValue): s.GameSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSessionId": "s",
      "Name": "s",
      "FleetId": "s",
      "FleetArn": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "CurrentPlayerSessionCount": "n",
      "MaximumPlayerSessionCount": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameSessionStatus>(x),
      "StatusReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameSessionStatusReason>(x),
      "GameProperties": [toGameProperty],
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlayerSessionCreationPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlayerSessionCreationPolicy>(x),
      "CreatorId": "s",
      "GameSessionData": "s",
      "MatchmakerData": "s",
    },
  }, root);
}

function toGameSessionQueue(root: jsonP.JSONValue): s.GameSessionQueue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "GameSessionQueueArn": "s",
      "TimeoutInSeconds": "n",
      "PlayerLatencyPolicies": [toPlayerLatencyPolicy],
      "Destinations": [toGameSessionQueueDestination],
    },
  }, root);
}

function toMatchmakingConfiguration(root: jsonP.JSONValue): s.MatchmakingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ConfigurationArn": "s",
      "Description": "s",
      "GameSessionQueueArns": ["s"],
      "RequestTimeoutSeconds": "n",
      "AcceptanceTimeoutSeconds": "n",
      "AcceptanceRequired": "b",
      "RuleSetName": "s",
      "RuleSetArn": "s",
      "NotificationTarget": "s",
      "AdditionalPlayerCount": "n",
      "CustomEventData": "s",
      "CreationTime": "d",
      "GameProperties": [toGameProperty],
      "GameSessionData": "s",
      "BackfillMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackfillMode>(x),
      "FlexMatchMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FlexMatchMode>(x),
    },
  }, root);
}

function toMatchmakingRuleSet(root: jsonP.JSONValue): s.MatchmakingRuleSet {
  return jsonP.readObj({
    required: {
      "RuleSetBody": "s",
    },
    optional: {
      "RuleSetName": "s",
      "RuleSetArn": "s",
      "CreationTime": "d",
    },
  }, root);
}

function toPlayerSession(root: jsonP.JSONValue): s.PlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerSessionId": "s",
      "PlayerId": "s",
      "GameSessionId": "s",
      "FleetId": "s",
      "FleetArn": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlayerSessionStatus>(x),
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlayerData": "s",
    },
  }, root);
}

function toScript(root: jsonP.JSONValue): s.Script {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScriptId": "s",
      "ScriptArn": "s",
      "Name": "s",
      "Version": "s",
      "SizeOnDisk": "n",
      "CreationTime": "d",
      "StorageLocation": toS3Location,
    },
  }, root);
}

function toVpcPeeringAuthorization(root: jsonP.JSONValue): s.VpcPeeringAuthorization {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameLiftAwsAccountId": "s",
      "PeerVpcAwsAccountId": "s",
      "PeerVpcId": "s",
      "CreationTime": "d",
      "ExpirationTime": "d",
    },
  }, root);
}

function toEC2InstanceLimit(root: jsonP.JSONValue): s.EC2InstanceLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EC2InstanceType>(x),
      "CurrentInstances": "n",
      "InstanceLimit": "n",
    },
  }, root);
}

function toFleetCapacity(root: jsonP.JSONValue): s.FleetCapacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EC2InstanceType>(x),
      "InstanceCounts": toEC2InstanceCounts,
    },
  }, root);
}

function toEC2InstanceCounts(root: jsonP.JSONValue): s.EC2InstanceCounts {
  return jsonP.readObj({
    required: {},
    optional: {
      "DESIRED": "n",
      "MINIMUM": "n",
      "MAXIMUM": "n",
      "PENDING": "n",
      "ACTIVE": "n",
      "IDLE": "n",
      "TERMINATING": "n",
    },
  }, root);
}

function toEvent(root: jsonP.JSONValue): s.Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventId": "s",
      "ResourceId": "s",
      "EventCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventCode>(x),
      "Message": "s",
      "EventTime": "d",
      "PreSignedLogUrl": "s",
    },
  }, root);
}

function toFleetUtilization(root: jsonP.JSONValue): s.FleetUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "ActiveServerProcessCount": "n",
      "ActiveGameSessionCount": "n",
      "CurrentPlayerSessionCount": "n",
      "MaximumPlayerSessionCount": "n",
    },
  }, root);
}

function toGameServerInstance(root: jsonP.JSONValue): s.GameServerInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "InstanceId": "s",
      "InstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameServerInstanceStatus>(x),
    },
  }, root);
}

function toGameSessionDetail(root: jsonP.JSONValue): s.GameSessionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSession": toGameSession,
      "ProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtectionPolicy>(x),
    },
  }, root);
}

function toGameSessionPlacement(root: jsonP.JSONValue): s.GameSessionPlacement {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlacementId": "s",
      "GameSessionQueueName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.GameSessionPlacementState>(x),
      "GameProperties": [toGameProperty],
      "MaximumPlayerSessionCount": "n",
      "GameSessionName": "s",
      "GameSessionId": "s",
      "GameSessionArn": "s",
      "GameSessionRegion": "s",
      "PlayerLatencies": [toPlayerLatency],
      "StartTime": "d",
      "EndTime": "d",
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlacedPlayerSessions": [toPlacedPlayerSession],
      "GameSessionData": "s",
      "MatchmakerData": "s",
    },
  }, root);
}

function toPlacedPlayerSession(root: jsonP.JSONValue): s.PlacedPlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerSessionId": "s",
    },
  }, root);
}

function toInstance(root: jsonP.JSONValue): s.Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceId": "s",
      "IpAddress": "s",
      "DnsName": "s",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EC2InstanceType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceStatus>(x),
      "CreationTime": "d",
    },
  }, root);
}

function toMatchmakingTicket(root: jsonP.JSONValue): s.MatchmakingTicket {
  return jsonP.readObj({
    required: {},
    optional: {
      "TicketId": "s",
      "ConfigurationName": "s",
      "ConfigurationArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MatchmakingConfigurationStatus>(x),
      "StatusReason": "s",
      "StatusMessage": "s",
      "StartTime": "d",
      "EndTime": "d",
      "Players": [toPlayer],
      "GameSessionConnectionInfo": toGameSessionConnectionInfo,
      "EstimatedWaitTime": "n",
    },
  }, root);
}

function toGameSessionConnectionInfo(root: jsonP.JSONValue): s.GameSessionConnectionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSessionArn": "s",
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "MatchedPlayerSessions": [toMatchedPlayerSession],
    },
  }, root);
}

function toMatchedPlayerSession(root: jsonP.JSONValue): s.MatchedPlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerSessionId": "s",
    },
  }, root);
}

function toScalingPolicy(root: jsonP.JSONValue): s.ScalingPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalingStatusType>(x),
      "ScalingAdjustment": "n",
      "ScalingAdjustmentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalingAdjustmentType>(x),
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperatorType>(x),
      "Threshold": "n",
      "EvaluationPeriods": "n",
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricName>(x),
      "PolicyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PolicyType>(x),
      "TargetConfiguration": toTargetConfiguration,
    },
  }, root);
}

function toVpcPeeringConnection(root: jsonP.JSONValue): s.VpcPeeringConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "FleetArn": "s",
      "IpV4CidrBlock": "s",
      "VpcPeeringConnectionId": "s",
      "Status": toVpcPeeringConnectionStatus,
      "PeerVpcId": "s",
      "GameLiftVpcId": "s",
    },
  }, root);
}

function toVpcPeeringConnectionStatus(root: jsonP.JSONValue): s.VpcPeeringConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

function toInstanceAccess(root: jsonP.JSONValue): s.InstanceAccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceId": "s",
      "IpAddress": "s",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      "Credentials": toInstanceCredentials,
    },
  }, root);
}

function toInstanceCredentials(root: jsonP.JSONValue): s.InstanceCredentials {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserName": "s",
      "Secret": "s",
    },
  }, root);
}
