// Autogenerated API client for: Amazon GameLift

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class GameLift {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(GameLift.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-10-01",
    "endpointPrefix": "gamelift",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon GameLift",
    "serviceId": "GameLift",
    "signatureVersion": "v4",
    "targetPrefix": "GameLift",
    "uid": "gamelift-2015-10-01"
  };

  async acceptMatch(
    {abortSignal, ...params}: RequestConfig & AcceptMatchInput,
  ): Promise<AcceptMatchOutput> {
    const body: jsonP.JSONObject = params ? {
      TicketId: params["TicketId"],
      PlayerIds: params["PlayerIds"],
      AcceptanceType: params["AcceptanceType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptMatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async claimGameServer(
    {abortSignal, ...params}: RequestConfig & ClaimGameServerInput,
  ): Promise<ClaimGameServerOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      GameServerData: params["GameServerData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ClaimGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & CreateAliasInput,
  ): Promise<CreateAliasOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Description: params["Description"],
      RoutingStrategy: fromRoutingStrategy(params["RoutingStrategy"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async createBuild(
    {abortSignal, ...params}: RequestConfig & CreateBuildInput = {},
  ): Promise<CreateBuildOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      OperatingSystem: params["OperatingSystem"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
        "UploadCredentials": toAwsCredentials,
        "StorageLocation": toS3Location,
      },
    }, await resp.json());
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & CreateFleetInput,
  ): Promise<CreateFleetOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Description: params["Description"],
      BuildId: params["BuildId"],
      ScriptId: params["ScriptId"],
      ServerLaunchPath: params["ServerLaunchPath"],
      ServerLaunchParameters: params["ServerLaunchParameters"],
      LogPaths: params["LogPaths"],
      EC2InstanceType: params["EC2InstanceType"],
      EC2InboundPermissions: params["EC2InboundPermissions"]?.map(x => fromIpPermission(x)),
      NewGameSessionProtectionPolicy: params["NewGameSessionProtectionPolicy"],
      RuntimeConfiguration: fromRuntimeConfiguration(params["RuntimeConfiguration"]),
      ResourceCreationLimitPolicy: fromResourceCreationLimitPolicy(params["ResourceCreationLimitPolicy"]),
      MetricGroups: params["MetricGroups"],
      PeerVpcAwsAccountId: params["PeerVpcAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
      FleetType: params["FleetType"],
      InstanceRoleArn: params["InstanceRoleArn"],
      CertificateConfiguration: fromCertificateConfiguration(params["CertificateConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetAttributes": toFleetAttributes,
      },
    }, await resp.json());
  }

  async createGameServerGroup(
    {abortSignal, ...params}: RequestConfig & CreateGameServerGroupInput,
  ): Promise<CreateGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      RoleArn: params["RoleArn"],
      MinSize: params["MinSize"],
      MaxSize: params["MaxSize"],
      LaunchTemplate: fromLaunchTemplateSpecification(params["LaunchTemplate"]),
      InstanceDefinitions: params["InstanceDefinitions"]?.map(x => fromInstanceDefinition(x)),
      AutoScalingPolicy: fromGameServerGroupAutoScalingPolicy(params["AutoScalingPolicy"]),
      BalancingStrategy: params["BalancingStrategy"],
      GameServerProtectionPolicy: params["GameServerProtectionPolicy"],
      VpcSubnets: params["VpcSubnets"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async createGameSession(
    {abortSignal, ...params}: RequestConfig & CreateGameSessionInput,
  ): Promise<CreateGameSessionOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      AliasId: params["AliasId"],
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      Name: params["Name"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      CreatorId: params["CreatorId"],
      GameSessionId: params["GameSessionId"],
      IdempotencyToken: params["IdempotencyToken"],
      GameSessionData: params["GameSessionData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSession": toGameSession,
      },
    }, await resp.json());
  }

  async createGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & CreateGameSessionQueueInput,
  ): Promise<CreateGameSessionQueueOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      PlayerLatencyPolicies: params["PlayerLatencyPolicies"]?.map(x => fromPlayerLatencyPolicy(x)),
      Destinations: params["Destinations"]?.map(x => fromGameSessionQueueDestination(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueue": toGameSessionQueue,
      },
    }, await resp.json());
  }

  async createMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateMatchmakingConfigurationInput,
  ): Promise<CreateMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Description: params["Description"],
      GameSessionQueueArns: params["GameSessionQueueArns"],
      RequestTimeoutSeconds: params["RequestTimeoutSeconds"],
      AcceptanceTimeoutSeconds: params["AcceptanceTimeoutSeconds"],
      AcceptanceRequired: params["AcceptanceRequired"],
      RuleSetName: params["RuleSetName"],
      NotificationTarget: params["NotificationTarget"],
      AdditionalPlayerCount: params["AdditionalPlayerCount"],
      CustomEventData: params["CustomEventData"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      GameSessionData: params["GameSessionData"],
      BackfillMode: params["BackfillMode"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toMatchmakingConfiguration,
      },
    }, await resp.json());
  }

  async createMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & CreateMatchmakingRuleSetInput,
  ): Promise<CreateMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      RuleSetBody: params["RuleSetBody"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {
        "RuleSet": toMatchmakingRuleSet,
      },
      optional: {},
    }, await resp.json());
  }

  async createPlayerSession(
    {abortSignal, ...params}: RequestConfig & CreatePlayerSessionInput,
  ): Promise<CreatePlayerSessionOutput> {
    const body: jsonP.JSONObject = params ? {
      GameSessionId: params["GameSessionId"],
      PlayerId: params["PlayerId"],
      PlayerData: params["PlayerData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlayerSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSession": toPlayerSession,
      },
    }, await resp.json());
  }

  async createPlayerSessions(
    {abortSignal, ...params}: RequestConfig & CreatePlayerSessionsInput,
  ): Promise<CreatePlayerSessionsOutput> {
    const body: jsonP.JSONObject = params ? {
      GameSessionId: params["GameSessionId"],
      PlayerIds: params["PlayerIds"],
      PlayerDataMap: params["PlayerDataMap"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlayerSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSessions": [toPlayerSession],
      },
    }, await resp.json());
  }

  async createScript(
    {abortSignal, ...params}: RequestConfig & CreateScriptInput = {},
  ): Promise<CreateScriptOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      ZipFile: jsonP.serializeBlob(params["ZipFile"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async createVpcPeeringAuthorization(
    {abortSignal, ...params}: RequestConfig & CreateVpcPeeringAuthorizationInput,
  ): Promise<CreateVpcPeeringAuthorizationOutput> {
    const body: jsonP.JSONObject = params ? {
      GameLiftAwsAccountId: params["GameLiftAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringAuthorization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringAuthorization": toVpcPeeringAuthorization,
      },
    }, await resp.json());
  }

  async createVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & CreateVpcPeeringConnectionInput,
  ): Promise<CreateVpcPeeringConnectionOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      PeerVpcAwsAccountId: params["PeerVpcAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAlias(
    {abortSignal, ...params}: RequestConfig & DeleteAliasInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      AliasId: params["AliasId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlias",
    });
  }

  async deleteBuild(
    {abortSignal, ...params}: RequestConfig & DeleteBuildInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      BuildId: params["BuildId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBuild",
    });
  }

  async deleteFleet(
    {abortSignal, ...params}: RequestConfig & DeleteFleetInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleet",
    });
  }

  async deleteGameServerGroup(
    {abortSignal, ...params}: RequestConfig & DeleteGameServerGroupInput,
  ): Promise<DeleteGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      DeleteOption: params["DeleteOption"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async deleteGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & DeleteGameSessionQueueInput,
  ): Promise<DeleteGameSessionQueueOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteMatchmakingConfigurationInput,
  ): Promise<DeleteMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & DeleteMatchmakingRuleSetInput,
  ): Promise<DeleteMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteScalingPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteScalingPolicyInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      FleetId: params["FleetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScalingPolicy",
    });
  }

  async deleteScript(
    {abortSignal, ...params}: RequestConfig & DeleteScriptInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ScriptId: params["ScriptId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteScript",
    });
  }

  async deleteVpcPeeringAuthorization(
    {abortSignal, ...params}: RequestConfig & DeleteVpcPeeringAuthorizationInput,
  ): Promise<DeleteVpcPeeringAuthorizationOutput> {
    const body: jsonP.JSONObject = params ? {
      GameLiftAwsAccountId: params["GameLiftAwsAccountId"],
      PeerVpcId: params["PeerVpcId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringAuthorization",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & DeleteVpcPeeringConnectionInput,
  ): Promise<DeleteVpcPeeringConnectionOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      VpcPeeringConnectionId: params["VpcPeeringConnectionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterGameServer(
    {abortSignal, ...params}: RequestConfig & DeregisterGameServerInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterGameServer",
    });
  }

  async describeAlias(
    {abortSignal, ...params}: RequestConfig & DescribeAliasInput,
  ): Promise<DescribeAliasOutput> {
    const body: jsonP.JSONObject = params ? {
      AliasId: params["AliasId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async describeBuild(
    {abortSignal, ...params}: RequestConfig & DescribeBuildInput,
  ): Promise<DescribeBuildOutput> {
    const body: jsonP.JSONObject = params ? {
      BuildId: params["BuildId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
      },
    }, await resp.json());
  }

  async describeEC2InstanceLimits(
    {abortSignal, ...params}: RequestConfig & DescribeEC2InstanceLimitsInput = {},
  ): Promise<DescribeEC2InstanceLimitsOutput> {
    const body: jsonP.JSONObject = params ? {
      EC2InstanceType: params["EC2InstanceType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEC2InstanceLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EC2InstanceLimits": [toEC2InstanceLimit],
      },
    }, await resp.json());
  }

  async describeFleetAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeFleetAttributesInput = {},
  ): Promise<DescribeFleetAttributesOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetAttributes": [toFleetAttributes],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetCapacity(
    {abortSignal, ...params}: RequestConfig & DescribeFleetCapacityInput = {},
  ): Promise<DescribeFleetCapacityOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetCapacity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetCapacity": [toFleetCapacity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetEvents(
    {abortSignal, ...params}: RequestConfig & DescribeFleetEventsInput,
  ): Promise<DescribeFleetEventsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Events": [toEvent],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleetPortSettings(
    {abortSignal, ...params}: RequestConfig & DescribeFleetPortSettingsInput,
  ): Promise<DescribeFleetPortSettingsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetPortSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InboundPermissions": [toIpPermission],
      },
    }, await resp.json());
  }

  async describeFleetUtilization(
    {abortSignal, ...params}: RequestConfig & DescribeFleetUtilizationInput = {},
  ): Promise<DescribeFleetUtilizationOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetIds: params["FleetIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetUtilization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetUtilization": [toFleetUtilization],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameServer(
    {abortSignal, ...params}: RequestConfig & DescribeGameServerInput,
  ): Promise<DescribeGameServerOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async describeGameServerGroup(
    {abortSignal, ...params}: RequestConfig & DescribeGameServerGroupInput,
  ): Promise<DescribeGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async describeGameServerInstances(
    {abortSignal, ...params}: RequestConfig & DescribeGameServerInstancesInput,
  ): Promise<DescribeGameServerInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      InstanceIds: params["InstanceIds"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameServerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerInstances": [toGameServerInstance],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessionDetails(
    {abortSignal, ...params}: RequestConfig & DescribeGameSessionDetailsInput = {},
  ): Promise<DescribeGameSessionDetailsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      GameSessionId: params["GameSessionId"],
      AliasId: params["AliasId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionDetails": [toGameSessionDetail],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & DescribeGameSessionPlacementInput,
  ): Promise<DescribeGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = params ? {
      PlacementId: params["PlacementId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async describeGameSessionQueues(
    {abortSignal, ...params}: RequestConfig & DescribeGameSessionQueuesInput = {},
  ): Promise<DescribeGameSessionQueuesOutput> {
    const body: jsonP.JSONObject = params ? {
      Names: params["Names"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessionQueues",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueues": [toGameSessionQueue],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeGameSessions(
    {abortSignal, ...params}: RequestConfig & DescribeGameSessionsInput = {},
  ): Promise<DescribeGameSessionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      GameSessionId: params["GameSessionId"],
      AliasId: params["AliasId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGameSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessions": [toGameSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & DescribeInstancesInput,
  ): Promise<DescribeInstancesOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      InstanceId: params["InstanceId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMatchmaking(
    {abortSignal, ...params}: RequestConfig & DescribeMatchmakingInput,
  ): Promise<DescribeMatchmakingOutput> {
    const body: jsonP.JSONObject = params ? {
      TicketIds: params["TicketIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TicketList": [toMatchmakingTicket],
      },
    }, await resp.json());
  }

  async describeMatchmakingConfigurations(
    {abortSignal, ...params}: RequestConfig & DescribeMatchmakingConfigurationsInput = {},
  ): Promise<DescribeMatchmakingConfigurationsOutput> {
    const body: jsonP.JSONObject = params ? {
      Names: params["Names"],
      RuleSetName: params["RuleSetName"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmakingConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configurations": [toMatchmakingConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMatchmakingRuleSets(
    {abortSignal, ...params}: RequestConfig & DescribeMatchmakingRuleSetsInput = {},
  ): Promise<DescribeMatchmakingRuleSetsOutput> {
    const body: jsonP.JSONObject = params ? {
      Names: params["Names"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMatchmakingRuleSets",
    });
    return jsonP.readObj({
      required: {
        "RuleSets": [toMatchmakingRuleSet],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePlayerSessions(
    {abortSignal, ...params}: RequestConfig & DescribePlayerSessionsInput = {},
  ): Promise<DescribePlayerSessionsOutput> {
    const body: jsonP.JSONObject = params ? {
      GameSessionId: params["GameSessionId"],
      PlayerId: params["PlayerId"],
      PlayerSessionId: params["PlayerSessionId"],
      PlayerSessionStatusFilter: params["PlayerSessionStatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePlayerSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PlayerSessions": [toPlayerSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeRuntimeConfiguration(
    {abortSignal, ...params}: RequestConfig & DescribeRuntimeConfigurationInput,
  ): Promise<DescribeRuntimeConfigurationOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRuntimeConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuntimeConfiguration": toRuntimeConfiguration,
      },
    }, await resp.json());
  }

  async describeScalingPolicies(
    {abortSignal, ...params}: RequestConfig & DescribeScalingPoliciesInput,
  ): Promise<DescribeScalingPoliciesOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      StatusFilter: params["StatusFilter"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ScalingPolicies": [toScalingPolicy],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeScript(
    {abortSignal, ...params}: RequestConfig & DescribeScriptInput,
  ): Promise<DescribeScriptOutput> {
    const body: jsonP.JSONObject = params ? {
      ScriptId: params["ScriptId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async describeVpcPeeringAuthorizations(
    {abortSignal, ...params}: RequestConfig & DescribeVpcPeeringAuthorizationsInput = {},
  ): Promise<DescribeVpcPeeringAuthorizationsOutput> {
    const body: jsonP.JSONObject = params ? {
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringAuthorizations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringAuthorizations": [toVpcPeeringAuthorization],
      },
    }, await resp.json());
  }

  async describeVpcPeeringConnections(
    {abortSignal, ...params}: RequestConfig & DescribeVpcPeeringConnectionsInput = {},
  ): Promise<DescribeVpcPeeringConnectionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "VpcPeeringConnections": [toVpcPeeringConnection],
      },
    }, await resp.json());
  }

  async getGameSessionLogUrl(
    {abortSignal, ...params}: RequestConfig & GetGameSessionLogUrlInput,
  ): Promise<GetGameSessionLogUrlOutput> {
    const body: jsonP.JSONObject = params ? {
      GameSessionId: params["GameSessionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGameSessionLogUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PreSignedUrl": "s",
      },
    }, await resp.json());
  }

  async getInstanceAccess(
    {abortSignal, ...params}: RequestConfig & GetInstanceAccessInput,
  ): Promise<GetInstanceAccessOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      InstanceId: params["InstanceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceAccess",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceAccess": toInstanceAccess,
      },
    }, await resp.json());
  }

  async listAliases(
    {abortSignal, ...params}: RequestConfig & ListAliasesInput = {},
  ): Promise<ListAliasesOutput> {
    const body: jsonP.JSONObject = params ? {
      RoutingStrategyType: params["RoutingStrategyType"],
      Name: params["Name"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Aliases": [toAlias],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listBuilds(
    {abortSignal, ...params}: RequestConfig & ListBuildsInput = {},
  ): Promise<ListBuildsOutput> {
    const body: jsonP.JSONObject = params ? {
      Status: params["Status"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Builds": [toBuild],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFleets(
    {abortSignal, ...params}: RequestConfig & ListFleetsInput = {},
  ): Promise<ListFleetsOutput> {
    const body: jsonP.JSONObject = params ? {
      BuildId: params["BuildId"],
      ScriptId: params["ScriptId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetIds": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGameServerGroups(
    {abortSignal, ...params}: RequestConfig & ListGameServerGroupsInput = {},
  ): Promise<ListGameServerGroupsOutput> {
    const body: jsonP.JSONObject = params ? {
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGameServerGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroups": [toGameServerGroup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGameServers(
    {abortSignal, ...params}: RequestConfig & ListGameServersInput,
  ): Promise<ListGameServersOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      SortOrder: params["SortOrder"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGameServers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServers": [toGameServer],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listScripts(
    {abortSignal, ...params}: RequestConfig & ListScriptsInput = {},
  ): Promise<ListScriptsOutput> {
    const body: jsonP.JSONObject = params ? {
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListScripts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Scripts": [toScript],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async putScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutScalingPolicyInput,
  ): Promise<PutScalingPolicyOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      FleetId: params["FleetId"],
      ScalingAdjustment: params["ScalingAdjustment"],
      ScalingAdjustmentType: params["ScalingAdjustmentType"],
      Threshold: params["Threshold"],
      ComparisonOperator: params["ComparisonOperator"],
      EvaluationPeriods: params["EvaluationPeriods"],
      MetricName: params["MetricName"],
      PolicyType: params["PolicyType"],
      TargetConfiguration: fromTargetConfiguration(params["TargetConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async registerGameServer(
    {abortSignal, ...params}: RequestConfig & RegisterGameServerInput,
  ): Promise<RegisterGameServerOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      InstanceId: params["InstanceId"],
      ConnectionInfo: params["ConnectionInfo"],
      GameServerData: params["GameServerData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async requestUploadCredentials(
    {abortSignal, ...params}: RequestConfig & RequestUploadCredentialsInput,
  ): Promise<RequestUploadCredentialsOutput> {
    const body: jsonP.JSONObject = params ? {
      BuildId: params["BuildId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestUploadCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UploadCredentials": toAwsCredentials,
        "StorageLocation": toS3Location,
      },
    }, await resp.json());
  }

  async resolveAlias(
    {abortSignal, ...params}: RequestConfig & ResolveAliasInput,
  ): Promise<ResolveAliasOutput> {
    const body: jsonP.JSONObject = params ? {
      AliasId: params["AliasId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResolveAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
        "FleetArn": "s",
      },
    }, await resp.json());
  }

  async resumeGameServerGroup(
    {abortSignal, ...params}: RequestConfig & ResumeGameServerGroupInput,
  ): Promise<ResumeGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      ResumeActions: params["ResumeActions"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async searchGameSessions(
    {abortSignal, ...params}: RequestConfig & SearchGameSessionsInput = {},
  ): Promise<SearchGameSessionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      AliasId: params["AliasId"],
      FilterExpression: params["FilterExpression"],
      SortExpression: params["SortExpression"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchGameSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessions": [toGameSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startFleetActions(
    {abortSignal, ...params}: RequestConfig & StartFleetActionsInput,
  ): Promise<StartFleetActionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      Actions: params["Actions"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartFleetActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & StartGameSessionPlacementInput,
  ): Promise<StartGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = params ? {
      PlacementId: params["PlacementId"],
      GameSessionQueueName: params["GameSessionQueueName"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      GameSessionName: params["GameSessionName"],
      PlayerLatencies: params["PlayerLatencies"]?.map(x => fromPlayerLatency(x)),
      DesiredPlayerSessions: params["DesiredPlayerSessions"]?.map(x => fromDesiredPlayerSession(x)),
      GameSessionData: params["GameSessionData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async startMatchBackfill(
    {abortSignal, ...params}: RequestConfig & StartMatchBackfillInput,
  ): Promise<StartMatchBackfillOutput> {
    const body: jsonP.JSONObject = params ? {
      TicketId: params["TicketId"],
      ConfigurationName: params["ConfigurationName"],
      GameSessionArn: params["GameSessionArn"],
      Players: params["Players"]?.map(x => fromPlayer(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMatchBackfill",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MatchmakingTicket": toMatchmakingTicket,
      },
    }, await resp.json());
  }

  async startMatchmaking(
    {abortSignal, ...params}: RequestConfig & StartMatchmakingInput,
  ): Promise<StartMatchmakingOutput> {
    const body: jsonP.JSONObject = params ? {
      TicketId: params["TicketId"],
      ConfigurationName: params["ConfigurationName"],
      Players: params["Players"]?.map(x => fromPlayer(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MatchmakingTicket": toMatchmakingTicket,
      },
    }, await resp.json());
  }

  async stopFleetActions(
    {abortSignal, ...params}: RequestConfig & StopFleetActionsInput,
  ): Promise<StopFleetActionsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      Actions: params["Actions"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopFleetActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopGameSessionPlacement(
    {abortSignal, ...params}: RequestConfig & StopGameSessionPlacementInput,
  ): Promise<StopGameSessionPlacementOutput> {
    const body: jsonP.JSONObject = params ? {
      PlacementId: params["PlacementId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopGameSessionPlacement",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionPlacement": toGameSessionPlacement,
      },
    }, await resp.json());
  }

  async stopMatchmaking(
    {abortSignal, ...params}: RequestConfig & StopMatchmakingInput,
  ): Promise<StopMatchmakingOutput> {
    const body: jsonP.JSONObject = params ? {
      TicketId: params["TicketId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopMatchmaking",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async suspendGameServerGroup(
    {abortSignal, ...params}: RequestConfig & SuspendGameServerGroupInput,
  ): Promise<SuspendGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      SuspendActions: params["SuspendActions"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SuspendGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAlias(
    {abortSignal, ...params}: RequestConfig & UpdateAliasInput,
  ): Promise<UpdateAliasOutput> {
    const body: jsonP.JSONObject = params ? {
      AliasId: params["AliasId"],
      Name: params["Name"],
      Description: params["Description"],
      RoutingStrategy: fromRoutingStrategy(params["RoutingStrategy"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Alias": toAlias,
      },
    }, await resp.json());
  }

  async updateBuild(
    {abortSignal, ...params}: RequestConfig & UpdateBuildInput,
  ): Promise<UpdateBuildOutput> {
    const body: jsonP.JSONObject = params ? {
      BuildId: params["BuildId"],
      Name: params["Name"],
      Version: params["Version"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Build": toBuild,
      },
    }, await resp.json());
  }

  async updateFleetAttributes(
    {abortSignal, ...params}: RequestConfig & UpdateFleetAttributesInput,
  ): Promise<UpdateFleetAttributesOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      Name: params["Name"],
      Description: params["Description"],
      NewGameSessionProtectionPolicy: params["NewGameSessionProtectionPolicy"],
      ResourceCreationLimitPolicy: fromResourceCreationLimitPolicy(params["ResourceCreationLimitPolicy"]),
      MetricGroups: params["MetricGroups"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateFleetCapacity(
    {abortSignal, ...params}: RequestConfig & UpdateFleetCapacityInput,
  ): Promise<UpdateFleetCapacityOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      DesiredInstances: params["DesiredInstances"],
      MinSize: params["MinSize"],
      MaxSize: params["MaxSize"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetCapacity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateFleetPortSettings(
    {abortSignal, ...params}: RequestConfig & UpdateFleetPortSettingsInput,
  ): Promise<UpdateFleetPortSettingsOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      InboundPermissionAuthorizations: params["InboundPermissionAuthorizations"]?.map(x => fromIpPermission(x)),
      InboundPermissionRevocations: params["InboundPermissionRevocations"]?.map(x => fromIpPermission(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleetPortSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FleetId": "s",
      },
    }, await resp.json());
  }

  async updateGameServer(
    {abortSignal, ...params}: RequestConfig & UpdateGameServerInput,
  ): Promise<UpdateGameServerOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      GameServerId: params["GameServerId"],
      GameServerData: params["GameServerData"],
      UtilizationStatus: params["UtilizationStatus"],
      HealthCheck: params["HealthCheck"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameServer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServer": toGameServer,
      },
    }, await resp.json());
  }

  async updateGameServerGroup(
    {abortSignal, ...params}: RequestConfig & UpdateGameServerGroupInput,
  ): Promise<UpdateGameServerGroupOutput> {
    const body: jsonP.JSONObject = params ? {
      GameServerGroupName: params["GameServerGroupName"],
      RoleArn: params["RoleArn"],
      InstanceDefinitions: params["InstanceDefinitions"]?.map(x => fromInstanceDefinition(x)),
      GameServerProtectionPolicy: params["GameServerProtectionPolicy"],
      BalancingStrategy: params["BalancingStrategy"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameServerGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameServerGroup": toGameServerGroup,
      },
    }, await resp.json());
  }

  async updateGameSession(
    {abortSignal, ...params}: RequestConfig & UpdateGameSessionInput,
  ): Promise<UpdateGameSessionOutput> {
    const body: jsonP.JSONObject = params ? {
      GameSessionId: params["GameSessionId"],
      MaximumPlayerSessionCount: params["MaximumPlayerSessionCount"],
      Name: params["Name"],
      PlayerSessionCreationPolicy: params["PlayerSessionCreationPolicy"],
      ProtectionPolicy: params["ProtectionPolicy"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSession": toGameSession,
      },
    }, await resp.json());
  }

  async updateGameSessionQueue(
    {abortSignal, ...params}: RequestConfig & UpdateGameSessionQueueInput,
  ): Promise<UpdateGameSessionQueueOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      TimeoutInSeconds: params["TimeoutInSeconds"],
      PlayerLatencyPolicies: params["PlayerLatencyPolicies"]?.map(x => fromPlayerLatencyPolicy(x)),
      Destinations: params["Destinations"]?.map(x => fromGameSessionQueueDestination(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGameSessionQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GameSessionQueue": toGameSessionQueue,
      },
    }, await resp.json());
  }

  async updateMatchmakingConfiguration(
    {abortSignal, ...params}: RequestConfig & UpdateMatchmakingConfigurationInput,
  ): Promise<UpdateMatchmakingConfigurationOutput> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Description: params["Description"],
      GameSessionQueueArns: params["GameSessionQueueArns"],
      RequestTimeoutSeconds: params["RequestTimeoutSeconds"],
      AcceptanceTimeoutSeconds: params["AcceptanceTimeoutSeconds"],
      AcceptanceRequired: params["AcceptanceRequired"],
      RuleSetName: params["RuleSetName"],
      NotificationTarget: params["NotificationTarget"],
      AdditionalPlayerCount: params["AdditionalPlayerCount"],
      CustomEventData: params["CustomEventData"],
      GameProperties: params["GameProperties"]?.map(x => fromGameProperty(x)),
      GameSessionData: params["GameSessionData"],
      BackfillMode: params["BackfillMode"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMatchmakingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toMatchmakingConfiguration,
      },
    }, await resp.json());
  }

  async updateRuntimeConfiguration(
    {abortSignal, ...params}: RequestConfig & UpdateRuntimeConfigurationInput,
  ): Promise<UpdateRuntimeConfigurationOutput> {
    const body: jsonP.JSONObject = params ? {
      FleetId: params["FleetId"],
      RuntimeConfiguration: fromRuntimeConfiguration(params["RuntimeConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuntimeConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuntimeConfiguration": toRuntimeConfiguration,
      },
    }, await resp.json());
  }

  async updateScript(
    {abortSignal, ...params}: RequestConfig & UpdateScriptInput,
  ): Promise<UpdateScriptOutput> {
    const body: jsonP.JSONObject = params ? {
      ScriptId: params["ScriptId"],
      Name: params["Name"],
      Version: params["Version"],
      StorageLocation: fromS3Location(params["StorageLocation"]),
      ZipFile: jsonP.serializeBlob(params["ZipFile"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Script": toScript,
      },
    }, await resp.json());
  }

  async validateMatchmakingRuleSet(
    {abortSignal, ...params}: RequestConfig & ValidateMatchmakingRuleSetInput,
  ): Promise<ValidateMatchmakingRuleSetOutput> {
    const body: jsonP.JSONObject = params ? {
      RuleSetBody: params["RuleSetBody"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateMatchmakingRuleSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Valid": "b",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AcceptMatchInput {
  TicketId: string;
  PlayerIds: string[];
  AcceptanceType: AcceptanceType;
}

// refs: 1 - tags: named, input
export interface ClaimGameServerInput {
  GameServerGroupName: string;
  GameServerId?: string | null;
  GameServerData?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateAliasInput {
  Name: string;
  Description?: string | null;
  RoutingStrategy: RoutingStrategy;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateBuildInput {
  Name?: string | null;
  Version?: string | null;
  StorageLocation?: S3Location | null;
  OperatingSystem?: OperatingSystem | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFleetInput {
  Name: string;
  Description?: string | null;
  BuildId?: string | null;
  ScriptId?: string | null;
  ServerLaunchPath?: string | null;
  ServerLaunchParameters?: string | null;
  LogPaths?: string[] | null;
  EC2InstanceType: EC2InstanceType;
  EC2InboundPermissions?: IpPermission[] | null;
  NewGameSessionProtectionPolicy?: ProtectionPolicy | null;
  RuntimeConfiguration?: RuntimeConfiguration | null;
  ResourceCreationLimitPolicy?: ResourceCreationLimitPolicy | null;
  MetricGroups?: string[] | null;
  PeerVpcAwsAccountId?: string | null;
  PeerVpcId?: string | null;
  FleetType?: FleetType | null;
  InstanceRoleArn?: string | null;
  CertificateConfiguration?: CertificateConfiguration | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateGameServerGroupInput {
  GameServerGroupName: string;
  RoleArn: string;
  MinSize: number;
  MaxSize: number;
  LaunchTemplate: LaunchTemplateSpecification;
  InstanceDefinitions: InstanceDefinition[];
  AutoScalingPolicy?: GameServerGroupAutoScalingPolicy | null;
  BalancingStrategy?: BalancingStrategy | null;
  GameServerProtectionPolicy?: GameServerProtectionPolicy | null;
  VpcSubnets?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateGameSessionInput {
  FleetId?: string | null;
  AliasId?: string | null;
  MaximumPlayerSessionCount: number;
  Name?: string | null;
  GameProperties?: GameProperty[] | null;
  CreatorId?: string | null;
  GameSessionId?: string | null;
  IdempotencyToken?: string | null;
  GameSessionData?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateGameSessionQueueInput {
  Name: string;
  TimeoutInSeconds?: number | null;
  PlayerLatencyPolicies?: PlayerLatencyPolicy[] | null;
  Destinations?: GameSessionQueueDestination[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateMatchmakingConfigurationInput {
  Name: string;
  Description?: string | null;
  GameSessionQueueArns: string[];
  RequestTimeoutSeconds: number;
  AcceptanceTimeoutSeconds?: number | null;
  AcceptanceRequired: boolean;
  RuleSetName: string;
  NotificationTarget?: string | null;
  AdditionalPlayerCount?: number | null;
  CustomEventData?: string | null;
  GameProperties?: GameProperty[] | null;
  GameSessionData?: string | null;
  BackfillMode?: BackfillMode | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateMatchmakingRuleSetInput {
  Name: string;
  RuleSetBody: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePlayerSessionInput {
  GameSessionId: string;
  PlayerId: string;
  PlayerData?: string | null;
}

// refs: 1 - tags: named, input
export interface CreatePlayerSessionsInput {
  GameSessionId: string;
  PlayerIds: string[];
  PlayerDataMap?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateScriptInput {
  Name?: string | null;
  Version?: string | null;
  StorageLocation?: S3Location | null;
  ZipFile?: Uint8Array | string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcPeeringAuthorizationInput {
  GameLiftAwsAccountId: string;
  PeerVpcId: string;
}

// refs: 1 - tags: named, input
export interface CreateVpcPeeringConnectionInput {
  FleetId: string;
  PeerVpcAwsAccountId: string;
  PeerVpcId: string;
}

// refs: 1 - tags: named, input
export interface DeleteAliasInput {
  AliasId: string;
}

// refs: 1 - tags: named, input
export interface DeleteBuildInput {
  BuildId: string;
}

// refs: 1 - tags: named, input
export interface DeleteFleetInput {
  FleetId: string;
}

// refs: 1 - tags: named, input
export interface DeleteGameServerGroupInput {
  GameServerGroupName: string;
  DeleteOption?: GameServerGroupDeleteOption | null;
}

// refs: 1 - tags: named, input
export interface DeleteGameSessionQueueInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteMatchmakingConfigurationInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteMatchmakingRuleSetInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteScalingPolicyInput {
  Name: string;
  FleetId: string;
}

// refs: 1 - tags: named, input
export interface DeleteScriptInput {
  ScriptId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVpcPeeringAuthorizationInput {
  GameLiftAwsAccountId: string;
  PeerVpcId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVpcPeeringConnectionInput {
  FleetId: string;
  VpcPeeringConnectionId: string;
}

// refs: 1 - tags: named, input
export interface DeregisterGameServerInput {
  GameServerGroupName: string;
  GameServerId: string;
}

// refs: 1 - tags: named, input
export interface DescribeAliasInput {
  AliasId: string;
}

// refs: 1 - tags: named, input
export interface DescribeBuildInput {
  BuildId: string;
}

// refs: 1 - tags: named, input
export interface DescribeEC2InstanceLimitsInput {
  EC2InstanceType?: EC2InstanceType | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetAttributesInput {
  FleetIds?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetCapacityInput {
  FleetIds?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetEventsInput {
  FleetId: string;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetPortSettingsInput {
  FleetId: string;
}

// refs: 1 - tags: named, input
export interface DescribeFleetUtilizationInput {
  FleetIds?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeGameServerInput {
  GameServerGroupName: string;
  GameServerId: string;
}

// refs: 1 - tags: named, input
export interface DescribeGameServerGroupInput {
  GameServerGroupName: string;
}

// refs: 1 - tags: named, input
export interface DescribeGameServerInstancesInput {
  GameServerGroupName: string;
  InstanceIds?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeGameSessionDetailsInput {
  FleetId?: string | null;
  GameSessionId?: string | null;
  AliasId?: string | null;
  StatusFilter?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeGameSessionPlacementInput {
  PlacementId: string;
}

// refs: 1 - tags: named, input
export interface DescribeGameSessionQueuesInput {
  Names?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeGameSessionsInput {
  FleetId?: string | null;
  GameSessionId?: string | null;
  AliasId?: string | null;
  StatusFilter?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstancesInput {
  FleetId: string;
  InstanceId?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeMatchmakingInput {
  TicketIds: string[];
}

// refs: 1 - tags: named, input
export interface DescribeMatchmakingConfigurationsInput {
  Names?: string[] | null;
  RuleSetName?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeMatchmakingRuleSetsInput {
  Names?: string[] | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePlayerSessionsInput {
  GameSessionId?: string | null;
  PlayerId?: string | null;
  PlayerSessionId?: string | null;
  PlayerSessionStatusFilter?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeRuntimeConfigurationInput {
  FleetId: string;
}

// refs: 1 - tags: named, input
export interface DescribeScalingPoliciesInput {
  FleetId: string;
  StatusFilter?: ScalingStatusType | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeScriptInput {
  ScriptId: string;
}

// refs: 1 - tags: named, input
export interface DescribeVpcPeeringAuthorizationsInput {
}

// refs: 1 - tags: named, input
export interface DescribeVpcPeeringConnectionsInput {
  FleetId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetGameSessionLogUrlInput {
  GameSessionId: string;
}

// refs: 1 - tags: named, input
export interface GetInstanceAccessInput {
  FleetId: string;
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface ListAliasesInput {
  RoutingStrategyType?: RoutingStrategyType | null;
  Name?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBuildsInput {
  Status?: BuildStatus | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListFleetsInput {
  BuildId?: string | null;
  ScriptId?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListGameServerGroupsInput {
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListGameServersInput {
  GameServerGroupName: string;
  SortOrder?: SortOrder | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListScriptsInput {
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceARN: string;
}

// refs: 1 - tags: named, input
export interface PutScalingPolicyInput {
  Name: string;
  FleetId: string;
  ScalingAdjustment?: number | null;
  ScalingAdjustmentType?: ScalingAdjustmentType | null;
  Threshold?: number | null;
  ComparisonOperator?: ComparisonOperatorType | null;
  EvaluationPeriods?: number | null;
  MetricName: MetricName;
  PolicyType?: PolicyType | null;
  TargetConfiguration?: TargetConfiguration | null;
}

// refs: 1 - tags: named, input
export interface RegisterGameServerInput {
  GameServerGroupName: string;
  GameServerId: string;
  InstanceId: string;
  ConnectionInfo?: string | null;
  GameServerData?: string | null;
}

// refs: 1 - tags: named, input
export interface RequestUploadCredentialsInput {
  BuildId: string;
}

// refs: 1 - tags: named, input
export interface ResolveAliasInput {
  AliasId: string;
}

// refs: 1 - tags: named, input
export interface ResumeGameServerGroupInput {
  GameServerGroupName: string;
  ResumeActions: GameServerGroupAction[];
}

// refs: 1 - tags: named, input
export interface SearchGameSessionsInput {
  FleetId?: string | null;
  AliasId?: string | null;
  FilterExpression?: string | null;
  SortExpression?: string | null;
  Limit?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface StartFleetActionsInput {
  FleetId: string;
  Actions: FleetAction[];
}

// refs: 1 - tags: named, input
export interface StartGameSessionPlacementInput {
  PlacementId: string;
  GameSessionQueueName: string;
  GameProperties?: GameProperty[] | null;
  MaximumPlayerSessionCount: number;
  GameSessionName?: string | null;
  PlayerLatencies?: PlayerLatency[] | null;
  DesiredPlayerSessions?: DesiredPlayerSession[] | null;
  GameSessionData?: string | null;
}

// refs: 1 - tags: named, input
export interface StartMatchBackfillInput {
  TicketId?: string | null;
  ConfigurationName: string;
  GameSessionArn: string;
  Players: Player[];
}

// refs: 1 - tags: named, input
export interface StartMatchmakingInput {
  TicketId?: string | null;
  ConfigurationName: string;
  Players: Player[];
}

// refs: 1 - tags: named, input
export interface StopFleetActionsInput {
  FleetId: string;
  Actions: FleetAction[];
}

// refs: 1 - tags: named, input
export interface StopGameSessionPlacementInput {
  PlacementId: string;
}

// refs: 1 - tags: named, input
export interface StopMatchmakingInput {
  TicketId: string;
}

// refs: 1 - tags: named, input
export interface SuspendGameServerGroupInput {
  GameServerGroupName: string;
  SuspendActions: GameServerGroupAction[];
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAliasInput {
  AliasId: string;
  Name?: string | null;
  Description?: string | null;
  RoutingStrategy?: RoutingStrategy | null;
}

// refs: 1 - tags: named, input
export interface UpdateBuildInput {
  BuildId: string;
  Name?: string | null;
  Version?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateFleetAttributesInput {
  FleetId: string;
  Name?: string | null;
  Description?: string | null;
  NewGameSessionProtectionPolicy?: ProtectionPolicy | null;
  ResourceCreationLimitPolicy?: ResourceCreationLimitPolicy | null;
  MetricGroups?: string[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateFleetCapacityInput {
  FleetId: string;
  DesiredInstances?: number | null;
  MinSize?: number | null;
  MaxSize?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateFleetPortSettingsInput {
  FleetId: string;
  InboundPermissionAuthorizations?: IpPermission[] | null;
  InboundPermissionRevocations?: IpPermission[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateGameServerInput {
  GameServerGroupName: string;
  GameServerId: string;
  GameServerData?: string | null;
  UtilizationStatus?: GameServerUtilizationStatus | null;
  HealthCheck?: GameServerHealthCheck | null;
}

// refs: 1 - tags: named, input
export interface UpdateGameServerGroupInput {
  GameServerGroupName: string;
  RoleArn?: string | null;
  InstanceDefinitions?: InstanceDefinition[] | null;
  GameServerProtectionPolicy?: GameServerProtectionPolicy | null;
  BalancingStrategy?: BalancingStrategy | null;
}

// refs: 1 - tags: named, input
export interface UpdateGameSessionInput {
  GameSessionId: string;
  MaximumPlayerSessionCount?: number | null;
  Name?: string | null;
  PlayerSessionCreationPolicy?: PlayerSessionCreationPolicy | null;
  ProtectionPolicy?: ProtectionPolicy | null;
}

// refs: 1 - tags: named, input
export interface UpdateGameSessionQueueInput {
  Name: string;
  TimeoutInSeconds?: number | null;
  PlayerLatencyPolicies?: PlayerLatencyPolicy[] | null;
  Destinations?: GameSessionQueueDestination[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateMatchmakingConfigurationInput {
  Name: string;
  Description?: string | null;
  GameSessionQueueArns?: string[] | null;
  RequestTimeoutSeconds?: number | null;
  AcceptanceTimeoutSeconds?: number | null;
  AcceptanceRequired?: boolean | null;
  RuleSetName?: string | null;
  NotificationTarget?: string | null;
  AdditionalPlayerCount?: number | null;
  CustomEventData?: string | null;
  GameProperties?: GameProperty[] | null;
  GameSessionData?: string | null;
  BackfillMode?: BackfillMode | null;
}

// refs: 1 - tags: named, input
export interface UpdateRuntimeConfigurationInput {
  FleetId: string;
  RuntimeConfiguration: RuntimeConfiguration;
}

// refs: 1 - tags: named, input
export interface UpdateScriptInput {
  ScriptId: string;
  Name?: string | null;
  Version?: string | null;
  StorageLocation?: S3Location | null;
  ZipFile?: Uint8Array | string | null;
}

// refs: 1 - tags: named, input
export interface ValidateMatchmakingRuleSetInput {
  RuleSetBody: string;
}

// refs: 1 - tags: named, output
export interface AcceptMatchOutput {
}

// refs: 1 - tags: named, output
export interface ClaimGameServerOutput {
  GameServer?: GameServer | null;
}

// refs: 1 - tags: named, output
export interface CreateAliasOutput {
  Alias?: Alias | null;
}

// refs: 1 - tags: named, output
export interface CreateBuildOutput {
  Build?: Build | null;
  UploadCredentials?: AwsCredentials | null;
  StorageLocation?: S3Location | null;
}

// refs: 1 - tags: named, output
export interface CreateFleetOutput {
  FleetAttributes?: FleetAttributes | null;
}

// refs: 1 - tags: named, output
export interface CreateGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateGameSessionOutput {
  GameSession?: GameSession | null;
}

// refs: 1 - tags: named, output
export interface CreateGameSessionQueueOutput {
  GameSessionQueue?: GameSessionQueue | null;
}

// refs: 1 - tags: named, output
export interface CreateMatchmakingConfigurationOutput {
  Configuration?: MatchmakingConfiguration | null;
}

// refs: 1 - tags: named, output
export interface CreateMatchmakingRuleSetOutput {
  RuleSet: MatchmakingRuleSet;
}

// refs: 1 - tags: named, output
export interface CreatePlayerSessionOutput {
  PlayerSession?: PlayerSession | null;
}

// refs: 1 - tags: named, output
export interface CreatePlayerSessionsOutput {
  PlayerSessions?: PlayerSession[] | null;
}

// refs: 1 - tags: named, output
export interface CreateScriptOutput {
  Script?: Script | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcPeeringAuthorizationOutput {
  VpcPeeringAuthorization?: VpcPeeringAuthorization | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcPeeringConnectionOutput {
}

// refs: 1 - tags: named, output
export interface DeleteGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteGameSessionQueueOutput {
}

// refs: 1 - tags: named, output
export interface DeleteMatchmakingConfigurationOutput {
}

// refs: 1 - tags: named, output
export interface DeleteMatchmakingRuleSetOutput {
}

// refs: 1 - tags: named, output
export interface DeleteVpcPeeringAuthorizationOutput {
}

// refs: 1 - tags: named, output
export interface DeleteVpcPeeringConnectionOutput {
}

// refs: 1 - tags: named, output
export interface DescribeAliasOutput {
  Alias?: Alias | null;
}

// refs: 1 - tags: named, output
export interface DescribeBuildOutput {
  Build?: Build | null;
}

// refs: 1 - tags: named, output
export interface DescribeEC2InstanceLimitsOutput {
  EC2InstanceLimits?: EC2InstanceLimit[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetAttributesOutput {
  FleetAttributes?: FleetAttributes[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetCapacityOutput {
  FleetCapacity?: FleetCapacity[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetEventsOutput {
  Events?: Event[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetPortSettingsOutput {
  InboundPermissions?: IpPermission[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetUtilizationOutput {
  FleetUtilization?: FleetUtilization[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameServerOutput {
  GameServer?: GameServer | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameServerInstancesOutput {
  GameServerInstances?: GameServerInstance[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameSessionDetailsOutput {
  GameSessionDetails?: GameSessionDetail[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameSessionPlacementOutput {
  GameSessionPlacement?: GameSessionPlacement | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameSessionQueuesOutput {
  GameSessionQueues?: GameSessionQueue[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeGameSessionsOutput {
  GameSessions?: GameSession[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstancesOutput {
  Instances?: Instance[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMatchmakingOutput {
  TicketList?: MatchmakingTicket[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeMatchmakingConfigurationsOutput {
  Configurations?: MatchmakingConfiguration[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeMatchmakingRuleSetsOutput {
  RuleSets: MatchmakingRuleSet[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePlayerSessionsOutput {
  PlayerSessions?: PlayerSession[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRuntimeConfigurationOutput {
  RuntimeConfiguration?: RuntimeConfiguration | null;
}

// refs: 1 - tags: named, output
export interface DescribeScalingPoliciesOutput {
  ScalingPolicies?: ScalingPolicy[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeScriptOutput {
  Script?: Script | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcPeeringAuthorizationsOutput {
  VpcPeeringAuthorizations?: VpcPeeringAuthorization[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcPeeringConnectionsOutput {
  VpcPeeringConnections?: VpcPeeringConnection[] | null;
}

// refs: 1 - tags: named, output
export interface GetGameSessionLogUrlOutput {
  PreSignedUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface GetInstanceAccessOutput {
  InstanceAccess?: InstanceAccess | null;
}

// refs: 1 - tags: named, output
export interface ListAliasesOutput {
  Aliases?: Alias[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBuildsOutput {
  Builds?: Build[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFleetsOutput {
  FleetIds?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGameServerGroupsOutput {
  GameServerGroups?: GameServerGroup[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGameServersOutput {
  GameServers?: GameServer[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListScriptsOutput {
  Scripts?: Script[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PutScalingPolicyOutput {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterGameServerOutput {
  GameServer?: GameServer | null;
}

// refs: 1 - tags: named, output
export interface RequestUploadCredentialsOutput {
  UploadCredentials?: AwsCredentials | null;
  StorageLocation?: S3Location | null;
}

// refs: 1 - tags: named, output
export interface ResolveAliasOutput {
  FleetId?: string | null;
  FleetArn?: string | null;
}

// refs: 1 - tags: named, output
export interface ResumeGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface SearchGameSessionsOutput {
  GameSessions?: GameSession[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface StartFleetActionsOutput {
}

// refs: 1 - tags: named, output
export interface StartGameSessionPlacementOutput {
  GameSessionPlacement?: GameSessionPlacement | null;
}

// refs: 1 - tags: named, output
export interface StartMatchBackfillOutput {
  MatchmakingTicket?: MatchmakingTicket | null;
}

// refs: 1 - tags: named, output
export interface StartMatchmakingOutput {
  MatchmakingTicket?: MatchmakingTicket | null;
}

// refs: 1 - tags: named, output
export interface StopFleetActionsOutput {
}

// refs: 1 - tags: named, output
export interface StopGameSessionPlacementOutput {
  GameSessionPlacement?: GameSessionPlacement | null;
}

// refs: 1 - tags: named, output
export interface StopMatchmakingOutput {
}

// refs: 1 - tags: named, output
export interface SuspendGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateAliasOutput {
  Alias?: Alias | null;
}

// refs: 1 - tags: named, output
export interface UpdateBuildOutput {
  Build?: Build | null;
}

// refs: 1 - tags: named, output
export interface UpdateFleetAttributesOutput {
  FleetId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateFleetCapacityOutput {
  FleetId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateFleetPortSettingsOutput {
  FleetId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateGameServerOutput {
  GameServer?: GameServer | null;
}

// refs: 1 - tags: named, output
export interface UpdateGameServerGroupOutput {
  GameServerGroup?: GameServerGroup | null;
}

// refs: 1 - tags: named, output
export interface UpdateGameSessionOutput {
  GameSession?: GameSession | null;
}

// refs: 1 - tags: named, output
export interface UpdateGameSessionQueueOutput {
  GameSessionQueue?: GameSessionQueue | null;
}

// refs: 1 - tags: named, output
export interface UpdateMatchmakingConfigurationOutput {
  Configuration?: MatchmakingConfiguration | null;
}

// refs: 1 - tags: named, output
export interface UpdateRuntimeConfigurationOutput {
  RuntimeConfiguration?: RuntimeConfiguration | null;
}

// refs: 1 - tags: named, output
export interface UpdateScriptOutput {
  Script?: Script | null;
}

// refs: 1 - tags: named, output
export interface ValidateMatchmakingRuleSetOutput {
  Valid?: boolean | null;
}

// refs: 1 - tags: input, named, enum
export type AcceptanceType =
| "ACCEPT"
| "REJECT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface RoutingStrategy {
  Type?: RoutingStrategyType | null;
  FleetId?: string | null;
  Message?: string | null;
}
function fromRoutingStrategy(input?: RoutingStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    FleetId: input["FleetId"],
    Message: input["Message"],
  }
}
function toRoutingStrategy(root: jsonP.JSONValue): RoutingStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<RoutingStrategyType>(x),
      "FleetId": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type RoutingStrategyType =
| "SIMPLE"
| "TERMINAL"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface S3Location {
  Bucket?: string | null;
  Key?: string | null;
  RoleArn?: string | null;
  ObjectVersion?: string | null;
}
function fromS3Location(input?: S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
    RoleArn: input["RoleArn"],
    ObjectVersion: input["ObjectVersion"],
  }
}
function toS3Location(root: jsonP.JSONValue): S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "Key": "s",
      "RoleArn": "s",
      "ObjectVersion": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type OperatingSystem =
| "WINDOWS_2012"
| "AMAZON_LINUX"
| "AMAZON_LINUX_2"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type EC2InstanceType =
| "t2.micro"
| "t2.small"
| "t2.medium"
| "t2.large"
| "c3.large"
| "c3.xlarge"
| "c3.2xlarge"
| "c3.4xlarge"
| "c3.8xlarge"
| "c4.large"
| "c4.xlarge"
| "c4.2xlarge"
| "c4.4xlarge"
| "c4.8xlarge"
| "c5.large"
| "c5.xlarge"
| "c5.2xlarge"
| "c5.4xlarge"
| "c5.9xlarge"
| "c5.12xlarge"
| "c5.18xlarge"
| "c5.24xlarge"
| "r3.large"
| "r3.xlarge"
| "r3.2xlarge"
| "r3.4xlarge"
| "r3.8xlarge"
| "r4.large"
| "r4.xlarge"
| "r4.2xlarge"
| "r4.4xlarge"
| "r4.8xlarge"
| "r4.16xlarge"
| "r5.large"
| "r5.xlarge"
| "r5.2xlarge"
| "r5.4xlarge"
| "r5.8xlarge"
| "r5.12xlarge"
| "r5.16xlarge"
| "r5.24xlarge"
| "m3.medium"
| "m3.large"
| "m3.xlarge"
| "m3.2xlarge"
| "m4.large"
| "m4.xlarge"
| "m4.2xlarge"
| "m4.4xlarge"
| "m4.10xlarge"
| "m5.large"
| "m5.xlarge"
| "m5.2xlarge"
| "m5.4xlarge"
| "m5.8xlarge"
| "m5.12xlarge"
| "m5.16xlarge"
| "m5.24xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface IpPermission {
  FromPort: number;
  ToPort: number;
  IpRange: string;
  Protocol: IpProtocol;
}
function fromIpPermission(input?: IpPermission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FromPort: input["FromPort"],
    ToPort: input["ToPort"],
    IpRange: input["IpRange"],
    Protocol: input["Protocol"],
  }
}
function toIpPermission(root: jsonP.JSONValue): IpPermission {
  return jsonP.readObj({
    required: {
      "FromPort": "n",
      "ToPort": "n",
      "IpRange": "s",
      "Protocol": (x: jsonP.JSONValue) => cmnP.readEnum<IpProtocol>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type IpProtocol =
| "TCP"
| "UDP"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ProtectionPolicy =
| "NoProtection"
| "FullProtection"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface RuntimeConfiguration {
  ServerProcesses?: ServerProcess[] | null;
  MaxConcurrentGameSessionActivations?: number | null;
  GameSessionActivationTimeoutSeconds?: number | null;
}
function fromRuntimeConfiguration(input?: RuntimeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServerProcesses: input["ServerProcesses"]?.map(x => fromServerProcess(x)),
    MaxConcurrentGameSessionActivations: input["MaxConcurrentGameSessionActivations"],
    GameSessionActivationTimeoutSeconds: input["GameSessionActivationTimeoutSeconds"],
  }
}
function toRuntimeConfiguration(root: jsonP.JSONValue): RuntimeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServerProcesses": [toServerProcess],
      "MaxConcurrentGameSessionActivations": "n",
      "GameSessionActivationTimeoutSeconds": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ServerProcess {
  LaunchPath: string;
  Parameters?: string | null;
  ConcurrentExecutions: number;
}
function fromServerProcess(input?: ServerProcess | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LaunchPath: input["LaunchPath"],
    Parameters: input["Parameters"],
    ConcurrentExecutions: input["ConcurrentExecutions"],
  }
}
function toServerProcess(root: jsonP.JSONValue): ServerProcess {
  return jsonP.readObj({
    required: {
      "LaunchPath": "s",
      "ConcurrentExecutions": "n",
    },
    optional: {
      "Parameters": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ResourceCreationLimitPolicy {
  NewGameSessionsPerCreator?: number | null;
  PolicyPeriodInMinutes?: number | null;
}
function fromResourceCreationLimitPolicy(input?: ResourceCreationLimitPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NewGameSessionsPerCreator: input["NewGameSessionsPerCreator"],
    PolicyPeriodInMinutes: input["PolicyPeriodInMinutes"],
  }
}
function toResourceCreationLimitPolicy(root: jsonP.JSONValue): ResourceCreationLimitPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "NewGameSessionsPerCreator": "n",
      "PolicyPeriodInMinutes": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type FleetType =
| "ON_DEMAND"
| "SPOT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface CertificateConfiguration {
  CertificateType: CertificateType;
}
function fromCertificateConfiguration(input?: CertificateConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateType: input["CertificateType"],
  }
}
function toCertificateConfiguration(root: jsonP.JSONValue): CertificateConfiguration {
  return jsonP.readObj({
    required: {
      "CertificateType": (x: jsonP.JSONValue) => cmnP.readEnum<CertificateType>(x),
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type CertificateType =
| "DISABLED"
| "GENERATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LaunchTemplateSpecification {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Version?: string | null;
}
function fromLaunchTemplateSpecification(input?: LaunchTemplateSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LaunchTemplateId: input["LaunchTemplateId"],
    LaunchTemplateName: input["LaunchTemplateName"],
    Version: input["Version"],
  }
}

// refs: 9 - tags: input, named, interface, output
export interface InstanceDefinition {
  InstanceType: GameServerGroupInstanceType;
  WeightedCapacity?: string | null;
}
function fromInstanceDefinition(input?: InstanceDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    WeightedCapacity: input["WeightedCapacity"],
  }
}
function toInstanceDefinition(root: jsonP.JSONValue): InstanceDefinition {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerGroupInstanceType>(x),
    },
    optional: {
      "WeightedCapacity": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type GameServerGroupInstanceType =
| "c4.large"
| "c4.xlarge"
| "c4.2xlarge"
| "c4.4xlarge"
| "c4.8xlarge"
| "c5.large"
| "c5.xlarge"
| "c5.2xlarge"
| "c5.4xlarge"
| "c5.9xlarge"
| "c5.12xlarge"
| "c5.18xlarge"
| "c5.24xlarge"
| "r4.large"
| "r4.xlarge"
| "r4.2xlarge"
| "r4.4xlarge"
| "r4.8xlarge"
| "r4.16xlarge"
| "r5.large"
| "r5.xlarge"
| "r5.2xlarge"
| "r5.4xlarge"
| "r5.8xlarge"
| "r5.12xlarge"
| "r5.16xlarge"
| "r5.24xlarge"
| "m4.large"
| "m4.xlarge"
| "m4.2xlarge"
| "m4.4xlarge"
| "m4.10xlarge"
| "m5.large"
| "m5.xlarge"
| "m5.2xlarge"
| "m5.4xlarge"
| "m5.8xlarge"
| "m5.12xlarge"
| "m5.16xlarge"
| "m5.24xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface GameServerGroupAutoScalingPolicy {
  EstimatedInstanceWarmup?: number | null;
  TargetTrackingConfiguration: TargetTrackingConfiguration;
}
function fromGameServerGroupAutoScalingPolicy(input?: GameServerGroupAutoScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EstimatedInstanceWarmup: input["EstimatedInstanceWarmup"],
    TargetTrackingConfiguration: fromTargetTrackingConfiguration(input["TargetTrackingConfiguration"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface TargetTrackingConfiguration {
  TargetValue: number;
}
function fromTargetTrackingConfiguration(input?: TargetTrackingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetValue: input["TargetValue"],
  }
}

// refs: 9 - tags: input, named, enum, output
export type BalancingStrategy =
| "SPOT_ONLY"
| "SPOT_PREFERRED"
| "ON_DEMAND_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type GameServerProtectionPolicy =
| "NO_PROTECTION"
| "FULL_PROTECTION"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface GameProperty {
  Key: string;
  Value: string;
}
function fromGameProperty(input?: GameProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toGameProperty(root: jsonP.JSONValue): GameProperty {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface PlayerLatencyPolicy {
  MaximumIndividualPlayerLatencyMilliseconds?: number | null;
  PolicyDurationSeconds?: number | null;
}
function fromPlayerLatencyPolicy(input?: PlayerLatencyPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumIndividualPlayerLatencyMilliseconds: input["MaximumIndividualPlayerLatencyMilliseconds"],
    PolicyDurationSeconds: input["PolicyDurationSeconds"],
  }
}
function toPlayerLatencyPolicy(root: jsonP.JSONValue): PlayerLatencyPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaximumIndividualPlayerLatencyMilliseconds": "n",
      "PolicyDurationSeconds": "n",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface GameSessionQueueDestination {
  DestinationArn?: string | null;
}
function fromGameSessionQueueDestination(input?: GameSessionQueueDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DestinationArn: input["DestinationArn"],
  }
}
function toGameSessionQueueDestination(root: jsonP.JSONValue): GameSessionQueueDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationArn": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type BackfillMode =
| "AUTOMATIC"
| "MANUAL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type GameServerGroupDeleteOption =
| "SAFE_DELETE"
| "FORCE_DELETE"
| "RETAIN"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ScalingStatusType =
| "ACTIVE"
| "UPDATE_REQUESTED"
| "UPDATING"
| "DELETE_REQUESTED"
| "DELETING"
| "DELETED"
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type BuildStatus =
| "INITIALIZED"
| "READY"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortOrder =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ScalingAdjustmentType =
| "ChangeInCapacity"
| "ExactCapacity"
| "PercentChangeInCapacity"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ComparisonOperatorType =
| "GreaterThanOrEqualToThreshold"
| "GreaterThanThreshold"
| "LessThanThreshold"
| "LessThanOrEqualToThreshold"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type MetricName =
| "ActivatingGameSessions"
| "ActiveGameSessions"
| "ActiveInstances"
| "AvailableGameSessions"
| "AvailablePlayerSessions"
| "CurrentPlayerSessions"
| "IdleInstances"
| "PercentAvailableGameSessions"
| "PercentIdleInstances"
| "QueueDepth"
| "WaitTime"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type PolicyType =
| "RuleBased"
| "TargetBased"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface TargetConfiguration {
  TargetValue: number;
}
function fromTargetConfiguration(input?: TargetConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetValue: input["TargetValue"],
  }
}
function toTargetConfiguration(root: jsonP.JSONValue): TargetConfiguration {
  return jsonP.readObj({
    required: {
      "TargetValue": "n",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type GameServerGroupAction =
| "REPLACE_INSTANCE_TYPES"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type FleetAction =
| "AUTO_SCALING"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface PlayerLatency {
  PlayerId?: string | null;
  RegionIdentifier?: string | null;
  LatencyInMilliseconds?: number | null;
}
function fromPlayerLatency(input?: PlayerLatency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    RegionIdentifier: input["RegionIdentifier"],
    LatencyInMilliseconds: input["LatencyInMilliseconds"],
  }
}
function toPlayerLatency(root: jsonP.JSONValue): PlayerLatency {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "RegionIdentifier": "s",
      "LatencyInMilliseconds": "n",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface DesiredPlayerSession {
  PlayerId?: string | null;
  PlayerData?: string | null;
}
function fromDesiredPlayerSession(input?: DesiredPlayerSession | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    PlayerData: input["PlayerData"],
  }
}

// refs: 5 - tags: input, named, interface, output
export interface Player {
  PlayerId?: string | null;
  PlayerAttributes?: { [key: string]: AttributeValue | null | undefined } | null;
  Team?: string | null;
  LatencyInMs?: { [key: string]: number | null | undefined } | null;
}
function fromPlayer(input?: Player | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PlayerId: input["PlayerId"],
    PlayerAttributes: jsonP.serializeMap(input["PlayerAttributes"], x => fromAttributeValue(x)),
    Team: input["Team"],
    LatencyInMs: input["LatencyInMs"],
  }
}
function toPlayer(root: jsonP.JSONValue): Player {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerAttributes": x => jsonP.readMap(String, toAttributeValue, x),
      "Team": "s",
      "LatencyInMs": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface AttributeValue {
  S?: string | null;
  N?: number | null;
  SL?: string[] | null;
  SDM?: { [key: string]: number | null | undefined } | null;
}
function fromAttributeValue(input?: AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    SL: input["SL"],
    SDM: input["SDM"],
  }
}
function toAttributeValue(root: jsonP.JSONValue): AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "n",
      "SL": ["s"],
      "SDM": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type GameServerUtilizationStatus =
| "AVAILABLE"
| "UTILIZED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type GameServerHealthCheck =
| "HEALTHY"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type PlayerSessionCreationPolicy =
| "ACCEPT_ALL"
| "DENY_ALL"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface GameServer {
  GameServerGroupName?: string | null;
  GameServerGroupArn?: string | null;
  GameServerId?: string | null;
  InstanceId?: string | null;
  ConnectionInfo?: string | null;
  GameServerData?: string | null;
  ClaimStatus?: GameServerClaimStatus | null;
  UtilizationStatus?: GameServerUtilizationStatus | null;
  RegistrationTime?: Date | number | null;
  LastClaimTime?: Date | number | null;
  LastHealthCheckTime?: Date | number | null;
}
function toGameServer(root: jsonP.JSONValue): GameServer {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "GameServerId": "s",
      "InstanceId": "s",
      "ConnectionInfo": "s",
      "GameServerData": "s",
      "ClaimStatus": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerClaimStatus>(x),
      "UtilizationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerUtilizationStatus>(x),
      "RegistrationTime": "d",
      "LastClaimTime": "d",
      "LastHealthCheckTime": "d",
    },
  }, root);
}

// refs: 5 - tags: output, named, enum
export type GameServerClaimStatus =
| "CLAIMED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Alias {
  AliasId?: string | null;
  Name?: string | null;
  AliasArn?: string | null;
  Description?: string | null;
  RoutingStrategy?: RoutingStrategy | null;
  CreationTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
}
function toAlias(root: jsonP.JSONValue): Alias {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasId": "s",
      "Name": "s",
      "AliasArn": "s",
      "Description": "s",
      "RoutingStrategy": toRoutingStrategy,
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Build {
  BuildId?: string | null;
  BuildArn?: string | null;
  Name?: string | null;
  Version?: string | null;
  Status?: BuildStatus | null;
  SizeOnDisk?: number | null;
  OperatingSystem?: OperatingSystem | null;
  CreationTime?: Date | number | null;
}
function toBuild(root: jsonP.JSONValue): Build {
  return jsonP.readObj({
    required: {},
    optional: {
      "BuildId": "s",
      "BuildArn": "s",
      "Name": "s",
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<BuildStatus>(x),
      "SizeOnDisk": "n",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<OperatingSystem>(x),
      "CreationTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AwsCredentials {
  AccessKeyId?: string | null;
  SecretAccessKey?: string | null;
  SessionToken?: string | null;
}
function toAwsCredentials(root: jsonP.JSONValue): AwsCredentials {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessKeyId": "s",
      "SecretAccessKey": "s",
      "SessionToken": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FleetAttributes {
  FleetId?: string | null;
  FleetArn?: string | null;
  FleetType?: FleetType | null;
  InstanceType?: EC2InstanceType | null;
  Description?: string | null;
  Name?: string | null;
  CreationTime?: Date | number | null;
  TerminationTime?: Date | number | null;
  Status?: FleetStatus | null;
  BuildId?: string | null;
  BuildArn?: string | null;
  ScriptId?: string | null;
  ScriptArn?: string | null;
  ServerLaunchPath?: string | null;
  ServerLaunchParameters?: string | null;
  LogPaths?: string[] | null;
  NewGameSessionProtectionPolicy?: ProtectionPolicy | null;
  OperatingSystem?: OperatingSystem | null;
  ResourceCreationLimitPolicy?: ResourceCreationLimitPolicy | null;
  MetricGroups?: string[] | null;
  StoppedActions?: FleetAction[] | null;
  InstanceRoleArn?: string | null;
  CertificateConfiguration?: CertificateConfiguration | null;
}
function toFleetAttributes(root: jsonP.JSONValue): FleetAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "FleetArn": "s",
      "FleetType": (x: jsonP.JSONValue) => cmnP.readEnum<FleetType>(x),
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<EC2InstanceType>(x),
      "Description": "s",
      "Name": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<FleetStatus>(x),
      "BuildId": "s",
      "BuildArn": "s",
      "ScriptId": "s",
      "ScriptArn": "s",
      "ServerLaunchPath": "s",
      "ServerLaunchParameters": "s",
      "LogPaths": ["s"],
      "NewGameSessionProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<ProtectionPolicy>(x),
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<OperatingSystem>(x),
      "ResourceCreationLimitPolicy": toResourceCreationLimitPolicy,
      "MetricGroups": ["s"],
      "StoppedActions": [(x: jsonP.JSONValue) => cmnP.readEnum<FleetAction>(x)],
      "InstanceRoleArn": "s",
      "CertificateConfiguration": toCertificateConfiguration,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type FleetStatus =
| "NEW"
| "DOWNLOADING"
| "VALIDATING"
| "BUILDING"
| "ACTIVATING"
| "ACTIVE"
| "DELETING"
| "ERROR"
| "TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, interface
export interface GameServerGroup {
  GameServerGroupName?: string | null;
  GameServerGroupArn?: string | null;
  RoleArn?: string | null;
  InstanceDefinitions?: InstanceDefinition[] | null;
  BalancingStrategy?: BalancingStrategy | null;
  GameServerProtectionPolicy?: GameServerProtectionPolicy | null;
  AutoScalingGroupArn?: string | null;
  Status?: GameServerGroupStatus | null;
  StatusReason?: string | null;
  SuspendedActions?: GameServerGroupAction[] | null;
  CreationTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
}
function toGameServerGroup(root: jsonP.JSONValue): GameServerGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "RoleArn": "s",
      "InstanceDefinitions": [toInstanceDefinition],
      "BalancingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<BalancingStrategy>(x),
      "GameServerProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerProtectionPolicy>(x),
      "AutoScalingGroupArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerGroupStatus>(x),
      "StatusReason": "s",
      "SuspendedActions": [(x: jsonP.JSONValue) => cmnP.readEnum<GameServerGroupAction>(x)],
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type GameServerGroupStatus =
| "NEW"
| "ACTIVATING"
| "ACTIVE"
| "DELETE_SCHEDULED"
| "DELETING"
| "DELETED"
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface GameSession {
  GameSessionId?: string | null;
  Name?: string | null;
  FleetId?: string | null;
  FleetArn?: string | null;
  CreationTime?: Date | number | null;
  TerminationTime?: Date | number | null;
  CurrentPlayerSessionCount?: number | null;
  MaximumPlayerSessionCount?: number | null;
  Status?: GameSessionStatus | null;
  StatusReason?: GameSessionStatusReason | null;
  GameProperties?: GameProperty[] | null;
  IpAddress?: string | null;
  DnsName?: string | null;
  Port?: number | null;
  PlayerSessionCreationPolicy?: PlayerSessionCreationPolicy | null;
  CreatorId?: string | null;
  GameSessionData?: string | null;
  MatchmakerData?: string | null;
}
function toGameSession(root: jsonP.JSONValue): GameSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSessionId": "s",
      "Name": "s",
      "FleetId": "s",
      "FleetArn": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "CurrentPlayerSessionCount": "n",
      "MaximumPlayerSessionCount": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<GameSessionStatus>(x),
      "StatusReason": (x: jsonP.JSONValue) => cmnP.readEnum<GameSessionStatusReason>(x),
      "GameProperties": [toGameProperty],
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlayerSessionCreationPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<PlayerSessionCreationPolicy>(x),
      "CreatorId": "s",
      "GameSessionData": "s",
      "MatchmakerData": "s",
    },
  }, root);
}

// refs: 5 - tags: output, named, enum
export type GameSessionStatus =
| "ACTIVE"
| "ACTIVATING"
| "TERMINATED"
| "TERMINATING"
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, enum
export type GameSessionStatusReason =
| "INTERRUPTED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface GameSessionQueue {
  Name?: string | null;
  GameSessionQueueArn?: string | null;
  TimeoutInSeconds?: number | null;
  PlayerLatencyPolicies?: PlayerLatencyPolicy[] | null;
  Destinations?: GameSessionQueueDestination[] | null;
}
function toGameSessionQueue(root: jsonP.JSONValue): GameSessionQueue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "GameSessionQueueArn": "s",
      "TimeoutInSeconds": "n",
      "PlayerLatencyPolicies": [toPlayerLatencyPolicy],
      "Destinations": [toGameSessionQueueDestination],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface MatchmakingConfiguration {
  Name?: string | null;
  ConfigurationArn?: string | null;
  Description?: string | null;
  GameSessionQueueArns?: string[] | null;
  RequestTimeoutSeconds?: number | null;
  AcceptanceTimeoutSeconds?: number | null;
  AcceptanceRequired?: boolean | null;
  RuleSetName?: string | null;
  RuleSetArn?: string | null;
  NotificationTarget?: string | null;
  AdditionalPlayerCount?: number | null;
  CustomEventData?: string | null;
  CreationTime?: Date | number | null;
  GameProperties?: GameProperty[] | null;
  GameSessionData?: string | null;
  BackfillMode?: BackfillMode | null;
}
function toMatchmakingConfiguration(root: jsonP.JSONValue): MatchmakingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ConfigurationArn": "s",
      "Description": "s",
      "GameSessionQueueArns": ["s"],
      "RequestTimeoutSeconds": "n",
      "AcceptanceTimeoutSeconds": "n",
      "AcceptanceRequired": "b",
      "RuleSetName": "s",
      "RuleSetArn": "s",
      "NotificationTarget": "s",
      "AdditionalPlayerCount": "n",
      "CustomEventData": "s",
      "CreationTime": "d",
      "GameProperties": [toGameProperty],
      "GameSessionData": "s",
      "BackfillMode": (x: jsonP.JSONValue) => cmnP.readEnum<BackfillMode>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface MatchmakingRuleSet {
  RuleSetName?: string | null;
  RuleSetArn?: string | null;
  RuleSetBody: string;
  CreationTime?: Date | number | null;
}
function toMatchmakingRuleSet(root: jsonP.JSONValue): MatchmakingRuleSet {
  return jsonP.readObj({
    required: {
      "RuleSetBody": "s",
    },
    optional: {
      "RuleSetName": "s",
      "RuleSetArn": "s",
      "CreationTime": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface PlayerSession {
  PlayerSessionId?: string | null;
  PlayerId?: string | null;
  GameSessionId?: string | null;
  FleetId?: string | null;
  FleetArn?: string | null;
  CreationTime?: Date | number | null;
  TerminationTime?: Date | number | null;
  Status?: PlayerSessionStatus | null;
  IpAddress?: string | null;
  DnsName?: string | null;
  Port?: number | null;
  PlayerData?: string | null;
}
function toPlayerSession(root: jsonP.JSONValue): PlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerSessionId": "s",
      "PlayerId": "s",
      "GameSessionId": "s",
      "FleetId": "s",
      "FleetArn": "s",
      "CreationTime": "d",
      "TerminationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<PlayerSessionStatus>(x),
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlayerData": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type PlayerSessionStatus =
| "RESERVED"
| "ACTIVE"
| "COMPLETED"
| "TIMEDOUT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Script {
  ScriptId?: string | null;
  ScriptArn?: string | null;
  Name?: string | null;
  Version?: string | null;
  SizeOnDisk?: number | null;
  CreationTime?: Date | number | null;
  StorageLocation?: S3Location | null;
}
function toScript(root: jsonP.JSONValue): Script {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScriptId": "s",
      "ScriptArn": "s",
      "Name": "s",
      "Version": "s",
      "SizeOnDisk": "n",
      "CreationTime": "d",
      "StorageLocation": toS3Location,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface VpcPeeringAuthorization {
  GameLiftAwsAccountId?: string | null;
  PeerVpcAwsAccountId?: string | null;
  PeerVpcId?: string | null;
  CreationTime?: Date | number | null;
  ExpirationTime?: Date | number | null;
}
function toVpcPeeringAuthorization(root: jsonP.JSONValue): VpcPeeringAuthorization {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameLiftAwsAccountId": "s",
      "PeerVpcAwsAccountId": "s",
      "PeerVpcId": "s",
      "CreationTime": "d",
      "ExpirationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EC2InstanceLimit {
  EC2InstanceType?: EC2InstanceType | null;
  CurrentInstances?: number | null;
  InstanceLimit?: number | null;
}
function toEC2InstanceLimit(root: jsonP.JSONValue): EC2InstanceLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "EC2InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<EC2InstanceType>(x),
      "CurrentInstances": "n",
      "InstanceLimit": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FleetCapacity {
  FleetId?: string | null;
  InstanceType?: EC2InstanceType | null;
  InstanceCounts?: EC2InstanceCounts | null;
}
function toFleetCapacity(root: jsonP.JSONValue): FleetCapacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<EC2InstanceType>(x),
      "InstanceCounts": toEC2InstanceCounts,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EC2InstanceCounts {
  DESIRED?: number | null;
  MINIMUM?: number | null;
  MAXIMUM?: number | null;
  PENDING?: number | null;
  ACTIVE?: number | null;
  IDLE?: number | null;
  TERMINATING?: number | null;
}
function toEC2InstanceCounts(root: jsonP.JSONValue): EC2InstanceCounts {
  return jsonP.readObj({
    required: {},
    optional: {
      "DESIRED": "n",
      "MINIMUM": "n",
      "MAXIMUM": "n",
      "PENDING": "n",
      "ACTIVE": "n",
      "IDLE": "n",
      "TERMINATING": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Event {
  EventId?: string | null;
  ResourceId?: string | null;
  EventCode?: EventCode | null;
  Message?: string | null;
  EventTime?: Date | number | null;
  PreSignedLogUrl?: string | null;
}
function toEvent(root: jsonP.JSONValue): Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventId": "s",
      "ResourceId": "s",
      "EventCode": (x: jsonP.JSONValue) => cmnP.readEnum<EventCode>(x),
      "Message": "s",
      "EventTime": "d",
      "PreSignedLogUrl": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type EventCode =
| "GENERIC_EVENT"
| "FLEET_CREATED"
| "FLEET_DELETED"
| "FLEET_SCALING_EVENT"
| "FLEET_STATE_DOWNLOADING"
| "FLEET_STATE_VALIDATING"
| "FLEET_STATE_BUILDING"
| "FLEET_STATE_ACTIVATING"
| "FLEET_STATE_ACTIVE"
| "FLEET_STATE_ERROR"
| "FLEET_INITIALIZATION_FAILED"
| "FLEET_BINARY_DOWNLOAD_FAILED"
| "FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND"
| "FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE"
| "FLEET_VALIDATION_TIMED_OUT"
| "FLEET_ACTIVATION_FAILED"
| "FLEET_ACTIVATION_FAILED_NO_INSTANCES"
| "FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED"
| "SERVER_PROCESS_INVALID_PATH"
| "SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT"
| "SERVER_PROCESS_PROCESS_READY_TIMEOUT"
| "SERVER_PROCESS_CRASHED"
| "SERVER_PROCESS_TERMINATED_UNHEALTHY"
| "SERVER_PROCESS_FORCE_TERMINATED"
| "SERVER_PROCESS_PROCESS_EXIT_TIMEOUT"
| "GAME_SESSION_ACTIVATION_TIMEOUT"
| "FLEET_CREATION_EXTRACTING_BUILD"
| "FLEET_CREATION_RUNNING_INSTALLER"
| "FLEET_CREATION_VALIDATING_RUNTIME_CONFIG"
| "FLEET_VPC_PEERING_SUCCEEDED"
| "FLEET_VPC_PEERING_FAILED"
| "FLEET_VPC_PEERING_DELETED"
| "INSTANCE_INTERRUPTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface FleetUtilization {
  FleetId?: string | null;
  ActiveServerProcessCount?: number | null;
  ActiveGameSessionCount?: number | null;
  CurrentPlayerSessionCount?: number | null;
  MaximumPlayerSessionCount?: number | null;
}
function toFleetUtilization(root: jsonP.JSONValue): FleetUtilization {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "ActiveServerProcessCount": "n",
      "ActiveGameSessionCount": "n",
      "CurrentPlayerSessionCount": "n",
      "MaximumPlayerSessionCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface GameServerInstance {
  GameServerGroupName?: string | null;
  GameServerGroupArn?: string | null;
  InstanceId?: string | null;
  InstanceStatus?: GameServerInstanceStatus | null;
}
function toGameServerInstance(root: jsonP.JSONValue): GameServerInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameServerGroupName": "s",
      "GameServerGroupArn": "s",
      "InstanceId": "s",
      "InstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<GameServerInstanceStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type GameServerInstanceStatus =
| "ACTIVE"
| "DRAINING"
| "SPOT_TERMINATING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GameSessionDetail {
  GameSession?: GameSession | null;
  ProtectionPolicy?: ProtectionPolicy | null;
}
function toGameSessionDetail(root: jsonP.JSONValue): GameSessionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSession": toGameSession,
      "ProtectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<ProtectionPolicy>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface GameSessionPlacement {
  PlacementId?: string | null;
  GameSessionQueueName?: string | null;
  Status?: GameSessionPlacementState | null;
  GameProperties?: GameProperty[] | null;
  MaximumPlayerSessionCount?: number | null;
  GameSessionName?: string | null;
  GameSessionId?: string | null;
  GameSessionArn?: string | null;
  GameSessionRegion?: string | null;
  PlayerLatencies?: PlayerLatency[] | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  IpAddress?: string | null;
  DnsName?: string | null;
  Port?: number | null;
  PlacedPlayerSessions?: PlacedPlayerSession[] | null;
  GameSessionData?: string | null;
  MatchmakerData?: string | null;
}
function toGameSessionPlacement(root: jsonP.JSONValue): GameSessionPlacement {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlacementId": "s",
      "GameSessionQueueName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<GameSessionPlacementState>(x),
      "GameProperties": [toGameProperty],
      "MaximumPlayerSessionCount": "n",
      "GameSessionName": "s",
      "GameSessionId": "s",
      "GameSessionArn": "s",
      "GameSessionRegion": "s",
      "PlayerLatencies": [toPlayerLatency],
      "StartTime": "d",
      "EndTime": "d",
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "PlacedPlayerSessions": [toPlacedPlayerSession],
      "GameSessionData": "s",
      "MatchmakerData": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type GameSessionPlacementState =
| "PENDING"
| "FULFILLED"
| "CANCELLED"
| "TIMED_OUT"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface PlacedPlayerSession {
  PlayerId?: string | null;
  PlayerSessionId?: string | null;
}
function toPlacedPlayerSession(root: jsonP.JSONValue): PlacedPlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerSessionId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Instance {
  FleetId?: string | null;
  InstanceId?: string | null;
  IpAddress?: string | null;
  DnsName?: string | null;
  OperatingSystem?: OperatingSystem | null;
  Type?: EC2InstanceType | null;
  Status?: InstanceStatus | null;
  CreationTime?: Date | number | null;
}
function toInstance(root: jsonP.JSONValue): Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceId": "s",
      "IpAddress": "s",
      "DnsName": "s",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<OperatingSystem>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<EC2InstanceType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceStatus>(x),
      "CreationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceStatus =
| "PENDING"
| "ACTIVE"
| "TERMINATING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface MatchmakingTicket {
  TicketId?: string | null;
  ConfigurationName?: string | null;
  ConfigurationArn?: string | null;
  Status?: MatchmakingConfigurationStatus | null;
  StatusReason?: string | null;
  StatusMessage?: string | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Players?: Player[] | null;
  GameSessionConnectionInfo?: GameSessionConnectionInfo | null;
  EstimatedWaitTime?: number | null;
}
function toMatchmakingTicket(root: jsonP.JSONValue): MatchmakingTicket {
  return jsonP.readObj({
    required: {},
    optional: {
      "TicketId": "s",
      "ConfigurationName": "s",
      "ConfigurationArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<MatchmakingConfigurationStatus>(x),
      "StatusReason": "s",
      "StatusMessage": "s",
      "StartTime": "d",
      "EndTime": "d",
      "Players": [toPlayer],
      "GameSessionConnectionInfo": toGameSessionConnectionInfo,
      "EstimatedWaitTime": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type MatchmakingConfigurationStatus =
| "CANCELLED"
| "COMPLETED"
| "FAILED"
| "PLACING"
| "QUEUED"
| "REQUIRES_ACCEPTANCE"
| "SEARCHING"
| "TIMED_OUT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface GameSessionConnectionInfo {
  GameSessionArn?: string | null;
  IpAddress?: string | null;
  DnsName?: string | null;
  Port?: number | null;
  MatchedPlayerSessions?: MatchedPlayerSession[] | null;
}
function toGameSessionConnectionInfo(root: jsonP.JSONValue): GameSessionConnectionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "GameSessionArn": "s",
      "IpAddress": "s",
      "DnsName": "s",
      "Port": "n",
      "MatchedPlayerSessions": [toMatchedPlayerSession],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface MatchedPlayerSession {
  PlayerId?: string | null;
  PlayerSessionId?: string | null;
}
function toMatchedPlayerSession(root: jsonP.JSONValue): MatchedPlayerSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "PlayerId": "s",
      "PlayerSessionId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ScalingPolicy {
  FleetId?: string | null;
  Name?: string | null;
  Status?: ScalingStatusType | null;
  ScalingAdjustment?: number | null;
  ScalingAdjustmentType?: ScalingAdjustmentType | null;
  ComparisonOperator?: ComparisonOperatorType | null;
  Threshold?: number | null;
  EvaluationPeriods?: number | null;
  MetricName?: MetricName | null;
  PolicyType?: PolicyType | null;
  TargetConfiguration?: TargetConfiguration | null;
}
function toScalingPolicy(root: jsonP.JSONValue): ScalingPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ScalingStatusType>(x),
      "ScalingAdjustment": "n",
      "ScalingAdjustmentType": (x: jsonP.JSONValue) => cmnP.readEnum<ScalingAdjustmentType>(x),
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<ComparisonOperatorType>(x),
      "Threshold": "n",
      "EvaluationPeriods": "n",
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<MetricName>(x),
      "PolicyType": (x: jsonP.JSONValue) => cmnP.readEnum<PolicyType>(x),
      "TargetConfiguration": toTargetConfiguration,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VpcPeeringConnection {
  FleetId?: string | null;
  FleetArn?: string | null;
  IpV4CidrBlock?: string | null;
  VpcPeeringConnectionId?: string | null;
  Status?: VpcPeeringConnectionStatus | null;
  PeerVpcId?: string | null;
  GameLiftVpcId?: string | null;
}
function toVpcPeeringConnection(root: jsonP.JSONValue): VpcPeeringConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "FleetArn": "s",
      "IpV4CidrBlock": "s",
      "VpcPeeringConnectionId": "s",
      "Status": toVpcPeeringConnectionStatus,
      "PeerVpcId": "s",
      "GameLiftVpcId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VpcPeeringConnectionStatus {
  Code?: string | null;
  Message?: string | null;
}
function toVpcPeeringConnectionStatus(root: jsonP.JSONValue): VpcPeeringConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceAccess {
  FleetId?: string | null;
  InstanceId?: string | null;
  IpAddress?: string | null;
  OperatingSystem?: OperatingSystem | null;
  Credentials?: InstanceCredentials | null;
}
function toInstanceAccess(root: jsonP.JSONValue): InstanceAccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "FleetId": "s",
      "InstanceId": "s",
      "IpAddress": "s",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<OperatingSystem>(x),
      "Credentials": toInstanceCredentials,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceCredentials {
  UserName?: string | null;
  Secret?: string | null;
}
function toInstanceCredentials(root: jsonP.JSONValue): InstanceCredentials {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserName": "s",
      "Secret": "s",
    },
  }, root);
}
