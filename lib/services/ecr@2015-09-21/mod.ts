// Autogenerated API client for: Amazon EC2 Container Registry

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ECR {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ECR.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-09-21",
    "endpointPrefix": "api.ecr",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon ECR",
    "serviceFullName": "Amazon EC2 Container Registry",
    "serviceId": "ECR",
    "signatureVersion": "v4",
    "signingName": "ecr",
    "targetPrefix": "AmazonEC2ContainerRegistry_V20150921",
    "uid": "ecr-2015-09-21"
  };

  async batchCheckLayerAvailability(
    {abortSignal, ...params}: RequestConfig & BatchCheckLayerAvailabilityRequest,
  ): Promise<BatchCheckLayerAvailabilityResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      layerDigests: params["layerDigests"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCheckLayerAvailability",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "layers": [toLayer],
        "failures": [toLayerFailure],
      },
    }, await resp.json());
  }

  async batchDeleteImage(
    {abortSignal, ...params}: RequestConfig & BatchDeleteImageRequest,
  ): Promise<BatchDeleteImageResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageIds": [toImageIdentifier],
        "failures": [toImageFailure],
      },
    }, await resp.json());
  }

  async batchGetImage(
    {abortSignal, ...params}: RequestConfig & BatchGetImageRequest,
  ): Promise<BatchGetImageResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      acceptedMediaTypes: params["acceptedMediaTypes"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "images": [toImage],
        "failures": [toImageFailure],
      },
    }, await resp.json());
  }

  async completeLayerUpload(
    {abortSignal, ...params}: RequestConfig & CompleteLayerUploadRequest,
  ): Promise<CompleteLayerUploadResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      layerDigests: params["layerDigests"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "layerDigest": "s",
      },
    }, await resp.json());
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & CreateRepositoryRequest,
  ): Promise<CreateRepositoryResponse> {
    const body: jsonP.JSONObject = params ? {
      repositoryName: params["repositoryName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      imageTagMutability: params["imageTagMutability"],
      imageScanningConfiguration: fromImageScanningConfiguration(params["imageScanningConfiguration"]),
      encryptionConfiguration: fromEncryptionConfiguration(params["encryptionConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
      },
    }, await resp.json());
  }

  async deleteLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & DeleteLifecyclePolicyRequest,
  ): Promise<DeleteLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "lastEvaluatedAt": "d",
      },
    }, await resp.json());
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryRequest,
  ): Promise<DeleteRepositoryResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      force: params["force"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
      },
    }, await resp.json());
  }

  async deleteRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryPolicyRequest,
  ): Promise<DeleteRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async describeImageScanFindings(
    {abortSignal, ...params}: RequestConfig & DescribeImageScanFindingsRequest,
  ): Promise<DescribeImageScanFindingsResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageId: fromImageIdentifier(params["imageId"]),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageScanFindings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageId": toImageIdentifier,
        "imageScanStatus": toImageScanStatus,
        "imageScanFindings": toImageScanFindings,
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeImages(
    {abortSignal, ...params}: RequestConfig & DescribeImagesRequest,
  ): Promise<DescribeImagesResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromDescribeImagesFilter(params["filter"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageDetails": [toImageDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeRepositories(
    {abortSignal, ...params}: RequestConfig & DescribeRepositoriesRequest = {},
  ): Promise<DescribeRepositoriesResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryNames: params["repositoryNames"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepository],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getAuthorizationToken(
    {abortSignal, ...params}: RequestConfig & GetAuthorizationTokenRequest = {},
  ): Promise<GetAuthorizationTokenResponse> {
    const body: jsonP.JSONObject = params ? {
      registryIds: params["registryIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAuthorizationToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizationData": [toAuthorizationData],
      },
    }, await resp.json());
  }

  async getDownloadUrlForLayer(
    {abortSignal, ...params}: RequestConfig & GetDownloadUrlForLayerRequest,
  ): Promise<GetDownloadUrlForLayerResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      layerDigest: params["layerDigest"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDownloadUrlForLayer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "downloadUrl": "s",
        "layerDigest": "s",
      },
    }, await resp.json());
  }

  async getLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & GetLifecyclePolicyRequest,
  ): Promise<GetLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "lastEvaluatedAt": "d",
      },
    }, await resp.json());
  }

  async getLifecyclePolicyPreview(
    {abortSignal, ...params}: RequestConfig & GetLifecyclePolicyPreviewRequest,
  ): Promise<GetLifecyclePolicyPreviewResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromLifecyclePolicyPreviewFilter(params["filter"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLifecyclePolicyPreview",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<LifecyclePolicyPreviewStatus>(x),
        "nextToken": "s",
        "previewResults": [toLifecyclePolicyPreviewResult],
        "summary": toLifecyclePolicyPreviewSummary,
      },
    }, await resp.json());
  }

  async getRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & GetRepositoryPolicyRequest,
  ): Promise<GetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async initiateLayerUpload(
    {abortSignal, ...params}: RequestConfig & InitiateLayerUploadRequest,
  ): Promise<InitiateLayerUploadResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitiateLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "uploadId": "s",
        "partSize": "n",
      },
    }, await resp.json());
  }

  async listImages(
    {abortSignal, ...params}: RequestConfig & ListImagesRequest,
  ): Promise<ListImagesResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromListImagesFilter(params["filter"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageIds": [toImageIdentifier],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      resourceArn: params["resourceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putImage(
    {abortSignal, ...params}: RequestConfig & PutImageRequest,
  ): Promise<PutImageResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageManifest: params["imageManifest"],
      imageManifestMediaType: params["imageManifestMediaType"],
      imageTag: params["imageTag"],
      imageDigest: params["imageDigest"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "image": toImage,
      },
    }, await resp.json());
  }

  async putImageScanningConfiguration(
    {abortSignal, ...params}: RequestConfig & PutImageScanningConfigurationRequest,
  ): Promise<PutImageScanningConfigurationResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageScanningConfiguration: fromImageScanningConfiguration(params["imageScanningConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImageScanningConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageScanningConfiguration": toImageScanningConfiguration,
      },
    }, await resp.json());
  }

  async putImageTagMutability(
    {abortSignal, ...params}: RequestConfig & PutImageTagMutabilityRequest,
  ): Promise<PutImageTagMutabilityResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageTagMutability: params["imageTagMutability"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImageTagMutability",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageTagMutability": (x: jsonP.JSONValue) => cmnP.readEnum<ImageTagMutability>(x),
      },
    }, await resp.json());
  }

  async putLifecyclePolicy(
    {abortSignal, ...params}: RequestConfig & PutLifecyclePolicyRequest,
  ): Promise<PutLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      lifecyclePolicyText: params["lifecyclePolicyText"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
      },
    }, await resp.json());
  }

  async setRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & SetRepositoryPolicyRequest,
  ): Promise<SetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      policyText: params["policyText"],
      force: params["force"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async startImageScan(
    {abortSignal, ...params}: RequestConfig & StartImageScanRequest,
  ): Promise<StartImageScanResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageId: fromImageIdentifier(params["imageId"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImageScan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageId": toImageIdentifier,
        "imageScanStatus": toImageScanStatus,
      },
    }, await resp.json());
  }

  async startLifecyclePolicyPreview(
    {abortSignal, ...params}: RequestConfig & StartLifecyclePolicyPreviewRequest,
  ): Promise<StartLifecyclePolicyPreviewResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      lifecyclePolicyText: params["lifecyclePolicyText"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartLifecyclePolicyPreview",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<LifecyclePolicyPreviewStatus>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async uploadLayerPart(
    {abortSignal, ...params}: RequestConfig & UploadLayerPartRequest,
  ): Promise<UploadLayerPartResponse> {
    const body: jsonP.JSONObject = params ? {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      partFirstByte: params["partFirstByte"],
      partLastByte: params["partLastByte"],
      layerPartBlob: jsonP.serializeBlob(params["layerPartBlob"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadLayerPart",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "lastByteReceived": "n",
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until an image scan is complete and findings can be accessed
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForImageScanComplete(
    params: RequestConfig & DescribeImageScanFindingsRequest,
  ): Promise<DescribeImageScanFindingsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageScanComplete';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeImageScanFindings(params);
      const field = resp?.imageScanStatus?.status;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a lifecycle policy preview request is complete and results can be accessed
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForLifecyclePolicyPreviewComplete(
    params: RequestConfig & GetLifecyclePolicyPreviewRequest,
  ): Promise<GetLifecyclePolicyPreviewResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LifecyclePolicyPreviewComplete';
    for (let i = 0; i < 20; i++) {
      const resp = await this.getLifecyclePolicyPreview(params);
      const field = resp?.status;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface BatchCheckLayerAvailabilityRequest {
  registryId?: string | null;
  repositoryName: string;
  layerDigests: string[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteImageRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds: ImageIdentifier[];
}

// refs: 1 - tags: named, input
export interface BatchGetImageRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds: ImageIdentifier[];
  acceptedMediaTypes?: string[] | null;
}

// refs: 1 - tags: named, input
export interface CompleteLayerUploadRequest {
  registryId?: string | null;
  repositoryName: string;
  uploadId: string;
  layerDigests: string[];
}

// refs: 1 - tags: named, input
export interface CreateRepositoryRequest {
  repositoryName: string;
  tags?: Tag[] | null;
  imageTagMutability?: ImageTagMutability | null;
  imageScanningConfiguration?: ImageScanningConfiguration | null;
  encryptionConfiguration?: EncryptionConfiguration | null;
}

// refs: 1 - tags: named, input
export interface DeleteLifecyclePolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryRequest {
  registryId?: string | null;
  repositoryName: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface DescribeImageScanFindingsRequest {
  registryId?: string | null;
  repositoryName: string;
  imageId: ImageIdentifier;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeImagesRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds?: ImageIdentifier[] | null;
  nextToken?: string | null;
  maxResults?: number | null;
  filter?: DescribeImagesFilter | null;
}

// refs: 1 - tags: named, input
export interface DescribeRepositoriesRequest {
  registryId?: string | null;
  repositoryNames?: string[] | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetAuthorizationTokenRequest {
  registryIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetDownloadUrlForLayerRequest {
  registryId?: string | null;
  repositoryName: string;
  layerDigest: string;
}

// refs: 1 - tags: named, input
export interface GetLifecyclePolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface GetLifecyclePolicyPreviewRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds?: ImageIdentifier[] | null;
  nextToken?: string | null;
  maxResults?: number | null;
  filter?: LifecyclePolicyPreviewFilter | null;
}

// refs: 1 - tags: named, input
export interface GetRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface InitiateLayerUploadRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface ListImagesRequest {
  registryId?: string | null;
  repositoryName: string;
  nextToken?: string | null;
  maxResults?: number | null;
  filter?: ListImagesFilter | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface PutImageRequest {
  registryId?: string | null;
  repositoryName: string;
  imageManifest: string;
  imageManifestMediaType?: string | null;
  imageTag?: string | null;
  imageDigest?: string | null;
}

// refs: 1 - tags: named, input
export interface PutImageScanningConfigurationRequest {
  registryId?: string | null;
  repositoryName: string;
  imageScanningConfiguration: ImageScanningConfiguration;
}

// refs: 1 - tags: named, input
export interface PutImageTagMutabilityRequest {
  registryId?: string | null;
  repositoryName: string;
  imageTagMutability: ImageTagMutability;
}

// refs: 1 - tags: named, input
export interface PutLifecyclePolicyRequest {
  registryId?: string | null;
  repositoryName: string;
  lifecyclePolicyText: string;
}

// refs: 1 - tags: named, input
export interface SetRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
  policyText: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartImageScanRequest {
  registryId?: string | null;
  repositoryName: string;
  imageId: ImageIdentifier;
}

// refs: 1 - tags: named, input
export interface StartLifecyclePolicyPreviewRequest {
  registryId?: string | null;
  repositoryName: string;
  lifecyclePolicyText?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UploadLayerPartRequest {
  registryId?: string | null;
  repositoryName: string;
  uploadId: string;
  partFirstByte: number;
  partLastByte: number;
  layerPartBlob: Uint8Array | string;
}

// refs: 1 - tags: named, output
export interface BatchCheckLayerAvailabilityResponse {
  layers?: Layer[] | null;
  failures?: LayerFailure[] | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteImageResponse {
  imageIds?: ImageIdentifier[] | null;
  failures?: ImageFailure[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetImageResponse {
  images?: Image[] | null;
  failures?: ImageFailure[] | null;
}

// refs: 1 - tags: named, output
export interface CompleteLayerUploadResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  uploadId?: string | null;
  layerDigest?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateRepositoryResponse {
  repository?: Repository | null;
}

// refs: 1 - tags: named, output
export interface DeleteLifecyclePolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  lifecyclePolicyText?: string | null;
  lastEvaluatedAt?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryResponse {
  repository?: Repository | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImageScanFindingsResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  imageId?: ImageIdentifier | null;
  imageScanStatus?: ImageScanStatus | null;
  imageScanFindings?: ImageScanFindings | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImagesResponse {
  imageDetails?: ImageDetail[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRepositoriesResponse {
  repositories?: Repository[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAuthorizationTokenResponse {
  authorizationData?: AuthorizationData[] | null;
}

// refs: 1 - tags: named, output
export interface GetDownloadUrlForLayerResponse {
  downloadUrl?: string | null;
  layerDigest?: string | null;
}

// refs: 1 - tags: named, output
export interface GetLifecyclePolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  lifecyclePolicyText?: string | null;
  lastEvaluatedAt?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetLifecyclePolicyPreviewResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  lifecyclePolicyText?: string | null;
  status?: LifecyclePolicyPreviewStatus | null;
  nextToken?: string | null;
  previewResults?: LifecyclePolicyPreviewResult[] | null;
  summary?: LifecyclePolicyPreviewSummary | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface InitiateLayerUploadResponse {
  uploadId?: string | null;
  partSize?: number | null;
}

// refs: 1 - tags: named, output
export interface ListImagesResponse {
  imageIds?: ImageIdentifier[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PutImageResponse {
  image?: Image | null;
}

// refs: 1 - tags: named, output
export interface PutImageScanningConfigurationResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  imageScanningConfiguration?: ImageScanningConfiguration | null;
}

// refs: 1 - tags: named, output
export interface PutImageTagMutabilityResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  imageTagMutability?: ImageTagMutability | null;
}

// refs: 1 - tags: named, output
export interface PutLifecyclePolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  lifecyclePolicyText?: string | null;
}

// refs: 1 - tags: named, output
export interface SetRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface StartImageScanResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  imageId?: ImageIdentifier | null;
  imageScanStatus?: ImageScanStatus | null;
}

// refs: 1 - tags: named, output
export interface StartLifecyclePolicyPreviewResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  lifecyclePolicyText?: string | null;
  status?: LifecyclePolicyPreviewStatus | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UploadLayerPartResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  uploadId?: string | null;
  lastByteReceived?: number | null;
}

// refs: 14 - tags: input, named, interface, output
export interface ImageIdentifier {
  imageDigest?: string | null;
  imageTag?: string | null;
}
function fromImageIdentifier(input?: ImageIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageDigest: input["imageDigest"],
    imageTag: input["imageTag"],
  }
}
function toImageIdentifier(root: jsonP.JSONValue): ImageIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageDigest": "s",
      "imageTag": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ImageTagMutability =
| "MUTABLE"
| "IMMUTABLE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface ImageScanningConfiguration {
  scanOnPush?: boolean | null;
}
function fromImageScanningConfiguration(input?: ImageScanningConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scanOnPush: input["scanOnPush"],
  }
}
function toImageScanningConfiguration(root: jsonP.JSONValue): ImageScanningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "scanOnPush": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface EncryptionConfiguration {
  encryptionType: EncryptionType;
  kmsKey?: string | null;
}
function fromEncryptionConfiguration(input?: EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionType: input["encryptionType"],
    kmsKey: input["kmsKey"],
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): EncryptionConfiguration {
  return jsonP.readObj({
    required: {
      "encryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionType>(x),
    },
    optional: {
      "kmsKey": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type EncryptionType =
| "AES256"
| "KMS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DescribeImagesFilter {
  tagStatus?: TagStatus | null;
}
function fromDescribeImagesFilter(input?: DescribeImagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

// refs: 3 - tags: input, named, enum
export type TagStatus =
| "TAGGED"
| "UNTAGGED"
| "ANY"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LifecyclePolicyPreviewFilter {
  tagStatus?: TagStatus | null;
}
function fromLifecyclePolicyPreviewFilter(input?: LifecyclePolicyPreviewFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

// refs: 1 - tags: input, named, interface
export interface ListImagesFilter {
  tagStatus?: TagStatus | null;
}
function fromListImagesFilter(input?: ListImagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

// refs: 1 - tags: output, named, interface
export interface Layer {
  layerDigest?: string | null;
  layerAvailability?: LayerAvailability | null;
  layerSize?: number | null;
  mediaType?: string | null;
}
function toLayer(root: jsonP.JSONValue): Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "layerAvailability": (x: jsonP.JSONValue) => cmnP.readEnum<LayerAvailability>(x),
      "layerSize": "n",
      "mediaType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type LayerAvailability =
| "AVAILABLE"
| "UNAVAILABLE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LayerFailure {
  layerDigest?: string | null;
  failureCode?: LayerFailureCode | null;
  failureReason?: string | null;
}
function toLayerFailure(root: jsonP.JSONValue): LayerFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<LayerFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type LayerFailureCode =
| "InvalidLayerDigest"
| "MissingLayerDigest"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ImageFailure {
  imageId?: ImageIdentifier | null;
  failureCode?: ImageFailureCode | null;
  failureReason?: string | null;
}
function toImageFailure(root: jsonP.JSONValue): ImageFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageId": toImageIdentifier,
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<ImageFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ImageFailureCode =
| "InvalidImageDigest"
| "InvalidImageTag"
| "ImageTagDoesNotMatchDigest"
| "ImageNotFound"
| "MissingDigestAndTag"
| "ImageReferencedByManifestList"
| "KmsError"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface Image {
  registryId?: string | null;
  repositoryName?: string | null;
  imageId?: ImageIdentifier | null;
  imageManifest?: string | null;
  imageManifestMediaType?: string | null;
}
function toImage(root: jsonP.JSONValue): Image {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageId": toImageIdentifier,
      "imageManifest": "s",
      "imageManifestMediaType": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Repository {
  repositoryArn?: string | null;
  registryId?: string | null;
  repositoryName?: string | null;
  repositoryUri?: string | null;
  createdAt?: Date | number | null;
  imageTagMutability?: ImageTagMutability | null;
  imageScanningConfiguration?: ImageScanningConfiguration | null;
  encryptionConfiguration?: EncryptionConfiguration | null;
}
function toRepository(root: jsonP.JSONValue): Repository {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryArn": "s",
      "registryId": "s",
      "repositoryName": "s",
      "repositoryUri": "s",
      "createdAt": "d",
      "imageTagMutability": (x: jsonP.JSONValue) => cmnP.readEnum<ImageTagMutability>(x),
      "imageScanningConfiguration": toImageScanningConfiguration,
      "encryptionConfiguration": toEncryptionConfiguration,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ImageScanStatus {
  status?: ScanStatus | null;
  description?: string | null;
}
function toImageScanStatus(root: jsonP.JSONValue): ImageScanStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ScanStatus>(x),
      "description": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ScanStatus =
| "IN_PROGRESS"
| "COMPLETE"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ImageScanFindings {
  imageScanCompletedAt?: Date | number | null;
  vulnerabilitySourceUpdatedAt?: Date | number | null;
  findings?: ImageScanFinding[] | null;
  findingSeverityCounts?: { [key in FindingSeverity]: number | null | undefined } | null;
}
function toImageScanFindings(root: jsonP.JSONValue): ImageScanFindings {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageScanCompletedAt": "d",
      "vulnerabilitySourceUpdatedAt": "d",
      "findings": [toImageScanFinding],
      "findingSeverityCounts": x => jsonP.readMap(x => cmnP.readEnumReq<FindingSeverity>(x), Number, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageScanFinding {
  name?: string | null;
  description?: string | null;
  uri?: string | null;
  severity?: FindingSeverity | null;
  attributes?: Attribute[] | null;
}
function toImageScanFinding(root: jsonP.JSONValue): ImageScanFinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "uri": "s",
      "severity": (x: jsonP.JSONValue) => cmnP.readEnum<FindingSeverity>(x),
      "attributes": [toAttribute],
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type FindingSeverity =
| "INFORMATIONAL"
| "LOW"
| "MEDIUM"
| "HIGH"
| "CRITICAL"
| "UNDEFINED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Attribute {
  key: string;
  value?: string | null;
}
function toAttribute(root: jsonP.JSONValue): Attribute {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "value": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageDetail {
  registryId?: string | null;
  repositoryName?: string | null;
  imageDigest?: string | null;
  imageTags?: string[] | null;
  imageSizeInBytes?: number | null;
  imagePushedAt?: Date | number | null;
  imageScanStatus?: ImageScanStatus | null;
  imageScanFindingsSummary?: ImageScanFindingsSummary | null;
  imageManifestMediaType?: string | null;
  artifactMediaType?: string | null;
}
function toImageDetail(root: jsonP.JSONValue): ImageDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageDigest": "s",
      "imageTags": ["s"],
      "imageSizeInBytes": "n",
      "imagePushedAt": "d",
      "imageScanStatus": toImageScanStatus,
      "imageScanFindingsSummary": toImageScanFindingsSummary,
      "imageManifestMediaType": "s",
      "artifactMediaType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageScanFindingsSummary {
  imageScanCompletedAt?: Date | number | null;
  vulnerabilitySourceUpdatedAt?: Date | number | null;
  findingSeverityCounts?: { [key in FindingSeverity]: number | null | undefined } | null;
}
function toImageScanFindingsSummary(root: jsonP.JSONValue): ImageScanFindingsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageScanCompletedAt": "d",
      "vulnerabilitySourceUpdatedAt": "d",
      "findingSeverityCounts": x => jsonP.readMap(x => cmnP.readEnumReq<FindingSeverity>(x), Number, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AuthorizationData {
  authorizationToken?: string | null;
  expiresAt?: Date | number | null;
  proxyEndpoint?: string | null;
}
function toAuthorizationData(root: jsonP.JSONValue): AuthorizationData {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizationToken": "s",
      "expiresAt": "d",
      "proxyEndpoint": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type LifecyclePolicyPreviewStatus =
| "IN_PROGRESS"
| "COMPLETE"
| "EXPIRED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LifecyclePolicyPreviewResult {
  imageTags?: string[] | null;
  imageDigest?: string | null;
  imagePushedAt?: Date | number | null;
  action?: LifecyclePolicyRuleAction | null;
  appliedRulePriority?: number | null;
}
function toLifecyclePolicyPreviewResult(root: jsonP.JSONValue): LifecyclePolicyPreviewResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageTags": ["s"],
      "imageDigest": "s",
      "imagePushedAt": "d",
      "action": toLifecyclePolicyRuleAction,
      "appliedRulePriority": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LifecyclePolicyRuleAction {
  type?: ImageActionType | null;
}
function toLifecyclePolicyRuleAction(root: jsonP.JSONValue): LifecyclePolicyRuleAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ImageActionType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ImageActionType =
| "EXPIRE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LifecyclePolicyPreviewSummary {
  expiringImageTotalCount?: number | null;
}
function toLifecyclePolicyPreviewSummary(root: jsonP.JSONValue): LifecyclePolicyPreviewSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "expiringImageTotalCount": "n",
    },
  }, root);
}
