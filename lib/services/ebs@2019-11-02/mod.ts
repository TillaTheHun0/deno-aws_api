// Autogenerated API client for: Amazon Elastic Block Store

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class EBS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EBS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-11-02",
    "endpointPrefix": "ebs",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon EBS",
    "serviceFullName": "Amazon Elastic Block Store",
    "serviceId": "EBS",
    "signatureVersion": "v4",
    "uid": "ebs-2019-11-02"
  };

  async completeSnapshot(
    {abortSignal, ...params}: RequestConfig & CompleteSnapshotRequest,
  ): Promise<CompleteSnapshotResponse> {
    const headers = new Headers;
    headers.append("x-amz-ChangedBlocksCount", params["ChangedBlocksCount"]?.toString() ?? '');
    if (params["Checksum"] != null) headers.append("x-amz-Checksum", params["Checksum"]);
    if (params["ChecksumAlgorithm"] != null) headers.append("x-amz-Checksum-Algorithm", params["ChecksumAlgorithm"]);
    if (params["ChecksumAggregationMethod"] != null) headers.append("x-amz-Checksum-Aggregation-Method", params["ChecksumAggregationMethod"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "CompleteSnapshot",
      requestUri: cmnP.encodePath`/snapshots/completion/${params["SnapshotId"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      },
    }, await resp.json());
  }

  async getSnapshotBlock(
    {abortSignal, ...params}: RequestConfig & GetSnapshotBlockRequest,
  ): Promise<GetSnapshotBlockResponse> {
    const query = new URLSearchParams;
    query.set("blockToken", params["BlockToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSnapshotBlock",
      method: "GET",
      requestUri: cmnP.encodePath`/snapshots/${params["SnapshotId"]}/blocks/${params["BlockIndex"].toString()}`,
    });
  return {
    DataLength: cmnP.readNum(resp.headers.get("x-amz-Data-Length")),
    Checksum: resp.headers.get("x-amz-Checksum"),
    ChecksumAlgorithm: cmnP.readEnum<ChecksumAlgorithm>(resp.headers.get("x-amz-Checksum-Algorithm")),
    BlockData: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async listChangedBlocks(
    {abortSignal, ...params}: RequestConfig & ListChangedBlocksRequest,
  ): Promise<ListChangedBlocksResponse> {
    const query = new URLSearchParams;
    if (params["FirstSnapshotId"] != null) query.set("firstSnapshotId", params["FirstSnapshotId"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("pageToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["StartingBlockIndex"] != null) query.set("startingBlockIndex", params["StartingBlockIndex"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChangedBlocks",
      method: "GET",
      requestUri: cmnP.encodePath`/snapshots/${params["SecondSnapshotId"]}/changedblocks`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChangedBlocks": [toChangedBlock],
        "ExpiryTime": "d",
        "VolumeSize": "n",
        "BlockSize": "n",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSnapshotBlocks(
    {abortSignal, ...params}: RequestConfig & ListSnapshotBlocksRequest,
  ): Promise<ListSnapshotBlocksResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("pageToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["StartingBlockIndex"] != null) query.set("startingBlockIndex", params["StartingBlockIndex"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSnapshotBlocks",
      method: "GET",
      requestUri: cmnP.encodePath`/snapshots/${params["SnapshotId"]}/blocks`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Blocks": [toBlock],
        "ExpiryTime": "d",
        "VolumeSize": "n",
        "BlockSize": "n",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putSnapshotBlock(
    {abortSignal, ...params}: RequestConfig & PutSnapshotBlockRequest,
  ): Promise<PutSnapshotBlockResponse> {
    const body = typeof params["BlockData"] === 'string' ? new TextEncoder().encode(params["BlockData"]) : params["BlockData"];
    const headers = new Headers;
    headers.append("x-amz-Data-Length", params["DataLength"]?.toString() ?? '');
    if (params["Progress"] != null) headers.append("x-amz-Progress", params["Progress"]?.toString() ?? '');
    headers.append("x-amz-Checksum", params["Checksum"]);
    headers.append("x-amz-Checksum-Algorithm", params["ChecksumAlgorithm"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSnapshotBlock",
      method: "PUT",
      requestUri: cmnP.encodePath`/snapshots/${params["SnapshotId"]}/blocks/${params["BlockIndex"].toString()}`,
      responseCode: 201,
    });
    return {
      Checksum: resp.headers.get("x-amz-Checksum"),
      ChecksumAlgorithm: cmnP.readEnum<ChecksumAlgorithm>(resp.headers.get("x-amz-Checksum-Algorithm")),
      ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
    };
  }

  async startSnapshot(
    {abortSignal, ...params}: RequestConfig & StartSnapshotRequest,
  ): Promise<StartSnapshotResponse> {
    const body: jsonP.JSONObject = {
      VolumeSize: params["VolumeSize"],
      ParentSnapshotId: params["ParentSnapshotId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      Description: params["Description"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      Encrypted: params["Encrypted"],
      KmsKeyArn: params["KmsKeyArn"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSnapshot",
      requestUri: "/snapshots",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Description": "s",
        "SnapshotId": "s",
        "OwnerId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
        "StartTime": "d",
        "VolumeSize": "n",
        "BlockSize": "n",
        "Tags": [toTag],
        "ParentSnapshotId": "s",
        "KmsKeyArn": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CompleteSnapshotRequest {
  SnapshotId: string;
  ChangedBlocksCount: number;
  Checksum?: string | null;
  ChecksumAlgorithm?: ChecksumAlgorithm | null;
  ChecksumAggregationMethod?: ChecksumAggregationMethod | null;
}

// refs: 1 - tags: named, input
export interface GetSnapshotBlockRequest {
  SnapshotId: string;
  BlockIndex: number;
  BlockToken: string;
}

// refs: 1 - tags: named, input
export interface ListChangedBlocksRequest {
  FirstSnapshotId?: string | null;
  SecondSnapshotId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  StartingBlockIndex?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSnapshotBlocksRequest {
  SnapshotId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  StartingBlockIndex?: number | null;
}

// refs: 1 - tags: named, input
export interface PutSnapshotBlockRequest {
  SnapshotId: string;
  BlockIndex: number;
  BlockData: Uint8Array | string;
  DataLength: number;
  Progress?: number | null;
  Checksum: string;
  ChecksumAlgorithm: ChecksumAlgorithm;
}

// refs: 1 - tags: named, input
export interface StartSnapshotRequest {
  VolumeSize: number;
  ParentSnapshotId?: string | null;
  Tags?: Tag[] | null;
  Description?: string | null;
  ClientToken?: string | null;
  Encrypted?: boolean | null;
  KmsKeyArn?: string | null;
  Timeout?: number | null;
}

// refs: 1 - tags: named, output
export interface CompleteSnapshotResponse {
  Status?: Status | null;
}

// refs: 1 - tags: named, output
export interface GetSnapshotBlockResponse {
  DataLength?: number | null;
  BlockData?: Uint8Array | string | null;
  Checksum?: string | null;
  ChecksumAlgorithm?: ChecksumAlgorithm | null;
}

// refs: 1 - tags: named, output
export interface ListChangedBlocksResponse {
  ChangedBlocks?: ChangedBlock[] | null;
  ExpiryTime?: Date | number | null;
  VolumeSize?: number | null;
  BlockSize?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSnapshotBlocksResponse {
  Blocks?: Block[] | null;
  ExpiryTime?: Date | number | null;
  VolumeSize?: number | null;
  BlockSize?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutSnapshotBlockResponse {
  Checksum?: string | null;
  ChecksumAlgorithm?: ChecksumAlgorithm | null;
}

// refs: 1 - tags: named, output
export interface StartSnapshotResponse {
  Description?: string | null;
  SnapshotId?: string | null;
  OwnerId?: string | null;
  Status?: Status | null;
  StartTime?: Date | number | null;
  VolumeSize?: number | null;
  BlockSize?: number | null;
  Tags?: Tag[] | null;
  ParentSnapshotId?: string | null;
  KmsKeyArn?: string | null;
}

// refs: 4 - tags: input, named, enum, output
export type ChecksumAlgorithm =
| "SHA256"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ChecksumAggregationMethod =
| "LINEAR"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type Status =
| "completed"
| "pending"
| "error"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ChangedBlock {
  BlockIndex?: number | null;
  FirstBlockToken?: string | null;
  SecondBlockToken?: string | null;
}
function toChangedBlock(root: jsonP.JSONValue): ChangedBlock {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockIndex": "n",
      "FirstBlockToken": "s",
      "SecondBlockToken": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Block {
  BlockIndex?: number | null;
  BlockToken?: string | null;
}
function toBlock(root: jsonP.JSONValue): Block {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockIndex": "n",
      "BlockToken": "s",
    },
  }, root);
}
