// Autogenerated API client for: AWS Elemental MediaPackage VOD

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class MediaPackageVod {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaPackageVod.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-11-07",
    "endpointPrefix": "mediapackage-vod",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "MediaPackage Vod",
    "serviceFullName": "AWS Elemental MediaPackage VOD",
    "serviceId": "MediaPackage Vod",
    "signatureVersion": "v4",
    "signingName": "mediapackage-vod",
    "uid": "mediapackage-vod-2018-11-07"
  };

  async configureLogs(
    {abortSignal, ...params}: RequestConfig & s.ConfigureLogsRequest,
  ): Promise<s.ConfigureLogsResponse> {
    const body: jsonP.JSONObject = {
      egressAccessLogs: fromEgressAccessLogs(params["EgressAccessLogs"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfigureLogs",
      method: "PUT",
      requestUri: cmnP.encodePath`/packaging_groups/${params["Id"]}/configure_logs`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "DomainName": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "Id": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createAsset(
    {abortSignal, ...params}: RequestConfig & s.CreateAssetRequest,
  ): Promise<s.CreateAssetResponse> {
    const body: jsonP.JSONObject = {
      id: params["Id"],
      packagingGroupId: params["PackagingGroupId"],
      resourceId: params["ResourceId"],
      sourceArn: params["SourceArn"],
      sourceRoleArn: params["SourceRoleArn"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAsset",
      requestUri: "/assets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreatedAt": "s",
        "EgressEndpoints": [toEgressEndpoint],
        "Id": "s",
        "PackagingGroupId": "s",
        "ResourceId": "s",
        "SourceArn": "s",
        "SourceRoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createPackagingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreatePackagingConfigurationRequest,
  ): Promise<s.CreatePackagingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      cmafPackage: fromCmafPackage(params["CmafPackage"]),
      dashPackage: fromDashPackage(params["DashPackage"]),
      hlsPackage: fromHlsPackage(params["HlsPackage"]),
      id: params["Id"],
      mssPackage: fromMssPackage(params["MssPackage"]),
      packagingGroupId: params["PackagingGroupId"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePackagingConfiguration",
      requestUri: "/packaging_configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "MssPackage": toMssPackage,
        "PackagingGroupId": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createPackagingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreatePackagingGroupRequest,
  ): Promise<s.CreatePackagingGroupResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
      egressAccessLogs: fromEgressAccessLogs(params["EgressAccessLogs"]),
      id: params["Id"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePackagingGroup",
      requestUri: "/packaging_groups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "DomainName": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "Id": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteAsset(
    {abortSignal, ...params}: RequestConfig & s.DeleteAssetRequest,
  ): Promise<s.DeleteAssetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAsset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/assets/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePackagingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeletePackagingConfigurationRequest,
  ): Promise<s.DeletePackagingConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePackagingConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/packaging_configurations/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePackagingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeletePackagingGroupRequest,
  ): Promise<s.DeletePackagingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePackagingGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/packaging_groups/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeAsset(
    {abortSignal, ...params}: RequestConfig & s.DescribeAssetRequest,
  ): Promise<s.DescribeAssetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAsset",
      method: "GET",
      requestUri: cmnP.encodePath`/assets/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CreatedAt": "s",
        "EgressEndpoints": [toEgressEndpoint],
        "Id": "s",
        "PackagingGroupId": "s",
        "ResourceId": "s",
        "SourceArn": "s",
        "SourceRoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describePackagingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribePackagingConfigurationRequest,
  ): Promise<s.DescribePackagingConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribePackagingConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/packaging_configurations/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "MssPackage": toMssPackage,
        "PackagingGroupId": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describePackagingGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribePackagingGroupRequest,
  ): Promise<s.DescribePackagingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribePackagingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/packaging_groups/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "DomainName": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "Id": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listAssets(
    {abortSignal, ...params}: RequestConfig & s.ListAssetsRequest = {},
  ): Promise<s.ListAssetsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["PackagingGroupId"] != null) query.set("packagingGroupId", params["PackagingGroupId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAssets",
      method: "GET",
      requestUri: "/assets",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Assets": [toAssetShallow],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPackagingConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListPackagingConfigurationsRequest = {},
  ): Promise<s.ListPackagingConfigurationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["PackagingGroupId"] != null) query.set("packagingGroupId", params["PackagingGroupId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackagingConfigurations",
      method: "GET",
      requestUri: "/packaging_configurations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "PackagingConfigurations": [toPackagingConfiguration],
      },
    }, await resp.json());
  }

  async listPackagingGroups(
    {abortSignal, ...params}: RequestConfig & s.ListPackagingGroupsRequest = {},
  ): Promise<s.ListPackagingGroupsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackagingGroups",
      method: "GET",
      requestUri: "/packaging_groups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "PackagingGroups": [toPackagingGroup],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async updatePackagingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdatePackagingGroupRequest,
  ): Promise<s.UpdatePackagingGroupResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePackagingGroup",
      method: "PUT",
      requestUri: cmnP.encodePath`/packaging_groups/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "DomainName": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "Id": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

}

function fromEgressAccessLogs(input?: s.EgressAccessLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["LogGroupName"],
  }
}
function toEgressAccessLogs(root: jsonP.JSONValue): s.EgressAccessLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
    },
  }, root);
}

function fromCmafPackage(input?: s.CmafPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromCmafEncryption(input["Encryption"]),
    hlsManifests: input["HlsManifests"]?.map(x => fromHlsManifest(x)),
    segmentDurationSeconds: input["SegmentDurationSeconds"],
  }
}
function toCmafPackage(root: jsonP.JSONValue): s.CmafPackage {
  return jsonP.readObj({
    required: {
      "HlsManifests": [toHlsManifest],
    },
    optional: {
      "Encryption": toCmafEncryption,
      "SegmentDurationSeconds": "n",
    },
  }, root);
}

function fromCmafEncryption(input?: s.CmafEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toCmafEncryption(root: jsonP.JSONValue): s.CmafEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {},
  }, root);
}

function fromSpekeKeyProvider(input?: s.SpekeKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    roleArn: input["RoleArn"],
    systemIds: input["SystemIds"],
    url: input["Url"],
  }
}
function toSpekeKeyProvider(root: jsonP.JSONValue): s.SpekeKeyProvider {
  return jsonP.readObj({
    required: {
      "RoleArn": "s",
      "SystemIds": ["s"],
      "Url": "s",
    },
    optional: {},
  }, root);
}

function fromHlsManifest(input?: s.HlsManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    includeIframeOnlyStream: input["IncludeIframeOnlyStream"],
    manifestName: input["ManifestName"],
    programDateTimeIntervalSeconds: input["ProgramDateTimeIntervalSeconds"],
    repeatExtXKey: input["RepeatExtXKey"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}
function toHlsManifest(root: jsonP.JSONValue): s.HlsManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdMarkers>(x),
      "IncludeIframeOnlyStream": "b",
      "ManifestName": "s",
      "ProgramDateTimeIntervalSeconds": "n",
      "RepeatExtXKey": "b",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

function fromStreamSelection(input?: s.StreamSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxVideoBitsPerSecond: input["MaxVideoBitsPerSecond"],
    minVideoBitsPerSecond: input["MinVideoBitsPerSecond"],
    streamOrder: input["StreamOrder"],
  }
}
function toStreamSelection(root: jsonP.JSONValue): s.StreamSelection {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxVideoBitsPerSecond": "n",
      "MinVideoBitsPerSecond": "n",
      "StreamOrder": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamOrder>(x),
    },
  }, root);
}

function fromDashPackage(input?: s.DashPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dashManifests: input["DashManifests"]?.map(x => fromDashManifest(x)),
    encryption: fromDashEncryption(input["Encryption"]),
    periodTriggers: input["PeriodTriggers"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    segmentTemplateFormat: input["SegmentTemplateFormat"],
  }
}
function toDashPackage(root: jsonP.JSONValue): s.DashPackage {
  return jsonP.readObj({
    required: {
      "DashManifests": [toDashManifest],
    },
    optional: {
      "Encryption": toDashEncryption,
      "PeriodTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__PeriodTriggersElement>(x)],
      "SegmentDurationSeconds": "n",
      "SegmentTemplateFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.SegmentTemplateFormat>(x),
    },
  }, root);
}

function fromDashManifest(input?: s.DashManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestLayout: input["ManifestLayout"],
    manifestName: input["ManifestName"],
    minBufferTimeSeconds: input["MinBufferTimeSeconds"],
    profile: input["Profile"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}
function toDashManifest(root: jsonP.JSONValue): s.DashManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestLayout": (x: jsonP.JSONValue) => cmnP.readEnum<s.ManifestLayout>(x),
      "ManifestName": "s",
      "MinBufferTimeSeconds": "n",
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.Profile>(x),
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

function fromDashEncryption(input?: s.DashEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toDashEncryption(root: jsonP.JSONValue): s.DashEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {},
  }, root);
}

function fromHlsPackage(input?: s.HlsPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromHlsEncryption(input["Encryption"]),
    hlsManifests: input["HlsManifests"]?.map(x => fromHlsManifest(x)),
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    useAudioRenditionGroup: input["UseAudioRenditionGroup"],
  }
}
function toHlsPackage(root: jsonP.JSONValue): s.HlsPackage {
  return jsonP.readObj({
    required: {
      "HlsManifests": [toHlsManifest],
    },
    optional: {
      "Encryption": toHlsEncryption,
      "SegmentDurationSeconds": "n",
      "UseAudioRenditionGroup": "b",
    },
  }, root);
}

function fromHlsEncryption(input?: s.HlsEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toHlsEncryption(root: jsonP.JSONValue): s.HlsEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionMethod>(x),
    },
  }, root);
}

function fromMssPackage(input?: s.MssPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromMssEncryption(input["Encryption"]),
    mssManifests: input["MssManifests"]?.map(x => fromMssManifest(x)),
    segmentDurationSeconds: input["SegmentDurationSeconds"],
  }
}
function toMssPackage(root: jsonP.JSONValue): s.MssPackage {
  return jsonP.readObj({
    required: {
      "MssManifests": [toMssManifest],
    },
    optional: {
      "Encryption": toMssEncryption,
      "SegmentDurationSeconds": "n",
    },
  }, root);
}

function fromMssEncryption(input?: s.MssEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toMssEncryption(root: jsonP.JSONValue): s.MssEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {},
  }, root);
}

function fromMssManifest(input?: s.MssManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    manifestName: input["ManifestName"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}
function toMssManifest(root: jsonP.JSONValue): s.MssManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManifestName": "s",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

function fromAuthorization(input?: s.Authorization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cdnIdentifierSecret: input["CdnIdentifierSecret"],
    secretsRoleArn: input["SecretsRoleArn"],
  }
}
function toAuthorization(root: jsonP.JSONValue): s.Authorization {
  return jsonP.readObj({
    required: {
      "CdnIdentifierSecret": "s",
      "SecretsRoleArn": "s",
    },
    optional: {},
  }, root);
}

function toEgressEndpoint(root: jsonP.JSONValue): s.EgressEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackagingConfigurationId": "s",
      "Url": "s",
    },
  }, root);
}

function toAssetShallow(root: jsonP.JSONValue): s.AssetShallow {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CreatedAt": "s",
      "Id": "s",
      "PackagingGroupId": "s",
      "ResourceId": "s",
      "SourceArn": "s",
      "SourceRoleArn": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toPackagingConfiguration(root: jsonP.JSONValue): s.PackagingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CmafPackage": toCmafPackage,
      "DashPackage": toDashPackage,
      "HlsPackage": toHlsPackage,
      "Id": "s",
      "MssPackage": toMssPackage,
      "PackagingGroupId": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toPackagingGroup(root: jsonP.JSONValue): s.PackagingGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Authorization": toAuthorization,
      "DomainName": "s",
      "EgressAccessLogs": toEgressAccessLogs,
      "Id": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
