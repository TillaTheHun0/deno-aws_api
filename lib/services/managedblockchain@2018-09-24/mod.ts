// Autogenerated API client for: Amazon Managed Blockchain

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class ManagedBlockchain {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ManagedBlockchain.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-09-24",
    "endpointPrefix": "managedblockchain",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "ManagedBlockchain",
    "serviceFullName": "Amazon Managed Blockchain",
    "serviceId": "ManagedBlockchain",
    "signatureVersion": "v4",
    "signingName": "managedblockchain",
    "uid": "managedblockchain-2018-09-24"
  };

  async createMember(
    {abortSignal, ...params}: RequestConfig & s.CreateMemberInput,
  ): Promise<s.CreateMemberOutput> {
    const body: jsonP.JSONObject = {
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      InvitationId: params["InvitationId"],
      MemberConfiguration: fromMemberConfiguration(params["MemberConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMember",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/members`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MemberId": "s",
      },
    }, await resp.json());
  }

  async createNetwork(
    {abortSignal, ...params}: RequestConfig & s.CreateNetworkInput,
  ): Promise<s.CreateNetworkOutput> {
    const body: jsonP.JSONObject = {
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Name: params["Name"],
      Description: params["Description"],
      Framework: params["Framework"],
      FrameworkVersion: params["FrameworkVersion"],
      FrameworkConfiguration: fromNetworkFrameworkConfiguration(params["FrameworkConfiguration"]),
      VotingPolicy: fromVotingPolicy(params["VotingPolicy"]),
      MemberConfiguration: fromMemberConfiguration(params["MemberConfiguration"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetwork",
      requestUri: "/networks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NetworkId": "s",
        "MemberId": "s",
      },
    }, await resp.json());
  }

  async createNode(
    {abortSignal, ...params}: RequestConfig & s.CreateNodeInput,
  ): Promise<s.CreateNodeOutput> {
    const body: jsonP.JSONObject = {
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      MemberId: params["MemberId"],
      NodeConfiguration: fromNodeConfiguration(params["NodeConfiguration"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNode",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/nodes`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NodeId": "s",
      },
    }, await resp.json());
  }

  async createProposal(
    {abortSignal, ...params}: RequestConfig & s.CreateProposalInput,
  ): Promise<s.CreateProposalOutput> {
    const body: jsonP.JSONObject = {
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      MemberId: params["MemberId"],
      Actions: fromProposalActions(params["Actions"]),
      Description: params["Description"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProposal",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/proposals`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProposalId": "s",
      },
    }, await resp.json());
  }

  async deleteMember(
    {abortSignal, ...params}: RequestConfig & s.DeleteMemberInput,
  ): Promise<s.DeleteMemberOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMember",
      method: "DELETE",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/members/${params["MemberId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteNode(
    {abortSignal, ...params}: RequestConfig & s.DeleteNodeInput,
  ): Promise<s.DeleteNodeOutput> {
    const query = new URLSearchParams;
    if (params["MemberId"] != null) query.set("memberId", params["MemberId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteNode",
      method: "DELETE",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/nodes/${params["NodeId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getMember(
    {abortSignal, ...params}: RequestConfig & s.GetMemberInput,
  ): Promise<s.GetMemberOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMember",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/members/${params["MemberId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Member": toMember,
      },
    }, await resp.json());
  }

  async getNetwork(
    {abortSignal, ...params}: RequestConfig & s.GetNetworkInput,
  ): Promise<s.GetNetworkOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetNetwork",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Network": toNetwork,
      },
    }, await resp.json());
  }

  async getNode(
    {abortSignal, ...params}: RequestConfig & s.GetNodeInput,
  ): Promise<s.GetNodeOutput> {
    const query = new URLSearchParams;
    if (params["MemberId"] != null) query.set("memberId", params["MemberId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetNode",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/nodes/${params["NodeId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Node": toNode,
      },
    }, await resp.json());
  }

  async getProposal(
    {abortSignal, ...params}: RequestConfig & s.GetProposalInput,
  ): Promise<s.GetProposalOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetProposal",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/proposals/${params["ProposalId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Proposal": toProposal,
      },
    }, await resp.json());
  }

  async listInvitations(
    {abortSignal, ...params}: RequestConfig & s.ListInvitationsInput = {},
  ): Promise<s.ListInvitationsOutput> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvitations",
      method: "GET",
      requestUri: "/invitations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Invitations": [toInvitation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMembers(
    {abortSignal, ...params}: RequestConfig & s.ListMembersInput,
  ): Promise<s.ListMembersOutput> {
    const query = new URLSearchParams;
    if (params["Name"] != null) query.set("name", params["Name"]?.toString() ?? "");
    if (params["Status"] != null) query.set("status", params["Status"]?.toString() ?? "");
    if (params["IsOwned"] != null) query.set("isOwned", params["IsOwned"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMembers",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/members`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Members": [toMemberSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNetworks(
    {abortSignal, ...params}: RequestConfig & s.ListNetworksInput = {},
  ): Promise<s.ListNetworksOutput> {
    const query = new URLSearchParams;
    if (params["Name"] != null) query.set("name", params["Name"]?.toString() ?? "");
    if (params["Framework"] != null) query.set("framework", params["Framework"]?.toString() ?? "");
    if (params["Status"] != null) query.set("status", params["Status"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNetworks",
      method: "GET",
      requestUri: "/networks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Networks": [toNetworkSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNodes(
    {abortSignal, ...params}: RequestConfig & s.ListNodesInput,
  ): Promise<s.ListNodesOutput> {
    const query = new URLSearchParams;
    if (params["MemberId"] != null) query.set("memberId", params["MemberId"]?.toString() ?? "");
    if (params["Status"] != null) query.set("status", params["Status"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListNodes",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/nodes`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Nodes": [toNodeSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProposalVotes(
    {abortSignal, ...params}: RequestConfig & s.ListProposalVotesInput,
  ): Promise<s.ListProposalVotesOutput> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProposalVotes",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/proposals/${params["ProposalId"]}/votes`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProposalVotes": [toVoteSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProposals(
    {abortSignal, ...params}: RequestConfig & s.ListProposalsInput,
  ): Promise<s.ListProposalsOutput> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProposals",
      method: "GET",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/proposals`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Proposals": [toProposalSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rejectInvitation(
    {abortSignal, ...params}: RequestConfig & s.RejectInvitationInput,
  ): Promise<s.RejectInvitationOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RejectInvitation",
      method: "DELETE",
      requestUri: cmnP.encodePath`/invitations/${params["InvitationId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateMember(
    {abortSignal, ...params}: RequestConfig & s.UpdateMemberInput,
  ): Promise<s.UpdateMemberOutput> {
    const body: jsonP.JSONObject = {
      LogPublishingConfiguration: fromMemberLogPublishingConfiguration(params["LogPublishingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMember",
      method: "PATCH",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/members/${params["MemberId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateNode(
    {abortSignal, ...params}: RequestConfig & s.UpdateNodeInput,
  ): Promise<s.UpdateNodeOutput> {
    const body: jsonP.JSONObject = {
      MemberId: params["MemberId"],
      LogPublishingConfiguration: fromNodeLogPublishingConfiguration(params["LogPublishingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNode",
      method: "PATCH",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/nodes/${params["NodeId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async voteOnProposal(
    {abortSignal, ...params}: RequestConfig & s.VoteOnProposalInput,
  ): Promise<s.VoteOnProposalOutput> {
    const body: jsonP.JSONObject = {
      VoterMemberId: params["VoterMemberId"],
      Vote: params["Vote"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VoteOnProposal",
      requestUri: cmnP.encodePath`/networks/${params["NetworkId"]}/proposals/${params["ProposalId"]}/votes`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromMemberConfiguration(input?: s.MemberConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    FrameworkConfiguration: fromMemberFrameworkConfiguration(input["FrameworkConfiguration"]),
    LogPublishingConfiguration: fromMemberLogPublishingConfiguration(input["LogPublishingConfiguration"]),
    Tags: input["Tags"],
  }
}

function fromMemberFrameworkConfiguration(input?: s.MemberFrameworkConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Fabric: fromMemberFabricConfiguration(input["Fabric"]),
  }
}

function fromMemberFabricConfiguration(input?: s.MemberFabricConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdminUsername: input["AdminUsername"],
    AdminPassword: input["AdminPassword"],
  }
}

function fromMemberLogPublishingConfiguration(input?: s.MemberLogPublishingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Fabric: fromMemberFabricLogPublishingConfiguration(input["Fabric"]),
  }
}
function toMemberLogPublishingConfiguration(root: jsonP.JSONValue): s.MemberLogPublishingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Fabric": toMemberFabricLogPublishingConfiguration,
    },
  }, root);
}

function fromMemberFabricLogPublishingConfiguration(input?: s.MemberFabricLogPublishingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CaLogs: fromLogConfigurations(input["CaLogs"]),
  }
}
function toMemberFabricLogPublishingConfiguration(root: jsonP.JSONValue): s.MemberFabricLogPublishingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaLogs": toLogConfigurations,
    },
  }, root);
}

function fromLogConfigurations(input?: s.LogConfigurations | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Cloudwatch: fromLogConfiguration(input["Cloudwatch"]),
  }
}
function toLogConfigurations(root: jsonP.JSONValue): s.LogConfigurations {
  return jsonP.readObj({
    required: {},
    optional: {
      "Cloudwatch": toLogConfiguration,
    },
  }, root);
}

function fromLogConfiguration(input?: s.LogConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toLogConfiguration(root: jsonP.JSONValue): s.LogConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromNetworkFrameworkConfiguration(input?: s.NetworkFrameworkConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Fabric: fromNetworkFabricConfiguration(input["Fabric"]),
  }
}

function fromNetworkFabricConfiguration(input?: s.NetworkFabricConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Edition: input["Edition"],
  }
}

function fromVotingPolicy(input?: s.VotingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApprovalThresholdPolicy: fromApprovalThresholdPolicy(input["ApprovalThresholdPolicy"]),
  }
}
function toVotingPolicy(root: jsonP.JSONValue): s.VotingPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApprovalThresholdPolicy": toApprovalThresholdPolicy,
    },
  }, root);
}

function fromApprovalThresholdPolicy(input?: s.ApprovalThresholdPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ThresholdPercentage: input["ThresholdPercentage"],
    ProposalDurationInHours: input["ProposalDurationInHours"],
    ThresholdComparator: input["ThresholdComparator"],
  }
}
function toApprovalThresholdPolicy(root: jsonP.JSONValue): s.ApprovalThresholdPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "ThresholdPercentage": "n",
      "ProposalDurationInHours": "n",
      "ThresholdComparator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThresholdComparator>(x),
    },
  }, root);
}

function fromNodeConfiguration(input?: s.NodeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    AvailabilityZone: input["AvailabilityZone"],
    LogPublishingConfiguration: fromNodeLogPublishingConfiguration(input["LogPublishingConfiguration"]),
    StateDB: input["StateDB"],
  }
}

function fromNodeLogPublishingConfiguration(input?: s.NodeLogPublishingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Fabric: fromNodeFabricLogPublishingConfiguration(input["Fabric"]),
  }
}
function toNodeLogPublishingConfiguration(root: jsonP.JSONValue): s.NodeLogPublishingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Fabric": toNodeFabricLogPublishingConfiguration,
    },
  }, root);
}

function fromNodeFabricLogPublishingConfiguration(input?: s.NodeFabricLogPublishingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ChaincodeLogs: fromLogConfigurations(input["ChaincodeLogs"]),
    PeerLogs: fromLogConfigurations(input["PeerLogs"]),
  }
}
function toNodeFabricLogPublishingConfiguration(root: jsonP.JSONValue): s.NodeFabricLogPublishingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChaincodeLogs": toLogConfigurations,
      "PeerLogs": toLogConfigurations,
    },
  }, root);
}

function fromProposalActions(input?: s.ProposalActions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Invitations: input["Invitations"]?.map(x => fromInviteAction(x)),
    Removals: input["Removals"]?.map(x => fromRemoveAction(x)),
  }
}
function toProposalActions(root: jsonP.JSONValue): s.ProposalActions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Invitations": [toInviteAction],
      "Removals": [toRemoveAction],
    },
  }, root);
}

function fromInviteAction(input?: s.InviteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principal: input["Principal"],
  }
}
function toInviteAction(root: jsonP.JSONValue): s.InviteAction {
  return jsonP.readObj({
    required: {
      "Principal": "s",
    },
    optional: {},
  }, root);
}

function fromRemoveAction(input?: s.RemoveAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MemberId: input["MemberId"],
  }
}
function toRemoveAction(root: jsonP.JSONValue): s.RemoveAction {
  return jsonP.readObj({
    required: {
      "MemberId": "s",
    },
    optional: {},
  }, root);
}

function toMember(root: jsonP.JSONValue): s.Member {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetworkId": "s",
      "Id": "s",
      "Name": "s",
      "Description": "s",
      "FrameworkAttributes": toMemberFrameworkAttributes,
      "LogPublishingConfiguration": toMemberLogPublishingConfiguration,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MemberStatus>(x),
      "CreationDate": "d",
      "Tags": x => jsonP.readMap(String, String, x),
      "Arn": "s",
    },
  }, root);
}

function toMemberFrameworkAttributes(root: jsonP.JSONValue): s.MemberFrameworkAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Fabric": toMemberFabricAttributes,
    },
  }, root);
}

function toMemberFabricAttributes(root: jsonP.JSONValue): s.MemberFabricAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdminUsername": "s",
      "CaEndpoint": "s",
    },
  }, root);
}

function toNetwork(root: jsonP.JSONValue): s.Network {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Description": "s",
      "Framework": (x: jsonP.JSONValue) => cmnP.readEnum<s.Framework>(x),
      "FrameworkVersion": "s",
      "FrameworkAttributes": toNetworkFrameworkAttributes,
      "VpcEndpointServiceName": "s",
      "VotingPolicy": toVotingPolicy,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkStatus>(x),
      "CreationDate": "d",
      "Tags": x => jsonP.readMap(String, String, x),
      "Arn": "s",
    },
  }, root);
}

function toNetworkFrameworkAttributes(root: jsonP.JSONValue): s.NetworkFrameworkAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Fabric": toNetworkFabricAttributes,
      "Ethereum": toNetworkEthereumAttributes,
    },
  }, root);
}

function toNetworkFabricAttributes(root: jsonP.JSONValue): s.NetworkFabricAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "OrderingServiceEndpoint": "s",
      "Edition": (x: jsonP.JSONValue) => cmnP.readEnum<s.Edition>(x),
    },
  }, root);
}

function toNetworkEthereumAttributes(root: jsonP.JSONValue): s.NetworkEthereumAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChainId": "s",
    },
  }, root);
}

function toNode(root: jsonP.JSONValue): s.Node {
  return jsonP.readObj({
    required: {},
    optional: {
      "NetworkId": "s",
      "MemberId": "s",
      "Id": "s",
      "InstanceType": "s",
      "AvailabilityZone": "s",
      "FrameworkAttributes": toNodeFrameworkAttributes,
      "LogPublishingConfiguration": toNodeLogPublishingConfiguration,
      "StateDB": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateDBType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodeStatus>(x),
      "CreationDate": "d",
      "Tags": x => jsonP.readMap(String, String, x),
      "Arn": "s",
    },
  }, root);
}

function toNodeFrameworkAttributes(root: jsonP.JSONValue): s.NodeFrameworkAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Fabric": toNodeFabricAttributes,
      "Ethereum": toNodeEthereumAttributes,
    },
  }, root);
}

function toNodeFabricAttributes(root: jsonP.JSONValue): s.NodeFabricAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "PeerEndpoint": "s",
      "PeerEventEndpoint": "s",
    },
  }, root);
}

function toNodeEthereumAttributes(root: jsonP.JSONValue): s.NodeEthereumAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "HttpEndpoint": "s",
      "WebSocketEndpoint": "s",
    },
  }, root);
}

function toProposal(root: jsonP.JSONValue): s.Proposal {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProposalId": "s",
      "NetworkId": "s",
      "Description": "s",
      "Actions": toProposalActions,
      "ProposedByMemberId": "s",
      "ProposedByMemberName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProposalStatus>(x),
      "CreationDate": "d",
      "ExpirationDate": "d",
      "YesVoteCount": "n",
      "NoVoteCount": "n",
      "OutstandingVoteCount": "n",
      "Tags": x => jsonP.readMap(String, String, x),
      "Arn": "s",
    },
  }, root);
}

function toInvitation(root: jsonP.JSONValue): s.Invitation {
  return jsonP.readObj({
    required: {},
    optional: {
      "InvitationId": "s",
      "CreationDate": "d",
      "ExpirationDate": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.InvitationStatus>(x),
      "NetworkSummary": toNetworkSummary,
      "Arn": "s",
    },
  }, root);
}

function toNetworkSummary(root: jsonP.JSONValue): s.NetworkSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Description": "s",
      "Framework": (x: jsonP.JSONValue) => cmnP.readEnum<s.Framework>(x),
      "FrameworkVersion": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkStatus>(x),
      "CreationDate": "d",
      "Arn": "s",
    },
  }, root);
}

function toMemberSummary(root: jsonP.JSONValue): s.MemberSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MemberStatus>(x),
      "CreationDate": "d",
      "IsOwned": "b",
      "Arn": "s",
    },
  }, root);
}

function toNodeSummary(root: jsonP.JSONValue): s.NodeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodeStatus>(x),
      "CreationDate": "d",
      "AvailabilityZone": "s",
      "InstanceType": "s",
      "Arn": "s",
    },
  }, root);
}

function toVoteSummary(root: jsonP.JSONValue): s.VoteSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Vote": (x: jsonP.JSONValue) => cmnP.readEnum<s.VoteValue>(x),
      "MemberName": "s",
      "MemberId": "s",
    },
  }, root);
}

function toProposalSummary(root: jsonP.JSONValue): s.ProposalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProposalId": "s",
      "Description": "s",
      "ProposedByMemberId": "s",
      "ProposedByMemberName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProposalStatus>(x),
      "CreationDate": "d",
      "ExpirationDate": "d",
      "Arn": "s",
    },
  }, root);
}
