// Autogenerated API client for: Amazon Kinesis Analytics

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class KinesisAnalytics {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KinesisAnalytics.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-08-14",
    "endpointPrefix": "kinesisanalytics",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Kinesis Analytics",
    "serviceFullName": "Amazon Kinesis Analytics",
    "serviceId": "Kinesis Analytics",
    "signatureVersion": "v4",
    "targetPrefix": "KinesisAnalytics_20150814",
    "uid": "kinesisanalytics-2015-08-14"
  };

  async addApplicationCloudWatchLoggingOption(
    {abortSignal, ...params}: RequestConfig & s.AddApplicationCloudWatchLoggingOptionRequest,
  ): Promise<s.AddApplicationCloudWatchLoggingOptionResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      CloudWatchLoggingOption: fromCloudWatchLoggingOption(params["CloudWatchLoggingOption"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddApplicationCloudWatchLoggingOption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addApplicationInput(
    {abortSignal, ...params}: RequestConfig & s.AddApplicationInputRequest,
  ): Promise<s.AddApplicationInputResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      Input: fromInput(params["Input"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddApplicationInput",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addApplicationInputProcessingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.AddApplicationInputProcessingConfigurationRequest,
  ): Promise<s.AddApplicationInputProcessingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      InputId: params["InputId"],
      InputProcessingConfiguration: fromInputProcessingConfiguration(params["InputProcessingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddApplicationInputProcessingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addApplicationOutput(
    {abortSignal, ...params}: RequestConfig & s.AddApplicationOutputRequest,
  ): Promise<s.AddApplicationOutputResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      Output: fromOutput(params["Output"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddApplicationOutput",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addApplicationReferenceDataSource(
    {abortSignal, ...params}: RequestConfig & s.AddApplicationReferenceDataSourceRequest,
  ): Promise<s.AddApplicationReferenceDataSourceResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      ReferenceDataSource: fromReferenceDataSource(params["ReferenceDataSource"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddApplicationReferenceDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateApplicationRequest,
  ): Promise<s.CreateApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      ApplicationDescription: params["ApplicationDescription"],
      Inputs: params["Inputs"]?.map(x => fromInput(x)),
      Outputs: params["Outputs"]?.map(x => fromOutput(x)),
      CloudWatchLoggingOptions: params["CloudWatchLoggingOptions"]?.map(x => fromCloudWatchLoggingOption(x)),
      ApplicationCode: params["ApplicationCode"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
    });
    return jsonP.readObj({
      required: {
        "ApplicationSummary": toApplicationSummary,
      },
      optional: {},
    }, await resp.json());
  }

  async deleteApplication(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationRequest,
  ): Promise<s.DeleteApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CreateTimestamp: jsonP.serializeDate_unixTimestamp(params["CreateTimestamp"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApplicationCloudWatchLoggingOption(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationCloudWatchLoggingOptionRequest,
  ): Promise<s.DeleteApplicationCloudWatchLoggingOptionResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      CloudWatchLoggingOptionId: params["CloudWatchLoggingOptionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplicationCloudWatchLoggingOption",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApplicationInputProcessingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationInputProcessingConfigurationRequest,
  ): Promise<s.DeleteApplicationInputProcessingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      InputId: params["InputId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplicationInputProcessingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApplicationOutput(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationOutputRequest,
  ): Promise<s.DeleteApplicationOutputResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      OutputId: params["OutputId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplicationOutput",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteApplicationReferenceDataSource(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationReferenceDataSourceRequest,
  ): Promise<s.DeleteApplicationReferenceDataSourceResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      ReferenceId: params["ReferenceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplicationReferenceDataSource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeApplication(
    {abortSignal, ...params}: RequestConfig & s.DescribeApplicationRequest,
  ): Promise<s.DescribeApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApplication",
    });
    return jsonP.readObj({
      required: {
        "ApplicationDetail": toApplicationDetail,
      },
      optional: {},
    }, await resp.json());
  }

  async discoverInputSchema(
    {abortSignal, ...params}: RequestConfig & s.DiscoverInputSchemaRequest = {},
  ): Promise<s.DiscoverInputSchemaResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      RoleARN: params["RoleARN"],
      InputStartingPositionConfiguration: fromInputStartingPositionConfiguration(params["InputStartingPositionConfiguration"]),
      S3Configuration: fromS3Configuration(params["S3Configuration"]),
      InputProcessingConfiguration: fromInputProcessingConfiguration(params["InputProcessingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DiscoverInputSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputSchema": toSourceSchema,
        "ParsedInputRecords": [x => jsonP.readList(String, x)],
        "ProcessedInputRecords": ["s"],
        "RawInputRecords": ["s"],
      },
    }, await resp.json());
  }

  async listApplications(
    {abortSignal, ...params}: RequestConfig & s.ListApplicationsRequest = {},
  ): Promise<s.ListApplicationsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      ExclusiveStartApplicationName: params["ExclusiveStartApplicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApplications",
    });
    return jsonP.readObj({
      required: {
        "ApplicationSummaries": [toApplicationSummary],
        "HasMoreApplications": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async startApplication(
    {abortSignal, ...params}: RequestConfig & s.StartApplicationRequest,
  ): Promise<s.StartApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      InputConfigurations: params["InputConfigurations"]?.map(x => fromInputConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopApplication(
    {abortSignal, ...params}: RequestConfig & s.StopApplicationRequest,
  ): Promise<s.StopApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationRequest,
  ): Promise<s.UpdateApplicationResponse> {
    const body: jsonP.JSONObject = {
      ApplicationName: params["ApplicationName"],
      CurrentApplicationVersionId: params["CurrentApplicationVersionId"],
      ApplicationUpdate: fromApplicationUpdate(params["ApplicationUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromCloudWatchLoggingOption(input?: s.CloudWatchLoggingOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogStreamARN: input["LogStreamARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromInput(input?: s.Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NamePrefix: input["NamePrefix"],
    InputProcessingConfiguration: fromInputProcessingConfiguration(input["InputProcessingConfiguration"]),
    KinesisStreamsInput: fromKinesisStreamsInput(input["KinesisStreamsInput"]),
    KinesisFirehoseInput: fromKinesisFirehoseInput(input["KinesisFirehoseInput"]),
    InputParallelism: fromInputParallelism(input["InputParallelism"]),
    InputSchema: fromSourceSchema(input["InputSchema"]),
  }
}

function fromInputProcessingConfiguration(input?: s.InputProcessingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputLambdaProcessor: fromInputLambdaProcessor(input["InputLambdaProcessor"]),
  }
}

function fromInputLambdaProcessor(input?: s.InputLambdaProcessor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromKinesisStreamsInput(input?: s.KinesisStreamsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromKinesisFirehoseInput(input?: s.KinesisFirehoseInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromInputParallelism(input?: s.InputParallelism | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Count: input["Count"],
  }
}
function toInputParallelism(root: jsonP.JSONValue): s.InputParallelism {
  return jsonP.readObj({
    required: {},
    optional: {
      "Count": "n",
    },
  }, root);
}

function fromSourceSchema(input?: s.SourceSchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordFormat: fromRecordFormat(input["RecordFormat"]),
    RecordEncoding: input["RecordEncoding"],
    RecordColumns: input["RecordColumns"]?.map(x => fromRecordColumn(x)),
  }
}
function toSourceSchema(root: jsonP.JSONValue): s.SourceSchema {
  return jsonP.readObj({
    required: {
      "RecordFormat": toRecordFormat,
      "RecordColumns": [toRecordColumn],
    },
    optional: {
      "RecordEncoding": "s",
    },
  }, root);
}

function fromRecordFormat(input?: s.RecordFormat | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordFormatType: input["RecordFormatType"],
    MappingParameters: fromMappingParameters(input["MappingParameters"]),
  }
}
function toRecordFormat(root: jsonP.JSONValue): s.RecordFormat {
  return jsonP.readObj({
    required: {
      "RecordFormatType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordFormatType>(x),
    },
    optional: {
      "MappingParameters": toMappingParameters,
    },
  }, root);
}

function fromMappingParameters(input?: s.MappingParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JSONMappingParameters: fromJSONMappingParameters(input["JSONMappingParameters"]),
    CSVMappingParameters: fromCSVMappingParameters(input["CSVMappingParameters"]),
  }
}
function toMappingParameters(root: jsonP.JSONValue): s.MappingParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "JSONMappingParameters": toJSONMappingParameters,
      "CSVMappingParameters": toCSVMappingParameters,
    },
  }, root);
}

function fromJSONMappingParameters(input?: s.JSONMappingParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordRowPath: input["RecordRowPath"],
  }
}
function toJSONMappingParameters(root: jsonP.JSONValue): s.JSONMappingParameters {
  return jsonP.readObj({
    required: {
      "RecordRowPath": "s",
    },
    optional: {},
  }, root);
}

function fromCSVMappingParameters(input?: s.CSVMappingParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordRowDelimiter: input["RecordRowDelimiter"],
    RecordColumnDelimiter: input["RecordColumnDelimiter"],
  }
}
function toCSVMappingParameters(root: jsonP.JSONValue): s.CSVMappingParameters {
  return jsonP.readObj({
    required: {
      "RecordRowDelimiter": "s",
      "RecordColumnDelimiter": "s",
    },
    optional: {},
  }, root);
}

function fromRecordColumn(input?: s.RecordColumn | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Mapping: input["Mapping"],
    SqlType: input["SqlType"],
  }
}
function toRecordColumn(root: jsonP.JSONValue): s.RecordColumn {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "SqlType": "s",
    },
    optional: {
      "Mapping": "s",
    },
  }, root);
}

function fromOutput(input?: s.Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    KinesisStreamsOutput: fromKinesisStreamsOutput(input["KinesisStreamsOutput"]),
    KinesisFirehoseOutput: fromKinesisFirehoseOutput(input["KinesisFirehoseOutput"]),
    LambdaOutput: fromLambdaOutput(input["LambdaOutput"]),
    DestinationSchema: fromDestinationSchema(input["DestinationSchema"]),
  }
}

function fromKinesisStreamsOutput(input?: s.KinesisStreamsOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromKinesisFirehoseOutput(input?: s.KinesisFirehoseOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromLambdaOutput(input?: s.LambdaOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARN: input["ResourceARN"],
    RoleARN: input["RoleARN"],
  }
}

function fromDestinationSchema(input?: s.DestinationSchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordFormatType: input["RecordFormatType"],
  }
}
function toDestinationSchema(root: jsonP.JSONValue): s.DestinationSchema {
  return jsonP.readObj({
    required: {
      "RecordFormatType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordFormatType>(x),
    },
    optional: {},
  }, root);
}

function fromReferenceDataSource(input?: s.ReferenceDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TableName: input["TableName"],
    S3ReferenceDataSource: fromS3ReferenceDataSource(input["S3ReferenceDataSource"]),
    ReferenceSchema: fromSourceSchema(input["ReferenceSchema"]),
  }
}

function fromS3ReferenceDataSource(input?: s.S3ReferenceDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BucketARN: input["BucketARN"],
    FileKey: input["FileKey"],
    ReferenceRoleARN: input["ReferenceRoleARN"],
  }
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromInputStartingPositionConfiguration(input?: s.InputStartingPositionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputStartingPosition: input["InputStartingPosition"],
  }
}
function toInputStartingPositionConfiguration(root: jsonP.JSONValue): s.InputStartingPositionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputStartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputStartingPosition>(x),
    },
  }, root);
}

function fromS3Configuration(input?: s.S3Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleARN: input["RoleARN"],
    BucketARN: input["BucketARN"],
    FileKey: input["FileKey"],
  }
}

function fromInputConfiguration(input?: s.InputConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    InputStartingPositionConfiguration: fromInputStartingPositionConfiguration(input["InputStartingPositionConfiguration"]),
  }
}

function fromApplicationUpdate(input?: s.ApplicationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputUpdates: input["InputUpdates"]?.map(x => fromInputUpdate(x)),
    ApplicationCodeUpdate: input["ApplicationCodeUpdate"],
    OutputUpdates: input["OutputUpdates"]?.map(x => fromOutputUpdate(x)),
    ReferenceDataSourceUpdates: input["ReferenceDataSourceUpdates"]?.map(x => fromReferenceDataSourceUpdate(x)),
    CloudWatchLoggingOptionUpdates: input["CloudWatchLoggingOptionUpdates"]?.map(x => fromCloudWatchLoggingOptionUpdate(x)),
  }
}

function fromInputUpdate(input?: s.InputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputId: input["InputId"],
    NamePrefixUpdate: input["NamePrefixUpdate"],
    InputProcessingConfigurationUpdate: fromInputProcessingConfigurationUpdate(input["InputProcessingConfigurationUpdate"]),
    KinesisStreamsInputUpdate: fromKinesisStreamsInputUpdate(input["KinesisStreamsInputUpdate"]),
    KinesisFirehoseInputUpdate: fromKinesisFirehoseInputUpdate(input["KinesisFirehoseInputUpdate"]),
    InputSchemaUpdate: fromInputSchemaUpdate(input["InputSchemaUpdate"]),
    InputParallelismUpdate: fromInputParallelismUpdate(input["InputParallelismUpdate"]),
  }
}

function fromInputProcessingConfigurationUpdate(input?: s.InputProcessingConfigurationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputLambdaProcessorUpdate: fromInputLambdaProcessorUpdate(input["InputLambdaProcessorUpdate"]),
  }
}

function fromInputLambdaProcessorUpdate(input?: s.InputLambdaProcessorUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromKinesisStreamsInputUpdate(input?: s.KinesisStreamsInputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromKinesisFirehoseInputUpdate(input?: s.KinesisFirehoseInputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromInputSchemaUpdate(input?: s.InputSchemaUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecordFormatUpdate: fromRecordFormat(input["RecordFormatUpdate"]),
    RecordEncodingUpdate: input["RecordEncodingUpdate"],
    RecordColumnUpdates: input["RecordColumnUpdates"]?.map(x => fromRecordColumn(x)),
  }
}

function fromInputParallelismUpdate(input?: s.InputParallelismUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CountUpdate: input["CountUpdate"],
  }
}

function fromOutputUpdate(input?: s.OutputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OutputId: input["OutputId"],
    NameUpdate: input["NameUpdate"],
    KinesisStreamsOutputUpdate: fromKinesisStreamsOutputUpdate(input["KinesisStreamsOutputUpdate"]),
    KinesisFirehoseOutputUpdate: fromKinesisFirehoseOutputUpdate(input["KinesisFirehoseOutputUpdate"]),
    LambdaOutputUpdate: fromLambdaOutputUpdate(input["LambdaOutputUpdate"]),
    DestinationSchemaUpdate: fromDestinationSchema(input["DestinationSchemaUpdate"]),
  }
}

function fromKinesisStreamsOutputUpdate(input?: s.KinesisStreamsOutputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromKinesisFirehoseOutputUpdate(input?: s.KinesisFirehoseOutputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromLambdaOutputUpdate(input?: s.LambdaOutputUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceARNUpdate: input["ResourceARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function fromReferenceDataSourceUpdate(input?: s.ReferenceDataSourceUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReferenceId: input["ReferenceId"],
    TableNameUpdate: input["TableNameUpdate"],
    S3ReferenceDataSourceUpdate: fromS3ReferenceDataSourceUpdate(input["S3ReferenceDataSourceUpdate"]),
    ReferenceSchemaUpdate: fromSourceSchema(input["ReferenceSchemaUpdate"]),
  }
}

function fromS3ReferenceDataSourceUpdate(input?: s.S3ReferenceDataSourceUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BucketARNUpdate: input["BucketARNUpdate"],
    FileKeyUpdate: input["FileKeyUpdate"],
    ReferenceRoleARNUpdate: input["ReferenceRoleARNUpdate"],
  }
}

function fromCloudWatchLoggingOptionUpdate(input?: s.CloudWatchLoggingOptionUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchLoggingOptionId: input["CloudWatchLoggingOptionId"],
    LogStreamARNUpdate: input["LogStreamARNUpdate"],
    RoleARNUpdate: input["RoleARNUpdate"],
  }
}

function toApplicationSummary(root: jsonP.JSONValue): s.ApplicationSummary {
  return jsonP.readObj({
    required: {
      "ApplicationName": "s",
      "ApplicationARN": "s",
      "ApplicationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApplicationStatus>(x),
    },
    optional: {},
  }, root);
}

function toApplicationDetail(root: jsonP.JSONValue): s.ApplicationDetail {
  return jsonP.readObj({
    required: {
      "ApplicationName": "s",
      "ApplicationARN": "s",
      "ApplicationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApplicationStatus>(x),
      "ApplicationVersionId": "n",
    },
    optional: {
      "ApplicationDescription": "s",
      "CreateTimestamp": "d",
      "LastUpdateTimestamp": "d",
      "InputDescriptions": [toInputDescription],
      "OutputDescriptions": [toOutputDescription],
      "ReferenceDataSourceDescriptions": [toReferenceDataSourceDescription],
      "CloudWatchLoggingOptionDescriptions": [toCloudWatchLoggingOptionDescription],
      "ApplicationCode": "s",
    },
  }, root);
}

function toInputDescription(root: jsonP.JSONValue): s.InputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputId": "s",
      "NamePrefix": "s",
      "InAppStreamNames": ["s"],
      "InputProcessingConfigurationDescription": toInputProcessingConfigurationDescription,
      "KinesisStreamsInputDescription": toKinesisStreamsInputDescription,
      "KinesisFirehoseInputDescription": toKinesisFirehoseInputDescription,
      "InputSchema": toSourceSchema,
      "InputParallelism": toInputParallelism,
      "InputStartingPositionConfiguration": toInputStartingPositionConfiguration,
    },
  }, root);
}

function toInputProcessingConfigurationDescription(root: jsonP.JSONValue): s.InputProcessingConfigurationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputLambdaProcessorDescription": toInputLambdaProcessorDescription,
    },
  }, root);
}

function toInputLambdaProcessorDescription(root: jsonP.JSONValue): s.InputLambdaProcessorDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toKinesisStreamsInputDescription(root: jsonP.JSONValue): s.KinesisStreamsInputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toKinesisFirehoseInputDescription(root: jsonP.JSONValue): s.KinesisFirehoseInputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toOutputDescription(root: jsonP.JSONValue): s.OutputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputId": "s",
      "Name": "s",
      "KinesisStreamsOutputDescription": toKinesisStreamsOutputDescription,
      "KinesisFirehoseOutputDescription": toKinesisFirehoseOutputDescription,
      "LambdaOutputDescription": toLambdaOutputDescription,
      "DestinationSchema": toDestinationSchema,
    },
  }, root);
}

function toKinesisStreamsOutputDescription(root: jsonP.JSONValue): s.KinesisStreamsOutputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toKinesisFirehoseOutputDescription(root: jsonP.JSONValue): s.KinesisFirehoseOutputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toLambdaOutputDescription(root: jsonP.JSONValue): s.LambdaOutputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "RoleARN": "s",
    },
  }, root);
}

function toReferenceDataSourceDescription(root: jsonP.JSONValue): s.ReferenceDataSourceDescription {
  return jsonP.readObj({
    required: {
      "ReferenceId": "s",
      "TableName": "s",
      "S3ReferenceDataSourceDescription": toS3ReferenceDataSourceDescription,
    },
    optional: {
      "ReferenceSchema": toSourceSchema,
    },
  }, root);
}

function toS3ReferenceDataSourceDescription(root: jsonP.JSONValue): s.S3ReferenceDataSourceDescription {
  return jsonP.readObj({
    required: {
      "BucketARN": "s",
      "FileKey": "s",
      "ReferenceRoleARN": "s",
    },
    optional: {},
  }, root);
}

function toCloudWatchLoggingOptionDescription(root: jsonP.JSONValue): s.CloudWatchLoggingOptionDescription {
  return jsonP.readObj({
    required: {
      "LogStreamARN": "s",
      "RoleARN": "s",
    },
    optional: {
      "CloudWatchLoggingOptionId": "s",
    },
  }, root);
}
