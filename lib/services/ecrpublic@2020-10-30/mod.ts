// Autogenerated API client for: Amazon Elastic Container Registry Public

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ECRPUBLIC {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ECRPUBLIC.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-10-30",
    "endpointPrefix": "api.ecr-public",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon ECR Public",
    "serviceFullName": "Amazon Elastic Container Registry Public",
    "serviceId": "ECR PUBLIC",
    "signatureVersion": "v4",
    "signingName": "ecr-public",
    "targetPrefix": "SpencerFrontendService",
    "uid": "ecr-public-2020-10-30"
  };

  async batchCheckLayerAvailability(
    {abortSignal, ...params}: RequestConfig & BatchCheckLayerAvailabilityRequest,
  ): Promise<BatchCheckLayerAvailabilityResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      layerDigests: params["layerDigests"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCheckLayerAvailability",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "layers": [toLayer],
        "failures": [toLayerFailure],
      },
    }, await resp.json());
  }

  async batchDeleteImage(
    {abortSignal, ...params}: RequestConfig & BatchDeleteImageRequest,
  ): Promise<BatchDeleteImageResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageIds": [toImageIdentifier],
        "failures": [toImageFailure],
      },
    }, await resp.json());
  }

  async completeLayerUpload(
    {abortSignal, ...params}: RequestConfig & CompleteLayerUploadRequest,
  ): Promise<CompleteLayerUploadResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      layerDigests: params["layerDigests"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "layerDigest": "s",
      },
    }, await resp.json());
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & CreateRepositoryRequest,
  ): Promise<CreateRepositoryResponse> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      catalogData: fromRepositoryCatalogDataInput(params["catalogData"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
        "catalogData": toRepositoryCatalogData,
      },
    }, await resp.json());
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryRequest,
  ): Promise<DeleteRepositoryResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
      },
    }, await resp.json());
  }

  async deleteRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryPolicyRequest,
  ): Promise<DeleteRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async describeImageTags(
    {abortSignal, ...params}: RequestConfig & DescribeImageTagsRequest,
  ): Promise<DescribeImageTagsResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageTagDetails": [toImageTagDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeImages(
    {abortSignal, ...params}: RequestConfig & DescribeImagesRequest,
  ): Promise<DescribeImagesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageDetails": [toImageDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeRegistries(
    {abortSignal, ...params}: RequestConfig & DescribeRegistriesRequest = {},
  ): Promise<DescribeRegistriesResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRegistries",
    });
    return jsonP.readObj({
      required: {
        "registries": [toRegistry],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeRepositories(
    {abortSignal, ...params}: RequestConfig & DescribeRepositoriesRequest = {},
  ): Promise<DescribeRepositoriesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryNames: params["repositoryNames"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepository],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getAuthorizationToken(
    {abortSignal, ...params}: RequestConfig & GetAuthorizationTokenRequest = {},
  ): Promise<GetAuthorizationTokenResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAuthorizationToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizationData": toAuthorizationData,
      },
    }, await resp.json());
  }

  async getRegistryCatalogData(
    {abortSignal, ...params}: RequestConfig & GetRegistryCatalogDataRequest = {},
  ): Promise<GetRegistryCatalogDataResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegistryCatalogData",
    });
    return jsonP.readObj({
      required: {
        "registryCatalogData": toRegistryCatalogData,
      },
      optional: {},
    }, await resp.json());
  }

  async getRepositoryCatalogData(
    {abortSignal, ...params}: RequestConfig & GetRepositoryCatalogDataRequest,
  ): Promise<GetRepositoryCatalogDataResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepositoryCatalogData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "catalogData": toRepositoryCatalogData,
      },
    }, await resp.json());
  }

  async getRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & GetRepositoryPolicyRequest,
  ): Promise<GetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async initiateLayerUpload(
    {abortSignal, ...params}: RequestConfig & InitiateLayerUploadRequest,
  ): Promise<InitiateLayerUploadResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitiateLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "uploadId": "s",
        "partSize": "n",
      },
    }, await resp.json());
  }

  async putImage(
    {abortSignal, ...params}: RequestConfig & PutImageRequest,
  ): Promise<PutImageResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageManifest: params["imageManifest"],
      imageManifestMediaType: params["imageManifestMediaType"],
      imageTag: params["imageTag"],
      imageDigest: params["imageDigest"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "image": toImage,
      },
    }, await resp.json());
  }

  async putRegistryCatalogData(
    {abortSignal, ...params}: RequestConfig & PutRegistryCatalogDataRequest = {},
  ): Promise<PutRegistryCatalogDataResponse> {
    const body: jsonP.JSONObject = {
      displayName: params["displayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRegistryCatalogData",
    });
    return jsonP.readObj({
      required: {
        "registryCatalogData": toRegistryCatalogData,
      },
      optional: {},
    }, await resp.json());
  }

  async putRepositoryCatalogData(
    {abortSignal, ...params}: RequestConfig & PutRepositoryCatalogDataRequest,
  ): Promise<PutRepositoryCatalogDataResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      catalogData: fromRepositoryCatalogDataInput(params["catalogData"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRepositoryCatalogData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "catalogData": toRepositoryCatalogData,
      },
    }, await resp.json());
  }

  async setRepositoryPolicy(
    {abortSignal, ...params}: RequestConfig & SetRepositoryPolicyRequest,
  ): Promise<SetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      policyText: params["policyText"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async uploadLayerPart(
    {abortSignal, ...params}: RequestConfig & UploadLayerPartRequest,
  ): Promise<UploadLayerPartResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      partFirstByte: params["partFirstByte"],
      partLastByte: params["partLastByte"],
      layerPartBlob: jsonP.serializeBlob(params["layerPartBlob"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadLayerPart",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "lastByteReceived": "n",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchCheckLayerAvailabilityRequest {
  registryId?: string | null;
  repositoryName: string;
  layerDigests: string[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteImageRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds: ImageIdentifier[];
}

// refs: 1 - tags: named, input
export interface CompleteLayerUploadRequest {
  registryId?: string | null;
  repositoryName: string;
  uploadId: string;
  layerDigests: string[];
}

// refs: 1 - tags: named, input
export interface CreateRepositoryRequest {
  repositoryName: string;
  catalogData?: RepositoryCatalogDataInput | null;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryRequest {
  registryId?: string | null;
  repositoryName: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface DescribeImageTagsRequest {
  registryId?: string | null;
  repositoryName: string;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeImagesRequest {
  registryId?: string | null;
  repositoryName: string;
  imageIds?: ImageIdentifier[] | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeRegistriesRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeRepositoriesRequest {
  registryId?: string | null;
  repositoryNames?: string[] | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetAuthorizationTokenRequest {
}

// refs: 1 - tags: named, input
export interface GetRegistryCatalogDataRequest {
}

// refs: 1 - tags: named, input
export interface GetRepositoryCatalogDataRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface GetRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface InitiateLayerUploadRequest {
  registryId?: string | null;
  repositoryName: string;
}

// refs: 1 - tags: named, input
export interface PutImageRequest {
  registryId?: string | null;
  repositoryName: string;
  imageManifest: string;
  imageManifestMediaType?: string | null;
  imageTag?: string | null;
  imageDigest?: string | null;
}

// refs: 1 - tags: named, input
export interface PutRegistryCatalogDataRequest {
  displayName?: string | null;
}

// refs: 1 - tags: named, input
export interface PutRepositoryCatalogDataRequest {
  registryId?: string | null;
  repositoryName: string;
  catalogData: RepositoryCatalogDataInput;
}

// refs: 1 - tags: named, input
export interface SetRepositoryPolicyRequest {
  registryId?: string | null;
  repositoryName: string;
  policyText: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UploadLayerPartRequest {
  registryId?: string | null;
  repositoryName: string;
  uploadId: string;
  partFirstByte: number;
  partLastByte: number;
  layerPartBlob: Uint8Array | string;
}

// refs: 1 - tags: named, output
export interface BatchCheckLayerAvailabilityResponse {
  layers?: Layer[] | null;
  failures?: LayerFailure[] | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteImageResponse {
  imageIds?: ImageIdentifier[] | null;
  failures?: ImageFailure[] | null;
}

// refs: 1 - tags: named, output
export interface CompleteLayerUploadResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  uploadId?: string | null;
  layerDigest?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateRepositoryResponse {
  repository?: Repository | null;
  catalogData?: RepositoryCatalogData | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryResponse {
  repository?: Repository | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImageTagsResponse {
  imageTagDetails?: ImageTagDetail[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImagesResponse {
  imageDetails?: ImageDetail[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRegistriesResponse {
  registries: Registry[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRepositoriesResponse {
  repositories?: Repository[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAuthorizationTokenResponse {
  authorizationData?: AuthorizationData | null;
}

// refs: 1 - tags: named, output
export interface GetRegistryCatalogDataResponse {
  registryCatalogData: RegistryCatalogData;
}

// refs: 1 - tags: named, output
export interface GetRepositoryCatalogDataResponse {
  catalogData?: RepositoryCatalogData | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface InitiateLayerUploadResponse {
  uploadId?: string | null;
  partSize?: number | null;
}

// refs: 1 - tags: named, output
export interface PutImageResponse {
  image?: Image | null;
}

// refs: 1 - tags: named, output
export interface PutRegistryCatalogDataResponse {
  registryCatalogData: RegistryCatalogData;
}

// refs: 1 - tags: named, output
export interface PutRepositoryCatalogDataResponse {
  catalogData?: RepositoryCatalogData | null;
}

// refs: 1 - tags: named, output
export interface SetRepositoryPolicyResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  policyText?: string | null;
}

// refs: 1 - tags: named, output
export interface UploadLayerPartResponse {
  registryId?: string | null;
  repositoryName?: string | null;
  uploadId?: string | null;
  lastByteReceived?: number | null;
}

// refs: 5 - tags: input, named, interface, output
export interface ImageIdentifier {
  imageDigest?: string | null;
  imageTag?: string | null;
}
function fromImageIdentifier(input?: ImageIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageDigest: input["imageDigest"],
    imageTag: input["imageTag"],
  }
}
function toImageIdentifier(root: jsonP.JSONValue): ImageIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageDigest": "s",
      "imageTag": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface RepositoryCatalogDataInput {
  description?: string | null;
  architectures?: string[] | null;
  operatingSystems?: string[] | null;
  logoImageBlob?: Uint8Array | string | null;
  aboutText?: string | null;
  usageText?: string | null;
}
function fromRepositoryCatalogDataInput(input?: RepositoryCatalogDataInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    description: input["description"],
    architectures: input["architectures"],
    operatingSystems: input["operatingSystems"],
    logoImageBlob: jsonP.serializeBlob(input["logoImageBlob"]),
    aboutText: input["aboutText"],
    usageText: input["usageText"],
  }
}

// refs: 1 - tags: output, named, interface
export interface Layer {
  layerDigest?: string | null;
  layerAvailability?: LayerAvailability | null;
  layerSize?: number | null;
  mediaType?: string | null;
}
function toLayer(root: jsonP.JSONValue): Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "layerAvailability": (x: jsonP.JSONValue) => cmnP.readEnum<LayerAvailability>(x),
      "layerSize": "n",
      "mediaType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type LayerAvailability =
| "AVAILABLE"
| "UNAVAILABLE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LayerFailure {
  layerDigest?: string | null;
  failureCode?: LayerFailureCode | null;
  failureReason?: string | null;
}
function toLayerFailure(root: jsonP.JSONValue): LayerFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<LayerFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type LayerFailureCode =
| "InvalidLayerDigest"
| "MissingLayerDigest"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ImageFailure {
  imageId?: ImageIdentifier | null;
  failureCode?: ImageFailureCode | null;
  failureReason?: string | null;
}
function toImageFailure(root: jsonP.JSONValue): ImageFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageId": toImageIdentifier,
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<ImageFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ImageFailureCode =
| "InvalidImageDigest"
| "InvalidImageTag"
| "ImageTagDoesNotMatchDigest"
| "ImageNotFound"
| "MissingDigestAndTag"
| "ImageReferencedByManifestList"
| "KmsError"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Repository {
  repositoryArn?: string | null;
  registryId?: string | null;
  repositoryName?: string | null;
  repositoryUri?: string | null;
  createdAt?: Date | number | null;
}
function toRepository(root: jsonP.JSONValue): Repository {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryArn": "s",
      "registryId": "s",
      "repositoryName": "s",
      "repositoryUri": "s",
      "createdAt": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface RepositoryCatalogData {
  description?: string | null;
  architectures?: string[] | null;
  operatingSystems?: string[] | null;
  logoUrl?: string | null;
  aboutText?: string | null;
  usageText?: string | null;
  marketplaceCertified?: boolean | null;
}
function toRepositoryCatalogData(root: jsonP.JSONValue): RepositoryCatalogData {
  return jsonP.readObj({
    required: {},
    optional: {
      "description": "s",
      "architectures": ["s"],
      "operatingSystems": ["s"],
      "logoUrl": "s",
      "aboutText": "s",
      "usageText": "s",
      "marketplaceCertified": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageTagDetail {
  imageTag?: string | null;
  createdAt?: Date | number | null;
  imageDetail?: ReferencedImageDetail | null;
}
function toImageTagDetail(root: jsonP.JSONValue): ImageTagDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageTag": "s",
      "createdAt": "d",
      "imageDetail": toReferencedImageDetail,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReferencedImageDetail {
  imageDigest?: string | null;
  imageSizeInBytes?: number | null;
  imagePushedAt?: Date | number | null;
  imageManifestMediaType?: string | null;
  artifactMediaType?: string | null;
}
function toReferencedImageDetail(root: jsonP.JSONValue): ReferencedImageDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageDigest": "s",
      "imageSizeInBytes": "n",
      "imagePushedAt": "d",
      "imageManifestMediaType": "s",
      "artifactMediaType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageDetail {
  registryId?: string | null;
  repositoryName?: string | null;
  imageDigest?: string | null;
  imageTags?: string[] | null;
  imageSizeInBytes?: number | null;
  imagePushedAt?: Date | number | null;
  imageManifestMediaType?: string | null;
  artifactMediaType?: string | null;
}
function toImageDetail(root: jsonP.JSONValue): ImageDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageDigest": "s",
      "imageTags": ["s"],
      "imageSizeInBytes": "n",
      "imagePushedAt": "d",
      "imageManifestMediaType": "s",
      "artifactMediaType": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Registry {
  registryId: string;
  registryArn: string;
  registryUri: string;
  verified: boolean;
  aliases: RegistryAlias[];
}
function toRegistry(root: jsonP.JSONValue): Registry {
  return jsonP.readObj({
    required: {
      "registryId": "s",
      "registryArn": "s",
      "registryUri": "s",
      "verified": "b",
      "aliases": [toRegistryAlias],
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RegistryAlias {
  name: string;
  status: RegistryAliasStatus;
  primaryRegistryAlias: boolean;
  defaultRegistryAlias: boolean;
}
function toRegistryAlias(root: jsonP.JSONValue): RegistryAlias {
  return jsonP.readObj({
    required: {
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<RegistryAliasStatus>(x),
      "primaryRegistryAlias": "b",
      "defaultRegistryAlias": "b",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, enum
export type RegistryAliasStatus =
| "ACTIVE"
| "PENDING"
| "REJECTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AuthorizationData {
  authorizationToken?: string | null;
  expiresAt?: Date | number | null;
}
function toAuthorizationData(root: jsonP.JSONValue): AuthorizationData {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizationToken": "s",
      "expiresAt": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RegistryCatalogData {
  displayName?: string | null;
}
function toRegistryCatalogData(root: jsonP.JSONValue): RegistryCatalogData {
  return jsonP.readObj({
    required: {},
    optional: {
      "displayName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Image {
  registryId?: string | null;
  repositoryName?: string | null;
  imageId?: ImageIdentifier | null;
  imageManifest?: string | null;
  imageManifestMediaType?: string | null;
}
function toImage(root: jsonP.JSONValue): Image {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageId": toImageIdentifier,
      "imageManifest": "s",
      "imageManifestMediaType": "s",
    },
  }, root);
}
