// Autogenerated API client for: AWS Support

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Support {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Support.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-04-15",
    "endpointPrefix": "support",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Support",
    "serviceId": "Support",
    "signatureVersion": "v4",
    "targetPrefix": "AWSSupport_20130415",
    "uid": "support-2013-04-15"
  };

  async addAttachmentsToSet(
    {abortSignal, ...params}: RequestConfig & s.AddAttachmentsToSetRequest,
  ): Promise<s.AddAttachmentsToSetResponse> {
    const body: jsonP.JSONObject = {
      attachmentSetId: params["attachmentSetId"],
      attachments: params["attachments"]?.map(x => fromAttachment(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddAttachmentsToSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attachmentSetId": "s",
        "expiryTime": "s",
      },
    }, await resp.json());
  }

  async addCommunicationToCase(
    {abortSignal, ...params}: RequestConfig & s.AddCommunicationToCaseRequest,
  ): Promise<s.AddCommunicationToCaseResponse> {
    const body: jsonP.JSONObject = {
      caseId: params["caseId"],
      communicationBody: params["communicationBody"],
      ccEmailAddresses: params["ccEmailAddresses"],
      attachmentSetId: params["attachmentSetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddCommunicationToCase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "result": "b",
      },
    }, await resp.json());
  }

  async createCase(
    {abortSignal, ...params}: RequestConfig & s.CreateCaseRequest,
  ): Promise<s.CreateCaseResponse> {
    const body: jsonP.JSONObject = {
      subject: params["subject"],
      serviceCode: params["serviceCode"],
      severityCode: params["severityCode"],
      categoryCode: params["categoryCode"],
      communicationBody: params["communicationBody"],
      ccEmailAddresses: params["ccEmailAddresses"],
      language: params["language"],
      issueType: params["issueType"],
      attachmentSetId: params["attachmentSetId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "caseId": "s",
      },
    }, await resp.json());
  }

  async describeAttachment(
    {abortSignal, ...params}: RequestConfig & s.DescribeAttachmentRequest,
  ): Promise<s.DescribeAttachmentResponse> {
    const body: jsonP.JSONObject = {
      attachmentId: params["attachmentId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAttachment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attachment": toAttachment,
      },
    }, await resp.json());
  }

  async describeCases(
    {abortSignal, ...params}: RequestConfig & s.DescribeCasesRequest = {},
  ): Promise<s.DescribeCasesResponse> {
    const body: jsonP.JSONObject = {
      caseIdList: params["caseIdList"],
      displayId: params["displayId"],
      afterTime: params["afterTime"],
      beforeTime: params["beforeTime"],
      includeResolvedCases: params["includeResolvedCases"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      language: params["language"],
      includeCommunications: params["includeCommunications"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cases": [toCaseDetails],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeCommunications(
    {abortSignal, ...params}: RequestConfig & s.DescribeCommunicationsRequest,
  ): Promise<s.DescribeCommunicationsResponse> {
    const body: jsonP.JSONObject = {
      caseId: params["caseId"],
      beforeTime: params["beforeTime"],
      afterTime: params["afterTime"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCommunications",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "communications": [toCommunication],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeServices(
    {abortSignal, ...params}: RequestConfig & s.DescribeServicesRequest = {},
  ): Promise<s.DescribeServicesResponse> {
    const body: jsonP.JSONObject = {
      serviceCodeList: params["serviceCodeList"],
      language: params["language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "services": [toService],
      },
    }, await resp.json());
  }

  async describeSeverityLevels(
    {abortSignal, ...params}: RequestConfig & s.DescribeSeverityLevelsRequest = {},
  ): Promise<s.DescribeSeverityLevelsResponse> {
    const body: jsonP.JSONObject = {
      language: params["language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSeverityLevels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "severityLevels": [toSeverityLevel],
      },
    }, await resp.json());
  }

  async describeTrustedAdvisorCheckRefreshStatuses(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrustedAdvisorCheckRefreshStatusesRequest,
  ): Promise<s.DescribeTrustedAdvisorCheckRefreshStatusesResponse> {
    const body: jsonP.JSONObject = {
      checkIds: params["checkIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrustedAdvisorCheckRefreshStatuses",
    });
    return jsonP.readObj({
      required: {
        "statuses": [toTrustedAdvisorCheckRefreshStatus],
      },
      optional: {},
    }, await resp.json());
  }

  async describeTrustedAdvisorCheckResult(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrustedAdvisorCheckResultRequest,
  ): Promise<s.DescribeTrustedAdvisorCheckResultResponse> {
    const body: jsonP.JSONObject = {
      checkId: params["checkId"],
      language: params["language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrustedAdvisorCheckResult",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "result": toTrustedAdvisorCheckResult,
      },
    }, await resp.json());
  }

  async describeTrustedAdvisorCheckSummaries(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrustedAdvisorCheckSummariesRequest,
  ): Promise<s.DescribeTrustedAdvisorCheckSummariesResponse> {
    const body: jsonP.JSONObject = {
      checkIds: params["checkIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrustedAdvisorCheckSummaries",
    });
    return jsonP.readObj({
      required: {
        "summaries": [toTrustedAdvisorCheckSummary],
      },
      optional: {},
    }, await resp.json());
  }

  async describeTrustedAdvisorChecks(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrustedAdvisorChecksRequest,
  ): Promise<s.DescribeTrustedAdvisorChecksResponse> {
    const body: jsonP.JSONObject = {
      language: params["language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrustedAdvisorChecks",
    });
    return jsonP.readObj({
      required: {
        "checks": [toTrustedAdvisorCheckDescription],
      },
      optional: {},
    }, await resp.json());
  }

  async refreshTrustedAdvisorCheck(
    {abortSignal, ...params}: RequestConfig & s.RefreshTrustedAdvisorCheckRequest,
  ): Promise<s.RefreshTrustedAdvisorCheckResponse> {
    const body: jsonP.JSONObject = {
      checkId: params["checkId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RefreshTrustedAdvisorCheck",
    });
    return jsonP.readObj({
      required: {
        "status": toTrustedAdvisorCheckRefreshStatus,
      },
      optional: {},
    }, await resp.json());
  }

  async resolveCase(
    {abortSignal, ...params}: RequestConfig & s.ResolveCaseRequest = {},
  ): Promise<s.ResolveCaseResponse> {
    const body: jsonP.JSONObject = {
      caseId: params["caseId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResolveCase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "initialCaseStatus": "s",
        "finalCaseStatus": "s",
      },
    }, await resp.json());
  }

}

function fromAttachment(input?: s.Attachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileName: input["fileName"],
    data: serializeBlob(input["data"]),
  }
}
function toAttachment(root: jsonP.JSONValue): s.Attachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "fileName": "s",
      "data": "a",
    },
  }, root);
}

function toCaseDetails(root: jsonP.JSONValue): s.CaseDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "caseId": "s",
      "displayId": "s",
      "subject": "s",
      "status": "s",
      "serviceCode": "s",
      "categoryCode": "s",
      "severityCode": "s",
      "submittedBy": "s",
      "timeCreated": "s",
      "recentCommunications": toRecentCaseCommunications,
      "ccEmailAddresses": ["s"],
      "language": "s",
    },
  }, root);
}

function toRecentCaseCommunications(root: jsonP.JSONValue): s.RecentCaseCommunications {
  return jsonP.readObj({
    required: {},
    optional: {
      "communications": [toCommunication],
      "nextToken": "s",
    },
  }, root);
}

function toCommunication(root: jsonP.JSONValue): s.Communication {
  return jsonP.readObj({
    required: {},
    optional: {
      "caseId": "s",
      "body": "s",
      "submittedBy": "s",
      "timeCreated": "s",
      "attachmentSet": [toAttachmentDetails],
    },
  }, root);
}

function toAttachmentDetails(root: jsonP.JSONValue): s.AttachmentDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachmentId": "s",
      "fileName": "s",
    },
  }, root);
}

function toService(root: jsonP.JSONValue): s.Service {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "name": "s",
      "categories": [toCategory],
    },
  }, root);
}

function toCategory(root: jsonP.JSONValue): s.Category {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "name": "s",
    },
  }, root);
}

function toSeverityLevel(root: jsonP.JSONValue): s.SeverityLevel {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "name": "s",
    },
  }, root);
}

function toTrustedAdvisorCheckRefreshStatus(root: jsonP.JSONValue): s.TrustedAdvisorCheckRefreshStatus {
  return jsonP.readObj({
    required: {
      "checkId": "s",
      "status": "s",
      "millisUntilNextRefreshable": "n",
    },
    optional: {},
  }, root);
}

function toTrustedAdvisorCheckResult(root: jsonP.JSONValue): s.TrustedAdvisorCheckResult {
  return jsonP.readObj({
    required: {
      "checkId": "s",
      "timestamp": "s",
      "status": "s",
      "resourcesSummary": toTrustedAdvisorResourcesSummary,
      "categorySpecificSummary": toTrustedAdvisorCategorySpecificSummary,
      "flaggedResources": [toTrustedAdvisorResourceDetail],
    },
    optional: {},
  }, root);
}

function toTrustedAdvisorResourcesSummary(root: jsonP.JSONValue): s.TrustedAdvisorResourcesSummary {
  return jsonP.readObj({
    required: {
      "resourcesProcessed": "n",
      "resourcesFlagged": "n",
      "resourcesIgnored": "n",
      "resourcesSuppressed": "n",
    },
    optional: {},
  }, root);
}

function toTrustedAdvisorCategorySpecificSummary(root: jsonP.JSONValue): s.TrustedAdvisorCategorySpecificSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "costOptimizing": toTrustedAdvisorCostOptimizingSummary,
    },
  }, root);
}

function toTrustedAdvisorCostOptimizingSummary(root: jsonP.JSONValue): s.TrustedAdvisorCostOptimizingSummary {
  return jsonP.readObj({
    required: {
      "estimatedMonthlySavings": "n",
      "estimatedPercentMonthlySavings": "n",
    },
    optional: {},
  }, root);
}

function toTrustedAdvisorResourceDetail(root: jsonP.JSONValue): s.TrustedAdvisorResourceDetail {
  return jsonP.readObj({
    required: {
      "status": "s",
      "resourceId": "s",
      "metadata": ["s"],
    },
    optional: {
      "region": "s",
      "isSuppressed": "b",
    },
  }, root);
}

function toTrustedAdvisorCheckSummary(root: jsonP.JSONValue): s.TrustedAdvisorCheckSummary {
  return jsonP.readObj({
    required: {
      "checkId": "s",
      "timestamp": "s",
      "status": "s",
      "resourcesSummary": toTrustedAdvisorResourcesSummary,
      "categorySpecificSummary": toTrustedAdvisorCategorySpecificSummary,
    },
    optional: {
      "hasFlaggedResources": "b",
    },
  }, root);
}

function toTrustedAdvisorCheckDescription(root: jsonP.JSONValue): s.TrustedAdvisorCheckDescription {
  return jsonP.readObj({
    required: {
      "id": "s",
      "name": "s",
      "description": "s",
      "category": "s",
      "metadata": ["s"],
    },
    optional: {},
  }, root);
}
