// Autogenerated API client for: AWS IoT Events Data

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class IoTEventsData {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IoTEventsData.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-10-23",
    "endpointPrefix": "data.iotevents",
    "protocol": "rest-json",
    "serviceFullName": "AWS IoT Events Data",
    "serviceId": "IoT Events Data",
    "signatureVersion": "v4",
    "signingName": "ioteventsdata",
    "uid": "iotevents-data-2018-10-23"
  };

  async batchPutMessage(
    {abortSignal, ...params}: RequestConfig & BatchPutMessageRequest,
  ): Promise<BatchPutMessageResponse> {
    const body: jsonP.JSONObject = {
      messages: params["messages"]?.map(x => fromMessage(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutMessage",
      requestUri: "/inputs/messages",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BatchPutMessageErrorEntries": [toBatchPutMessageErrorEntry],
      },
    }, await resp.json());
  }

  async batchUpdateDetector(
    {abortSignal, ...params}: RequestConfig & BatchUpdateDetectorRequest,
  ): Promise<BatchUpdateDetectorResponse> {
    const body: jsonP.JSONObject = {
      detectors: params["detectors"]?.map(x => fromUpdateDetectorRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdateDetector",
      requestUri: "/detectors",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchUpdateDetectorErrorEntries": [toBatchUpdateDetectorErrorEntry],
      },
    }, await resp.json());
  }

  async describeDetector(
    {abortSignal, ...params}: RequestConfig & DescribeDetectorRequest,
  ): Promise<DescribeDetectorResponse> {
    const query = new URLSearchParams;
    if (params["keyValue"] != null) query.set("keyValue", params["keyValue"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDetector",
      method: "GET",
      requestUri: cmnP.encodePath`/detectors/${params["detectorModelName"]}/keyValues/`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detector": toDetector,
      },
    }, await resp.json());
  }

  async listDetectors(
    {abortSignal, ...params}: RequestConfig & ListDetectorsRequest,
  ): Promise<ListDetectorsResponse> {
    const query = new URLSearchParams;
    if (params["stateName"] != null) query.set("stateName", params["stateName"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDetectors",
      method: "GET",
      requestUri: cmnP.encodePath`/detectors/${params["detectorModelName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detectorSummaries": [toDetectorSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchPutMessageRequest {
  messages: Message[];
}

// refs: 1 - tags: named, input
export interface BatchUpdateDetectorRequest {
  detectors: UpdateDetectorRequest[];
}

// refs: 1 - tags: named, input
export interface DescribeDetectorRequest {
  detectorModelName: string;
  keyValue?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDetectorsRequest {
  detectorModelName: string;
  stateName?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, output
export interface BatchPutMessageResponse {
  BatchPutMessageErrorEntries?: BatchPutMessageErrorEntry[] | null;
}

// refs: 1 - tags: named, output
export interface BatchUpdateDetectorResponse {
  batchUpdateDetectorErrorEntries?: BatchUpdateDetectorErrorEntry[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeDetectorResponse {
  detector?: Detector | null;
}

// refs: 1 - tags: named, output
export interface ListDetectorsResponse {
  detectorSummaries?: DetectorSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: input, named, interface
export interface Message {
  messageId: string;
  inputName: string;
  payload: Uint8Array | string;
}
function fromMessage(input?: Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageId: input["messageId"],
    inputName: input["inputName"],
    payload: jsonP.serializeBlob(input["payload"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateDetectorRequest {
  messageId: string;
  detectorModelName: string;
  keyValue?: string | null;
  state: DetectorStateDefinition;
}
function fromUpdateDetectorRequest(input?: UpdateDetectorRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageId: input["messageId"],
    detectorModelName: input["detectorModelName"],
    keyValue: input["keyValue"],
    state: fromDetectorStateDefinition(input["state"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface DetectorStateDefinition {
  stateName: string;
  variables: VariableDefinition[];
  timers: TimerDefinition[];
}
function fromDetectorStateDefinition(input?: DetectorStateDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    stateName: input["stateName"],
    variables: input["variables"]?.map(x => fromVariableDefinition(x)),
    timers: input["timers"]?.map(x => fromTimerDefinition(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface VariableDefinition {
  name: string;
  value: string;
}
function fromVariableDefinition(input?: VariableDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TimerDefinition {
  name: string;
  seconds: number;
}
function fromTimerDefinition(input?: TimerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    seconds: input["seconds"],
  }
}

// refs: 1 - tags: output, named, interface
export interface BatchPutMessageErrorEntry {
  messageId?: string | null;
  errorCode?: ErrorCode | null;
  errorMessage?: string | null;
}
function toBatchPutMessageErrorEntry(root: jsonP.JSONValue): BatchPutMessageErrorEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "messageId": "s",
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<ErrorCode>(x),
      "errorMessage": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ErrorCode =
| "ResourceNotFoundException"
| "InvalidRequestException"
| "InternalFailureException"
| "ServiceUnavailableException"
| "ThrottlingException"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BatchUpdateDetectorErrorEntry {
  messageId?: string | null;
  errorCode?: ErrorCode | null;
  errorMessage?: string | null;
}
function toBatchUpdateDetectorErrorEntry(root: jsonP.JSONValue): BatchUpdateDetectorErrorEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "messageId": "s",
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<ErrorCode>(x),
      "errorMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Detector {
  detectorModelName?: string | null;
  keyValue?: string | null;
  detectorModelVersion?: string | null;
  state?: DetectorState | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
}
function toDetector(root: jsonP.JSONValue): Detector {
  return jsonP.readObj({
    required: {},
    optional: {
      "detectorModelName": "s",
      "keyValue": "s",
      "detectorModelVersion": "s",
      "state": toDetectorState,
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DetectorState {
  stateName: string;
  variables: Variable[];
  timers: Timer[];
}
function toDetectorState(root: jsonP.JSONValue): DetectorState {
  return jsonP.readObj({
    required: {
      "stateName": "s",
      "variables": [toVariable],
      "timers": [toTimer],
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Variable {
  name: string;
  value: string;
}
function toVariable(root: jsonP.JSONValue): Variable {
  return jsonP.readObj({
    required: {
      "name": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Timer {
  name: string;
  timestamp: Date | number;
}
function toTimer(root: jsonP.JSONValue): Timer {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timestamp": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DetectorSummary {
  detectorModelName?: string | null;
  keyValue?: string | null;
  detectorModelVersion?: string | null;
  state?: DetectorStateSummary | null;
  creationTime?: Date | number | null;
  lastUpdateTime?: Date | number | null;
}
function toDetectorSummary(root: jsonP.JSONValue): DetectorSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "detectorModelName": "s",
      "keyValue": "s",
      "detectorModelVersion": "s",
      "state": toDetectorStateSummary,
      "creationTime": "d",
      "lastUpdateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DetectorStateSummary {
  stateName?: string | null;
}
function toDetectorStateSummary(root: jsonP.JSONValue): DetectorStateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "stateName": "s",
    },
  }, root);
}
