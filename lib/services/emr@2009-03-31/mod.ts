// Autogenerated API client for: Amazon Elastic MapReduce

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class EMR {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EMR.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2009-03-31",
    "endpointPrefix": "elasticmapreduce",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon EMR",
    "serviceFullName": "Amazon Elastic MapReduce",
    "serviceId": "EMR",
    "signatureVersion": "v4",
    "targetPrefix": "ElasticMapReduce",
    "uid": "elasticmapreduce-2009-03-31"
  };

  async addInstanceFleet(
    {abortSignal, ...params}: RequestConfig & s.AddInstanceFleetInput,
  ): Promise<s.AddInstanceFleetOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceFleet: fromInstanceFleetConfig(params["InstanceFleet"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceFleetId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addInstanceGroups(
    {abortSignal, ...params}: RequestConfig & s.AddInstanceGroupsInput,
  ): Promise<s.AddInstanceGroupsOutput> {
    const body: jsonP.JSONObject = {
      InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
      JobFlowId: params["JobFlowId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "InstanceGroupIds": ["s"],
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addJobFlowSteps(
    {abortSignal, ...params}: RequestConfig & s.AddJobFlowStepsInput,
  ): Promise<s.AddJobFlowStepsOutput> {
    const body: jsonP.JSONObject = {
      JobFlowId: params["JobFlowId"],
      Steps: params["Steps"]?.map(x => fromStepConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddJobFlowSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StepIds": ["s"],
      },
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & s.AddTagsInput,
  ): Promise<s.AddTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelSteps(
    {abortSignal, ...params}: RequestConfig & s.CancelStepsInput,
  ): Promise<s.CancelStepsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepIds: params["StepIds"],
      StepCancellationOption: params["StepCancellationOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CancelStepsInfoList": [toCancelStepsInfo],
      },
    }, await resp.json());
  }

  async createSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateSecurityConfigurationInput,
  ): Promise<s.CreateSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      SecurityConfiguration: params["SecurityConfiguration"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "CreationDateTime": "d",
      },
      optional: {},
    }, await resp.json());
  }

  async createStudio(
    {abortSignal, ...params}: RequestConfig & s.CreateStudioInput,
  ): Promise<s.CreateStudioOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      AuthMode: params["AuthMode"],
      VpcId: params["VpcId"],
      SubnetIds: params["SubnetIds"],
      ServiceRole: params["ServiceRole"],
      UserRole: params["UserRole"],
      WorkspaceSecurityGroupId: params["WorkspaceSecurityGroupId"],
      EngineSecurityGroupId: params["EngineSecurityGroupId"],
      DefaultS3Location: params["DefaultS3Location"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStudio",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StudioId": "s",
        "Url": "s",
      },
    }, await resp.json());
  }

  async createStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & s.CreateStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
      SessionPolicyArn: params["SessionPolicyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStudioSessionMapping",
    });
  }

  async deleteSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteSecurityConfigurationInput,
  ): Promise<s.DeleteSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteStudio(
    {abortSignal, ...params}: RequestConfig & s.DeleteStudioInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStudio",
    });
  }

  async deleteStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & s.DeleteStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStudioSessionMapping",
    });
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & s.DescribeClusterInput,
  ): Promise<s.DescribeClusterOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async describeJobFlows(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobFlowsInput = {},
  ): Promise<s.DescribeJobFlowsOutput> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      JobFlowIds: params["JobFlowIds"],
      JobFlowStates: params["JobFlowStates"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobFlows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlows": [toJobFlowDetail],
      },
    }, await resp.json());
  }

  async describeNotebookExecution(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotebookExecutionInput,
  ): Promise<s.DescribeNotebookExecutionOutput> {
    const body: jsonP.JSONObject = {
      NotebookExecutionId: params["NotebookExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecution": toNotebookExecution,
      },
    }, await resp.json());
  }

  async describeSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeSecurityConfigurationInput,
  ): Promise<s.DescribeSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "SecurityConfiguration": "s",
        "CreationDateTime": "d",
      },
    }, await resp.json());
  }

  async describeStep(
    {abortSignal, ...params}: RequestConfig & s.DescribeStepInput,
  ): Promise<s.DescribeStepOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepId: params["StepId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStep",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Step": toStep,
      },
    }, await resp.json());
  }

  async describeStudio(
    {abortSignal, ...params}: RequestConfig & s.DescribeStudioInput,
  ): Promise<s.DescribeStudioOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStudio",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Studio": toStudio,
      },
    }, await resp.json());
  }

  async getBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetBlockPublicAccessConfigurationInput = {},
  ): Promise<s.GetBlockPublicAccessConfigurationOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlockPublicAccessConfiguration",
    });
    return jsonP.readObj({
      required: {
        "BlockPublicAccessConfiguration": toBlockPublicAccessConfiguration,
        "BlockPublicAccessConfigurationMetadata": toBlockPublicAccessConfigurationMetadata,
      },
      optional: {},
    }, await resp.json());
  }

  async getManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetManagedScalingPolicyInput,
  ): Promise<s.GetManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ManagedScalingPolicy": toManagedScalingPolicy,
      },
    }, await resp.json());
  }

  async getStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & s.GetStudioSessionMappingInput,
  ): Promise<s.GetStudioSessionMappingOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStudioSessionMapping",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionMapping": toSessionMappingDetail,
      },
    }, await resp.json());
  }

  async listBootstrapActions(
    {abortSignal, ...params}: RequestConfig & s.ListBootstrapActionsInput,
  ): Promise<s.ListBootstrapActionsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBootstrapActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BootstrapActions": [toCommand],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & s.ListClustersInput = {},
  ): Promise<s.ListClustersOutput> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      ClusterStates: params["ClusterStates"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Clusters": [toClusterSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceFleets(
    {abortSignal, ...params}: RequestConfig & s.ListInstanceFleetsInput,
  ): Promise<s.ListInstanceFleetsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceFleets": [toInstanceFleet],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceGroups(
    {abortSignal, ...params}: RequestConfig & s.ListInstanceGroupsInput,
  ): Promise<s.ListInstanceGroupsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceGroups": [toInstanceGroup],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstances(
    {abortSignal, ...params}: RequestConfig & s.ListInstancesInput,
  ): Promise<s.ListInstancesOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
      InstanceGroupTypes: params["InstanceGroupTypes"],
      InstanceFleetId: params["InstanceFleetId"],
      InstanceFleetType: params["InstanceFleetType"],
      InstanceStates: params["InstanceStates"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listNotebookExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListNotebookExecutionsInput = {},
  ): Promise<s.ListNotebookExecutionsOutput> {
    const body: jsonP.JSONObject = {
      EditorId: params["EditorId"],
      Status: params["Status"],
      From: jsonP.serializeDate_unixTimestamp(params["From"]),
      To: jsonP.serializeDate_unixTimestamp(params["To"]),
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecutions": [toNotebookExecutionSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSecurityConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListSecurityConfigurationsInput = {},
  ): Promise<s.ListSecurityConfigurationsOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecurityConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfigurations": [toSecurityConfigurationSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSteps(
    {abortSignal, ...params}: RequestConfig & s.ListStepsInput,
  ): Promise<s.ListStepsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepStates: params["StepStates"],
      StepIds: params["StepIds"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Steps": [toStepSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listStudioSessionMappings(
    {abortSignal, ...params}: RequestConfig & s.ListStudioSessionMappingsInput = {},
  ): Promise<s.ListStudioSessionMappingsOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityType: params["IdentityType"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStudioSessionMappings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionMappings": [toSessionMappingSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listStudios(
    {abortSignal, ...params}: RequestConfig & s.ListStudiosInput = {},
  ): Promise<s.ListStudiosOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStudios",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Studios": [toStudioSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterInput,
  ): Promise<s.ModifyClusterOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepConcurrencyLevel: params["StepConcurrencyLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StepConcurrencyLevel": "n",
      },
    }, await resp.json());
  }

  async modifyInstanceFleet(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceFleetInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceFleet: fromInstanceFleetModifyConfig(params["InstanceFleet"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceFleet",
    });
  }

  async modifyInstanceGroups(
    {abortSignal, ...params}: RequestConfig & s.ModifyInstanceGroupsInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupModifyConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceGroups",
    });
  }

  async putAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutAutoScalingPolicyInput,
  ): Promise<s.PutAutoScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
      AutoScalingPolicy: fromAutoScalingPolicy(params["AutoScalingPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAutoScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceGroupId": "s",
        "AutoScalingPolicy": toAutoScalingPolicyDescription,
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async putBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutBlockPublicAccessConfigurationInput,
  ): Promise<s.PutBlockPublicAccessConfigurationOutput> {
    const body: jsonP.JSONObject = {
      BlockPublicAccessConfiguration: fromBlockPublicAccessConfiguration(params["BlockPublicAccessConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBlockPublicAccessConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutManagedScalingPolicyInput,
  ): Promise<s.PutManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.RemoveAutoScalingPolicyInput,
  ): Promise<s.RemoveAutoScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveAutoScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & s.RemoveManagedScalingPolicyInput,
  ): Promise<s.RemoveManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsInput,
  ): Promise<s.RemoveTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async runJobFlow(
    {abortSignal, ...params}: RequestConfig & s.RunJobFlowInput,
  ): Promise<s.RunJobFlowOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      LogUri: params["LogUri"],
      LogEncryptionKmsKeyId: params["LogEncryptionKmsKeyId"],
      AdditionalInfo: params["AdditionalInfo"],
      AmiVersion: params["AmiVersion"],
      ReleaseLabel: params["ReleaseLabel"],
      Instances: fromJobFlowInstancesConfig(params["Instances"]),
      Steps: params["Steps"]?.map(x => fromStepConfig(x)),
      BootstrapActions: params["BootstrapActions"]?.map(x => fromBootstrapActionConfig(x)),
      SupportedProducts: params["SupportedProducts"],
      NewSupportedProducts: params["NewSupportedProducts"]?.map(x => fromSupportedProductConfig(x)),
      Applications: params["Applications"]?.map(x => fromApplication(x)),
      Configurations: params["Configurations"]?.map(x => fromConfiguration(x)),
      VisibleToAllUsers: params["VisibleToAllUsers"],
      JobFlowRole: params["JobFlowRole"],
      ServiceRole: params["ServiceRole"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      SecurityConfiguration: params["SecurityConfiguration"],
      AutoScalingRole: params["AutoScalingRole"],
      ScaleDownBehavior: params["ScaleDownBehavior"],
      CustomAmiId: params["CustomAmiId"],
      EbsRootVolumeSize: params["EbsRootVolumeSize"],
      RepoUpgradeOnBoot: params["RepoUpgradeOnBoot"],
      KerberosAttributes: fromKerberosAttributes(params["KerberosAttributes"]),
      StepConcurrencyLevel: params["StepConcurrencyLevel"],
      ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
      PlacementGroupConfigs: params["PlacementGroupConfigs"]?.map(x => fromPlacementGroupConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunJobFlow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async setTerminationProtection(
    {abortSignal, ...params}: RequestConfig & s.SetTerminationProtectionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
      TerminationProtected: params["TerminationProtected"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTerminationProtection",
    });
  }

  async setVisibleToAllUsers(
    {abortSignal, ...params}: RequestConfig & s.SetVisibleToAllUsersInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
      VisibleToAllUsers: params["VisibleToAllUsers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetVisibleToAllUsers",
    });
  }

  async startNotebookExecution(
    {abortSignal, ...params}: RequestConfig & s.StartNotebookExecutionInput,
  ): Promise<s.StartNotebookExecutionOutput> {
    const body: jsonP.JSONObject = {
      EditorId: params["EditorId"],
      RelativePath: params["RelativePath"],
      NotebookExecutionName: params["NotebookExecutionName"],
      NotebookParams: params["NotebookParams"],
      ExecutionEngine: fromExecutionEngineConfig(params["ExecutionEngine"]),
      ServiceRole: params["ServiceRole"],
      NotebookInstanceSecurityGroupId: params["NotebookInstanceSecurityGroupId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNotebookExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecutionId": "s",
      },
    }, await resp.json());
  }

  async stopNotebookExecution(
    {abortSignal, ...params}: RequestConfig & s.StopNotebookExecutionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookExecutionId: params["NotebookExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopNotebookExecution",
    });
  }

  async terminateJobFlows(
    {abortSignal, ...params}: RequestConfig & s.TerminateJobFlowsInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateJobFlows",
    });
  }

  async updateStudio(
    {abortSignal, ...params}: RequestConfig & s.UpdateStudioInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      Name: params["Name"],
      Description: params["Description"],
      SubnetIds: params["SubnetIds"],
      DefaultS3Location: params["DefaultS3Location"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStudio",
    });
  }

  async updateStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & s.UpdateStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
      SessionPolicyArn: params["SessionPolicyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStudioSessionMapping",
    });
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterRunning(
    params: RequestConfig & s.DescribeClusterInput,
  ): Promise<s.DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterRunning';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.Cluster?.Status?.State;
      if (field === "RUNNING") return resp;
      if (field === "WAITING") return resp;
      if (field === "TERMINATING") throw new Error(errMessage);
      if (field === "TERMINATED") throw new Error(errMessage);
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForStepComplete(
    params: RequestConfig & s.DescribeStepInput,
  ): Promise<s.DescribeStepOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StepComplete';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeStep(params);
      const field = resp?.Step?.Status?.State;
      if (field === "COMPLETED") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      if (field === "CANCELLED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterTerminated(
    params: RequestConfig & s.DescribeClusterInput,
  ): Promise<s.DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterTerminated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.Cluster?.Status?.State;
      if (field === "TERMINATED") return resp;
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function fromInstanceFleetConfig(input?: s.InstanceFleetConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    InstanceFleetType: input["InstanceFleetType"],
    TargetOnDemandCapacity: input["TargetOnDemandCapacity"],
    TargetSpotCapacity: input["TargetSpotCapacity"],
    InstanceTypeConfigs: input["InstanceTypeConfigs"]?.map(x => fromInstanceTypeConfig(x)),
    LaunchSpecifications: fromInstanceFleetProvisioningSpecifications(input["LaunchSpecifications"]),
  }
}

function fromInstanceTypeConfig(input?: s.InstanceTypeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    WeightedCapacity: input["WeightedCapacity"],
    BidPrice: input["BidPrice"],
    BidPriceAsPercentageOfOnDemandPrice: input["BidPriceAsPercentageOfOnDemandPrice"],
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

function fromEbsConfiguration(input?: s.EbsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EbsBlockDeviceConfigs: input["EbsBlockDeviceConfigs"]?.map(x => fromEbsBlockDeviceConfig(x)),
    EbsOptimized: input["EbsOptimized"],
  }
}

function fromEbsBlockDeviceConfig(input?: s.EbsBlockDeviceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeSpecification: fromVolumeSpecification(input["VolumeSpecification"]),
    VolumesPerInstance: input["VolumesPerInstance"],
  }
}

function fromVolumeSpecification(input?: s.VolumeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeType: input["VolumeType"],
    Iops: input["Iops"],
    SizeInGB: input["SizeInGB"],
  }
}
function toVolumeSpecification(root: jsonP.JSONValue): s.VolumeSpecification {
  return jsonP.readObj({
    required: {
      "VolumeType": "s",
      "SizeInGB": "n",
    },
    optional: {
      "Iops": "n",
    },
  }, root);
}

function fromConfiguration(input?: s.Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
    Properties: input["Properties"],
  }
}
function toConfiguration(root: jsonP.JSONValue): s.Configuration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Classification": "s",
      "Configurations": [toConfiguration],
      "Properties": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromInstanceFleetProvisioningSpecifications(input?: s.InstanceFleetProvisioningSpecifications | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SpotSpecification: fromSpotProvisioningSpecification(input["SpotSpecification"]),
    OnDemandSpecification: fromOnDemandProvisioningSpecification(input["OnDemandSpecification"]),
  }
}
function toInstanceFleetProvisioningSpecifications(root: jsonP.JSONValue): s.InstanceFleetProvisioningSpecifications {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpotSpecification": toSpotProvisioningSpecification,
      "OnDemandSpecification": toOnDemandProvisioningSpecification,
    },
  }, root);
}

function fromSpotProvisioningSpecification(input?: s.SpotProvisioningSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeoutDurationMinutes: input["TimeoutDurationMinutes"],
    TimeoutAction: input["TimeoutAction"],
    BlockDurationMinutes: input["BlockDurationMinutes"],
    AllocationStrategy: input["AllocationStrategy"],
  }
}
function toSpotProvisioningSpecification(root: jsonP.JSONValue): s.SpotProvisioningSpecification {
  return jsonP.readObj({
    required: {
      "TimeoutDurationMinutes": "n",
      "TimeoutAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.SpotProvisioningTimeoutAction>(x),
    },
    optional: {
      "BlockDurationMinutes": "n",
      "AllocationStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SpotProvisioningAllocationStrategy>(x),
    },
  }, root);
}

function fromOnDemandProvisioningSpecification(input?: s.OnDemandProvisioningSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllocationStrategy: input["AllocationStrategy"],
    CapacityReservationOptions: fromOnDemandCapacityReservationOptions(input["CapacityReservationOptions"]),
  }
}
function toOnDemandProvisioningSpecification(root: jsonP.JSONValue): s.OnDemandProvisioningSpecification {
  return jsonP.readObj({
    required: {
      "AllocationStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.OnDemandProvisioningAllocationStrategy>(x),
    },
    optional: {
      "CapacityReservationOptions": toOnDemandCapacityReservationOptions,
    },
  }, root);
}

function fromOnDemandCapacityReservationOptions(input?: s.OnDemandCapacityReservationOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UsageStrategy: input["UsageStrategy"],
    CapacityReservationPreference: input["CapacityReservationPreference"],
    CapacityReservationResourceGroupArn: input["CapacityReservationResourceGroupArn"],
  }
}
function toOnDemandCapacityReservationOptions(root: jsonP.JSONValue): s.OnDemandCapacityReservationOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "UsageStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.OnDemandCapacityReservationUsageStrategy>(x),
      "CapacityReservationPreference": (x: jsonP.JSONValue) => cmnP.readEnum<s.OnDemandCapacityReservationPreference>(x),
      "CapacityReservationResourceGroupArn": "s",
    },
  }, root);
}

function fromInstanceGroupConfig(input?: s.InstanceGroupConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Market: input["Market"],
    InstanceRole: input["InstanceRole"],
    BidPrice: input["BidPrice"],
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    AutoScalingPolicy: fromAutoScalingPolicy(input["AutoScalingPolicy"]),
  }
}

function fromAutoScalingPolicy(input?: s.AutoScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Constraints: fromScalingConstraints(input["Constraints"]),
    Rules: input["Rules"]?.map(x => fromScalingRule(x)),
  }
}

function fromScalingConstraints(input?: s.ScalingConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinCapacity: input["MinCapacity"],
    MaxCapacity: input["MaxCapacity"],
  }
}
function toScalingConstraints(root: jsonP.JSONValue): s.ScalingConstraints {
  return jsonP.readObj({
    required: {
      "MinCapacity": "n",
      "MaxCapacity": "n",
    },
    optional: {},
  }, root);
}

function fromScalingRule(input?: s.ScalingRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Action: fromScalingAction(input["Action"]),
    Trigger: fromScalingTrigger(input["Trigger"]),
  }
}
function toScalingRule(root: jsonP.JSONValue): s.ScalingRule {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Action": toScalingAction,
      "Trigger": toScalingTrigger,
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

function fromScalingAction(input?: s.ScalingAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Market: input["Market"],
    SimpleScalingPolicyConfiguration: fromSimpleScalingPolicyConfiguration(input["SimpleScalingPolicyConfiguration"]),
  }
}
function toScalingAction(root: jsonP.JSONValue): s.ScalingAction {
  return jsonP.readObj({
    required: {
      "SimpleScalingPolicyConfiguration": toSimpleScalingPolicyConfiguration,
    },
    optional: {
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<s.MarketType>(x),
    },
  }, root);
}

function fromSimpleScalingPolicyConfiguration(input?: s.SimpleScalingPolicyConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdjustmentType: input["AdjustmentType"],
    ScalingAdjustment: input["ScalingAdjustment"],
    CoolDown: input["CoolDown"],
  }
}
function toSimpleScalingPolicyConfiguration(root: jsonP.JSONValue): s.SimpleScalingPolicyConfiguration {
  return jsonP.readObj({
    required: {
      "ScalingAdjustment": "n",
    },
    optional: {
      "AdjustmentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdjustmentType>(x),
      "CoolDown": "n",
    },
  }, root);
}

function fromScalingTrigger(input?: s.ScalingTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchAlarmDefinition: fromCloudWatchAlarmDefinition(input["CloudWatchAlarmDefinition"]),
  }
}
function toScalingTrigger(root: jsonP.JSONValue): s.ScalingTrigger {
  return jsonP.readObj({
    required: {
      "CloudWatchAlarmDefinition": toCloudWatchAlarmDefinition,
    },
    optional: {},
  }, root);
}

function fromCloudWatchAlarmDefinition(input?: s.CloudWatchAlarmDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComparisonOperator: input["ComparisonOperator"],
    EvaluationPeriods: input["EvaluationPeriods"],
    MetricName: input["MetricName"],
    Namespace: input["Namespace"],
    Period: input["Period"],
    Statistic: input["Statistic"],
    Threshold: input["Threshold"],
    Unit: input["Unit"],
    Dimensions: input["Dimensions"]?.map(x => fromMetricDimension(x)),
  }
}
function toCloudWatchAlarmDefinition(root: jsonP.JSONValue): s.CloudWatchAlarmDefinition {
  return jsonP.readObj({
    required: {
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperator>(x),
      "MetricName": "s",
      "Period": "n",
      "Threshold": "n",
    },
    optional: {
      "EvaluationPeriods": "n",
      "Namespace": "s",
      "Statistic": (x: jsonP.JSONValue) => cmnP.readEnum<s.Statistic>(x),
      "Unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.Unit>(x),
      "Dimensions": [toMetricDimension],
    },
  }, root);
}

function fromMetricDimension(input?: s.MetricDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toMetricDimension(root: jsonP.JSONValue): s.MetricDimension {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromStepConfig(input?: s.StepConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ActionOnFailure: input["ActionOnFailure"],
    HadoopJarStep: fromHadoopJarStepConfig(input["HadoopJarStep"]),
  }
}
function toStepConfig(root: jsonP.JSONValue): s.StepConfig {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "HadoopJarStep": toHadoopJarStepConfig,
    },
    optional: {
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionOnFailure>(x),
    },
  }, root);
}

function fromHadoopJarStepConfig(input?: s.HadoopJarStepConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Properties: input["Properties"]?.map(x => fromKeyValue(x)),
    Jar: input["Jar"],
    MainClass: input["MainClass"],
    Args: input["Args"],
  }
}
function toHadoopJarStepConfig(root: jsonP.JSONValue): s.HadoopJarStepConfig {
  return jsonP.readObj({
    required: {
      "Jar": "s",
    },
    optional: {
      "Properties": [toKeyValue],
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

function fromKeyValue(input?: s.KeyValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toKeyValue(root: jsonP.JSONValue): s.KeyValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromInstanceFleetModifyConfig(input?: s.InstanceFleetModifyConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceFleetId: input["InstanceFleetId"],
    TargetOnDemandCapacity: input["TargetOnDemandCapacity"],
    TargetSpotCapacity: input["TargetSpotCapacity"],
  }
}

function fromInstanceGroupModifyConfig(input?: s.InstanceGroupModifyConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceGroupId: input["InstanceGroupId"],
    InstanceCount: input["InstanceCount"],
    EC2InstanceIdsToTerminate: input["EC2InstanceIdsToTerminate"],
    ShrinkPolicy: fromShrinkPolicy(input["ShrinkPolicy"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

function fromShrinkPolicy(input?: s.ShrinkPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DecommissionTimeout: input["DecommissionTimeout"],
    InstanceResizePolicy: fromInstanceResizePolicy(input["InstanceResizePolicy"]),
  }
}
function toShrinkPolicy(root: jsonP.JSONValue): s.ShrinkPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "DecommissionTimeout": "n",
      "InstanceResizePolicy": toInstanceResizePolicy,
    },
  }, root);
}

function fromInstanceResizePolicy(input?: s.InstanceResizePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstancesToTerminate: input["InstancesToTerminate"],
    InstancesToProtect: input["InstancesToProtect"],
    InstanceTerminationTimeout: input["InstanceTerminationTimeout"],
  }
}
function toInstanceResizePolicy(root: jsonP.JSONValue): s.InstanceResizePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstancesToTerminate": ["s"],
      "InstancesToProtect": ["s"],
      "InstanceTerminationTimeout": "n",
    },
  }, root);
}

function fromBlockPublicAccessConfiguration(input?: s.BlockPublicAccessConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlockPublicSecurityGroupRules: input["BlockPublicSecurityGroupRules"],
    PermittedPublicSecurityGroupRuleRanges: input["PermittedPublicSecurityGroupRuleRanges"]?.map(x => fromPortRange(x)),
  }
}
function toBlockPublicAccessConfiguration(root: jsonP.JSONValue): s.BlockPublicAccessConfiguration {
  return jsonP.readObj({
    required: {
      "BlockPublicSecurityGroupRules": "b",
    },
    optional: {
      "PermittedPublicSecurityGroupRuleRanges": [toPortRange],
    },
  }, root);
}

function fromPortRange(input?: s.PortRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinRange: input["MinRange"],
    MaxRange: input["MaxRange"],
  }
}
function toPortRange(root: jsonP.JSONValue): s.PortRange {
  return jsonP.readObj({
    required: {
      "MinRange": "n",
    },
    optional: {
      "MaxRange": "n",
    },
  }, root);
}

function fromManagedScalingPolicy(input?: s.ManagedScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComputeLimits: fromComputeLimits(input["ComputeLimits"]),
  }
}
function toManagedScalingPolicy(root: jsonP.JSONValue): s.ManagedScalingPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComputeLimits": toComputeLimits,
    },
  }, root);
}

function fromComputeLimits(input?: s.ComputeLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UnitType: input["UnitType"],
    MinimumCapacityUnits: input["MinimumCapacityUnits"],
    MaximumCapacityUnits: input["MaximumCapacityUnits"],
    MaximumOnDemandCapacityUnits: input["MaximumOnDemandCapacityUnits"],
    MaximumCoreCapacityUnits: input["MaximumCoreCapacityUnits"],
  }
}
function toComputeLimits(root: jsonP.JSONValue): s.ComputeLimits {
  return jsonP.readObj({
    required: {
      "UnitType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputeLimitsUnitType>(x),
      "MinimumCapacityUnits": "n",
      "MaximumCapacityUnits": "n",
    },
    optional: {
      "MaximumOnDemandCapacityUnits": "n",
      "MaximumCoreCapacityUnits": "n",
    },
  }, root);
}

function fromJobFlowInstancesConfig(input?: s.JobFlowInstancesConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MasterInstanceType: input["MasterInstanceType"],
    SlaveInstanceType: input["SlaveInstanceType"],
    InstanceCount: input["InstanceCount"],
    InstanceGroups: input["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
    InstanceFleets: input["InstanceFleets"]?.map(x => fromInstanceFleetConfig(x)),
    Ec2KeyName: input["Ec2KeyName"],
    Placement: fromPlacementType(input["Placement"]),
    KeepJobFlowAliveWhenNoSteps: input["KeepJobFlowAliveWhenNoSteps"],
    TerminationProtected: input["TerminationProtected"],
    HadoopVersion: input["HadoopVersion"],
    Ec2SubnetId: input["Ec2SubnetId"],
    Ec2SubnetIds: input["Ec2SubnetIds"],
    EmrManagedMasterSecurityGroup: input["EmrManagedMasterSecurityGroup"],
    EmrManagedSlaveSecurityGroup: input["EmrManagedSlaveSecurityGroup"],
    ServiceAccessSecurityGroup: input["ServiceAccessSecurityGroup"],
    AdditionalMasterSecurityGroups: input["AdditionalMasterSecurityGroups"],
    AdditionalSlaveSecurityGroups: input["AdditionalSlaveSecurityGroups"],
  }
}

function fromPlacementType(input?: s.PlacementType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZone: input["AvailabilityZone"],
    AvailabilityZones: input["AvailabilityZones"],
  }
}
function toPlacementType(root: jsonP.JSONValue): s.PlacementType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZone": "s",
      "AvailabilityZones": ["s"],
    },
  }, root);
}

function fromBootstrapActionConfig(input?: s.BootstrapActionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ScriptBootstrapAction: fromScriptBootstrapActionConfig(input["ScriptBootstrapAction"]),
  }
}
function toBootstrapActionConfig(root: jsonP.JSONValue): s.BootstrapActionConfig {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "ScriptBootstrapAction": toScriptBootstrapActionConfig,
    },
    optional: {},
  }, root);
}

function fromScriptBootstrapActionConfig(input?: s.ScriptBootstrapActionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    Args: input["Args"],
  }
}
function toScriptBootstrapActionConfig(root: jsonP.JSONValue): s.ScriptBootstrapActionConfig {
  return jsonP.readObj({
    required: {
      "Path": "s",
    },
    optional: {
      "Args": ["s"],
    },
  }, root);
}

function fromSupportedProductConfig(input?: s.SupportedProductConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Args: input["Args"],
  }
}

function fromApplication(input?: s.Application | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
    Args: input["Args"],
    AdditionalInfo: input["AdditionalInfo"],
  }
}
function toApplication(root: jsonP.JSONValue): s.Application {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
      "Args": ["s"],
      "AdditionalInfo": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromKerberosAttributes(input?: s.KerberosAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Realm: input["Realm"],
    KdcAdminPassword: input["KdcAdminPassword"],
    CrossRealmTrustPrincipalPassword: input["CrossRealmTrustPrincipalPassword"],
    ADDomainJoinUser: input["ADDomainJoinUser"],
    ADDomainJoinPassword: input["ADDomainJoinPassword"],
  }
}
function toKerberosAttributes(root: jsonP.JSONValue): s.KerberosAttributes {
  return jsonP.readObj({
    required: {
      "Realm": "s",
      "KdcAdminPassword": "s",
    },
    optional: {
      "CrossRealmTrustPrincipalPassword": "s",
      "ADDomainJoinUser": "s",
      "ADDomainJoinPassword": "s",
    },
  }, root);
}

function fromPlacementGroupConfig(input?: s.PlacementGroupConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceRole: input["InstanceRole"],
    PlacementStrategy: input["PlacementStrategy"],
  }
}
function toPlacementGroupConfig(root: jsonP.JSONValue): s.PlacementGroupConfig {
  return jsonP.readObj({
    required: {
      "InstanceRole": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceRoleType>(x),
    },
    optional: {
      "PlacementStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlacementGroupStrategy>(x),
    },
  }, root);
}

function fromExecutionEngineConfig(input?: s.ExecutionEngineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Type: input["Type"],
    MasterInstanceSecurityGroupId: input["MasterInstanceSecurityGroupId"],
  }
}
function toExecutionEngineConfig(root: jsonP.JSONValue): s.ExecutionEngineConfig {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionEngineType>(x),
      "MasterInstanceSecurityGroupId": "s",
    },
  }, root);
}

function toCancelStepsInfo(root: jsonP.JSONValue): s.CancelStepsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CancelStepsRequestStatus>(x),
      "Reason": "s",
    },
  }, root);
}

function toCluster(root: jsonP.JSONValue): s.Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "Ec2InstanceAttributes": toEc2InstanceAttributes,
      "InstanceCollectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceCollectionType>(x),
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "RequestedAmiVersion": "s",
      "RunningAmiVersion": "s",
      "ReleaseLabel": "s",
      "AutoTerminate": "b",
      "TerminationProtected": "b",
      "VisibleToAllUsers": "b",
      "Applications": [toApplication],
      "Tags": [toTag],
      "ServiceRole": "s",
      "NormalizedInstanceHours": "n",
      "MasterPublicDnsName": "s",
      "Configurations": [toConfiguration],
      "SecurityConfiguration": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScaleDownBehavior>(x),
      "CustomAmiId": "s",
      "EbsRootVolumeSize": "n",
      "RepoUpgradeOnBoot": (x: jsonP.JSONValue) => cmnP.readEnum<s.RepoUpgradeOnBoot>(x),
      "KerberosAttributes": toKerberosAttributes,
      "ClusterArn": "s",
      "OutpostArn": "s",
      "StepConcurrencyLevel": "n",
      "PlacementGroups": [toPlacementGroupConfig],
    },
  }, root);
}

function toClusterStatus(root: jsonP.JSONValue): s.ClusterStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
      "StateChangeReason": toClusterStateChangeReason,
      "Timeline": toClusterTimeline,
    },
  }, root);
}

function toClusterStateChangeReason(root: jsonP.JSONValue): s.ClusterStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toClusterTimeline(root: jsonP.JSONValue): s.ClusterTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toEc2InstanceAttributes(root: jsonP.JSONValue): s.Ec2InstanceAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "RequestedEc2SubnetIds": ["s"],
      "Ec2AvailabilityZone": "s",
      "RequestedEc2AvailabilityZones": ["s"],
      "IamInstanceProfile": "s",
      "EmrManagedMasterSecurityGroup": "s",
      "EmrManagedSlaveSecurityGroup": "s",
      "ServiceAccessSecurityGroup": "s",
      "AdditionalMasterSecurityGroups": ["s"],
      "AdditionalSlaveSecurityGroups": ["s"],
    },
  }, root);
}

function toJobFlowDetail(root: jsonP.JSONValue): s.JobFlowDetail {
  return jsonP.readObj({
    required: {
      "JobFlowId": "s",
      "Name": "s",
      "ExecutionStatusDetail": toJobFlowExecutionStatusDetail,
      "Instances": toJobFlowInstancesDetail,
    },
    optional: {
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "AmiVersion": "s",
      "Steps": [toStepDetail],
      "BootstrapActions": [toBootstrapActionDetail],
      "SupportedProducts": ["s"],
      "VisibleToAllUsers": "b",
      "JobFlowRole": "s",
      "ServiceRole": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScaleDownBehavior>(x),
    },
  }, root);
}

function toJobFlowExecutionStatusDetail(root: jsonP.JSONValue): s.JobFlowExecutionStatusDetail {
  return jsonP.readObj({
    required: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobFlowExecutionState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

function toJobFlowInstancesDetail(root: jsonP.JSONValue): s.JobFlowInstancesDetail {
  return jsonP.readObj({
    required: {
      "MasterInstanceType": "s",
      "SlaveInstanceType": "s",
      "InstanceCount": "n",
    },
    optional: {
      "MasterPublicDnsName": "s",
      "MasterInstanceId": "s",
      "InstanceGroups": [toInstanceGroupDetail],
      "NormalizedInstanceHours": "n",
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "Placement": toPlacementType,
      "KeepJobFlowAliveWhenNoSteps": "b",
      "TerminationProtected": "b",
      "HadoopVersion": "s",
    },
  }, root);
}

function toInstanceGroupDetail(root: jsonP.JSONValue): s.InstanceGroupDetail {
  return jsonP.readObj({
    required: {
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<s.MarketType>(x),
      "InstanceRole": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceRoleType>(x),
      "InstanceType": "s",
      "InstanceRequestCount": "n",
      "InstanceRunningCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceGroupState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "InstanceGroupId": "s",
      "Name": "s",
      "BidPrice": "s",
      "LastStateChangeReason": "s",
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toStepDetail(root: jsonP.JSONValue): s.StepDetail {
  return jsonP.readObj({
    required: {
      "StepConfig": toStepConfig,
      "ExecutionStatusDetail": toStepExecutionStatusDetail,
    },
    optional: {},
  }, root);
}

function toStepExecutionStatusDetail(root: jsonP.JSONValue): s.StepExecutionStatusDetail {
  return jsonP.readObj({
    required: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.StepExecutionState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

function toBootstrapActionDetail(root: jsonP.JSONValue): s.BootstrapActionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "BootstrapActionConfig": toBootstrapActionConfig,
    },
  }, root);
}

function toNotebookExecution(root: jsonP.JSONValue): s.NotebookExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "ExecutionEngine": toExecutionEngineConfig,
      "NotebookExecutionName": "s",
      "NotebookParams": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookExecutionStatus>(x),
      "StartTime": "d",
      "EndTime": "d",
      "Arn": "s",
      "OutputNotebookURI": "s",
      "LastStateChangeReason": "s",
      "NotebookInstanceSecurityGroupId": "s",
      "Tags": [toTag],
    },
  }, root);
}

function toStep(root: jsonP.JSONValue): s.Step {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionOnFailure>(x),
      "Status": toStepStatus,
    },
  }, root);
}

function toHadoopStepConfig(root: jsonP.JSONValue): s.HadoopStepConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Jar": "s",
      "Properties": x => jsonP.readMap(String, String, x),
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

function toStepStatus(root: jsonP.JSONValue): s.StepStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.StepState>(x),
      "StateChangeReason": toStepStateChangeReason,
      "FailureDetails": toFailureDetails,
      "Timeline": toStepTimeline,
    },
  }, root);
}

function toStepStateChangeReason(root: jsonP.JSONValue): s.StepStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.StepStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toFailureDetails(root: jsonP.JSONValue): s.FailureDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Reason": "s",
      "Message": "s",
      "LogFile": "s",
    },
  }, root);
}

function toStepTimeline(root: jsonP.JSONValue): s.StepTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "StartDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toStudio(root: jsonP.JSONValue): s.Studio {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "StudioArn": "s",
      "Name": "s",
      "Description": "s",
      "AuthMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthMode>(x),
      "VpcId": "s",
      "SubnetIds": ["s"],
      "ServiceRole": "s",
      "UserRole": "s",
      "WorkspaceSecurityGroupId": "s",
      "EngineSecurityGroupId": "s",
      "Url": "s",
      "CreationTime": "d",
      "DefaultS3Location": "s",
      "Tags": [toTag],
    },
  }, root);
}

function toBlockPublicAccessConfigurationMetadata(root: jsonP.JSONValue): s.BlockPublicAccessConfigurationMetadata {
  return jsonP.readObj({
    required: {
      "CreationDateTime": "d",
      "CreatedByArn": "s",
    },
    optional: {},
  }, root);
}

function toSessionMappingDetail(root: jsonP.JSONValue): s.SessionMappingDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "IdentityId": "s",
      "IdentityName": "s",
      "IdentityType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityType>(x),
      "SessionPolicyArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toCommand(root: jsonP.JSONValue): s.Command {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ScriptPath": "s",
      "Args": ["s"],
    },
  }, root);
}

function toClusterSummary(root: jsonP.JSONValue): s.ClusterSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "NormalizedInstanceHours": "n",
      "ClusterArn": "s",
      "OutpostArn": "s",
    },
  }, root);
}

function toInstanceFleet(root: jsonP.JSONValue): s.InstanceFleet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toInstanceFleetStatus,
      "InstanceFleetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceFleetType>(x),
      "TargetOnDemandCapacity": "n",
      "TargetSpotCapacity": "n",
      "ProvisionedOnDemandCapacity": "n",
      "ProvisionedSpotCapacity": "n",
      "InstanceTypeSpecifications": [toInstanceTypeSpecification],
      "LaunchSpecifications": toInstanceFleetProvisioningSpecifications,
    },
  }, root);
}

function toInstanceFleetStatus(root: jsonP.JSONValue): s.InstanceFleetStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceFleetState>(x),
      "StateChangeReason": toInstanceFleetStateChangeReason,
      "Timeline": toInstanceFleetTimeline,
    },
  }, root);
}

function toInstanceFleetStateChangeReason(root: jsonP.JSONValue): s.InstanceFleetStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceFleetStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toInstanceFleetTimeline(root: jsonP.JSONValue): s.InstanceFleetTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toInstanceTypeSpecification(root: jsonP.JSONValue): s.InstanceTypeSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceType": "s",
      "WeightedCapacity": "n",
      "BidPrice": "s",
      "BidPriceAsPercentageOfOnDemandPrice": "n",
      "Configurations": [toConfiguration],
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
    },
  }, root);
}

function toEbsBlockDevice(root: jsonP.JSONValue): s.EbsBlockDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeSpecification": toVolumeSpecification,
      "Device": "s",
    },
  }, root);
}

function toInstanceGroup(root: jsonP.JSONValue): s.InstanceGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<s.MarketType>(x),
      "InstanceGroupType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceGroupType>(x),
      "BidPrice": "s",
      "InstanceType": "s",
      "RequestedInstanceCount": "n",
      "RunningInstanceCount": "n",
      "Status": toInstanceGroupStatus,
      "Configurations": [toConfiguration],
      "ConfigurationsVersion": "n",
      "LastSuccessfullyAppliedConfigurations": [toConfiguration],
      "LastSuccessfullyAppliedConfigurationsVersion": "n",
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
      "ShrinkPolicy": toShrinkPolicy,
      "AutoScalingPolicy": toAutoScalingPolicyDescription,
    },
  }, root);
}

function toInstanceGroupStatus(root: jsonP.JSONValue): s.InstanceGroupStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceGroupState>(x),
      "StateChangeReason": toInstanceGroupStateChangeReason,
      "Timeline": toInstanceGroupTimeline,
    },
  }, root);
}

function toInstanceGroupStateChangeReason(root: jsonP.JSONValue): s.InstanceGroupStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceGroupStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toInstanceGroupTimeline(root: jsonP.JSONValue): s.InstanceGroupTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toAutoScalingPolicyDescription(root: jsonP.JSONValue): s.AutoScalingPolicyDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": toAutoScalingPolicyStatus,
      "Constraints": toScalingConstraints,
      "Rules": [toScalingRule],
    },
  }, root);
}

function toAutoScalingPolicyStatus(root: jsonP.JSONValue): s.AutoScalingPolicyStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoScalingPolicyState>(x),
      "StateChangeReason": toAutoScalingPolicyStateChangeReason,
    },
  }, root);
}

function toAutoScalingPolicyStateChangeReason(root: jsonP.JSONValue): s.AutoScalingPolicyStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoScalingPolicyStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toInstance(root: jsonP.JSONValue): s.Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Ec2InstanceId": "s",
      "PublicDnsName": "s",
      "PublicIpAddress": "s",
      "PrivateDnsName": "s",
      "PrivateIpAddress": "s",
      "Status": toInstanceStatus,
      "InstanceGroupId": "s",
      "InstanceFleetId": "s",
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<s.MarketType>(x),
      "InstanceType": "s",
      "EbsVolumes": [toEbsVolume],
    },
  }, root);
}

function toInstanceStatus(root: jsonP.JSONValue): s.InstanceStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceState>(x),
      "StateChangeReason": toInstanceStateChangeReason,
      "Timeline": toInstanceTimeline,
    },
  }, root);
}

function toInstanceStateChangeReason(root: jsonP.JSONValue): s.InstanceStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toInstanceTimeline(root: jsonP.JSONValue): s.InstanceTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

function toEbsVolume(root: jsonP.JSONValue): s.EbsVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "Device": "s",
      "VolumeId": "s",
    },
  }, root);
}

function toNotebookExecutionSummary(root: jsonP.JSONValue): s.NotebookExecutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "NotebookExecutionName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookExecutionStatus>(x),
      "StartTime": "d",
      "EndTime": "d",
    },
  }, root);
}

function toSecurityConfigurationSummary(root: jsonP.JSONValue): s.SecurityConfigurationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CreationDateTime": "d",
    },
  }, root);
}

function toStepSummary(root: jsonP.JSONValue): s.StepSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionOnFailure>(x),
      "Status": toStepStatus,
    },
  }, root);
}

function toSessionMappingSummary(root: jsonP.JSONValue): s.SessionMappingSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "IdentityId": "s",
      "IdentityName": "s",
      "IdentityType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityType>(x),
      "SessionPolicyArn": "s",
      "CreationTime": "d",
    },
  }, root);
}

function toStudioSummary(root: jsonP.JSONValue): s.StudioSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "Name": "s",
      "VpcId": "s",
      "Description": "s",
      "Url": "s",
      "CreationTime": "d",
    },
  }, root);
}
