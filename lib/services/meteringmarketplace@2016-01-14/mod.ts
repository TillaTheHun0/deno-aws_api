// Autogenerated API client for: AWSMarketplace Metering

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class MarketplaceMetering {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MarketplaceMetering.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-01-14",
    "endpointPrefix": "metering.marketplace",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWSMarketplace Metering",
    "serviceId": "Marketplace Metering",
    "signatureVersion": "v4",
    "signingName": "aws-marketplace",
    "targetPrefix": "AWSMPMeteringService",
    "uid": "meteringmarketplace-2016-01-14"
  };

  async batchMeterUsage(
    {abortSignal, ...params}: RequestConfig & BatchMeterUsageRequest,
  ): Promise<BatchMeterUsageResult> {
    const body: JSONObject = {...params,
    UsageRecords: params["UsageRecords"]?.map(x => fromUsageRecord(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchMeterUsage",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Results": [toUsageRecordResult],
        "UnprocessedRecords": [toUsageRecord],
      },
    }, await resp.json());
  }

  async meterUsage(
    {abortSignal, ...params}: RequestConfig & MeterUsageRequest,
  ): Promise<MeterUsageResult> {
    const body: JSONObject = {...params,
    Timestamp: prt.serializeDate_unixTimestamp(params["Timestamp"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MeterUsage",
    });
    return prt.readObj({
      required: {},
      optional: {
        "MeteringRecordId": "s",
      },
    }, await resp.json());
  }

  async registerUsage(
    {abortSignal, ...params}: RequestConfig & RegisterUsageRequest,
  ): Promise<RegisterUsageResult> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterUsage",
    });
    return prt.readObj({
      required: {},
      optional: {
        "PublicKeyRotationTimestamp": "d",
        "Signature": "s",
      },
    }, await resp.json());
  }

  async resolveCustomer(
    {abortSignal, ...params}: RequestConfig & ResolveCustomerRequest,
  ): Promise<ResolveCustomerResult> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResolveCustomer",
    });
    return prt.readObj({
      required: {},
      optional: {
        "CustomerIdentifier": "s",
        "ProductCode": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchMeterUsageRequest {
  UsageRecords: UsageRecord[];
  ProductCode: string;
}

// refs: 1 - tags: named, input
export interface MeterUsageRequest {
  ProductCode: string;
  Timestamp: Date | number;
  UsageDimension: string;
  UsageQuantity?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RegisterUsageRequest {
  ProductCode: string;
  PublicKeyVersion: number;
  Nonce?: string | null;
}

// refs: 1 - tags: named, input
export interface ResolveCustomerRequest {
  RegistrationToken: string;
}

// refs: 1 - tags: named, output
export interface BatchMeterUsageResult {
  Results?: UsageRecordResult[] | null;
  UnprocessedRecords?: UsageRecord[] | null;
}

// refs: 1 - tags: named, output
export interface MeterUsageResult {
  MeteringRecordId?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterUsageResult {
  PublicKeyRotationTimestamp?: Date | number | null;
  Signature?: string | null;
}

// refs: 1 - tags: named, output
export interface ResolveCustomerResult {
  CustomerIdentifier?: string | null;
  ProductCode?: string | null;
}

// refs: 3 - tags: input, named, interface, output
export interface UsageRecord {
  Timestamp: Date | number;
  CustomerIdentifier: string;
  Dimension: string;
  Quantity?: number | null;
}
function fromUsageRecord(input?: UsageRecord | null): JSONValue {
  if (!input) return input;
  return {...input,
    Timestamp: prt.serializeDate_unixTimestamp(input["Timestamp"]),
  }
}
function toUsageRecord(root: JSONValue): UsageRecord {
  return prt.readObj({
    required: {
      "Timestamp": "d",
      "CustomerIdentifier": "s",
      "Dimension": "s",
    },
    optional: {
      "Quantity": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UsageRecordResult {
  UsageRecord?: UsageRecord | null;
  MeteringRecordId?: string | null;
  Status?: UsageRecordResultStatus | null;
}
function toUsageRecordResult(root: JSONValue): UsageRecordResult {
  return prt.readObj({
    required: {},
    optional: {
      "UsageRecord": toUsageRecord,
      "MeteringRecordId": "s",
      "Status": toUsageRecordResultStatus,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type UsageRecordResultStatus =
| "Success"
| "CustomerNotSubscribed"
| "DuplicateRecord"
;
function toUsageRecordResultStatus(root: JSONValue): UsageRecordResultStatus | null {
  return ( false
    || root == "Success"
    || root == "CustomerNotSubscribed"
    || root == "DuplicateRecord"
  ) ? root : null;
}
