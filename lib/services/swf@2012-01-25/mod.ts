// Autogenerated API client for: Amazon Simple Workflow Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class SWF {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SWF.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-01-25",
    "endpointPrefix": "swf",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "Amazon SWF",
    "serviceFullName": "Amazon Simple Workflow Service",
    "serviceId": "SWF",
    "signatureVersion": "v4",
    "targetPrefix": "SimpleWorkflowService",
    "uid": "swf-2012-01-25"
  };

  async countClosedWorkflowExecutions(
    {abortSignal, ...params}: RequestConfig & s.CountClosedWorkflowExecutionsInput,
  ): Promise<s.WorkflowExecutionCount> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      startTimeFilter: fromExecutionTimeFilter(params["startTimeFilter"]),
      closeTimeFilter: fromExecutionTimeFilter(params["closeTimeFilter"]),
      executionFilter: fromWorkflowExecutionFilter(params["executionFilter"]),
      typeFilter: fromWorkflowTypeFilter(params["typeFilter"]),
      tagFilter: fromTagFilter(params["tagFilter"]),
      closeStatusFilter: fromCloseStatusFilter(params["closeStatusFilter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CountClosedWorkflowExecutions",
    });
    return jsonP.readObj({
      required: {
        "count": "n",
      },
      optional: {
        "truncated": "b",
      },
    }, await resp.json());
  }

  async countOpenWorkflowExecutions(
    {abortSignal, ...params}: RequestConfig & s.CountOpenWorkflowExecutionsInput,
  ): Promise<s.WorkflowExecutionCount> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      startTimeFilter: fromExecutionTimeFilter(params["startTimeFilter"]),
      typeFilter: fromWorkflowTypeFilter(params["typeFilter"]),
      tagFilter: fromTagFilter(params["tagFilter"]),
      executionFilter: fromWorkflowExecutionFilter(params["executionFilter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CountOpenWorkflowExecutions",
    });
    return jsonP.readObj({
      required: {
        "count": "n",
      },
      optional: {
        "truncated": "b",
      },
    }, await resp.json());
  }

  async countPendingActivityTasks(
    {abortSignal, ...params}: RequestConfig & s.CountPendingActivityTasksInput,
  ): Promise<s.PendingTaskCount> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      taskList: fromTaskList(params["taskList"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CountPendingActivityTasks",
    });
    return jsonP.readObj({
      required: {
        "count": "n",
      },
      optional: {
        "truncated": "b",
      },
    }, await resp.json());
  }

  async countPendingDecisionTasks(
    {abortSignal, ...params}: RequestConfig & s.CountPendingDecisionTasksInput,
  ): Promise<s.PendingTaskCount> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      taskList: fromTaskList(params["taskList"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CountPendingDecisionTasks",
    });
    return jsonP.readObj({
      required: {
        "count": "n",
      },
      optional: {
        "truncated": "b",
      },
    }, await resp.json());
  }

  async deprecateActivityType(
    {abortSignal, ...params}: RequestConfig & s.DeprecateActivityTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      activityType: fromActivityType(params["activityType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprecateActivityType",
    });
  }

  async deprecateDomain(
    {abortSignal, ...params}: RequestConfig & s.DeprecateDomainInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprecateDomain",
    });
  }

  async deprecateWorkflowType(
    {abortSignal, ...params}: RequestConfig & s.DeprecateWorkflowTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowType: fromWorkflowType(params["workflowType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprecateWorkflowType",
    });
  }

  async describeActivityType(
    {abortSignal, ...params}: RequestConfig & s.DescribeActivityTypeInput,
  ): Promise<s.ActivityTypeDetail> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      activityType: fromActivityType(params["activityType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeActivityType",
    });
    return jsonP.readObj({
      required: {
        "typeInfo": toActivityTypeInfo,
        "configuration": toActivityTypeConfiguration,
      },
      optional: {},
    }, await resp.json());
  }

  async describeDomain(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainInput,
  ): Promise<s.DomainDetail> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomain",
    });
    return jsonP.readObj({
      required: {
        "domainInfo": toDomainInfo,
        "configuration": toDomainConfiguration,
      },
      optional: {},
    }, await resp.json());
  }

  async describeWorkflowExecution(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorkflowExecutionInput,
  ): Promise<s.WorkflowExecutionDetail> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      execution: fromWorkflowExecution(params["execution"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkflowExecution",
    });
    return jsonP.readObj({
      required: {
        "executionInfo": toWorkflowExecutionInfo,
        "executionConfiguration": toWorkflowExecutionConfiguration,
        "openCounts": toWorkflowExecutionOpenCounts,
      },
      optional: {
        "latestActivityTaskTimestamp": "d",
        "latestExecutionContext": "s",
      },
    }, await resp.json());
  }

  async describeWorkflowType(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorkflowTypeInput,
  ): Promise<s.WorkflowTypeDetail> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowType: fromWorkflowType(params["workflowType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkflowType",
    });
    return jsonP.readObj({
      required: {
        "typeInfo": toWorkflowTypeInfo,
        "configuration": toWorkflowTypeConfiguration,
      },
      optional: {},
    }, await resp.json());
  }

  async getWorkflowExecutionHistory(
    {abortSignal, ...params}: RequestConfig & s.GetWorkflowExecutionHistoryInput,
  ): Promise<s.History> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      execution: fromWorkflowExecution(params["execution"]),
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowExecutionHistory",
    });
    return jsonP.readObj({
      required: {
        "events": [toHistoryEvent],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async listActivityTypes(
    {abortSignal, ...params}: RequestConfig & s.ListActivityTypesInput,
  ): Promise<s.ActivityTypeInfos> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      name: params["name"],
      registrationStatus: params["registrationStatus"],
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListActivityTypes",
    });
    return jsonP.readObj({
      required: {
        "typeInfos": [toActivityTypeInfo],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async listClosedWorkflowExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListClosedWorkflowExecutionsInput,
  ): Promise<s.WorkflowExecutionInfos> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      startTimeFilter: fromExecutionTimeFilter(params["startTimeFilter"]),
      closeTimeFilter: fromExecutionTimeFilter(params["closeTimeFilter"]),
      executionFilter: fromWorkflowExecutionFilter(params["executionFilter"]),
      closeStatusFilter: fromCloseStatusFilter(params["closeStatusFilter"]),
      typeFilter: fromWorkflowTypeFilter(params["typeFilter"]),
      tagFilter: fromTagFilter(params["tagFilter"]),
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClosedWorkflowExecutions",
    });
    return jsonP.readObj({
      required: {
        "executionInfos": [toWorkflowExecutionInfo],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & s.ListDomainsInput,
  ): Promise<s.DomainInfos> {
    const body: jsonP.JSONObject = {
      nextPageToken: params["nextPageToken"],
      registrationStatus: params["registrationStatus"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
    });
    return jsonP.readObj({
      required: {
        "domainInfos": [toDomainInfo],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async listOpenWorkflowExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListOpenWorkflowExecutionsInput,
  ): Promise<s.WorkflowExecutionInfos> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      startTimeFilter: fromExecutionTimeFilter(params["startTimeFilter"]),
      typeFilter: fromWorkflowTypeFilter(params["typeFilter"]),
      tagFilter: fromTagFilter(params["tagFilter"]),
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
      executionFilter: fromWorkflowExecutionFilter(params["executionFilter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOpenWorkflowExecutions",
    });
    return jsonP.readObj({
      required: {
        "executionInfos": [toWorkflowExecutionInfo],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toResourceTag],
      },
    }, await resp.json());
  }

  async listWorkflowTypes(
    {abortSignal, ...params}: RequestConfig & s.ListWorkflowTypesInput,
  ): Promise<s.WorkflowTypeInfos> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      name: params["name"],
      registrationStatus: params["registrationStatus"],
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkflowTypes",
    });
    return jsonP.readObj({
      required: {
        "typeInfos": [toWorkflowTypeInfo],
      },
      optional: {
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async pollForActivityTask(
    {abortSignal, ...params}: RequestConfig & s.PollForActivityTaskInput,
  ): Promise<s.ActivityTask> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      taskList: fromTaskList(params["taskList"]),
      identity: params["identity"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PollForActivityTask",
    });
    return jsonP.readObj({
      required: {
        "taskToken": "s",
        "activityId": "s",
        "startedEventId": "n",
        "workflowExecution": toWorkflowExecution,
        "activityType": toActivityType,
      },
      optional: {
        "input": "s",
      },
    }, await resp.json());
  }

  async pollForDecisionTask(
    {abortSignal, ...params}: RequestConfig & s.PollForDecisionTaskInput,
  ): Promise<s.DecisionTask> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      taskList: fromTaskList(params["taskList"]),
      identity: params["identity"],
      nextPageToken: params["nextPageToken"],
      maximumPageSize: params["maximumPageSize"],
      reverseOrder: params["reverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PollForDecisionTask",
    });
    return jsonP.readObj({
      required: {
        "taskToken": "s",
        "startedEventId": "n",
        "workflowExecution": toWorkflowExecution,
        "workflowType": toWorkflowType,
        "events": [toHistoryEvent],
      },
      optional: {
        "nextPageToken": "s",
        "previousStartedEventId": "n",
      },
    }, await resp.json());
  }

  async recordActivityTaskHeartbeat(
    {abortSignal, ...params}: RequestConfig & s.RecordActivityTaskHeartbeatInput,
  ): Promise<s.ActivityTaskStatus> {
    const body: jsonP.JSONObject = {
      taskToken: params["taskToken"],
      details: params["details"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecordActivityTaskHeartbeat",
    });
    return jsonP.readObj({
      required: {
        "cancelRequested": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async registerActivityType(
    {abortSignal, ...params}: RequestConfig & s.RegisterActivityTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      name: params["name"],
      version: params["version"],
      description: params["description"],
      defaultTaskStartToCloseTimeout: params["defaultTaskStartToCloseTimeout"],
      defaultTaskHeartbeatTimeout: params["defaultTaskHeartbeatTimeout"],
      defaultTaskList: fromTaskList(params["defaultTaskList"]),
      defaultTaskPriority: params["defaultTaskPriority"],
      defaultTaskScheduleToStartTimeout: params["defaultTaskScheduleToStartTimeout"],
      defaultTaskScheduleToCloseTimeout: params["defaultTaskScheduleToCloseTimeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterActivityType",
    });
  }

  async registerDomain(
    {abortSignal, ...params}: RequestConfig & s.RegisterDomainInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      workflowExecutionRetentionPeriodInDays: params["workflowExecutionRetentionPeriodInDays"],
      tags: params["tags"]?.map(x => fromResourceTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterDomain",
    });
  }

  async registerWorkflowType(
    {abortSignal, ...params}: RequestConfig & s.RegisterWorkflowTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      name: params["name"],
      version: params["version"],
      description: params["description"],
      defaultTaskStartToCloseTimeout: params["defaultTaskStartToCloseTimeout"],
      defaultExecutionStartToCloseTimeout: params["defaultExecutionStartToCloseTimeout"],
      defaultTaskList: fromTaskList(params["defaultTaskList"]),
      defaultTaskPriority: params["defaultTaskPriority"],
      defaultChildPolicy: params["defaultChildPolicy"],
      defaultLambdaRole: params["defaultLambdaRole"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterWorkflowType",
    });
  }

  async requestCancelWorkflowExecution(
    {abortSignal, ...params}: RequestConfig & s.RequestCancelWorkflowExecutionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowId: params["workflowId"],
      runId: params["runId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestCancelWorkflowExecution",
    });
  }

  async respondActivityTaskCanceled(
    {abortSignal, ...params}: RequestConfig & s.RespondActivityTaskCanceledInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      taskToken: params["taskToken"],
      details: params["details"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RespondActivityTaskCanceled",
    });
  }

  async respondActivityTaskCompleted(
    {abortSignal, ...params}: RequestConfig & s.RespondActivityTaskCompletedInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      taskToken: params["taskToken"],
      result: params["result"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RespondActivityTaskCompleted",
    });
  }

  async respondActivityTaskFailed(
    {abortSignal, ...params}: RequestConfig & s.RespondActivityTaskFailedInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      taskToken: params["taskToken"],
      reason: params["reason"],
      details: params["details"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RespondActivityTaskFailed",
    });
  }

  async respondDecisionTaskCompleted(
    {abortSignal, ...params}: RequestConfig & s.RespondDecisionTaskCompletedInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      taskToken: params["taskToken"],
      decisions: params["decisions"]?.map(x => fromDecision(x)),
      executionContext: params["executionContext"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RespondDecisionTaskCompleted",
    });
  }

  async signalWorkflowExecution(
    {abortSignal, ...params}: RequestConfig & s.SignalWorkflowExecutionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowId: params["workflowId"],
      runId: params["runId"],
      signalName: params["signalName"],
      input: params["input"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SignalWorkflowExecution",
    });
  }

  async startWorkflowExecution(
    {abortSignal, ...params}: RequestConfig & s.StartWorkflowExecutionInput,
  ): Promise<s.Run> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowId: params["workflowId"],
      workflowType: fromWorkflowType(params["workflowType"]),
      taskList: fromTaskList(params["taskList"]),
      taskPriority: params["taskPriority"],
      input: params["input"],
      executionStartToCloseTimeout: params["executionStartToCloseTimeout"],
      tagList: params["tagList"],
      taskStartToCloseTimeout: params["taskStartToCloseTimeout"],
      childPolicy: params["childPolicy"],
      lambdaRole: params["lambdaRole"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartWorkflowExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "runId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromResourceTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async terminateWorkflowExecution(
    {abortSignal, ...params}: RequestConfig & s.TerminateWorkflowExecutionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowId: params["workflowId"],
      runId: params["runId"],
      reason: params["reason"],
      details: params["details"],
      childPolicy: params["childPolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateWorkflowExecution",
    });
  }

  async undeprecateActivityType(
    {abortSignal, ...params}: RequestConfig & s.UndeprecateActivityTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      activityType: fromActivityType(params["activityType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UndeprecateActivityType",
    });
  }

  async undeprecateDomain(
    {abortSignal, ...params}: RequestConfig & s.UndeprecateDomainInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UndeprecateDomain",
    });
  }

  async undeprecateWorkflowType(
    {abortSignal, ...params}: RequestConfig & s.UndeprecateWorkflowTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      workflowType: fromWorkflowType(params["workflowType"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UndeprecateWorkflowType",
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

}

function fromExecutionTimeFilter(input?: s.ExecutionTimeFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    oldestDate: jsonP.serializeDate_unixTimestamp(input["oldestDate"]),
    latestDate: jsonP.serializeDate_unixTimestamp(input["latestDate"]),
  }
}

function fromWorkflowExecutionFilter(input?: s.WorkflowExecutionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    workflowId: input["workflowId"],
  }
}

function fromWorkflowTypeFilter(input?: s.WorkflowTypeFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}

function fromTagFilter(input?: s.TagFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tag: input["tag"],
  }
}

function fromCloseStatusFilter(input?: s.CloseStatusFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
  }
}

function fromTaskList(input?: s.TaskList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toTaskList(root: jsonP.JSONValue): s.TaskList {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromActivityType(input?: s.ActivityType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}
function toActivityType(root: jsonP.JSONValue): s.ActivityType {
  return jsonP.readObj({
    required: {
      "name": "s",
      "version": "s",
    },
    optional: {},
  }, root);
}

function fromWorkflowType(input?: s.WorkflowType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    version: input["version"],
  }
}
function toWorkflowType(root: jsonP.JSONValue): s.WorkflowType {
  return jsonP.readObj({
    required: {
      "name": "s",
      "version": "s",
    },
    optional: {},
  }, root);
}

function fromWorkflowExecution(input?: s.WorkflowExecution | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    workflowId: input["workflowId"],
    runId: input["runId"],
  }
}
function toWorkflowExecution(root: jsonP.JSONValue): s.WorkflowExecution {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "runId": "s",
    },
    optional: {},
  }, root);
}

function fromResourceTag(input?: s.ResourceTag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toResourceTag(root: jsonP.JSONValue): s.ResourceTag {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "value": "s",
    },
  }, root);
}

function fromDecision(input?: s.Decision | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    decisionType: input["decisionType"],
    scheduleActivityTaskDecisionAttributes: fromScheduleActivityTaskDecisionAttributes(input["scheduleActivityTaskDecisionAttributes"]),
    requestCancelActivityTaskDecisionAttributes: fromRequestCancelActivityTaskDecisionAttributes(input["requestCancelActivityTaskDecisionAttributes"]),
    completeWorkflowExecutionDecisionAttributes: fromCompleteWorkflowExecutionDecisionAttributes(input["completeWorkflowExecutionDecisionAttributes"]),
    failWorkflowExecutionDecisionAttributes: fromFailWorkflowExecutionDecisionAttributes(input["failWorkflowExecutionDecisionAttributes"]),
    cancelWorkflowExecutionDecisionAttributes: fromCancelWorkflowExecutionDecisionAttributes(input["cancelWorkflowExecutionDecisionAttributes"]),
    continueAsNewWorkflowExecutionDecisionAttributes: fromContinueAsNewWorkflowExecutionDecisionAttributes(input["continueAsNewWorkflowExecutionDecisionAttributes"]),
    recordMarkerDecisionAttributes: fromRecordMarkerDecisionAttributes(input["recordMarkerDecisionAttributes"]),
    startTimerDecisionAttributes: fromStartTimerDecisionAttributes(input["startTimerDecisionAttributes"]),
    cancelTimerDecisionAttributes: fromCancelTimerDecisionAttributes(input["cancelTimerDecisionAttributes"]),
    signalExternalWorkflowExecutionDecisionAttributes: fromSignalExternalWorkflowExecutionDecisionAttributes(input["signalExternalWorkflowExecutionDecisionAttributes"]),
    requestCancelExternalWorkflowExecutionDecisionAttributes: fromRequestCancelExternalWorkflowExecutionDecisionAttributes(input["requestCancelExternalWorkflowExecutionDecisionAttributes"]),
    startChildWorkflowExecutionDecisionAttributes: fromStartChildWorkflowExecutionDecisionAttributes(input["startChildWorkflowExecutionDecisionAttributes"]),
    scheduleLambdaFunctionDecisionAttributes: fromScheduleLambdaFunctionDecisionAttributes(input["scheduleLambdaFunctionDecisionAttributes"]),
  }
}

function fromScheduleActivityTaskDecisionAttributes(input?: s.ScheduleActivityTaskDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    activityType: fromActivityType(input["activityType"]),
    activityId: input["activityId"],
    control: input["control"],
    input: input["input"],
    scheduleToCloseTimeout: input["scheduleToCloseTimeout"],
    taskList: fromTaskList(input["taskList"]),
    taskPriority: input["taskPriority"],
    scheduleToStartTimeout: input["scheduleToStartTimeout"],
    startToCloseTimeout: input["startToCloseTimeout"],
    heartbeatTimeout: input["heartbeatTimeout"],
  }
}

function fromRequestCancelActivityTaskDecisionAttributes(input?: s.RequestCancelActivityTaskDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    activityId: input["activityId"],
  }
}

function fromCompleteWorkflowExecutionDecisionAttributes(input?: s.CompleteWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    result: input["result"],
  }
}

function fromFailWorkflowExecutionDecisionAttributes(input?: s.FailWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    reason: input["reason"],
    details: input["details"],
  }
}

function fromCancelWorkflowExecutionDecisionAttributes(input?: s.CancelWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    details: input["details"],
  }
}

function fromContinueAsNewWorkflowExecutionDecisionAttributes(input?: s.ContinueAsNewWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    input: input["input"],
    executionStartToCloseTimeout: input["executionStartToCloseTimeout"],
    taskList: fromTaskList(input["taskList"]),
    taskPriority: input["taskPriority"],
    taskStartToCloseTimeout: input["taskStartToCloseTimeout"],
    childPolicy: input["childPolicy"],
    tagList: input["tagList"],
    workflowTypeVersion: input["workflowTypeVersion"],
    lambdaRole: input["lambdaRole"],
  }
}

function fromRecordMarkerDecisionAttributes(input?: s.RecordMarkerDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    markerName: input["markerName"],
    details: input["details"],
  }
}

function fromStartTimerDecisionAttributes(input?: s.StartTimerDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timerId: input["timerId"],
    control: input["control"],
    startToFireTimeout: input["startToFireTimeout"],
  }
}

function fromCancelTimerDecisionAttributes(input?: s.CancelTimerDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timerId: input["timerId"],
  }
}

function fromSignalExternalWorkflowExecutionDecisionAttributes(input?: s.SignalExternalWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    workflowId: input["workflowId"],
    runId: input["runId"],
    signalName: input["signalName"],
    input: input["input"],
    control: input["control"],
  }
}

function fromRequestCancelExternalWorkflowExecutionDecisionAttributes(input?: s.RequestCancelExternalWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    workflowId: input["workflowId"],
    runId: input["runId"],
    control: input["control"],
  }
}

function fromStartChildWorkflowExecutionDecisionAttributes(input?: s.StartChildWorkflowExecutionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    workflowType: fromWorkflowType(input["workflowType"]),
    workflowId: input["workflowId"],
    control: input["control"],
    input: input["input"],
    executionStartToCloseTimeout: input["executionStartToCloseTimeout"],
    taskList: fromTaskList(input["taskList"]),
    taskPriority: input["taskPriority"],
    taskStartToCloseTimeout: input["taskStartToCloseTimeout"],
    childPolicy: input["childPolicy"],
    tagList: input["tagList"],
    lambdaRole: input["lambdaRole"],
  }
}

function fromScheduleLambdaFunctionDecisionAttributes(input?: s.ScheduleLambdaFunctionDecisionAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    name: input["name"],
    control: input["control"],
    input: input["input"],
    startToCloseTimeout: input["startToCloseTimeout"],
  }
}

function toActivityTypeInfo(root: jsonP.JSONValue): s.ActivityTypeInfo {
  return jsonP.readObj({
    required: {
      "activityType": toActivityType,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistrationStatus>(x),
      "creationDate": "d",
    },
    optional: {
      "description": "s",
      "deprecationDate": "d",
    },
  }, root);
}

function toActivityTypeConfiguration(root: jsonP.JSONValue): s.ActivityTypeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "defaultTaskStartToCloseTimeout": "s",
      "defaultTaskHeartbeatTimeout": "s",
      "defaultTaskList": toTaskList,
      "defaultTaskPriority": "s",
      "defaultTaskScheduleToStartTimeout": "s",
      "defaultTaskScheduleToCloseTimeout": "s",
    },
  }, root);
}

function toDomainInfo(root: jsonP.JSONValue): s.DomainInfo {
  return jsonP.readObj({
    required: {
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistrationStatus>(x),
    },
    optional: {
      "description": "s",
      "arn": "s",
    },
  }, root);
}

function toDomainConfiguration(root: jsonP.JSONValue): s.DomainConfiguration {
  return jsonP.readObj({
    required: {
      "workflowExecutionRetentionPeriodInDays": "s",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionInfo(root: jsonP.JSONValue): s.WorkflowExecutionInfo {
  return jsonP.readObj({
    required: {
      "execution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "startTimestamp": "d",
      "executionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionStatus>(x),
    },
    optional: {
      "closeTimestamp": "d",
      "closeStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloseStatus>(x),
      "parent": toWorkflowExecution,
      "tagList": ["s"],
      "cancelRequested": "b",
    },
  }, root);
}

function toWorkflowExecutionConfiguration(root: jsonP.JSONValue): s.WorkflowExecutionConfiguration {
  return jsonP.readObj({
    required: {
      "taskStartToCloseTimeout": "s",
      "executionStartToCloseTimeout": "s",
      "taskList": toTaskList,
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
    },
    optional: {
      "taskPriority": "s",
      "lambdaRole": "s",
    },
  }, root);
}

function toWorkflowExecutionOpenCounts(root: jsonP.JSONValue): s.WorkflowExecutionOpenCounts {
  return jsonP.readObj({
    required: {
      "openActivityTasks": "n",
      "openDecisionTasks": "n",
      "openTimers": "n",
      "openChildWorkflowExecutions": "n",
    },
    optional: {
      "openLambdaFunctions": "n",
    },
  }, root);
}

function toWorkflowTypeInfo(root: jsonP.JSONValue): s.WorkflowTypeInfo {
  return jsonP.readObj({
    required: {
      "workflowType": toWorkflowType,
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistrationStatus>(x),
      "creationDate": "d",
    },
    optional: {
      "description": "s",
      "deprecationDate": "d",
    },
  }, root);
}

function toWorkflowTypeConfiguration(root: jsonP.JSONValue): s.WorkflowTypeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "defaultTaskStartToCloseTimeout": "s",
      "defaultExecutionStartToCloseTimeout": "s",
      "defaultTaskList": toTaskList,
      "defaultTaskPriority": "s",
      "defaultChildPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
      "defaultLambdaRole": "s",
    },
  }, root);
}

function toHistoryEvent(root: jsonP.JSONValue): s.HistoryEvent {
  return jsonP.readObj({
    required: {
      "eventTimestamp": "d",
      "eventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventType>(x),
      "eventId": "n",
    },
    optional: {
      "workflowExecutionStartedEventAttributes": toWorkflowExecutionStartedEventAttributes,
      "workflowExecutionCompletedEventAttributes": toWorkflowExecutionCompletedEventAttributes,
      "completeWorkflowExecutionFailedEventAttributes": toCompleteWorkflowExecutionFailedEventAttributes,
      "workflowExecutionFailedEventAttributes": toWorkflowExecutionFailedEventAttributes,
      "failWorkflowExecutionFailedEventAttributes": toFailWorkflowExecutionFailedEventAttributes,
      "workflowExecutionTimedOutEventAttributes": toWorkflowExecutionTimedOutEventAttributes,
      "workflowExecutionCanceledEventAttributes": toWorkflowExecutionCanceledEventAttributes,
      "cancelWorkflowExecutionFailedEventAttributes": toCancelWorkflowExecutionFailedEventAttributes,
      "workflowExecutionContinuedAsNewEventAttributes": toWorkflowExecutionContinuedAsNewEventAttributes,
      "continueAsNewWorkflowExecutionFailedEventAttributes": toContinueAsNewWorkflowExecutionFailedEventAttributes,
      "workflowExecutionTerminatedEventAttributes": toWorkflowExecutionTerminatedEventAttributes,
      "workflowExecutionCancelRequestedEventAttributes": toWorkflowExecutionCancelRequestedEventAttributes,
      "decisionTaskScheduledEventAttributes": toDecisionTaskScheduledEventAttributes,
      "decisionTaskStartedEventAttributes": toDecisionTaskStartedEventAttributes,
      "decisionTaskCompletedEventAttributes": toDecisionTaskCompletedEventAttributes,
      "decisionTaskTimedOutEventAttributes": toDecisionTaskTimedOutEventAttributes,
      "activityTaskScheduledEventAttributes": toActivityTaskScheduledEventAttributes,
      "activityTaskStartedEventAttributes": toActivityTaskStartedEventAttributes,
      "activityTaskCompletedEventAttributes": toActivityTaskCompletedEventAttributes,
      "activityTaskFailedEventAttributes": toActivityTaskFailedEventAttributes,
      "activityTaskTimedOutEventAttributes": toActivityTaskTimedOutEventAttributes,
      "activityTaskCanceledEventAttributes": toActivityTaskCanceledEventAttributes,
      "activityTaskCancelRequestedEventAttributes": toActivityTaskCancelRequestedEventAttributes,
      "workflowExecutionSignaledEventAttributes": toWorkflowExecutionSignaledEventAttributes,
      "markerRecordedEventAttributes": toMarkerRecordedEventAttributes,
      "recordMarkerFailedEventAttributes": toRecordMarkerFailedEventAttributes,
      "timerStartedEventAttributes": toTimerStartedEventAttributes,
      "timerFiredEventAttributes": toTimerFiredEventAttributes,
      "timerCanceledEventAttributes": toTimerCanceledEventAttributes,
      "startChildWorkflowExecutionInitiatedEventAttributes": toStartChildWorkflowExecutionInitiatedEventAttributes,
      "childWorkflowExecutionStartedEventAttributes": toChildWorkflowExecutionStartedEventAttributes,
      "childWorkflowExecutionCompletedEventAttributes": toChildWorkflowExecutionCompletedEventAttributes,
      "childWorkflowExecutionFailedEventAttributes": toChildWorkflowExecutionFailedEventAttributes,
      "childWorkflowExecutionTimedOutEventAttributes": toChildWorkflowExecutionTimedOutEventAttributes,
      "childWorkflowExecutionCanceledEventAttributes": toChildWorkflowExecutionCanceledEventAttributes,
      "childWorkflowExecutionTerminatedEventAttributes": toChildWorkflowExecutionTerminatedEventAttributes,
      "signalExternalWorkflowExecutionInitiatedEventAttributes": toSignalExternalWorkflowExecutionInitiatedEventAttributes,
      "externalWorkflowExecutionSignaledEventAttributes": toExternalWorkflowExecutionSignaledEventAttributes,
      "signalExternalWorkflowExecutionFailedEventAttributes": toSignalExternalWorkflowExecutionFailedEventAttributes,
      "externalWorkflowExecutionCancelRequestedEventAttributes": toExternalWorkflowExecutionCancelRequestedEventAttributes,
      "requestCancelExternalWorkflowExecutionInitiatedEventAttributes": toRequestCancelExternalWorkflowExecutionInitiatedEventAttributes,
      "requestCancelExternalWorkflowExecutionFailedEventAttributes": toRequestCancelExternalWorkflowExecutionFailedEventAttributes,
      "scheduleActivityTaskFailedEventAttributes": toScheduleActivityTaskFailedEventAttributes,
      "requestCancelActivityTaskFailedEventAttributes": toRequestCancelActivityTaskFailedEventAttributes,
      "startTimerFailedEventAttributes": toStartTimerFailedEventAttributes,
      "cancelTimerFailedEventAttributes": toCancelTimerFailedEventAttributes,
      "startChildWorkflowExecutionFailedEventAttributes": toStartChildWorkflowExecutionFailedEventAttributes,
      "lambdaFunctionScheduledEventAttributes": toLambdaFunctionScheduledEventAttributes,
      "lambdaFunctionStartedEventAttributes": toLambdaFunctionStartedEventAttributes,
      "lambdaFunctionCompletedEventAttributes": toLambdaFunctionCompletedEventAttributes,
      "lambdaFunctionFailedEventAttributes": toLambdaFunctionFailedEventAttributes,
      "lambdaFunctionTimedOutEventAttributes": toLambdaFunctionTimedOutEventAttributes,
      "scheduleLambdaFunctionFailedEventAttributes": toScheduleLambdaFunctionFailedEventAttributes,
      "startLambdaFunctionFailedEventAttributes": toStartLambdaFunctionFailedEventAttributes,
    },
  }, root);
}

function toWorkflowExecutionStartedEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
      "taskList": toTaskList,
      "workflowType": toWorkflowType,
    },
    optional: {
      "input": "s",
      "executionStartToCloseTimeout": "s",
      "taskStartToCloseTimeout": "s",
      "taskPriority": "s",
      "tagList": ["s"],
      "continuedExecutionRunId": "s",
      "parentWorkflowExecution": toWorkflowExecution,
      "parentInitiatedEventId": "n",
      "lambdaRole": "s",
    },
  }, root);
}

function toWorkflowExecutionCompletedEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionCompletedEventAttributes {
  return jsonP.readObj({
    required: {
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "result": "s",
    },
  }, root);
}

function toCompleteWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.CompleteWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompleteWorkflowExecutionFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "reason": "s",
      "details": "s",
    },
  }, root);
}

function toFailWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.FailWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailWorkflowExecutionFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionTimedOutEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionTimedOutEventAttributes {
  return jsonP.readObj({
    required: {
      "timeoutType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowExecutionTimeoutType>(x),
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionCanceledEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionCanceledEventAttributes {
  return jsonP.readObj({
    required: {
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "details": "s",
    },
  }, root);
}

function toCancelWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.CancelWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.CancelWorkflowExecutionFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionContinuedAsNewEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionContinuedAsNewEventAttributes {
  return jsonP.readObj({
    required: {
      "decisionTaskCompletedEventId": "n",
      "newExecutionRunId": "s",
      "taskList": toTaskList,
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
      "workflowType": toWorkflowType,
    },
    optional: {
      "input": "s",
      "executionStartToCloseTimeout": "s",
      "taskPriority": "s",
      "taskStartToCloseTimeout": "s",
      "tagList": ["s"],
      "lambdaRole": "s",
    },
  }, root);
}

function toContinueAsNewWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.ContinueAsNewWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContinueAsNewWorkflowExecutionFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionTerminatedEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionTerminatedEventAttributes {
  return jsonP.readObj({
    required: {
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
    },
    optional: {
      "reason": "s",
      "details": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowExecutionTerminatedCause>(x),
    },
  }, root);
}

function toWorkflowExecutionCancelRequestedEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionCancelRequestedEventAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "externalWorkflowExecution": toWorkflowExecution,
      "externalInitiatedEventId": "n",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowExecutionCancelRequestedCause>(x),
    },
  }, root);
}

function toDecisionTaskScheduledEventAttributes(root: jsonP.JSONValue): s.DecisionTaskScheduledEventAttributes {
  return jsonP.readObj({
    required: {
      "taskList": toTaskList,
    },
    optional: {
      "taskPriority": "s",
      "startToCloseTimeout": "s",
    },
  }, root);
}

function toDecisionTaskStartedEventAttributes(root: jsonP.JSONValue): s.DecisionTaskStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
    },
    optional: {
      "identity": "s",
    },
  }, root);
}

function toDecisionTaskCompletedEventAttributes(root: jsonP.JSONValue): s.DecisionTaskCompletedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "executionContext": "s",
    },
  }, root);
}

function toDecisionTaskTimedOutEventAttributes(root: jsonP.JSONValue): s.DecisionTaskTimedOutEventAttributes {
  return jsonP.readObj({
    required: {
      "timeoutType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DecisionTaskTimeoutType>(x),
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {},
  }, root);
}

function toActivityTaskScheduledEventAttributes(root: jsonP.JSONValue): s.ActivityTaskScheduledEventAttributes {
  return jsonP.readObj({
    required: {
      "activityType": toActivityType,
      "activityId": "s",
      "taskList": toTaskList,
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "input": "s",
      "control": "s",
      "scheduleToStartTimeout": "s",
      "scheduleToCloseTimeout": "s",
      "startToCloseTimeout": "s",
      "taskPriority": "s",
      "heartbeatTimeout": "s",
    },
  }, root);
}

function toActivityTaskStartedEventAttributes(root: jsonP.JSONValue): s.ActivityTaskStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
    },
    optional: {
      "identity": "s",
    },
  }, root);
}

function toActivityTaskCompletedEventAttributes(root: jsonP.JSONValue): s.ActivityTaskCompletedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "result": "s",
    },
  }, root);
}

function toActivityTaskFailedEventAttributes(root: jsonP.JSONValue): s.ActivityTaskFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "reason": "s",
      "details": "s",
    },
  }, root);
}

function toActivityTaskTimedOutEventAttributes(root: jsonP.JSONValue): s.ActivityTaskTimedOutEventAttributes {
  return jsonP.readObj({
    required: {
      "timeoutType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActivityTaskTimeoutType>(x),
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "details": "s",
    },
  }, root);
}

function toActivityTaskCanceledEventAttributes(root: jsonP.JSONValue): s.ActivityTaskCanceledEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "details": "s",
      "latestCancelRequestedEventId": "n",
    },
  }, root);
}

function toActivityTaskCancelRequestedEventAttributes(root: jsonP.JSONValue): s.ActivityTaskCancelRequestedEventAttributes {
  return jsonP.readObj({
    required: {
      "decisionTaskCompletedEventId": "n",
      "activityId": "s",
    },
    optional: {},
  }, root);
}

function toWorkflowExecutionSignaledEventAttributes(root: jsonP.JSONValue): s.WorkflowExecutionSignaledEventAttributes {
  return jsonP.readObj({
    required: {
      "signalName": "s",
    },
    optional: {
      "input": "s",
      "externalWorkflowExecution": toWorkflowExecution,
      "externalInitiatedEventId": "n",
    },
  }, root);
}

function toMarkerRecordedEventAttributes(root: jsonP.JSONValue): s.MarkerRecordedEventAttributes {
  return jsonP.readObj({
    required: {
      "markerName": "s",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "details": "s",
    },
  }, root);
}

function toRecordMarkerFailedEventAttributes(root: jsonP.JSONValue): s.RecordMarkerFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "markerName": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordMarkerFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toTimerStartedEventAttributes(root: jsonP.JSONValue): s.TimerStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "timerId": "s",
      "startToFireTimeout": "s",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "control": "s",
    },
  }, root);
}

function toTimerFiredEventAttributes(root: jsonP.JSONValue): s.TimerFiredEventAttributes {
  return jsonP.readObj({
    required: {
      "timerId": "s",
      "startedEventId": "n",
    },
    optional: {},
  }, root);
}

function toTimerCanceledEventAttributes(root: jsonP.JSONValue): s.TimerCanceledEventAttributes {
  return jsonP.readObj({
    required: {
      "timerId": "s",
      "startedEventId": "n",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toStartChildWorkflowExecutionInitiatedEventAttributes(root: jsonP.JSONValue): s.StartChildWorkflowExecutionInitiatedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "workflowType": toWorkflowType,
      "taskList": toTaskList,
      "decisionTaskCompletedEventId": "n",
      "childPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChildPolicy>(x),
    },
    optional: {
      "control": "s",
      "input": "s",
      "executionStartToCloseTimeout": "s",
      "taskPriority": "s",
      "taskStartToCloseTimeout": "s",
      "tagList": ["s"],
      "lambdaRole": "s",
    },
  }, root);
}

function toChildWorkflowExecutionStartedEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "initiatedEventId": "n",
    },
    optional: {},
  }, root);
}

function toChildWorkflowExecutionCompletedEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionCompletedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "initiatedEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "result": "s",
    },
  }, root);
}

function toChildWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "initiatedEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "reason": "s",
      "details": "s",
    },
  }, root);
}

function toChildWorkflowExecutionTimedOutEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionTimedOutEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "timeoutType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowExecutionTimeoutType>(x),
      "initiatedEventId": "n",
      "startedEventId": "n",
    },
    optional: {},
  }, root);
}

function toChildWorkflowExecutionCanceledEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionCanceledEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "initiatedEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "details": "s",
    },
  }, root);
}

function toChildWorkflowExecutionTerminatedEventAttributes(root: jsonP.JSONValue): s.ChildWorkflowExecutionTerminatedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "workflowType": toWorkflowType,
      "initiatedEventId": "n",
      "startedEventId": "n",
    },
    optional: {},
  }, root);
}

function toSignalExternalWorkflowExecutionInitiatedEventAttributes(root: jsonP.JSONValue): s.SignalExternalWorkflowExecutionInitiatedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "signalName": "s",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "runId": "s",
      "input": "s",
      "control": "s",
    },
  }, root);
}

function toExternalWorkflowExecutionSignaledEventAttributes(root: jsonP.JSONValue): s.ExternalWorkflowExecutionSignaledEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "initiatedEventId": "n",
    },
    optional: {},
  }, root);
}

function toSignalExternalWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.SignalExternalWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.SignalExternalWorkflowExecutionFailedCause>(x),
      "initiatedEventId": "n",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "runId": "s",
      "control": "s",
    },
  }, root);
}

function toExternalWorkflowExecutionCancelRequestedEventAttributes(root: jsonP.JSONValue): s.ExternalWorkflowExecutionCancelRequestedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowExecution": toWorkflowExecution,
      "initiatedEventId": "n",
    },
    optional: {},
  }, root);
}

function toRequestCancelExternalWorkflowExecutionInitiatedEventAttributes(root: jsonP.JSONValue): s.RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "runId": "s",
      "control": "s",
    },
  }, root);
}

function toRequestCancelExternalWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.RequestCancelExternalWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.RequestCancelExternalWorkflowExecutionFailedCause>(x),
      "initiatedEventId": "n",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "runId": "s",
      "control": "s",
    },
  }, root);
}

function toScheduleActivityTaskFailedEventAttributes(root: jsonP.JSONValue): s.ScheduleActivityTaskFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "activityType": toActivityType,
      "activityId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleActivityTaskFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toRequestCancelActivityTaskFailedEventAttributes(root: jsonP.JSONValue): s.RequestCancelActivityTaskFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "activityId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.RequestCancelActivityTaskFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toStartTimerFailedEventAttributes(root: jsonP.JSONValue): s.StartTimerFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "timerId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.StartTimerFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toCancelTimerFailedEventAttributes(root: jsonP.JSONValue): s.CancelTimerFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "timerId": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.CancelTimerFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toStartChildWorkflowExecutionFailedEventAttributes(root: jsonP.JSONValue): s.StartChildWorkflowExecutionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "workflowType": toWorkflowType,
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.StartChildWorkflowExecutionFailedCause>(x),
      "workflowId": "s",
      "initiatedEventId": "n",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "control": "s",
    },
  }, root);
}

function toLambdaFunctionScheduledEventAttributes(root: jsonP.JSONValue): s.LambdaFunctionScheduledEventAttributes {
  return jsonP.readObj({
    required: {
      "id": "s",
      "name": "s",
      "decisionTaskCompletedEventId": "n",
    },
    optional: {
      "control": "s",
      "input": "s",
      "startToCloseTimeout": "s",
    },
  }, root);
}

function toLambdaFunctionStartedEventAttributes(root: jsonP.JSONValue): s.LambdaFunctionStartedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
    },
    optional: {},
  }, root);
}

function toLambdaFunctionCompletedEventAttributes(root: jsonP.JSONValue): s.LambdaFunctionCompletedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "result": "s",
    },
  }, root);
}

function toLambdaFunctionFailedEventAttributes(root: jsonP.JSONValue): s.LambdaFunctionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "reason": "s",
      "details": "s",
    },
  }, root);
}

function toLambdaFunctionTimedOutEventAttributes(root: jsonP.JSONValue): s.LambdaFunctionTimedOutEventAttributes {
  return jsonP.readObj({
    required: {
      "scheduledEventId": "n",
      "startedEventId": "n",
    },
    optional: {
      "timeoutType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LambdaFunctionTimeoutType>(x),
    },
  }, root);
}

function toScheduleLambdaFunctionFailedEventAttributes(root: jsonP.JSONValue): s.ScheduleLambdaFunctionFailedEventAttributes {
  return jsonP.readObj({
    required: {
      "id": "s",
      "name": "s",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleLambdaFunctionFailedCause>(x),
      "decisionTaskCompletedEventId": "n",
    },
    optional: {},
  }, root);
}

function toStartLambdaFunctionFailedEventAttributes(root: jsonP.JSONValue): s.StartLambdaFunctionFailedEventAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "scheduledEventId": "n",
      "cause": (x: jsonP.JSONValue) => cmnP.readEnum<s.StartLambdaFunctionFailedCause>(x),
      "message": "s",
    },
  }, root);
}
