// Autogenerated API client for: Amazon Forecast Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ForecastService {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ForecastService.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-06-26",
    "endpointPrefix": "forecast",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Forecast Service",
    "serviceId": "forecast",
    "signatureVersion": "v4",
    "signingName": "forecast",
    "targetPrefix": "AmazonForecast",
    "uid": "forecast-2018-06-26"
  };

  async createDataset(
    {abortSignal, ...params}: RequestConfig & CreateDatasetRequest,
  ): Promise<CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      Domain: params["Domain"],
      DatasetType: params["DatasetType"],
      DataFrequency: params["DataFrequency"],
      Schema: fromSchema(params["Schema"]),
      EncryptionConfig: fromEncryptionConfig(params["EncryptionConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDatasetGroupRequest,
  ): Promise<CreateDatasetGroupResponse> {
    const body: jsonP.JSONObject = {
      DatasetGroupName: params["DatasetGroupName"],
      Domain: params["Domain"],
      DatasetArns: params["DatasetArns"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetGroupArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & CreateDatasetImportJobRequest,
  ): Promise<CreateDatasetImportJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetImportJobName: params["DatasetImportJobName"],
      DatasetArn: params["DatasetArn"],
      DataSource: fromDataSource(params["DataSource"]),
      TimestampFormat: params["TimestampFormat"],
      TimeZone: params["TimeZone"],
      UseGeolocationForTimeZone: params["UseGeolocationForTimeZone"],
      GeolocationFormat: params["GeolocationFormat"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetImportJobArn": "s",
      },
    }, await resp.json());
  }

  async createForecast(
    {abortSignal, ...params}: RequestConfig & CreateForecastRequest,
  ): Promise<CreateForecastResponse> {
    const body: jsonP.JSONObject = {
      ForecastName: params["ForecastName"],
      PredictorArn: params["PredictorArn"],
      ForecastTypes: params["ForecastTypes"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ForecastArn": "s",
      },
    }, await resp.json());
  }

  async createForecastExportJob(
    {abortSignal, ...params}: RequestConfig & CreateForecastExportJobRequest,
  ): Promise<CreateForecastExportJobResponse> {
    const body: jsonP.JSONObject = {
      ForecastExportJobName: params["ForecastExportJobName"],
      ForecastArn: params["ForecastArn"],
      Destination: fromDataDestination(params["Destination"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateForecastExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ForecastExportJobArn": "s",
      },
    }, await resp.json());
  }

  async createPredictor(
    {abortSignal, ...params}: RequestConfig & CreatePredictorRequest,
  ): Promise<CreatePredictorResponse> {
    const body: jsonP.JSONObject = {
      PredictorName: params["PredictorName"],
      AlgorithmArn: params["AlgorithmArn"],
      ForecastHorizon: params["ForecastHorizon"],
      ForecastTypes: params["ForecastTypes"],
      PerformAutoML: params["PerformAutoML"],
      PerformHPO: params["PerformHPO"],
      TrainingParameters: params["TrainingParameters"],
      EvaluationParameters: fromEvaluationParameters(params["EvaluationParameters"]),
      HPOConfig: fromHyperParameterTuningJobConfig(params["HPOConfig"]),
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      FeaturizationConfig: fromFeaturizationConfig(params["FeaturizationConfig"]),
      EncryptionConfig: fromEncryptionConfig(params["EncryptionConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePredictor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorArn": "s",
      },
    }, await resp.json());
  }

  async createPredictorBacktestExportJob(
    {abortSignal, ...params}: RequestConfig & CreatePredictorBacktestExportJobRequest,
  ): Promise<CreatePredictorBacktestExportJobResponse> {
    const body: jsonP.JSONObject = {
      PredictorBacktestExportJobName: params["PredictorBacktestExportJobName"],
      PredictorArn: params["PredictorArn"],
      Destination: fromDataDestination(params["Destination"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePredictorBacktestExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorBacktestExportJobArn": "s",
      },
    }, await resp.json());
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatasetArn: params["DatasetArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataset",
    });
  }

  async deleteDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatasetGroupArn: params["DatasetGroupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetGroup",
    });
  }

  async deleteDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetImportJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatasetImportJobArn: params["DatasetImportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetImportJob",
    });
  }

  async deleteForecast(
    {abortSignal, ...params}: RequestConfig & DeleteForecastRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ForecastArn: params["ForecastArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteForecast",
    });
  }

  async deleteForecastExportJob(
    {abortSignal, ...params}: RequestConfig & DeleteForecastExportJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ForecastExportJobArn: params["ForecastExportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteForecastExportJob",
    });
  }

  async deletePredictor(
    {abortSignal, ...params}: RequestConfig & DeletePredictorRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      PredictorArn: params["PredictorArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePredictor",
    });
  }

  async deletePredictorBacktestExportJob(
    {abortSignal, ...params}: RequestConfig & DeletePredictorBacktestExportJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      PredictorBacktestExportJobArn: params["PredictorBacktestExportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePredictorBacktestExportJob",
    });
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetRequest,
  ): Promise<DescribeDatasetResponse> {
    const body: jsonP.JSONObject = {
      DatasetArn: params["DatasetArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetArn": "s",
        "DatasetName": "s",
        "Domain": (x: jsonP.JSONValue) => cmnP.readEnum<Domain>(x),
        "DatasetType": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetType>(x),
        "DataFrequency": "s",
        "Schema": toSchema,
        "EncryptionConfig": toEncryptionConfig,
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetGroupRequest,
  ): Promise<DescribeDatasetGroupResponse> {
    const body: jsonP.JSONObject = {
      DatasetGroupArn: params["DatasetGroupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetGroupName": "s",
        "DatasetGroupArn": "s",
        "DatasetArns": ["s"],
        "Domain": (x: jsonP.JSONValue) => cmnP.readEnum<Domain>(x),
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetImportJobRequest,
  ): Promise<DescribeDatasetImportJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetImportJobArn: params["DatasetImportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetImportJobName": "s",
        "DatasetImportJobArn": "s",
        "DatasetArn": "s",
        "TimestampFormat": "s",
        "TimeZone": "s",
        "UseGeolocationForTimeZone": "b",
        "GeolocationFormat": "s",
        "DataSource": toDataSource,
        "FieldStatistics": x => jsonP.readMap(String, toStatistics, x),
        "DataSize": "n",
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeForecast(
    {abortSignal, ...params}: RequestConfig & DescribeForecastRequest,
  ): Promise<DescribeForecastResponse> {
    const body: jsonP.JSONObject = {
      ForecastArn: params["ForecastArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeForecast",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ForecastArn": "s",
        "ForecastName": "s",
        "ForecastTypes": ["s"],
        "PredictorArn": "s",
        "DatasetGroupArn": "s",
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeForecastExportJob(
    {abortSignal, ...params}: RequestConfig & DescribeForecastExportJobRequest,
  ): Promise<DescribeForecastExportJobResponse> {
    const body: jsonP.JSONObject = {
      ForecastExportJobArn: params["ForecastExportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeForecastExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ForecastExportJobArn": "s",
        "ForecastExportJobName": "s",
        "ForecastArn": "s",
        "Destination": toDataDestination,
        "Message": "s",
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describePredictor(
    {abortSignal, ...params}: RequestConfig & DescribePredictorRequest,
  ): Promise<DescribePredictorResponse> {
    const body: jsonP.JSONObject = {
      PredictorArn: params["PredictorArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePredictor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorArn": "s",
        "PredictorName": "s",
        "AlgorithmArn": "s",
        "ForecastHorizon": "n",
        "ForecastTypes": ["s"],
        "PerformAutoML": "b",
        "PerformHPO": "b",
        "TrainingParameters": x => jsonP.readMap(String, String, x),
        "EvaluationParameters": toEvaluationParameters,
        "HPOConfig": toHyperParameterTuningJobConfig,
        "InputDataConfig": toInputDataConfig,
        "FeaturizationConfig": toFeaturizationConfig,
        "EncryptionConfig": toEncryptionConfig,
        "PredictorExecutionDetails": toPredictorExecutionDetails,
        "DatasetImportJobArns": ["s"],
        "AutoMLAlgorithmArns": ["s"],
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describePredictorBacktestExportJob(
    {abortSignal, ...params}: RequestConfig & DescribePredictorBacktestExportJobRequest,
  ): Promise<DescribePredictorBacktestExportJobResponse> {
    const body: jsonP.JSONObject = {
      PredictorBacktestExportJobArn: params["PredictorBacktestExportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePredictorBacktestExportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorBacktestExportJobArn": "s",
        "PredictorBacktestExportJobName": "s",
        "PredictorArn": "s",
        "Destination": toDataDestination,
        "Message": "s",
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async getAccuracyMetrics(
    {abortSignal, ...params}: RequestConfig & GetAccuracyMetricsRequest,
  ): Promise<GetAccuracyMetricsResponse> {
    const body: jsonP.JSONObject = {
      PredictorArn: params["PredictorArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccuracyMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorEvaluationResults": [toEvaluationResult],
      },
    }, await resp.json());
  }

  async listDatasetGroups(
    {abortSignal, ...params}: RequestConfig & ListDatasetGroupsRequest = {},
  ): Promise<ListDatasetGroupsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetGroups": [toDatasetGroupSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetImportJobs(
    {abortSignal, ...params}: RequestConfig & ListDatasetImportJobsRequest = {},
  ): Promise<ListDatasetImportJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetImportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetImportJobs": [toDatasetImportJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & ListDatasetsRequest = {},
  ): Promise<ListDatasetsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Datasets": [toDatasetSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listForecastExportJobs(
    {abortSignal, ...params}: RequestConfig & ListForecastExportJobsRequest = {},
  ): Promise<ListForecastExportJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListForecastExportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ForecastExportJobs": [toForecastExportJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listForecasts(
    {abortSignal, ...params}: RequestConfig & ListForecastsRequest = {},
  ): Promise<ListForecastsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListForecasts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Forecasts": [toForecastSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPredictorBacktestExportJobs(
    {abortSignal, ...params}: RequestConfig & ListPredictorBacktestExportJobsRequest = {},
  ): Promise<ListPredictorBacktestExportJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPredictorBacktestExportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PredictorBacktestExportJobs": [toPredictorBacktestExportJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPredictors(
    {abortSignal, ...params}: RequestConfig & ListPredictorsRequest = {},
  ): Promise<ListPredictorsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPredictors",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Predictors": [toPredictorSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDatasetGroup(
    {abortSignal, ...params}: RequestConfig & UpdateDatasetGroupRequest,
  ): Promise<UpdateDatasetGroupResponse> {
    const body: jsonP.JSONObject = {
      DatasetGroupArn: params["DatasetGroupArn"],
      DatasetArns: params["DatasetArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateDatasetRequest {
  DatasetName: string;
  Domain: Domain;
  DatasetType: DatasetType;
  DataFrequency?: string | null;
  Schema: Schema;
  EncryptionConfig?: EncryptionConfig | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetGroupRequest {
  DatasetGroupName: string;
  Domain: Domain;
  DatasetArns?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetImportJobRequest {
  DatasetImportJobName: string;
  DatasetArn: string;
  DataSource: DataSource;
  TimestampFormat?: string | null;
  TimeZone?: string | null;
  UseGeolocationForTimeZone?: boolean | null;
  GeolocationFormat?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateForecastRequest {
  ForecastName: string;
  PredictorArn: string;
  ForecastTypes?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateForecastExportJobRequest {
  ForecastExportJobName: string;
  ForecastArn: string;
  Destination: DataDestination;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePredictorRequest {
  PredictorName: string;
  AlgorithmArn?: string | null;
  ForecastHorizon: number;
  ForecastTypes?: string[] | null;
  PerformAutoML?: boolean | null;
  PerformHPO?: boolean | null;
  TrainingParameters?: { [key: string]: string | null | undefined } | null;
  EvaluationParameters?: EvaluationParameters | null;
  HPOConfig?: HyperParameterTuningJobConfig | null;
  InputDataConfig: InputDataConfig;
  FeaturizationConfig: FeaturizationConfig;
  EncryptionConfig?: EncryptionConfig | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePredictorBacktestExportJobRequest {
  PredictorBacktestExportJobName: string;
  PredictorArn: string;
  Destination: DataDestination;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetRequest {
  DatasetArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetGroupRequest {
  DatasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetImportJobRequest {
  DatasetImportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteForecastRequest {
  ForecastArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteForecastExportJobRequest {
  ForecastExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePredictorRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePredictorBacktestExportJobRequest {
  PredictorBacktestExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetRequest {
  DatasetArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetGroupRequest {
  DatasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetImportJobRequest {
  DatasetImportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeForecastRequest {
  ForecastArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeForecastExportJobRequest {
  ForecastExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribePredictorRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface DescribePredictorBacktestExportJobRequest {
  PredictorBacktestExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface GetAccuracyMetricsRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface ListDatasetGroupsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetImportJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListForecastExportJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListForecastsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListPredictorBacktestExportJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListPredictorsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDatasetGroupRequest {
  DatasetGroupArn: string;
  DatasetArns: string[];
}

// refs: 1 - tags: named, output
export interface CreateDatasetResponse {
  DatasetArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetGroupResponse {
  DatasetGroupArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetImportJobResponse {
  DatasetImportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateForecastResponse {
  ForecastArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateForecastExportJobResponse {
  ForecastExportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePredictorResponse {
  PredictorArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePredictorBacktestExportJobResponse {
  PredictorBacktestExportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetResponse {
  DatasetArn?: string | null;
  DatasetName?: string | null;
  Domain?: Domain | null;
  DatasetType?: DatasetType | null;
  DataFrequency?: string | null;
  Schema?: Schema | null;
  EncryptionConfig?: EncryptionConfig | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetGroupResponse {
  DatasetGroupName?: string | null;
  DatasetGroupArn?: string | null;
  DatasetArns?: string[] | null;
  Domain?: Domain | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetImportJobResponse {
  DatasetImportJobName?: string | null;
  DatasetImportJobArn?: string | null;
  DatasetArn?: string | null;
  TimestampFormat?: string | null;
  TimeZone?: string | null;
  UseGeolocationForTimeZone?: boolean | null;
  GeolocationFormat?: string | null;
  DataSource?: DataSource | null;
  FieldStatistics?: { [key: string]: Statistics | null | undefined } | null;
  DataSize?: number | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeForecastResponse {
  ForecastArn?: string | null;
  ForecastName?: string | null;
  ForecastTypes?: string[] | null;
  PredictorArn?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeForecastExportJobResponse {
  ForecastExportJobArn?: string | null;
  ForecastExportJobName?: string | null;
  ForecastArn?: string | null;
  Destination?: DataDestination | null;
  Message?: string | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribePredictorResponse {
  PredictorArn?: string | null;
  PredictorName?: string | null;
  AlgorithmArn?: string | null;
  ForecastHorizon?: number | null;
  ForecastTypes?: string[] | null;
  PerformAutoML?: boolean | null;
  PerformHPO?: boolean | null;
  TrainingParameters?: { [key: string]: string | null | undefined } | null;
  EvaluationParameters?: EvaluationParameters | null;
  HPOConfig?: HyperParameterTuningJobConfig | null;
  InputDataConfig?: InputDataConfig | null;
  FeaturizationConfig?: FeaturizationConfig | null;
  EncryptionConfig?: EncryptionConfig | null;
  PredictorExecutionDetails?: PredictorExecutionDetails | null;
  DatasetImportJobArns?: string[] | null;
  AutoMLAlgorithmArns?: string[] | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribePredictorBacktestExportJobResponse {
  PredictorBacktestExportJobArn?: string | null;
  PredictorBacktestExportJobName?: string | null;
  PredictorArn?: string | null;
  Destination?: DataDestination | null;
  Message?: string | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetAccuracyMetricsResponse {
  PredictorEvaluationResults?: EvaluationResult[] | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetGroupsResponse {
  DatasetGroups?: DatasetGroupSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetImportJobsResponse {
  DatasetImportJobs?: DatasetImportJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetsResponse {
  Datasets?: DatasetSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListForecastExportJobsResponse {
  ForecastExportJobs?: ForecastExportJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListForecastsResponse {
  Forecasts?: ForecastSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPredictorBacktestExportJobsResponse {
  PredictorBacktestExportJobs?: PredictorBacktestExportJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPredictorsResponse {
  Predictors?: PredictorSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDatasetGroupResponse {
}

// refs: 5 - tags: input, named, enum, output
export type Domain =
| "RETAIL"
| "CUSTOM"
| "INVENTORY_PLANNING"
| "EC2_CAPACITY"
| "WORK_FORCE"
| "WEB_TRAFFIC"
| "METRICS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type DatasetType =
| "TARGET_TIME_SERIES"
| "RELATED_TIME_SERIES"
| "ITEM_METADATA"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Schema {
  Attributes?: SchemaAttribute[] | null;
}
function fromSchema(input?: Schema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: input["Attributes"]?.map(x => fromSchemaAttribute(x)),
  }
}
function toSchema(root: jsonP.JSONValue): Schema {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": [toSchemaAttribute],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SchemaAttribute {
  AttributeName?: string | null;
  AttributeType?: AttributeType | null;
}
function fromSchemaAttribute(input?: SchemaAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toSchemaAttribute(root: jsonP.JSONValue): SchemaAttribute {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeName": "s",
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<AttributeType>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type AttributeType =
| "string"
| "integer"
| "float"
| "timestamp"
| "geolocation"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface EncryptionConfig {
  RoleArn: string;
  KMSKeyArn: string;
}
function fromEncryptionConfig(input?: EncryptionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleArn: input["RoleArn"],
    KMSKeyArn: input["KMSKeyArn"],
  }
}
function toEncryptionConfig(root: jsonP.JSONValue): EncryptionConfig {
  return jsonP.readObj({
    required: {
      "RoleArn": "s",
      "KMSKeyArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DataSource {
  S3Config: S3Config;
}
function fromDataSource(input?: DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Config: fromS3Config(input["S3Config"]),
  }
}
function toDataSource(root: jsonP.JSONValue): DataSource {
  return jsonP.readObj({
    required: {
      "S3Config": toS3Config,
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface S3Config {
  Path: string;
  RoleArn: string;
  KMSKeyArn?: string | null;
}
function fromS3Config(input?: S3Config | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    RoleArn: input["RoleArn"],
    KMSKeyArn: input["KMSKeyArn"],
  }
}
function toS3Config(root: jsonP.JSONValue): S3Config {
  return jsonP.readObj({
    required: {
      "Path": "s",
      "RoleArn": "s",
    },
    optional: {
      "KMSKeyArn": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DataDestination {
  S3Config: S3Config;
}
function fromDataDestination(input?: DataDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Config: fromS3Config(input["S3Config"]),
  }
}
function toDataDestination(root: jsonP.JSONValue): DataDestination {
  return jsonP.readObj({
    required: {
      "S3Config": toS3Config,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface EvaluationParameters {
  NumberOfBacktestWindows?: number | null;
  BackTestWindowOffset?: number | null;
}
function fromEvaluationParameters(input?: EvaluationParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NumberOfBacktestWindows: input["NumberOfBacktestWindows"],
    BackTestWindowOffset: input["BackTestWindowOffset"],
  }
}
function toEvaluationParameters(root: jsonP.JSONValue): EvaluationParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumberOfBacktestWindows": "n",
      "BackTestWindowOffset": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HyperParameterTuningJobConfig {
  ParameterRanges?: ParameterRanges | null;
}
function fromHyperParameterTuningJobConfig(input?: HyperParameterTuningJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParameterRanges: fromParameterRanges(input["ParameterRanges"]),
  }
}
function toHyperParameterTuningJobConfig(root: jsonP.JSONValue): HyperParameterTuningJobConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterRanges": toParameterRanges,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ParameterRanges {
  CategoricalParameterRanges?: CategoricalParameterRange[] | null;
  ContinuousParameterRanges?: ContinuousParameterRange[] | null;
  IntegerParameterRanges?: IntegerParameterRange[] | null;
}
function fromParameterRanges(input?: ParameterRanges | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CategoricalParameterRanges: input["CategoricalParameterRanges"]?.map(x => fromCategoricalParameterRange(x)),
    ContinuousParameterRanges: input["ContinuousParameterRanges"]?.map(x => fromContinuousParameterRange(x)),
    IntegerParameterRanges: input["IntegerParameterRanges"]?.map(x => fromIntegerParameterRange(x)),
  }
}
function toParameterRanges(root: jsonP.JSONValue): ParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "CategoricalParameterRanges": [toCategoricalParameterRange],
      "ContinuousParameterRanges": [toContinuousParameterRange],
      "IntegerParameterRanges": [toIntegerParameterRange],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface CategoricalParameterRange {
  Name: string;
  Values: string[];
}
function fromCategoricalParameterRange(input?: CategoricalParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}
function toCategoricalParameterRange(root: jsonP.JSONValue): CategoricalParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ContinuousParameterRange {
  Name: string;
  MaxValue: number;
  MinValue: number;
  ScalingType?: ScalingType | null;
}
function fromContinuousParameterRange(input?: ContinuousParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MaxValue: input["MaxValue"],
    MinValue: input["MinValue"],
    ScalingType: input["ScalingType"],
  }
}
function toContinuousParameterRange(root: jsonP.JSONValue): ContinuousParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MaxValue": "n",
      "MinValue": "n",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<ScalingType>(x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ScalingType =
| "Auto"
| "Linear"
| "Logarithmic"
| "ReverseLogarithmic"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface IntegerParameterRange {
  Name: string;
  MaxValue: number;
  MinValue: number;
  ScalingType?: ScalingType | null;
}
function fromIntegerParameterRange(input?: IntegerParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MaxValue: input["MaxValue"],
    MinValue: input["MinValue"],
    ScalingType: input["ScalingType"],
  }
}
function toIntegerParameterRange(root: jsonP.JSONValue): IntegerParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MaxValue": "n",
      "MinValue": "n",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<ScalingType>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface InputDataConfig {
  DatasetGroupArn: string;
  SupplementaryFeatures?: SupplementaryFeature[] | null;
}
function fromInputDataConfig(input?: InputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatasetGroupArn: input["DatasetGroupArn"],
    SupplementaryFeatures: input["SupplementaryFeatures"]?.map(x => fromSupplementaryFeature(x)),
  }
}
function toInputDataConfig(root: jsonP.JSONValue): InputDataConfig {
  return jsonP.readObj({
    required: {
      "DatasetGroupArn": "s",
    },
    optional: {
      "SupplementaryFeatures": [toSupplementaryFeature],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SupplementaryFeature {
  Name: string;
  Value: string;
}
function fromSupplementaryFeature(input?: SupplementaryFeature | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toSupplementaryFeature(root: jsonP.JSONValue): SupplementaryFeature {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface FeaturizationConfig {
  ForecastFrequency: string;
  ForecastDimensions?: string[] | null;
  Featurizations?: Featurization[] | null;
}
function fromFeaturizationConfig(input?: FeaturizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ForecastFrequency: input["ForecastFrequency"],
    ForecastDimensions: input["ForecastDimensions"],
    Featurizations: input["Featurizations"]?.map(x => fromFeaturization(x)),
  }
}
function toFeaturizationConfig(root: jsonP.JSONValue): FeaturizationConfig {
  return jsonP.readObj({
    required: {
      "ForecastFrequency": "s",
    },
    optional: {
      "ForecastDimensions": ["s"],
      "Featurizations": [toFeaturization],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface Featurization {
  AttributeName: string;
  FeaturizationPipeline?: FeaturizationMethod[] | null;
}
function fromFeaturization(input?: Featurization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    FeaturizationPipeline: input["FeaturizationPipeline"]?.map(x => fromFeaturizationMethod(x)),
  }
}
function toFeaturization(root: jsonP.JSONValue): Featurization {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
    },
    optional: {
      "FeaturizationPipeline": [toFeaturizationMethod],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface FeaturizationMethod {
  FeaturizationMethodName: FeaturizationMethodName;
  FeaturizationMethodParameters?: { [key: string]: string | null | undefined } | null;
}
function fromFeaturizationMethod(input?: FeaturizationMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FeaturizationMethodName: input["FeaturizationMethodName"],
    FeaturizationMethodParameters: input["FeaturizationMethodParameters"],
  }
}
function toFeaturizationMethod(root: jsonP.JSONValue): FeaturizationMethod {
  return jsonP.readObj({
    required: {
      "FeaturizationMethodName": (x: jsonP.JSONValue) => cmnP.readEnum<FeaturizationMethodName>(x),
    },
    optional: {
      "FeaturizationMethodParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type FeaturizationMethodName =
| "filling"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface
export interface Filter {
  Key: string;
  Value: string;
  Condition: FilterConditionString;
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Condition: input["Condition"],
  }
}

// refs: 5 - tags: input, named, enum
export type FilterConditionString =
| "IS"
| "IS_NOT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Statistics {
  Count?: number | null;
  CountDistinct?: number | null;
  CountNull?: number | null;
  CountNan?: number | null;
  Min?: string | null;
  Max?: string | null;
  Avg?: number | null;
  Stddev?: number | null;
}
function toStatistics(root: jsonP.JSONValue): Statistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Count": "n",
      "CountDistinct": "n",
      "CountNull": "n",
      "CountNan": "n",
      "Min": "s",
      "Max": "s",
      "Avg": "n",
      "Stddev": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorExecutionDetails {
  PredictorExecutions?: PredictorExecution[] | null;
}
function toPredictorExecutionDetails(root: jsonP.JSONValue): PredictorExecutionDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PredictorExecutions": [toPredictorExecution],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorExecution {
  AlgorithmArn?: string | null;
  TestWindows?: TestWindowSummary[] | null;
}
function toPredictorExecution(root: jsonP.JSONValue): PredictorExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "AlgorithmArn": "s",
      "TestWindows": [toTestWindowSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TestWindowSummary {
  TestWindowStart?: Date | number | null;
  TestWindowEnd?: Date | number | null;
  Status?: string | null;
  Message?: string | null;
}
function toTestWindowSummary(root: jsonP.JSONValue): TestWindowSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TestWindowStart": "d",
      "TestWindowEnd": "d",
      "Status": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EvaluationResult {
  AlgorithmArn?: string | null;
  TestWindows?: WindowSummary[] | null;
}
function toEvaluationResult(root: jsonP.JSONValue): EvaluationResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "AlgorithmArn": "s",
      "TestWindows": [toWindowSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface WindowSummary {
  TestWindowStart?: Date | number | null;
  TestWindowEnd?: Date | number | null;
  ItemCount?: number | null;
  EvaluationType?: EvaluationType | null;
  Metrics?: Metrics | null;
}
function toWindowSummary(root: jsonP.JSONValue): WindowSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TestWindowStart": "d",
      "TestWindowEnd": "d",
      "ItemCount": "n",
      "EvaluationType": (x: jsonP.JSONValue) => cmnP.readEnum<EvaluationType>(x),
      "Metrics": toMetrics,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type EvaluationType =
| "SUMMARY"
| "COMPUTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Metrics {
  RMSE?: number | null;
  WeightedQuantileLosses?: WeightedQuantileLoss[] | null;
  ErrorMetrics?: ErrorMetric[] | null;
}
function toMetrics(root: jsonP.JSONValue): Metrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "RMSE": "n",
      "WeightedQuantileLosses": [toWeightedQuantileLoss],
      "ErrorMetrics": [toErrorMetric],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface WeightedQuantileLoss {
  Quantile?: number | null;
  LossValue?: number | null;
}
function toWeightedQuantileLoss(root: jsonP.JSONValue): WeightedQuantileLoss {
  return jsonP.readObj({
    required: {},
    optional: {
      "Quantile": "n",
      "LossValue": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ErrorMetric {
  ForecastType?: string | null;
  WAPE?: number | null;
  RMSE?: number | null;
}
function toErrorMetric(root: jsonP.JSONValue): ErrorMetric {
  return jsonP.readObj({
    required: {},
    optional: {
      "ForecastType": "s",
      "WAPE": "n",
      "RMSE": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetGroupSummary {
  DatasetGroupArn?: string | null;
  DatasetGroupName?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetGroupSummary(root: jsonP.JSONValue): DatasetGroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatasetGroupArn": "s",
      "DatasetGroupName": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetImportJobSummary {
  DatasetImportJobArn?: string | null;
  DatasetImportJobName?: string | null;
  DataSource?: DataSource | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetImportJobSummary(root: jsonP.JSONValue): DatasetImportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatasetImportJobArn": "s",
      "DatasetImportJobName": "s",
      "DataSource": toDataSource,
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSummary {
  DatasetArn?: string | null;
  DatasetName?: string | null;
  DatasetType?: DatasetType | null;
  Domain?: Domain | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetSummary(root: jsonP.JSONValue): DatasetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatasetArn": "s",
      "DatasetName": "s",
      "DatasetType": (x: jsonP.JSONValue) => cmnP.readEnum<DatasetType>(x),
      "Domain": (x: jsonP.JSONValue) => cmnP.readEnum<Domain>(x),
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ForecastExportJobSummary {
  ForecastExportJobArn?: string | null;
  ForecastExportJobName?: string | null;
  Destination?: DataDestination | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toForecastExportJobSummary(root: jsonP.JSONValue): ForecastExportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ForecastExportJobArn": "s",
      "ForecastExportJobName": "s",
      "Destination": toDataDestination,
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ForecastSummary {
  ForecastArn?: string | null;
  ForecastName?: string | null;
  PredictorArn?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toForecastSummary(root: jsonP.JSONValue): ForecastSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ForecastArn": "s",
      "ForecastName": "s",
      "PredictorArn": "s",
      "DatasetGroupArn": "s",
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorBacktestExportJobSummary {
  PredictorBacktestExportJobArn?: string | null;
  PredictorBacktestExportJobName?: string | null;
  Destination?: DataDestination | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toPredictorBacktestExportJobSummary(root: jsonP.JSONValue): PredictorBacktestExportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PredictorBacktestExportJobArn": "s",
      "PredictorBacktestExportJobName": "s",
      "Destination": toDataDestination,
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorSummary {
  PredictorArn?: string | null;
  PredictorName?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toPredictorSummary(root: jsonP.JSONValue): PredictorSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PredictorArn": "s",
      "PredictorName": "s",
      "DatasetGroupArn": "s",
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}
