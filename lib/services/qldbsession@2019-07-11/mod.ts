// Autogenerated API client for: Amazon QLDB Session

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class QLDBSession {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(QLDBSession.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-07-11",
    "endpointPrefix": "session.qldb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "QLDB Session",
    "serviceFullName": "Amazon QLDB Session",
    "serviceId": "QLDB Session",
    "signatureVersion": "v4",
    "signingName": "qldb",
    "targetPrefix": "QLDBSession",
    "uid": "qldb-session-2019-07-11"
  };

  async sendCommand(
    {abortSignal, ...params}: RequestConfig & s.SendCommandRequest = {},
  ): Promise<s.SendCommandResult> {
    const body: jsonP.JSONObject = {
      SessionToken: params["SessionToken"],
      StartSession: fromStartSessionRequest(params["StartSession"]),
      StartTransaction: fromStartTransactionRequest(params["StartTransaction"]),
      EndSession: fromEndSessionRequest(params["EndSession"]),
      CommitTransaction: fromCommitTransactionRequest(params["CommitTransaction"]),
      AbortTransaction: fromAbortTransactionRequest(params["AbortTransaction"]),
      ExecuteStatement: fromExecuteStatementRequest(params["ExecuteStatement"]),
      FetchPage: fromFetchPageRequest(params["FetchPage"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendCommand",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StartSession": toStartSessionResult,
        "StartTransaction": toStartTransactionResult,
        "EndSession": toEndSessionResult,
        "CommitTransaction": toCommitTransactionResult,
        "AbortTransaction": toAbortTransactionResult,
        "ExecuteStatement": toExecuteStatementResult,
        "FetchPage": toFetchPageResult,
      },
    }, await resp.json());
  }

}

function fromStartSessionRequest(input?: s.StartSessionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LedgerName: input["LedgerName"],
  }
}

function fromStartTransactionRequest(input?: s.StartTransactionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}

function fromEndSessionRequest(input?: s.EndSessionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}

function fromCommitTransactionRequest(input?: s.CommitTransactionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TransactionId: input["TransactionId"],
    CommitDigest: serializeBlob(input["CommitDigest"]),
  }
}

function fromAbortTransactionRequest(input?: s.AbortTransactionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}

function fromExecuteStatementRequest(input?: s.ExecuteStatementRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TransactionId: input["TransactionId"],
    Statement: input["Statement"],
    Parameters: input["Parameters"]?.map(x => fromValueHolder(x)),
  }
}

function fromValueHolder(input?: s.ValueHolder | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IonBinary: serializeBlob(input["IonBinary"]),
    IonText: input["IonText"],
  }
}
function toValueHolder(root: jsonP.JSONValue): s.ValueHolder {
  return jsonP.readObj({
    required: {},
    optional: {
      "IonBinary": "a",
      "IonText": "s",
    },
  }, root);
}

function fromFetchPageRequest(input?: s.FetchPageRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TransactionId: input["TransactionId"],
    NextPageToken: input["NextPageToken"],
  }
}

function toStartSessionResult(root: jsonP.JSONValue): s.StartSessionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "SessionToken": "s",
      "TimingInformation": toTimingInformation,
    },
  }, root);
}

function toTimingInformation(root: jsonP.JSONValue): s.TimingInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProcessingTimeMilliseconds": "n",
    },
  }, root);
}

function toStartTransactionResult(root: jsonP.JSONValue): s.StartTransactionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransactionId": "s",
      "TimingInformation": toTimingInformation,
    },
  }, root);
}

function toEndSessionResult(root: jsonP.JSONValue): s.EndSessionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimingInformation": toTimingInformation,
    },
  }, root);
}

function toCommitTransactionResult(root: jsonP.JSONValue): s.CommitTransactionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransactionId": "s",
      "CommitDigest": "a",
      "TimingInformation": toTimingInformation,
      "ConsumedIOs": toIOUsage,
    },
  }, root);
}

function toIOUsage(root: jsonP.JSONValue): s.IOUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadIOs": "n",
      "WriteIOs": "n",
    },
  }, root);
}

function toAbortTransactionResult(root: jsonP.JSONValue): s.AbortTransactionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimingInformation": toTimingInformation,
    },
  }, root);
}

function toExecuteStatementResult(root: jsonP.JSONValue): s.ExecuteStatementResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "FirstPage": toPage,
      "TimingInformation": toTimingInformation,
      "ConsumedIOs": toIOUsage,
    },
  }, root);
}

function toPage(root: jsonP.JSONValue): s.Page {
  return jsonP.readObj({
    required: {},
    optional: {
      "Values": [toValueHolder],
      "NextPageToken": "s",
    },
  }, root);
}

function toFetchPageResult(root: jsonP.JSONValue): s.FetchPageResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Page": toPage,
      "TimingInformation": toTimingInformation,
      "ConsumedIOs": toIOUsage,
    },
  }, root);
}
