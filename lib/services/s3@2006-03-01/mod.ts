// Autogenerated API client for: Amazon Simple Storage Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as HashMd5 from "https://deno.land/std@0.86.0/hash/md5.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as Base64 from "https://deno.land/x/base64@v0.2.1/mod.ts";
function hashMD5(data: HashMd5.Message): string {
  const hasher = new HashMd5.Md5();
  hasher.update(data);
  return hasher.toString('base64');
}

export default class S3 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(S3.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2006-03-01",
    "checksumFormat": "md5",
    "endpointPrefix": "s3",
    "globalEndpoint": "s3.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Amazon S3",
    "serviceFullName": "Amazon Simple Storage Service",
    "serviceId": "S3",
    "signatureVersion": "s3",
    "uid": "s3-2006-03-01"
  };

  async abortMultipartUpload(
    {abortSignal, ...params}: RequestConfig & AbortMultipartUploadRequest,
  ): Promise<AbortMultipartUploadOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "AbortMultipartUpload",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
      responseCode: 204,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async completeMultipartUpload(
    {abortSignal, ...params}: RequestConfig & CompleteMultipartUploadRequest,
  ): Promise<CompleteMultipartUploadOutput> {
    const inner = params["MultipartUpload"];
    const body = inner ? xmlP.stringify({
      name: "CompleteMultipartUpload",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Parts"]?.map(x => ({name: "Part", ...CompletedPart_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "CompleteMultipartUpload",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Expiration: resp.headers.get("x-amz-expiration"),
      ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      VersionId: resp.headers.get("x-amz-version-id"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...xml.strings({
        optional: {"Location":true,"Bucket":true,"Key":true,"ETag":true},
      }),
    };
  }

  async copyObject(
    {abortSignal, ...params}: RequestConfig & CopyObjectRequest,
  ): Promise<CopyObjectOutput> {
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    headers.append("x-amz-copy-source", params["CopySource"]);
    if (params["CopySourceIfMatch"] != null) headers.append("x-amz-copy-source-if-match", params["CopySourceIfMatch"]);
    if (params["CopySourceIfModifiedSince"] != null) headers.append("x-amz-copy-source-if-modified-since", cmnP.serializeDate_rfc822(params["CopySourceIfModifiedSince"]) ?? "");
    if (params["CopySourceIfNoneMatch"] != null) headers.append("x-amz-copy-source-if-none-match", params["CopySourceIfNoneMatch"]);
    if (params["CopySourceIfUnmodifiedSince"] != null) headers.append("x-amz-copy-source-if-unmodified-since", cmnP.serializeDate_rfc822(params["CopySourceIfUnmodifiedSince"]) ?? "");
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["MetadataDirective"] != null) headers.append("x-amz-metadata-directive", params["MetadataDirective"]);
    if (params["TaggingDirective"] != null) headers.append("x-amz-tagging-directive", params["TaggingDirective"]);
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["CopySourceSSECustomerAlgorithm"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-algorithm", params["CopySourceSSECustomerAlgorithm"]);
    if (params["CopySourceSSECustomerKey"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key", cmnP.serializeBlob(params["CopySourceSSECustomerKey"]) ?? '');
    if (params["CopySourceSSECustomerKeyMD5"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key-MD5", params["CopySourceSSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["ExpectedSourceBucketOwner"] != null) headers.append("x-amz-source-expected-bucket-owner", params["ExpectedSourceBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "CopyObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Expiration: resp.headers.get("x-amz-expiration"),
    CopySourceVersionId: resp.headers.get("x-amz-copy-source-version-id"),
    VersionId: resp.headers.get("x-amz-version-id"),
    ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
    SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
    SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
    SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
    SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
    BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
    RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    CopyObjectResult: {
        ...xml.strings({
          optional: {"ETag":true},
        }),
        LastModified: xml.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
      },
  };
  }

  async createBucket(
    {abortSignal, ...params}: RequestConfig & CreateBucketRequest,
  ): Promise<CreateBucketOutput> {
    const inner = params["CreateBucketConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CreateBucketConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "LocationConstraint", content: inner["LocationConstraint"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ObjectLockEnabledForBucket"] != null) headers.append("x-amz-bucket-object-lock-enabled", params["ObjectLockEnabledForBucket"]?.toString() ?? '');
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateBucket",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
    return {
      Location: resp.headers.get("Location"),
    };
  }

  async createMultipartUpload(
    {abortSignal, ...params}: RequestConfig & CreateMultipartUploadRequest,
  ): Promise<CreateMultipartUploadOutput> {
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "CreateMultipartUpload",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?uploads`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AbortDate: cmnP.readTimestamp(resp.headers.get("x-amz-abort-date")),
      AbortRuleId: resp.headers.get("x-amz-abort-rule-id"),
      ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...xml.strings({
        optional: {"Bucket":true,"Key":true,"UploadId":true},
      }),
    };
  }

  async deleteBucket(
    {abortSignal, ...params}: RequestConfig & DeleteBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucket",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
      responseCode: 204,
    });
  }

  async deleteBucketAnalyticsConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteBucketAnalyticsConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteBucketAnalyticsConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
      responseCode: 204,
    });
  }

  async deleteBucketCors(
    {abortSignal, ...params}: RequestConfig & DeleteBucketCorsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketCors",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
      responseCode: 204,
    });
  }

  async deleteBucketEncryption(
    {abortSignal, ...params}: RequestConfig & DeleteBucketEncryptionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketEncryption",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
      responseCode: 204,
    });
  }

  async deleteBucketIntelligentTieringConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteBucketIntelligentTieringConfigurationRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteBucketIntelligentTieringConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
      responseCode: 204,
    });
  }

  async deleteBucketInventoryConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteBucketInventoryConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteBucketInventoryConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
      responseCode: 204,
    });
  }

  async deleteBucketLifecycle(
    {abortSignal, ...params}: RequestConfig & DeleteBucketLifecycleRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketLifecycle",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
      responseCode: 204,
    });
  }

  async deleteBucketMetricsConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteBucketMetricsConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteBucketMetricsConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
      responseCode: 204,
    });
  }

  async deleteBucketOwnershipControls(
    {abortSignal, ...params}: RequestConfig & DeleteBucketOwnershipControlsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketOwnershipControls",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
      responseCode: 204,
    });
  }

  async deleteBucketPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
      responseCode: 204,
    });
  }

  async deleteBucketReplication(
    {abortSignal, ...params}: RequestConfig & DeleteBucketReplicationRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketReplication",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
      responseCode: 204,
    });
  }

  async deleteBucketTagging(
    {abortSignal, ...params}: RequestConfig & DeleteBucketTaggingRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
      responseCode: 204,
    });
  }

  async deleteBucketWebsite(
    {abortSignal, ...params}: RequestConfig & DeleteBucketWebsiteRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketWebsite",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
      responseCode: 204,
    });
  }

  async deleteObject(
    {abortSignal, ...params}: RequestConfig & DeleteObjectRequest,
  ): Promise<DeleteObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteObject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
      responseCode: 204,
    });
    return {
      DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
      VersionId: resp.headers.get("x-amz-version-id"),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async deleteObjectTagging(
    {abortSignal, ...params}: RequestConfig & DeleteObjectTaggingRequest,
  ): Promise<DeleteObjectTaggingOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteObjectTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
      responseCode: 204,
    });
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
    };
  }

  async deleteObjects(
    {abortSignal, ...params}: RequestConfig & DeleteObjectsRequest,
  ): Promise<DeleteObjectsOutput> {
    const inner = params["Delete"];
    const body = inner ? xmlP.stringify({
      name: "Delete",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Objects"]?.map(x => ({name: "Object", ...ObjectIdentifier_Serialize(x)})) ?? []),
        {name: "Quiet", content: inner["Quiet"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DeleteObjects",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?delete`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        Deleted: xml.getList("Deleted").map(DeletedObject_Parse),
        Errors: xml.getList("Error").map(Error_Parse),
      },
    };
  }

  async deletePublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & DeletePublicAccessBlockRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeletePublicAccessBlock",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
      responseCode: 204,
    });
  }

  async getBucketAccelerateConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketAccelerateConfigurationRequest,
  ): Promise<GetBucketAccelerateConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketAccelerateConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?accelerate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", false, x => (x.content ?? '') as BucketAccelerateStatus),
    };
  }

  async getBucketAcl(
    {abortSignal, ...params}: RequestConfig & GetBucketAclRequest,
  ): Promise<GetBucketAclOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketAcl",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?acl`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Owner: xml.first("Owner", false, Owner_Parse),
      Grants: xml.getList("AccessControlList", "Grant").map(Grant_Parse),
    };
  }

  async getBucketAnalyticsConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketAnalyticsConfigurationRequest,
  ): Promise<GetBucketAnalyticsConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetBucketAnalyticsConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    AnalyticsConfiguration: AnalyticsConfiguration_Parse(xml),
  };
  }

  async getBucketCors(
    {abortSignal, ...params}: RequestConfig & GetBucketCorsRequest,
  ): Promise<GetBucketCorsOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketCors",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CORSRules: xml.getList("CORSRule").map(CORSRule_Parse),
    };
  }

  async getBucketEncryption(
    {abortSignal, ...params}: RequestConfig & GetBucketEncryptionRequest,
  ): Promise<GetBucketEncryptionOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketEncryption",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ServerSideEncryptionConfiguration: ServerSideEncryptionConfiguration_Parse(xml),
  };
  }

  async getBucketIntelligentTieringConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketIntelligentTieringConfigurationRequest,
  ): Promise<GetBucketIntelligentTieringConfigurationOutput> {
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBucketIntelligentTieringConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    IntelligentTieringConfiguration: IntelligentTieringConfiguration_Parse(xml),
  };
  }

  async getBucketInventoryConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketInventoryConfigurationRequest,
  ): Promise<GetBucketInventoryConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetBucketInventoryConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    InventoryConfiguration: InventoryConfiguration_Parse(xml),
  };
  }

  async getBucketLifecycle(
    {abortSignal, ...params}: RequestConfig & GetBucketLifecycleRequest,
  ): Promise<GetBucketLifecycleOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLifecycle",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rule").map(Rule_Parse),
    };
  }

  async getBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketLifecycleConfigurationRequest,
  ): Promise<GetBucketLifecycleConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLifecycleConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rule").map(LifecycleRule_Parse),
    };
  }

  async getBucketLocation(
    {abortSignal, ...params}: RequestConfig & GetBucketLocationRequest,
  ): Promise<GetBucketLocationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLocation",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?location`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocationConstraint: xml.first("LocationConstraint", false, x => (x.content ?? '') as BucketLocationConstraint),
    };
  }

  async getBucketLogging(
    {abortSignal, ...params}: RequestConfig & GetBucketLoggingRequest,
  ): Promise<GetBucketLoggingOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLogging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?logging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LoggingEnabled: xml.first("LoggingEnabled", false, LoggingEnabled_Parse),
    };
  }

  async getBucketMetricsConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketMetricsConfigurationRequest,
  ): Promise<GetBucketMetricsConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetBucketMetricsConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    MetricsConfiguration: MetricsConfiguration_Parse(xml),
  };
  }

  async getBucketNotification(
    {abortSignal, ...params}: RequestConfig & GetBucketNotificationConfigurationRequest,
  ): Promise<NotificationConfigurationDeprecated> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketNotification",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TopicConfiguration: xml.first("TopicConfiguration", false, TopicConfigurationDeprecated_Parse),
      QueueConfiguration: xml.first("QueueConfiguration", false, QueueConfigurationDeprecated_Parse),
      CloudFunctionConfiguration: xml.first("CloudFunctionConfiguration", false, CloudFunctionConfiguration_Parse),
    };
  }

  async getBucketNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketNotificationConfigurationRequest,
  ): Promise<NotificationConfiguration> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketNotificationConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TopicConfigurations: xml.getList("TopicConfiguration").map(TopicConfiguration_Parse),
      QueueConfigurations: xml.getList("QueueConfiguration").map(QueueConfiguration_Parse),
      LambdaFunctionConfigurations: xml.getList("CloudFunctionConfiguration").map(LambdaFunctionConfiguration_Parse),
    };
  }

  async getBucketOwnershipControls(
    {abortSignal, ...params}: RequestConfig & GetBucketOwnershipControlsRequest,
  ): Promise<GetBucketOwnershipControlsOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketOwnershipControls",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    OwnershipControls: OwnershipControls_Parse(xml),
  };
  }

  async getBucketPolicy(
    {abortSignal, ...params}: RequestConfig & GetBucketPolicyRequest,
  ): Promise<GetBucketPolicyOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
    });
  return {
  };
  }

  async getBucketPolicyStatus(
    {abortSignal, ...params}: RequestConfig & GetBucketPolicyStatusRequest,
  ): Promise<GetBucketPolicyStatusOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketPolicyStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policyStatus`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PolicyStatus: {
        IsPublic: xml.first("IsPublic", false, x => x.content === 'true'),
      },
  };
  }

  async getBucketReplication(
    {abortSignal, ...params}: RequestConfig & GetBucketReplicationRequest,
  ): Promise<GetBucketReplicationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketReplication",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ReplicationConfiguration: ReplicationConfiguration_Parse(xml),
  };
  }

  async getBucketRequestPayment(
    {abortSignal, ...params}: RequestConfig & GetBucketRequestPaymentRequest,
  ): Promise<GetBucketRequestPaymentOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketRequestPayment",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?requestPayment`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Payer: xml.first("Payer", false, x => (x.content ?? '') as Payer),
    };
  }

  async getBucketTagging(
    {abortSignal, ...params}: RequestConfig & GetBucketTaggingRequest,
  ): Promise<GetBucketTaggingOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TagSet: xml.getList("TagSet", "Tag").map(Tag_Parse),
    };
  }

  async getBucketVersioning(
    {abortSignal, ...params}: RequestConfig & GetBucketVersioningRequest,
  ): Promise<GetBucketVersioningOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketVersioning",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versioning`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", false, x => (x.content ?? '') as BucketVersioningStatus),
      MFADelete: xml.first("MfaDelete", false, x => (x.content ?? '') as MFADeleteStatus),
    };
  }

  async getBucketWebsite(
    {abortSignal, ...params}: RequestConfig & GetBucketWebsiteRequest,
  ): Promise<GetBucketWebsiteOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketWebsite",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RedirectAllRequestsTo: xml.first("RedirectAllRequestsTo", false, RedirectAllRequestsTo_Parse),
      IndexDocument: xml.first("IndexDocument", false, IndexDocument_Parse),
      ErrorDocument: xml.first("ErrorDocument", false, ErrorDocument_Parse),
      RoutingRules: xml.getList("RoutingRules", "RoutingRule").map(RoutingRule_Parse),
    };
  }

  async getObject(
    {abortSignal, ...params}: RequestConfig & GetObjectRequest,
  ): Promise<GetObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    if (params["IfModifiedSince"] != null) headers.append("If-Modified-Since", cmnP.serializeDate_rfc822(params["IfModifiedSince"]) ?? "");
    if (params["IfNoneMatch"] != null) headers.append("If-None-Match", params["IfNoneMatch"]);
    if (params["IfUnmodifiedSince"] != null) headers.append("If-Unmodified-Since", cmnP.serializeDate_rfc822(params["IfUnmodifiedSince"]) ?? "");
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    if (params["ResponseCacheControl"] != null) query.set("response-cache-control", params["ResponseCacheControl"]?.toString() ?? "");
    if (params["ResponseContentDisposition"] != null) query.set("response-content-disposition", params["ResponseContentDisposition"]?.toString() ?? "");
    if (params["ResponseContentEncoding"] != null) query.set("response-content-encoding", params["ResponseContentEncoding"]?.toString() ?? "");
    if (params["ResponseContentLanguage"] != null) query.set("response-content-language", params["ResponseContentLanguage"]?.toString() ?? "");
    if (params["ResponseContentType"] != null) query.set("response-content-type", params["ResponseContentType"]?.toString() ?? "");
    if (params["ResponseExpires"] != null) query.set("response-expires", cmnP.serializeDate_rfc822(params["ResponseExpires"]) ?? "");
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["PartNumber"] != null) query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetObject",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
  return {
    DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
    AcceptRanges: resp.headers.get("accept-ranges"),
    Expiration: resp.headers.get("x-amz-expiration"),
    Restore: resp.headers.get("x-amz-restore"),
    LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
    ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
    ETag: resp.headers.get("ETag"),
    MissingMeta: cmnP.readNum(resp.headers.get("x-amz-missing-meta")),
    VersionId: resp.headers.get("x-amz-version-id"),
    CacheControl: resp.headers.get("Cache-Control"),
    ContentDisposition: resp.headers.get("Content-Disposition"),
    ContentEncoding: resp.headers.get("Content-Encoding"),
    ContentLanguage: resp.headers.get("Content-Language"),
    ContentRange: resp.headers.get("Content-Range"),
    ContentType: resp.headers.get("Content-Type"),
    Expires: cmnP.readTimestamp(resp.headers.get("Expires")),
    WebsiteRedirectLocation: resp.headers.get("x-amz-website-redirect-location"),
    ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
    Metadata: cmnP.toJsObj(resp.headers, "x-amz-meta-", v => v),
    SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
    SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
    SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
    BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
    StorageClass: cmnP.readEnum<StorageClass>(resp.headers.get("x-amz-storage-class")),
    RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    ReplicationStatus: cmnP.readEnum<ReplicationStatus>(resp.headers.get("x-amz-replication-status")),
    PartsCount: cmnP.readNum(resp.headers.get("x-amz-mp-parts-count")),
    TagCount: cmnP.readNum(resp.headers.get("x-amz-tagging-count")),
    ObjectLockMode: cmnP.readEnum<ObjectLockMode>(resp.headers.get("x-amz-object-lock-mode")),
    ObjectLockRetainUntilDate: cmnP.readTimestamp(resp.headers.get("x-amz-object-lock-retain-until-date")),
    ObjectLockLegalHoldStatus: cmnP.readEnum<ObjectLockLegalHoldStatus>(resp.headers.get("x-amz-object-lock-legal-hold")),
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getObjectAcl(
    {abortSignal, ...params}: RequestConfig & GetObjectAclRequest,
  ): Promise<GetObjectAclOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetObjectAcl",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?acl`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        Owner: xml.first("Owner", false, Owner_Parse),
        Grants: xml.getList("AccessControlList", "Grant").map(Grant_Parse),
      },
    };
  }

  async getObjectLegalHold(
    {abortSignal, ...params}: RequestConfig & GetObjectLegalHoldRequest,
  ): Promise<GetObjectLegalHoldOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetObjectLegalHold",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?legal-hold`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    LegalHold: ObjectLockLegalHold_Parse(xml),
  };
  }

  async getObjectLockConfiguration(
    {abortSignal, ...params}: RequestConfig & GetObjectLockConfigurationRequest,
  ): Promise<GetObjectLockConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetObjectLockConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?object-lock`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ObjectLockConfiguration: ObjectLockConfiguration_Parse(xml),
  };
  }

  async getObjectRetention(
    {abortSignal, ...params}: RequestConfig & GetObjectRetentionRequest,
  ): Promise<GetObjectRetentionOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetObjectRetention",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?retention`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Retention: ObjectLockRetention_Parse(xml),
  };
  }

  async getObjectTagging(
    {abortSignal, ...params}: RequestConfig & GetObjectTaggingRequest,
  ): Promise<GetObjectTaggingOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetObjectTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
      ...{
        TagSet: xml.getList("TagSet", "Tag").map(Tag_Parse),
      },
    };
  }

  async getObjectTorrent(
    {abortSignal, ...params}: RequestConfig & GetObjectTorrentRequest,
  ): Promise<GetObjectTorrentOutput> {
    const headers = new Headers;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetObjectTorrent",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?torrent`,
    });
  return {
    RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & GetPublicAccessBlockRequest,
  ): Promise<GetPublicAccessBlockOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetPublicAccessBlock",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PublicAccessBlockConfiguration: PublicAccessBlockConfiguration_Parse(xml),
  };
  }

  async headBucket(
    {abortSignal, ...params}: RequestConfig & HeadBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "HeadBucket",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
  }

  async headObject(
    {abortSignal, ...params}: RequestConfig & HeadObjectRequest,
  ): Promise<HeadObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    if (params["IfModifiedSince"] != null) headers.append("If-Modified-Since", cmnP.serializeDate_rfc822(params["IfModifiedSince"]) ?? "");
    if (params["IfNoneMatch"] != null) headers.append("If-None-Match", params["IfNoneMatch"]);
    if (params["IfUnmodifiedSince"] != null) headers.append("If-Unmodified-Since", cmnP.serializeDate_rfc822(params["IfUnmodifiedSince"]) ?? "");
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["PartNumber"] != null) query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "HeadObject",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    return {
      DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
      AcceptRanges: resp.headers.get("accept-ranges"),
      Expiration: resp.headers.get("x-amz-expiration"),
      Restore: resp.headers.get("x-amz-restore"),
      ArchiveStatus: cmnP.readEnum<ArchiveStatus>(resp.headers.get("x-amz-archive-status")),
      LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
      ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
      ETag: resp.headers.get("ETag"),
      MissingMeta: cmnP.readNum(resp.headers.get("x-amz-missing-meta")),
      VersionId: resp.headers.get("x-amz-version-id"),
      CacheControl: resp.headers.get("Cache-Control"),
      ContentDisposition: resp.headers.get("Content-Disposition"),
      ContentEncoding: resp.headers.get("Content-Encoding"),
      ContentLanguage: resp.headers.get("Content-Language"),
      ContentType: resp.headers.get("Content-Type"),
      Expires: cmnP.readTimestamp(resp.headers.get("Expires")),
      WebsiteRedirectLocation: resp.headers.get("x-amz-website-redirect-location"),
      ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      Metadata: cmnP.toJsObj(resp.headers, "x-amz-meta-", v => v),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      StorageClass: cmnP.readEnum<StorageClass>(resp.headers.get("x-amz-storage-class")),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ReplicationStatus: cmnP.readEnum<ReplicationStatus>(resp.headers.get("x-amz-replication-status")),
      PartsCount: cmnP.readNum(resp.headers.get("x-amz-mp-parts-count")),
      ObjectLockMode: cmnP.readEnum<ObjectLockMode>(resp.headers.get("x-amz-object-lock-mode")),
      ObjectLockRetainUntilDate: cmnP.readTimestamp(resp.headers.get("x-amz-object-lock-retain-until-date")),
      ObjectLockLegalHoldStatus: cmnP.readEnum<ObjectLockLegalHoldStatus>(resp.headers.get("x-amz-object-lock-legal-hold")),
    };
  }

  async listBucketAnalyticsConfigurations(
    {abortSignal, ...params}: RequestConfig & ListBucketAnalyticsConfigurationsRequest,
  ): Promise<ListBucketAnalyticsConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListBucketAnalyticsConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      AnalyticsConfigurationList: xml.getList("AnalyticsConfiguration").map(AnalyticsConfiguration_Parse),
    };
  }

  async listBucketIntelligentTieringConfigurations(
    {abortSignal, ...params}: RequestConfig & ListBucketIntelligentTieringConfigurationsRequest,
  ): Promise<ListBucketIntelligentTieringConfigurationsOutput> {
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListBucketIntelligentTieringConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      IntelligentTieringConfigurationList: xml.getList("IntelligentTieringConfiguration").map(IntelligentTieringConfiguration_Parse),
    };
  }

  async listBucketInventoryConfigurations(
    {abortSignal, ...params}: RequestConfig & ListBucketInventoryConfigurationsRequest,
  ): Promise<ListBucketInventoryConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListBucketInventoryConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      InventoryConfigurationList: xml.getList("InventoryConfiguration").map(InventoryConfiguration_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listBucketMetricsConfigurations(
    {abortSignal, ...params}: RequestConfig & ListBucketMetricsConfigurationsRequest,
  ): Promise<ListBucketMetricsConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListBucketMetricsConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      MetricsConfigurationList: xml.getList("MetricsConfiguration").map(MetricsConfiguration_Parse),
    };
  }

  async listBuckets(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<ListBucketsOutput> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListBuckets",
      method: "GET",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Buckets: xml.getList("Buckets", "Bucket").map(Bucket_Parse),
      Owner: xml.first("Owner", false, Owner_Parse),
    };
  }

  async listMultipartUploads(
    {abortSignal, ...params}: RequestConfig & ListMultipartUploadsRequest,
  ): Promise<ListMultipartUploadsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["KeyMarker"] != null) query.set("key-marker", params["KeyMarker"]?.toString() ?? "");
    if (params["MaxUploads"] != null) query.set("max-uploads", params["MaxUploads"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["UploadIdMarker"] != null) query.set("upload-id-marker", params["UploadIdMarker"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListMultipartUploads",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?uploads`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Bucket":true,"KeyMarker":true,"UploadIdMarker":true,"NextKeyMarker":true,"Prefix":true,"Delimiter":true,"NextUploadIdMarker":true},
      }),
      MaxUploads: xml.first("MaxUploads", false, x => parseInt(x.content ?? '0')),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Uploads: xml.getList("Upload").map(MultipartUpload_Parse),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as EncodingType),
    };
  }

  async listObjectVersions(
    {abortSignal, ...params}: RequestConfig & ListObjectVersionsRequest,
  ): Promise<ListObjectVersionsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["KeyMarker"] != null) query.set("key-marker", params["KeyMarker"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["VersionIdMarker"] != null) query.set("version-id-marker", params["VersionIdMarker"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListObjectVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versions`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"KeyMarker":true,"VersionIdMarker":true,"NextKeyMarker":true,"NextVersionIdMarker":true,"Name":true,"Prefix":true,"Delimiter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Versions: xml.getList("Version").map(ObjectVersion_Parse),
      DeleteMarkers: xml.getList("DeleteMarker").map(DeleteMarkerEntry_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as EncodingType),
    };
  }

  async listObjects(
    {abortSignal, ...params}: RequestConfig & ListObjectsRequest,
  ): Promise<ListObjectsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListObjects",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Marker":true,"NextMarker":true,"Name":true,"Prefix":true,"Delimiter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Contents: xml.getList("Contents").map(_Object_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as EncodingType),
    };
  }

  async listObjectsV2(
    {abortSignal, ...params}: RequestConfig & ListObjectsV2Request,
  ): Promise<ListObjectsV2Output> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["FetchOwner"] != null) query.set("fetch-owner", params["FetchOwner"]?.toString() ?? "");
    if (params["StartAfter"] != null) query.set("start-after", params["StartAfter"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListObjectsV2",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?list-type=2`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Name":true,"Prefix":true,"Delimiter":true,"ContinuationToken":true,"NextContinuationToken":true,"StartAfter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Contents: xml.getList("Contents").map(_Object_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as EncodingType),
      KeyCount: xml.first("KeyCount", false, x => parseInt(x.content ?? '0')),
    };
  }

  async listParts(
    {abortSignal, ...params}: RequestConfig & ListPartsRequest,
  ): Promise<ListPartsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["MaxParts"] != null) query.set("max-parts", params["MaxParts"]?.toString() ?? "");
    if (params["PartNumberMarker"] != null) query.set("part-number-marker", params["PartNumberMarker"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListParts",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AbortDate: cmnP.readTimestamp(resp.headers.get("x-amz-abort-date")),
      AbortRuleId: resp.headers.get("x-amz-abort-rule-id"),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        ...xml.strings({
          optional: {"Bucket":true,"Key":true,"UploadId":true},
        }),
        PartNumberMarker: xml.first("PartNumberMarker", false, x => parseInt(x.content ?? '0')),
        NextPartNumberMarker: xml.first("NextPartNumberMarker", false, x => parseInt(x.content ?? '0')),
        MaxParts: xml.first("MaxParts", false, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
        Parts: xml.getList("Part").map(Part_Parse),
        Initiator: xml.first("Initiator", false, Initiator_Parse),
        Owner: xml.first("Owner", false, Owner_Parse),
        StorageClass: xml.first("StorageClass", false, x => (x.content ?? '') as StorageClass),
      },
    };
  }

  async putBucketAccelerateConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketAccelerateConfigurationRequest,
  ): Promise<void> {
    const inner = params["AccelerateConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "AccelerateConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketAccelerateConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?accelerate`,
    });
  }

  async putBucketAcl(
    {abortSignal, ...params}: RequestConfig & PutBucketAclRequest,
  ): Promise<void> {
    const inner = params["AccessControlPolicy"];
    const body = inner ? xmlP.stringify({
      name: "AccessControlPolicy",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "AccessControlList", children: inner["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
        {name: "Owner", ...Owner_Serialize(inner["Owner"])},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketAcl",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?acl`,
    });
  }

  async putBucketAnalyticsConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketAnalyticsConfigurationRequest,
  ): Promise<void> {
    const inner = params["AnalyticsConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "AnalyticsConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...AnalyticsFilter_Serialize(inner["Filter"])},
        {name: "StorageClassAnalysis", ...StorageClassAnalysis_Serialize(inner["StorageClassAnalysis"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutBucketAnalyticsConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
  }

  async putBucketCors(
    {abortSignal, ...params}: RequestConfig & PutBucketCorsRequest,
  ): Promise<void> {
    const inner = params["CORSConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CORSConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["CORSRules"]?.map(x => ({name: "CORSRule", ...CORSRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketCors",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
    });
  }

  async putBucketEncryption(
    {abortSignal, ...params}: RequestConfig & PutBucketEncryptionRequest,
  ): Promise<void> {
    const inner = params["ServerSideEncryptionConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ServerSideEncryptionConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...ServerSideEncryptionRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketEncryption",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
    });
  }

  async putBucketIntelligentTieringConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketIntelligentTieringConfigurationRequest,
  ): Promise<void> {
    const inner = params["IntelligentTieringConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "IntelligentTieringConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...IntelligentTieringFilter_Serialize(inner["Filter"])},
        {name: "Status", content: inner["Status"]?.toString()},
        ...(inner["Tierings"]?.map(x => ({name: "Tiering", ...Tiering_Serialize(x)})) ?? []),
      ]}) : "";
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutBucketIntelligentTieringConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
  }

  async putBucketInventoryConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketInventoryConfigurationRequest,
  ): Promise<void> {
    const inner = params["InventoryConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "InventoryConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Destination", ...InventoryDestination_Serialize(inner["Destination"])},
        {name: "IsEnabled", content: inner["IsEnabled"]?.toString()},
        {name: "Filter", ...InventoryFilter_Serialize(inner["Filter"])},
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "IncludedObjectVersions", content: inner["IncludedObjectVersions"]?.toString()},
        {name: "OptionalFields", children: inner["OptionalFields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Schedule", ...InventorySchedule_Serialize(inner["Schedule"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutBucketInventoryConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
  }

  async putBucketLifecycle(
    {abortSignal, ...params}: RequestConfig & PutBucketLifecycleRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...Rule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketLifecycle",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
  }

  async putBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketLifecycleConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
  }

  async putBucketLogging(
    {abortSignal, ...params}: RequestConfig & PutBucketLoggingRequest,
  ): Promise<void> {
    const inner = params["BucketLoggingStatus"];
    const body = inner ? xmlP.stringify({
      name: "BucketLoggingStatus",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "LoggingEnabled", ...LoggingEnabled_Serialize(inner["LoggingEnabled"])},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketLogging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?logging`,
    });
  }

  async putBucketMetricsConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketMetricsConfigurationRequest,
  ): Promise<void> {
    const inner = params["MetricsConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "MetricsConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...MetricsFilter_Serialize(inner["Filter"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutBucketMetricsConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
  }

  async putBucketNotification(
    {abortSignal, ...params}: RequestConfig & PutBucketNotificationRequest,
  ): Promise<void> {
    const inner = params["NotificationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "NotificationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TopicConfiguration", ...TopicConfigurationDeprecated_Serialize(inner["TopicConfiguration"])},
        {name: "QueueConfiguration", ...QueueConfigurationDeprecated_Serialize(inner["QueueConfiguration"])},
        {name: "CloudFunctionConfiguration", ...CloudFunctionConfiguration_Serialize(inner["CloudFunctionConfiguration"])},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketNotification",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
  }

  async putBucketNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketNotificationConfigurationRequest,
  ): Promise<void> {
    const inner = params["NotificationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "NotificationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["TopicConfigurations"]?.map(x => ({name: "TopicConfiguration", ...TopicConfiguration_Serialize(x)})) ?? []),
        ...(inner["QueueConfigurations"]?.map(x => ({name: "QueueConfiguration", ...QueueConfiguration_Serialize(x)})) ?? []),
        ...(inner["LambdaFunctionConfigurations"]?.map(x => ({name: "CloudFunctionConfiguration", ...LambdaFunctionConfiguration_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketNotificationConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
  }

  async putBucketOwnershipControls(
    {abortSignal, ...params}: RequestConfig & PutBucketOwnershipControlsRequest,
  ): Promise<void> {
    const inner = params["OwnershipControls"];
    const body = inner ? xmlP.stringify({
      name: "OwnershipControls",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...OwnershipControlsRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketOwnershipControls",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
    });
  }

  async putBucketPolicy(
    {abortSignal, ...params}: RequestConfig & PutBucketPolicyRequest,
  ): Promise<void> {
    const body = typeof params["Policy"] === 'string' ? new TextEncoder().encode(params["Policy"]) : params["Policy"];
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ConfirmRemoveSelfBucketAccess"] != null) headers.append("x-amz-confirm-remove-self-bucket-access", params["ConfirmRemoveSelfBucketAccess"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
    });
  }

  async putBucketReplication(
    {abortSignal, ...params}: RequestConfig & PutBucketReplicationRequest,
  ): Promise<void> {
    const inner = params["ReplicationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ReplicationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Role", content: inner["Role"]?.toString()},
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...ReplicationRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["Token"] != null) headers.append("x-amz-bucket-object-lock-token", params["Token"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketReplication",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
    });
  }

  async putBucketRequestPayment(
    {abortSignal, ...params}: RequestConfig & PutBucketRequestPaymentRequest,
  ): Promise<void> {
    const inner = params["RequestPaymentConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "RequestPaymentConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Payer", content: inner["Payer"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketRequestPayment",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?requestPayment`,
    });
  }

  async putBucketTagging(
    {abortSignal, ...params}: RequestConfig & PutBucketTaggingRequest,
  ): Promise<void> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
      responseCode: 204,
    });
  }

  async putBucketVersioning(
    {abortSignal, ...params}: RequestConfig & PutBucketVersioningRequest,
  ): Promise<void> {
    const inner = params["VersioningConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "VersioningConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "MfaDelete", content: inner["MFADelete"]?.toString()},
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketVersioning",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versioning`,
    });
  }

  async putBucketWebsite(
    {abortSignal, ...params}: RequestConfig & PutBucketWebsiteRequest,
  ): Promise<void> {
    const inner = params["WebsiteConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "WebsiteConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "ErrorDocument", ...ErrorDocument_Serialize(inner["ErrorDocument"])},
        {name: "IndexDocument", ...IndexDocument_Serialize(inner["IndexDocument"])},
        {name: "RedirectAllRequestsTo", ...RedirectAllRequestsTo_Serialize(inner["RedirectAllRequestsTo"])},
        {name: "RoutingRules", children: inner["RoutingRules"]?.map(x => ({name: "RoutingRule", ...RoutingRule_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketWebsite",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
    });
  }

  async putObject(
    {abortSignal, ...params}: RequestConfig & PutObjectRequest,
  ): Promise<PutObjectOutput> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentLength"] != null) headers.append("Content-Length", params["ContentLength"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    return {
      Expiration: resp.headers.get("x-amz-expiration"),
      ETag: resp.headers.get("ETag"),
      ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      VersionId: resp.headers.get("x-amz-version-id"),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectAcl(
    {abortSignal, ...params}: RequestConfig & PutObjectAclRequest,
  ): Promise<PutObjectAclOutput> {
    const inner = params["AccessControlPolicy"];
    const body = inner ? xmlP.stringify({
      name: "AccessControlPolicy",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "AccessControlList", children: inner["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
        {name: "Owner", ...Owner_Serialize(inner["Owner"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutObjectAcl",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?acl`,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectLegalHold(
    {abortSignal, ...params}: RequestConfig & PutObjectLegalHoldRequest,
  ): Promise<PutObjectLegalHoldOutput> {
    const inner = params["LegalHold"];
    const body = inner ? xmlP.stringify({
      name: "LegalHold",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutObjectLegalHold",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?legal-hold`,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectLockConfiguration(
    {abortSignal, ...params}: RequestConfig & PutObjectLockConfigurationRequest,
  ): Promise<PutObjectLockConfigurationOutput> {
    const inner = params["ObjectLockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ObjectLockConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "ObjectLockEnabled", content: inner["ObjectLockEnabled"]?.toString()},
        {name: "Rule", ...ObjectLockRule_Serialize(inner["Rule"])},
      ]}) : "";
    const headers = new Headers;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Token"] != null) headers.append("x-amz-bucket-object-lock-token", params["Token"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutObjectLockConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?object-lock`,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectRetention(
    {abortSignal, ...params}: RequestConfig & PutObjectRetentionRequest,
  ): Promise<PutObjectRetentionOutput> {
    const inner = params["Retention"];
    const body = inner ? xmlP.stringify({
      name: "Retention",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Mode", content: inner["Mode"]?.toString()},
        {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(inner["RetainUntilDate"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutObjectRetention",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?retention`,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectTagging(
    {abortSignal, ...params}: RequestConfig & PutObjectTaggingRequest,
  ): Promise<PutObjectTaggingOutput> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PutObjectTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
    });
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
    };
  }

  async putPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & PutPublicAccessBlockRequest,
  ): Promise<void> {
    const inner = params["PublicAccessBlockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "PublicAccessBlockConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "BlockPublicAcls", content: inner["BlockPublicAcls"]?.toString()},
        {name: "IgnorePublicAcls", content: inner["IgnorePublicAcls"]?.toString()},
        {name: "BlockPublicPolicy", content: inner["BlockPublicPolicy"]?.toString()},
        {name: "RestrictPublicBuckets", content: inner["RestrictPublicBuckets"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutPublicAccessBlock",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
    });
  }

  async restoreObject(
    {abortSignal, ...params}: RequestConfig & RestoreObjectRequest,
  ): Promise<RestoreObjectOutput> {
    const inner = params["RestoreRequest"];
    const body = inner ? xmlP.stringify({
      name: "RestoreRequest",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Days", content: inner["Days"]?.toString()},
        {name: "GlacierJobParameters", ...GlacierJobParameters_Serialize(inner["GlacierJobParameters"])},
        {name: "Type", content: inner["Type"]?.toString()},
        {name: "Tier", content: inner["Tier"]?.toString()},
        {name: "Description", content: inner["Description"]?.toString()},
        {name: "SelectParameters", ...SelectParameters_Serialize(inner["SelectParameters"])},
        {name: "OutputLocation", ...OutputLocation_Serialize(inner["OutputLocation"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "RestoreObject",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?restore`,
    });
    return {
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
      RestoreOutputPath: resp.headers.get("x-amz-restore-output-path"),
    };
  }

  async selectObjectContent(
    {abortSignal, ...params}: RequestConfig & SelectObjectContentRequest,
  ): Promise<SelectObjectContentOutput> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "SelectObjectContentRequest",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Expression", content: params["Expression"]?.toString()},
        {name: "ExpressionType", content: params["ExpressionType"]?.toString()},
        {name: "RequestProgress", ...RequestProgress_Serialize(params["RequestProgress"])},
        {name: "InputSerialization", ...InputSerialization_Serialize(params["InputSerialization"])},
        {name: "OutputSerialization", ...OutputSerialization_Serialize(params["OutputSerialization"])},
        {name: "ScanRange", ...ScanRange_Serialize(params["ScanRange"])},
      ]});
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "SelectObjectContent",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?select&select-type=2`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Payload: {
        Records: xml.first("Records", false, RecordsEvent_Parse),
        Stats: xml.first("Stats", false, StatsEvent_Parse),
        Progress: xml.first("Progress", false, ProgressEvent_Parse),
        Cont: xml.first("Cont", false, ContinuationEvent_Parse),
        End: xml.first("End", false, EndEvent_Parse),
      },
  };
  }

  async uploadPart(
    {abortSignal, ...params}: RequestConfig & UploadPartRequest,
  ): Promise<UploadPartOutput> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContentLength"] != null) headers.append("Content-Length", params["ContentLength"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "UploadPart",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    return {
      ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      ETag: resp.headers.get("ETag"),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async uploadPartCopy(
    {abortSignal, ...params}: RequestConfig & UploadPartCopyRequest,
  ): Promise<UploadPartCopyOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-copy-source", params["CopySource"]);
    if (params["CopySourceIfMatch"] != null) headers.append("x-amz-copy-source-if-match", params["CopySourceIfMatch"]);
    if (params["CopySourceIfModifiedSince"] != null) headers.append("x-amz-copy-source-if-modified-since", cmnP.serializeDate_rfc822(params["CopySourceIfModifiedSince"]) ?? "");
    if (params["CopySourceIfNoneMatch"] != null) headers.append("x-amz-copy-source-if-none-match", params["CopySourceIfNoneMatch"]);
    if (params["CopySourceIfUnmodifiedSince"] != null) headers.append("x-amz-copy-source-if-unmodified-since", cmnP.serializeDate_rfc822(params["CopySourceIfUnmodifiedSince"]) ?? "");
    if (params["CopySourceRange"] != null) headers.append("x-amz-copy-source-range", params["CopySourceRange"]);
    query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", cmnP.serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["CopySourceSSECustomerAlgorithm"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-algorithm", params["CopySourceSSECustomerAlgorithm"]);
    if (params["CopySourceSSECustomerKey"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key", cmnP.serializeBlob(params["CopySourceSSECustomerKey"]) ?? '');
    if (params["CopySourceSSECustomerKeyMD5"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key-MD5", params["CopySourceSSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["ExpectedSourceBucketOwner"] != null) headers.append("x-amz-source-expected-bucket-owner", params["ExpectedSourceBucketOwner"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "UploadPartCopy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CopySourceVersionId: resp.headers.get("x-amz-copy-source-version-id"),
    ServerSideEncryption: cmnP.readEnum<ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
    SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
    SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
    SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
    BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
    RequestCharged: cmnP.readEnum<RequestCharged>(resp.headers.get("x-amz-request-charged")),
    CopyPartResult: {
        ...xml.strings({
          optional: {"ETag":true},
        }),
        LastModified: xml.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
      },
  };
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForBucketExists(
    params: RequestConfig & HeadBucketRequest,
  ): Promise<Error | void> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BucketExists';
    for (let i = 0; i < 20; i++) {
      try {
        await this.headBucket(params);
        return; // for status 200
        return; // for status 301
      } catch (err) {
        if (["Http403"].includes(err.shortCode)) return err;
        if (!["Http404"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForBucketNotExists(
    params: RequestConfig & HeadBucketRequest,
  ): Promise<Error | void> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BucketNotExists';
    for (let i = 0; i < 20; i++) {
      try {
        await this.headBucket(params);
      } catch (err) {
        if (["Http404"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForObjectExists(
    params: RequestConfig & HeadObjectRequest,
  ): Promise<HeadObjectOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ObjectExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.headObject(params);
        return resp; // for status 200
      } catch (err) {
        if (!["Http404"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForObjectNotExists(
    params: RequestConfig & HeadObjectRequest,
  ): Promise<Error | HeadObjectOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ObjectNotExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.headObject(params);
      } catch (err) {
        if (["Http404"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AbortMultipartUploadRequest {
  Bucket: string;
  Key: string;
  UploadId: string;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface CompleteMultipartUploadRequest {
  Bucket: string;
  Key: string;
  MultipartUpload?: CompletedMultipartUpload | null;
  UploadId: string;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface CopyObjectRequest {
  ACL?: ObjectCannedACL | null;
  Bucket: string;
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  ContentType?: string | null;
  CopySource: string;
  CopySourceIfMatch?: string | null;
  CopySourceIfModifiedSince?: Date | number | null;
  CopySourceIfNoneMatch?: string | null;
  CopySourceIfUnmodifiedSince?: Date | number | null;
  Expires?: Date | number | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWriteACP?: string | null;
  Key: string;
  Metadata?: { [key: string]: string | null | undefined } | null;
  MetadataDirective?: MetadataDirective | null;
  TaggingDirective?: TaggingDirective | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  StorageClass?: StorageClass | null;
  WebsiteRedirectLocation?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  CopySourceSSECustomerAlgorithm?: string | null;
  CopySourceSSECustomerKey?: Uint8Array | string | null;
  CopySourceSSECustomerKeyMD5?: string | null;
  RequestPayer?: RequestPayer | null;
  Tagging?: string | null;
  ObjectLockMode?: ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
  ObjectLockLegalHoldStatus?: ObjectLockLegalHoldStatus | null;
  ExpectedBucketOwner?: string | null;
  ExpectedSourceBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateBucketRequest {
  ACL?: BucketCannedACL | null;
  Bucket: string;
  CreateBucketConfiguration?: CreateBucketConfiguration | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWrite?: string | null;
  GrantWriteACP?: string | null;
  ObjectLockEnabledForBucket?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateMultipartUploadRequest {
  ACL?: ObjectCannedACL | null;
  Bucket: string;
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  ContentType?: string | null;
  Expires?: Date | number | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWriteACP?: string | null;
  Key: string;
  Metadata?: { [key: string]: string | null | undefined } | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  StorageClass?: StorageClass | null;
  WebsiteRedirectLocation?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestPayer?: RequestPayer | null;
  Tagging?: string | null;
  ObjectLockMode?: ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
  ObjectLockLegalHoldStatus?: ObjectLockLegalHoldStatus | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketAnalyticsConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketCorsRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketEncryptionRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketIntelligentTieringConfigurationRequest {
  Bucket: string;
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteBucketInventoryConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketLifecycleRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketMetricsConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketOwnershipControlsRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketPolicyRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketReplicationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketTaggingRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteBucketWebsiteRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteObjectRequest {
  Bucket: string;
  Key: string;
  MFA?: string | null;
  VersionId?: string | null;
  RequestPayer?: RequestPayer | null;
  BypassGovernanceRetention?: boolean | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteObjectTaggingRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteObjectsRequest {
  Bucket: string;
  Delete: Delete;
  MFA?: string | null;
  RequestPayer?: RequestPayer | null;
  BypassGovernanceRetention?: boolean | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeletePublicAccessBlockRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketAccelerateConfigurationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketAclRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketAnalyticsConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketCorsRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketEncryptionRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketIntelligentTieringConfigurationRequest {
  Bucket: string;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetBucketInventoryConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketLifecycleRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketLifecycleConfigurationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketLocationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketLoggingRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketMetricsConfigurationRequest {
  Bucket: string;
  Id: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketNotificationConfigurationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketOwnershipControlsRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketPolicyRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketPolicyStatusRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketReplicationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketRequestPaymentRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketTaggingRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketVersioningRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetBucketWebsiteRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectRequest {
  Bucket: string;
  IfMatch?: string | null;
  IfModifiedSince?: Date | number | null;
  IfNoneMatch?: string | null;
  IfUnmodifiedSince?: Date | number | null;
  Key: string;
  Range?: string | null;
  ResponseCacheControl?: string | null;
  ResponseContentDisposition?: string | null;
  ResponseContentEncoding?: string | null;
  ResponseContentLanguage?: string | null;
  ResponseContentType?: string | null;
  ResponseExpires?: Date | number | null;
  VersionId?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  RequestPayer?: RequestPayer | null;
  PartNumber?: number | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectAclRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectLegalHoldRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectLockConfigurationRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectRetentionRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectTaggingRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetObjectTorrentRequest {
  Bucket: string;
  Key: string;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPublicAccessBlockRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface HeadBucketRequest {
  Bucket: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface HeadObjectRequest {
  Bucket: string;
  IfMatch?: string | null;
  IfModifiedSince?: Date | number | null;
  IfNoneMatch?: string | null;
  IfUnmodifiedSince?: Date | number | null;
  Key: string;
  Range?: string | null;
  VersionId?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  RequestPayer?: RequestPayer | null;
  PartNumber?: number | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBucketAnalyticsConfigurationsRequest {
  Bucket: string;
  ContinuationToken?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBucketIntelligentTieringConfigurationsRequest {
  Bucket: string;
  ContinuationToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBucketInventoryConfigurationsRequest {
  Bucket: string;
  ContinuationToken?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBucketMetricsConfigurationsRequest {
  Bucket: string;
  ContinuationToken?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListMultipartUploadsRequest {
  Bucket: string;
  Delimiter?: string | null;
  EncodingType?: EncodingType | null;
  KeyMarker?: string | null;
  MaxUploads?: number | null;
  Prefix?: string | null;
  UploadIdMarker?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListObjectVersionsRequest {
  Bucket: string;
  Delimiter?: string | null;
  EncodingType?: EncodingType | null;
  KeyMarker?: string | null;
  MaxKeys?: number | null;
  Prefix?: string | null;
  VersionIdMarker?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListObjectsRequest {
  Bucket: string;
  Delimiter?: string | null;
  EncodingType?: EncodingType | null;
  Marker?: string | null;
  MaxKeys?: number | null;
  Prefix?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListObjectsV2Request {
  Bucket: string;
  Delimiter?: string | null;
  EncodingType?: EncodingType | null;
  MaxKeys?: number | null;
  Prefix?: string | null;
  ContinuationToken?: string | null;
  FetchOwner?: boolean | null;
  StartAfter?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPartsRequest {
  Bucket: string;
  Key: string;
  MaxParts?: number | null;
  PartNumberMarker?: number | null;
  UploadId: string;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketAccelerateConfigurationRequest {
  Bucket: string;
  AccelerateConfiguration: AccelerateConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketAclRequest {
  ACL?: BucketCannedACL | null;
  AccessControlPolicy?: AccessControlPolicy | null;
  Bucket: string;
  ContentMD5?: string | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWrite?: string | null;
  GrantWriteACP?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketAnalyticsConfigurationRequest {
  Bucket: string;
  Id: string;
  AnalyticsConfiguration: AnalyticsConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketCorsRequest {
  Bucket: string;
  CORSConfiguration: CORSConfiguration;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketEncryptionRequest {
  Bucket: string;
  ContentMD5?: string | null;
  ServerSideEncryptionConfiguration: ServerSideEncryptionConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketIntelligentTieringConfigurationRequest {
  Bucket: string;
  Id: string;
  IntelligentTieringConfiguration: IntelligentTieringConfiguration;
}

// refs: 1 - tags: named, input
export interface PutBucketInventoryConfigurationRequest {
  Bucket: string;
  Id: string;
  InventoryConfiguration: InventoryConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketLifecycleRequest {
  Bucket: string;
  ContentMD5?: string | null;
  LifecycleConfiguration?: LifecycleConfiguration | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketLifecycleConfigurationRequest {
  Bucket: string;
  LifecycleConfiguration?: BucketLifecycleConfiguration | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketLoggingRequest {
  Bucket: string;
  BucketLoggingStatus: BucketLoggingStatus;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketMetricsConfigurationRequest {
  Bucket: string;
  Id: string;
  MetricsConfiguration: MetricsConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketNotificationRequest {
  Bucket: string;
  ContentMD5?: string | null;
  NotificationConfiguration: NotificationConfigurationDeprecated;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketNotificationConfigurationRequest {
  Bucket: string;
  NotificationConfiguration: NotificationConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketOwnershipControlsRequest {
  Bucket: string;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
  OwnershipControls: OwnershipControls;
}

// refs: 1 - tags: named, input
export interface PutBucketPolicyRequest {
  Bucket: string;
  ContentMD5?: string | null;
  ConfirmRemoveSelfBucketAccess?: boolean | null;
  Policy: string;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketReplicationRequest {
  Bucket: string;
  ContentMD5?: string | null;
  ReplicationConfiguration: ReplicationConfiguration;
  Token?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketRequestPaymentRequest {
  Bucket: string;
  ContentMD5?: string | null;
  RequestPaymentConfiguration: RequestPaymentConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketTaggingRequest {
  Bucket: string;
  ContentMD5?: string | null;
  Tagging: Tagging;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketVersioningRequest {
  Bucket: string;
  ContentMD5?: string | null;
  MFA?: string | null;
  VersioningConfiguration: VersioningConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutBucketWebsiteRequest {
  Bucket: string;
  ContentMD5?: string | null;
  WebsiteConfiguration: WebsiteConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectRequest {
  ACL?: ObjectCannedACL | null;
  Body?: Uint8Array | string | null;
  Bucket: string;
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  ContentLength?: number | null;
  ContentMD5?: string | null;
  ContentType?: string | null;
  Expires?: Date | number | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWriteACP?: string | null;
  Key: string;
  Metadata?: { [key: string]: string | null | undefined } | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  StorageClass?: StorageClass | null;
  WebsiteRedirectLocation?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestPayer?: RequestPayer | null;
  Tagging?: string | null;
  ObjectLockMode?: ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
  ObjectLockLegalHoldStatus?: ObjectLockLegalHoldStatus | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectAclRequest {
  ACL?: ObjectCannedACL | null;
  AccessControlPolicy?: AccessControlPolicy | null;
  Bucket: string;
  ContentMD5?: string | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWrite?: string | null;
  GrantWriteACP?: string | null;
  Key: string;
  RequestPayer?: RequestPayer | null;
  VersionId?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectLegalHoldRequest {
  Bucket: string;
  Key: string;
  LegalHold?: ObjectLockLegalHold | null;
  RequestPayer?: RequestPayer | null;
  VersionId?: string | null;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectLockConfigurationRequest {
  Bucket: string;
  ObjectLockConfiguration?: ObjectLockConfiguration | null;
  RequestPayer?: RequestPayer | null;
  Token?: string | null;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectRetentionRequest {
  Bucket: string;
  Key: string;
  Retention?: ObjectLockRetention | null;
  RequestPayer?: RequestPayer | null;
  VersionId?: string | null;
  BypassGovernanceRetention?: boolean | null;
  ContentMD5?: string | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutObjectTaggingRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  ContentMD5?: string | null;
  Tagging: Tagging;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface PutPublicAccessBlockRequest {
  Bucket: string;
  ContentMD5?: string | null;
  PublicAccessBlockConfiguration: PublicAccessBlockConfiguration;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface RestoreObjectRequest {
  Bucket: string;
  Key: string;
  VersionId?: string | null;
  RestoreRequest?: RestoreRequest | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface SelectObjectContentRequest {
  Bucket: string;
  Key: string;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  Expression: string;
  ExpressionType: ExpressionType;
  RequestProgress?: RequestProgress | null;
  InputSerialization: InputSerialization;
  OutputSerialization: OutputSerialization;
  ScanRange?: ScanRange | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface UploadPartRequest {
  Body?: Uint8Array | string | null;
  Bucket: string;
  ContentLength?: number | null;
  ContentMD5?: string | null;
  Key: string;
  PartNumber: number;
  UploadId: string;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface UploadPartCopyRequest {
  Bucket: string;
  CopySource: string;
  CopySourceIfMatch?: string | null;
  CopySourceIfModifiedSince?: Date | number | null;
  CopySourceIfNoneMatch?: string | null;
  CopySourceIfUnmodifiedSince?: Date | number | null;
  CopySourceRange?: string | null;
  Key: string;
  PartNumber: number;
  UploadId: string;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKey?: Uint8Array | string | null;
  SSECustomerKeyMD5?: string | null;
  CopySourceSSECustomerAlgorithm?: string | null;
  CopySourceSSECustomerKey?: Uint8Array | string | null;
  CopySourceSSECustomerKeyMD5?: string | null;
  RequestPayer?: RequestPayer | null;
  ExpectedBucketOwner?: string | null;
  ExpectedSourceBucketOwner?: string | null;
}

// refs: 1 - tags: named, output
export interface AbortMultipartUploadOutput {
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface CompleteMultipartUploadOutput {
  Location?: string | null;
  Bucket?: string | null;
  Key?: string | null;
  Expiration?: string | null;
  ETag?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  VersionId?: string | null;
  SSEKMSKeyId?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface CopyObjectOutput {
  CopyObjectResult?: CopyObjectResult | null;
  Expiration?: string | null;
  CopySourceVersionId?: string | null;
  VersionId?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface CreateBucketOutput {
  Location?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateMultipartUploadOutput {
  AbortDate?: Date | number | null;
  AbortRuleId?: string | null;
  Bucket?: string | null;
  Key?: string | null;
  UploadId?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface DeleteObjectOutput {
  DeleteMarker?: boolean | null;
  VersionId?: string | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface DeleteObjectTaggingOutput {
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteObjectsOutput {
  Deleted: DeletedObject[];
  RequestCharged?: RequestCharged | null;
  Errors: Error[];
}

// refs: 1 - tags: named, output
export interface GetBucketAccelerateConfigurationOutput {
  Status?: BucketAccelerateStatus | null;
}

// refs: 1 - tags: named, output
export interface GetBucketAclOutput {
  Owner?: Owner | null;
  Grants: Grant[];
}

// refs: 1 - tags: named, output
export interface GetBucketAnalyticsConfigurationOutput {
  AnalyticsConfiguration?: AnalyticsConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetBucketCorsOutput {
  CORSRules: CORSRule[];
}

// refs: 1 - tags: named, output
export interface GetBucketEncryptionOutput {
  ServerSideEncryptionConfiguration?: ServerSideEncryptionConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetBucketIntelligentTieringConfigurationOutput {
  IntelligentTieringConfiguration?: IntelligentTieringConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetBucketInventoryConfigurationOutput {
  InventoryConfiguration?: InventoryConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetBucketLifecycleOutput {
  Rules: Rule[];
}

// refs: 1 - tags: named, output
export interface GetBucketLifecycleConfigurationOutput {
  Rules: LifecycleRule[];
}

// refs: 1 - tags: named, output
export interface GetBucketLocationOutput {
  LocationConstraint?: BucketLocationConstraint | null;
}

// refs: 1 - tags: named, output
export interface GetBucketLoggingOutput {
  LoggingEnabled?: LoggingEnabled | null;
}

// refs: 1 - tags: named, output
export interface GetBucketMetricsConfigurationOutput {
  MetricsConfiguration?: MetricsConfiguration | null;
}

// refs: 2 - tags: input, named, interface, output
export interface NotificationConfigurationDeprecated {
  TopicConfiguration?: TopicConfigurationDeprecated | null;
  QueueConfiguration?: QueueConfigurationDeprecated | null;
  CloudFunctionConfiguration?: CloudFunctionConfiguration | null;
}
function NotificationConfigurationDeprecated_Serialize(data: NotificationConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TopicConfiguration", ...TopicConfigurationDeprecated_Serialize(data["TopicConfiguration"])},
    {name: "QueueConfiguration", ...QueueConfigurationDeprecated_Serialize(data["QueueConfiguration"])},
    {name: "CloudFunctionConfiguration", ...CloudFunctionConfiguration_Serialize(data["CloudFunctionConfiguration"])},
  ]};
}
function NotificationConfigurationDeprecated_Parse(node: xmlP.XmlNode): NotificationConfigurationDeprecated {
  return {
    TopicConfiguration: node.first("TopicConfiguration", false, TopicConfigurationDeprecated_Parse),
    QueueConfiguration: node.first("QueueConfiguration", false, QueueConfigurationDeprecated_Parse),
    CloudFunctionConfiguration: node.first("CloudFunctionConfiguration", false, CloudFunctionConfiguration_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface NotificationConfiguration {
  TopicConfigurations: TopicConfiguration[];
  QueueConfigurations: QueueConfiguration[];
  LambdaFunctionConfigurations: LambdaFunctionConfiguration[];
}
function NotificationConfiguration_Serialize(data: NotificationConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["TopicConfigurations"]?.map(x => ({name: "TopicConfiguration", ...TopicConfiguration_Serialize(x)})) ?? []),
    ...(data["QueueConfigurations"]?.map(x => ({name: "QueueConfiguration", ...QueueConfiguration_Serialize(x)})) ?? []),
    ...(data["LambdaFunctionConfigurations"]?.map(x => ({name: "CloudFunctionConfiguration", ...LambdaFunctionConfiguration_Serialize(x)})) ?? []),
  ]};
}
function NotificationConfiguration_Parse(node: xmlP.XmlNode): NotificationConfiguration {
  return {
    TopicConfigurations: node.getList("TopicConfiguration").map(TopicConfiguration_Parse),
    QueueConfigurations: node.getList("QueueConfiguration").map(QueueConfiguration_Parse),
    LambdaFunctionConfigurations: node.getList("CloudFunctionConfiguration").map(LambdaFunctionConfiguration_Parse),
  };
}

// refs: 1 - tags: named, output
export interface GetBucketOwnershipControlsOutput {
  OwnershipControls?: OwnershipControls | null;
}

// refs: 1 - tags: named, output
export interface GetBucketPolicyOutput {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBucketPolicyStatusOutput {
  PolicyStatus?: PolicyStatus | null;
}

// refs: 1 - tags: named, output
export interface GetBucketReplicationOutput {
  ReplicationConfiguration?: ReplicationConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetBucketRequestPaymentOutput {
  Payer?: Payer | null;
}

// refs: 1 - tags: named, output
export interface GetBucketTaggingOutput {
  TagSet: Tag[];
}

// refs: 1 - tags: named, output
export interface GetBucketVersioningOutput {
  Status?: BucketVersioningStatus | null;
  MFADelete?: MFADeleteStatus | null;
}

// refs: 1 - tags: named, output
export interface GetBucketWebsiteOutput {
  RedirectAllRequestsTo?: RedirectAllRequestsTo | null;
  IndexDocument?: IndexDocument | null;
  ErrorDocument?: ErrorDocument | null;
  RoutingRules: RoutingRule[];
}

// refs: 1 - tags: named, output
export interface GetObjectOutput {
  Body?: Uint8Array | string | null;
  DeleteMarker?: boolean | null;
  AcceptRanges?: string | null;
  Expiration?: string | null;
  Restore?: string | null;
  LastModified?: Date | number | null;
  ContentLength?: number | null;
  ETag?: string | null;
  MissingMeta?: number | null;
  VersionId?: string | null;
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  ContentRange?: string | null;
  ContentType?: string | null;
  Expires?: Date | number | null;
  WebsiteRedirectLocation?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  Metadata: { [key: string]: string | null | undefined };
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  BucketKeyEnabled?: boolean | null;
  StorageClass?: StorageClass | null;
  RequestCharged?: RequestCharged | null;
  ReplicationStatus?: ReplicationStatus | null;
  PartsCount?: number | null;
  TagCount?: number | null;
  ObjectLockMode?: ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
  ObjectLockLegalHoldStatus?: ObjectLockLegalHoldStatus | null;
}

// refs: 1 - tags: named, output
export interface GetObjectAclOutput {
  Owner?: Owner | null;
  Grants: Grant[];
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface GetObjectLegalHoldOutput {
  LegalHold?: ObjectLockLegalHold | null;
}

// refs: 1 - tags: named, output
export interface GetObjectLockConfigurationOutput {
  ObjectLockConfiguration?: ObjectLockConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetObjectRetentionOutput {
  Retention?: ObjectLockRetention | null;
}

// refs: 1 - tags: named, output
export interface GetObjectTaggingOutput {
  VersionId?: string | null;
  TagSet: Tag[];
}

// refs: 1 - tags: named, output
export interface GetObjectTorrentOutput {
  Body?: Uint8Array | string | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface GetPublicAccessBlockOutput {
  PublicAccessBlockConfiguration?: PublicAccessBlockConfiguration | null;
}

// refs: 1 - tags: named, output
export interface HeadObjectOutput {
  DeleteMarker?: boolean | null;
  AcceptRanges?: string | null;
  Expiration?: string | null;
  Restore?: string | null;
  ArchiveStatus?: ArchiveStatus | null;
  LastModified?: Date | number | null;
  ContentLength?: number | null;
  ETag?: string | null;
  MissingMeta?: number | null;
  VersionId?: string | null;
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  ContentType?: string | null;
  Expires?: Date | number | null;
  WebsiteRedirectLocation?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  Metadata: { [key: string]: string | null | undefined };
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  BucketKeyEnabled?: boolean | null;
  StorageClass?: StorageClass | null;
  RequestCharged?: RequestCharged | null;
  ReplicationStatus?: ReplicationStatus | null;
  PartsCount?: number | null;
  ObjectLockMode?: ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
  ObjectLockLegalHoldStatus?: ObjectLockLegalHoldStatus | null;
}

// refs: 1 - tags: named, output
export interface ListBucketAnalyticsConfigurationsOutput {
  IsTruncated?: boolean | null;
  ContinuationToken?: string | null;
  NextContinuationToken?: string | null;
  AnalyticsConfigurationList: AnalyticsConfiguration[];
}

// refs: 1 - tags: named, output
export interface ListBucketIntelligentTieringConfigurationsOutput {
  IsTruncated?: boolean | null;
  ContinuationToken?: string | null;
  NextContinuationToken?: string | null;
  IntelligentTieringConfigurationList: IntelligentTieringConfiguration[];
}

// refs: 1 - tags: named, output
export interface ListBucketInventoryConfigurationsOutput {
  ContinuationToken?: string | null;
  InventoryConfigurationList: InventoryConfiguration[];
  IsTruncated?: boolean | null;
  NextContinuationToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBucketMetricsConfigurationsOutput {
  IsTruncated?: boolean | null;
  ContinuationToken?: string | null;
  NextContinuationToken?: string | null;
  MetricsConfigurationList: MetricsConfiguration[];
}

// refs: 1 - tags: named, output
export interface ListBucketsOutput {
  Buckets: Bucket[];
  Owner?: Owner | null;
}

// refs: 1 - tags: named, output
export interface ListMultipartUploadsOutput {
  Bucket?: string | null;
  KeyMarker?: string | null;
  UploadIdMarker?: string | null;
  NextKeyMarker?: string | null;
  Prefix?: string | null;
  Delimiter?: string | null;
  NextUploadIdMarker?: string | null;
  MaxUploads?: number | null;
  IsTruncated?: boolean | null;
  Uploads: MultipartUpload[];
  CommonPrefixes: CommonPrefix[];
  EncodingType?: EncodingType | null;
}

// refs: 1 - tags: named, output
export interface ListObjectVersionsOutput {
  IsTruncated?: boolean | null;
  KeyMarker?: string | null;
  VersionIdMarker?: string | null;
  NextKeyMarker?: string | null;
  NextVersionIdMarker?: string | null;
  Versions: ObjectVersion[];
  DeleteMarkers: DeleteMarkerEntry[];
  Name?: string | null;
  Prefix?: string | null;
  Delimiter?: string | null;
  MaxKeys?: number | null;
  CommonPrefixes: CommonPrefix[];
  EncodingType?: EncodingType | null;
}

// refs: 1 - tags: named, output
export interface ListObjectsOutput {
  IsTruncated?: boolean | null;
  Marker?: string | null;
  NextMarker?: string | null;
  Contents: _Object[];
  Name?: string | null;
  Prefix?: string | null;
  Delimiter?: string | null;
  MaxKeys?: number | null;
  CommonPrefixes: CommonPrefix[];
  EncodingType?: EncodingType | null;
}

// refs: 1 - tags: named, output
export interface ListObjectsV2Output {
  IsTruncated?: boolean | null;
  Contents: _Object[];
  Name?: string | null;
  Prefix?: string | null;
  Delimiter?: string | null;
  MaxKeys?: number | null;
  CommonPrefixes: CommonPrefix[];
  EncodingType?: EncodingType | null;
  KeyCount?: number | null;
  ContinuationToken?: string | null;
  NextContinuationToken?: string | null;
  StartAfter?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPartsOutput {
  AbortDate?: Date | number | null;
  AbortRuleId?: string | null;
  Bucket?: string | null;
  Key?: string | null;
  UploadId?: string | null;
  PartNumberMarker?: number | null;
  NextPartNumberMarker?: number | null;
  MaxParts?: number | null;
  IsTruncated?: boolean | null;
  Parts: Part[];
  Initiator?: Initiator | null;
  Owner?: Owner | null;
  StorageClass?: StorageClass | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectOutput {
  Expiration?: string | null;
  ETag?: string | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  VersionId?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  SSEKMSEncryptionContext?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectAclOutput {
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectLegalHoldOutput {
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectLockConfigurationOutput {
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectRetentionOutput {
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface PutObjectTaggingOutput {
  VersionId?: string | null;
}

// refs: 1 - tags: named, output
export interface RestoreObjectOutput {
  RequestCharged?: RequestCharged | null;
  RestoreOutputPath?: string | null;
}

// refs: 1 - tags: named, output
export interface SelectObjectContentOutput {
  Payload?: SelectObjectContentEventStream | null;
}

// refs: 1 - tags: named, output
export interface UploadPartOutput {
  ServerSideEncryption?: ServerSideEncryption | null;
  ETag?: string | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 1 - tags: named, output
export interface UploadPartCopyOutput {
  CopySourceVersionId?: string | null;
  CopyPartResult?: CopyPartResult | null;
  ServerSideEncryption?: ServerSideEncryption | null;
  SSECustomerAlgorithm?: string | null;
  SSECustomerKeyMD5?: string | null;
  SSEKMSKeyId?: string | null;
  BucketKeyEnabled?: boolean | null;
  RequestCharged?: RequestCharged | null;
}

// refs: 23 - tags: input, named, enum
export type RequestPayer =
| "requester"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CompletedMultipartUpload {
  Parts?: CompletedPart[] | null;
}
function CompletedMultipartUpload_Serialize(data: CompletedMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Parts"]?.map(x => ({name: "Part", ...CompletedPart_Serialize(x)})) ?? []),
  ]};
}

// refs: 1 - tags: input, named, interface
export interface CompletedPart {
  ETag?: string | null;
  PartNumber?: number | null;
}
function CompletedPart_Serialize(data: CompletedPart | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ETag", content: data["ETag"]?.toString()},
    {name: "PartNumber", content: data["PartNumber"]?.toString()},
  ]};
}

// refs: 5 - tags: input, named, enum
export type ObjectCannedACL =
| "private"
| "public-read"
| "public-read-write"
| "authenticated-read"
| "aws-exec-read"
| "bucket-owner-read"
| "bucket-owner-full-control"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type MetadataDirective =
| "COPY"
| "REPLACE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TaggingDirective =
| "COPY"
| "REPLACE"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type ServerSideEncryption =
| "AES256"
| "aws:kms"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type StorageClass =
| "STANDARD"
| "REDUCED_REDUNDANCY"
| "STANDARD_IA"
| "ONEZONE_IA"
| "INTELLIGENT_TIERING"
| "GLACIER"
| "DEEP_ARCHIVE"
| "OUTPOSTS"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type ObjectLockMode =
| "GOVERNANCE"
| "COMPLIANCE"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type ObjectLockLegalHoldStatus =
| "ON"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type BucketCannedACL =
| "private"
| "public-read"
| "public-read-write"
| "authenticated-read"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CreateBucketConfiguration {
  LocationConstraint?: BucketLocationConstraint | null;
}
function CreateBucketConfiguration_Serialize(data: CreateBucketConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LocationConstraint", content: data["LocationConstraint"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum, output
export type BucketLocationConstraint =
| "af-south-1"
| "ap-east-1"
| "ap-northeast-1"
| "ap-northeast-2"
| "ap-northeast-3"
| "ap-south-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ca-central-1"
| "cn-north-1"
| "cn-northwest-1"
| "EU"
| "eu-central-1"
| "eu-north-1"
| "eu-south-1"
| "eu-west-1"
| "eu-west-2"
| "eu-west-3"
| "me-south-1"
| "sa-east-1"
| "us-east-2"
| "us-gov-east-1"
| "us-gov-west-1"
| "us-west-1"
| "us-west-2"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Delete {
  Objects: ObjectIdentifier[];
  Quiet?: boolean | null;
}
function Delete_Serialize(data: Delete | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Objects"]?.map(x => ({name: "Object", ...ObjectIdentifier_Serialize(x)})) ?? []),
    {name: "Quiet", content: data["Quiet"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface ObjectIdentifier {
  Key: string;
  VersionId?: string | null;
}
function ObjectIdentifier_Serialize(data: ObjectIdentifier | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "VersionId", content: data["VersionId"]?.toString()},
  ]};
}

// refs: 8 - tags: input, named, enum, output
export type EncodingType =
| "url"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface AccelerateConfiguration {
  Status?: BucketAccelerateStatus | null;
}
function AccelerateConfiguration_Serialize(data: AccelerateConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum, output
export type BucketAccelerateStatus =
| "Enabled"
| "Suspended"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface AccessControlPolicy {
  Grants?: Grant[] | null;
  Owner?: Owner | null;
}
function AccessControlPolicy_Serialize(data: AccessControlPolicy | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlList", children: data["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
    {name: "Owner", ...Owner_Serialize(data["Owner"])},
  ]};
}

// refs: 5 - tags: input, named, interface, output
export interface Grant {
  Grantee?: Grantee | null;
  Permission?: Permission | null;
}
function Grant_Serialize(data: Grant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function Grant_Parse(node: xmlP.XmlNode): Grant {
  return {
    Grantee: node.first("Grantee", false, Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as Permission),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface Grantee {
  DisplayName?: string | null;
  EmailAddress?: string | null;
  ID?: string | null;
  Type: Type;
  URI?: string | null;
}
function Grantee_Serialize(data: Grantee | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {attributes: {
    "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "xsi:type": data["Type"] ?? undefined,
  }, children: [
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
    {name: "EmailAddress", content: data["EmailAddress"]?.toString()},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "URI", content: data["URI"]?.toString()},
  ]};
}
function Grantee_Parse(node: xmlP.XmlNode): Grantee {
  return {
    ...node.strings({
      optional: {"DisplayName":true,"EmailAddress":true,"ID":true,"URI":true},
    }),
    Type: cmnP.readEnumReq<Type>(node.attributes["xsi:type"]),
  };
}

// refs: 7 - tags: input, named, enum, output
export type Type =
| "CanonicalUser"
| "AmazonCustomerByEmail"
| "Group"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type Permission =
| "FULL_CONTROL"
| "WRITE"
| "WRITE_ACP"
| "READ"
| "READ_ACP"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface Owner {
  DisplayName?: string | null;
  ID?: string | null;
}
function Owner_Serialize(data: Owner | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
    {name: "ID", content: data["ID"]?.toString()},
  ]};
}
function Owner_Parse(node: xmlP.XmlNode): Owner {
  return node.strings({
    optional: {"DisplayName":true,"ID":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface AnalyticsConfiguration {
  Id: string;
  Filter?: AnalyticsFilter | null;
  StorageClassAnalysis: StorageClassAnalysis;
}
function AnalyticsConfiguration_Serialize(data: AnalyticsConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...AnalyticsFilter_Serialize(data["Filter"])},
    {name: "StorageClassAnalysis", ...StorageClassAnalysis_Serialize(data["StorageClassAnalysis"])},
  ]};
}
function AnalyticsConfiguration_Parse(node: xmlP.XmlNode): AnalyticsConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, AnalyticsFilter_Parse),
    StorageClassAnalysis: node.first("StorageClassAnalysis", true, StorageClassAnalysis_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface AnalyticsFilter {
  Prefix?: string | null;
  Tag?: Tag | null;
  And?: AnalyticsAndOperator | null;
}
function AnalyticsFilter_Serialize(data: AnalyticsFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...AnalyticsAndOperator_Serialize(data["And"])},
  ]};
}
function AnalyticsFilter_Parse(node: xmlP.XmlNode): AnalyticsFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, AnalyticsAndOperator_Parse),
  };
}

// refs: 31 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function Tag_Serialize(data: Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface AnalyticsAndOperator {
  Prefix?: string | null;
  Tags: Tag[];
}
function AnalyticsAndOperator_Serialize(data: AnalyticsAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function AnalyticsAndOperator_Parse(node: xmlP.XmlNode): AnalyticsAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface StorageClassAnalysis {
  DataExport?: StorageClassAnalysisDataExport | null;
}
function StorageClassAnalysis_Serialize(data: StorageClassAnalysis | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DataExport", ...StorageClassAnalysisDataExport_Serialize(data["DataExport"])},
  ]};
}
function StorageClassAnalysis_Parse(node: xmlP.XmlNode): StorageClassAnalysis {
  return {
    DataExport: node.first("DataExport", false, StorageClassAnalysisDataExport_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface StorageClassAnalysisDataExport {
  OutputSchemaVersion: StorageClassAnalysisSchemaVersion;
  Destination: AnalyticsExportDestination;
}
function StorageClassAnalysisDataExport_Serialize(data: StorageClassAnalysisDataExport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OutputSchemaVersion", content: data["OutputSchemaVersion"]?.toString()},
    {name: "Destination", ...AnalyticsExportDestination_Serialize(data["Destination"])},
  ]};
}
function StorageClassAnalysisDataExport_Parse(node: xmlP.XmlNode): StorageClassAnalysisDataExport {
  return {
    OutputSchemaVersion: node.first("OutputSchemaVersion", true, x => (x.content ?? '') as StorageClassAnalysisSchemaVersion),
    Destination: node.first("Destination", true, AnalyticsExportDestination_Parse),
  };
}

// refs: 3 - tags: input, named, enum, output
export type StorageClassAnalysisSchemaVersion =
| "V_1"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface AnalyticsExportDestination {
  S3BucketDestination: AnalyticsS3BucketDestination;
}
function AnalyticsExportDestination_Serialize(data: AnalyticsExportDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...AnalyticsS3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function AnalyticsExportDestination_Parse(node: xmlP.XmlNode): AnalyticsExportDestination {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, AnalyticsS3BucketDestination_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface AnalyticsS3BucketDestination {
  Format: AnalyticsS3ExportFileFormat;
  BucketAccountId?: string | null;
  Bucket: string;
  Prefix?: string | null;
}
function AnalyticsS3BucketDestination_Serialize(data: AnalyticsS3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "BucketAccountId", content: data["BucketAccountId"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function AnalyticsS3BucketDestination_Parse(node: xmlP.XmlNode): AnalyticsS3BucketDestination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"BucketAccountId":true,"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as AnalyticsS3ExportFileFormat),
  };
}

// refs: 3 - tags: input, named, enum, output
export type AnalyticsS3ExportFileFormat =
| "CSV"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CORSConfiguration {
  CORSRules: CORSRule[];
}
function CORSConfiguration_Serialize(data: CORSConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["CORSRules"]?.map(x => ({name: "CORSRule", ...CORSRule_Serialize(x)})) ?? []),
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface CORSRule {
  AllowedHeaders: string[];
  AllowedMethods: string[];
  AllowedOrigins: string[];
  ExposeHeaders: string[];
  MaxAgeSeconds?: number | null;
}
function CORSRule_Serialize(data: CORSRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["AllowedHeaders"]?.map(x => ({name: "AllowedHeader", content: x})) ?? []),
    ...(data["AllowedMethods"]?.map(x => ({name: "AllowedMethod", content: x})) ?? []),
    ...(data["AllowedOrigins"]?.map(x => ({name: "AllowedOrigin", content: x})) ?? []),
    ...(data["ExposeHeaders"]?.map(x => ({name: "ExposeHeader", content: x})) ?? []),
    {name: "MaxAgeSeconds", content: data["MaxAgeSeconds"]?.toString()},
  ]};
}
function CORSRule_Parse(node: xmlP.XmlNode): CORSRule {
  return {
    AllowedHeaders: node.getList("AllowedHeader").map(x => x.content ?? ''),
    AllowedMethods: node.getList("AllowedMethod").map(x => x.content ?? ''),
    AllowedOrigins: node.getList("AllowedOrigin").map(x => x.content ?? ''),
    ExposeHeaders: node.getList("ExposeHeader").map(x => x.content ?? ''),
    MaxAgeSeconds: node.first("MaxAgeSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ServerSideEncryptionConfiguration {
  Rules: ServerSideEncryptionRule[];
}
function ServerSideEncryptionConfiguration_Serialize(data: ServerSideEncryptionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...ServerSideEncryptionRule_Serialize(x)})) ?? []),
  ]};
}
function ServerSideEncryptionConfiguration_Parse(node: xmlP.XmlNode): ServerSideEncryptionConfiguration {
  return {
    Rules: node.getList("Rule").map(ServerSideEncryptionRule_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ServerSideEncryptionRule {
  ApplyServerSideEncryptionByDefault?: ServerSideEncryptionByDefault | null;
  BucketKeyEnabled?: boolean | null;
}
function ServerSideEncryptionRule_Serialize(data: ServerSideEncryptionRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ApplyServerSideEncryptionByDefault", ...ServerSideEncryptionByDefault_Serialize(data["ApplyServerSideEncryptionByDefault"])},
    {name: "BucketKeyEnabled", content: data["BucketKeyEnabled"]?.toString()},
  ]};
}
function ServerSideEncryptionRule_Parse(node: xmlP.XmlNode): ServerSideEncryptionRule {
  return {
    ApplyServerSideEncryptionByDefault: node.first("ApplyServerSideEncryptionByDefault", false, ServerSideEncryptionByDefault_Parse),
    BucketKeyEnabled: node.first("BucketKeyEnabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ServerSideEncryptionByDefault {
  SSEAlgorithm: ServerSideEncryption;
  KMSMasterKeyID?: string | null;
}
function ServerSideEncryptionByDefault_Serialize(data: ServerSideEncryptionByDefault | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSEAlgorithm", content: data["SSEAlgorithm"]?.toString()},
    {name: "KMSMasterKeyID", content: data["KMSMasterKeyID"]?.toString()},
  ]};
}
function ServerSideEncryptionByDefault_Parse(node: xmlP.XmlNode): ServerSideEncryptionByDefault {
  return {
    ...node.strings({
      optional: {"KMSMasterKeyID":true},
    }),
    SSEAlgorithm: node.first("SSEAlgorithm", true, x => (x.content ?? '') as ServerSideEncryption),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface IntelligentTieringConfiguration {
  Id: string;
  Filter?: IntelligentTieringFilter | null;
  Status: IntelligentTieringStatus;
  Tierings: Tiering[];
}
function IntelligentTieringConfiguration_Serialize(data: IntelligentTieringConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...IntelligentTieringFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    ...(data["Tierings"]?.map(x => ({name: "Tiering", ...Tiering_Serialize(x)})) ?? []),
  ]};
}
function IntelligentTieringConfiguration_Parse(node: xmlP.XmlNode): IntelligentTieringConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, IntelligentTieringFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as IntelligentTieringStatus),
    Tierings: node.getList("Tiering").map(Tiering_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface IntelligentTieringFilter {
  Prefix?: string | null;
  Tag?: Tag | null;
  And?: IntelligentTieringAndOperator | null;
}
function IntelligentTieringFilter_Serialize(data: IntelligentTieringFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...IntelligentTieringAndOperator_Serialize(data["And"])},
  ]};
}
function IntelligentTieringFilter_Parse(node: xmlP.XmlNode): IntelligentTieringFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, IntelligentTieringAndOperator_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface IntelligentTieringAndOperator {
  Prefix?: string | null;
  Tags: Tag[];
}
function IntelligentTieringAndOperator_Serialize(data: IntelligentTieringAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function IntelligentTieringAndOperator_Parse(node: xmlP.XmlNode): IntelligentTieringAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

// refs: 3 - tags: input, named, enum, output
export type IntelligentTieringStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Tiering {
  Days: number;
  AccessTier: IntelligentTieringAccessTier;
}
function Tiering_Serialize(data: Tiering | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Days", content: data["Days"]?.toString()},
    {name: "AccessTier", content: data["AccessTier"]?.toString()},
  ]};
}
function Tiering_Parse(node: xmlP.XmlNode): Tiering {
  return {
    Days: node.first("Days", true, x => parseInt(x.content ?? '0')),
    AccessTier: node.first("AccessTier", true, x => (x.content ?? '') as IntelligentTieringAccessTier),
  };
}

// refs: 3 - tags: input, named, enum, output
export type IntelligentTieringAccessTier =
| "ARCHIVE_ACCESS"
| "DEEP_ARCHIVE_ACCESS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface InventoryConfiguration {
  Destination: InventoryDestination;
  IsEnabled: boolean;
  Filter?: InventoryFilter | null;
  Id: string;
  IncludedObjectVersions: InventoryIncludedObjectVersions;
  OptionalFields: InventoryOptionalField[];
  Schedule: InventorySchedule;
}
function InventoryConfiguration_Serialize(data: InventoryConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Destination", ...InventoryDestination_Serialize(data["Destination"])},
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "Filter", ...InventoryFilter_Serialize(data["Filter"])},
    {name: "Id", content: data["Id"]?.toString()},
    {name: "IncludedObjectVersions", content: data["IncludedObjectVersions"]?.toString()},
    {name: "OptionalFields", children: data["OptionalFields"]?.map(x => ({name: "Field", content: x}))},
    {name: "Schedule", ...InventorySchedule_Serialize(data["Schedule"])},
  ]};
}
function InventoryConfiguration_Parse(node: xmlP.XmlNode): InventoryConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Destination: node.first("Destination", true, InventoryDestination_Parse),
    IsEnabled: node.first("IsEnabled", true, x => x.content === 'true'),
    Filter: node.first("Filter", false, InventoryFilter_Parse),
    IncludedObjectVersions: node.first("IncludedObjectVersions", true, x => (x.content ?? '') as InventoryIncludedObjectVersions),
    OptionalFields: node.getList("OptionalFields", "Field").map(x => (x.content ?? '') as InventoryOptionalField),
    Schedule: node.first("Schedule", true, InventorySchedule_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface InventoryDestination {
  S3BucketDestination: InventoryS3BucketDestination;
}
function InventoryDestination_Serialize(data: InventoryDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...InventoryS3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function InventoryDestination_Parse(node: xmlP.XmlNode): InventoryDestination {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, InventoryS3BucketDestination_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface InventoryS3BucketDestination {
  AccountId?: string | null;
  Bucket: string;
  Format: InventoryFormat;
  Prefix?: string | null;
  Encryption?: InventoryEncryption | null;
}
function InventoryS3BucketDestination_Serialize(data: InventoryS3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccountId", content: data["AccountId"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...InventoryEncryption_Serialize(data["Encryption"])},
  ]};
}
function InventoryS3BucketDestination_Parse(node: xmlP.XmlNode): InventoryS3BucketDestination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"AccountId":true,"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as InventoryFormat),
    Encryption: node.first("Encryption", false, InventoryEncryption_Parse),
  };
}

// refs: 3 - tags: input, named, enum, output
export type InventoryFormat =
| "CSV"
| "ORC"
| "Parquet"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface InventoryEncryption {
  SSES3?: SSES3 | null;
  SSEKMS?: SSEKMS | null;
}
function InventoryEncryption_Serialize(data: InventoryEncryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSE-S3", ...SSES3_Serialize(data["SSES3"])},
    {name: "SSE-KMS", ...SSEKMS_Serialize(data["SSEKMS"])},
  ]};
}
function InventoryEncryption_Parse(node: xmlP.XmlNode): InventoryEncryption {
  return {
    SSES3: node.first("SSE-S3", false, SSES3_Parse),
    SSEKMS: node.first("SSE-KMS", false, SSEKMS_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface SSES3 {
}
function SSES3_Serialize(data: SSES3 | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}
function SSES3_Parse(node: xmlP.XmlNode): SSES3 {
  return {};
}

// refs: 3 - tags: input, named, interface, output
export interface SSEKMS {
  KeyId: string;
}
function SSEKMS_Serialize(data: SSEKMS | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "KeyId", content: data["KeyId"]?.toString()},
  ]};
}
function SSEKMS_Parse(node: xmlP.XmlNode): SSEKMS {
  return node.strings({
    required: {"KeyId":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface InventoryFilter {
  Prefix: string;
}
function InventoryFilter_Serialize(data: InventoryFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function InventoryFilter_Parse(node: xmlP.XmlNode): InventoryFilter {
  return node.strings({
    required: {"Prefix":true},
  });
}

// refs: 3 - tags: input, named, enum, output
export type InventoryIncludedObjectVersions =
| "All"
| "Current"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type InventoryOptionalField =
| "Size"
| "LastModifiedDate"
| "StorageClass"
| "ETag"
| "IsMultipartUploaded"
| "ReplicationStatus"
| "EncryptionStatus"
| "ObjectLockRetainUntilDate"
| "ObjectLockMode"
| "ObjectLockLegalHoldStatus"
| "IntelligentTieringAccessTier"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface InventorySchedule {
  Frequency: InventoryFrequency;
}
function InventorySchedule_Serialize(data: InventorySchedule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Frequency", content: data["Frequency"]?.toString()},
  ]};
}
function InventorySchedule_Parse(node: xmlP.XmlNode): InventorySchedule {
  return {
    Frequency: node.first("Frequency", true, x => (x.content ?? '') as InventoryFrequency),
  };
}

// refs: 3 - tags: input, named, enum, output
export type InventoryFrequency =
| "Daily"
| "Weekly"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LifecycleConfiguration {
  Rules: Rule[];
}
function LifecycleConfiguration_Serialize(data: LifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...Rule_Serialize(x)})) ?? []),
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface Rule {
  Expiration?: LifecycleExpiration | null;
  ID?: string | null;
  Prefix: string;
  Status: ExpirationStatus;
  Transition?: Transition | null;
  NoncurrentVersionTransition?: NoncurrentVersionTransition | null;
  NoncurrentVersionExpiration?: NoncurrentVersionExpiration | null;
  AbortIncompleteMultipartUpload?: AbortIncompleteMultipartUpload | null;
}
function Rule_Serialize(data: Rule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Transition", ...Transition_Serialize(data["Transition"])},
    {name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(data["NoncurrentVersionTransition"])},
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function Rule_Parse(node: xmlP.XmlNode): Rule {
  return {
    ...node.strings({
      required: {"Prefix":true},
      optional: {"ID":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as ExpirationStatus),
    Transition: node.first("Transition", false, Transition_Parse),
    NoncurrentVersionTransition: node.first("NoncurrentVersionTransition", false, NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface LifecycleExpiration {
  Date?: Date | number | null;
  Days?: number | null;
  ExpiredObjectDeleteMarker?: boolean | null;
}
function LifecycleExpiration_Serialize(data: LifecycleExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "ExpiredObjectDeleteMarker", content: data["ExpiredObjectDeleteMarker"]?.toString()},
  ]};
}
function LifecycleExpiration_Parse(node: xmlP.XmlNode): LifecycleExpiration {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    ExpiredObjectDeleteMarker: node.first("ExpiredObjectDeleteMarker", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, enum, output
export type ExpirationStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Transition {
  Date?: Date | number | null;
  Days?: number | null;
  StorageClass?: TransitionStorageClass | null;
}
function Transition_Serialize(data: Transition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function Transition_Parse(node: xmlP.XmlNode): Transition {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as TransitionStorageClass),
  };
}

// refs: 8 - tags: input, named, enum, output
export type TransitionStorageClass =
| "GLACIER"
| "STANDARD_IA"
| "ONEZONE_IA"
| "INTELLIGENT_TIERING"
| "DEEP_ARCHIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface NoncurrentVersionTransition {
  NoncurrentDays?: number | null;
  StorageClass?: TransitionStorageClass | null;
}
function NoncurrentVersionTransition_Serialize(data: NoncurrentVersionTransition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function NoncurrentVersionTransition_Parse(node: xmlP.XmlNode): NoncurrentVersionTransition {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as TransitionStorageClass),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface NoncurrentVersionExpiration {
  NoncurrentDays?: number | null;
}
function NoncurrentVersionExpiration_Serialize(data: NoncurrentVersionExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
  ]};
}
function NoncurrentVersionExpiration_Parse(node: xmlP.XmlNode): NoncurrentVersionExpiration {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface AbortIncompleteMultipartUpload {
  DaysAfterInitiation?: number | null;
}
function AbortIncompleteMultipartUpload_Serialize(data: AbortIncompleteMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DaysAfterInitiation", content: data["DaysAfterInitiation"]?.toString()},
  ]};
}
function AbortIncompleteMultipartUpload_Parse(node: xmlP.XmlNode): AbortIncompleteMultipartUpload {
  return {
    DaysAfterInitiation: node.first("DaysAfterInitiation", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: input, named, interface
export interface BucketLifecycleConfiguration {
  Rules: LifecycleRule[];
}
function BucketLifecycleConfiguration_Serialize(data: BucketLifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)})) ?? []),
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRule {
  Expiration?: LifecycleExpiration | null;
  ID?: string | null;
  Prefix?: string | null;
  Filter?: LifecycleRuleFilter | null;
  Status: ExpirationStatus;
  Transitions: Transition[];
  NoncurrentVersionTransitions: NoncurrentVersionTransition[];
  NoncurrentVersionExpiration?: NoncurrentVersionExpiration | null;
  AbortIncompleteMultipartUpload?: AbortIncompleteMultipartUpload | null;
}
function LifecycleRule_Serialize(data: LifecycleRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Filter", ...LifecycleRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    ...(data["Transitions"]?.map(x => ({name: "Transition", ...Transition_Serialize(x)})) ?? []),
    ...(data["NoncurrentVersionTransitions"]?.map(x => ({name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(x)})) ?? []),
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function LifecycleRule_Parse(node: xmlP.XmlNode): LifecycleRule {
  return {
    ...node.strings({
      optional: {"ID":true,"Prefix":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Filter: node.first("Filter", false, LifecycleRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as ExpirationStatus),
    Transitions: node.getList("Transition").map(Transition_Parse),
    NoncurrentVersionTransitions: node.getList("NoncurrentVersionTransition").map(NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRuleFilter {
  Prefix?: string | null;
  Tag?: Tag | null;
  And?: LifecycleRuleAndOperator | null;
}
function LifecycleRuleFilter_Serialize(data: LifecycleRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...LifecycleRuleAndOperator_Serialize(data["And"])},
  ]};
}
function LifecycleRuleFilter_Parse(node: xmlP.XmlNode): LifecycleRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, LifecycleRuleAndOperator_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRuleAndOperator {
  Prefix?: string | null;
  Tags: Tag[];
}
function LifecycleRuleAndOperator_Serialize(data: LifecycleRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function LifecycleRuleAndOperator_Parse(node: xmlP.XmlNode): LifecycleRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

// refs: 1 - tags: input, named, interface
export interface BucketLoggingStatus {
  LoggingEnabled?: LoggingEnabled | null;
}
function BucketLoggingStatus_Serialize(data: BucketLoggingStatus | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LoggingEnabled", ...LoggingEnabled_Serialize(data["LoggingEnabled"])},
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface LoggingEnabled {
  TargetBucket: string;
  TargetGrants: TargetGrant[];
  TargetPrefix: string;
}
function LoggingEnabled_Serialize(data: LoggingEnabled | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetBucket", content: data["TargetBucket"]?.toString()},
    {name: "TargetGrants", children: data["TargetGrants"]?.map(x => ({name: "Grant", ...TargetGrant_Serialize(x)}))},
    {name: "TargetPrefix", content: data["TargetPrefix"]?.toString()},
  ]};
}
function LoggingEnabled_Parse(node: xmlP.XmlNode): LoggingEnabled {
  return {
    ...node.strings({
      required: {"TargetBucket":true,"TargetPrefix":true},
    }),
    TargetGrants: node.getList("TargetGrants", "Grant").map(TargetGrant_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TargetGrant {
  Grantee?: Grantee | null;
  Permission?: BucketLogsPermission | null;
}
function TargetGrant_Serialize(data: TargetGrant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function TargetGrant_Parse(node: xmlP.XmlNode): TargetGrant {
  return {
    Grantee: node.first("Grantee", false, Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as BucketLogsPermission),
  };
}

// refs: 2 - tags: input, named, enum, output
export type BucketLogsPermission =
| "FULL_CONTROL"
| "READ"
| "WRITE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface MetricsConfiguration {
  Id: string;
  Filter?: MetricsFilter | null;
}
function MetricsConfiguration_Serialize(data: MetricsConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...MetricsFilter_Serialize(data["Filter"])},
  ]};
}
function MetricsConfiguration_Parse(node: xmlP.XmlNode): MetricsConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, MetricsFilter_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface MetricsFilter {
  Prefix?: string | null;
  Tag?: Tag | null;
  And?: MetricsAndOperator | null;
}
function MetricsFilter_Serialize(data: MetricsFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...MetricsAndOperator_Serialize(data["And"])},
  ]};
}
function MetricsFilter_Parse(node: xmlP.XmlNode): MetricsFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, MetricsAndOperator_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface MetricsAndOperator {
  Prefix?: string | null;
  Tags: Tag[];
}
function MetricsAndOperator_Serialize(data: MetricsAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function MetricsAndOperator_Parse(node: xmlP.XmlNode): MetricsAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TopicConfigurationDeprecated {
  Id?: string | null;
  Events: Event[];
  Event?: Event | null;
  Topic?: string | null;
}
function TopicConfigurationDeprecated_Serialize(data: TopicConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Event", content: data["Event"]?.toString()},
    {name: "Topic", content: data["Topic"]?.toString()},
  ]};
}
function TopicConfigurationDeprecated_Parse(node: xmlP.XmlNode): TopicConfigurationDeprecated {
  return {
    ...node.strings({
      optional: {"Id":true,"Topic":true},
    }),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
    Event: node.first("Event", false, x => (x.content ?? '') as Event),
  };
}

// refs: 18 - tags: input, named, enum, output
export type Event =
| "s3:ReducedRedundancyLostObject"
| "s3:ObjectCreated:*"
| "s3:ObjectCreated:Put"
| "s3:ObjectCreated:Post"
| "s3:ObjectCreated:Copy"
| "s3:ObjectCreated:CompleteMultipartUpload"
| "s3:ObjectRemoved:*"
| "s3:ObjectRemoved:Delete"
| "s3:ObjectRemoved:DeleteMarkerCreated"
| "s3:ObjectRestore:*"
| "s3:ObjectRestore:Post"
| "s3:ObjectRestore:Completed"
| "s3:Replication:*"
| "s3:Replication:OperationFailedReplication"
| "s3:Replication:OperationNotTracked"
| "s3:Replication:OperationMissedThreshold"
| "s3:Replication:OperationReplicatedAfterThreshold"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface QueueConfigurationDeprecated {
  Id?: string | null;
  Event?: Event | null;
  Events: Event[];
  Queue?: string | null;
}
function QueueConfigurationDeprecated_Serialize(data: QueueConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Event", content: data["Event"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Queue", content: data["Queue"]?.toString()},
  ]};
}
function QueueConfigurationDeprecated_Parse(node: xmlP.XmlNode): QueueConfigurationDeprecated {
  return {
    ...node.strings({
      optional: {"Id":true,"Queue":true},
    }),
    Event: node.first("Event", false, x => (x.content ?? '') as Event),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface CloudFunctionConfiguration {
  Id?: string | null;
  Event?: Event | null;
  Events: Event[];
  CloudFunction?: string | null;
  InvocationRole?: string | null;
}
function CloudFunctionConfiguration_Serialize(data: CloudFunctionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Event", content: data["Event"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "CloudFunction", content: data["CloudFunction"]?.toString()},
    {name: "InvocationRole", content: data["InvocationRole"]?.toString()},
  ]};
}
function CloudFunctionConfiguration_Parse(node: xmlP.XmlNode): CloudFunctionConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true,"CloudFunction":true,"InvocationRole":true},
    }),
    Event: node.first("Event", false, x => (x.content ?? '') as Event),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TopicConfiguration {
  Id?: string | null;
  TopicArn: string;
  Events: Event[];
  Filter?: NotificationConfigurationFilter | null;
}
function TopicConfiguration_Serialize(data: TopicConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Topic", content: data["TopicArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function TopicConfiguration_Parse(node: xmlP.XmlNode): TopicConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    TopicArn: node.first("Topic", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface NotificationConfigurationFilter {
  Key?: S3KeyFilter | null;
}
function NotificationConfigurationFilter_Serialize(data: NotificationConfigurationFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3Key", ...S3KeyFilter_Serialize(data["Key"])},
  ]};
}
function NotificationConfigurationFilter_Parse(node: xmlP.XmlNode): NotificationConfigurationFilter {
  return {
    Key: node.first("S3Key", false, S3KeyFilter_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface S3KeyFilter {
  FilterRules: FilterRule[];
}
function S3KeyFilter_Serialize(data: S3KeyFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["FilterRules"]?.map(x => ({name: "FilterRule", ...FilterRule_Serialize(x)})) ?? []),
  ]};
}
function S3KeyFilter_Parse(node: xmlP.XmlNode): S3KeyFilter {
  return {
    FilterRules: node.getList("FilterRule").map(FilterRule_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface FilterRule {
  Name?: FilterRuleName | null;
  Value?: string | null;
}
function FilterRule_Serialize(data: FilterRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function FilterRule_Parse(node: xmlP.XmlNode): FilterRule {
  return {
    ...node.strings({
      optional: {"Value":true},
    }),
    Name: node.first("Name", false, x => (x.content ?? '') as FilterRuleName),
  };
}

// refs: 6 - tags: input, named, enum, output
export type FilterRuleName =
| "prefix"
| "suffix"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface QueueConfiguration {
  Id?: string | null;
  QueueArn: string;
  Events: Event[];
  Filter?: NotificationConfigurationFilter | null;
}
function QueueConfiguration_Serialize(data: QueueConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Queue", content: data["QueueArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function QueueConfiguration_Parse(node: xmlP.XmlNode): QueueConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    QueueArn: node.first("Queue", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LambdaFunctionConfiguration {
  Id?: string | null;
  LambdaFunctionArn: string;
  Events: Event[];
  Filter?: NotificationConfigurationFilter | null;
}
function LambdaFunctionConfiguration_Serialize(data: LambdaFunctionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "CloudFunction", content: data["LambdaFunctionArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function LambdaFunctionConfiguration_Parse(node: xmlP.XmlNode): LambdaFunctionConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    LambdaFunctionArn: node.first("CloudFunction", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface OwnershipControls {
  Rules: OwnershipControlsRule[];
}
function OwnershipControls_Serialize(data: OwnershipControls | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...OwnershipControlsRule_Serialize(x)})) ?? []),
  ]};
}
function OwnershipControls_Parse(node: xmlP.XmlNode): OwnershipControls {
  return {
    Rules: node.getList("Rule").map(OwnershipControlsRule_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface OwnershipControlsRule {
  ObjectOwnership: ObjectOwnership;
}
function OwnershipControlsRule_Serialize(data: OwnershipControlsRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectOwnership", content: data["ObjectOwnership"]?.toString()},
  ]};
}
function OwnershipControlsRule_Parse(node: xmlP.XmlNode): OwnershipControlsRule {
  return {
    ObjectOwnership: node.first("ObjectOwnership", true, x => (x.content ?? '') as ObjectOwnership),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ObjectOwnership =
| "BucketOwnerPreferred"
| "ObjectWriter"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ReplicationConfiguration {
  Role: string;
  Rules: ReplicationRule[];
}
function ReplicationConfiguration_Serialize(data: ReplicationConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Role", content: data["Role"]?.toString()},
    ...(data["Rules"]?.map(x => ({name: "Rule", ...ReplicationRule_Serialize(x)})) ?? []),
  ]};
}
function ReplicationConfiguration_Parse(node: xmlP.XmlNode): ReplicationConfiguration {
  return {
    ...node.strings({
      required: {"Role":true},
    }),
    Rules: node.getList("Rule").map(ReplicationRule_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ReplicationRule {
  ID?: string | null;
  Priority?: number | null;
  Prefix?: string | null;
  Filter?: ReplicationRuleFilter | null;
  Status: ReplicationRuleStatus;
  SourceSelectionCriteria?: SourceSelectionCriteria | null;
  ExistingObjectReplication?: ExistingObjectReplication | null;
  Destination: Destination;
  DeleteMarkerReplication?: DeleteMarkerReplication | null;
}
function ReplicationRule_Serialize(data: ReplicationRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Priority", content: data["Priority"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Filter", ...ReplicationRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "SourceSelectionCriteria", ...SourceSelectionCriteria_Serialize(data["SourceSelectionCriteria"])},
    {name: "ExistingObjectReplication", ...ExistingObjectReplication_Serialize(data["ExistingObjectReplication"])},
    {name: "Destination", ...Destination_Serialize(data["Destination"])},
    {name: "DeleteMarkerReplication", ...DeleteMarkerReplication_Serialize(data["DeleteMarkerReplication"])},
  ]};
}
function ReplicationRule_Parse(node: xmlP.XmlNode): ReplicationRule {
  return {
    ...node.strings({
      optional: {"ID":true,"Prefix":true},
    }),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    Filter: node.first("Filter", false, ReplicationRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as ReplicationRuleStatus),
    SourceSelectionCriteria: node.first("SourceSelectionCriteria", false, SourceSelectionCriteria_Parse),
    ExistingObjectReplication: node.first("ExistingObjectReplication", false, ExistingObjectReplication_Parse),
    Destination: node.first("Destination", true, Destination_Parse),
    DeleteMarkerReplication: node.first("DeleteMarkerReplication", false, DeleteMarkerReplication_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ReplicationRuleFilter {
  Prefix?: string | null;
  Tag?: Tag | null;
  And?: ReplicationRuleAndOperator | null;
}
function ReplicationRuleFilter_Serialize(data: ReplicationRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...ReplicationRuleAndOperator_Serialize(data["And"])},
  ]};
}
function ReplicationRuleFilter_Parse(node: xmlP.XmlNode): ReplicationRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, ReplicationRuleAndOperator_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ReplicationRuleAndOperator {
  Prefix?: string | null;
  Tags: Tag[];
}
function ReplicationRuleAndOperator_Serialize(data: ReplicationRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function ReplicationRuleAndOperator_Parse(node: xmlP.XmlNode): ReplicationRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ReplicationRuleStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface SourceSelectionCriteria {
  SseKmsEncryptedObjects?: SseKmsEncryptedObjects | null;
  ReplicaModifications?: ReplicaModifications | null;
}
function SourceSelectionCriteria_Serialize(data: SourceSelectionCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SseKmsEncryptedObjects", ...SseKmsEncryptedObjects_Serialize(data["SseKmsEncryptedObjects"])},
    {name: "ReplicaModifications", ...ReplicaModifications_Serialize(data["ReplicaModifications"])},
  ]};
}
function SourceSelectionCriteria_Parse(node: xmlP.XmlNode): SourceSelectionCriteria {
  return {
    SseKmsEncryptedObjects: node.first("SseKmsEncryptedObjects", false, SseKmsEncryptedObjects_Parse),
    ReplicaModifications: node.first("ReplicaModifications", false, ReplicaModifications_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface SseKmsEncryptedObjects {
  Status: SseKmsEncryptedObjectsStatus;
}
function SseKmsEncryptedObjects_Serialize(data: SseKmsEncryptedObjects | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function SseKmsEncryptedObjects_Parse(node: xmlP.XmlNode): SseKmsEncryptedObjects {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as SseKmsEncryptedObjectsStatus),
  };
}

// refs: 2 - tags: input, named, enum, output
export type SseKmsEncryptedObjectsStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ReplicaModifications {
  Status: ReplicaModificationsStatus;
}
function ReplicaModifications_Serialize(data: ReplicaModifications | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ReplicaModifications_Parse(node: xmlP.XmlNode): ReplicaModifications {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as ReplicaModificationsStatus),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ReplicaModificationsStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ExistingObjectReplication {
  Status: ExistingObjectReplicationStatus;
}
function ExistingObjectReplication_Serialize(data: ExistingObjectReplication | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ExistingObjectReplication_Parse(node: xmlP.XmlNode): ExistingObjectReplication {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as ExistingObjectReplicationStatus),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ExistingObjectReplicationStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Destination {
  Bucket: string;
  Account?: string | null;
  StorageClass?: StorageClass | null;
  AccessControlTranslation?: AccessControlTranslation | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
  ReplicationTime?: ReplicationTime | null;
  Metrics?: Metrics | null;
}
function Destination_Serialize(data: Destination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Account", content: data["Account"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
    {name: "AccessControlTranslation", ...AccessControlTranslation_Serialize(data["AccessControlTranslation"])},
    {name: "EncryptionConfiguration", ...EncryptionConfiguration_Serialize(data["EncryptionConfiguration"])},
    {name: "ReplicationTime", ...ReplicationTime_Serialize(data["ReplicationTime"])},
    {name: "Metrics", ...Metrics_Serialize(data["Metrics"])},
  ]};
}
function Destination_Parse(node: xmlP.XmlNode): Destination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"Account":true},
    }),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as StorageClass),
    AccessControlTranslation: node.first("AccessControlTranslation", false, AccessControlTranslation_Parse),
    EncryptionConfiguration: node.first("EncryptionConfiguration", false, EncryptionConfiguration_Parse),
    ReplicationTime: node.first("ReplicationTime", false, ReplicationTime_Parse),
    Metrics: node.first("Metrics", false, Metrics_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface AccessControlTranslation {
  Owner: OwnerOverride;
}
function AccessControlTranslation_Serialize(data: AccessControlTranslation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Owner", content: data["Owner"]?.toString()},
  ]};
}
function AccessControlTranslation_Parse(node: xmlP.XmlNode): AccessControlTranslation {
  return {
    Owner: node.first("Owner", true, x => (x.content ?? '') as OwnerOverride),
  };
}

// refs: 2 - tags: input, named, enum, output
export type OwnerOverride =
| "Destination"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface EncryptionConfiguration {
  ReplicaKmsKeyID?: string | null;
}
function EncryptionConfiguration_Serialize(data: EncryptionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ReplicaKmsKeyID", content: data["ReplicaKmsKeyID"]?.toString()},
  ]};
}
function EncryptionConfiguration_Parse(node: xmlP.XmlNode): EncryptionConfiguration {
  return node.strings({
    optional: {"ReplicaKmsKeyID":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface ReplicationTime {
  Status: ReplicationTimeStatus;
  Time: ReplicationTimeValue;
}
function ReplicationTime_Serialize(data: ReplicationTime | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Time", ...ReplicationTimeValue_Serialize(data["Time"])},
  ]};
}
function ReplicationTime_Parse(node: xmlP.XmlNode): ReplicationTime {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as ReplicationTimeStatus),
    Time: node.first("Time", true, ReplicationTimeValue_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ReplicationTimeStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ReplicationTimeValue {
  Minutes?: number | null;
}
function ReplicationTimeValue_Serialize(data: ReplicationTimeValue | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Minutes", content: data["Minutes"]?.toString()},
  ]};
}
function ReplicationTimeValue_Parse(node: xmlP.XmlNode): ReplicationTimeValue {
  return {
    Minutes: node.first("Minutes", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Metrics {
  Status: MetricsStatus;
  EventThreshold?: ReplicationTimeValue | null;
}
function Metrics_Serialize(data: Metrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
    {name: "EventThreshold", ...ReplicationTimeValue_Serialize(data["EventThreshold"])},
  ]};
}
function Metrics_Parse(node: xmlP.XmlNode): Metrics {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as MetricsStatus),
    EventThreshold: node.first("EventThreshold", false, ReplicationTimeValue_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type MetricsStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface DeleteMarkerReplication {
  Status?: DeleteMarkerReplicationStatus | null;
}
function DeleteMarkerReplication_Serialize(data: DeleteMarkerReplication | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function DeleteMarkerReplication_Parse(node: xmlP.XmlNode): DeleteMarkerReplication {
  return {
    Status: node.first("Status", false, x => (x.content ?? '') as DeleteMarkerReplicationStatus),
  };
}

// refs: 2 - tags: input, named, enum, output
export type DeleteMarkerReplicationStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RequestPaymentConfiguration {
  Payer: Payer;
}
function RequestPaymentConfiguration_Serialize(data: RequestPaymentConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Payer", content: data["Payer"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum, output
export type Payer =
| "Requester"
| "BucketOwner"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface Tagging {
  TagSet: Tag[];
}
function Tagging_Serialize(data: Tagging | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface VersioningConfiguration {
  MFADelete?: MFADelete | null;
  Status?: BucketVersioningStatus | null;
}
function VersioningConfiguration_Serialize(data: VersioningConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "MfaDelete", content: data["MFADelete"]?.toString()},
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, enum
export type MFADelete =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type BucketVersioningStatus =
| "Enabled"
| "Suspended"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface WebsiteConfiguration {
  ErrorDocument?: ErrorDocument | null;
  IndexDocument?: IndexDocument | null;
  RedirectAllRequestsTo?: RedirectAllRequestsTo | null;
  RoutingRules?: RoutingRule[] | null;
}
function WebsiteConfiguration_Serialize(data: WebsiteConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorDocument", ...ErrorDocument_Serialize(data["ErrorDocument"])},
    {name: "IndexDocument", ...IndexDocument_Serialize(data["IndexDocument"])},
    {name: "RedirectAllRequestsTo", ...RedirectAllRequestsTo_Serialize(data["RedirectAllRequestsTo"])},
    {name: "RoutingRules", children: data["RoutingRules"]?.map(x => ({name: "RoutingRule", ...RoutingRule_Serialize(x)}))},
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface ErrorDocument {
  Key: string;
}
function ErrorDocument_Serialize(data: ErrorDocument | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
  ]};
}
function ErrorDocument_Parse(node: xmlP.XmlNode): ErrorDocument {
  return node.strings({
    required: {"Key":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface IndexDocument {
  Suffix: string;
}
function IndexDocument_Serialize(data: IndexDocument | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Suffix", content: data["Suffix"]?.toString()},
  ]};
}
function IndexDocument_Parse(node: xmlP.XmlNode): IndexDocument {
  return node.strings({
    required: {"Suffix":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface RedirectAllRequestsTo {
  HostName: string;
  Protocol?: Protocol | null;
}
function RedirectAllRequestsTo_Serialize(data: RedirectAllRequestsTo | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostName", content: data["HostName"]?.toString()},
    {name: "Protocol", content: data["Protocol"]?.toString()},
  ]};
}
function RedirectAllRequestsTo_Parse(node: xmlP.XmlNode): RedirectAllRequestsTo {
  return {
    ...node.strings({
      required: {"HostName":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as Protocol),
  };
}

// refs: 4 - tags: input, named, enum, output
export type Protocol =
| "http"
| "https"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface RoutingRule {
  Condition?: Condition | null;
  Redirect: Redirect;
}
function RoutingRule_Serialize(data: RoutingRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Condition", ...Condition_Serialize(data["Condition"])},
    {name: "Redirect", ...Redirect_Serialize(data["Redirect"])},
  ]};
}
function RoutingRule_Parse(node: xmlP.XmlNode): RoutingRule {
  return {
    Condition: node.first("Condition", false, Condition_Parse),
    Redirect: node.first("Redirect", true, Redirect_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Condition {
  HttpErrorCodeReturnedEquals?: string | null;
  KeyPrefixEquals?: string | null;
}
function Condition_Serialize(data: Condition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HttpErrorCodeReturnedEquals", content: data["HttpErrorCodeReturnedEquals"]?.toString()},
    {name: "KeyPrefixEquals", content: data["KeyPrefixEquals"]?.toString()},
  ]};
}
function Condition_Parse(node: xmlP.XmlNode): Condition {
  return node.strings({
    optional: {"HttpErrorCodeReturnedEquals":true,"KeyPrefixEquals":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface Redirect {
  HostName?: string | null;
  HttpRedirectCode?: string | null;
  Protocol?: Protocol | null;
  ReplaceKeyPrefixWith?: string | null;
  ReplaceKeyWith?: string | null;
}
function Redirect_Serialize(data: Redirect | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostName", content: data["HostName"]?.toString()},
    {name: "HttpRedirectCode", content: data["HttpRedirectCode"]?.toString()},
    {name: "Protocol", content: data["Protocol"]?.toString()},
    {name: "ReplaceKeyPrefixWith", content: data["ReplaceKeyPrefixWith"]?.toString()},
    {name: "ReplaceKeyWith", content: data["ReplaceKeyWith"]?.toString()},
  ]};
}
function Redirect_Parse(node: xmlP.XmlNode): Redirect {
  return {
    ...node.strings({
      optional: {"HostName":true,"HttpRedirectCode":true,"ReplaceKeyPrefixWith":true,"ReplaceKeyWith":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as Protocol),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ObjectLockLegalHold {
  Status?: ObjectLockLegalHoldStatus | null;
}
function ObjectLockLegalHold_Serialize(data: ObjectLockLegalHold | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ObjectLockLegalHold_Parse(node: xmlP.XmlNode): ObjectLockLegalHold {
  return {
    Status: node.first("Status", false, x => (x.content ?? '') as ObjectLockLegalHoldStatus),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ObjectLockConfiguration {
  ObjectLockEnabled?: ObjectLockEnabled | null;
  Rule?: ObjectLockRule | null;
}
function ObjectLockConfiguration_Serialize(data: ObjectLockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectLockEnabled", content: data["ObjectLockEnabled"]?.toString()},
    {name: "Rule", ...ObjectLockRule_Serialize(data["Rule"])},
  ]};
}
function ObjectLockConfiguration_Parse(node: xmlP.XmlNode): ObjectLockConfiguration {
  return {
    ObjectLockEnabled: node.first("ObjectLockEnabled", false, x => (x.content ?? '') as ObjectLockEnabled),
    Rule: node.first("Rule", false, ObjectLockRule_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ObjectLockEnabled =
| "Enabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ObjectLockRule {
  DefaultRetention?: DefaultRetention | null;
}
function ObjectLockRule_Serialize(data: ObjectLockRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DefaultRetention", ...DefaultRetention_Serialize(data["DefaultRetention"])},
  ]};
}
function ObjectLockRule_Parse(node: xmlP.XmlNode): ObjectLockRule {
  return {
    DefaultRetention: node.first("DefaultRetention", false, DefaultRetention_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface DefaultRetention {
  Mode?: ObjectLockRetentionMode | null;
  Days?: number | null;
  Years?: number | null;
}
function DefaultRetention_Serialize(data: DefaultRetention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Mode", content: data["Mode"]?.toString()},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "Years", content: data["Years"]?.toString()},
  ]};
}
function DefaultRetention_Parse(node: xmlP.XmlNode): DefaultRetention {
  return {
    Mode: node.first("Mode", false, x => (x.content ?? '') as ObjectLockRetentionMode),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    Years: node.first("Years", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, enum, output
export type ObjectLockRetentionMode =
| "GOVERNANCE"
| "COMPLIANCE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ObjectLockRetention {
  Mode?: ObjectLockRetentionMode | null;
  RetainUntilDate?: Date | number | null;
}
function ObjectLockRetention_Serialize(data: ObjectLockRetention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Mode", content: data["Mode"]?.toString()},
    {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(data["RetainUntilDate"])},
  ]};
}
function ObjectLockRetention_Parse(node: xmlP.XmlNode): ObjectLockRetention {
  return {
    Mode: node.first("Mode", false, x => (x.content ?? '') as ObjectLockRetentionMode),
    RetainUntilDate: node.first("RetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface PublicAccessBlockConfiguration {
  BlockPublicAcls?: boolean | null;
  IgnorePublicAcls?: boolean | null;
  BlockPublicPolicy?: boolean | null;
  RestrictPublicBuckets?: boolean | null;
}
function PublicAccessBlockConfiguration_Serialize(data: PublicAccessBlockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BlockPublicAcls", content: data["BlockPublicAcls"]?.toString()},
    {name: "IgnorePublicAcls", content: data["IgnorePublicAcls"]?.toString()},
    {name: "BlockPublicPolicy", content: data["BlockPublicPolicy"]?.toString()},
    {name: "RestrictPublicBuckets", content: data["RestrictPublicBuckets"]?.toString()},
  ]};
}
function PublicAccessBlockConfiguration_Parse(node: xmlP.XmlNode): PublicAccessBlockConfiguration {
  return {
    BlockPublicAcls: node.first("BlockPublicAcls", false, x => x.content === 'true'),
    IgnorePublicAcls: node.first("IgnorePublicAcls", false, x => x.content === 'true'),
    BlockPublicPolicy: node.first("BlockPublicPolicy", false, x => x.content === 'true'),
    RestrictPublicBuckets: node.first("RestrictPublicBuckets", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, interface
export interface RestoreRequest {
  Days?: number | null;
  GlacierJobParameters?: GlacierJobParameters | null;
  Type?: RestoreRequestType | null;
  Tier?: Tier | null;
  Description?: string | null;
  SelectParameters?: SelectParameters | null;
  OutputLocation?: OutputLocation | null;
}
function RestoreRequest_Serialize(data: RestoreRequest | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Days", content: data["Days"]?.toString()},
    {name: "GlacierJobParameters", ...GlacierJobParameters_Serialize(data["GlacierJobParameters"])},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "Tier", content: data["Tier"]?.toString()},
    {name: "Description", content: data["Description"]?.toString()},
    {name: "SelectParameters", ...SelectParameters_Serialize(data["SelectParameters"])},
    {name: "OutputLocation", ...OutputLocation_Serialize(data["OutputLocation"])},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface GlacierJobParameters {
  Tier: Tier;
}
function GlacierJobParameters_Serialize(data: GlacierJobParameters | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Tier", content: data["Tier"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum
export type Tier =
| "Standard"
| "Bulk"
| "Expedited"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type RestoreRequestType =
| "SELECT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SelectParameters {
  InputSerialization: InputSerialization;
  ExpressionType: ExpressionType;
  Expression: string;
  OutputSerialization: OutputSerialization;
}
function SelectParameters_Serialize(data: SelectParameters | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "InputSerialization", ...InputSerialization_Serialize(data["InputSerialization"])},
    {name: "ExpressionType", content: data["ExpressionType"]?.toString()},
    {name: "Expression", content: data["Expression"]?.toString()},
    {name: "OutputSerialization", ...OutputSerialization_Serialize(data["OutputSerialization"])},
  ]};
}

// refs: 2 - tags: input, named, interface
export interface InputSerialization {
  CSV?: CSVInput | null;
  CompressionType?: CompressionType | null;
  JSON?: JSONInput | null;
  Parquet?: ParquetInput | null;
}
function InputSerialization_Serialize(data: InputSerialization | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CSV", ...CSVInput_Serialize(data["CSV"])},
    {name: "CompressionType", content: data["CompressionType"]?.toString()},
    {name: "JSON", ...JSONInput_Serialize(data["JSON"])},
    {name: "Parquet", ...ParquetInput_Serialize(data["Parquet"])},
  ]};
}

// refs: 2 - tags: input, named, interface
export interface CSVInput {
  FileHeaderInfo?: FileHeaderInfo | null;
  Comments?: string | null;
  QuoteEscapeCharacter?: string | null;
  RecordDelimiter?: string | null;
  FieldDelimiter?: string | null;
  QuoteCharacter?: string | null;
  AllowQuotedRecordDelimiter?: boolean | null;
}
function CSVInput_Serialize(data: CSVInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "FileHeaderInfo", content: data["FileHeaderInfo"]?.toString()},
    {name: "Comments", content: data["Comments"]?.toString()},
    {name: "QuoteEscapeCharacter", content: data["QuoteEscapeCharacter"]?.toString()},
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
    {name: "FieldDelimiter", content: data["FieldDelimiter"]?.toString()},
    {name: "QuoteCharacter", content: data["QuoteCharacter"]?.toString()},
    {name: "AllowQuotedRecordDelimiter", content: data["AllowQuotedRecordDelimiter"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum
export type FileHeaderInfo =
| "USE"
| "IGNORE"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type CompressionType =
| "NONE"
| "GZIP"
| "BZIP2"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface JSONInput {
  Type?: JSONType | null;
}
function JSONInput_Serialize(data: JSONInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Type", content: data["Type"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum
export type JSONType =
| "DOCUMENT"
| "LINES"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ParquetInput {
}
function ParquetInput_Serialize(data: ParquetInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}

// refs: 2 - tags: input, named, enum
export type ExpressionType =
| "SQL"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface OutputSerialization {
  CSV?: CSVOutput | null;
  JSON?: JSONOutput | null;
}
function OutputSerialization_Serialize(data: OutputSerialization | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CSV", ...CSVOutput_Serialize(data["CSV"])},
    {name: "JSON", ...JSONOutput_Serialize(data["JSON"])},
  ]};
}

// refs: 2 - tags: input, named, interface
export interface CSVOutput {
  QuoteFields?: QuoteFields | null;
  QuoteEscapeCharacter?: string | null;
  RecordDelimiter?: string | null;
  FieldDelimiter?: string | null;
  QuoteCharacter?: string | null;
}
function CSVOutput_Serialize(data: CSVOutput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QuoteFields", content: data["QuoteFields"]?.toString()},
    {name: "QuoteEscapeCharacter", content: data["QuoteEscapeCharacter"]?.toString()},
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
    {name: "FieldDelimiter", content: data["FieldDelimiter"]?.toString()},
    {name: "QuoteCharacter", content: data["QuoteCharacter"]?.toString()},
  ]};
}

// refs: 2 - tags: input, named, enum
export type QuoteFields =
| "ALWAYS"
| "ASNEEDED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface JSONOutput {
  RecordDelimiter?: string | null;
}
function JSONOutput_Serialize(data: JSONOutput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface OutputLocation {
  S3?: S3Location | null;
}
function OutputLocation_Serialize(data: OutputLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3", ...S3Location_Serialize(data["S3"])},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface S3Location {
  BucketName: string;
  Prefix: string;
  Encryption?: Encryption | null;
  CannedACL?: ObjectCannedACL | null;
  AccessControlList?: Grant[] | null;
  Tagging?: Tagging | null;
  UserMetadata?: MetadataEntry[] | null;
  StorageClass?: StorageClass | null;
}
function S3Location_Serialize(data: S3Location | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BucketName", content: data["BucketName"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...Encryption_Serialize(data["Encryption"])},
    {name: "CannedACL", content: data["CannedACL"]?.toString()},
    {name: "AccessControlList", children: data["AccessControlList"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
    {name: "Tagging", ...Tagging_Serialize(data["Tagging"])},
    {name: "UserMetadata", children: data["UserMetadata"]?.map(x => ({name: "MetadataEntry", ...MetadataEntry_Serialize(x)}))},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface Encryption {
  EncryptionType: ServerSideEncryption;
  KMSKeyId?: string | null;
  KMSContext?: string | null;
}
function Encryption_Serialize(data: Encryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "EncryptionType", content: data["EncryptionType"]?.toString()},
    {name: "KMSKeyId", content: data["KMSKeyId"]?.toString()},
    {name: "KMSContext", content: data["KMSContext"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface MetadataEntry {
  Name?: string | null;
  Value?: string | null;
}
function MetadataEntry_Serialize(data: MetadataEntry | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface RequestProgress {
  Enabled?: boolean | null;
}
function RequestProgress_Serialize(data: RequestProgress | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface ScanRange {
  Start?: number | null;
  End?: number | null;
}
function ScanRange_Serialize(data: ScanRange | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Start", content: data["Start"]?.toString()},
    {name: "End", content: data["End"]?.toString()},
  ]};
}

// refs: 19 - tags: output, named, enum
export type RequestCharged =
| "requester"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CopyObjectResult {
  ETag?: string | null;
  LastModified?: Date | number | null;
}
function CopyObjectResult_Parse(node: xmlP.XmlNode): CopyObjectResult {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface DeletedObject {
  Key?: string | null;
  VersionId?: string | null;
  DeleteMarker?: boolean | null;
  DeleteMarkerVersionId?: string | null;
}
function DeletedObject_Parse(node: xmlP.XmlNode): DeletedObject {
  return {
    ...node.strings({
      optional: {"Key":true,"VersionId":true,"DeleteMarkerVersionId":true},
    }),
    DeleteMarker: node.first("DeleteMarker", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface Error {
  Key?: string | null;
  VersionId?: string | null;
  Code?: string | null;
  Message?: string | null;
}
function Error_Parse(node: xmlP.XmlNode): Error {
  return node.strings({
    optional: {"Key":true,"VersionId":true,"Code":true,"Message":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface PolicyStatus {
  IsPublic?: boolean | null;
}
function PolicyStatus_Parse(node: xmlP.XmlNode): PolicyStatus {
  return {
    IsPublic: node.first("IsPublic", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, enum
export type MFADeleteStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ReplicationStatus =
| "COMPLETE"
| "PENDING"
| "FAILED"
| "REPLICA"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type ArchiveStatus =
| "ARCHIVE_ACCESS"
| "DEEP_ARCHIVE_ACCESS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Bucket {
  Name?: string | null;
  CreationDate?: Date | number | null;
}
function Bucket_Parse(node: xmlP.XmlNode): Bucket {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreationDate: node.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface MultipartUpload {
  UploadId?: string | null;
  Key?: string | null;
  Initiated?: Date | number | null;
  StorageClass?: StorageClass | null;
  Owner?: Owner | null;
  Initiator?: Initiator | null;
}
function MultipartUpload_Parse(node: xmlP.XmlNode): MultipartUpload {
  return {
    ...node.strings({
      optional: {"UploadId":true,"Key":true},
    }),
    Initiated: node.first("Initiated", false, x => xmlP.parseTimestamp(x.content)),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as StorageClass),
    Owner: node.first("Owner", false, Owner_Parse),
    Initiator: node.first("Initiator", false, Initiator_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface Initiator {
  ID?: string | null;
  DisplayName?: string | null;
}
function Initiator_Parse(node: xmlP.XmlNode): Initiator {
  return node.strings({
    optional: {"ID":true,"DisplayName":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface CommonPrefix {
  Prefix?: string | null;
}
function CommonPrefix_Parse(node: xmlP.XmlNode): CommonPrefix {
  return node.strings({
    optional: {"Prefix":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ObjectVersion {
  ETag?: string | null;
  Size?: number | null;
  StorageClass?: ObjectVersionStorageClass | null;
  Key?: string | null;
  VersionId?: string | null;
  IsLatest?: boolean | null;
  LastModified?: Date | number | null;
  Owner?: Owner | null;
}
function ObjectVersion_Parse(node: xmlP.XmlNode): ObjectVersion {
  return {
    ...node.strings({
      optional: {"ETag":true,"Key":true,"VersionId":true},
    }),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as ObjectVersionStorageClass),
    IsLatest: node.first("IsLatest", false, x => x.content === 'true'),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Owner: node.first("Owner", false, Owner_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ObjectVersionStorageClass =
| "STANDARD"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DeleteMarkerEntry {
  Owner?: Owner | null;
  Key?: string | null;
  VersionId?: string | null;
  IsLatest?: boolean | null;
  LastModified?: Date | number | null;
}
function DeleteMarkerEntry_Parse(node: xmlP.XmlNode): DeleteMarkerEntry {
  return {
    ...node.strings({
      optional: {"Key":true,"VersionId":true},
    }),
    Owner: node.first("Owner", false, Owner_Parse),
    IsLatest: node.first("IsLatest", false, x => x.content === 'true'),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface _Object {
  Key?: string | null;
  LastModified?: Date | number | null;
  ETag?: string | null;
  Size?: number | null;
  StorageClass?: ObjectStorageClass | null;
  Owner?: Owner | null;
}
function _Object_Parse(node: xmlP.XmlNode): _Object {
  return {
    ...node.strings({
      optional: {"Key":true,"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as ObjectStorageClass),
    Owner: node.first("Owner", false, Owner_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type ObjectStorageClass =
| "STANDARD"
| "REDUCED_REDUNDANCY"
| "GLACIER"
| "STANDARD_IA"
| "ONEZONE_IA"
| "INTELLIGENT_TIERING"
| "DEEP_ARCHIVE"
| "OUTPOSTS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Part {
  PartNumber?: number | null;
  LastModified?: Date | number | null;
  ETag?: string | null;
  Size?: number | null;
}
function Part_Parse(node: xmlP.XmlNode): Part {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    PartNumber: node.first("PartNumber", false, x => parseInt(x.content ?? '0')),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface SelectObjectContentEventStream {
  Records?: RecordsEvent | null;
  Stats?: StatsEvent | null;
  Progress?: ProgressEvent | null;
  Cont?: ContinuationEvent | null;
  End?: EndEvent | null;
}
function SelectObjectContentEventStream_Parse(node: xmlP.XmlNode): SelectObjectContentEventStream {
  return {
    Records: node.first("Records", false, RecordsEvent_Parse),
    Stats: node.first("Stats", false, StatsEvent_Parse),
    Progress: node.first("Progress", false, ProgressEvent_Parse),
    Cont: node.first("Cont", false, ContinuationEvent_Parse),
    End: node.first("End", false, EndEvent_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface RecordsEvent {
  Payload?: Uint8Array | string | null;
}
function RecordsEvent_Parse(node: xmlP.XmlNode): RecordsEvent {
  return {
    Payload: node.first("Payload", false, x => Base64.toUint8Array(x.content ?? '')),
  };
}

// refs: 1 - tags: output, named, interface
export interface StatsEvent {
  Details?: Stats | null;
}
function StatsEvent_Parse(node: xmlP.XmlNode): StatsEvent {
  return {
    Details: node.first("Details", false, Stats_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface Stats {
  BytesScanned?: number | null;
  BytesProcessed?: number | null;
  BytesReturned?: number | null;
}
function Stats_Parse(node: xmlP.XmlNode): Stats {
  return {
    BytesScanned: node.first("BytesScanned", false, x => parseInt(x.content ?? '0')),
    BytesProcessed: node.first("BytesProcessed", false, x => parseInt(x.content ?? '0')),
    BytesReturned: node.first("BytesReturned", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ProgressEvent {
  Details?: Progress | null;
}
function ProgressEvent_Parse(node: xmlP.XmlNode): ProgressEvent {
  return {
    Details: node.first("Details", false, Progress_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface Progress {
  BytesScanned?: number | null;
  BytesProcessed?: number | null;
  BytesReturned?: number | null;
}
function Progress_Parse(node: xmlP.XmlNode): Progress {
  return {
    BytesScanned: node.first("BytesScanned", false, x => parseInt(x.content ?? '0')),
    BytesProcessed: node.first("BytesProcessed", false, x => parseInt(x.content ?? '0')),
    BytesReturned: node.first("BytesReturned", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ContinuationEvent {
}
function ContinuationEvent_Parse(node: xmlP.XmlNode): ContinuationEvent {
  return {};
}

// refs: 1 - tags: output, named, interface
export interface EndEvent {
}
function EndEvent_Parse(node: xmlP.XmlNode): EndEvent {
  return {};
}

// refs: 1 - tags: output, named, interface
export interface CopyPartResult {
  ETag?: string | null;
  LastModified?: Date | number | null;
}
function CopyPartResult_Parse(node: xmlP.XmlNode): CopyPartResult {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}
