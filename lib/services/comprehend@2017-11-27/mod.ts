// Autogenerated API client for: Amazon Comprehend

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Comprehend {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Comprehend.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-11-27",
    "endpointPrefix": "comprehend",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Comprehend",
    "serviceId": "Comprehend",
    "signatureVersion": "v4",
    "signingName": "comprehend",
    "targetPrefix": "Comprehend_20171127",
    "uid": "comprehend-2017-11-27"
  };

  async batchDetectDominantLanguage(
    {abortSignal, ...params}: RequestConfig & s.BatchDetectDominantLanguageRequest,
  ): Promise<s.BatchDetectDominantLanguageResponse> {
    const body: jsonP.JSONObject = {
      TextList: params["TextList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDetectDominantLanguage",
    });
    return jsonP.readObj({
      required: {
        "ResultList": [toBatchDetectDominantLanguageItemResult],
        "ErrorList": [toBatchItemError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDetectEntities(
    {abortSignal, ...params}: RequestConfig & s.BatchDetectEntitiesRequest,
  ): Promise<s.BatchDetectEntitiesResponse> {
    const body: jsonP.JSONObject = {
      TextList: params["TextList"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDetectEntities",
    });
    return jsonP.readObj({
      required: {
        "ResultList": [toBatchDetectEntitiesItemResult],
        "ErrorList": [toBatchItemError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDetectKeyPhrases(
    {abortSignal, ...params}: RequestConfig & s.BatchDetectKeyPhrasesRequest,
  ): Promise<s.BatchDetectKeyPhrasesResponse> {
    const body: jsonP.JSONObject = {
      TextList: params["TextList"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDetectKeyPhrases",
    });
    return jsonP.readObj({
      required: {
        "ResultList": [toBatchDetectKeyPhrasesItemResult],
        "ErrorList": [toBatchItemError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDetectSentiment(
    {abortSignal, ...params}: RequestConfig & s.BatchDetectSentimentRequest,
  ): Promise<s.BatchDetectSentimentResponse> {
    const body: jsonP.JSONObject = {
      TextList: params["TextList"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDetectSentiment",
    });
    return jsonP.readObj({
      required: {
        "ResultList": [toBatchDetectSentimentItemResult],
        "ErrorList": [toBatchItemError],
      },
      optional: {},
    }, await resp.json());
  }

  async batchDetectSyntax(
    {abortSignal, ...params}: RequestConfig & s.BatchDetectSyntaxRequest,
  ): Promise<s.BatchDetectSyntaxResponse> {
    const body: jsonP.JSONObject = {
      TextList: params["TextList"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDetectSyntax",
    });
    return jsonP.readObj({
      required: {
        "ResultList": [toBatchDetectSyntaxItemResult],
        "ErrorList": [toBatchItemError],
      },
      optional: {},
    }, await resp.json());
  }

  async classifyDocument(
    {abortSignal, ...params}: RequestConfig & s.ClassifyDocumentRequest,
  ): Promise<s.ClassifyDocumentResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ClassifyDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Classes": [toDocumentClass],
        "Labels": [toDocumentLabel],
      },
    }, await resp.json());
  }

  async createDocumentClassifier(
    {abortSignal, ...params}: RequestConfig & s.CreateDocumentClassifierRequest,
  ): Promise<s.CreateDocumentClassifierResponse> {
    const body: jsonP.JSONObject = {
      DocumentClassifierName: params["DocumentClassifierName"],
      DataAccessRoleArn: params["DataAccessRoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      InputDataConfig: fromDocumentClassifierInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromDocumentClassifierOutputDataConfig(params["OutputDataConfig"]),
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      LanguageCode: params["LanguageCode"],
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      Mode: params["Mode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocumentClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentClassifierArn": "s",
      },
    }, await resp.json());
  }

  async createEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateEndpointRequest,
  ): Promise<s.CreateEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      ModelArn: params["ModelArn"],
      DesiredInferenceUnits: params["DesiredInferenceUnits"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EndpointArn": "s",
      },
    }, await resp.json());
  }

  async createEntityRecognizer(
    {abortSignal, ...params}: RequestConfig & s.CreateEntityRecognizerRequest,
  ): Promise<s.CreateEntityRecognizerResponse> {
    const body: jsonP.JSONObject = {
      RecognizerName: params["RecognizerName"],
      DataAccessRoleArn: params["DataAccessRoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      InputDataConfig: fromEntityRecognizerInputDataConfig(params["InputDataConfig"]),
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      LanguageCode: params["LanguageCode"],
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEntityRecognizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntityRecognizerArn": "s",
      },
    }, await resp.json());
  }

  async deleteDocumentClassifier(
    {abortSignal, ...params}: RequestConfig & s.DeleteDocumentClassifierRequest,
  ): Promise<s.DeleteDocumentClassifierResponse> {
    const body: jsonP.JSONObject = {
      DocumentClassifierArn: params["DocumentClassifierArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDocumentClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteEndpointRequest,
  ): Promise<s.DeleteEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEntityRecognizer(
    {abortSignal, ...params}: RequestConfig & s.DeleteEntityRecognizerRequest,
  ): Promise<s.DeleteEntityRecognizerResponse> {
    const body: jsonP.JSONObject = {
      EntityRecognizerArn: params["EntityRecognizerArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEntityRecognizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeDocumentClassificationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeDocumentClassificationJobRequest,
  ): Promise<s.DescribeDocumentClassificationJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDocumentClassificationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentClassificationJobProperties": toDocumentClassificationJobProperties,
      },
    }, await resp.json());
  }

  async describeDocumentClassifier(
    {abortSignal, ...params}: RequestConfig & s.DescribeDocumentClassifierRequest,
  ): Promise<s.DescribeDocumentClassifierResponse> {
    const body: jsonP.JSONObject = {
      DocumentClassifierArn: params["DocumentClassifierArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDocumentClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentClassifierProperties": toDocumentClassifierProperties,
      },
    }, await resp.json());
  }

  async describeDominantLanguageDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeDominantLanguageDetectionJobRequest,
  ): Promise<s.DescribeDominantLanguageDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDominantLanguageDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DominantLanguageDetectionJobProperties": toDominantLanguageDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describeEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointRequest,
  ): Promise<s.DescribeEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EndpointProperties": toEndpointProperties,
      },
    }, await resp.json());
  }

  async describeEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeEntitiesDetectionJobRequest,
  ): Promise<s.DescribeEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntitiesDetectionJobProperties": toEntitiesDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describeEntityRecognizer(
    {abortSignal, ...params}: RequestConfig & s.DescribeEntityRecognizerRequest,
  ): Promise<s.DescribeEntityRecognizerResponse> {
    const body: jsonP.JSONObject = {
      EntityRecognizerArn: params["EntityRecognizerArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEntityRecognizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntityRecognizerProperties": toEntityRecognizerProperties,
      },
    }, await resp.json());
  }

  async describeEventsDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsDetectionJobRequest,
  ): Promise<s.DescribeEventsDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventsDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventsDetectionJobProperties": toEventsDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describeKeyPhrasesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeKeyPhrasesDetectionJobRequest,
  ): Promise<s.DescribeKeyPhrasesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKeyPhrasesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyPhrasesDetectionJobProperties": toKeyPhrasesDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describePiiEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribePiiEntitiesDetectionJobRequest,
  ): Promise<s.DescribePiiEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePiiEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PiiEntitiesDetectionJobProperties": toPiiEntitiesDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describeSentimentDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeSentimentDetectionJobRequest,
  ): Promise<s.DescribeSentimentDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSentimentDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SentimentDetectionJobProperties": toSentimentDetectionJobProperties,
      },
    }, await resp.json());
  }

  async describeTopicsDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeTopicsDetectionJobRequest,
  ): Promise<s.DescribeTopicsDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTopicsDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TopicsDetectionJobProperties": toTopicsDetectionJobProperties,
      },
    }, await resp.json());
  }

  async detectDominantLanguage(
    {abortSignal, ...params}: RequestConfig & s.DetectDominantLanguageRequest,
  ): Promise<s.DetectDominantLanguageResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectDominantLanguage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Languages": [toDominantLanguage],
      },
    }, await resp.json());
  }

  async detectEntities(
    {abortSignal, ...params}: RequestConfig & s.DetectEntitiesRequest,
  ): Promise<s.DetectEntitiesResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      LanguageCode: params["LanguageCode"],
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectEntities",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entities": [toEntity],
      },
    }, await resp.json());
  }

  async detectKeyPhrases(
    {abortSignal, ...params}: RequestConfig & s.DetectKeyPhrasesRequest,
  ): Promise<s.DetectKeyPhrasesResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectKeyPhrases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyPhrases": [toKeyPhrase],
      },
    }, await resp.json());
  }

  async detectPiiEntities(
    {abortSignal, ...params}: RequestConfig & s.DetectPiiEntitiesRequest,
  ): Promise<s.DetectPiiEntitiesResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectPiiEntities",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entities": [toPiiEntity],
      },
    }, await resp.json());
  }

  async detectSentiment(
    {abortSignal, ...params}: RequestConfig & s.DetectSentimentRequest,
  ): Promise<s.DetectSentimentResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectSentiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<s.SentimentType>(x),
        "SentimentScore": toSentimentScore,
      },
    }, await resp.json());
  }

  async detectSyntax(
    {abortSignal, ...params}: RequestConfig & s.DetectSyntaxRequest,
  ): Promise<s.DetectSyntaxResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      LanguageCode: params["LanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectSyntax",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SyntaxTokens": [toSyntaxToken],
      },
    }, await resp.json());
  }

  async listDocumentClassificationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListDocumentClassificationJobsRequest = {},
  ): Promise<s.ListDocumentClassificationJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromDocumentClassificationJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDocumentClassificationJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentClassificationJobPropertiesList": [toDocumentClassificationJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDocumentClassifiers(
    {abortSignal, ...params}: RequestConfig & s.ListDocumentClassifiersRequest = {},
  ): Promise<s.ListDocumentClassifiersResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromDocumentClassifierFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDocumentClassifiers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentClassifierPropertiesList": [toDocumentClassifierProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDominantLanguageDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListDominantLanguageDetectionJobsRequest = {},
  ): Promise<s.ListDominantLanguageDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromDominantLanguageDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDominantLanguageDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DominantLanguageDetectionJobPropertiesList": [toDominantLanguageDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEndpoints(
    {abortSignal, ...params}: RequestConfig & s.ListEndpointsRequest = {},
  ): Promise<s.ListEndpointsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromEndpointFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EndpointPropertiesList": [toEndpointProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEntitiesDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListEntitiesDetectionJobsRequest = {},
  ): Promise<s.ListEntitiesDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromEntitiesDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEntitiesDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntitiesDetectionJobPropertiesList": [toEntitiesDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEntityRecognizers(
    {abortSignal, ...params}: RequestConfig & s.ListEntityRecognizersRequest = {},
  ): Promise<s.ListEntityRecognizersResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromEntityRecognizerFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEntityRecognizers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EntityRecognizerPropertiesList": [toEntityRecognizerProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEventsDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListEventsDetectionJobsRequest = {},
  ): Promise<s.ListEventsDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromEventsDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEventsDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventsDetectionJobPropertiesList": [toEventsDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listKeyPhrasesDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListKeyPhrasesDetectionJobsRequest = {},
  ): Promise<s.ListKeyPhrasesDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromKeyPhrasesDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListKeyPhrasesDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyPhrasesDetectionJobPropertiesList": [toKeyPhrasesDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPiiEntitiesDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListPiiEntitiesDetectionJobsRequest = {},
  ): Promise<s.ListPiiEntitiesDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromPiiEntitiesDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPiiEntitiesDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PiiEntitiesDetectionJobPropertiesList": [toPiiEntitiesDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSentimentDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListSentimentDetectionJobsRequest = {},
  ): Promise<s.ListSentimentDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromSentimentDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSentimentDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SentimentDetectionJobPropertiesList": [toSentimentDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceArn": "s",
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async listTopicsDetectionJobs(
    {abortSignal, ...params}: RequestConfig & s.ListTopicsDetectionJobsRequest = {},
  ): Promise<s.ListTopicsDetectionJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromTopicsDetectionJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTopicsDetectionJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TopicsDetectionJobPropertiesList": [toTopicsDetectionJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startDocumentClassificationJob(
    {abortSignal, ...params}: RequestConfig & s.StartDocumentClassificationJobRequest,
  ): Promise<s.StartDocumentClassificationJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      DocumentClassifierArn: params["DocumentClassifierArn"],
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDocumentClassificationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startDominantLanguageDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartDominantLanguageDetectionJobRequest,
  ): Promise<s.StartDominantLanguageDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDominantLanguageDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartEntitiesDetectionJobRequest,
  ): Promise<s.StartEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      EntityRecognizerArn: params["EntityRecognizerArn"],
      LanguageCode: params["LanguageCode"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startEventsDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartEventsDetectionJobRequest,
  ): Promise<s.StartEventsDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      LanguageCode: params["LanguageCode"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      TargetEventTypes: params["TargetEventTypes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartEventsDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startKeyPhrasesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartKeyPhrasesDetectionJobRequest,
  ): Promise<s.StartKeyPhrasesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      LanguageCode: params["LanguageCode"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartKeyPhrasesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startPiiEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartPiiEntitiesDetectionJobRequest,
  ): Promise<s.StartPiiEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      Mode: params["Mode"],
      RedactionConfig: fromRedactionConfig(params["RedactionConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      LanguageCode: params["LanguageCode"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPiiEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startSentimentDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartSentimentDetectionJobRequest,
  ): Promise<s.StartSentimentDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      LanguageCode: params["LanguageCode"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSentimentDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async startTopicsDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StartTopicsDetectionJobRequest,
  ): Promise<s.StartTopicsDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      JobName: params["JobName"],
      NumberOfTopics: params["NumberOfTopics"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      VolumeKmsKeyId: params["VolumeKmsKeyId"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTopicsDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopDominantLanguageDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopDominantLanguageDetectionJobRequest,
  ): Promise<s.StopDominantLanguageDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDominantLanguageDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopEntitiesDetectionJobRequest,
  ): Promise<s.StopEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopEventsDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopEventsDetectionJobRequest,
  ): Promise<s.StopEventsDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopEventsDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopKeyPhrasesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopKeyPhrasesDetectionJobRequest,
  ): Promise<s.StopKeyPhrasesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopKeyPhrasesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopPiiEntitiesDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopPiiEntitiesDetectionJobRequest,
  ): Promise<s.StopPiiEntitiesDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopPiiEntitiesDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopSentimentDetectionJob(
    {abortSignal, ...params}: RequestConfig & s.StopSentimentDetectionJobRequest,
  ): Promise<s.StopSentimentDetectionJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopSentimentDetectionJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopTrainingDocumentClassifier(
    {abortSignal, ...params}: RequestConfig & s.StopTrainingDocumentClassifierRequest,
  ): Promise<s.StopTrainingDocumentClassifierResponse> {
    const body: jsonP.JSONObject = {
      DocumentClassifierArn: params["DocumentClassifierArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrainingDocumentClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopTrainingEntityRecognizer(
    {abortSignal, ...params}: RequestConfig & s.StopTrainingEntityRecognizerRequest,
  ): Promise<s.StopTrainingEntityRecognizerResponse> {
    const body: jsonP.JSONObject = {
      EntityRecognizerArn: params["EntityRecognizerArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrainingEntityRecognizer",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateEndpoint(
    {abortSignal, ...params}: RequestConfig & s.UpdateEndpointRequest,
  ): Promise<s.UpdateEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
      DesiredInferenceUnits: params["DesiredInferenceUnits"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromDocumentClassifierInputDataConfig(input?: s.DocumentClassifierInputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataFormat: input["DataFormat"],
    S3Uri: input["S3Uri"],
    LabelDelimiter: input["LabelDelimiter"],
    AugmentedManifests: input["AugmentedManifests"]?.map(x => fromAugmentedManifestsListItem(x)),
  }
}
function toDocumentClassifierInputDataConfig(root: jsonP.JSONValue): s.DocumentClassifierInputDataConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentClassifierDataFormat>(x),
      "S3Uri": "s",
      "LabelDelimiter": "s",
      "AugmentedManifests": [toAugmentedManifestsListItem],
    },
  }, root);
}

function fromAugmentedManifestsListItem(input?: s.AugmentedManifestsListItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    AttributeNames: input["AttributeNames"],
  }
}
function toAugmentedManifestsListItem(root: jsonP.JSONValue): s.AugmentedManifestsListItem {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "AttributeNames": ["s"],
    },
    optional: {},
  }, root);
}

function fromDocumentClassifierOutputDataConfig(input?: s.DocumentClassifierOutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toDocumentClassifierOutputDataConfig(root: jsonP.JSONValue): s.DocumentClassifierOutputDataConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
      "KmsKeyId": "s",
    },
  }, root);
}

function fromVpcConfig(input?: s.VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecurityGroupIds: input["SecurityGroupIds"],
    Subnets: input["Subnets"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): s.VpcConfig {
  return jsonP.readObj({
    required: {
      "SecurityGroupIds": ["s"],
      "Subnets": ["s"],
    },
    optional: {},
  }, root);
}

function fromEntityRecognizerInputDataConfig(input?: s.EntityRecognizerInputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataFormat: input["DataFormat"],
    EntityTypes: input["EntityTypes"]?.map(x => fromEntityTypesListItem(x)),
    Documents: fromEntityRecognizerDocuments(input["Documents"]),
    Annotations: fromEntityRecognizerAnnotations(input["Annotations"]),
    EntityList: fromEntityRecognizerEntityList(input["EntityList"]),
    AugmentedManifests: input["AugmentedManifests"]?.map(x => fromAugmentedManifestsListItem(x)),
  }
}
function toEntityRecognizerInputDataConfig(root: jsonP.JSONValue): s.EntityRecognizerInputDataConfig {
  return jsonP.readObj({
    required: {
      "EntityTypes": [toEntityTypesListItem],
    },
    optional: {
      "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityRecognizerDataFormat>(x),
      "Documents": toEntityRecognizerDocuments,
      "Annotations": toEntityRecognizerAnnotations,
      "EntityList": toEntityRecognizerEntityList,
      "AugmentedManifests": [toAugmentedManifestsListItem],
    },
  }, root);
}

function fromEntityTypesListItem(input?: s.EntityTypesListItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
  }
}
function toEntityTypesListItem(root: jsonP.JSONValue): s.EntityTypesListItem {
  return jsonP.readObj({
    required: {
      "Type": "s",
    },
    optional: {},
  }, root);
}

function fromEntityRecognizerDocuments(input?: s.EntityRecognizerDocuments | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toEntityRecognizerDocuments(root: jsonP.JSONValue): s.EntityRecognizerDocuments {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromEntityRecognizerAnnotations(input?: s.EntityRecognizerAnnotations | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toEntityRecognizerAnnotations(root: jsonP.JSONValue): s.EntityRecognizerAnnotations {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromEntityRecognizerEntityList(input?: s.EntityRecognizerEntityList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toEntityRecognizerEntityList(root: jsonP.JSONValue): s.EntityRecognizerEntityList {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromDocumentClassificationJobFilter(input?: s.DocumentClassificationJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromDocumentClassifierFilter(input?: s.DocumentClassifierFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromDominantLanguageDetectionJobFilter(input?: s.DominantLanguageDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromEndpointFilter(input?: s.EndpointFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ModelArn: input["ModelArn"],
    Status: input["Status"],
    CreationTimeBefore: jsonP.serializeDate_unixTimestamp(input["CreationTimeBefore"]),
    CreationTimeAfter: jsonP.serializeDate_unixTimestamp(input["CreationTimeAfter"]),
  }
}

function fromEntitiesDetectionJobFilter(input?: s.EntitiesDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromEntityRecognizerFilter(input?: s.EntityRecognizerFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromEventsDetectionJobFilter(input?: s.EventsDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromKeyPhrasesDetectionJobFilter(input?: s.KeyPhrasesDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromPiiEntitiesDetectionJobFilter(input?: s.PiiEntitiesDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromSentimentDetectionJobFilter(input?: s.SentimentDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromTopicsDetectionJobFilter(input?: s.TopicsDetectionJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmitTimeBefore: jsonP.serializeDate_unixTimestamp(input["SubmitTimeBefore"]),
    SubmitTimeAfter: jsonP.serializeDate_unixTimestamp(input["SubmitTimeAfter"]),
  }
}

function fromInputDataConfig(input?: s.InputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    InputFormat: input["InputFormat"],
  }
}
function toInputDataConfig(root: jsonP.JSONValue): s.InputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "InputFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputFormat>(x),
    },
  }, root);
}

function fromOutputDataConfig(input?: s.OutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toOutputDataConfig(root: jsonP.JSONValue): s.OutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromRedactionConfig(input?: s.RedactionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PiiEntityTypes: input["PiiEntityTypes"],
    MaskMode: input["MaskMode"],
    MaskCharacter: input["MaskCharacter"],
  }
}
function toRedactionConfig(root: jsonP.JSONValue): s.RedactionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "PiiEntityTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.PiiEntityType>(x)],
      "MaskMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.PiiEntitiesDetectionMaskMode>(x),
      "MaskCharacter": "s",
    },
  }, root);
}

function toBatchDetectDominantLanguageItemResult(root: jsonP.JSONValue): s.BatchDetectDominantLanguageItemResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "Languages": [toDominantLanguage],
    },
  }, root);
}

function toDominantLanguage(root: jsonP.JSONValue): s.DominantLanguage {
  return jsonP.readObj({
    required: {},
    optional: {
      "LanguageCode": "s",
      "Score": "n",
    },
  }, root);
}

function toBatchItemError(root: jsonP.JSONValue): s.BatchItemError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toBatchDetectEntitiesItemResult(root: jsonP.JSONValue): s.BatchDetectEntitiesItemResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "Entities": [toEntity],
    },
  }, root);
}

function toEntity(root: jsonP.JSONValue): s.Entity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Score": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EntityType>(x),
      "Text": "s",
      "BeginOffset": "n",
      "EndOffset": "n",
    },
  }, root);
}

function toBatchDetectKeyPhrasesItemResult(root: jsonP.JSONValue): s.BatchDetectKeyPhrasesItemResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "KeyPhrases": [toKeyPhrase],
    },
  }, root);
}

function toKeyPhrase(root: jsonP.JSONValue): s.KeyPhrase {
  return jsonP.readObj({
    required: {},
    optional: {
      "Score": "n",
      "Text": "s",
      "BeginOffset": "n",
      "EndOffset": "n",
    },
  }, root);
}

function toBatchDetectSentimentItemResult(root: jsonP.JSONValue): s.BatchDetectSentimentItemResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "Sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<s.SentimentType>(x),
      "SentimentScore": toSentimentScore,
    },
  }, root);
}

function toSentimentScore(root: jsonP.JSONValue): s.SentimentScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "Positive": "n",
      "Negative": "n",
      "Neutral": "n",
      "Mixed": "n",
    },
  }, root);
}

function toBatchDetectSyntaxItemResult(root: jsonP.JSONValue): s.BatchDetectSyntaxItemResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "SyntaxTokens": [toSyntaxToken],
    },
  }, root);
}

function toSyntaxToken(root: jsonP.JSONValue): s.SyntaxToken {
  return jsonP.readObj({
    required: {},
    optional: {
      "TokenId": "n",
      "Text": "s",
      "BeginOffset": "n",
      "EndOffset": "n",
      "PartOfSpeech": toPartOfSpeechTag,
    },
  }, root);
}

function toPartOfSpeechTag(root: jsonP.JSONValue): s.PartOfSpeechTag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Tag": (x: jsonP.JSONValue) => cmnP.readEnum<s.PartOfSpeechTagType>(x),
      "Score": "n",
    },
  }, root);
}

function toDocumentClass(root: jsonP.JSONValue): s.DocumentClass {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Score": "n",
    },
  }, root);
}

function toDocumentLabel(root: jsonP.JSONValue): s.DocumentLabel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Score": "n",
    },
  }, root);
}

function toDocumentClassificationJobProperties(root: jsonP.JSONValue): s.DocumentClassificationJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "DocumentClassifierArn": "s",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toDocumentClassifierProperties(root: jsonP.JSONValue): s.DocumentClassifierProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "DocumentClassifierArn": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "InputDataConfig": toDocumentClassifierInputDataConfig,
      "OutputDataConfig": toDocumentClassifierOutputDataConfig,
      "ClassifierMetadata": toClassifierMetadata,
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentClassifierMode>(x),
    },
  }, root);
}

function toClassifierMetadata(root: jsonP.JSONValue): s.ClassifierMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumberOfLabels": "n",
      "NumberOfTrainedDocuments": "n",
      "NumberOfTestDocuments": "n",
      "EvaluationMetrics": toClassifierEvaluationMetrics,
    },
  }, root);
}

function toClassifierEvaluationMetrics(root: jsonP.JSONValue): s.ClassifierEvaluationMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Accuracy": "n",
      "Precision": "n",
      "Recall": "n",
      "F1Score": "n",
      "MicroPrecision": "n",
      "MicroRecall": "n",
      "MicroF1Score": "n",
      "HammingLoss": "n",
    },
  }, root);
}

function toDominantLanguageDetectionJobProperties(root: jsonP.JSONValue): s.DominantLanguageDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toEndpointProperties(root: jsonP.JSONValue): s.EndpointProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointStatus>(x),
      "Message": "s",
      "ModelArn": "s",
      "DesiredInferenceUnits": "n",
      "CurrentInferenceUnits": "n",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toEntitiesDetectionJobProperties(root: jsonP.JSONValue): s.EntitiesDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "EntityRecognizerArn": "s",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toEntityRecognizerProperties(root: jsonP.JSONValue): s.EntityRecognizerProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "EntityRecognizerArn": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "InputDataConfig": toEntityRecognizerInputDataConfig,
      "RecognizerMetadata": toEntityRecognizerMetadata,
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toEntityRecognizerMetadata(root: jsonP.JSONValue): s.EntityRecognizerMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumberOfTrainedDocuments": "n",
      "NumberOfTestDocuments": "n",
      "EvaluationMetrics": toEntityRecognizerEvaluationMetrics,
      "EntityTypes": [toEntityRecognizerMetadataEntityTypesListItem],
    },
  }, root);
}

function toEntityRecognizerEvaluationMetrics(root: jsonP.JSONValue): s.EntityRecognizerEvaluationMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Precision": "n",
      "Recall": "n",
      "F1Score": "n",
    },
  }, root);
}

function toEntityRecognizerMetadataEntityTypesListItem(root: jsonP.JSONValue): s.EntityRecognizerMetadataEntityTypesListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "EvaluationMetrics": toEntityTypesEvaluationMetrics,
      "NumberOfTrainMentions": "n",
    },
  }, root);
}

function toEntityTypesEvaluationMetrics(root: jsonP.JSONValue): s.EntityTypesEvaluationMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "Precision": "n",
      "Recall": "n",
      "F1Score": "n",
    },
  }, root);
}

function toEventsDetectionJobProperties(root: jsonP.JSONValue): s.EventsDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "DataAccessRoleArn": "s",
      "TargetEventTypes": ["s"],
    },
  }, root);
}

function toKeyPhrasesDetectionJobProperties(root: jsonP.JSONValue): s.KeyPhrasesDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toPiiEntitiesDetectionJobProperties(root: jsonP.JSONValue): s.PiiEntitiesDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toPiiOutputDataConfig,
      "RedactionConfig": toRedactionConfig,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "DataAccessRoleArn": "s",
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.PiiEntitiesDetectionMode>(x),
    },
  }, root);
}

function toPiiOutputDataConfig(root: jsonP.JSONValue): s.PiiOutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function toSentimentDetectionJobProperties(root: jsonP.JSONValue): s.SentimentDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageCode>(x),
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toTopicsDetectionJobProperties(root: jsonP.JSONValue): s.TopicsDetectionJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Message": "s",
      "SubmitTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "NumberOfTopics": "n",
      "DataAccessRoleArn": "s",
      "VolumeKmsKeyId": "s",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function toPiiEntity(root: jsonP.JSONValue): s.PiiEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Score": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.PiiEntityType>(x),
      "BeginOffset": "n",
      "EndOffset": "n",
    },
  }, root);
}
