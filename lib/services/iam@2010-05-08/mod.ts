// Autogenerated API client for: AWS Identity and Access Management

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function parseBlob(input: string | null | undefined) {
  if (input == null) return input;
  return Base64.decode(input);
}

export default class IAM {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IAM.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2010-05-08",
    "endpointPrefix": "iam",
    "globalEndpoint": "iam.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "IAM",
    "serviceFullName": "AWS Identity and Access Management",
    "serviceId": "IAM",
    "signatureVersion": "v4",
    "uid": "iam-2010-05-08",
    "xmlNamespace": "https://iam.amazonaws.com/doc/2010-05-08/"
  };

  async addClientIDToOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & s.AddClientIDToOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    body.append(prefix+"ClientID", (params["ClientID"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddClientIDToOpenIDConnectProvider",
    });
  }

  async addRoleToInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.AddRoleToInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddRoleToInstanceProfile",
    });
  }

  async addUserToGroup(
    {abortSignal, ...params}: RequestConfig & s.AddUserToGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddUserToGroup",
    });
  }

  async attachGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachGroupPolicy",
    });
  }

  async attachRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachRolePolicy",
    });
  }

  async attachUserPolicy(
    {abortSignal, ...params}: RequestConfig & s.AttachUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachUserPolicy",
    });
  }

  async changePassword(
    {abortSignal, ...params}: RequestConfig & s.ChangePasswordRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OldPassword", (params["OldPassword"] ?? '').toString());
    body.append(prefix+"NewPassword", (params["NewPassword"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ChangePassword",
    });
  }

  async createAccessKey(
    {abortSignal, ...params}: RequestConfig & s.CreateAccessKeyRequest = {},
  ): Promise<s.CreateAccessKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAccessKey",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateAccessKeyResult");
    return {
      AccessKey: xml.first("AccessKey", true, AccessKey_Parse),
    };
  }

  async createAccountAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateAccountAliasRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccountAlias", (params["AccountAlias"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAccountAlias",
    });
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGroupRequest,
  ): Promise<s.CreateGroupResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateGroupResult");
    return {
      Group: xml.first("Group", true, Group_Parse),
    };
  }

  async createInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateInstanceProfileRequest,
  ): Promise<s.CreateInstanceProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateInstanceProfileResult");
    return {
      InstanceProfile: xml.first("InstanceProfile", true, InstanceProfile_Parse),
    };
  }

  async createLoginProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateLoginProfileRequest,
  ): Promise<s.CreateLoginProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"Password", (params["Password"] ?? '').toString());
    if ("PasswordResetRequired" in params) body.append(prefix+"PasswordResetRequired", (params["PasswordResetRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoginProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateLoginProfileResult");
    return {
      LoginProfile: xml.first("LoginProfile", true, LoginProfile_Parse),
    };
  }

  async createOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & s.CreateOpenIDConnectProviderRequest,
  ): Promise<s.CreateOpenIDConnectProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Url", (params["Url"] ?? '').toString());
    if (params["ClientIDList"]) qsP.appendList(body, prefix+"ClientIDList", params["ClientIDList"], {"entryPrefix":".member."})
    if (params["ThumbprintList"]) qsP.appendList(body, prefix+"ThumbprintList", params["ThumbprintList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOpenIDConnectProvider",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateOpenIDConnectProviderResult");
    return xml.strings({
      optional: {"OpenIDConnectProviderArn":true},
    });
  }

  async createPolicy(
    {abortSignal, ...params}: RequestConfig & s.CreatePolicyRequest,
  ): Promise<s.CreatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreatePolicyResult");
    return {
      Policy: xml.first("Policy", false, Policy_Parse),
    };
  }

  async createPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.CreatePolicyVersionRequest,
  ): Promise<s.CreatePolicyVersionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if ("SetAsDefault" in params) body.append(prefix+"SetAsDefault", (params["SetAsDefault"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePolicyVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreatePolicyVersionResult");
    return {
      PolicyVersion: xml.first("PolicyVersion", false, PolicyVersion_Parse),
    };
  }

  async createRole(
    {abortSignal, ...params}: RequestConfig & s.CreateRoleRequest,
  ): Promise<s.CreateRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"AssumeRolePolicyDocument", (params["AssumeRolePolicyDocument"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("MaxSessionDuration" in params) body.append(prefix+"MaxSessionDuration", (params["MaxSessionDuration"] ?? '').toString());
    if ("PermissionsBoundary" in params) body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateRoleResult");
    return {
      Role: xml.first("Role", true, Role_Parse),
    };
  }

  async createSAMLProvider(
    {abortSignal, ...params}: RequestConfig & s.CreateSAMLProviderRequest,
  ): Promise<s.CreateSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLMetadataDocument", (params["SAMLMetadataDocument"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSAMLProvider",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSAMLProviderResult");
    return xml.strings({
      optional: {"SAMLProviderArn":true},
    });
  }

  async createServiceLinkedRole(
    {abortSignal, ...params}: RequestConfig & s.CreateServiceLinkedRoleRequest,
  ): Promise<s.CreateServiceLinkedRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AWSServiceName", (params["AWSServiceName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("CustomSuffix" in params) body.append(prefix+"CustomSuffix", (params["CustomSuffix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateServiceLinkedRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateServiceLinkedRoleResult");
    return {
      Role: xml.first("Role", false, Role_Parse),
    };
  }

  async createServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & s.CreateServiceSpecificCredentialRequest,
  ): Promise<s.CreateServiceSpecificCredentialResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateServiceSpecificCredential",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateServiceSpecificCredentialResult");
    return {
      ServiceSpecificCredential: xml.first("ServiceSpecificCredential", false, ServiceSpecificCredential_Parse),
    };
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & s.CreateUserRequest,
  ): Promise<s.CreateUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("PermissionsBoundary" in params) body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUserResult");
    return {
      User: xml.first("User", false, User_Parse),
    };
  }

  async createVirtualMFADevice(
    {abortSignal, ...params}: RequestConfig & s.CreateVirtualMFADeviceRequest,
  ): Promise<s.CreateVirtualMFADeviceResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"VirtualMFADeviceName", (params["VirtualMFADeviceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVirtualMFADevice",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateVirtualMFADeviceResult");
    return {
      VirtualMFADevice: xml.first("VirtualMFADevice", true, VirtualMFADevice_Parse),
    };
  }

  async deactivateMFADevice(
    {abortSignal, ...params}: RequestConfig & s.DeactivateMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeactivateMFADevice",
    });
  }

  async deleteAccessKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccessKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccessKey",
    });
  }

  async deleteAccountAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccountAliasRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccountAlias", (params["AccountAlias"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccountAlias",
    });
  }

  async deleteAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<void> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAccountPasswordPolicy",
    });
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroup",
    });
  }

  async deleteGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroupPolicy",
    });
  }

  async deleteInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstanceProfile",
    });
  }

  async deleteLoginProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteLoginProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoginProfile",
    });
  }

  async deleteOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & s.DeleteOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOpenIDConnectProvider",
    });
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeletePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicy",
    });
  }

  async deletePolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.DeletePolicyVersionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicyVersion",
    });
  }

  async deleteRole(
    {abortSignal, ...params}: RequestConfig & s.DeleteRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRole",
    });
  }

  async deleteRolePermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & s.DeleteRolePermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRolePermissionsBoundary",
    });
  }

  async deleteRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRolePolicy",
    });
  }

  async deleteSAMLProvider(
    {abortSignal, ...params}: RequestConfig & s.DeleteSAMLProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSAMLProvider",
    });
  }

  async deleteSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & s.DeleteSSHPublicKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSSHPublicKey",
    });
  }

  async deleteServerCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteServerCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServerCertificate",
    });
  }

  async deleteServiceLinkedRole(
    {abortSignal, ...params}: RequestConfig & s.DeleteServiceLinkedRoleRequest,
  ): Promise<s.DeleteServiceLinkedRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServiceLinkedRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteServiceLinkedRoleResult");
    return xml.strings({
      required: {"DeletionTaskId":true},
    });
  }

  async deleteServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & s.DeleteServiceSpecificCredentialRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServiceSpecificCredential",
    });
  }

  async deleteSigningCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteSigningCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateId", (params["CertificateId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSigningCertificate",
    });
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
  }

  async deleteUserPermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserPermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPermissionsBoundary",
    });
  }

  async deleteUserPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPolicy",
    });
  }

  async deleteVirtualMFADevice(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVirtualMFADevice",
    });
  }

  async detachGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachGroupPolicy",
    });
  }

  async detachRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachRolePolicy",
    });
  }

  async detachUserPolicy(
    {abortSignal, ...params}: RequestConfig & s.DetachUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachUserPolicy",
    });
  }

  async enableMFADevice(
    {abortSignal, ...params}: RequestConfig & s.EnableMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    body.append(prefix+"AuthenticationCode1", (params["AuthenticationCode1"] ?? '').toString());
    body.append(prefix+"AuthenticationCode2", (params["AuthenticationCode2"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableMFADevice",
    });
  }

  async generateCredentialReport(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.GenerateCredentialReportResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GenerateCredentialReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GenerateCredentialReportResult");
    return {
      ...xml.strings({
        optional: {"Description":true},
      }),
      State: xml.first("State", false, x => (x.content ?? '') as s.ReportStateType),
    };
  }

  async generateOrganizationsAccessReport(
    {abortSignal, ...params}: RequestConfig & s.GenerateOrganizationsAccessReportRequest,
  ): Promise<s.GenerateOrganizationsAccessReportResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EntityPath", (params["EntityPath"] ?? '').toString());
    if ("OrganizationsPolicyId" in params) body.append(prefix+"OrganizationsPolicyId", (params["OrganizationsPolicyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateOrganizationsAccessReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GenerateOrganizationsAccessReportResult");
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async generateServiceLastAccessedDetails(
    {abortSignal, ...params}: RequestConfig & s.GenerateServiceLastAccessedDetailsRequest,
  ): Promise<s.GenerateServiceLastAccessedDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Granularity" in params) body.append(prefix+"Granularity", (params["Granularity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateServiceLastAccessedDetails",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GenerateServiceLastAccessedDetailsResult");
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async getAccessKeyLastUsed(
    {abortSignal, ...params}: RequestConfig & s.GetAccessKeyLastUsedRequest,
  ): Promise<s.GetAccessKeyLastUsedResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccessKeyLastUsed",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAccessKeyLastUsedResult");
    return {
      ...xml.strings({
        optional: {"UserName":true},
      }),
      AccessKeyLastUsed: xml.first("AccessKeyLastUsed", false, AccessKeyLastUsed_Parse),
    };
  }

  async getAccountAuthorizationDetails(
    {abortSignal, ...params}: RequestConfig & s.GetAccountAuthorizationDetailsRequest = {},
  ): Promise<s.GetAccountAuthorizationDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"entryPrefix":".member."})
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccountAuthorizationDetails",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAccountAuthorizationDetailsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UserDetailList: xml.getList("UserDetailList", "member").map(UserDetail_Parse),
      GroupDetailList: xml.getList("GroupDetailList", "member").map(GroupDetail_Parse),
      RoleDetailList: xml.getList("RoleDetailList", "member").map(RoleDetail_Parse),
      Policies: xml.getList("Policies", "member").map(ManagedPolicyDetail_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async getAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.GetAccountPasswordPolicyResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountPasswordPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAccountPasswordPolicyResult");
    return {
      PasswordPolicy: xml.first("PasswordPolicy", true, PasswordPolicy_Parse),
    };
  }

  async getAccountSummary(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.GetAccountSummaryResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountSummary",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAccountSummaryResult");
    return {
      SummaryMap: xmlP.readXmlMap(xml.getList("SummaryMap", "entry"), x => parseInt(x.content ?? '0'), {}),
    };
  }

  async getContextKeysForCustomPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetContextKeysForCustomPolicyRequest,
  ): Promise<s.GetContextKeysForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PolicyInputList"]) qsP.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContextKeysForCustomPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetContextKeysForCustomPolicyResult");
    return {
      ContextKeyNames: xml.getList("ContextKeyNames", "member").map(x => x.content ?? ''),
    };
  }

  async getContextKeysForPrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetContextKeysForPrincipalPolicyRequest,
  ): Promise<s.GetContextKeysForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicySourceArn", (params["PolicySourceArn"] ?? '').toString());
    if (params["PolicyInputList"]) qsP.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContextKeysForPrincipalPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetContextKeysForPrincipalPolicyResult");
    return {
      ContextKeyNames: xml.getList("ContextKeyNames", "member").map(x => x.content ?? ''),
    };
  }

  async getCredentialReport(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.GetCredentialReportResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCredentialReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetCredentialReportResult");
    return {
      Content: xml.first("Content", false, x => parseBlob(x.content) ?? ''),
      ReportFormat: xml.first("ReportFormat", false, x => (x.content ?? '') as s.ReportFormatType),
      GeneratedTime: xml.first("GeneratedTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getGroup(
    {abortSignal, ...params}: RequestConfig & s.GetGroupRequest,
  ): Promise<s.GetGroupResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetGroupResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Group: xml.first("Group", true, Group_Parse),
      Users: xml.getList("Users", "member").map(User_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async getGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetGroupPolicyRequest,
  ): Promise<s.GetGroupPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroupPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetGroupPolicyResult");
    return xml.strings({
      required: {"GroupName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async getInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceProfileRequest,
  ): Promise<s.GetInstanceProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetInstanceProfileResult");
    return {
      InstanceProfile: xml.first("InstanceProfile", true, InstanceProfile_Parse),
    };
  }

  async getLoginProfile(
    {abortSignal, ...params}: RequestConfig & s.GetLoginProfileRequest,
  ): Promise<s.GetLoginProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoginProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetLoginProfileResult");
    return {
      LoginProfile: xml.first("LoginProfile", true, LoginProfile_Parse),
    };
  }

  async getOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & s.GetOpenIDConnectProviderRequest,
  ): Promise<s.GetOpenIDConnectProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOpenIDConnectProvider",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetOpenIDConnectProviderResult");
    return {
      ...xml.strings({
        optional: {"Url":true},
      }),
      ClientIDList: xml.getList("ClientIDList", "member").map(x => x.content ?? ''),
      ThumbprintList: xml.getList("ThumbprintList", "member").map(x => x.content ?? ''),
      CreateDate: xml.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getOrganizationsAccessReport(
    {abortSignal, ...params}: RequestConfig & s.GetOrganizationsAccessReportRequest,
  ): Promise<s.GetOrganizationsAccessReportResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("SortKey" in params) body.append(prefix+"SortKey", (params["SortKey"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOrganizationsAccessReport",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetOrganizationsAccessReportResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as s.jobStatusType),
      JobCreationDate: xml.first("JobCreationDate", true, x => xmlP.parseTimestamp(x.content)),
      JobCompletionDate: xml.first("JobCompletionDate", false, x => xmlP.parseTimestamp(x.content)),
      NumberOfServicesAccessible: xml.first("NumberOfServicesAccessible", false, x => parseInt(x.content ?? '0')),
      NumberOfServicesNotAccessed: xml.first("NumberOfServicesNotAccessed", false, x => parseInt(x.content ?? '0')),
      AccessDetails: xml.getList("AccessDetails", "member").map(AccessDetail_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      ErrorDetails: xml.first("ErrorDetails", false, ErrorDetails_Parse),
    };
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetPolicyRequest,
  ): Promise<s.GetPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetPolicyResult");
    return {
      Policy: xml.first("Policy", false, Policy_Parse),
    };
  }

  async getPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.GetPolicyVersionRequest,
  ): Promise<s.GetPolicyVersionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPolicyVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetPolicyVersionResult");
    return {
      PolicyVersion: xml.first("PolicyVersion", false, PolicyVersion_Parse),
    };
  }

  async getRole(
    {abortSignal, ...params}: RequestConfig & s.GetRoleRequest,
  ): Promise<s.GetRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetRoleResult");
    return {
      Role: xml.first("Role", true, Role_Parse),
    };
  }

  async getRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetRolePolicyRequest,
  ): Promise<s.GetRolePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRolePolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetRolePolicyResult");
    return xml.strings({
      required: {"RoleName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async getSAMLProvider(
    {abortSignal, ...params}: RequestConfig & s.GetSAMLProviderRequest,
  ): Promise<s.GetSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSAMLProvider",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetSAMLProviderResult");
    return {
      ...xml.strings({
        optional: {"SAMLMetadataDocument":true},
      }),
      CreateDate: xml.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
      ValidUntil: xml.first("ValidUntil", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & s.GetSSHPublicKeyRequest,
  ): Promise<s.GetSSHPublicKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    body.append(prefix+"Encoding", (params["Encoding"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSSHPublicKey",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetSSHPublicKeyResult");
    return {
      SSHPublicKey: xml.first("SSHPublicKey", false, SSHPublicKey_Parse),
    };
  }

  async getServerCertificate(
    {abortSignal, ...params}: RequestConfig & s.GetServerCertificateRequest,
  ): Promise<s.GetServerCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServerCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetServerCertificateResult");
    return {
      ServerCertificate: xml.first("ServerCertificate", true, ServerCertificate_Parse),
    };
  }

  async getServiceLastAccessedDetails(
    {abortSignal, ...params}: RequestConfig & s.GetServiceLastAccessedDetailsRequest,
  ): Promise<s.GetServiceLastAccessedDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLastAccessedDetails",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetServiceLastAccessedDetailsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as s.jobStatusType),
      JobType: xml.first("JobType", false, x => (x.content ?? '') as s.AccessAdvisorUsageGranularityType),
      JobCreationDate: xml.first("JobCreationDate", true, x => xmlP.parseTimestamp(x.content)),
      ServicesLastAccessed: xml.getList("ServicesLastAccessed", "member").map(ServiceLastAccessed_Parse),
      JobCompletionDate: xml.first("JobCompletionDate", true, x => xmlP.parseTimestamp(x.content)),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Error: xml.first("Error", false, ErrorDetails_Parse),
    };
  }

  async getServiceLastAccessedDetailsWithEntities(
    {abortSignal, ...params}: RequestConfig & s.GetServiceLastAccessedDetailsWithEntitiesRequest,
  ): Promise<s.GetServiceLastAccessedDetailsWithEntitiesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    body.append(prefix+"ServiceNamespace", (params["ServiceNamespace"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLastAccessedDetailsWithEntities",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetServiceLastAccessedDetailsWithEntitiesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as s.jobStatusType),
      JobCreationDate: xml.first("JobCreationDate", true, x => xmlP.parseTimestamp(x.content)),
      JobCompletionDate: xml.first("JobCompletionDate", true, x => xmlP.parseTimestamp(x.content)),
      EntityDetailsList: xml.getList("EntityDetailsList", "member").map(EntityDetails_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Error: xml.first("Error", false, ErrorDetails_Parse),
    };
  }

  async getServiceLinkedRoleDeletionStatus(
    {abortSignal, ...params}: RequestConfig & s.GetServiceLinkedRoleDeletionStatusRequest,
  ): Promise<s.GetServiceLinkedRoleDeletionStatusResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DeletionTaskId", (params["DeletionTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLinkedRoleDeletionStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetServiceLinkedRoleDeletionStatusResult");
    return {
      Status: xml.first("Status", true, x => (x.content ?? '') as s.DeletionTaskStatusType),
      Reason: xml.first("Reason", false, DeletionTaskFailureReasonType_Parse),
    };
  }

  async getUser(
    {abortSignal, ...params}: RequestConfig & s.GetUserRequest = {},
  ): Promise<s.GetUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetUserResult");
    return {
      User: xml.first("User", true, User_Parse),
    };
  }

  async getUserPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetUserPolicyRequest,
  ): Promise<s.GetUserPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetUserPolicyResult");
    return xml.strings({
      required: {"UserName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async listAccessKeys(
    {abortSignal, ...params}: RequestConfig & s.ListAccessKeysRequest = {},
  ): Promise<s.ListAccessKeysResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccessKeys",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAccessKeysResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AccessKeyMetadata: xml.getList("AccessKeyMetadata", "member").map(AccessKeyMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAccountAliases(
    {abortSignal, ...params}: RequestConfig & s.ListAccountAliasesRequest = {},
  ): Promise<s.ListAccountAliasesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccountAliases",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAccountAliasesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AccountAliases: xml.getList("AccountAliases", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedGroupPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListAttachedGroupPoliciesRequest,
  ): Promise<s.ListAttachedGroupPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedGroupPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAttachedGroupPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedRolePolicies(
    {abortSignal, ...params}: RequestConfig & s.ListAttachedRolePoliciesRequest,
  ): Promise<s.ListAttachedRolePoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedRolePolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAttachedRolePoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedUserPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListAttachedUserPoliciesRequest,
  ): Promise<s.ListAttachedUserPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedUserPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAttachedUserPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listEntitiesForPolicy(
    {abortSignal, ...params}: RequestConfig & s.ListEntitiesForPolicyRequest,
  ): Promise<s.ListEntitiesForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    if ("EntityFilter" in params) body.append(prefix+"EntityFilter", (params["EntityFilter"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("PolicyUsageFilter" in params) body.append(prefix+"PolicyUsageFilter", (params["PolicyUsageFilter"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEntitiesForPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListEntitiesForPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyGroups: xml.getList("PolicyGroups", "member").map(PolicyGroup_Parse),
      PolicyUsers: xml.getList("PolicyUsers", "member").map(PolicyUser_Parse),
      PolicyRoles: xml.getList("PolicyRoles", "member").map(PolicyRole_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroupPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListGroupPoliciesRequest,
  ): Promise<s.ListGroupPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroupPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListGroupPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroups(
    {abortSignal, ...params}: RequestConfig & s.ListGroupsRequest = {},
  ): Promise<s.ListGroupsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Groups: xml.getList("Groups", "member").map(Group_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroupsForUser(
    {abortSignal, ...params}: RequestConfig & s.ListGroupsForUserRequest,
  ): Promise<s.ListGroupsForUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroupsForUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListGroupsForUserResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Groups: xml.getList("Groups", "member").map(Group_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listInstanceProfiles(
    {abortSignal, ...params}: RequestConfig & s.ListInstanceProfilesRequest = {},
  ): Promise<s.ListInstanceProfilesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceProfiles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListInstanceProfilesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      InstanceProfiles: xml.getList("InstanceProfiles", "member").map(InstanceProfile_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listInstanceProfilesForRole(
    {abortSignal, ...params}: RequestConfig & s.ListInstanceProfilesForRoleRequest,
  ): Promise<s.ListInstanceProfilesForRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceProfilesForRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListInstanceProfilesForRoleResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      InstanceProfiles: xml.getList("InstanceProfiles", "member").map(InstanceProfile_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listMFADevices(
    {abortSignal, ...params}: RequestConfig & s.ListMFADevicesRequest = {},
  ): Promise<s.ListMFADevicesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMFADevices",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListMFADevicesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      MFADevices: xml.getList("MFADevices", "member").map(MFADevice_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listOpenIDConnectProviders(
    {abortSignal, ...params}: RequestConfig & s.ListOpenIDConnectProvidersRequest = {},
  ): Promise<s.ListOpenIDConnectProvidersResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOpenIDConnectProviders",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListOpenIDConnectProvidersResult");
    return {
      OpenIDConnectProviderList: xml.getList("OpenIDConnectProviderList", "member").map(OpenIDConnectProviderListEntry_Parse),
    };
  }

  async listPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListPoliciesRequest = {},
  ): Promise<s.ListPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Scope" in params) body.append(prefix+"Scope", (params["Scope"] ?? '').toString());
    if ("OnlyAttached" in params) body.append(prefix+"OnlyAttached", (params["OnlyAttached"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("PolicyUsageFilter" in params) body.append(prefix+"PolicyUsageFilter", (params["PolicyUsageFilter"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Policies: xml.getList("Policies", "member").map(Policy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listPoliciesGrantingServiceAccess(
    {abortSignal, ...params}: RequestConfig & s.ListPoliciesGrantingServiceAccessRequest,
  ): Promise<s.ListPoliciesGrantingServiceAccessResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if (params["ServiceNamespaces"]) qsP.appendList(body, prefix+"ServiceNamespaces", params["ServiceNamespaces"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPoliciesGrantingServiceAccess",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListPoliciesGrantingServiceAccessResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PoliciesGrantingServiceAccess: xml.getList("PoliciesGrantingServiceAccess", "member").map(ListPoliciesGrantingServiceAccessEntry_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listPolicyVersions(
    {abortSignal, ...params}: RequestConfig & s.ListPolicyVersionsRequest,
  ): Promise<s.ListPolicyVersionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPolicyVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListPolicyVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Versions: xml.getList("Versions", "member").map(PolicyVersion_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRolePolicies(
    {abortSignal, ...params}: RequestConfig & s.ListRolePoliciesRequest,
  ): Promise<s.ListRolePoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRolePolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListRolePoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRoleTags(
    {abortSignal, ...params}: RequestConfig & s.ListRoleTagsRequest,
  ): Promise<s.ListRoleTagsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRoleTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListRoleTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRoles(
    {abortSignal, ...params}: RequestConfig & s.ListRolesRequest = {},
  ): Promise<s.ListRolesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRoles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListRolesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Roles: xml.getList("Roles", "member").map(Role_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listSAMLProviders(
    {abortSignal, ...params}: RequestConfig & s.ListSAMLProvidersRequest = {},
  ): Promise<s.ListSAMLProvidersResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSAMLProviders",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListSAMLProvidersResult");
    return {
      SAMLProviderList: xml.getList("SAMLProviderList", "member").map(SAMLProviderListEntry_Parse),
    };
  }

  async listSSHPublicKeys(
    {abortSignal, ...params}: RequestConfig & s.ListSSHPublicKeysRequest = {},
  ): Promise<s.ListSSHPublicKeysResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSSHPublicKeys",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListSSHPublicKeysResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SSHPublicKeys: xml.getList("SSHPublicKeys", "member").map(SSHPublicKeyMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listServerCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListServerCertificatesRequest = {},
  ): Promise<s.ListServerCertificatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServerCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListServerCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ServerCertificateMetadataList: xml.getList("ServerCertificateMetadataList", "member").map(ServerCertificateMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listServiceSpecificCredentials(
    {abortSignal, ...params}: RequestConfig & s.ListServiceSpecificCredentialsRequest = {},
  ): Promise<s.ListServiceSpecificCredentialsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("ServiceName" in params) body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServiceSpecificCredentials",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListServiceSpecificCredentialsResult");
    return {
      ServiceSpecificCredentials: xml.getList("ServiceSpecificCredentials", "member").map(ServiceSpecificCredentialMetadata_Parse),
    };
  }

  async listSigningCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListSigningCertificatesRequest = {},
  ): Promise<s.ListSigningCertificatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSigningCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListSigningCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Certificates: xml.getList("Certificates", "member").map(SigningCertificate_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUserPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListUserPoliciesRequest,
  ): Promise<s.ListUserPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListUserPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUserTags(
    {abortSignal, ...params}: RequestConfig & s.ListUserTagsRequest,
  ): Promise<s.ListUserTagsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListUserTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUsers(
    {abortSignal, ...params}: RequestConfig & s.ListUsersRequest = {},
  ): Promise<s.ListUsersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUsers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListUsersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Users: xml.getList("Users", "member").map(User_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listVirtualMFADevices(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualMFADevicesRequest = {},
  ): Promise<s.ListVirtualMFADevicesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AssignmentStatus" in params) body.append(prefix+"AssignmentStatus", (params["AssignmentStatus"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVirtualMFADevices",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListVirtualMFADevicesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      VirtualMFADevices: xml.getList("VirtualMFADevices", "member").map(VirtualMFADevice_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async putGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutGroupPolicy",
    });
  }

  async putRolePermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & s.PutRolePermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRolePermissionsBoundary",
    });
  }

  async putRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRolePolicy",
    });
  }

  async putUserPermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & s.PutUserPermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutUserPermissionsBoundary",
    });
  }

  async putUserPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutUserPolicy",
    });
  }

  async removeClientIDFromOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & s.RemoveClientIDFromOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    body.append(prefix+"ClientID", (params["ClientID"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveClientIDFromOpenIDConnectProvider",
    });
  }

  async removeRoleFromInstanceProfile(
    {abortSignal, ...params}: RequestConfig & s.RemoveRoleFromInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveRoleFromInstanceProfile",
    });
  }

  async removeUserFromGroup(
    {abortSignal, ...params}: RequestConfig & s.RemoveUserFromGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveUserFromGroup",
    });
  }

  async resetServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & s.ResetServiceSpecificCredentialRequest,
  ): Promise<s.ResetServiceSpecificCredentialResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetServiceSpecificCredential",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetServiceSpecificCredentialResult");
    return {
      ServiceSpecificCredential: xml.first("ServiceSpecificCredential", false, ServiceSpecificCredential_Parse),
    };
  }

  async resyncMFADevice(
    {abortSignal, ...params}: RequestConfig & s.ResyncMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    body.append(prefix+"AuthenticationCode1", (params["AuthenticationCode1"] ?? '').toString());
    body.append(prefix+"AuthenticationCode2", (params["AuthenticationCode2"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResyncMFADevice",
    });
  }

  async setDefaultPolicyVersion(
    {abortSignal, ...params}: RequestConfig & s.SetDefaultPolicyVersionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDefaultPolicyVersion",
    });
  }

  async setSecurityTokenServicePreferences(
    {abortSignal, ...params}: RequestConfig & s.SetSecurityTokenServicePreferencesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalEndpointTokenVersion", (params["GlobalEndpointTokenVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSecurityTokenServicePreferences",
    });
  }

  async simulateCustomPolicy(
    {abortSignal, ...params}: RequestConfig & s.SimulateCustomPolicyRequest,
  ): Promise<s.SimulatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PolicyInputList"]) qsP.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    if (params["PermissionsBoundaryPolicyInputList"]) qsP.appendList(body, prefix+"PermissionsBoundaryPolicyInputList", params["PermissionsBoundaryPolicyInputList"], {"entryPrefix":".member."})
    if (params["ActionNames"]) qsP.appendList(body, prefix+"ActionNames", params["ActionNames"], {"entryPrefix":".member."})
    if (params["ResourceArns"]) qsP.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if ("ResourcePolicy" in params) body.append(prefix+"ResourcePolicy", (params["ResourcePolicy"] ?? '').toString());
    if ("ResourceOwner" in params) body.append(prefix+"ResourceOwner", (params["ResourceOwner"] ?? '').toString());
    if ("CallerArn" in params) body.append(prefix+"CallerArn", (params["CallerArn"] ?? '').toString());
    if (params["ContextEntries"]) qsP.appendList(body, prefix+"ContextEntries", params["ContextEntries"], {"appender":ContextEntry_Serialize,"entryPrefix":".member."})
    if ("ResourceHandlingOption" in params) body.append(prefix+"ResourceHandlingOption", (params["ResourceHandlingOption"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SimulateCustomPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SimulateCustomPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EvaluationResults: xml.getList("EvaluationResults", "member").map(EvaluationResult_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async simulatePrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & s.SimulatePrincipalPolicyRequest,
  ): Promise<s.SimulatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicySourceArn", (params["PolicySourceArn"] ?? '').toString());
    if (params["PolicyInputList"]) qsP.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    if (params["PermissionsBoundaryPolicyInputList"]) qsP.appendList(body, prefix+"PermissionsBoundaryPolicyInputList", params["PermissionsBoundaryPolicyInputList"], {"entryPrefix":".member."})
    if (params["ActionNames"]) qsP.appendList(body, prefix+"ActionNames", params["ActionNames"], {"entryPrefix":".member."})
    if (params["ResourceArns"]) qsP.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if ("ResourcePolicy" in params) body.append(prefix+"ResourcePolicy", (params["ResourcePolicy"] ?? '').toString());
    if ("ResourceOwner" in params) body.append(prefix+"ResourceOwner", (params["ResourceOwner"] ?? '').toString());
    if ("CallerArn" in params) body.append(prefix+"CallerArn", (params["CallerArn"] ?? '').toString());
    if (params["ContextEntries"]) qsP.appendList(body, prefix+"ContextEntries", params["ContextEntries"], {"appender":ContextEntry_Serialize,"entryPrefix":".member."})
    if ("ResourceHandlingOption" in params) body.append(prefix+"ResourceHandlingOption", (params["ResourceHandlingOption"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SimulatePrincipalPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SimulatePrincipalPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EvaluationResults: xml.getList("EvaluationResults", "member").map(EvaluationResult_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async tagRole(
    {abortSignal, ...params}: RequestConfig & s.TagRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagRole",
    });
  }

  async tagUser(
    {abortSignal, ...params}: RequestConfig & s.TagUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagUser",
    });
  }

  async untagRole(
    {abortSignal, ...params}: RequestConfig & s.UntagRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagRole",
    });
  }

  async untagUser(
    {abortSignal, ...params}: RequestConfig & s.UntagUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagUser",
    });
  }

  async updateAccessKey(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccessKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccessKey",
    });
  }

  async updateAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateAccountPasswordPolicyRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MinimumPasswordLength" in params) body.append(prefix+"MinimumPasswordLength", (params["MinimumPasswordLength"] ?? '').toString());
    if ("RequireSymbols" in params) body.append(prefix+"RequireSymbols", (params["RequireSymbols"] ?? '').toString());
    if ("RequireNumbers" in params) body.append(prefix+"RequireNumbers", (params["RequireNumbers"] ?? '').toString());
    if ("RequireUppercaseCharacters" in params) body.append(prefix+"RequireUppercaseCharacters", (params["RequireUppercaseCharacters"] ?? '').toString());
    if ("RequireLowercaseCharacters" in params) body.append(prefix+"RequireLowercaseCharacters", (params["RequireLowercaseCharacters"] ?? '').toString());
    if ("AllowUsersToChangePassword" in params) body.append(prefix+"AllowUsersToChangePassword", (params["AllowUsersToChangePassword"] ?? '').toString());
    if ("MaxPasswordAge" in params) body.append(prefix+"MaxPasswordAge", (params["MaxPasswordAge"] ?? '').toString());
    if ("PasswordReusePrevention" in params) body.append(prefix+"PasswordReusePrevention", (params["PasswordReusePrevention"] ?? '').toString());
    if ("HardExpiry" in params) body.append(prefix+"HardExpiry", (params["HardExpiry"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountPasswordPolicy",
    });
  }

  async updateAssumeRolePolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateAssumeRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAssumeRolePolicy",
    });
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewGroupName" in params) body.append(prefix+"NewGroupName", (params["NewGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
    });
  }

  async updateLoginProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateLoginProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Password" in params) body.append(prefix+"Password", (params["Password"] ?? '').toString());
    if ("PasswordResetRequired" in params) body.append(prefix+"PasswordResetRequired", (params["PasswordResetRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLoginProfile",
    });
  }

  async updateOpenIDConnectProviderThumbprint(
    {abortSignal, ...params}: RequestConfig & s.UpdateOpenIDConnectProviderThumbprintRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    if (params["ThumbprintList"]) qsP.appendList(body, prefix+"ThumbprintList", params["ThumbprintList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOpenIDConnectProviderThumbprint",
    });
  }

  async updateRole(
    {abortSignal, ...params}: RequestConfig & s.UpdateRoleRequest,
  ): Promise<s.UpdateRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("MaxSessionDuration" in params) body.append(prefix+"MaxSessionDuration", (params["MaxSessionDuration"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRole",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateRoleResult");
    return {};
  }

  async updateRoleDescription(
    {abortSignal, ...params}: RequestConfig & s.UpdateRoleDescriptionRequest,
  ): Promise<s.UpdateRoleDescriptionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRoleDescription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateRoleDescriptionResult");
    return {
      Role: xml.first("Role", false, Role_Parse),
    };
  }

  async updateSAMLProvider(
    {abortSignal, ...params}: RequestConfig & s.UpdateSAMLProviderRequest,
  ): Promise<s.UpdateSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLMetadataDocument", (params["SAMLMetadataDocument"] ?? '').toString());
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSAMLProvider",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateSAMLProviderResult");
    return xml.strings({
      optional: {"SAMLProviderArn":true},
    });
  }

  async updateSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & s.UpdateSSHPublicKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSSHPublicKey",
    });
  }

  async updateServerCertificate(
    {abortSignal, ...params}: RequestConfig & s.UpdateServerCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewServerCertificateName" in params) body.append(prefix+"NewServerCertificateName", (params["NewServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServerCertificate",
    });
  }

  async updateServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & s.UpdateServiceSpecificCredentialRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceSpecificCredential",
    });
  }

  async updateSigningCertificate(
    {abortSignal, ...params}: RequestConfig & s.UpdateSigningCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateId", (params["CertificateId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSigningCertificate",
    });
  }

  async updateUser(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewUserName" in params) body.append(prefix+"NewUserName", (params["NewUserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUser",
    });
  }

  async uploadSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & s.UploadSSHPublicKeyRequest,
  ): Promise<s.UploadSSHPublicKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyBody", (params["SSHPublicKeyBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadSSHPublicKey",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UploadSSHPublicKeyResult");
    return {
      SSHPublicKey: xml.first("SSHPublicKey", false, SSHPublicKey_Parse),
    };
  }

  async uploadServerCertificate(
    {abortSignal, ...params}: RequestConfig & s.UploadServerCertificateRequest,
  ): Promise<s.UploadServerCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    body.append(prefix+"CertificateBody", (params["CertificateBody"] ?? '').toString());
    body.append(prefix+"PrivateKey", (params["PrivateKey"] ?? '').toString());
    if ("CertificateChain" in params) body.append(prefix+"CertificateChain", (params["CertificateChain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadServerCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UploadServerCertificateResult");
    return {
      ServerCertificateMetadata: xml.first("ServerCertificateMetadata", false, ServerCertificateMetadata_Parse),
    };
  }

  async uploadSigningCertificate(
    {abortSignal, ...params}: RequestConfig & s.UploadSigningCertificateRequest,
  ): Promise<s.UploadSigningCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateBody", (params["CertificateBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadSigningCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UploadSigningCertificateResult");
    return {
      Certificate: xml.first("Certificate", true, SigningCertificate_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForInstanceProfileExists(
    params: RequestConfig & s.GetInstanceProfileRequest,
  ): Promise<s.GetInstanceProfileResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceProfileExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.getInstanceProfile(params);
        return resp; // for status 200
      } catch (err) {
        if (!["Http404"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForUserExists(
    params: RequestConfig & s.GetUserRequest,
  ): Promise<s.GetUserResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state UserExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getUser(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForRoleExists(
    params: RequestConfig & s.GetRoleRequest,
  ): Promise<s.GetRoleResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state RoleExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getRole(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForPolicyExists(
    params: RequestConfig & s.GetPolicyRequest,
  ): Promise<s.GetPolicyResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state PolicyExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getPolicy(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function ContextEntry_Serialize(body: URLSearchParams, prefix: string, params: s.ContextEntry) {
    if ("ContextKeyName" in params) body.append(prefix+".ContextKeyName", (params["ContextKeyName"] ?? '').toString());
    if (params["ContextKeyValues"]) qsP.appendList(body, prefix+".ContextKeyValues", params["ContextKeyValues"], {"entryPrefix":".member."})
    if ("ContextKeyType" in params) body.append(prefix+".ContextKeyType", (params["ContextKeyType"] ?? '').toString());
}

function AccessKey_Parse(node: xmlP.XmlNode): s.AccessKey {
  return {
    ...node.strings({
      required: {"UserName":true,"AccessKeyId":true,"SecretAccessKey":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function Group_Parse(node: xmlP.XmlNode): s.Group {
  return {
    ...node.strings({
      required: {"Path":true,"GroupName":true,"GroupId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function InstanceProfile_Parse(node: xmlP.XmlNode): s.InstanceProfile {
  return {
    ...node.strings({
      required: {"Path":true,"InstanceProfileName":true,"InstanceProfileId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
    Roles: node.getList("Roles", "member").map(Role_Parse),
  };
}

function Role_Parse(node: xmlP.XmlNode): s.Role {
  return {
    ...node.strings({
      required: {"Path":true,"RoleName":true,"RoleId":true,"Arn":true},
      optional: {"AssumeRolePolicyDocument":true,"Description":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
    MaxSessionDuration: node.first("MaxSessionDuration", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    RoleLastUsed: node.first("RoleLastUsed", false, RoleLastUsed_Parse),
  };
}

function AttachedPermissionsBoundary_Parse(node: xmlP.XmlNode): s.AttachedPermissionsBoundary {
  return {
    ...node.strings({
      optional: {"PermissionsBoundaryArn":true},
    }),
    PermissionsBoundaryType: node.first("PermissionsBoundaryType", false, x => (x.content ?? '') as s.PermissionsBoundaryAttachmentType),
  };
}

function RoleLastUsed_Parse(node: xmlP.XmlNode): s.RoleLastUsed {
  return {
    ...node.strings({
      optional: {"Region":true},
    }),
    LastUsedDate: node.first("LastUsedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function LoginProfile_Parse(node: xmlP.XmlNode): s.LoginProfile {
  return {
    ...node.strings({
      required: {"UserName":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
    PasswordResetRequired: node.first("PasswordResetRequired", false, x => x.content === 'true'),
  };
}

function Policy_Parse(node: xmlP.XmlNode): s.Policy {
  return {
    ...node.strings({
      optional: {"PolicyName":true,"PolicyId":true,"Arn":true,"Path":true,"DefaultVersionId":true,"Description":true},
    }),
    AttachmentCount: node.first("AttachmentCount", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundaryUsageCount: node.first("PermissionsBoundaryUsageCount", false, x => parseInt(x.content ?? '0')),
    IsAttachable: node.first("IsAttachable", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function PolicyVersion_Parse(node: xmlP.XmlNode): s.PolicyVersion {
  return {
    ...node.strings({
      optional: {"Document":true,"VersionId":true},
    }),
    IsDefaultVersion: node.first("IsDefaultVersion", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ServiceSpecificCredential_Parse(node: xmlP.XmlNode): s.ServiceSpecificCredential {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceUserName":true,"ServicePassword":true,"ServiceSpecificCredentialId":true,"UserName":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
  };
}

function User_Parse(node: xmlP.XmlNode): s.User {
  return {
    ...node.strings({
      required: {"Path":true,"UserName":true,"UserId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
    PasswordLastUsed: node.first("PasswordLastUsed", false, x => xmlP.parseTimestamp(x.content)),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

function VirtualMFADevice_Parse(node: xmlP.XmlNode): s.VirtualMFADevice {
  return {
    ...node.strings({
      required: {"SerialNumber":true},
    }),
    Base32StringSeed: node.first("Base32StringSeed", false, x => parseBlob(x.content) ?? ''),
    QRCodePNG: node.first("QRCodePNG", false, x => parseBlob(x.content) ?? ''),
    User: node.first("User", false, User_Parse),
    EnableDate: node.first("EnableDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function AccessKeyLastUsed_Parse(node: xmlP.XmlNode): s.AccessKeyLastUsed {
  return {
    ...node.strings({
      required: {"ServiceName":true,"Region":true},
    }),
    LastUsedDate: node.first("LastUsedDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function UserDetail_Parse(node: xmlP.XmlNode): s.UserDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"UserName":true,"UserId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    UserPolicyList: node.getList("UserPolicyList", "member").map(PolicyDetail_Parse),
    GroupList: node.getList("GroupList", "member").map(x => x.content ?? ''),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

function PolicyDetail_Parse(node: xmlP.XmlNode): s.PolicyDetail {
  return node.strings({
    optional: {"PolicyName":true,"PolicyDocument":true},
  });
}

function AttachedPolicy_Parse(node: xmlP.XmlNode): s.AttachedPolicy {
  return node.strings({
    optional: {"PolicyName":true,"PolicyArn":true},
  });
}

function GroupDetail_Parse(node: xmlP.XmlNode): s.GroupDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"GroupName":true,"GroupId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    GroupPolicyList: node.getList("GroupPolicyList", "member").map(PolicyDetail_Parse),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
  };
}

function RoleDetail_Parse(node: xmlP.XmlNode): s.RoleDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"RoleName":true,"RoleId":true,"Arn":true,"AssumeRolePolicyDocument":true},
    }),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    InstanceProfileList: node.getList("InstanceProfileList", "member").map(InstanceProfile_Parse),
    RolePolicyList: node.getList("RolePolicyList", "member").map(PolicyDetail_Parse),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    RoleLastUsed: node.first("RoleLastUsed", false, RoleLastUsed_Parse),
  };
}

function ManagedPolicyDetail_Parse(node: xmlP.XmlNode): s.ManagedPolicyDetail {
  return {
    ...node.strings({
      optional: {"PolicyName":true,"PolicyId":true,"Arn":true,"Path":true,"DefaultVersionId":true,"Description":true},
    }),
    AttachmentCount: node.first("AttachmentCount", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundaryUsageCount: node.first("PermissionsBoundaryUsageCount", false, x => parseInt(x.content ?? '0')),
    IsAttachable: node.first("IsAttachable", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", false, x => xmlP.parseTimestamp(x.content)),
    PolicyVersionList: node.getList("PolicyVersionList", "member").map(PolicyVersion_Parse),
  };
}

function PasswordPolicy_Parse(node: xmlP.XmlNode): s.PasswordPolicy {
  return {
    MinimumPasswordLength: node.first("MinimumPasswordLength", false, x => parseInt(x.content ?? '0')),
    RequireSymbols: node.first("RequireSymbols", false, x => x.content === 'true'),
    RequireNumbers: node.first("RequireNumbers", false, x => x.content === 'true'),
    RequireUppercaseCharacters: node.first("RequireUppercaseCharacters", false, x => x.content === 'true'),
    RequireLowercaseCharacters: node.first("RequireLowercaseCharacters", false, x => x.content === 'true'),
    AllowUsersToChangePassword: node.first("AllowUsersToChangePassword", false, x => x.content === 'true'),
    ExpirePasswords: node.first("ExpirePasswords", false, x => x.content === 'true'),
    MaxPasswordAge: node.first("MaxPasswordAge", false, x => parseInt(x.content ?? '0')),
    PasswordReusePrevention: node.first("PasswordReusePrevention", false, x => parseInt(x.content ?? '0')),
    HardExpiry: node.first("HardExpiry", false, x => x.content === 'true'),
  };
}

function AccessDetail_Parse(node: xmlP.XmlNode): s.AccessDetail {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceNamespace":true},
      optional: {"Region":true,"EntityPath":true},
    }),
    LastAuthenticatedTime: node.first("LastAuthenticatedTime", false, x => xmlP.parseTimestamp(x.content)),
    TotalAuthenticatedEntities: node.first("TotalAuthenticatedEntities", false, x => parseInt(x.content ?? '0')),
  };
}

function ErrorDetails_Parse(node: xmlP.XmlNode): s.ErrorDetails {
  return node.strings({
    required: {"Message":true,"Code":true},
  });
}

function SSHPublicKey_Parse(node: xmlP.XmlNode): s.SSHPublicKey {
  return {
    ...node.strings({
      required: {"UserName":true,"SSHPublicKeyId":true,"Fingerprint":true,"SSHPublicKeyBody":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
    UploadDate: node.first("UploadDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ServerCertificate_Parse(node: xmlP.XmlNode): s.ServerCertificate {
  return {
    ...node.strings({
      required: {"CertificateBody":true},
      optional: {"CertificateChain":true},
    }),
    ServerCertificateMetadata: node.first("ServerCertificateMetadata", true, ServerCertificateMetadata_Parse),
  };
}

function ServerCertificateMetadata_Parse(node: xmlP.XmlNode): s.ServerCertificateMetadata {
  return {
    ...node.strings({
      required: {"Path":true,"ServerCertificateName":true,"ServerCertificateId":true,"Arn":true},
    }),
    UploadDate: node.first("UploadDate", false, x => xmlP.parseTimestamp(x.content)),
    Expiration: node.first("Expiration", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ServiceLastAccessed_Parse(node: xmlP.XmlNode): s.ServiceLastAccessed {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceNamespace":true},
      optional: {"LastAuthenticatedEntity":true,"LastAuthenticatedRegion":true},
    }),
    LastAuthenticated: node.first("LastAuthenticated", false, x => xmlP.parseTimestamp(x.content)),
    TotalAuthenticatedEntities: node.first("TotalAuthenticatedEntities", false, x => parseInt(x.content ?? '0')),
    TrackedActionsLastAccessed: node.getList("TrackedActionsLastAccessed", "member").map(TrackedActionLastAccessed_Parse),
  };
}

function TrackedActionLastAccessed_Parse(node: xmlP.XmlNode): s.TrackedActionLastAccessed {
  return {
    ...node.strings({
      optional: {"ActionName":true,"LastAccessedEntity":true,"LastAccessedRegion":true},
    }),
    LastAccessedTime: node.first("LastAccessedTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EntityDetails_Parse(node: xmlP.XmlNode): s.EntityDetails {
  return {
    EntityInfo: node.first("EntityInfo", true, EntityInfo_Parse),
    LastAuthenticated: node.first("LastAuthenticated", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EntityInfo_Parse(node: xmlP.XmlNode): s.EntityInfo {
  return {
    ...node.strings({
      required: {"Arn":true,"Name":true,"Id":true},
      optional: {"Path":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as s.policyOwnerEntityType),
  };
}

function DeletionTaskFailureReasonType_Parse(node: xmlP.XmlNode): s.DeletionTaskFailureReasonType {
  return {
    ...node.strings({
      optional: {"Reason":true},
    }),
    RoleUsageList: node.getList("RoleUsageList", "member").map(RoleUsageType_Parse),
  };
}

function RoleUsageType_Parse(node: xmlP.XmlNode): s.RoleUsageType {
  return {
    ...node.strings({
      optional: {"Region":true},
    }),
    Resources: node.getList("Resources", "member").map(x => x.content ?? ''),
  };
}

function AccessKeyMetadata_Parse(node: xmlP.XmlNode): s.AccessKeyMetadata {
  return {
    ...node.strings({
      optional: {"UserName":true,"AccessKeyId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.statusType),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function PolicyGroup_Parse(node: xmlP.XmlNode): s.PolicyGroup {
  return node.strings({
    optional: {"GroupName":true,"GroupId":true},
  });
}

function PolicyUser_Parse(node: xmlP.XmlNode): s.PolicyUser {
  return node.strings({
    optional: {"UserName":true,"UserId":true},
  });
}

function PolicyRole_Parse(node: xmlP.XmlNode): s.PolicyRole {
  return node.strings({
    optional: {"RoleName":true,"RoleId":true},
  });
}

function MFADevice_Parse(node: xmlP.XmlNode): s.MFADevice {
  return {
    ...node.strings({
      required: {"UserName":true,"SerialNumber":true},
    }),
    EnableDate: node.first("EnableDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function OpenIDConnectProviderListEntry_Parse(node: xmlP.XmlNode): s.OpenIDConnectProviderListEntry {
  return node.strings({
    optional: {"Arn":true},
  });
}

function ListPoliciesGrantingServiceAccessEntry_Parse(node: xmlP.XmlNode): s.ListPoliciesGrantingServiceAccessEntry {
  return {
    ...node.strings({
      optional: {"ServiceNamespace":true},
    }),
    Policies: node.getList("Policies", "member").map(PolicyGrantingServiceAccess_Parse),
  };
}

function PolicyGrantingServiceAccess_Parse(node: xmlP.XmlNode): s.PolicyGrantingServiceAccess {
  return {
    ...node.strings({
      required: {"PolicyName":true},
      optional: {"PolicyArn":true,"EntityName":true},
    }),
    PolicyType: node.first("PolicyType", true, x => (x.content ?? '') as s.policyType),
    EntityType: node.first("EntityType", false, x => (x.content ?? '') as s.policyOwnerEntityType),
  };
}

function SAMLProviderListEntry_Parse(node: xmlP.XmlNode): s.SAMLProviderListEntry {
  return {
    ...node.strings({
      optional: {"Arn":true},
    }),
    ValidUntil: node.first("ValidUntil", false, x => xmlP.parseTimestamp(x.content)),
    CreateDate: node.first("CreateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function SSHPublicKeyMetadata_Parse(node: xmlP.XmlNode): s.SSHPublicKeyMetadata {
  return {
    ...node.strings({
      required: {"UserName":true,"SSHPublicKeyId":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
    UploadDate: node.first("UploadDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function ServiceSpecificCredentialMetadata_Parse(node: xmlP.XmlNode): s.ServiceSpecificCredentialMetadata {
  return {
    ...node.strings({
      required: {"UserName":true,"ServiceUserName":true,"ServiceSpecificCredentialId":true,"ServiceName":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
    CreateDate: node.first("CreateDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function SigningCertificate_Parse(node: xmlP.XmlNode): s.SigningCertificate {
  return {
    ...node.strings({
      required: {"UserName":true,"CertificateId":true,"CertificateBody":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.statusType),
    UploadDate: node.first("UploadDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EvaluationResult_Parse(node: xmlP.XmlNode): s.EvaluationResult {
  return {
    ...node.strings({
      required: {"EvalActionName":true},
      optional: {"EvalResourceName":true},
    }),
    EvalDecision: node.first("EvalDecision", true, x => (x.content ?? '') as s.PolicyEvaluationDecisionType),
    MatchedStatements: node.getList("MatchedStatements", "member").map(Statement_Parse),
    MissingContextValues: node.getList("MissingContextValues", "member").map(x => x.content ?? ''),
    OrganizationsDecisionDetail: node.first("OrganizationsDecisionDetail", false, OrganizationsDecisionDetail_Parse),
    PermissionsBoundaryDecisionDetail: node.first("PermissionsBoundaryDecisionDetail", false, PermissionsBoundaryDecisionDetail_Parse),
    EvalDecisionDetails: xmlP.readXmlMap(node.getList("EvalDecisionDetails", "entry"), x => (x.content ?? '') as s.PolicyEvaluationDecisionType, {}),
    ResourceSpecificResults: node.getList("ResourceSpecificResults", "member").map(ResourceSpecificResult_Parse),
  };
}

function Statement_Parse(node: xmlP.XmlNode): s.Statement {
  return {
    ...node.strings({
      optional: {"SourcePolicyId":true},
    }),
    SourcePolicyType: node.first("SourcePolicyType", false, x => (x.content ?? '') as s.PolicySourceType),
    StartPosition: node.first("StartPosition", false, Position_Parse),
    EndPosition: node.first("EndPosition", false, Position_Parse),
  };
}

function Position_Parse(node: xmlP.XmlNode): s.Position {
  return {
    Line: node.first("Line", false, x => parseInt(x.content ?? '0')),
    Column: node.first("Column", false, x => parseInt(x.content ?? '0')),
  };
}

function OrganizationsDecisionDetail_Parse(node: xmlP.XmlNode): s.OrganizationsDecisionDetail {
  return {
    AllowedByOrganizations: node.first("AllowedByOrganizations", false, x => x.content === 'true'),
  };
}

function PermissionsBoundaryDecisionDetail_Parse(node: xmlP.XmlNode): s.PermissionsBoundaryDecisionDetail {
  return {
    AllowedByPermissionsBoundary: node.first("AllowedByPermissionsBoundary", false, x => x.content === 'true'),
  };
}

function ResourceSpecificResult_Parse(node: xmlP.XmlNode): s.ResourceSpecificResult {
  return {
    ...node.strings({
      required: {"EvalResourceName":true},
    }),
    EvalResourceDecision: node.first("EvalResourceDecision", true, x => (x.content ?? '') as s.PolicyEvaluationDecisionType),
    MatchedStatements: node.getList("MatchedStatements", "member").map(Statement_Parse),
    MissingContextValues: node.getList("MissingContextValues", "member").map(x => x.content ?? ''),
    EvalDecisionDetails: xmlP.readXmlMap(node.getList("EvalDecisionDetails", "entry"), x => (x.content ?? '') as s.PolicyEvaluationDecisionType, {}),
    PermissionsBoundaryDecisionDetail: node.first("PermissionsBoundaryDecisionDetail", false, PermissionsBoundaryDecisionDetail_Parse),
  };
}
