// Autogenerated API client for: AWS Identity and Access Management

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

import * as Base64 from "https://deno.land/x/base64@v0.2.1/mod.ts";

export default class IAM {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(IAM.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2010-05-08",
    "endpointPrefix": "iam",
    "globalEndpoint": "iam.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "IAM",
    "serviceFullName": "AWS Identity and Access Management",
    "serviceId": "IAM",
    "signatureVersion": "v4",
    "uid": "iam-2010-05-08",
    "xmlNamespace": "https://iam.amazonaws.com/doc/2010-05-08/"
  };

  async addClientIDToOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & AddClientIDToOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    body.append(prefix+"ClientID", (params["ClientID"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddClientIDToOpenIDConnectProvider",
    });
  }

  async addRoleToInstanceProfile(
    {abortSignal, ...params}: RequestConfig & AddRoleToInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddRoleToInstanceProfile",
    });
  }

  async addUserToGroup(
    {abortSignal, ...params}: RequestConfig & AddUserToGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddUserToGroup",
    });
  }

  async attachGroupPolicy(
    {abortSignal, ...params}: RequestConfig & AttachGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachGroupPolicy",
    });
  }

  async attachRolePolicy(
    {abortSignal, ...params}: RequestConfig & AttachRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachRolePolicy",
    });
  }

  async attachUserPolicy(
    {abortSignal, ...params}: RequestConfig & AttachUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachUserPolicy",
    });
  }

  async changePassword(
    {abortSignal, ...params}: RequestConfig & ChangePasswordRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OldPassword", (params["OldPassword"] ?? '').toString());
    body.append(prefix+"NewPassword", (params["NewPassword"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ChangePassword",
    });
  }

  async createAccessKey(
    {abortSignal, ...params}: RequestConfig & CreateAccessKeyRequest = {},
  ): Promise<CreateAccessKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAccessKey",
    });
    const xml = readXmlResult(await resp.text(), "CreateAccessKeyResult");
    return {
      AccessKey: xml.first("AccessKey", true, AccessKey_Parse),
    };
  }

  async createAccountAlias(
    {abortSignal, ...params}: RequestConfig & CreateAccountAliasRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccountAlias", (params["AccountAlias"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAccountAlias",
    });
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & CreateGroupRequest,
  ): Promise<CreateGroupResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateGroupResult");
    return {
      Group: xml.first("Group", true, Group_Parse),
    };
  }

  async createInstanceProfile(
    {abortSignal, ...params}: RequestConfig & CreateInstanceProfileRequest,
  ): Promise<CreateInstanceProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstanceProfile",
    });
    const xml = readXmlResult(await resp.text(), "CreateInstanceProfileResult");
    return {
      InstanceProfile: xml.first("InstanceProfile", true, InstanceProfile_Parse),
    };
  }

  async createLoginProfile(
    {abortSignal, ...params}: RequestConfig & CreateLoginProfileRequest,
  ): Promise<CreateLoginProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"Password", (params["Password"] ?? '').toString());
    if ("PasswordResetRequired" in params) body.append(prefix+"PasswordResetRequired", (params["PasswordResetRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoginProfile",
    });
    const xml = readXmlResult(await resp.text(), "CreateLoginProfileResult");
    return {
      LoginProfile: xml.first("LoginProfile", true, LoginProfile_Parse),
    };
  }

  async createOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & CreateOpenIDConnectProviderRequest,
  ): Promise<CreateOpenIDConnectProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Url", (params["Url"] ?? '').toString());
    if (params["ClientIDList"]) prt.appendList(body, prefix+"ClientIDList", params["ClientIDList"], {"entryPrefix":".member."})
    if (params["ThumbprintList"]) prt.appendList(body, prefix+"ThumbprintList", params["ThumbprintList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOpenIDConnectProvider",
    });
    const xml = readXmlResult(await resp.text(), "CreateOpenIDConnectProviderResult");
    return xml.strings({
      optional: {"OpenIDConnectProviderArn":true},
    });
  }

  async createPolicy(
    {abortSignal, ...params}: RequestConfig & CreatePolicyRequest,
  ): Promise<CreatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePolicy",
    });
    const xml = readXmlResult(await resp.text(), "CreatePolicyResult");
    return {
      Policy: xml.first("Policy", false, Policy_Parse),
    };
  }

  async createPolicyVersion(
    {abortSignal, ...params}: RequestConfig & CreatePolicyVersionRequest,
  ): Promise<CreatePolicyVersionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if ("SetAsDefault" in params) body.append(prefix+"SetAsDefault", (params["SetAsDefault"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePolicyVersion",
    });
    const xml = readXmlResult(await resp.text(), "CreatePolicyVersionResult");
    return {
      PolicyVersion: xml.first("PolicyVersion", false, PolicyVersion_Parse),
    };
  }

  async createRole(
    {abortSignal, ...params}: RequestConfig & CreateRoleRequest,
  ): Promise<CreateRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"AssumeRolePolicyDocument", (params["AssumeRolePolicyDocument"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("MaxSessionDuration" in params) body.append(prefix+"MaxSessionDuration", (params["MaxSessionDuration"] ?? '').toString());
    if ("PermissionsBoundary" in params) body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRole",
    });
    const xml = readXmlResult(await resp.text(), "CreateRoleResult");
    return {
      Role: xml.first("Role", true, Role_Parse),
    };
  }

  async createSAMLProvider(
    {abortSignal, ...params}: RequestConfig & CreateSAMLProviderRequest,
  ): Promise<CreateSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLMetadataDocument", (params["SAMLMetadataDocument"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSAMLProvider",
    });
    const xml = readXmlResult(await resp.text(), "CreateSAMLProviderResult");
    return xml.strings({
      optional: {"SAMLProviderArn":true},
    });
  }

  async createServiceLinkedRole(
    {abortSignal, ...params}: RequestConfig & CreateServiceLinkedRoleRequest,
  ): Promise<CreateServiceLinkedRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AWSServiceName", (params["AWSServiceName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("CustomSuffix" in params) body.append(prefix+"CustomSuffix", (params["CustomSuffix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateServiceLinkedRole",
    });
    const xml = readXmlResult(await resp.text(), "CreateServiceLinkedRoleResult");
    return {
      Role: xml.first("Role", false, Role_Parse),
    };
  }

  async createServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & CreateServiceSpecificCredentialRequest,
  ): Promise<CreateServiceSpecificCredentialResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateServiceSpecificCredential",
    });
    const xml = readXmlResult(await resp.text(), "CreateServiceSpecificCredentialResult");
    return {
      ServiceSpecificCredential: xml.first("ServiceSpecificCredential", false, ServiceSpecificCredential_Parse),
    };
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & CreateUserRequest,
  ): Promise<CreateUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("PermissionsBoundary" in params) body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUser",
    });
    const xml = readXmlResult(await resp.text(), "CreateUserResult");
    return {
      User: xml.first("User", false, User_Parse),
    };
  }

  async createVirtualMFADevice(
    {abortSignal, ...params}: RequestConfig & CreateVirtualMFADeviceRequest,
  ): Promise<CreateVirtualMFADeviceResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"VirtualMFADeviceName", (params["VirtualMFADeviceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVirtualMFADevice",
    });
    const xml = readXmlResult(await resp.text(), "CreateVirtualMFADeviceResult");
    return {
      VirtualMFADevice: xml.first("VirtualMFADevice", true, VirtualMFADevice_Parse),
    };
  }

  async deactivateMFADevice(
    {abortSignal, ...params}: RequestConfig & DeactivateMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeactivateMFADevice",
    });
  }

  async deleteAccessKey(
    {abortSignal, ...params}: RequestConfig & DeleteAccessKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccessKey",
    });
  }

  async deleteAccountAlias(
    {abortSignal, ...params}: RequestConfig & DeleteAccountAliasRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccountAlias", (params["AccountAlias"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccountAlias",
    });
  }

  async deleteAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<void> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAccountPasswordPolicy",
    });
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & DeleteGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroup",
    });
  }

  async deleteGroupPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroupPolicy",
    });
  }

  async deleteInstanceProfile(
    {abortSignal, ...params}: RequestConfig & DeleteInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstanceProfile",
    });
  }

  async deleteLoginProfile(
    {abortSignal, ...params}: RequestConfig & DeleteLoginProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoginProfile",
    });
  }

  async deleteOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & DeleteOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOpenIDConnectProvider",
    });
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & DeletePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicy",
    });
  }

  async deletePolicyVersion(
    {abortSignal, ...params}: RequestConfig & DeletePolicyVersionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicyVersion",
    });
  }

  async deleteRole(
    {abortSignal, ...params}: RequestConfig & DeleteRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRole",
    });
  }

  async deleteRolePermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & DeleteRolePermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRolePermissionsBoundary",
    });
  }

  async deleteRolePolicy(
    {abortSignal, ...params}: RequestConfig & DeleteRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRolePolicy",
    });
  }

  async deleteSAMLProvider(
    {abortSignal, ...params}: RequestConfig & DeleteSAMLProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSAMLProvider",
    });
  }

  async deleteSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & DeleteSSHPublicKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSSHPublicKey",
    });
  }

  async deleteServerCertificate(
    {abortSignal, ...params}: RequestConfig & DeleteServerCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServerCertificate",
    });
  }

  async deleteServiceLinkedRole(
    {abortSignal, ...params}: RequestConfig & DeleteServiceLinkedRoleRequest,
  ): Promise<DeleteServiceLinkedRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServiceLinkedRole",
    });
    const xml = readXmlResult(await resp.text(), "DeleteServiceLinkedRoleResult");
    return xml.strings({
      required: {"DeletionTaskId":true},
    });
  }

  async deleteServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & DeleteServiceSpecificCredentialRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteServiceSpecificCredential",
    });
  }

  async deleteSigningCertificate(
    {abortSignal, ...params}: RequestConfig & DeleteSigningCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateId", (params["CertificateId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSigningCertificate",
    });
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & DeleteUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
  }

  async deleteUserPermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & DeleteUserPermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPermissionsBoundary",
    });
  }

  async deleteUserPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPolicy",
    });
  }

  async deleteVirtualMFADevice(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVirtualMFADevice",
    });
  }

  async detachGroupPolicy(
    {abortSignal, ...params}: RequestConfig & DetachGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachGroupPolicy",
    });
  }

  async detachRolePolicy(
    {abortSignal, ...params}: RequestConfig & DetachRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachRolePolicy",
    });
  }

  async detachUserPolicy(
    {abortSignal, ...params}: RequestConfig & DetachUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachUserPolicy",
    });
  }

  async enableMFADevice(
    {abortSignal, ...params}: RequestConfig & EnableMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    body.append(prefix+"AuthenticationCode1", (params["AuthenticationCode1"] ?? '').toString());
    body.append(prefix+"AuthenticationCode2", (params["AuthenticationCode2"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableMFADevice",
    });
  }

  async generateCredentialReport(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GenerateCredentialReportResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GenerateCredentialReport",
    });
    const xml = readXmlResult(await resp.text(), "GenerateCredentialReportResult");
    return {
      ...xml.strings({
        optional: {"Description":true},
      }),
      State: xml.first("State", false, x => (x.content ?? '') as ReportStateType),
    };
  }

  async generateOrganizationsAccessReport(
    {abortSignal, ...params}: RequestConfig & GenerateOrganizationsAccessReportRequest,
  ): Promise<GenerateOrganizationsAccessReportResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EntityPath", (params["EntityPath"] ?? '').toString());
    if ("OrganizationsPolicyId" in params) body.append(prefix+"OrganizationsPolicyId", (params["OrganizationsPolicyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateOrganizationsAccessReport",
    });
    const xml = readXmlResult(await resp.text(), "GenerateOrganizationsAccessReportResult");
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async generateServiceLastAccessedDetails(
    {abortSignal, ...params}: RequestConfig & GenerateServiceLastAccessedDetailsRequest,
  ): Promise<GenerateServiceLastAccessedDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Granularity" in params) body.append(prefix+"Granularity", (params["Granularity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateServiceLastAccessedDetails",
    });
    const xml = readXmlResult(await resp.text(), "GenerateServiceLastAccessedDetailsResult");
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async getAccessKeyLastUsed(
    {abortSignal, ...params}: RequestConfig & GetAccessKeyLastUsedRequest,
  ): Promise<GetAccessKeyLastUsedResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccessKeyLastUsed",
    });
    const xml = readXmlResult(await resp.text(), "GetAccessKeyLastUsedResult");
    return {
      ...xml.strings({
        optional: {"UserName":true},
      }),
      AccessKeyLastUsed: xml.first("AccessKeyLastUsed", false, AccessKeyLastUsed_Parse),
    };
  }

  async getAccountAuthorizationDetails(
    {abortSignal, ...params}: RequestConfig & GetAccountAuthorizationDetailsRequest = {},
  ): Promise<GetAccountAuthorizationDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) prt.appendList(body, prefix+"Filter", params["Filter"], {"entryPrefix":".member."})
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccountAuthorizationDetails",
    });
    const xml = readXmlResult(await resp.text(), "GetAccountAuthorizationDetailsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UserDetailList: xml.getList("UserDetailList", "member").map(UserDetail_Parse),
      GroupDetailList: xml.getList("GroupDetailList", "member").map(GroupDetail_Parse),
      RoleDetailList: xml.getList("RoleDetailList", "member").map(RoleDetail_Parse),
      Policies: xml.getList("Policies", "member").map(ManagedPolicyDetail_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async getAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetAccountPasswordPolicyResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountPasswordPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetAccountPasswordPolicyResult");
    return {
      PasswordPolicy: xml.first("PasswordPolicy", true, PasswordPolicy_Parse),
    };
  }

  async getAccountSummary(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetAccountSummaryResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountSummary",
    });
    const xml = readXmlResult(await resp.text(), "GetAccountSummaryResult");
    return {
      SummaryMap: readXmlMap(xml.getList("SummaryMap", "entry"), x => parseInt(x.content ?? '0'), {}),
    };
  }

  async getContextKeysForCustomPolicy(
    {abortSignal, ...params}: RequestConfig & GetContextKeysForCustomPolicyRequest,
  ): Promise<GetContextKeysForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PolicyInputList"]) prt.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContextKeysForCustomPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetContextKeysForCustomPolicyResult");
    return {
      ContextKeyNames: xml.getList("ContextKeyNames", "member").map(x => x.content ?? ''),
    };
  }

  async getContextKeysForPrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & GetContextKeysForPrincipalPolicyRequest,
  ): Promise<GetContextKeysForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicySourceArn", (params["PolicySourceArn"] ?? '').toString());
    if (params["PolicyInputList"]) prt.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContextKeysForPrincipalPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetContextKeysForPrincipalPolicyResult");
    return {
      ContextKeyNames: xml.getList("ContextKeyNames", "member").map(x => x.content ?? ''),
    };
  }

  async getCredentialReport(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetCredentialReportResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCredentialReport",
    });
    const xml = readXmlResult(await resp.text(), "GetCredentialReportResult");
    return {
      Content: xml.first("Content", false, x => Base64.toUint8Array(x.content ?? '')),
      ReportFormat: xml.first("ReportFormat", false, x => (x.content ?? '') as ReportFormatType),
      GeneratedTime: xml.first("GeneratedTime", false, x => parseTimestamp(x.content)),
    };
  }

  async getGroup(
    {abortSignal, ...params}: RequestConfig & GetGroupRequest,
  ): Promise<GetGroupResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroup",
    });
    const xml = readXmlResult(await resp.text(), "GetGroupResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Group: xml.first("Group", true, Group_Parse),
      Users: xml.getList("Users", "member").map(User_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async getGroupPolicy(
    {abortSignal, ...params}: RequestConfig & GetGroupPolicyRequest,
  ): Promise<GetGroupPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroupPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetGroupPolicyResult");
    return xml.strings({
      required: {"GroupName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async getInstanceProfile(
    {abortSignal, ...params}: RequestConfig & GetInstanceProfileRequest,
  ): Promise<GetInstanceProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceProfile",
    });
    const xml = readXmlResult(await resp.text(), "GetInstanceProfileResult");
    return {
      InstanceProfile: xml.first("InstanceProfile", true, InstanceProfile_Parse),
    };
  }

  async getLoginProfile(
    {abortSignal, ...params}: RequestConfig & GetLoginProfileRequest,
  ): Promise<GetLoginProfileResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoginProfile",
    });
    const xml = readXmlResult(await resp.text(), "GetLoginProfileResult");
    return {
      LoginProfile: xml.first("LoginProfile", true, LoginProfile_Parse),
    };
  }

  async getOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & GetOpenIDConnectProviderRequest,
  ): Promise<GetOpenIDConnectProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOpenIDConnectProvider",
    });
    const xml = readXmlResult(await resp.text(), "GetOpenIDConnectProviderResult");
    return {
      ...xml.strings({
        optional: {"Url":true},
      }),
      ClientIDList: xml.getList("ClientIDList", "member").map(x => x.content ?? ''),
      ThumbprintList: xml.getList("ThumbprintList", "member").map(x => x.content ?? ''),
      CreateDate: xml.first("CreateDate", false, x => parseTimestamp(x.content)),
    };
  }

  async getOrganizationsAccessReport(
    {abortSignal, ...params}: RequestConfig & GetOrganizationsAccessReportRequest,
  ): Promise<GetOrganizationsAccessReportResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("SortKey" in params) body.append(prefix+"SortKey", (params["SortKey"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOrganizationsAccessReport",
    });
    const xml = readXmlResult(await resp.text(), "GetOrganizationsAccessReportResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as jobStatusType),
      JobCreationDate: xml.first("JobCreationDate", true, x => parseTimestamp(x.content)),
      JobCompletionDate: xml.first("JobCompletionDate", false, x => parseTimestamp(x.content)),
      NumberOfServicesAccessible: xml.first("NumberOfServicesAccessible", false, x => parseInt(x.content ?? '0')),
      NumberOfServicesNotAccessed: xml.first("NumberOfServicesNotAccessed", false, x => parseInt(x.content ?? '0')),
      AccessDetails: xml.getList("AccessDetails", "member").map(AccessDetail_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      ErrorDetails: xml.first("ErrorDetails", false, ErrorDetails_Parse),
    };
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & GetPolicyRequest,
  ): Promise<GetPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetPolicyResult");
    return {
      Policy: xml.first("Policy", false, Policy_Parse),
    };
  }

  async getPolicyVersion(
    {abortSignal, ...params}: RequestConfig & GetPolicyVersionRequest,
  ): Promise<GetPolicyVersionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPolicyVersion",
    });
    const xml = readXmlResult(await resp.text(), "GetPolicyVersionResult");
    return {
      PolicyVersion: xml.first("PolicyVersion", false, PolicyVersion_Parse),
    };
  }

  async getRole(
    {abortSignal, ...params}: RequestConfig & GetRoleRequest,
  ): Promise<GetRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRole",
    });
    const xml = readXmlResult(await resp.text(), "GetRoleResult");
    return {
      Role: xml.first("Role", true, Role_Parse),
    };
  }

  async getRolePolicy(
    {abortSignal, ...params}: RequestConfig & GetRolePolicyRequest,
  ): Promise<GetRolePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRolePolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetRolePolicyResult");
    return xml.strings({
      required: {"RoleName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async getSAMLProvider(
    {abortSignal, ...params}: RequestConfig & GetSAMLProviderRequest,
  ): Promise<GetSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSAMLProvider",
    });
    const xml = readXmlResult(await resp.text(), "GetSAMLProviderResult");
    return {
      ...xml.strings({
        optional: {"SAMLMetadataDocument":true},
      }),
      CreateDate: xml.first("CreateDate", false, x => parseTimestamp(x.content)),
      ValidUntil: xml.first("ValidUntil", false, x => parseTimestamp(x.content)),
    };
  }

  async getSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & GetSSHPublicKeyRequest,
  ): Promise<GetSSHPublicKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    body.append(prefix+"Encoding", (params["Encoding"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSSHPublicKey",
    });
    const xml = readXmlResult(await resp.text(), "GetSSHPublicKeyResult");
    return {
      SSHPublicKey: xml.first("SSHPublicKey", false, SSHPublicKey_Parse),
    };
  }

  async getServerCertificate(
    {abortSignal, ...params}: RequestConfig & GetServerCertificateRequest,
  ): Promise<GetServerCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServerCertificate",
    });
    const xml = readXmlResult(await resp.text(), "GetServerCertificateResult");
    return {
      ServerCertificate: xml.first("ServerCertificate", true, ServerCertificate_Parse),
    };
  }

  async getServiceLastAccessedDetails(
    {abortSignal, ...params}: RequestConfig & GetServiceLastAccessedDetailsRequest,
  ): Promise<GetServiceLastAccessedDetailsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLastAccessedDetails",
    });
    const xml = readXmlResult(await resp.text(), "GetServiceLastAccessedDetailsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as jobStatusType),
      JobType: xml.first("JobType", false, x => (x.content ?? '') as AccessAdvisorUsageGranularityType),
      JobCreationDate: xml.first("JobCreationDate", true, x => parseTimestamp(x.content)),
      ServicesLastAccessed: xml.getList("ServicesLastAccessed", "member").map(ServiceLastAccessed_Parse),
      JobCompletionDate: xml.first("JobCompletionDate", true, x => parseTimestamp(x.content)),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Error: xml.first("Error", false, ErrorDetails_Parse),
    };
  }

  async getServiceLastAccessedDetailsWithEntities(
    {abortSignal, ...params}: RequestConfig & GetServiceLastAccessedDetailsWithEntitiesRequest,
  ): Promise<GetServiceLastAccessedDetailsWithEntitiesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"JobId", (params["JobId"] ?? '').toString());
    body.append(prefix+"ServiceNamespace", (params["ServiceNamespace"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLastAccessedDetailsWithEntities",
    });
    const xml = readXmlResult(await resp.text(), "GetServiceLastAccessedDetailsWithEntitiesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      JobStatus: xml.first("JobStatus", true, x => (x.content ?? '') as jobStatusType),
      JobCreationDate: xml.first("JobCreationDate", true, x => parseTimestamp(x.content)),
      JobCompletionDate: xml.first("JobCompletionDate", true, x => parseTimestamp(x.content)),
      EntityDetailsList: xml.getList("EntityDetailsList", "member").map(EntityDetails_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Error: xml.first("Error", false, ErrorDetails_Parse),
    };
  }

  async getServiceLinkedRoleDeletionStatus(
    {abortSignal, ...params}: RequestConfig & GetServiceLinkedRoleDeletionStatusRequest,
  ): Promise<GetServiceLinkedRoleDeletionStatusResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DeletionTaskId", (params["DeletionTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceLinkedRoleDeletionStatus",
    });
    const xml = readXmlResult(await resp.text(), "GetServiceLinkedRoleDeletionStatusResult");
    return {
      Status: xml.first("Status", true, x => (x.content ?? '') as DeletionTaskStatusType),
      Reason: xml.first("Reason", false, DeletionTaskFailureReasonType_Parse),
    };
  }

  async getUser(
    {abortSignal, ...params}: RequestConfig & GetUserRequest = {},
  ): Promise<GetUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUser",
    });
    const xml = readXmlResult(await resp.text(), "GetUserResult");
    return {
      User: xml.first("User", true, User_Parse),
    };
  }

  async getUserPolicy(
    {abortSignal, ...params}: RequestConfig & GetUserPolicyRequest,
  ): Promise<GetUserPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserPolicy",
    });
    const xml = readXmlResult(await resp.text(), "GetUserPolicyResult");
    return xml.strings({
      required: {"UserName":true,"PolicyName":true,"PolicyDocument":true},
    });
  }

  async listAccessKeys(
    {abortSignal, ...params}: RequestConfig & ListAccessKeysRequest = {},
  ): Promise<ListAccessKeysResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccessKeys",
    });
    const xml = readXmlResult(await resp.text(), "ListAccessKeysResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AccessKeyMetadata: xml.getList("AccessKeyMetadata", "member").map(AccessKeyMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAccountAliases(
    {abortSignal, ...params}: RequestConfig & ListAccountAliasesRequest = {},
  ): Promise<ListAccountAliasesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccountAliases",
    });
    const xml = readXmlResult(await resp.text(), "ListAccountAliasesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AccountAliases: xml.getList("AccountAliases", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedGroupPolicies(
    {abortSignal, ...params}: RequestConfig & ListAttachedGroupPoliciesRequest,
  ): Promise<ListAttachedGroupPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedGroupPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListAttachedGroupPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedRolePolicies(
    {abortSignal, ...params}: RequestConfig & ListAttachedRolePoliciesRequest,
  ): Promise<ListAttachedRolePoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedRolePolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListAttachedRolePoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listAttachedUserPolicies(
    {abortSignal, ...params}: RequestConfig & ListAttachedUserPoliciesRequest,
  ): Promise<ListAttachedUserPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttachedUserPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListAttachedUserPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      AttachedPolicies: xml.getList("AttachedPolicies", "member").map(AttachedPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listEntitiesForPolicy(
    {abortSignal, ...params}: RequestConfig & ListEntitiesForPolicyRequest,
  ): Promise<ListEntitiesForPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    if ("EntityFilter" in params) body.append(prefix+"EntityFilter", (params["EntityFilter"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("PolicyUsageFilter" in params) body.append(prefix+"PolicyUsageFilter", (params["PolicyUsageFilter"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEntitiesForPolicy",
    });
    const xml = readXmlResult(await resp.text(), "ListEntitiesForPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyGroups: xml.getList("PolicyGroups", "member").map(PolicyGroup_Parse),
      PolicyUsers: xml.getList("PolicyUsers", "member").map(PolicyUser_Parse),
      PolicyRoles: xml.getList("PolicyRoles", "member").map(PolicyRole_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroupPolicies(
    {abortSignal, ...params}: RequestConfig & ListGroupPoliciesRequest,
  ): Promise<ListGroupPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroupPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListGroupPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroups(
    {abortSignal, ...params}: RequestConfig & ListGroupsRequest = {},
  ): Promise<ListGroupsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroups",
    });
    const xml = readXmlResult(await resp.text(), "ListGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Groups: xml.getList("Groups", "member").map(Group_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listGroupsForUser(
    {abortSignal, ...params}: RequestConfig & ListGroupsForUserRequest,
  ): Promise<ListGroupsForUserResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroupsForUser",
    });
    const xml = readXmlResult(await resp.text(), "ListGroupsForUserResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Groups: xml.getList("Groups", "member").map(Group_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listInstanceProfiles(
    {abortSignal, ...params}: RequestConfig & ListInstanceProfilesRequest = {},
  ): Promise<ListInstanceProfilesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceProfiles",
    });
    const xml = readXmlResult(await resp.text(), "ListInstanceProfilesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      InstanceProfiles: xml.getList("InstanceProfiles", "member").map(InstanceProfile_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listInstanceProfilesForRole(
    {abortSignal, ...params}: RequestConfig & ListInstanceProfilesForRoleRequest,
  ): Promise<ListInstanceProfilesForRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceProfilesForRole",
    });
    const xml = readXmlResult(await resp.text(), "ListInstanceProfilesForRoleResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      InstanceProfiles: xml.getList("InstanceProfiles", "member").map(InstanceProfile_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listMFADevices(
    {abortSignal, ...params}: RequestConfig & ListMFADevicesRequest = {},
  ): Promise<ListMFADevicesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMFADevices",
    });
    const xml = readXmlResult(await resp.text(), "ListMFADevicesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      MFADevices: xml.getList("MFADevices", "member").map(MFADevice_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listOpenIDConnectProviders(
    {abortSignal, ...params}: RequestConfig & ListOpenIDConnectProvidersRequest = {},
  ): Promise<ListOpenIDConnectProvidersResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOpenIDConnectProviders",
    });
    const xml = readXmlResult(await resp.text(), "ListOpenIDConnectProvidersResult");
    return {
      OpenIDConnectProviderList: xml.getList("OpenIDConnectProviderList", "member").map(OpenIDConnectProviderListEntry_Parse),
    };
  }

  async listPolicies(
    {abortSignal, ...params}: RequestConfig & ListPoliciesRequest = {},
  ): Promise<ListPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Scope" in params) body.append(prefix+"Scope", (params["Scope"] ?? '').toString());
    if ("OnlyAttached" in params) body.append(prefix+"OnlyAttached", (params["OnlyAttached"] ?? '').toString());
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("PolicyUsageFilter" in params) body.append(prefix+"PolicyUsageFilter", (params["PolicyUsageFilter"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Policies: xml.getList("Policies", "member").map(Policy_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listPoliciesGrantingServiceAccess(
    {abortSignal, ...params}: RequestConfig & ListPoliciesGrantingServiceAccessRequest,
  ): Promise<ListPoliciesGrantingServiceAccessResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if (params["ServiceNamespaces"]) prt.appendList(body, prefix+"ServiceNamespaces", params["ServiceNamespaces"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPoliciesGrantingServiceAccess",
    });
    const xml = readXmlResult(await resp.text(), "ListPoliciesGrantingServiceAccessResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PoliciesGrantingServiceAccess: xml.getList("PoliciesGrantingServiceAccess", "member").map(ListPoliciesGrantingServiceAccessEntry_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listPolicyVersions(
    {abortSignal, ...params}: RequestConfig & ListPolicyVersionsRequest,
  ): Promise<ListPolicyVersionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPolicyVersions",
    });
    const xml = readXmlResult(await resp.text(), "ListPolicyVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Versions: xml.getList("Versions", "member").map(PolicyVersion_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRolePolicies(
    {abortSignal, ...params}: RequestConfig & ListRolePoliciesRequest,
  ): Promise<ListRolePoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRolePolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListRolePoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRoleTags(
    {abortSignal, ...params}: RequestConfig & ListRoleTagsRequest,
  ): Promise<ListRoleTagsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRoleTags",
    });
    const xml = readXmlResult(await resp.text(), "ListRoleTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listRoles(
    {abortSignal, ...params}: RequestConfig & ListRolesRequest = {},
  ): Promise<ListRolesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRoles",
    });
    const xml = readXmlResult(await resp.text(), "ListRolesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Roles: xml.getList("Roles", "member").map(Role_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listSAMLProviders(
    {abortSignal, ...params}: RequestConfig & ListSAMLProvidersRequest = {},
  ): Promise<ListSAMLProvidersResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSAMLProviders",
    });
    const xml = readXmlResult(await resp.text(), "ListSAMLProvidersResult");
    return {
      SAMLProviderList: xml.getList("SAMLProviderList", "member").map(SAMLProviderListEntry_Parse),
    };
  }

  async listSSHPublicKeys(
    {abortSignal, ...params}: RequestConfig & ListSSHPublicKeysRequest = {},
  ): Promise<ListSSHPublicKeysResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSSHPublicKeys",
    });
    const xml = readXmlResult(await resp.text(), "ListSSHPublicKeysResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      SSHPublicKeys: xml.getList("SSHPublicKeys", "member").map(SSHPublicKeyMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listServerCertificates(
    {abortSignal, ...params}: RequestConfig & ListServerCertificatesRequest = {},
  ): Promise<ListServerCertificatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServerCertificates",
    });
    const xml = readXmlResult(await resp.text(), "ListServerCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ServerCertificateMetadataList: xml.getList("ServerCertificateMetadataList", "member").map(ServerCertificateMetadata_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listServiceSpecificCredentials(
    {abortSignal, ...params}: RequestConfig & ListServiceSpecificCredentialsRequest = {},
  ): Promise<ListServiceSpecificCredentialsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("ServiceName" in params) body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServiceSpecificCredentials",
    });
    const xml = readXmlResult(await resp.text(), "ListServiceSpecificCredentialsResult");
    return {
      ServiceSpecificCredentials: xml.getList("ServiceSpecificCredentials", "member").map(ServiceSpecificCredentialMetadata_Parse),
    };
  }

  async listSigningCertificates(
    {abortSignal, ...params}: RequestConfig & ListSigningCertificatesRequest = {},
  ): Promise<ListSigningCertificatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSigningCertificates",
    });
    const xml = readXmlResult(await resp.text(), "ListSigningCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Certificates: xml.getList("Certificates", "member").map(SigningCertificate_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUserPolicies(
    {abortSignal, ...params}: RequestConfig & ListUserPoliciesRequest,
  ): Promise<ListUserPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListUserPoliciesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUserTags(
    {abortSignal, ...params}: RequestConfig & ListUserTagsRequest,
  ): Promise<ListUserTagsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserTags",
    });
    const xml = readXmlResult(await resp.text(), "ListUserTagsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listUsers(
    {abortSignal, ...params}: RequestConfig & ListUsersRequest = {},
  ): Promise<ListUsersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PathPrefix" in params) body.append(prefix+"PathPrefix", (params["PathPrefix"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUsers",
    });
    const xml = readXmlResult(await resp.text(), "ListUsersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Users: xml.getList("Users", "member").map(User_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listVirtualMFADevices(
    {abortSignal, ...params}: RequestConfig & ListVirtualMFADevicesRequest = {},
  ): Promise<ListVirtualMFADevicesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AssignmentStatus" in params) body.append(prefix+"AssignmentStatus", (params["AssignmentStatus"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVirtualMFADevices",
    });
    const xml = readXmlResult(await resp.text(), "ListVirtualMFADevicesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      VirtualMFADevices: xml.getList("VirtualMFADevices", "member").map(VirtualMFADevice_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async putGroupPolicy(
    {abortSignal, ...params}: RequestConfig & PutGroupPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutGroupPolicy",
    });
  }

  async putRolePermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & PutRolePermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRolePermissionsBoundary",
    });
  }

  async putRolePolicy(
    {abortSignal, ...params}: RequestConfig & PutRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutRolePolicy",
    });
  }

  async putUserPermissionsBoundary(
    {abortSignal, ...params}: RequestConfig & PutUserPermissionsBoundaryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PermissionsBoundary", (params["PermissionsBoundary"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutUserPermissionsBoundary",
    });
  }

  async putUserPolicy(
    {abortSignal, ...params}: RequestConfig & PutUserPolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutUserPolicy",
    });
  }

  async removeClientIDFromOpenIDConnectProvider(
    {abortSignal, ...params}: RequestConfig & RemoveClientIDFromOpenIDConnectProviderRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    body.append(prefix+"ClientID", (params["ClientID"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveClientIDFromOpenIDConnectProvider",
    });
  }

  async removeRoleFromInstanceProfile(
    {abortSignal, ...params}: RequestConfig & RemoveRoleFromInstanceProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceProfileName", (params["InstanceProfileName"] ?? '').toString());
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveRoleFromInstanceProfile",
    });
  }

  async removeUserFromGroup(
    {abortSignal, ...params}: RequestConfig & RemoveUserFromGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveUserFromGroup",
    });
  }

  async resetServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & ResetServiceSpecificCredentialRequest,
  ): Promise<ResetServiceSpecificCredentialResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetServiceSpecificCredential",
    });
    const xml = readXmlResult(await resp.text(), "ResetServiceSpecificCredentialResult");
    return {
      ServiceSpecificCredential: xml.first("ServiceSpecificCredential", false, ServiceSpecificCredential_Parse),
    };
  }

  async resyncMFADevice(
    {abortSignal, ...params}: RequestConfig & ResyncMFADeviceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SerialNumber", (params["SerialNumber"] ?? '').toString());
    body.append(prefix+"AuthenticationCode1", (params["AuthenticationCode1"] ?? '').toString());
    body.append(prefix+"AuthenticationCode2", (params["AuthenticationCode2"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResyncMFADevice",
    });
  }

  async setDefaultPolicyVersion(
    {abortSignal, ...params}: RequestConfig & SetDefaultPolicyVersionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicyArn", (params["PolicyArn"] ?? '').toString());
    body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDefaultPolicyVersion",
    });
  }

  async setSecurityTokenServicePreferences(
    {abortSignal, ...params}: RequestConfig & SetSecurityTokenServicePreferencesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalEndpointTokenVersion", (params["GlobalEndpointTokenVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSecurityTokenServicePreferences",
    });
  }

  async simulateCustomPolicy(
    {abortSignal, ...params}: RequestConfig & SimulateCustomPolicyRequest,
  ): Promise<SimulatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PolicyInputList"]) prt.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    if (params["PermissionsBoundaryPolicyInputList"]) prt.appendList(body, prefix+"PermissionsBoundaryPolicyInputList", params["PermissionsBoundaryPolicyInputList"], {"entryPrefix":".member."})
    if (params["ActionNames"]) prt.appendList(body, prefix+"ActionNames", params["ActionNames"], {"entryPrefix":".member."})
    if (params["ResourceArns"]) prt.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if ("ResourcePolicy" in params) body.append(prefix+"ResourcePolicy", (params["ResourcePolicy"] ?? '').toString());
    if ("ResourceOwner" in params) body.append(prefix+"ResourceOwner", (params["ResourceOwner"] ?? '').toString());
    if ("CallerArn" in params) body.append(prefix+"CallerArn", (params["CallerArn"] ?? '').toString());
    if (params["ContextEntries"]) prt.appendList(body, prefix+"ContextEntries", params["ContextEntries"], {"appender":ContextEntry_Serialize,"entryPrefix":".member."})
    if ("ResourceHandlingOption" in params) body.append(prefix+"ResourceHandlingOption", (params["ResourceHandlingOption"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SimulateCustomPolicy",
    });
    const xml = readXmlResult(await resp.text(), "SimulateCustomPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EvaluationResults: xml.getList("EvaluationResults", "member").map(EvaluationResult_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async simulatePrincipalPolicy(
    {abortSignal, ...params}: RequestConfig & SimulatePrincipalPolicyRequest,
  ): Promise<SimulatePolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PolicySourceArn", (params["PolicySourceArn"] ?? '').toString());
    if (params["PolicyInputList"]) prt.appendList(body, prefix+"PolicyInputList", params["PolicyInputList"], {"entryPrefix":".member."})
    if (params["PermissionsBoundaryPolicyInputList"]) prt.appendList(body, prefix+"PermissionsBoundaryPolicyInputList", params["PermissionsBoundaryPolicyInputList"], {"entryPrefix":".member."})
    if (params["ActionNames"]) prt.appendList(body, prefix+"ActionNames", params["ActionNames"], {"entryPrefix":".member."})
    if (params["ResourceArns"]) prt.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if ("ResourcePolicy" in params) body.append(prefix+"ResourcePolicy", (params["ResourcePolicy"] ?? '').toString());
    if ("ResourceOwner" in params) body.append(prefix+"ResourceOwner", (params["ResourceOwner"] ?? '').toString());
    if ("CallerArn" in params) body.append(prefix+"CallerArn", (params["CallerArn"] ?? '').toString());
    if (params["ContextEntries"]) prt.appendList(body, prefix+"ContextEntries", params["ContextEntries"], {"appender":ContextEntry_Serialize,"entryPrefix":".member."})
    if ("ResourceHandlingOption" in params) body.append(prefix+"ResourceHandlingOption", (params["ResourceHandlingOption"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SimulatePrincipalPolicy",
    });
    const xml = readXmlResult(await resp.text(), "SimulatePrincipalPolicyResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EvaluationResults: xml.getList("EvaluationResults", "member").map(EvaluationResult_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async tagRole(
    {abortSignal, ...params}: RequestConfig & TagRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagRole",
    });
  }

  async tagUser(
    {abortSignal, ...params}: RequestConfig & TagUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagUser",
    });
  }

  async untagRole(
    {abortSignal, ...params}: RequestConfig & UntagRoleRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagKeys"]) prt.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagRole",
    });
  }

  async untagUser(
    {abortSignal, ...params}: RequestConfig & UntagUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if (params["TagKeys"]) prt.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagUser",
    });
  }

  async updateAccessKey(
    {abortSignal, ...params}: RequestConfig & UpdateAccessKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"AccessKeyId", (params["AccessKeyId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccessKey",
    });
  }

  async updateAccountPasswordPolicy(
    {abortSignal, ...params}: RequestConfig & UpdateAccountPasswordPolicyRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MinimumPasswordLength" in params) body.append(prefix+"MinimumPasswordLength", (params["MinimumPasswordLength"] ?? '').toString());
    if ("RequireSymbols" in params) body.append(prefix+"RequireSymbols", (params["RequireSymbols"] ?? '').toString());
    if ("RequireNumbers" in params) body.append(prefix+"RequireNumbers", (params["RequireNumbers"] ?? '').toString());
    if ("RequireUppercaseCharacters" in params) body.append(prefix+"RequireUppercaseCharacters", (params["RequireUppercaseCharacters"] ?? '').toString());
    if ("RequireLowercaseCharacters" in params) body.append(prefix+"RequireLowercaseCharacters", (params["RequireLowercaseCharacters"] ?? '').toString());
    if ("AllowUsersToChangePassword" in params) body.append(prefix+"AllowUsersToChangePassword", (params["AllowUsersToChangePassword"] ?? '').toString());
    if ("MaxPasswordAge" in params) body.append(prefix+"MaxPasswordAge", (params["MaxPasswordAge"] ?? '').toString());
    if ("PasswordReusePrevention" in params) body.append(prefix+"PasswordReusePrevention", (params["PasswordReusePrevention"] ?? '').toString());
    if ("HardExpiry" in params) body.append(prefix+"HardExpiry", (params["HardExpiry"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountPasswordPolicy",
    });
  }

  async updateAssumeRolePolicy(
    {abortSignal, ...params}: RequestConfig & UpdateAssumeRolePolicyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAssumeRolePolicy",
    });
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & UpdateGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewGroupName" in params) body.append(prefix+"NewGroupName", (params["NewGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
    });
  }

  async updateLoginProfile(
    {abortSignal, ...params}: RequestConfig & UpdateLoginProfileRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("Password" in params) body.append(prefix+"Password", (params["Password"] ?? '').toString());
    if ("PasswordResetRequired" in params) body.append(prefix+"PasswordResetRequired", (params["PasswordResetRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLoginProfile",
    });
  }

  async updateOpenIDConnectProviderThumbprint(
    {abortSignal, ...params}: RequestConfig & UpdateOpenIDConnectProviderThumbprintRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OpenIDConnectProviderArn", (params["OpenIDConnectProviderArn"] ?? '').toString());
    if (params["ThumbprintList"]) prt.appendList(body, prefix+"ThumbprintList", params["ThumbprintList"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOpenIDConnectProviderThumbprint",
    });
  }

  async updateRole(
    {abortSignal, ...params}: RequestConfig & UpdateRoleRequest,
  ): Promise<UpdateRoleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("MaxSessionDuration" in params) body.append(prefix+"MaxSessionDuration", (params["MaxSessionDuration"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRole",
    });
    const xml = readXmlResult(await resp.text(), "UpdateRoleResult");
    return {};
  }

  async updateRoleDescription(
    {abortSignal, ...params}: RequestConfig & UpdateRoleDescriptionRequest,
  ): Promise<UpdateRoleDescriptionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRoleDescription",
    });
    const xml = readXmlResult(await resp.text(), "UpdateRoleDescriptionResult");
    return {
      Role: xml.first("Role", false, Role_Parse),
    };
  }

  async updateSAMLProvider(
    {abortSignal, ...params}: RequestConfig & UpdateSAMLProviderRequest,
  ): Promise<UpdateSAMLProviderResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SAMLMetadataDocument", (params["SAMLMetadataDocument"] ?? '').toString());
    body.append(prefix+"SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSAMLProvider",
    });
    const xml = readXmlResult(await resp.text(), "UpdateSAMLProviderResult");
    return xml.strings({
      optional: {"SAMLProviderArn":true},
    });
  }

  async updateSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & UpdateSSHPublicKeyRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyId", (params["SSHPublicKeyId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSSHPublicKey",
    });
  }

  async updateServerCertificate(
    {abortSignal, ...params}: RequestConfig & UpdateServerCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewServerCertificateName" in params) body.append(prefix+"NewServerCertificateName", (params["NewServerCertificateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServerCertificate",
    });
  }

  async updateServiceSpecificCredential(
    {abortSignal, ...params}: RequestConfig & UpdateServiceSpecificCredentialRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"ServiceSpecificCredentialId", (params["ServiceSpecificCredentialId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceSpecificCredential",
    });
  }

  async updateSigningCertificate(
    {abortSignal, ...params}: RequestConfig & UpdateSigningCertificateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateId", (params["CertificateId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSigningCertificate",
    });
  }

  async updateUser(
    {abortSignal, ...params}: RequestConfig & UpdateUserRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    if ("NewPath" in params) body.append(prefix+"NewPath", (params["NewPath"] ?? '').toString());
    if ("NewUserName" in params) body.append(prefix+"NewUserName", (params["NewUserName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUser",
    });
  }

  async uploadSSHPublicKey(
    {abortSignal, ...params}: RequestConfig & UploadSSHPublicKeyRequest,
  ): Promise<UploadSSHPublicKeyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"SSHPublicKeyBody", (params["SSHPublicKeyBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadSSHPublicKey",
    });
    const xml = readXmlResult(await resp.text(), "UploadSSHPublicKeyResult");
    return {
      SSHPublicKey: xml.first("SSHPublicKey", false, SSHPublicKey_Parse),
    };
  }

  async uploadServerCertificate(
    {abortSignal, ...params}: RequestConfig & UploadServerCertificateRequest,
  ): Promise<UploadServerCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Path" in params) body.append(prefix+"Path", (params["Path"] ?? '').toString());
    body.append(prefix+"ServerCertificateName", (params["ServerCertificateName"] ?? '').toString());
    body.append(prefix+"CertificateBody", (params["CertificateBody"] ?? '').toString());
    body.append(prefix+"PrivateKey", (params["PrivateKey"] ?? '').toString());
    if ("CertificateChain" in params) body.append(prefix+"CertificateChain", (params["CertificateChain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadServerCertificate",
    });
    const xml = readXmlResult(await resp.text(), "UploadServerCertificateResult");
    return {
      ServerCertificateMetadata: xml.first("ServerCertificateMetadata", false, ServerCertificateMetadata_Parse),
    };
  }

  async uploadSigningCertificate(
    {abortSignal, ...params}: RequestConfig & UploadSigningCertificateRequest,
  ): Promise<UploadSigningCertificateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserName" in params) body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"CertificateBody", (params["CertificateBody"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UploadSigningCertificate",
    });
    const xml = readXmlResult(await resp.text(), "UploadSigningCertificateResult");
    return {
      Certificate: xml.first("Certificate", true, SigningCertificate_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForInstanceProfileExists(
    params: RequestConfig & GetInstanceProfileRequest,
  ): Promise<GetInstanceProfileResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceProfileExists';
    for (let i = 0; i < 40; i++) {
      const resp = await this.getInstanceProfile(params);
      return resp; // for status 200
      // TODO: if (statusCode == 404) continue;
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForUserExists(
    params: RequestConfig & GetUserRequest,
  ): Promise<GetUserResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state UserExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getUser(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForRoleExists(
    params: RequestConfig & GetRoleRequest,
  ): Promise<GetRoleResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state RoleExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getRole(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForPolicyExists(
    params: RequestConfig & GetPolicyRequest,
  ): Promise<GetPolicyResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state PolicyExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getPolicy(params);
        return resp; // for status 200
      } catch (err) {
        if (!["NoSuchEntity"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddClientIDToOpenIDConnectProviderRequest {
  OpenIDConnectProviderArn: string;
  ClientID: string;
}

// refs: 1 - tags: named, input
export interface AddRoleToInstanceProfileRequest {
  InstanceProfileName: string;
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface AddUserToGroupRequest {
  GroupName: string;
  UserName: string;
}

// refs: 1 - tags: named, input
export interface AttachGroupPolicyRequest {
  GroupName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface AttachRolePolicyRequest {
  RoleName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface AttachUserPolicyRequest {
  UserName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface ChangePasswordRequest {
  OldPassword: string;
  NewPassword: string;
}

// refs: 1 - tags: named, input
export interface CreateAccessKeyRequest {
  UserName?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateAccountAliasRequest {
  AccountAlias: string;
}

// refs: 1 - tags: named, input
export interface CreateGroupRequest {
  Path?: string | null;
  GroupName: string;
}

// refs: 1 - tags: named, input
export interface CreateInstanceProfileRequest {
  InstanceProfileName: string;
  Path?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateLoginProfileRequest {
  UserName: string;
  Password: string;
  PasswordResetRequired?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateOpenIDConnectProviderRequest {
  Url: string;
  ClientIDList?: string[] | null;
  ThumbprintList: string[];
}

// refs: 1 - tags: named, input
export interface CreatePolicyRequest {
  PolicyName: string;
  Path?: string | null;
  PolicyDocument: string;
  Description?: string | null;
}

// refs: 1 - tags: named, input
export interface CreatePolicyVersionRequest {
  PolicyArn: string;
  PolicyDocument: string;
  SetAsDefault?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateRoleRequest {
  Path?: string | null;
  RoleName: string;
  AssumeRolePolicyDocument: string;
  Description?: string | null;
  MaxSessionDuration?: number | null;
  PermissionsBoundary?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSAMLProviderRequest {
  SAMLMetadataDocument: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface CreateServiceLinkedRoleRequest {
  AWSServiceName: string;
  Description?: string | null;
  CustomSuffix?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateServiceSpecificCredentialRequest {
  UserName: string;
  ServiceName: string;
}

// refs: 1 - tags: named, input
export interface CreateUserRequest {
  Path?: string | null;
  UserName: string;
  PermissionsBoundary?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVirtualMFADeviceRequest {
  Path?: string | null;
  VirtualMFADeviceName: string;
}

// refs: 1 - tags: named, input
export interface DeactivateMFADeviceRequest {
  UserName: string;
  SerialNumber: string;
}

// refs: 1 - tags: named, input
export interface DeleteAccessKeyRequest {
  UserName?: string | null;
  AccessKeyId: string;
}

// refs: 1 - tags: named, input
export interface DeleteAccountAliasRequest {
  AccountAlias: string;
}

// refs: 1 - tags: named, input
export interface DeleteGroupRequest {
  GroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGroupPolicyRequest {
  GroupName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteInstanceProfileRequest {
  InstanceProfileName: string;
}

// refs: 1 - tags: named, input
export interface DeleteLoginProfileRequest {
  UserName: string;
}

// refs: 1 - tags: named, input
export interface DeleteOpenIDConnectProviderRequest {
  OpenIDConnectProviderArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePolicyRequest {
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePolicyVersionRequest {
  PolicyArn: string;
  VersionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteRoleRequest {
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRolePermissionsBoundaryRequest {
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRolePolicyRequest {
  RoleName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteSAMLProviderRequest {
  SAMLProviderArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteSSHPublicKeyRequest {
  UserName: string;
  SSHPublicKeyId: string;
}

// refs: 1 - tags: named, input
export interface DeleteServerCertificateRequest {
  ServerCertificateName: string;
}

// refs: 1 - tags: named, input
export interface DeleteServiceLinkedRoleRequest {
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteServiceSpecificCredentialRequest {
  UserName?: string | null;
  ServiceSpecificCredentialId: string;
}

// refs: 1 - tags: named, input
export interface DeleteSigningCertificateRequest {
  UserName?: string | null;
  CertificateId: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserRequest {
  UserName: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserPermissionsBoundaryRequest {
  UserName: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserPolicyRequest {
  UserName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualMFADeviceRequest {
  SerialNumber: string;
}

// refs: 1 - tags: named, input
export interface DetachGroupPolicyRequest {
  GroupName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface DetachRolePolicyRequest {
  RoleName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface DetachUserPolicyRequest {
  UserName: string;
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface EnableMFADeviceRequest {
  UserName: string;
  SerialNumber: string;
  AuthenticationCode1: string;
  AuthenticationCode2: string;
}

// refs: 1 - tags: named, input
export interface GenerateOrganizationsAccessReportRequest {
  EntityPath: string;
  OrganizationsPolicyId?: string | null;
}

// refs: 1 - tags: named, input
export interface GenerateServiceLastAccessedDetailsRequest {
  Arn: string;
  Granularity?: AccessAdvisorUsageGranularityType | null;
}

// refs: 1 - tags: named, input
export interface GetAccessKeyLastUsedRequest {
  AccessKeyId: string;
}

// refs: 1 - tags: named, input
export interface GetAccountAuthorizationDetailsRequest {
  Filter?: EntityType[] | null;
  MaxItems?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface GetContextKeysForCustomPolicyRequest {
  PolicyInputList: string[];
}

// refs: 1 - tags: named, input
export interface GetContextKeysForPrincipalPolicyRequest {
  PolicySourceArn: string;
  PolicyInputList?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GetGroupRequest {
  GroupName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface GetGroupPolicyRequest {
  GroupName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface GetInstanceProfileRequest {
  InstanceProfileName: string;
}

// refs: 1 - tags: named, input
export interface GetLoginProfileRequest {
  UserName: string;
}

// refs: 1 - tags: named, input
export interface GetOpenIDConnectProviderRequest {
  OpenIDConnectProviderArn: string;
}

// refs: 1 - tags: named, input
export interface GetOrganizationsAccessReportRequest {
  JobId: string;
  MaxItems?: number | null;
  Marker?: string | null;
  SortKey?: sortKeyType | null;
}

// refs: 1 - tags: named, input
export interface GetPolicyRequest {
  PolicyArn: string;
}

// refs: 1 - tags: named, input
export interface GetPolicyVersionRequest {
  PolicyArn: string;
  VersionId: string;
}

// refs: 1 - tags: named, input
export interface GetRoleRequest {
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface GetRolePolicyRequest {
  RoleName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface GetSAMLProviderRequest {
  SAMLProviderArn: string;
}

// refs: 1 - tags: named, input
export interface GetSSHPublicKeyRequest {
  UserName: string;
  SSHPublicKeyId: string;
  Encoding: encodingType;
}

// refs: 1 - tags: named, input
export interface GetServerCertificateRequest {
  ServerCertificateName: string;
}

// refs: 1 - tags: named, input
export interface GetServiceLastAccessedDetailsRequest {
  JobId: string;
  MaxItems?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface GetServiceLastAccessedDetailsWithEntitiesRequest {
  JobId: string;
  ServiceNamespace: string;
  MaxItems?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface GetServiceLinkedRoleDeletionStatusRequest {
  DeletionTaskId: string;
}

// refs: 1 - tags: named, input
export interface GetUserRequest {
  UserName?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUserPolicyRequest {
  UserName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface ListAccessKeysRequest {
  UserName?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAccountAliasesRequest {
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAttachedGroupPoliciesRequest {
  GroupName: string;
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAttachedRolePoliciesRequest {
  RoleName: string;
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAttachedUserPoliciesRequest {
  UserName: string;
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListEntitiesForPolicyRequest {
  PolicyArn: string;
  EntityFilter?: EntityType | null;
  PathPrefix?: string | null;
  PolicyUsageFilter?: PolicyUsageType | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListGroupPoliciesRequest {
  GroupName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListGroupsRequest {
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListGroupsForUserRequest {
  UserName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceProfilesRequest {
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceProfilesForRoleRequest {
  RoleName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListMFADevicesRequest {
  UserName?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListOpenIDConnectProvidersRequest {
}

// refs: 1 - tags: named, input
export interface ListPoliciesRequest {
  Scope?: policyScopeType | null;
  OnlyAttached?: boolean | null;
  PathPrefix?: string | null;
  PolicyUsageFilter?: PolicyUsageType | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListPoliciesGrantingServiceAccessRequest {
  Marker?: string | null;
  Arn: string;
  ServiceNamespaces: string[];
}

// refs: 1 - tags: named, input
export interface ListPolicyVersionsRequest {
  PolicyArn: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRolePoliciesRequest {
  RoleName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRoleTagsRequest {
  RoleName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRolesRequest {
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSAMLProvidersRequest {
}

// refs: 1 - tags: named, input
export interface ListSSHPublicKeysRequest {
  UserName?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListServerCertificatesRequest {
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListServiceSpecificCredentialsRequest {
  UserName?: string | null;
  ServiceName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSigningCertificatesRequest {
  UserName?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListUserPoliciesRequest {
  UserName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListUserTagsRequest {
  UserName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListUsersRequest {
  PathPrefix?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListVirtualMFADevicesRequest {
  AssignmentStatus?: assignmentStatusType | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface PutGroupPolicyRequest {
  GroupName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, input
export interface PutRolePermissionsBoundaryRequest {
  RoleName: string;
  PermissionsBoundary: string;
}

// refs: 1 - tags: named, input
export interface PutRolePolicyRequest {
  RoleName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, input
export interface PutUserPermissionsBoundaryRequest {
  UserName: string;
  PermissionsBoundary: string;
}

// refs: 1 - tags: named, input
export interface PutUserPolicyRequest {
  UserName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, input
export interface RemoveClientIDFromOpenIDConnectProviderRequest {
  OpenIDConnectProviderArn: string;
  ClientID: string;
}

// refs: 1 - tags: named, input
export interface RemoveRoleFromInstanceProfileRequest {
  InstanceProfileName: string;
  RoleName: string;
}

// refs: 1 - tags: named, input
export interface RemoveUserFromGroupRequest {
  GroupName: string;
  UserName: string;
}

// refs: 1 - tags: named, input
export interface ResetServiceSpecificCredentialRequest {
  UserName?: string | null;
  ServiceSpecificCredentialId: string;
}

// refs: 1 - tags: named, input
export interface ResyncMFADeviceRequest {
  UserName: string;
  SerialNumber: string;
  AuthenticationCode1: string;
  AuthenticationCode2: string;
}

// refs: 1 - tags: named, input
export interface SetDefaultPolicyVersionRequest {
  PolicyArn: string;
  VersionId: string;
}

// refs: 1 - tags: named, input
export interface SetSecurityTokenServicePreferencesRequest {
  GlobalEndpointTokenVersion: globalEndpointTokenVersion;
}

// refs: 1 - tags: named, input
export interface SimulateCustomPolicyRequest {
  PolicyInputList: string[];
  PermissionsBoundaryPolicyInputList?: string[] | null;
  ActionNames: string[];
  ResourceArns?: string[] | null;
  ResourcePolicy?: string | null;
  ResourceOwner?: string | null;
  CallerArn?: string | null;
  ContextEntries?: ContextEntry[] | null;
  ResourceHandlingOption?: string | null;
  MaxItems?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface SimulatePrincipalPolicyRequest {
  PolicySourceArn: string;
  PolicyInputList?: string[] | null;
  PermissionsBoundaryPolicyInputList?: string[] | null;
  ActionNames: string[];
  ResourceArns?: string[] | null;
  ResourcePolicy?: string | null;
  ResourceOwner?: string | null;
  CallerArn?: string | null;
  ContextEntries?: ContextEntry[] | null;
  ResourceHandlingOption?: string | null;
  MaxItems?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface TagRoleRequest {
  RoleName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface TagUserRequest {
  UserName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagRoleRequest {
  RoleName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UntagUserRequest {
  UserName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAccessKeyRequest {
  UserName?: string | null;
  AccessKeyId: string;
  Status: statusType;
}

// refs: 1 - tags: named, input
export interface UpdateAccountPasswordPolicyRequest {
  MinimumPasswordLength?: number | null;
  RequireSymbols?: boolean | null;
  RequireNumbers?: boolean | null;
  RequireUppercaseCharacters?: boolean | null;
  RequireLowercaseCharacters?: boolean | null;
  AllowUsersToChangePassword?: boolean | null;
  MaxPasswordAge?: number | null;
  PasswordReusePrevention?: number | null;
  HardExpiry?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateAssumeRolePolicyRequest {
  RoleName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, input
export interface UpdateGroupRequest {
  GroupName: string;
  NewPath?: string | null;
  NewGroupName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateLoginProfileRequest {
  UserName: string;
  Password?: string | null;
  PasswordResetRequired?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateOpenIDConnectProviderThumbprintRequest {
  OpenIDConnectProviderArn: string;
  ThumbprintList: string[];
}

// refs: 1 - tags: named, input
export interface UpdateRoleRequest {
  RoleName: string;
  Description?: string | null;
  MaxSessionDuration?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateRoleDescriptionRequest {
  RoleName: string;
  Description: string;
}

// refs: 1 - tags: named, input
export interface UpdateSAMLProviderRequest {
  SAMLMetadataDocument: string;
  SAMLProviderArn: string;
}

// refs: 1 - tags: named, input
export interface UpdateSSHPublicKeyRequest {
  UserName: string;
  SSHPublicKeyId: string;
  Status: statusType;
}

// refs: 1 - tags: named, input
export interface UpdateServerCertificateRequest {
  ServerCertificateName: string;
  NewPath?: string | null;
  NewServerCertificateName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateServiceSpecificCredentialRequest {
  UserName?: string | null;
  ServiceSpecificCredentialId: string;
  Status: statusType;
}

// refs: 1 - tags: named, input
export interface UpdateSigningCertificateRequest {
  UserName?: string | null;
  CertificateId: string;
  Status: statusType;
}

// refs: 1 - tags: named, input
export interface UpdateUserRequest {
  UserName: string;
  NewPath?: string | null;
  NewUserName?: string | null;
}

// refs: 1 - tags: named, input
export interface UploadSSHPublicKeyRequest {
  UserName: string;
  SSHPublicKeyBody: string;
}

// refs: 1 - tags: named, input
export interface UploadServerCertificateRequest {
  Path?: string | null;
  ServerCertificateName: string;
  CertificateBody: string;
  PrivateKey: string;
  CertificateChain?: string | null;
}

// refs: 1 - tags: named, input
export interface UploadSigningCertificateRequest {
  UserName?: string | null;
  CertificateBody: string;
}

// refs: 1 - tags: named, output
export interface CreateAccessKeyResponse {
  AccessKey: AccessKey;
}

// refs: 1 - tags: named, output
export interface CreateGroupResponse {
  Group: Group;
}

// refs: 1 - tags: named, output
export interface CreateInstanceProfileResponse {
  InstanceProfile: InstanceProfile;
}

// refs: 1 - tags: named, output
export interface CreateLoginProfileResponse {
  LoginProfile: LoginProfile;
}

// refs: 1 - tags: named, output
export interface CreateOpenIDConnectProviderResponse {
  OpenIDConnectProviderArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePolicyResponse {
  Policy?: Policy | null;
}

// refs: 1 - tags: named, output
export interface CreatePolicyVersionResponse {
  PolicyVersion?: PolicyVersion | null;
}

// refs: 1 - tags: named, output
export interface CreateRoleResponse {
  Role: Role;
}

// refs: 1 - tags: named, output
export interface CreateSAMLProviderResponse {
  SAMLProviderArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateServiceLinkedRoleResponse {
  Role?: Role | null;
}

// refs: 1 - tags: named, output
export interface CreateServiceSpecificCredentialResponse {
  ServiceSpecificCredential?: ServiceSpecificCredential | null;
}

// refs: 1 - tags: named, output
export interface CreateUserResponse {
  User?: User | null;
}

// refs: 1 - tags: named, output
export interface CreateVirtualMFADeviceResponse {
  VirtualMFADevice: VirtualMFADevice;
}

// refs: 1 - tags: named, output
export interface DeleteServiceLinkedRoleResponse {
  DeletionTaskId: string;
}

// refs: 1 - tags: named, output
export interface GenerateCredentialReportResponse {
  State?: ReportStateType | null;
  Description?: string | null;
}

// refs: 1 - tags: named, output
export interface GenerateOrganizationsAccessReportResponse {
  JobId?: string | null;
}

// refs: 1 - tags: named, output
export interface GenerateServiceLastAccessedDetailsResponse {
  JobId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAccessKeyLastUsedResponse {
  UserName?: string | null;
  AccessKeyLastUsed?: AccessKeyLastUsed | null;
}

// refs: 1 - tags: named, output
export interface GetAccountAuthorizationDetailsResponse {
  UserDetailList: UserDetail[];
  GroupDetailList: GroupDetail[];
  RoleDetailList: RoleDetail[];
  Policies: ManagedPolicyDetail[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAccountPasswordPolicyResponse {
  PasswordPolicy: PasswordPolicy;
}

// refs: 1 - tags: named, output
export interface GetAccountSummaryResponse {
  SummaryMap: { [key in summaryKeyType]: number };
}

// refs: 1 - tags: named, output
export interface GetContextKeysForPolicyResponse {
  ContextKeyNames: string[];
}

// refs: 1 - tags: named, output
export interface GetCredentialReportResponse {
  Content?: Uint8Array | string | null;
  ReportFormat?: ReportFormatType | null;
  GeneratedTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetGroupResponse {
  Group: Group;
  Users: User[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface GetGroupPolicyResponse {
  GroupName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, output
export interface GetInstanceProfileResponse {
  InstanceProfile: InstanceProfile;
}

// refs: 1 - tags: named, output
export interface GetLoginProfileResponse {
  LoginProfile: LoginProfile;
}

// refs: 1 - tags: named, output
export interface GetOpenIDConnectProviderResponse {
  Url?: string | null;
  ClientIDList: string[];
  ThumbprintList: string[];
  CreateDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetOrganizationsAccessReportResponse {
  JobStatus: jobStatusType;
  JobCreationDate: Date | number;
  JobCompletionDate?: Date | number | null;
  NumberOfServicesAccessible?: number | null;
  NumberOfServicesNotAccessed?: number | null;
  AccessDetails: AccessDetail[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
  ErrorDetails?: ErrorDetails | null;
}

// refs: 1 - tags: named, output
export interface GetPolicyResponse {
  Policy?: Policy | null;
}

// refs: 1 - tags: named, output
export interface GetPolicyVersionResponse {
  PolicyVersion?: PolicyVersion | null;
}

// refs: 1 - tags: named, output
export interface GetRoleResponse {
  Role: Role;
}

// refs: 1 - tags: named, output
export interface GetRolePolicyResponse {
  RoleName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, output
export interface GetSAMLProviderResponse {
  SAMLMetadataDocument?: string | null;
  CreateDate?: Date | number | null;
  ValidUntil?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetSSHPublicKeyResponse {
  SSHPublicKey?: SSHPublicKey | null;
}

// refs: 1 - tags: named, output
export interface GetServerCertificateResponse {
  ServerCertificate: ServerCertificate;
}

// refs: 1 - tags: named, output
export interface GetServiceLastAccessedDetailsResponse {
  JobStatus: jobStatusType;
  JobType?: AccessAdvisorUsageGranularityType | null;
  JobCreationDate: Date | number;
  ServicesLastAccessed: ServiceLastAccessed[];
  JobCompletionDate: Date | number;
  IsTruncated?: boolean | null;
  Marker?: string | null;
  Error?: ErrorDetails | null;
}

// refs: 1 - tags: named, output
export interface GetServiceLastAccessedDetailsWithEntitiesResponse {
  JobStatus: jobStatusType;
  JobCreationDate: Date | number;
  JobCompletionDate: Date | number;
  EntityDetailsList: EntityDetails[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
  Error?: ErrorDetails | null;
}

// refs: 1 - tags: named, output
export interface GetServiceLinkedRoleDeletionStatusResponse {
  Status: DeletionTaskStatusType;
  Reason?: DeletionTaskFailureReasonType | null;
}

// refs: 1 - tags: named, output
export interface GetUserResponse {
  User: User;
}

// refs: 1 - tags: named, output
export interface GetUserPolicyResponse {
  UserName: string;
  PolicyName: string;
  PolicyDocument: string;
}

// refs: 1 - tags: named, output
export interface ListAccessKeysResponse {
  AccessKeyMetadata: AccessKeyMetadata[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAccountAliasesResponse {
  AccountAliases: string[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAttachedGroupPoliciesResponse {
  AttachedPolicies: AttachedPolicy[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAttachedRolePoliciesResponse {
  AttachedPolicies: AttachedPolicy[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAttachedUserPoliciesResponse {
  AttachedPolicies: AttachedPolicy[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListEntitiesForPolicyResponse {
  PolicyGroups: PolicyGroup[];
  PolicyUsers: PolicyUser[];
  PolicyRoles: PolicyRole[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGroupPoliciesResponse {
  PolicyNames: string[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGroupsResponse {
  Groups: Group[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGroupsForUserResponse {
  Groups: Group[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceProfilesResponse {
  InstanceProfiles: InstanceProfile[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceProfilesForRoleResponse {
  InstanceProfiles: InstanceProfile[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMFADevicesResponse {
  MFADevices: MFADevice[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListOpenIDConnectProvidersResponse {
  OpenIDConnectProviderList: OpenIDConnectProviderListEntry[];
}

// refs: 1 - tags: named, output
export interface ListPoliciesResponse {
  Policies: Policy[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPoliciesGrantingServiceAccessResponse {
  PoliciesGrantingServiceAccess: ListPoliciesGrantingServiceAccessEntry[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPolicyVersionsResponse {
  Versions: PolicyVersion[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRolePoliciesResponse {
  PolicyNames: string[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRoleTagsResponse {
  Tags: Tag[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRolesResponse {
  Roles: Role[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSAMLProvidersResponse {
  SAMLProviderList: SAMLProviderListEntry[];
}

// refs: 1 - tags: named, output
export interface ListSSHPublicKeysResponse {
  SSHPublicKeys: SSHPublicKeyMetadata[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListServerCertificatesResponse {
  ServerCertificateMetadataList: ServerCertificateMetadata[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListServiceSpecificCredentialsResponse {
  ServiceSpecificCredentials: ServiceSpecificCredentialMetadata[];
}

// refs: 1 - tags: named, output
export interface ListSigningCertificatesResponse {
  Certificates: SigningCertificate[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListUserPoliciesResponse {
  PolicyNames: string[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListUserTagsResponse {
  Tags: Tag[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListUsersResponse {
  Users: User[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListVirtualMFADevicesResponse {
  VirtualMFADevices: VirtualMFADevice[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ResetServiceSpecificCredentialResponse {
  ServiceSpecificCredential?: ServiceSpecificCredential | null;
}

// refs: 1 - tags: named, output
export interface SimulatePolicyResponse {
  EvaluationResults: EvaluationResult[];
  IsTruncated?: boolean | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateRoleResponse {
}

// refs: 1 - tags: named, output
export interface UpdateRoleDescriptionResponse {
  Role?: Role | null;
}

// refs: 1 - tags: named, output
export interface UpdateSAMLProviderResponse {
  SAMLProviderArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UploadSSHPublicKeyResponse {
  SSHPublicKey?: SSHPublicKey | null;
}

// refs: 1 - tags: named, output
export interface UploadServerCertificateResponse {
  ServerCertificateMetadata?: ServerCertificateMetadata | null;
}

// refs: 1 - tags: named, output
export interface UploadSigningCertificateResponse {
  Certificate: SigningCertificate;
}

// refs: 24 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: XmlNode): Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 2 - tags: input, named, enum, output
export type AccessAdvisorUsageGranularityType =
| "SERVICE_LEVEL"
| "ACTION_LEVEL"
;



// refs: 2 - tags: input, named, enum
export type EntityType =
| "User"
| "Role"
| "Group"
| "LocalManagedPolicy"
| "AWSManagedPolicy"
;


// refs: 1 - tags: input, named, enum
export type sortKeyType =
| "SERVICE_NAMESPACE_ASCENDING"
| "SERVICE_NAMESPACE_DESCENDING"
| "LAST_AUTHENTICATED_TIME_ASCENDING"
| "LAST_AUTHENTICATED_TIME_DESCENDING"
;


// refs: 1 - tags: input, named, enum
export type encodingType =
| "SSH"
| "PEM"
;


// refs: 2 - tags: input, named, enum
export type PolicyUsageType =
| "PermissionsPolicy"
| "PermissionsBoundary"
;


// refs: 1 - tags: input, named, enum
export type policyScopeType =
| "All"
| "AWS"
| "Local"
;


// refs: 1 - tags: input, named, enum
export type assignmentStatusType =
| "Assigned"
| "Unassigned"
| "Any"
;


// refs: 1 - tags: input, named, enum
export type globalEndpointTokenVersion =
| "v1Token"
| "v2Token"
;


// refs: 2 - tags: input, named, interface
export interface ContextEntry {
  ContextKeyName?: string | null;
  ContextKeyValues?: string[] | null;
  ContextKeyType?: ContextKeyTypeEnum | null;
}
function ContextEntry_Serialize(body: URLSearchParams, prefix: string, params: ContextEntry) {
    if ("ContextKeyName" in params) body.append(prefix+".ContextKeyName", (params["ContextKeyName"] ?? '').toString());
    if (params["ContextKeyValues"]) prt.appendList(body, prefix+".ContextKeyValues", params["ContextKeyValues"], {"entryPrefix":".member."})
    if ("ContextKeyType" in params) body.append(prefix+".ContextKeyType", (params["ContextKeyType"] ?? '').toString());
}

// refs: 2 - tags: input, named, enum
export type ContextKeyTypeEnum =
| "string"
| "stringList"
| "numeric"
| "numericList"
| "boolean"
| "booleanList"
| "ip"
| "ipList"
| "binary"
| "binaryList"
| "date"
| "dateList"
;


// refs: 14 - tags: input, named, enum, output
export type statusType =
| "Active"
| "Inactive"
;



// refs: 1 - tags: output, named, interface
export interface AccessKey {
  UserName: string;
  AccessKeyId: string;
  Status: statusType;
  SecretAccessKey: string;
  CreateDate?: Date | number | null;
}
function AccessKey_Parse(node: XmlNode): AccessKey {
  return {
    ...node.strings({
      required: {"UserName":true,"AccessKeyId":true,"SecretAccessKey":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 4 - tags: output, named, interface
export interface Group {
  Path: string;
  GroupName: string;
  GroupId: string;
  Arn: string;
  CreateDate: Date | number;
}
function Group_Parse(node: XmlNode): Group {
  return {
    ...node.strings({
      required: {"Path":true,"GroupName":true,"GroupId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
  };
}

// refs: 5 - tags: output, named, interface
export interface InstanceProfile {
  Path: string;
  InstanceProfileName: string;
  InstanceProfileId: string;
  Arn: string;
  CreateDate: Date | number;
  Roles: Role[];
}
function InstanceProfile_Parse(node: XmlNode): InstanceProfile {
  return {
    ...node.strings({
      required: {"Path":true,"InstanceProfileName":true,"InstanceProfileId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
    Roles: node.getList("Roles", "member").map(Role_Parse),
  };
}

// refs: 10 - tags: output, named, interface
export interface Role {
  Path: string;
  RoleName: string;
  RoleId: string;
  Arn: string;
  CreateDate: Date | number;
  AssumeRolePolicyDocument?: string | null;
  Description?: string | null;
  MaxSessionDuration?: number | null;
  PermissionsBoundary?: AttachedPermissionsBoundary | null;
  Tags: Tag[];
  RoleLastUsed?: RoleLastUsed | null;
}
function Role_Parse(node: XmlNode): Role {
  return {
    ...node.strings({
      required: {"Path":true,"RoleName":true,"RoleId":true,"Arn":true},
      optional: {"AssumeRolePolicyDocument":true,"Description":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
    MaxSessionDuration: node.first("MaxSessionDuration", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    RoleLastUsed: node.first("RoleLastUsed", false, RoleLastUsed_Parse),
  };
}

// refs: 18 - tags: output, named, interface
export interface AttachedPermissionsBoundary {
  PermissionsBoundaryType?: PermissionsBoundaryAttachmentType | null;
  PermissionsBoundaryArn?: string | null;
}
function AttachedPermissionsBoundary_Parse(node: XmlNode): AttachedPermissionsBoundary {
  return {
    ...node.strings({
      optional: {"PermissionsBoundaryArn":true},
    }),
    PermissionsBoundaryType: node.first("PermissionsBoundaryType", false, x => (x.content ?? '') as PermissionsBoundaryAttachmentType),
  };
}

// refs: 18 - tags: output, named, enum
export type PermissionsBoundaryAttachmentType =
| "PermissionsBoundaryPolicy"
;


// refs: 11 - tags: output, named, interface
export interface RoleLastUsed {
  LastUsedDate?: Date | number | null;
  Region?: string | null;
}
function RoleLastUsed_Parse(node: XmlNode): RoleLastUsed {
  return {
    ...node.strings({
      optional: {"Region":true},
    }),
    LastUsedDate: node.first("LastUsedDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface LoginProfile {
  UserName: string;
  CreateDate: Date | number;
  PasswordResetRequired?: boolean | null;
}
function LoginProfile_Parse(node: XmlNode): LoginProfile {
  return {
    ...node.strings({
      required: {"UserName":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
    PasswordResetRequired: node.first("PasswordResetRequired", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface Policy {
  PolicyName?: string | null;
  PolicyId?: string | null;
  Arn?: string | null;
  Path?: string | null;
  DefaultVersionId?: string | null;
  AttachmentCount?: number | null;
  PermissionsBoundaryUsageCount?: number | null;
  IsAttachable?: boolean | null;
  Description?: string | null;
  CreateDate?: Date | number | null;
  UpdateDate?: Date | number | null;
}
function Policy_Parse(node: XmlNode): Policy {
  return {
    ...node.strings({
      optional: {"PolicyName":true,"PolicyId":true,"Arn":true,"Path":true,"DefaultVersionId":true,"Description":true},
    }),
    AttachmentCount: node.first("AttachmentCount", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundaryUsageCount: node.first("PermissionsBoundaryUsageCount", false, x => parseInt(x.content ?? '0')),
    IsAttachable: node.first("IsAttachable", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 4 - tags: output, named, interface
export interface PolicyVersion {
  Document?: string | null;
  VersionId?: string | null;
  IsDefaultVersion?: boolean | null;
  CreateDate?: Date | number | null;
}
function PolicyVersion_Parse(node: XmlNode): PolicyVersion {
  return {
    ...node.strings({
      optional: {"Document":true,"VersionId":true},
    }),
    IsDefaultVersion: node.first("IsDefaultVersion", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface ServiceSpecificCredential {
  CreateDate: Date | number;
  ServiceName: string;
  ServiceUserName: string;
  ServicePassword: string;
  ServiceSpecificCredentialId: string;
  UserName: string;
  Status: statusType;
}
function ServiceSpecificCredential_Parse(node: XmlNode): ServiceSpecificCredential {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceUserName":true,"ServicePassword":true,"ServiceSpecificCredentialId":true,"UserName":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
  };
}

// refs: 6 - tags: output, named, interface
export interface User {
  Path: string;
  UserName: string;
  UserId: string;
  Arn: string;
  CreateDate: Date | number;
  PasswordLastUsed?: Date | number | null;
  PermissionsBoundary?: AttachedPermissionsBoundary | null;
  Tags: Tag[];
}
function User_Parse(node: XmlNode): User {
  return {
    ...node.strings({
      required: {"Path":true,"UserName":true,"UserId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
    PasswordLastUsed: node.first("PasswordLastUsed", false, x => parseTimestamp(x.content)),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface VirtualMFADevice {
  SerialNumber: string;
  Base32StringSeed?: Uint8Array | string | null;
  QRCodePNG?: Uint8Array | string | null;
  User?: User | null;
  EnableDate?: Date | number | null;
}
function VirtualMFADevice_Parse(node: XmlNode): VirtualMFADevice {
  return {
    ...node.strings({
      required: {"SerialNumber":true},
    }),
    Base32StringSeed: node.first("Base32StringSeed", false, x => Base64.toUint8Array(x.content ?? '')),
    QRCodePNG: node.first("QRCodePNG", false, x => Base64.toUint8Array(x.content ?? '')),
    User: node.first("User", false, User_Parse),
    EnableDate: node.first("EnableDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, enum
export type ReportStateType =
| "STARTED"
| "INPROGRESS"
| "COMPLETE"
;


// refs: 1 - tags: output, named, interface
export interface AccessKeyLastUsed {
  LastUsedDate: Date | number;
  ServiceName: string;
  Region: string;
}
function AccessKeyLastUsed_Parse(node: XmlNode): AccessKeyLastUsed {
  return {
    ...node.strings({
      required: {"ServiceName":true,"Region":true},
    }),
    LastUsedDate: node.first("LastUsedDate", true, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface UserDetail {
  Path?: string | null;
  UserName?: string | null;
  UserId?: string | null;
  Arn?: string | null;
  CreateDate?: Date | number | null;
  UserPolicyList: PolicyDetail[];
  GroupList: string[];
  AttachedManagedPolicies: AttachedPolicy[];
  PermissionsBoundary?: AttachedPermissionsBoundary | null;
  Tags: Tag[];
}
function UserDetail_Parse(node: XmlNode): UserDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"UserName":true,"UserId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
    UserPolicyList: node.getList("UserPolicyList", "member").map(PolicyDetail_Parse),
    GroupList: node.getList("GroupList", "member").map(x => x.content ?? ''),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface PolicyDetail {
  PolicyName?: string | null;
  PolicyDocument?: string | null;
}
function PolicyDetail_Parse(node: XmlNode): PolicyDetail {
  return node.strings({
    optional: {"PolicyName":true,"PolicyDocument":true},
  });
}

// refs: 6 - tags: output, named, interface
export interface AttachedPolicy {
  PolicyName?: string | null;
  PolicyArn?: string | null;
}
function AttachedPolicy_Parse(node: XmlNode): AttachedPolicy {
  return node.strings({
    optional: {"PolicyName":true,"PolicyArn":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface GroupDetail {
  Path?: string | null;
  GroupName?: string | null;
  GroupId?: string | null;
  Arn?: string | null;
  CreateDate?: Date | number | null;
  GroupPolicyList: PolicyDetail[];
  AttachedManagedPolicies: AttachedPolicy[];
}
function GroupDetail_Parse(node: XmlNode): GroupDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"GroupName":true,"GroupId":true,"Arn":true},
    }),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
    GroupPolicyList: node.getList("GroupPolicyList", "member").map(PolicyDetail_Parse),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface RoleDetail {
  Path?: string | null;
  RoleName?: string | null;
  RoleId?: string | null;
  Arn?: string | null;
  CreateDate?: Date | number | null;
  AssumeRolePolicyDocument?: string | null;
  InstanceProfileList: InstanceProfile[];
  RolePolicyList: PolicyDetail[];
  AttachedManagedPolicies: AttachedPolicy[];
  PermissionsBoundary?: AttachedPermissionsBoundary | null;
  Tags: Tag[];
  RoleLastUsed?: RoleLastUsed | null;
}
function RoleDetail_Parse(node: XmlNode): RoleDetail {
  return {
    ...node.strings({
      optional: {"Path":true,"RoleName":true,"RoleId":true,"Arn":true,"AssumeRolePolicyDocument":true},
    }),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
    InstanceProfileList: node.getList("InstanceProfileList", "member").map(InstanceProfile_Parse),
    RolePolicyList: node.getList("RolePolicyList", "member").map(PolicyDetail_Parse),
    AttachedManagedPolicies: node.getList("AttachedManagedPolicies", "member").map(AttachedPolicy_Parse),
    PermissionsBoundary: node.first("PermissionsBoundary", false, AttachedPermissionsBoundary_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    RoleLastUsed: node.first("RoleLastUsed", false, RoleLastUsed_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ManagedPolicyDetail {
  PolicyName?: string | null;
  PolicyId?: string | null;
  Arn?: string | null;
  Path?: string | null;
  DefaultVersionId?: string | null;
  AttachmentCount?: number | null;
  PermissionsBoundaryUsageCount?: number | null;
  IsAttachable?: boolean | null;
  Description?: string | null;
  CreateDate?: Date | number | null;
  UpdateDate?: Date | number | null;
  PolicyVersionList: PolicyVersion[];
}
function ManagedPolicyDetail_Parse(node: XmlNode): ManagedPolicyDetail {
  return {
    ...node.strings({
      optional: {"PolicyName":true,"PolicyId":true,"Arn":true,"Path":true,"DefaultVersionId":true,"Description":true},
    }),
    AttachmentCount: node.first("AttachmentCount", false, x => parseInt(x.content ?? '0')),
    PermissionsBoundaryUsageCount: node.first("PermissionsBoundaryUsageCount", false, x => parseInt(x.content ?? '0')),
    IsAttachable: node.first("IsAttachable", false, x => x.content === 'true'),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", false, x => parseTimestamp(x.content)),
    PolicyVersionList: node.getList("PolicyVersionList", "member").map(PolicyVersion_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PasswordPolicy {
  MinimumPasswordLength?: number | null;
  RequireSymbols?: boolean | null;
  RequireNumbers?: boolean | null;
  RequireUppercaseCharacters?: boolean | null;
  RequireLowercaseCharacters?: boolean | null;
  AllowUsersToChangePassword?: boolean | null;
  ExpirePasswords?: boolean | null;
  MaxPasswordAge?: number | null;
  PasswordReusePrevention?: number | null;
  HardExpiry?: boolean | null;
}
function PasswordPolicy_Parse(node: XmlNode): PasswordPolicy {
  return {
    MinimumPasswordLength: node.first("MinimumPasswordLength", false, x => parseInt(x.content ?? '0')),
    RequireSymbols: node.first("RequireSymbols", false, x => x.content === 'true'),
    RequireNumbers: node.first("RequireNumbers", false, x => x.content === 'true'),
    RequireUppercaseCharacters: node.first("RequireUppercaseCharacters", false, x => x.content === 'true'),
    RequireLowercaseCharacters: node.first("RequireLowercaseCharacters", false, x => x.content === 'true'),
    AllowUsersToChangePassword: node.first("AllowUsersToChangePassword", false, x => x.content === 'true'),
    ExpirePasswords: node.first("ExpirePasswords", false, x => x.content === 'true'),
    MaxPasswordAge: node.first("MaxPasswordAge", false, x => parseInt(x.content ?? '0')),
    PasswordReusePrevention: node.first("PasswordReusePrevention", false, x => parseInt(x.content ?? '0')),
    HardExpiry: node.first("HardExpiry", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, enum
export type summaryKeyType =
| "Users"
| "UsersQuota"
| "Groups"
| "GroupsQuota"
| "ServerCertificates"
| "ServerCertificatesQuota"
| "UserPolicySizeQuota"
| "GroupPolicySizeQuota"
| "GroupsPerUserQuota"
| "SigningCertificatesPerUserQuota"
| "AccessKeysPerUserQuota"
| "MFADevices"
| "MFADevicesInUse"
| "AccountMFAEnabled"
| "AccountAccessKeysPresent"
| "AccountSigningCertificatesPresent"
| "AttachedPoliciesPerGroupQuota"
| "AttachedPoliciesPerRoleQuota"
| "AttachedPoliciesPerUserQuota"
| "Policies"
| "PoliciesQuota"
| "PolicySizeQuota"
| "PolicyVersionsInUse"
| "PolicyVersionsInUseQuota"
| "VersionsPerPolicyQuota"
| "GlobalEndpointTokenVersion"
;


// refs: 1 - tags: output, named, enum
export type ReportFormatType =
| "text/csv"
;


// refs: 3 - tags: output, named, enum
export type jobStatusType =
| "IN_PROGRESS"
| "COMPLETED"
| "FAILED"
;


// refs: 1 - tags: output, named, interface
export interface AccessDetail {
  ServiceName: string;
  ServiceNamespace: string;
  Region?: string | null;
  EntityPath?: string | null;
  LastAuthenticatedTime?: Date | number | null;
  TotalAuthenticatedEntities?: number | null;
}
function AccessDetail_Parse(node: XmlNode): AccessDetail {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceNamespace":true},
      optional: {"Region":true,"EntityPath":true},
    }),
    LastAuthenticatedTime: node.first("LastAuthenticatedTime", false, x => parseTimestamp(x.content)),
    TotalAuthenticatedEntities: node.first("TotalAuthenticatedEntities", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface ErrorDetails {
  Message: string;
  Code: string;
}
function ErrorDetails_Parse(node: XmlNode): ErrorDetails {
  return node.strings({
    required: {"Message":true,"Code":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface SSHPublicKey {
  UserName: string;
  SSHPublicKeyId: string;
  Fingerprint: string;
  SSHPublicKeyBody: string;
  Status: statusType;
  UploadDate?: Date | number | null;
}
function SSHPublicKey_Parse(node: XmlNode): SSHPublicKey {
  return {
    ...node.strings({
      required: {"UserName":true,"SSHPublicKeyId":true,"Fingerprint":true,"SSHPublicKeyBody":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
    UploadDate: node.first("UploadDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ServerCertificate {
  ServerCertificateMetadata: ServerCertificateMetadata;
  CertificateBody: string;
  CertificateChain?: string | null;
}
function ServerCertificate_Parse(node: XmlNode): ServerCertificate {
  return {
    ...node.strings({
      required: {"CertificateBody":true},
      optional: {"CertificateChain":true},
    }),
    ServerCertificateMetadata: node.first("ServerCertificateMetadata", true, ServerCertificateMetadata_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ServerCertificateMetadata {
  Path: string;
  ServerCertificateName: string;
  ServerCertificateId: string;
  Arn: string;
  UploadDate?: Date | number | null;
  Expiration?: Date | number | null;
}
function ServerCertificateMetadata_Parse(node: XmlNode): ServerCertificateMetadata {
  return {
    ...node.strings({
      required: {"Path":true,"ServerCertificateName":true,"ServerCertificateId":true,"Arn":true},
    }),
    UploadDate: node.first("UploadDate", false, x => parseTimestamp(x.content)),
    Expiration: node.first("Expiration", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ServiceLastAccessed {
  ServiceName: string;
  LastAuthenticated?: Date | number | null;
  ServiceNamespace: string;
  LastAuthenticatedEntity?: string | null;
  LastAuthenticatedRegion?: string | null;
  TotalAuthenticatedEntities?: number | null;
  TrackedActionsLastAccessed: TrackedActionLastAccessed[];
}
function ServiceLastAccessed_Parse(node: XmlNode): ServiceLastAccessed {
  return {
    ...node.strings({
      required: {"ServiceName":true,"ServiceNamespace":true},
      optional: {"LastAuthenticatedEntity":true,"LastAuthenticatedRegion":true},
    }),
    LastAuthenticated: node.first("LastAuthenticated", false, x => parseTimestamp(x.content)),
    TotalAuthenticatedEntities: node.first("TotalAuthenticatedEntities", false, x => parseInt(x.content ?? '0')),
    TrackedActionsLastAccessed: node.getList("TrackedActionsLastAccessed", "member").map(TrackedActionLastAccessed_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TrackedActionLastAccessed {
  ActionName?: string | null;
  LastAccessedEntity?: string | null;
  LastAccessedTime?: Date | number | null;
  LastAccessedRegion?: string | null;
}
function TrackedActionLastAccessed_Parse(node: XmlNode): TrackedActionLastAccessed {
  return {
    ...node.strings({
      optional: {"ActionName":true,"LastAccessedEntity":true,"LastAccessedRegion":true},
    }),
    LastAccessedTime: node.first("LastAccessedTime", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface EntityDetails {
  EntityInfo: EntityInfo;
  LastAuthenticated?: Date | number | null;
}
function EntityDetails_Parse(node: XmlNode): EntityDetails {
  return {
    EntityInfo: node.first("EntityInfo", true, EntityInfo_Parse),
    LastAuthenticated: node.first("LastAuthenticated", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface EntityInfo {
  Arn: string;
  Name: string;
  Type: policyOwnerEntityType;
  Id: string;
  Path?: string | null;
}
function EntityInfo_Parse(node: XmlNode): EntityInfo {
  return {
    ...node.strings({
      required: {"Arn":true,"Name":true,"Id":true},
      optional: {"Path":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as policyOwnerEntityType),
  };
}

// refs: 2 - tags: output, named, enum
export type policyOwnerEntityType =
| "USER"
| "ROLE"
| "GROUP"
;


// refs: 1 - tags: output, named, enum
export type DeletionTaskStatusType =
| "SUCCEEDED"
| "IN_PROGRESS"
| "FAILED"
| "NOT_STARTED"
;


// refs: 1 - tags: output, named, interface
export interface DeletionTaskFailureReasonType {
  Reason?: string | null;
  RoleUsageList: RoleUsageType[];
}
function DeletionTaskFailureReasonType_Parse(node: XmlNode): DeletionTaskFailureReasonType {
  return {
    ...node.strings({
      optional: {"Reason":true},
    }),
    RoleUsageList: node.getList("RoleUsageList", "member").map(RoleUsageType_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface RoleUsageType {
  Region?: string | null;
  Resources: string[];
}
function RoleUsageType_Parse(node: XmlNode): RoleUsageType {
  return {
    ...node.strings({
      optional: {"Region":true},
    }),
    Resources: node.getList("Resources", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccessKeyMetadata {
  UserName?: string | null;
  AccessKeyId?: string | null;
  Status?: statusType | null;
  CreateDate?: Date | number | null;
}
function AccessKeyMetadata_Parse(node: XmlNode): AccessKeyMetadata {
  return {
    ...node.strings({
      optional: {"UserName":true,"AccessKeyId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as statusType),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface PolicyGroup {
  GroupName?: string | null;
  GroupId?: string | null;
}
function PolicyGroup_Parse(node: XmlNode): PolicyGroup {
  return node.strings({
    optional: {"GroupName":true,"GroupId":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface PolicyUser {
  UserName?: string | null;
  UserId?: string | null;
}
function PolicyUser_Parse(node: XmlNode): PolicyUser {
  return node.strings({
    optional: {"UserName":true,"UserId":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface PolicyRole {
  RoleName?: string | null;
  RoleId?: string | null;
}
function PolicyRole_Parse(node: XmlNode): PolicyRole {
  return node.strings({
    optional: {"RoleName":true,"RoleId":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface MFADevice {
  UserName: string;
  SerialNumber: string;
  EnableDate: Date | number;
}
function MFADevice_Parse(node: XmlNode): MFADevice {
  return {
    ...node.strings({
      required: {"UserName":true,"SerialNumber":true},
    }),
    EnableDate: node.first("EnableDate", true, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface OpenIDConnectProviderListEntry {
  Arn?: string | null;
}
function OpenIDConnectProviderListEntry_Parse(node: XmlNode): OpenIDConnectProviderListEntry {
  return node.strings({
    optional: {"Arn":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ListPoliciesGrantingServiceAccessEntry {
  ServiceNamespace?: string | null;
  Policies: PolicyGrantingServiceAccess[];
}
function ListPoliciesGrantingServiceAccessEntry_Parse(node: XmlNode): ListPoliciesGrantingServiceAccessEntry {
  return {
    ...node.strings({
      optional: {"ServiceNamespace":true},
    }),
    Policies: node.getList("Policies", "member").map(PolicyGrantingServiceAccess_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PolicyGrantingServiceAccess {
  PolicyName: string;
  PolicyType: policyType;
  PolicyArn?: string | null;
  EntityType?: policyOwnerEntityType | null;
  EntityName?: string | null;
}
function PolicyGrantingServiceAccess_Parse(node: XmlNode): PolicyGrantingServiceAccess {
  return {
    ...node.strings({
      required: {"PolicyName":true},
      optional: {"PolicyArn":true,"EntityName":true},
    }),
    PolicyType: node.first("PolicyType", true, x => (x.content ?? '') as policyType),
    EntityType: node.first("EntityType", false, x => (x.content ?? '') as policyOwnerEntityType),
  };
}

// refs: 1 - tags: output, named, enum
export type policyType =
| "INLINE"
| "MANAGED"
;


// refs: 1 - tags: output, named, interface
export interface SAMLProviderListEntry {
  Arn?: string | null;
  ValidUntil?: Date | number | null;
  CreateDate?: Date | number | null;
}
function SAMLProviderListEntry_Parse(node: XmlNode): SAMLProviderListEntry {
  return {
    ...node.strings({
      optional: {"Arn":true},
    }),
    ValidUntil: node.first("ValidUntil", false, x => parseTimestamp(x.content)),
    CreateDate: node.first("CreateDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface SSHPublicKeyMetadata {
  UserName: string;
  SSHPublicKeyId: string;
  Status: statusType;
  UploadDate: Date | number;
}
function SSHPublicKeyMetadata_Parse(node: XmlNode): SSHPublicKeyMetadata {
  return {
    ...node.strings({
      required: {"UserName":true,"SSHPublicKeyId":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
    UploadDate: node.first("UploadDate", true, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ServiceSpecificCredentialMetadata {
  UserName: string;
  Status: statusType;
  ServiceUserName: string;
  CreateDate: Date | number;
  ServiceSpecificCredentialId: string;
  ServiceName: string;
}
function ServiceSpecificCredentialMetadata_Parse(node: XmlNode): ServiceSpecificCredentialMetadata {
  return {
    ...node.strings({
      required: {"UserName":true,"ServiceUserName":true,"ServiceSpecificCredentialId":true,"ServiceName":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
    CreateDate: node.first("CreateDate", true, x => parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface SigningCertificate {
  UserName: string;
  CertificateId: string;
  CertificateBody: string;
  Status: statusType;
  UploadDate?: Date | number | null;
}
function SigningCertificate_Parse(node: XmlNode): SigningCertificate {
  return {
    ...node.strings({
      required: {"UserName":true,"CertificateId":true,"CertificateBody":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as statusType),
    UploadDate: node.first("UploadDate", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface EvaluationResult {
  EvalActionName: string;
  EvalResourceName?: string | null;
  EvalDecision: PolicyEvaluationDecisionType;
  MatchedStatements: Statement[];
  MissingContextValues: string[];
  OrganizationsDecisionDetail?: OrganizationsDecisionDetail | null;
  PermissionsBoundaryDecisionDetail?: PermissionsBoundaryDecisionDetail | null;
  EvalDecisionDetails: { [key: string]: PolicyEvaluationDecisionType };
  ResourceSpecificResults: ResourceSpecificResult[];
}
function EvaluationResult_Parse(node: XmlNode): EvaluationResult {
  return {
    ...node.strings({
      required: {"EvalActionName":true},
      optional: {"EvalResourceName":true},
    }),
    EvalDecision: node.first("EvalDecision", true, x => (x.content ?? '') as PolicyEvaluationDecisionType),
    MatchedStatements: node.getList("MatchedStatements", "member").map(Statement_Parse),
    MissingContextValues: node.getList("MissingContextValues", "member").map(x => x.content ?? ''),
    OrganizationsDecisionDetail: node.first("OrganizationsDecisionDetail", false, OrganizationsDecisionDetail_Parse),
    PermissionsBoundaryDecisionDetail: node.first("PermissionsBoundaryDecisionDetail", false, PermissionsBoundaryDecisionDetail_Parse),
    EvalDecisionDetails: readXmlMap(node.getList("EvalDecisionDetails", "entry"), x => (x.content ?? '') as PolicyEvaluationDecisionType, {}),
    ResourceSpecificResults: node.getList("ResourceSpecificResults", "member").map(ResourceSpecificResult_Parse),
  };
}

// refs: 4 - tags: output, named, enum
export type PolicyEvaluationDecisionType =
| "allowed"
| "explicitDeny"
| "implicitDeny"
;


// refs: 2 - tags: output, named, interface
export interface Statement {
  SourcePolicyId?: string | null;
  SourcePolicyType?: PolicySourceType | null;
  StartPosition?: Position | null;
  EndPosition?: Position | null;
}
function Statement_Parse(node: XmlNode): Statement {
  return {
    ...node.strings({
      optional: {"SourcePolicyId":true},
    }),
    SourcePolicyType: node.first("SourcePolicyType", false, x => (x.content ?? '') as PolicySourceType),
    StartPosition: node.first("StartPosition", false, Position_Parse),
    EndPosition: node.first("EndPosition", false, Position_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type PolicySourceType =
| "user"
| "group"
| "role"
| "aws-managed"
| "user-managed"
| "resource"
| "none"
;


// refs: 4 - tags: output, named, interface
export interface Position {
  Line?: number | null;
  Column?: number | null;
}
function Position_Parse(node: XmlNode): Position {
  return {
    Line: node.first("Line", false, x => parseInt(x.content ?? '0')),
    Column: node.first("Column", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface OrganizationsDecisionDetail {
  AllowedByOrganizations?: boolean | null;
}
function OrganizationsDecisionDetail_Parse(node: XmlNode): OrganizationsDecisionDetail {
  return {
    AllowedByOrganizations: node.first("AllowedByOrganizations", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface PermissionsBoundaryDecisionDetail {
  AllowedByPermissionsBoundary?: boolean | null;
}
function PermissionsBoundaryDecisionDetail_Parse(node: XmlNode): PermissionsBoundaryDecisionDetail {
  return {
    AllowedByPermissionsBoundary: node.first("AllowedByPermissionsBoundary", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface ResourceSpecificResult {
  EvalResourceName: string;
  EvalResourceDecision: PolicyEvaluationDecisionType;
  MatchedStatements: Statement[];
  MissingContextValues: string[];
  EvalDecisionDetails: { [key: string]: PolicyEvaluationDecisionType };
  PermissionsBoundaryDecisionDetail?: PermissionsBoundaryDecisionDetail | null;
}
function ResourceSpecificResult_Parse(node: XmlNode): ResourceSpecificResult {
  return {
    ...node.strings({
      required: {"EvalResourceName":true},
    }),
    EvalResourceDecision: node.first("EvalResourceDecision", true, x => (x.content ?? '') as PolicyEvaluationDecisionType),
    MatchedStatements: node.getList("MatchedStatements", "member").map(Statement_Parse),
    MissingContextValues: node.getList("MissingContextValues", "member").map(x => x.content ?? ''),
    EvalDecisionDetails: readXmlMap(node.getList("EvalDecisionDetails", "entry"), x => (x.content ?? '') as PolicyEvaluationDecisionType, {}),
    PermissionsBoundaryDecisionDetail: node.first("PermissionsBoundaryDecisionDetail", false, PermissionsBoundaryDecisionDetail_Parse),
  };
}
