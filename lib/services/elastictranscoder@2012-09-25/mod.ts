// Autogenerated API client for: Amazon Elastic Transcoder

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ElasticTranscoder {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElasticTranscoder.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2012-09-25",
    "endpointPrefix": "elastictranscoder",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Elastic Transcoder",
    "serviceId": "Elastic Transcoder",
    "signatureVersion": "v4",
    "uid": "elastictranscoder-2012-09-25"
  };

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & CancelJobRequest,
  ): Promise<CancelJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/jobs/${params["Id"]}`,
      responseCode: 202,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & CreateJobRequest,
  ): Promise<CreateJobResponse> {
    const body: jsonP.JSONObject = params ? {
      PipelineId: params["PipelineId"],
      Input: fromJobInput(params["Input"]),
      Inputs: params["Inputs"]?.map(x => fromJobInput(x)),
      Output: fromCreateJobOutput(params["Output"]),
      Outputs: params["Outputs"]?.map(x => fromCreateJobOutput(x)),
      OutputKeyPrefix: params["OutputKeyPrefix"],
      Playlists: params["Playlists"]?.map(x => fromCreateJobPlaylist(x)),
      UserMetadata: params["UserMetadata"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
      requestUri: "/2012-09-25/jobs",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Job": toJob,
        },
      }, await resp.json()),
  };
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & CreatePipelineRequest,
  ): Promise<CreatePipelineResponse> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      InputBucket: params["InputBucket"],
      OutputBucket: params["OutputBucket"],
      Role: params["Role"],
      AwsKmsKeyArn: params["AwsKmsKeyArn"],
      Notifications: fromNotifications(params["Notifications"]),
      ContentConfig: fromPipelineOutputConfig(params["ContentConfig"]),
      ThumbnailConfig: fromPipelineOutputConfig(params["ThumbnailConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
      requestUri: "/2012-09-25/pipelines",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipeline": toPipeline,
          "Warnings": [toWarning],
        },
      }, await resp.json()),
  };
  }

  async createPreset(
    {abortSignal, ...params}: RequestConfig & CreatePresetRequest,
  ): Promise<CreatePresetResponse> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Description: params["Description"],
      Container: params["Container"],
      Video: fromVideoParameters(params["Video"]),
      Audio: fromAudioParameters(params["Audio"]),
      Thumbnails: fromThumbnails(params["Thumbnails"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePreset",
      requestUri: "/2012-09-25/presets",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Preset": toPreset,
          "Warning": "s",
        },
      }, await resp.json()),
  };
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & DeletePipelineRequest,
  ): Promise<DeletePipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePipeline",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
      responseCode: 202,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deletePreset(
    {abortSignal, ...params}: RequestConfig & DeletePresetRequest,
  ): Promise<DeletePresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePreset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/presets/${params["Id"]}`,
      responseCode: 202,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async listJobsByPipeline(
    {abortSignal, ...params}: RequestConfig & ListJobsByPipelineRequest,
  ): Promise<ListJobsByPipelineResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobsByPipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobsByPipeline/${params["PipelineId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Jobs": [toJob],
          "NextPageToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listJobsByStatus(
    {abortSignal, ...params}: RequestConfig & ListJobsByStatusRequest,
  ): Promise<ListJobsByStatusResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobsByStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobsByStatus/${params["Status"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Jobs": [toJob],
          "NextPageToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & ListPipelinesRequest = {},
  ): Promise<ListPipelinesResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPipelines",
      method: "GET",
      requestUri: "/2012-09-25/pipelines",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipelines": [toPipeline],
          "NextPageToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPresets(
    {abortSignal, ...params}: RequestConfig & ListPresetsRequest = {},
  ): Promise<ListPresetsResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPresets",
      method: "GET",
      requestUri: "/2012-09-25/presets",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Presets": [toPreset],
          "NextPageToken": "s",
        },
      }, await resp.json()),
  };
  }

  async readJob(
    {abortSignal, ...params}: RequestConfig & ReadJobRequest,
  ): Promise<ReadJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadJob",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobs/${params["Id"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Job": toJob,
        },
      }, await resp.json()),
  };
  }

  async readPipeline(
    {abortSignal, ...params}: RequestConfig & ReadPipelineRequest,
  ): Promise<ReadPipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadPipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipeline": toPipeline,
          "Warnings": [toWarning],
        },
      }, await resp.json()),
  };
  }

  async readPreset(
    {abortSignal, ...params}: RequestConfig & ReadPresetRequest,
  ): Promise<ReadPresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadPreset",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/presets/${params["Id"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Preset": toPreset,
        },
      }, await resp.json()),
  };
  }

  async testRole(
    {abortSignal, ...params}: RequestConfig & TestRoleRequest,
  ): Promise<TestRoleResponse> {
    const body: jsonP.JSONObject = params ? {
      Role: params["Role"],
      InputBucket: params["InputBucket"],
      OutputBucket: params["OutputBucket"],
      Topics: params["Topics"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRole",
      requestUri: "/2012-09-25/roleTests",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Success": "s",
          "Messages": ["s"],
        },
      }, await resp.json()),
  };
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & UpdatePipelineRequest,
  ): Promise<UpdatePipelineResponse> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      InputBucket: params["InputBucket"],
      Role: params["Role"],
      AwsKmsKeyArn: params["AwsKmsKeyArn"],
      Notifications: fromNotifications(params["Notifications"]),
      ContentConfig: fromPipelineOutputConfig(params["ContentConfig"]),
      ThumbnailConfig: fromPipelineOutputConfig(params["ThumbnailConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
      method: "PUT",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipeline": toPipeline,
          "Warnings": [toWarning],
        },
      }, await resp.json()),
  };
  }

  async updatePipelineNotifications(
    {abortSignal, ...params}: RequestConfig & UpdatePipelineNotificationsRequest,
  ): Promise<UpdatePipelineNotificationsResponse> {
    const body: jsonP.JSONObject = params ? {
      Notifications: fromNotifications(params["Notifications"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipelineNotifications",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}/notifications`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipeline": toPipeline,
        },
      }, await resp.json()),
  };
  }

  async updatePipelineStatus(
    {abortSignal, ...params}: RequestConfig & UpdatePipelineStatusRequest,
  ): Promise<UpdatePipelineStatusResponse> {
    const body: jsonP.JSONObject = params ? {
      Status: params["Status"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipelineStatus",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}/status`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Pipeline": toPipeline,
        },
      }, await resp.json()),
  };
  }

  // Resource State Waiters

  /** Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time). */
  async waitForJobComplete(
    params: RequestConfig & ReadJobRequest,
  ): Promise<ReadJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state JobComplete';
    for (let i = 0; i < 120; i++) {
      const resp = await this.readJob(params);
      const field = resp?.Job?.Status;
      if (field === "Complete") return resp;
      if (field === "Canceled") throw new Error(errMessage);
      if (field === "Error") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CancelJobRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface CreateJobRequest {
  PipelineId: string;
  Input?: JobInput | null;
  Inputs?: JobInput[] | null;
  Output?: CreateJobOutput | null;
  Outputs?: CreateJobOutput[] | null;
  OutputKeyPrefix?: string | null;
  Playlists?: CreateJobPlaylist[] | null;
  UserMetadata?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreatePipelineRequest {
  Name: string;
  InputBucket: string;
  OutputBucket?: string | null;
  Role: string;
  AwsKmsKeyArn?: string | null;
  Notifications?: Notifications | null;
  ContentConfig?: PipelineOutputConfig | null;
  ThumbnailConfig?: PipelineOutputConfig | null;
}

// refs: 1 - tags: named, input
export interface CreatePresetRequest {
  Name: string;
  Description?: string | null;
  Container: string;
  Video?: VideoParameters | null;
  Audio?: AudioParameters | null;
  Thumbnails?: Thumbnails | null;
}

// refs: 1 - tags: named, input
export interface DeletePipelineRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeletePresetRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ListJobsByPipelineRequest {
  PipelineId: string;
  Ascending?: string | null;
  PageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListJobsByStatusRequest {
  Status: string;
  Ascending?: string | null;
  PageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPipelinesRequest {
  Ascending?: string | null;
  PageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPresetsRequest {
  Ascending?: string | null;
  PageToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ReadJobRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ReadPipelineRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ReadPresetRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface TestRoleRequest {
  Role: string;
  InputBucket: string;
  OutputBucket: string;
  Topics: string[];
}

// refs: 1 - tags: named, input
export interface UpdatePipelineRequest {
  Id: string;
  Name?: string | null;
  InputBucket?: string | null;
  Role?: string | null;
  AwsKmsKeyArn?: string | null;
  Notifications?: Notifications | null;
  ContentConfig?: PipelineOutputConfig | null;
  ThumbnailConfig?: PipelineOutputConfig | null;
}

// refs: 1 - tags: named, input
export interface UpdatePipelineNotificationsRequest {
  Id: string;
  Notifications: Notifications;
}

// refs: 1 - tags: named, input
export interface UpdatePipelineStatusRequest {
  Id: string;
  Status: string;
}

// refs: 1 - tags: named, output
export interface CancelJobResponse {
}

// refs: 1 - tags: named, output
export interface CreateJobResponse {
  Job?: Job | null;
}

// refs: 1 - tags: named, output
export interface CreatePipelineResponse {
  Pipeline?: Pipeline | null;
  Warnings?: Warning[] | null;
}

// refs: 1 - tags: named, output
export interface CreatePresetResponse {
  Preset?: Preset | null;
  Warning?: string | null;
}

// refs: 1 - tags: named, output
export interface DeletePipelineResponse {
}

// refs: 1 - tags: named, output
export interface DeletePresetResponse {
}

// refs: 1 - tags: named, output
export interface ListJobsByPipelineResponse {
  Jobs?: Job[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsByStatusResponse {
  Jobs?: Job[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPipelinesResponse {
  Pipelines?: Pipeline[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPresetsResponse {
  Presets?: Preset[] | null;
  NextPageToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ReadJobResponse {
  Job?: Job | null;
}

// refs: 1 - tags: named, output
export interface ReadPipelineResponse {
  Pipeline?: Pipeline | null;
  Warnings?: Warning[] | null;
}

// refs: 1 - tags: named, output
export interface ReadPresetResponse {
  Preset?: Preset | null;
}

// refs: 1 - tags: named, output
export interface TestRoleResponse {
  Success?: string | null;
  Messages?: string[] | null;
}

// refs: 1 - tags: named, output
export interface UpdatePipelineResponse {
  Pipeline?: Pipeline | null;
  Warnings?: Warning[] | null;
}

// refs: 1 - tags: named, output
export interface UpdatePipelineNotificationsResponse {
  Pipeline?: Pipeline | null;
}

// refs: 1 - tags: named, output
export interface UpdatePipelineStatusResponse {
  Pipeline?: Pipeline | null;
}

// refs: 10 - tags: input, named, interface, output
export interface JobInput {
  Key?: string | null;
  FrameRate?: string | null;
  Resolution?: string | null;
  AspectRatio?: string | null;
  Interlaced?: string | null;
  Container?: string | null;
  Encryption?: Encryption | null;
  TimeSpan?: TimeSpan | null;
  InputCaptions?: InputCaptions | null;
  DetectedProperties?: DetectedProperties | null;
}
function fromJobInput(input?: JobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    FrameRate: input["FrameRate"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    Interlaced: input["Interlaced"],
    Container: input["Container"],
    Encryption: fromEncryption(input["Encryption"]),
    TimeSpan: fromTimeSpan(input["TimeSpan"]),
    InputCaptions: fromInputCaptions(input["InputCaptions"]),
    DetectedProperties: fromDetectedProperties(input["DetectedProperties"]),
  }
}
function toJobInput(root: jsonP.JSONValue): JobInput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "FrameRate": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "Interlaced": "s",
      "Container": "s",
      "Encryption": toEncryption,
      "TimeSpan": toTimeSpan,
      "InputCaptions": toInputCaptions,
      "DetectedProperties": toDetectedProperties,
    },
  }, root);
}

// refs: 80 - tags: input, named, interface, output
export interface Encryption {
  Mode?: string | null;
  Key?: string | null;
  KeyMd5?: string | null;
  InitializationVector?: string | null;
}
function fromEncryption(input?: Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Mode: input["Mode"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    InitializationVector: input["InitializationVector"],
  }
}
function toEncryption(root: jsonP.JSONValue): Encryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "Mode": "s",
      "Key": "s",
      "KeyMd5": "s",
      "InitializationVector": "s",
    },
  }, root);
}

// refs: 20 - tags: input, named, interface, output
export interface TimeSpan {
  StartTime?: string | null;
  Duration?: string | null;
}
function fromTimeSpan(input?: TimeSpan | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTime: input["StartTime"],
    Duration: input["Duration"],
  }
}
function toTimeSpan(root: jsonP.JSONValue): TimeSpan {
  return jsonP.readObj({
    required: {},
    optional: {
      "StartTime": "s",
      "Duration": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface InputCaptions {
  MergePolicy?: string | null;
  CaptionSources?: CaptionSource[] | null;
}
function fromInputCaptions(input?: InputCaptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    CaptionSources: input["CaptionSources"]?.map(x => fromCaptionSource(x)),
  }
}
function toInputCaptions(root: jsonP.JSONValue): InputCaptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "CaptionSources": [toCaptionSource],
    },
  }, root);
}

// refs: 20 - tags: input, named, interface, output
export interface CaptionSource {
  Key?: string | null;
  Language?: string | null;
  TimeOffset?: string | null;
  Label?: string | null;
  Encryption?: Encryption | null;
}
function fromCaptionSource(input?: CaptionSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Language: input["Language"],
    TimeOffset: input["TimeOffset"],
    Label: input["Label"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toCaptionSource(root: jsonP.JSONValue): CaptionSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Language": "s",
      "TimeOffset": "s",
      "Label": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface DetectedProperties {
  Width?: number | null;
  Height?: number | null;
  FrameRate?: string | null;
  FileSize?: number | null;
  DurationMillis?: number | null;
}
function fromDetectedProperties(input?: DetectedProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Width: input["Width"],
    Height: input["Height"],
    FrameRate: input["FrameRate"],
    FileSize: input["FileSize"],
    DurationMillis: input["DurationMillis"],
  }
}
function toDetectedProperties(root: jsonP.JSONValue): DetectedProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Width": "n",
      "Height": "n",
      "FrameRate": "s",
      "FileSize": "n",
      "DurationMillis": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface CreateJobOutput {
  Key?: string | null;
  ThumbnailPattern?: string | null;
  ThumbnailEncryption?: Encryption | null;
  Rotate?: string | null;
  PresetId?: string | null;
  SegmentDuration?: string | null;
  Watermarks?: JobWatermark[] | null;
  AlbumArt?: JobAlbumArt | null;
  Composition?: Clip[] | null;
  Captions?: Captions | null;
  Encryption?: Encryption | null;
}
function fromCreateJobOutput(input?: CreateJobOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    ThumbnailPattern: input["ThumbnailPattern"],
    ThumbnailEncryption: fromEncryption(input["ThumbnailEncryption"]),
    Rotate: input["Rotate"],
    PresetId: input["PresetId"],
    SegmentDuration: input["SegmentDuration"],
    Watermarks: input["Watermarks"]?.map(x => fromJobWatermark(x)),
    AlbumArt: fromJobAlbumArt(input["AlbumArt"]),
    Composition: input["Composition"]?.map(x => fromClip(x)),
    Captions: fromCaptions(input["Captions"]),
    Encryption: fromEncryption(input["Encryption"]),
  }
}

// refs: 10 - tags: input, named, interface, output
export interface JobWatermark {
  PresetWatermarkId?: string | null;
  InputKey?: string | null;
  Encryption?: Encryption | null;
}
function fromJobWatermark(input?: JobWatermark | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PresetWatermarkId: input["PresetWatermarkId"],
    InputKey: input["InputKey"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toJobWatermark(root: jsonP.JSONValue): JobWatermark {
  return jsonP.readObj({
    required: {},
    optional: {
      "PresetWatermarkId": "s",
      "InputKey": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface JobAlbumArt {
  MergePolicy?: string | null;
  Artwork?: Artwork[] | null;
}
function fromJobAlbumArt(input?: JobAlbumArt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    Artwork: input["Artwork"]?.map(x => fromArtwork(x)),
  }
}
function toJobAlbumArt(root: jsonP.JSONValue): JobAlbumArt {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "Artwork": [toArtwork],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface Artwork {
  InputKey?: string | null;
  MaxWidth?: string | null;
  MaxHeight?: string | null;
  SizingPolicy?: string | null;
  PaddingPolicy?: string | null;
  AlbumArtFormat?: string | null;
  Encryption?: Encryption | null;
}
function fromArtwork(input?: Artwork | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputKey: input["InputKey"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
    AlbumArtFormat: input["AlbumArtFormat"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toArtwork(root: jsonP.JSONValue): Artwork {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputKey": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
      "AlbumArtFormat": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface Clip {
  TimeSpan?: TimeSpan | null;
}
function fromClip(input?: Clip | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeSpan: fromTimeSpan(input["TimeSpan"]),
  }
}
function toClip(root: jsonP.JSONValue): Clip {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimeSpan": toTimeSpan,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface Captions {
  MergePolicy?: string | null;
  CaptionSources?: CaptionSource[] | null;
  CaptionFormats?: CaptionFormat[] | null;
}
function fromCaptions(input?: Captions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    CaptionSources: input["CaptionSources"]?.map(x => fromCaptionSource(x)),
    CaptionFormats: input["CaptionFormats"]?.map(x => fromCaptionFormat(x)),
  }
}
function toCaptions(root: jsonP.JSONValue): Captions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "CaptionSources": [toCaptionSource],
      "CaptionFormats": [toCaptionFormat],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CaptionFormat {
  Format?: string | null;
  Pattern?: string | null;
  Encryption?: Encryption | null;
}
function fromCaptionFormat(input?: CaptionFormat | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Pattern: input["Pattern"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toCaptionFormat(root: jsonP.JSONValue): CaptionFormat {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Pattern": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface CreateJobPlaylist {
  Name?: string | null;
  Format?: string | null;
  OutputKeys?: string[] | null;
  HlsContentProtection?: HlsContentProtection | null;
  PlayReadyDrm?: PlayReadyDrm | null;
}
function fromCreateJobPlaylist(input?: CreateJobPlaylist | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Format: input["Format"],
    OutputKeys: input["OutputKeys"],
    HlsContentProtection: fromHlsContentProtection(input["HlsContentProtection"]),
    PlayReadyDrm: fromPlayReadyDrm(input["PlayReadyDrm"]),
  }
}

// refs: 5 - tags: input, named, interface, output
export interface HlsContentProtection {
  Method?: string | null;
  Key?: string | null;
  KeyMd5?: string | null;
  InitializationVector?: string | null;
  LicenseAcquisitionUrl?: string | null;
  KeyStoragePolicy?: string | null;
}
function fromHlsContentProtection(input?: HlsContentProtection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Method: input["Method"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    InitializationVector: input["InitializationVector"],
    LicenseAcquisitionUrl: input["LicenseAcquisitionUrl"],
    KeyStoragePolicy: input["KeyStoragePolicy"],
  }
}
function toHlsContentProtection(root: jsonP.JSONValue): HlsContentProtection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Method": "s",
      "Key": "s",
      "KeyMd5": "s",
      "InitializationVector": "s",
      "LicenseAcquisitionUrl": "s",
      "KeyStoragePolicy": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface PlayReadyDrm {
  Format?: string | null;
  Key?: string | null;
  KeyMd5?: string | null;
  KeyId?: string | null;
  InitializationVector?: string | null;
  LicenseAcquisitionUrl?: string | null;
}
function fromPlayReadyDrm(input?: PlayReadyDrm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    KeyId: input["KeyId"],
    InitializationVector: input["InitializationVector"],
    LicenseAcquisitionUrl: input["LicenseAcquisitionUrl"],
  }
}
function toPlayReadyDrm(root: jsonP.JSONValue): PlayReadyDrm {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Key": "s",
      "KeyMd5": "s",
      "KeyId": "s",
      "InitializationVector": "s",
      "LicenseAcquisitionUrl": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Notifications {
  Progressing?: string | null;
  Completed?: string | null;
  Warning?: string | null;
  Error?: string | null;
}
function fromNotifications(input?: Notifications | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Progressing: input["Progressing"],
    Completed: input["Completed"],
    Warning: input["Warning"],
    Error: input["Error"],
  }
}
function toNotifications(root: jsonP.JSONValue): Notifications {
  return jsonP.readObj({
    required: {},
    optional: {
      "Progressing": "s",
      "Completed": "s",
      "Warning": "s",
      "Error": "s",
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface PipelineOutputConfig {
  Bucket?: string | null;
  StorageClass?: string | null;
  Permissions?: Permission[] | null;
}
function fromPipelineOutputConfig(input?: PipelineOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    StorageClass: input["StorageClass"],
    Permissions: input["Permissions"]?.map(x => fromPermission(x)),
  }
}
function toPipelineOutputConfig(root: jsonP.JSONValue): PipelineOutputConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "StorageClass": "s",
      "Permissions": [toPermission],
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface Permission {
  GranteeType?: string | null;
  Grantee?: string | null;
  Access?: string[] | null;
}
function fromPermission(input?: Permission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GranteeType: input["GranteeType"],
    Grantee: input["Grantee"],
    Access: input["Access"],
  }
}
function toPermission(root: jsonP.JSONValue): Permission {
  return jsonP.readObj({
    required: {},
    optional: {
      "GranteeType": "s",
      "Grantee": "s",
      "Access": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface VideoParameters {
  Codec?: string | null;
  CodecOptions?: { [key: string]: string | null | undefined } | null;
  KeyframesMaxDist?: string | null;
  FixedGOP?: string | null;
  BitRate?: string | null;
  FrameRate?: string | null;
  MaxFrameRate?: string | null;
  Resolution?: string | null;
  AspectRatio?: string | null;
  MaxWidth?: string | null;
  MaxHeight?: string | null;
  DisplayAspectRatio?: string | null;
  SizingPolicy?: string | null;
  PaddingPolicy?: string | null;
  Watermarks?: PresetWatermark[] | null;
}
function fromVideoParameters(input?: VideoParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Codec: input["Codec"],
    CodecOptions: input["CodecOptions"],
    KeyframesMaxDist: input["KeyframesMaxDist"],
    FixedGOP: input["FixedGOP"],
    BitRate: input["BitRate"],
    FrameRate: input["FrameRate"],
    MaxFrameRate: input["MaxFrameRate"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    DisplayAspectRatio: input["DisplayAspectRatio"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
    Watermarks: input["Watermarks"]?.map(x => fromPresetWatermark(x)),
  }
}
function toVideoParameters(root: jsonP.JSONValue): VideoParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "CodecOptions": x => jsonP.readMap(String, String, x),
      "KeyframesMaxDist": "s",
      "FixedGOP": "s",
      "BitRate": "s",
      "FrameRate": "s",
      "MaxFrameRate": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "DisplayAspectRatio": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
      "Watermarks": [toPresetWatermark],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PresetWatermark {
  Id?: string | null;
  MaxWidth?: string | null;
  MaxHeight?: string | null;
  SizingPolicy?: string | null;
  HorizontalAlign?: string | null;
  HorizontalOffset?: string | null;
  VerticalAlign?: string | null;
  VerticalOffset?: string | null;
  Opacity?: string | null;
  Target?: string | null;
}
function fromPresetWatermark(input?: PresetWatermark | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    HorizontalAlign: input["HorizontalAlign"],
    HorizontalOffset: input["HorizontalOffset"],
    VerticalAlign: input["VerticalAlign"],
    VerticalOffset: input["VerticalOffset"],
    Opacity: input["Opacity"],
    Target: input["Target"],
  }
}
function toPresetWatermark(root: jsonP.JSONValue): PresetWatermark {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "HorizontalAlign": "s",
      "HorizontalOffset": "s",
      "VerticalAlign": "s",
      "VerticalOffset": "s",
      "Opacity": "s",
      "Target": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface AudioParameters {
  Codec?: string | null;
  SampleRate?: string | null;
  BitRate?: string | null;
  Channels?: string | null;
  AudioPackingMode?: string | null;
  CodecOptions?: AudioCodecOptions | null;
}
function fromAudioParameters(input?: AudioParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Codec: input["Codec"],
    SampleRate: input["SampleRate"],
    BitRate: input["BitRate"],
    Channels: input["Channels"],
    AudioPackingMode: input["AudioPackingMode"],
    CodecOptions: fromAudioCodecOptions(input["CodecOptions"]),
  }
}
function toAudioParameters(root: jsonP.JSONValue): AudioParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "SampleRate": "s",
      "BitRate": "s",
      "Channels": "s",
      "AudioPackingMode": "s",
      "CodecOptions": toAudioCodecOptions,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface AudioCodecOptions {
  Profile?: string | null;
  BitDepth?: string | null;
  BitOrder?: string | null;
  Signed?: string | null;
}
function fromAudioCodecOptions(input?: AudioCodecOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Profile: input["Profile"],
    BitDepth: input["BitDepth"],
    BitOrder: input["BitOrder"],
    Signed: input["Signed"],
  }
}
function toAudioCodecOptions(root: jsonP.JSONValue): AudioCodecOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Profile": "s",
      "BitDepth": "s",
      "BitOrder": "s",
      "Signed": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Thumbnails {
  Format?: string | null;
  Interval?: string | null;
  Resolution?: string | null;
  AspectRatio?: string | null;
  MaxWidth?: string | null;
  MaxHeight?: string | null;
  SizingPolicy?: string | null;
  PaddingPolicy?: string | null;
}
function fromThumbnails(input?: Thumbnails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Interval: input["Interval"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
  }
}
function toThumbnails(root: jsonP.JSONValue): Thumbnails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Interval": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Job {
  Id?: string | null;
  Arn?: string | null;
  PipelineId?: string | null;
  Input?: JobInput | null;
  Inputs?: JobInput[] | null;
  Output?: JobOutput | null;
  Outputs?: JobOutput[] | null;
  OutputKeyPrefix?: string | null;
  Playlists?: Playlist[] | null;
  Status?: string | null;
  UserMetadata?: { [key: string]: string | null | undefined } | null;
  Timing?: Timing | null;
}
function toJob(root: jsonP.JSONValue): Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "PipelineId": "s",
      "Input": toJobInput,
      "Inputs": [toJobInput],
      "Output": toJobOutput,
      "Outputs": [toJobOutput],
      "OutputKeyPrefix": "s",
      "Playlists": [toPlaylist],
      "Status": "s",
      "UserMetadata": x => jsonP.readMap(String, String, x),
      "Timing": toTiming,
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface JobOutput {
  Id?: string | null;
  Key?: string | null;
  ThumbnailPattern?: string | null;
  ThumbnailEncryption?: Encryption | null;
  Rotate?: string | null;
  PresetId?: string | null;
  SegmentDuration?: string | null;
  Status?: string | null;
  StatusDetail?: string | null;
  Duration?: number | null;
  Width?: number | null;
  Height?: number | null;
  FrameRate?: string | null;
  FileSize?: number | null;
  DurationMillis?: number | null;
  Watermarks?: JobWatermark[] | null;
  AlbumArt?: JobAlbumArt | null;
  Composition?: Clip[] | null;
  Captions?: Captions | null;
  Encryption?: Encryption | null;
  AppliedColorSpaceConversion?: string | null;
}
function toJobOutput(root: jsonP.JSONValue): JobOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Key": "s",
      "ThumbnailPattern": "s",
      "ThumbnailEncryption": toEncryption,
      "Rotate": "s",
      "PresetId": "s",
      "SegmentDuration": "s",
      "Status": "s",
      "StatusDetail": "s",
      "Duration": "n",
      "Width": "n",
      "Height": "n",
      "FrameRate": "s",
      "FileSize": "n",
      "DurationMillis": "n",
      "Watermarks": [toJobWatermark],
      "AlbumArt": toJobAlbumArt,
      "Composition": [toClip],
      "Captions": toCaptions,
      "Encryption": toEncryption,
      "AppliedColorSpaceConversion": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Playlist {
  Name?: string | null;
  Format?: string | null;
  OutputKeys?: string[] | null;
  HlsContentProtection?: HlsContentProtection | null;
  PlayReadyDrm?: PlayReadyDrm | null;
  Status?: string | null;
  StatusDetail?: string | null;
}
function toPlaylist(root: jsonP.JSONValue): Playlist {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Format": "s",
      "OutputKeys": ["s"],
      "HlsContentProtection": toHlsContentProtection,
      "PlayReadyDrm": toPlayReadyDrm,
      "Status": "s",
      "StatusDetail": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Timing {
  SubmitTimeMillis?: number | null;
  StartTimeMillis?: number | null;
  FinishTimeMillis?: number | null;
}
function toTiming(root: jsonP.JSONValue): Timing {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubmitTimeMillis": "n",
      "StartTimeMillis": "n",
      "FinishTimeMillis": "n",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Pipeline {
  Id?: string | null;
  Arn?: string | null;
  Name?: string | null;
  Status?: string | null;
  InputBucket?: string | null;
  OutputBucket?: string | null;
  Role?: string | null;
  AwsKmsKeyArn?: string | null;
  Notifications?: Notifications | null;
  ContentConfig?: PipelineOutputConfig | null;
  ThumbnailConfig?: PipelineOutputConfig | null;
}
function toPipeline(root: jsonP.JSONValue): Pipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "Name": "s",
      "Status": "s",
      "InputBucket": "s",
      "OutputBucket": "s",
      "Role": "s",
      "AwsKmsKeyArn": "s",
      "Notifications": toNotifications,
      "ContentConfig": toPipelineOutputConfig,
      "ThumbnailConfig": toPipelineOutputConfig,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Warning {
  Code?: string | null;
  Message?: string | null;
}
function toWarning(root: jsonP.JSONValue): Warning {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Preset {
  Id?: string | null;
  Arn?: string | null;
  Name?: string | null;
  Description?: string | null;
  Container?: string | null;
  Audio?: AudioParameters | null;
  Video?: VideoParameters | null;
  Thumbnails?: Thumbnails | null;
  Type?: string | null;
}
function toPreset(root: jsonP.JSONValue): Preset {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "Name": "s",
      "Description": "s",
      "Container": "s",
      "Audio": toAudioParameters,
      "Video": toVideoParameters,
      "Thumbnails": toThumbnails,
      "Type": "s",
    },
  }, root);
}
