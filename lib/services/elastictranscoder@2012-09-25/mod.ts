// Autogenerated API client for: Amazon Elastic Transcoder

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class ElasticTranscoder {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElasticTranscoder.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-09-25",
    "endpointPrefix": "elastictranscoder",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Elastic Transcoder",
    "serviceId": "Elastic Transcoder",
    "signatureVersion": "v4",
    "uid": "elastictranscoder-2012-09-25"
  };

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & s.CancelJobRequest,
  ): Promise<s.CancelJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/jobs/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & s.CreateJobRequest,
  ): Promise<s.CreateJobResponse> {
    const body: jsonP.JSONObject = {
      PipelineId: params["PipelineId"],
      Input: fromJobInput(params["Input"]),
      Inputs: params["Inputs"]?.map(x => fromJobInput(x)),
      Output: fromCreateJobOutput(params["Output"]),
      Outputs: params["Outputs"]?.map(x => fromCreateJobOutput(x)),
      OutputKeyPrefix: params["OutputKeyPrefix"],
      Playlists: params["Playlists"]?.map(x => fromCreateJobPlaylist(x)),
      UserMetadata: params["UserMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
      requestUri: "/2012-09-25/jobs",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & s.CreatePipelineRequest,
  ): Promise<s.CreatePipelineResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      InputBucket: params["InputBucket"],
      OutputBucket: params["OutputBucket"],
      Role: params["Role"],
      AwsKmsKeyArn: params["AwsKmsKeyArn"],
      Notifications: fromNotifications(params["Notifications"]),
      ContentConfig: fromPipelineOutputConfig(params["ContentConfig"]),
      ThumbnailConfig: fromPipelineOutputConfig(params["ThumbnailConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
      requestUri: "/2012-09-25/pipelines",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipeline": toPipeline,
        "Warnings": [toWarning],
      },
    }, await resp.json());
  }

  async createPreset(
    {abortSignal, ...params}: RequestConfig & s.CreatePresetRequest,
  ): Promise<s.CreatePresetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      Container: params["Container"],
      Video: fromVideoParameters(params["Video"]),
      Audio: fromAudioParameters(params["Audio"]),
      Thumbnails: fromThumbnails(params["Thumbnails"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePreset",
      requestUri: "/2012-09-25/presets",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
        "Warning": "s",
      },
    }, await resp.json());
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeletePipelineRequest,
  ): Promise<s.DeletePipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePipeline",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePreset(
    {abortSignal, ...params}: RequestConfig & s.DeletePresetRequest,
  ): Promise<s.DeletePresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePreset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2012-09-25/presets/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listJobsByPipeline(
    {abortSignal, ...params}: RequestConfig & s.ListJobsByPipelineRequest,
  ): Promise<s.ListJobsByPipelineResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobsByPipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobsByPipeline/${params["PipelineId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async listJobsByStatus(
    {abortSignal, ...params}: RequestConfig & s.ListJobsByStatusRequest,
  ): Promise<s.ListJobsByStatusResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobsByStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobsByStatus/${params["Status"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & s.ListPipelinesRequest = {},
  ): Promise<s.ListPipelinesResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPipelines",
      method: "GET",
      requestUri: "/2012-09-25/pipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipelines": [toPipeline],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async listPresets(
    {abortSignal, ...params}: RequestConfig & s.ListPresetsRequest = {},
  ): Promise<s.ListPresetsResponse> {
    const query = new URLSearchParams;
    if (params["Ascending"] != null) query.set("Ascending", params["Ascending"]?.toString() ?? "");
    if (params["PageToken"] != null) query.set("PageToken", params["PageToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPresets",
      method: "GET",
      requestUri: "/2012-09-25/presets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Presets": [toPreset],
        "NextPageToken": "s",
      },
    }, await resp.json());
  }

  async readJob(
    {abortSignal, ...params}: RequestConfig & s.ReadJobRequest,
  ): Promise<s.ReadJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadJob",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/jobs/${params["Id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async readPipeline(
    {abortSignal, ...params}: RequestConfig & s.ReadPipelineRequest,
  ): Promise<s.ReadPipelineResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadPipeline",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipeline": toPipeline,
        "Warnings": [toWarning],
      },
    }, await resp.json());
  }

  async readPreset(
    {abortSignal, ...params}: RequestConfig & s.ReadPresetRequest,
  ): Promise<s.ReadPresetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ReadPreset",
      method: "GET",
      requestUri: cmnP.encodePath`/2012-09-25/presets/${params["Id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Preset": toPreset,
      },
    }, await resp.json());
  }

  async testRole(
    {abortSignal, ...params}: RequestConfig & s.TestRoleRequest,
  ): Promise<s.TestRoleResponse> {
    const body: jsonP.JSONObject = {
      Role: params["Role"],
      InputBucket: params["InputBucket"],
      OutputBucket: params["OutputBucket"],
      Topics: params["Topics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRole",
      requestUri: "/2012-09-25/roleTests",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Success": "s",
        "Messages": ["s"],
      },
    }, await resp.json());
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineRequest,
  ): Promise<s.UpdatePipelineResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      InputBucket: params["InputBucket"],
      Role: params["Role"],
      AwsKmsKeyArn: params["AwsKmsKeyArn"],
      Notifications: fromNotifications(params["Notifications"]),
      ContentConfig: fromPipelineOutputConfig(params["ContentConfig"]),
      ThumbnailConfig: fromPipelineOutputConfig(params["ThumbnailConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
      method: "PUT",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipeline": toPipeline,
        "Warnings": [toWarning],
      },
    }, await resp.json());
  }

  async updatePipelineNotifications(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineNotificationsRequest,
  ): Promise<s.UpdatePipelineNotificationsResponse> {
    const body: jsonP.JSONObject = {
      Notifications: fromNotifications(params["Notifications"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipelineNotifications",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}/notifications`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipeline": toPipeline,
      },
    }, await resp.json());
  }

  async updatePipelineStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineStatusRequest,
  ): Promise<s.UpdatePipelineStatusResponse> {
    const body: jsonP.JSONObject = {
      Status: params["Status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipelineStatus",
      requestUri: cmnP.encodePath`/2012-09-25/pipelines/${params["Id"]}/status`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Pipeline": toPipeline,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time). */
  async waitForJobComplete(
    params: RequestConfig & s.ReadJobRequest,
  ): Promise<s.ReadJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state JobComplete';
    for (let i = 0; i < 120; i++) {
      const resp = await this.readJob(params);
      const field = resp?.Job?.Status;
      if (field === "Complete") return resp;
      if (field === "Canceled") throw new Error(errMessage);
      if (field === "Error") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function fromJobInput(input?: s.JobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    FrameRate: input["FrameRate"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    Interlaced: input["Interlaced"],
    Container: input["Container"],
    Encryption: fromEncryption(input["Encryption"]),
    TimeSpan: fromTimeSpan(input["TimeSpan"]),
    InputCaptions: fromInputCaptions(input["InputCaptions"]),
    DetectedProperties: fromDetectedProperties(input["DetectedProperties"]),
  }
}
function toJobInput(root: jsonP.JSONValue): s.JobInput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "FrameRate": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "Interlaced": "s",
      "Container": "s",
      "Encryption": toEncryption,
      "TimeSpan": toTimeSpan,
      "InputCaptions": toInputCaptions,
      "DetectedProperties": toDetectedProperties,
    },
  }, root);
}

function fromEncryption(input?: s.Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Mode: input["Mode"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    InitializationVector: input["InitializationVector"],
  }
}
function toEncryption(root: jsonP.JSONValue): s.Encryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "Mode": "s",
      "Key": "s",
      "KeyMd5": "s",
      "InitializationVector": "s",
    },
  }, root);
}

function fromTimeSpan(input?: s.TimeSpan | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTime: input["StartTime"],
    Duration: input["Duration"],
  }
}
function toTimeSpan(root: jsonP.JSONValue): s.TimeSpan {
  return jsonP.readObj({
    required: {},
    optional: {
      "StartTime": "s",
      "Duration": "s",
    },
  }, root);
}

function fromInputCaptions(input?: s.InputCaptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    CaptionSources: input["CaptionSources"]?.map(x => fromCaptionSource(x)),
  }
}
function toInputCaptions(root: jsonP.JSONValue): s.InputCaptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "CaptionSources": [toCaptionSource],
    },
  }, root);
}

function fromCaptionSource(input?: s.CaptionSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Language: input["Language"],
    TimeOffset: input["TimeOffset"],
    Label: input["Label"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toCaptionSource(root: jsonP.JSONValue): s.CaptionSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Language": "s",
      "TimeOffset": "s",
      "Label": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

function fromDetectedProperties(input?: s.DetectedProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Width: input["Width"],
    Height: input["Height"],
    FrameRate: input["FrameRate"],
    FileSize: input["FileSize"],
    DurationMillis: input["DurationMillis"],
  }
}
function toDetectedProperties(root: jsonP.JSONValue): s.DetectedProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Width": "n",
      "Height": "n",
      "FrameRate": "s",
      "FileSize": "n",
      "DurationMillis": "n",
    },
  }, root);
}

function fromCreateJobOutput(input?: s.CreateJobOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    ThumbnailPattern: input["ThumbnailPattern"],
    ThumbnailEncryption: fromEncryption(input["ThumbnailEncryption"]),
    Rotate: input["Rotate"],
    PresetId: input["PresetId"],
    SegmentDuration: input["SegmentDuration"],
    Watermarks: input["Watermarks"]?.map(x => fromJobWatermark(x)),
    AlbumArt: fromJobAlbumArt(input["AlbumArt"]),
    Composition: input["Composition"]?.map(x => fromClip(x)),
    Captions: fromCaptions(input["Captions"]),
    Encryption: fromEncryption(input["Encryption"]),
  }
}

function fromJobWatermark(input?: s.JobWatermark | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PresetWatermarkId: input["PresetWatermarkId"],
    InputKey: input["InputKey"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toJobWatermark(root: jsonP.JSONValue): s.JobWatermark {
  return jsonP.readObj({
    required: {},
    optional: {
      "PresetWatermarkId": "s",
      "InputKey": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

function fromJobAlbumArt(input?: s.JobAlbumArt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    Artwork: input["Artwork"]?.map(x => fromArtwork(x)),
  }
}
function toJobAlbumArt(root: jsonP.JSONValue): s.JobAlbumArt {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "Artwork": [toArtwork],
    },
  }, root);
}

function fromArtwork(input?: s.Artwork | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputKey: input["InputKey"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
    AlbumArtFormat: input["AlbumArtFormat"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toArtwork(root: jsonP.JSONValue): s.Artwork {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputKey": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
      "AlbumArtFormat": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

function fromClip(input?: s.Clip | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeSpan: fromTimeSpan(input["TimeSpan"]),
  }
}
function toClip(root: jsonP.JSONValue): s.Clip {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimeSpan": toTimeSpan,
    },
  }, root);
}

function fromCaptions(input?: s.Captions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MergePolicy: input["MergePolicy"],
    CaptionSources: input["CaptionSources"]?.map(x => fromCaptionSource(x)),
    CaptionFormats: input["CaptionFormats"]?.map(x => fromCaptionFormat(x)),
  }
}
function toCaptions(root: jsonP.JSONValue): s.Captions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MergePolicy": "s",
      "CaptionSources": [toCaptionSource],
      "CaptionFormats": [toCaptionFormat],
    },
  }, root);
}

function fromCaptionFormat(input?: s.CaptionFormat | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Pattern: input["Pattern"],
    Encryption: fromEncryption(input["Encryption"]),
  }
}
function toCaptionFormat(root: jsonP.JSONValue): s.CaptionFormat {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Pattern": "s",
      "Encryption": toEncryption,
    },
  }, root);
}

function fromCreateJobPlaylist(input?: s.CreateJobPlaylist | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Format: input["Format"],
    OutputKeys: input["OutputKeys"],
    HlsContentProtection: fromHlsContentProtection(input["HlsContentProtection"]),
    PlayReadyDrm: fromPlayReadyDrm(input["PlayReadyDrm"]),
  }
}

function fromHlsContentProtection(input?: s.HlsContentProtection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Method: input["Method"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    InitializationVector: input["InitializationVector"],
    LicenseAcquisitionUrl: input["LicenseAcquisitionUrl"],
    KeyStoragePolicy: input["KeyStoragePolicy"],
  }
}
function toHlsContentProtection(root: jsonP.JSONValue): s.HlsContentProtection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Method": "s",
      "Key": "s",
      "KeyMd5": "s",
      "InitializationVector": "s",
      "LicenseAcquisitionUrl": "s",
      "KeyStoragePolicy": "s",
    },
  }, root);
}

function fromPlayReadyDrm(input?: s.PlayReadyDrm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Key: input["Key"],
    KeyMd5: input["KeyMd5"],
    KeyId: input["KeyId"],
    InitializationVector: input["InitializationVector"],
    LicenseAcquisitionUrl: input["LicenseAcquisitionUrl"],
  }
}
function toPlayReadyDrm(root: jsonP.JSONValue): s.PlayReadyDrm {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Key": "s",
      "KeyMd5": "s",
      "KeyId": "s",
      "InitializationVector": "s",
      "LicenseAcquisitionUrl": "s",
    },
  }, root);
}

function fromNotifications(input?: s.Notifications | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Progressing: input["Progressing"],
    Completed: input["Completed"],
    Warning: input["Warning"],
    Error: input["Error"],
  }
}
function toNotifications(root: jsonP.JSONValue): s.Notifications {
  return jsonP.readObj({
    required: {},
    optional: {
      "Progressing": "s",
      "Completed": "s",
      "Warning": "s",
      "Error": "s",
    },
  }, root);
}

function fromPipelineOutputConfig(input?: s.PipelineOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    StorageClass: input["StorageClass"],
    Permissions: input["Permissions"]?.map(x => fromPermission(x)),
  }
}
function toPipelineOutputConfig(root: jsonP.JSONValue): s.PipelineOutputConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "StorageClass": "s",
      "Permissions": [toPermission],
    },
  }, root);
}

function fromPermission(input?: s.Permission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GranteeType: input["GranteeType"],
    Grantee: input["Grantee"],
    Access: input["Access"],
  }
}
function toPermission(root: jsonP.JSONValue): s.Permission {
  return jsonP.readObj({
    required: {},
    optional: {
      "GranteeType": "s",
      "Grantee": "s",
      "Access": ["s"],
    },
  }, root);
}

function fromVideoParameters(input?: s.VideoParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Codec: input["Codec"],
    CodecOptions: input["CodecOptions"],
    KeyframesMaxDist: input["KeyframesMaxDist"],
    FixedGOP: input["FixedGOP"],
    BitRate: input["BitRate"],
    FrameRate: input["FrameRate"],
    MaxFrameRate: input["MaxFrameRate"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    DisplayAspectRatio: input["DisplayAspectRatio"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
    Watermarks: input["Watermarks"]?.map(x => fromPresetWatermark(x)),
  }
}
function toVideoParameters(root: jsonP.JSONValue): s.VideoParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "CodecOptions": x => jsonP.readMap(String, String, x),
      "KeyframesMaxDist": "s",
      "FixedGOP": "s",
      "BitRate": "s",
      "FrameRate": "s",
      "MaxFrameRate": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "DisplayAspectRatio": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
      "Watermarks": [toPresetWatermark],
    },
  }, root);
}

function fromPresetWatermark(input?: s.PresetWatermark | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    HorizontalAlign: input["HorizontalAlign"],
    HorizontalOffset: input["HorizontalOffset"],
    VerticalAlign: input["VerticalAlign"],
    VerticalOffset: input["VerticalOffset"],
    Opacity: input["Opacity"],
    Target: input["Target"],
  }
}
function toPresetWatermark(root: jsonP.JSONValue): s.PresetWatermark {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "HorizontalAlign": "s",
      "HorizontalOffset": "s",
      "VerticalAlign": "s",
      "VerticalOffset": "s",
      "Opacity": "s",
      "Target": "s",
    },
  }, root);
}

function fromAudioParameters(input?: s.AudioParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Codec: input["Codec"],
    SampleRate: input["SampleRate"],
    BitRate: input["BitRate"],
    Channels: input["Channels"],
    AudioPackingMode: input["AudioPackingMode"],
    CodecOptions: fromAudioCodecOptions(input["CodecOptions"]),
  }
}
function toAudioParameters(root: jsonP.JSONValue): s.AudioParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "SampleRate": "s",
      "BitRate": "s",
      "Channels": "s",
      "AudioPackingMode": "s",
      "CodecOptions": toAudioCodecOptions,
    },
  }, root);
}

function fromAudioCodecOptions(input?: s.AudioCodecOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Profile: input["Profile"],
    BitDepth: input["BitDepth"],
    BitOrder: input["BitOrder"],
    Signed: input["Signed"],
  }
}
function toAudioCodecOptions(root: jsonP.JSONValue): s.AudioCodecOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Profile": "s",
      "BitDepth": "s",
      "BitOrder": "s",
      "Signed": "s",
    },
  }, root);
}

function fromThumbnails(input?: s.Thumbnails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Interval: input["Interval"],
    Resolution: input["Resolution"],
    AspectRatio: input["AspectRatio"],
    MaxWidth: input["MaxWidth"],
    MaxHeight: input["MaxHeight"],
    SizingPolicy: input["SizingPolicy"],
    PaddingPolicy: input["PaddingPolicy"],
  }
}
function toThumbnails(root: jsonP.JSONValue): s.Thumbnails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "Interval": "s",
      "Resolution": "s",
      "AspectRatio": "s",
      "MaxWidth": "s",
      "MaxHeight": "s",
      "SizingPolicy": "s",
      "PaddingPolicy": "s",
    },
  }, root);
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "PipelineId": "s",
      "Input": toJobInput,
      "Inputs": [toJobInput],
      "Output": toJobOutput,
      "Outputs": [toJobOutput],
      "OutputKeyPrefix": "s",
      "Playlists": [toPlaylist],
      "Status": "s",
      "UserMetadata": x => jsonP.readMap(String, String, x),
      "Timing": toTiming,
    },
  }, root);
}

function toJobOutput(root: jsonP.JSONValue): s.JobOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Key": "s",
      "ThumbnailPattern": "s",
      "ThumbnailEncryption": toEncryption,
      "Rotate": "s",
      "PresetId": "s",
      "SegmentDuration": "s",
      "Status": "s",
      "StatusDetail": "s",
      "Duration": "n",
      "Width": "n",
      "Height": "n",
      "FrameRate": "s",
      "FileSize": "n",
      "DurationMillis": "n",
      "Watermarks": [toJobWatermark],
      "AlbumArt": toJobAlbumArt,
      "Composition": [toClip],
      "Captions": toCaptions,
      "Encryption": toEncryption,
      "AppliedColorSpaceConversion": "s",
    },
  }, root);
}

function toPlaylist(root: jsonP.JSONValue): s.Playlist {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Format": "s",
      "OutputKeys": ["s"],
      "HlsContentProtection": toHlsContentProtection,
      "PlayReadyDrm": toPlayReadyDrm,
      "Status": "s",
      "StatusDetail": "s",
    },
  }, root);
}

function toTiming(root: jsonP.JSONValue): s.Timing {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubmitTimeMillis": "n",
      "StartTimeMillis": "n",
      "FinishTimeMillis": "n",
    },
  }, root);
}

function toPipeline(root: jsonP.JSONValue): s.Pipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "Name": "s",
      "Status": "s",
      "InputBucket": "s",
      "OutputBucket": "s",
      "Role": "s",
      "AwsKmsKeyArn": "s",
      "Notifications": toNotifications,
      "ContentConfig": toPipelineOutputConfig,
      "ThumbnailConfig": toPipelineOutputConfig,
    },
  }, root);
}

function toWarning(root: jsonP.JSONValue): s.Warning {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Message": "s",
    },
  }, root);
}

function toPreset(root: jsonP.JSONValue): s.Preset {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Arn": "s",
      "Name": "s",
      "Description": "s",
      "Container": "s",
      "Audio": toAudioParameters,
      "Video": toVideoParameters,
      "Thumbnails": toThumbnails,
      "Type": "s",
    },
  }, root);
}
