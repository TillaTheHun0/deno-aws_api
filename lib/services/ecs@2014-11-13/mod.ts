// Autogenerated API client for: Amazon EC2 Container Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ECS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ECS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-11-13",
    "endpointPrefix": "ecs",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon ECS",
    "serviceFullName": "Amazon EC2 Container Service",
    "serviceId": "ECS",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonEC2ContainerServiceV20141113",
    "uid": "ecs-2014-11-13"
  };

  async createCapacityProvider(
    {abortSignal, ...params}: RequestConfig & s.CreateCapacityProviderRequest,
  ): Promise<s.CreateCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      autoScalingGroupProvider: fromAutoScalingGroupProvider(params["autoScalingGroupProvider"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterRequest = {},
  ): Promise<s.CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      clusterName: params["clusterName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      settings: params["settings"]?.map(x => fromClusterSetting(x)),
      capacityProviders: params["capacityProviders"],
      defaultCapacityProviderStrategy: params["defaultCapacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async createService(
    {abortSignal, ...params}: RequestConfig & s.CreateServiceRequest,
  ): Promise<s.CreateServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      serviceName: params["serviceName"],
      taskDefinition: params["taskDefinition"],
      loadBalancers: params["loadBalancers"]?.map(x => fromLoadBalancer(x)),
      serviceRegistries: params["serviceRegistries"]?.map(x => fromServiceRegistry(x)),
      desiredCount: params["desiredCount"],
      clientToken: params["clientToken"],
      launchType: params["launchType"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      platformVersion: params["platformVersion"],
      role: params["role"],
      deploymentConfiguration: fromDeploymentConfiguration(params["deploymentConfiguration"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      healthCheckGracePeriodSeconds: params["healthCheckGracePeriodSeconds"],
      schedulingStrategy: params["schedulingStrategy"],
      deploymentController: fromDeploymentController(params["deploymentController"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      enableECSManagedTags: params["enableECSManagedTags"],
      propagateTags: params["propagateTags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async createTaskSet(
    {abortSignal, ...params}: RequestConfig & s.CreateTaskSetRequest,
  ): Promise<s.CreateTaskSetResponse> {
    const body: jsonP.JSONObject = {
      service: params["service"],
      cluster: params["cluster"],
      externalId: params["externalId"],
      taskDefinition: params["taskDefinition"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      loadBalancers: params["loadBalancers"]?.map(x => fromLoadBalancer(x)),
      serviceRegistries: params["serviceRegistries"]?.map(x => fromServiceRegistry(x)),
      launchType: params["launchType"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      platformVersion: params["platformVersion"],
      scale: fromScale(params["scale"]),
      clientToken: params["clientToken"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async deleteAccountSetting(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccountSettingRequest,
  ): Promise<s.DeleteAccountSettingResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      principalArn: params["principalArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccountSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async deleteAttributes(
    {abortSignal, ...params}: RequestConfig & s.DeleteAttributesRequest,
  ): Promise<s.DeleteAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
      },
    }, await resp.json());
  }

  async deleteCapacityProvider(
    {abortSignal, ...params}: RequestConfig & s.DeleteCapacityProviderRequest,
  ): Promise<s.DeleteCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      capacityProvider: params["capacityProvider"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterRequest,
  ): Promise<s.DeleteClusterResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteService(
    {abortSignal, ...params}: RequestConfig & s.DeleteServiceRequest,
  ): Promise<s.DeleteServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async deleteTaskSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteTaskSetRequest,
  ): Promise<s.DeleteTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSet: params["taskSet"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async deregisterContainerInstance(
    {abortSignal, ...params}: RequestConfig & s.DeregisterContainerInstanceRequest,
  ): Promise<s.DeregisterContainerInstanceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterContainerInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async deregisterTaskDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTaskDefinitionRequest,
  ): Promise<s.DeregisterTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
      },
    }, await resp.json());
  }

  async describeCapacityProviders(
    {abortSignal, ...params}: RequestConfig & s.DescribeCapacityProvidersRequest = {},
  ): Promise<s.DescribeCapacityProvidersResponse> {
    const body: jsonP.JSONObject = {
      capacityProviders: params["capacityProviders"],
      include: params["include"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCapacityProviders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProviders": [toCapacityProvider],
        "failures": [toFailure],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeClustersRequest = {},
  ): Promise<s.DescribeClustersResponse> {
    const body: jsonP.JSONObject = {
      clusters: params["clusters"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusters": [toCluster],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeContainerInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeContainerInstancesRequest,
  ): Promise<s.DescribeContainerInstancesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContainerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstances": [toContainerInstance],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeServices(
    {abortSignal, ...params}: RequestConfig & s.DescribeServicesRequest,
  ): Promise<s.DescribeServicesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      services: params["services"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "services": [toService],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeTaskDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeTaskDefinitionRequest,
  ): Promise<s.DescribeTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      taskDefinition: params["taskDefinition"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async describeTaskSets(
    {abortSignal, ...params}: RequestConfig & s.DescribeTaskSetsRequest,
  ): Promise<s.DescribeTaskSetsResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSets: params["taskSets"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTaskSets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSets": [toTaskSet],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeTasksRequest,
  ): Promise<s.DescribeTasksResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      tasks: params["tasks"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async discoverPollEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DiscoverPollEndpointRequest = {},
  ): Promise<s.DiscoverPollEndpointResponse> {
    const body: jsonP.JSONObject = {
      containerInstance: params["containerInstance"],
      cluster: params["cluster"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DiscoverPollEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "endpoint": "s",
        "telemetryEndpoint": "s",
      },
    }, await resp.json());
  }

  async listAccountSettings(
    {abortSignal, ...params}: RequestConfig & s.ListAccountSettingsRequest = {},
  ): Promise<s.ListAccountSettingsResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
      principalArn: params["principalArn"],
      effectiveSettings: params["effectiveSettings"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccountSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "settings": [toSetting],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAttributes(
    {abortSignal, ...params}: RequestConfig & s.ListAttributesRequest,
  ): Promise<s.ListAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      targetType: params["targetType"],
      attributeName: params["attributeName"],
      attributeValue: params["attributeValue"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & s.ListClustersRequest = {},
  ): Promise<s.ListClustersResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusterArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listContainerInstances(
    {abortSignal, ...params}: RequestConfig & s.ListContainerInstancesRequest = {},
  ): Promise<s.ListContainerInstancesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      filter: params["filter"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContainerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstanceArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listServices(
    {abortSignal, ...params}: RequestConfig & s.ListServicesRequest = {},
  ): Promise<s.ListServicesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      launchType: params["launchType"],
      schedulingStrategy: params["schedulingStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "serviceArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async listTaskDefinitionFamilies(
    {abortSignal, ...params}: RequestConfig & s.ListTaskDefinitionFamiliesRequest = {},
  ): Promise<s.ListTaskDefinitionFamiliesResponse> {
    const body: jsonP.JSONObject = {
      familyPrefix: params["familyPrefix"],
      status: params["status"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTaskDefinitionFamilies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "families": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTaskDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListTaskDefinitionsRequest = {},
  ): Promise<s.ListTaskDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      familyPrefix: params["familyPrefix"],
      status: params["status"],
      sort: params["sort"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTaskDefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinitionArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTasks(
    {abortSignal, ...params}: RequestConfig & s.ListTasksRequest = {},
  ): Promise<s.ListTasksResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
      family: params["family"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      startedBy: params["startedBy"],
      serviceName: params["serviceName"],
      desiredStatus: params["desiredStatus"],
      launchType: params["launchType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async putAccountSetting(
    {abortSignal, ...params}: RequestConfig & s.PutAccountSettingRequest,
  ): Promise<s.PutAccountSettingResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
      principalArn: params["principalArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAccountSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async putAccountSettingDefault(
    {abortSignal, ...params}: RequestConfig & s.PutAccountSettingDefaultRequest,
  ): Promise<s.PutAccountSettingDefaultResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAccountSettingDefault",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async putAttributes(
    {abortSignal, ...params}: RequestConfig & s.PutAttributesRequest,
  ): Promise<s.PutAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
      },
    }, await resp.json());
  }

  async putClusterCapacityProviders(
    {abortSignal, ...params}: RequestConfig & s.PutClusterCapacityProvidersRequest,
  ): Promise<s.PutClusterCapacityProvidersResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      capacityProviders: params["capacityProviders"],
      defaultCapacityProviderStrategy: params["defaultCapacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutClusterCapacityProviders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async registerContainerInstance(
    {abortSignal, ...params}: RequestConfig & s.RegisterContainerInstanceRequest = {},
  ): Promise<s.RegisterContainerInstanceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      instanceIdentityDocument: params["instanceIdentityDocument"],
      instanceIdentityDocumentSignature: params["instanceIdentityDocumentSignature"],
      totalResources: params["totalResources"]?.map(x => fromResource(x)),
      versionInfo: fromVersionInfo(params["versionInfo"]),
      containerInstanceArn: params["containerInstanceArn"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
      platformDevices: params["platformDevices"]?.map(x => fromPlatformDevice(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterContainerInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async registerTaskDefinition(
    {abortSignal, ...params}: RequestConfig & s.RegisterTaskDefinitionRequest,
  ): Promise<s.RegisterTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      family: params["family"],
      taskRoleArn: params["taskRoleArn"],
      executionRoleArn: params["executionRoleArn"],
      networkMode: params["networkMode"],
      containerDefinitions: params["containerDefinitions"]?.map(x => fromContainerDefinition(x)),
      volumes: params["volumes"]?.map(x => fromVolume(x)),
      placementConstraints: params["placementConstraints"]?.map(x => fromTaskDefinitionPlacementConstraint(x)),
      requiresCompatibilities: params["requiresCompatibilities"],
      cpu: params["cpu"],
      memory: params["memory"],
      tags: params["tags"]?.map(x => fromTag(x)),
      pidMode: params["pidMode"],
      ipcMode: params["ipcMode"],
      proxyConfiguration: fromProxyConfiguration(params["proxyConfiguration"]),
      inferenceAccelerators: params["inferenceAccelerators"]?.map(x => fromInferenceAccelerator(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async runTask(
    {abortSignal, ...params}: RequestConfig & s.RunTaskRequest,
  ): Promise<s.RunTaskResponse> {
    const body: jsonP.JSONObject = {
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      cluster: params["cluster"],
      count: params["count"],
      enableECSManagedTags: params["enableECSManagedTags"],
      group: params["group"],
      launchType: params["launchType"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      overrides: fromTaskOverride(params["overrides"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      platformVersion: params["platformVersion"],
      propagateTags: params["propagateTags"],
      referenceId: params["referenceId"],
      startedBy: params["startedBy"],
      tags: params["tags"]?.map(x => fromTag(x)),
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async startTask(
    {abortSignal, ...params}: RequestConfig & s.StartTaskRequest,
  ): Promise<s.StartTaskResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      enableECSManagedTags: params["enableECSManagedTags"],
      group: params["group"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      overrides: fromTaskOverride(params["overrides"]),
      propagateTags: params["propagateTags"],
      referenceId: params["referenceId"],
      startedBy: params["startedBy"],
      tags: params["tags"]?.map(x => fromTag(x)),
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async stopTask(
    {abortSignal, ...params}: RequestConfig & s.StopTaskRequest,
  ): Promise<s.StopTaskResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "task": toTask,
      },
    }, await resp.json());
  }

  async submitAttachmentStateChanges(
    {abortSignal, ...params}: RequestConfig & s.SubmitAttachmentStateChangesRequest,
  ): Promise<s.SubmitAttachmentStateChangesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attachments: params["attachments"]?.map(x => fromAttachmentStateChange(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitAttachmentStateChanges",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async submitContainerStateChange(
    {abortSignal, ...params}: RequestConfig & s.SubmitContainerStateChangeRequest = {},
  ): Promise<s.SubmitContainerStateChangeResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      containerName: params["containerName"],
      runtimeId: params["runtimeId"],
      status: params["status"],
      exitCode: params["exitCode"],
      reason: params["reason"],
      networkBindings: params["networkBindings"]?.map(x => fromNetworkBinding(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitContainerStateChange",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async submitTaskStateChange(
    {abortSignal, ...params}: RequestConfig & s.SubmitTaskStateChangeRequest = {},
  ): Promise<s.SubmitTaskStateChangeResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      status: params["status"],
      reason: params["reason"],
      containers: params["containers"]?.map(x => fromContainerStateChange(x)),
      attachments: params["attachments"]?.map(x => fromAttachmentStateChange(x)),
      pullStartedAt: jsonP.serializeDate_unixTimestamp(params["pullStartedAt"]),
      pullStoppedAt: jsonP.serializeDate_unixTimestamp(params["pullStoppedAt"]),
      executionStoppedAt: jsonP.serializeDate_unixTimestamp(params["executionStoppedAt"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitTaskStateChange",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateCapacityProvider(
    {abortSignal, ...params}: RequestConfig & s.UpdateCapacityProviderRequest,
  ): Promise<s.UpdateCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      autoScalingGroupProvider: fromAutoScalingGroupProviderUpdate(params["autoScalingGroupProvider"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async updateClusterSettings(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterSettingsRequest,
  ): Promise<s.UpdateClusterSettingsResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      settings: params["settings"]?.map(x => fromClusterSetting(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async updateContainerAgent(
    {abortSignal, ...params}: RequestConfig & s.UpdateContainerAgentRequest,
  ): Promise<s.UpdateContainerAgentResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContainerAgent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async updateContainerInstancesState(
    {abortSignal, ...params}: RequestConfig & s.UpdateContainerInstancesStateRequest,
  ): Promise<s.UpdateContainerInstancesStateResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContainerInstancesState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstances": [toContainerInstance],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async updateService(
    {abortSignal, ...params}: RequestConfig & s.UpdateServiceRequest,
  ): Promise<s.UpdateServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      desiredCount: params["desiredCount"],
      taskDefinition: params["taskDefinition"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      deploymentConfiguration: fromDeploymentConfiguration(params["deploymentConfiguration"]),
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      platformVersion: params["platformVersion"],
      forceNewDeployment: params["forceNewDeployment"],
      healthCheckGracePeriodSeconds: params["healthCheckGracePeriodSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async updateServicePrimaryTaskSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateServicePrimaryTaskSetRequest,
  ): Promise<s.UpdateServicePrimaryTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      primaryTaskSet: params["primaryTaskSet"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServicePrimaryTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async updateTaskSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateTaskSetRequest,
  ): Promise<s.UpdateTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSet: params["taskSet"],
      scale: fromScale(params["scale"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 100 times, 6 seconds apart (about 10 minutes max wait time). */
  async waitForTasksRunning(
    params: RequestConfig & s.DescribeTasksRequest,
  ): Promise<s.DescribeTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TasksRunning';
    for (let i = 0; i < 100; i++) {
      const resp = await this.describeTasks(params);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.some(x => x === "STOPPED")) throw new Error(errMessage);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.every(x => x === "RUNNING")) return resp;
      await new Promise(r => setTimeout(r, 6000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 100 times, 6 seconds apart (about 10 minutes max wait time). */
  async waitForTasksStopped(
    params: RequestConfig & s.DescribeTasksRequest,
  ): Promise<s.DescribeTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TasksStopped';
    for (let i = 0; i < 100; i++) {
      const resp = await this.describeTasks(params);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.every(x => x === "STOPPED")) return resp;
      await new Promise(r => setTimeout(r, 6000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForServicesStable(
    params: RequestConfig & s.DescribeServicesRequest,
  ): Promise<s.DescribeServicesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ServicesStable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeServices(params);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "DRAINING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "INACTIVE")) throw new Error(errMessage);
      if ((resp?.services?.filter(x => !((x?.deployments || '').length == 1 && x?.runningCount == x?.desiredCount)) || '').length == 0) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForServicesInactive(
    params: RequestConfig & s.DescribeServicesRequest,
  ): Promise<s.DescribeServicesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ServicesInactive';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeServices(params);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "INACTIVE")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function fromAutoScalingGroupProvider(input?: s.AutoScalingGroupProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    autoScalingGroupArn: input["autoScalingGroupArn"],
    managedScaling: fromManagedScaling(input["managedScaling"]),
    managedTerminationProtection: input["managedTerminationProtection"],
  }
}
function toAutoScalingGroupProvider(root: jsonP.JSONValue): s.AutoScalingGroupProvider {
  return jsonP.readObj({
    required: {
      "autoScalingGroupArn": "s",
    },
    optional: {
      "managedScaling": toManagedScaling,
      "managedTerminationProtection": (x: jsonP.JSONValue) => cmnP.readEnum<s.ManagedTerminationProtection>(x),
    },
  }, root);
}

function fromManagedScaling(input?: s.ManagedScaling | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    targetCapacity: input["targetCapacity"],
    minimumScalingStepSize: input["minimumScalingStepSize"],
    maximumScalingStepSize: input["maximumScalingStepSize"],
    instanceWarmupPeriod: input["instanceWarmupPeriod"],
  }
}
function toManagedScaling(root: jsonP.JSONValue): s.ManagedScaling {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ManagedScalingStatus>(x),
      "targetCapacity": "n",
      "minimumScalingStepSize": "n",
      "maximumScalingStepSize": "n",
      "instanceWarmupPeriod": "n",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

function fromClusterSetting(input?: s.ClusterSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toClusterSetting(root: jsonP.JSONValue): s.ClusterSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterSettingName>(x),
      "value": "s",
    },
  }, root);
}

function fromCapacityProviderStrategyItem(input?: s.CapacityProviderStrategyItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    capacityProvider: input["capacityProvider"],
    weight: input["weight"],
    base: input["base"],
  }
}
function toCapacityProviderStrategyItem(root: jsonP.JSONValue): s.CapacityProviderStrategyItem {
  return jsonP.readObj({
    required: {
      "capacityProvider": "s",
    },
    optional: {
      "weight": "n",
      "base": "n",
    },
  }, root);
}

function fromLoadBalancer(input?: s.LoadBalancer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetGroupArn: input["targetGroupArn"],
    loadBalancerName: input["loadBalancerName"],
    containerName: input["containerName"],
    containerPort: input["containerPort"],
  }
}
function toLoadBalancer(root: jsonP.JSONValue): s.LoadBalancer {
  return jsonP.readObj({
    required: {},
    optional: {
      "targetGroupArn": "s",
      "loadBalancerName": "s",
      "containerName": "s",
      "containerPort": "n",
    },
  }, root);
}

function fromServiceRegistry(input?: s.ServiceRegistry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    registryArn: input["registryArn"],
    port: input["port"],
    containerName: input["containerName"],
    containerPort: input["containerPort"],
  }
}
function toServiceRegistry(root: jsonP.JSONValue): s.ServiceRegistry {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryArn": "s",
      "port": "n",
      "containerName": "s",
      "containerPort": "n",
    },
  }, root);
}

function fromDeploymentConfiguration(input?: s.DeploymentConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deploymentCircuitBreaker: fromDeploymentCircuitBreaker(input["deploymentCircuitBreaker"]),
    maximumPercent: input["maximumPercent"],
    minimumHealthyPercent: input["minimumHealthyPercent"],
  }
}
function toDeploymentConfiguration(root: jsonP.JSONValue): s.DeploymentConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentCircuitBreaker": toDeploymentCircuitBreaker,
      "maximumPercent": "n",
      "minimumHealthyPercent": "n",
    },
  }, root);
}

function fromDeploymentCircuitBreaker(input?: s.DeploymentCircuitBreaker | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enable: input["enable"],
    rollback: input["rollback"],
  }
}
function toDeploymentCircuitBreaker(root: jsonP.JSONValue): s.DeploymentCircuitBreaker {
  return jsonP.readObj({
    required: {
      "enable": "b",
      "rollback": "b",
    },
    optional: {},
  }, root);
}

function fromPlacementConstraint(input?: s.PlacementConstraint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    expression: input["expression"],
  }
}
function toPlacementConstraint(root: jsonP.JSONValue): s.PlacementConstraint {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlacementConstraintType>(x),
      "expression": "s",
    },
  }, root);
}

function fromPlacementStrategy(input?: s.PlacementStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    field: input["field"],
  }
}
function toPlacementStrategy(root: jsonP.JSONValue): s.PlacementStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlacementStrategyType>(x),
      "field": "s",
    },
  }, root);
}

function fromNetworkConfiguration(input?: s.NetworkConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsvpcConfiguration: fromAwsVpcConfiguration(input["awsvpcConfiguration"]),
  }
}
function toNetworkConfiguration(root: jsonP.JSONValue): s.NetworkConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsvpcConfiguration": toAwsVpcConfiguration,
    },
  }, root);
}

function fromAwsVpcConfiguration(input?: s.AwsVpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnets: input["subnets"],
    securityGroups: input["securityGroups"],
    assignPublicIp: input["assignPublicIp"],
  }
}
function toAwsVpcConfiguration(root: jsonP.JSONValue): s.AwsVpcConfiguration {
  return jsonP.readObj({
    required: {
      "subnets": ["s"],
    },
    optional: {
      "securityGroups": ["s"],
      "assignPublicIp": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssignPublicIp>(x),
    },
  }, root);
}

function fromDeploymentController(input?: s.DeploymentController | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
  }
}
function toDeploymentController(root: jsonP.JSONValue): s.DeploymentController {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentControllerType>(x),
    },
    optional: {},
  }, root);
}

function fromScale(input?: s.Scale | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    unit: input["unit"],
  }
}
function toScale(root: jsonP.JSONValue): s.Scale {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": "n",
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScaleUnit>(x),
    },
  }, root);
}

function fromAttribute(input?: s.Attribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
    targetType: input["targetType"],
    targetId: input["targetId"],
  }
}
function toAttribute(root: jsonP.JSONValue): s.Attribute {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "value": "s",
      "targetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetType>(x),
      "targetId": "s",
    },
  }, root);
}

function fromResource(input?: s.Resource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
    doubleValue: input["doubleValue"],
    longValue: input["longValue"],
    integerValue: input["integerValue"],
    stringSetValue: input["stringSetValue"],
  }
}
function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "type": "s",
      "doubleValue": "n",
      "longValue": "n",
      "integerValue": "n",
      "stringSetValue": ["s"],
    },
  }, root);
}

function fromVersionInfo(input?: s.VersionInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    agentVersion: input["agentVersion"],
    agentHash: input["agentHash"],
    dockerVersion: input["dockerVersion"],
  }
}
function toVersionInfo(root: jsonP.JSONValue): s.VersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "agentVersion": "s",
      "agentHash": "s",
      "dockerVersion": "s",
    },
  }, root);
}

function fromPlatformDevice(input?: s.PlatformDevice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    type: input["type"],
  }
}

function fromContainerDefinition(input?: s.ContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    image: input["image"],
    repositoryCredentials: fromRepositoryCredentials(input["repositoryCredentials"]),
    cpu: input["cpu"],
    memory: input["memory"],
    memoryReservation: input["memoryReservation"],
    links: input["links"],
    portMappings: input["portMappings"]?.map(x => fromPortMapping(x)),
    essential: input["essential"],
    entryPoint: input["entryPoint"],
    command: input["command"],
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    environmentFiles: input["environmentFiles"]?.map(x => fromEnvironmentFile(x)),
    mountPoints: input["mountPoints"]?.map(x => fromMountPoint(x)),
    volumesFrom: input["volumesFrom"]?.map(x => fromVolumeFrom(x)),
    linuxParameters: fromLinuxParameters(input["linuxParameters"]),
    secrets: input["secrets"]?.map(x => fromSecret(x)),
    dependsOn: input["dependsOn"]?.map(x => fromContainerDependency(x)),
    startTimeout: input["startTimeout"],
    stopTimeout: input["stopTimeout"],
    hostname: input["hostname"],
    user: input["user"],
    workingDirectory: input["workingDirectory"],
    disableNetworking: input["disableNetworking"],
    privileged: input["privileged"],
    readonlyRootFilesystem: input["readonlyRootFilesystem"],
    dnsServers: input["dnsServers"],
    dnsSearchDomains: input["dnsSearchDomains"],
    extraHosts: input["extraHosts"]?.map(x => fromHostEntry(x)),
    dockerSecurityOptions: input["dockerSecurityOptions"],
    interactive: input["interactive"],
    pseudoTerminal: input["pseudoTerminal"],
    dockerLabels: input["dockerLabels"],
    ulimits: input["ulimits"]?.map(x => fromUlimit(x)),
    logConfiguration: fromLogConfiguration(input["logConfiguration"]),
    healthCheck: fromHealthCheck(input["healthCheck"]),
    systemControls: input["systemControls"]?.map(x => fromSystemControl(x)),
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
    firelensConfiguration: fromFirelensConfiguration(input["firelensConfiguration"]),
  }
}
function toContainerDefinition(root: jsonP.JSONValue): s.ContainerDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "image": "s",
      "repositoryCredentials": toRepositoryCredentials,
      "cpu": "n",
      "memory": "n",
      "memoryReservation": "n",
      "links": ["s"],
      "portMappings": [toPortMapping],
      "essential": "b",
      "entryPoint": ["s"],
      "command": ["s"],
      "environment": [toKeyValuePair],
      "environmentFiles": [toEnvironmentFile],
      "mountPoints": [toMountPoint],
      "volumesFrom": [toVolumeFrom],
      "linuxParameters": toLinuxParameters,
      "secrets": [toSecret],
      "dependsOn": [toContainerDependency],
      "startTimeout": "n",
      "stopTimeout": "n",
      "hostname": "s",
      "user": "s",
      "workingDirectory": "s",
      "disableNetworking": "b",
      "privileged": "b",
      "readonlyRootFilesystem": "b",
      "dnsServers": ["s"],
      "dnsSearchDomains": ["s"],
      "extraHosts": [toHostEntry],
      "dockerSecurityOptions": ["s"],
      "interactive": "b",
      "pseudoTerminal": "b",
      "dockerLabels": x => jsonP.readMap(String, String, x),
      "ulimits": [toUlimit],
      "logConfiguration": toLogConfiguration,
      "healthCheck": toHealthCheck,
      "systemControls": [toSystemControl],
      "resourceRequirements": [toResourceRequirement],
      "firelensConfiguration": toFirelensConfiguration,
    },
  }, root);
}

function fromRepositoryCredentials(input?: s.RepositoryCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credentialsParameter: input["credentialsParameter"],
  }
}
function toRepositoryCredentials(root: jsonP.JSONValue): s.RepositoryCredentials {
  return jsonP.readObj({
    required: {
      "credentialsParameter": "s",
    },
    optional: {},
  }, root);
}

function fromPortMapping(input?: s.PortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPort: input["containerPort"],
    hostPort: input["hostPort"],
    protocol: input["protocol"],
  }
}
function toPortMapping(root: jsonP.JSONValue): s.PortMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerPort": "n",
      "hostPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransportProtocol>(x),
    },
  }, root);
}

function fromKeyValuePair(input?: s.KeyValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toKeyValuePair(root: jsonP.JSONValue): s.KeyValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "value": "s",
    },
  }, root);
}

function fromEnvironmentFile(input?: s.EnvironmentFile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toEnvironmentFile(root: jsonP.JSONValue): s.EnvironmentFile {
  return jsonP.readObj({
    required: {
      "value": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EnvironmentFileType>(x),
    },
    optional: {},
  }, root);
}

function fromMountPoint(input?: s.MountPoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceVolume: input["sourceVolume"],
    containerPath: input["containerPath"],
    readOnly: input["readOnly"],
  }
}
function toMountPoint(root: jsonP.JSONValue): s.MountPoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourceVolume": "s",
      "containerPath": "s",
      "readOnly": "b",
    },
  }, root);
}

function fromVolumeFrom(input?: s.VolumeFrom | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceContainer: input["sourceContainer"],
    readOnly: input["readOnly"],
  }
}
function toVolumeFrom(root: jsonP.JSONValue): s.VolumeFrom {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourceContainer": "s",
      "readOnly": "b",
    },
  }, root);
}

function fromLinuxParameters(input?: s.LinuxParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    capabilities: fromKernelCapabilities(input["capabilities"]),
    devices: input["devices"]?.map(x => fromDevice(x)),
    initProcessEnabled: input["initProcessEnabled"],
    sharedMemorySize: input["sharedMemorySize"],
    tmpfs: input["tmpfs"]?.map(x => fromTmpfs(x)),
    maxSwap: input["maxSwap"],
    swappiness: input["swappiness"],
  }
}
function toLinuxParameters(root: jsonP.JSONValue): s.LinuxParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "capabilities": toKernelCapabilities,
      "devices": [toDevice],
      "initProcessEnabled": "b",
      "sharedMemorySize": "n",
      "tmpfs": [toTmpfs],
      "maxSwap": "n",
      "swappiness": "n",
    },
  }, root);
}

function fromKernelCapabilities(input?: s.KernelCapabilities | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    add: input["add"],
    drop: input["drop"],
  }
}
function toKernelCapabilities(root: jsonP.JSONValue): s.KernelCapabilities {
  return jsonP.readObj({
    required: {},
    optional: {
      "add": ["s"],
      "drop": ["s"],
    },
  }, root);
}

function fromDevice(input?: s.Device | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostPath: input["hostPath"],
    containerPath: input["containerPath"],
    permissions: input["permissions"],
  }
}
function toDevice(root: jsonP.JSONValue): s.Device {
  return jsonP.readObj({
    required: {
      "hostPath": "s",
    },
    optional: {
      "containerPath": "s",
      "permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceCgroupPermission>(x)],
    },
  }, root);
}

function fromTmpfs(input?: s.Tmpfs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPath: input["containerPath"],
    size: input["size"],
    mountOptions: input["mountOptions"],
  }
}
function toTmpfs(root: jsonP.JSONValue): s.Tmpfs {
  return jsonP.readObj({
    required: {
      "containerPath": "s",
      "size": "n",
    },
    optional: {
      "mountOptions": ["s"],
    },
  }, root);
}

function fromSecret(input?: s.Secret | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    valueFrom: input["valueFrom"],
  }
}
function toSecret(root: jsonP.JSONValue): s.Secret {
  return jsonP.readObj({
    required: {
      "name": "s",
      "valueFrom": "s",
    },
    optional: {},
  }, root);
}

function fromContainerDependency(input?: s.ContainerDependency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerName: input["containerName"],
    condition: input["condition"],
  }
}
function toContainerDependency(root: jsonP.JSONValue): s.ContainerDependency {
  return jsonP.readObj({
    required: {
      "containerName": "s",
      "condition": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerCondition>(x),
    },
    optional: {},
  }, root);
}

function fromHostEntry(input?: s.HostEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostname: input["hostname"],
    ipAddress: input["ipAddress"],
  }
}
function toHostEntry(root: jsonP.JSONValue): s.HostEntry {
  return jsonP.readObj({
    required: {
      "hostname": "s",
      "ipAddress": "s",
    },
    optional: {},
  }, root);
}

function fromUlimit(input?: s.Ulimit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    softLimit: input["softLimit"],
    hardLimit: input["hardLimit"],
  }
}
function toUlimit(root: jsonP.JSONValue): s.Ulimit {
  return jsonP.readObj({
    required: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.UlimitName>(x),
      "softLimit": "n",
      "hardLimit": "n",
    },
    optional: {},
  }, root);
}

function fromLogConfiguration(input?: s.LogConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logDriver: input["logDriver"],
    options: input["options"],
    secretOptions: input["secretOptions"]?.map(x => fromSecret(x)),
  }
}
function toLogConfiguration(root: jsonP.JSONValue): s.LogConfiguration {
  return jsonP.readObj({
    required: {
      "logDriver": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogDriver>(x),
    },
    optional: {
      "options": x => jsonP.readMap(String, String, x),
      "secretOptions": [toSecret],
    },
  }, root);
}

function fromHealthCheck(input?: s.HealthCheck | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    command: input["command"],
    interval: input["interval"],
    timeout: input["timeout"],
    retries: input["retries"],
    startPeriod: input["startPeriod"],
  }
}
function toHealthCheck(root: jsonP.JSONValue): s.HealthCheck {
  return jsonP.readObj({
    required: {
      "command": ["s"],
    },
    optional: {
      "interval": "n",
      "timeout": "n",
      "retries": "n",
      "startPeriod": "n",
    },
  }, root);
}

function fromSystemControl(input?: s.SystemControl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    namespace: input["namespace"],
    value: input["value"],
  }
}
function toSystemControl(root: jsonP.JSONValue): s.SystemControl {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "value": "s",
    },
  }, root);
}

function fromResourceRequirement(input?: s.ResourceRequirement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toResourceRequirement(root: jsonP.JSONValue): s.ResourceRequirement {
  return jsonP.readObj({
    required: {
      "value": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
    },
    optional: {},
  }, root);
}

function fromFirelensConfiguration(input?: s.FirelensConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    options: input["options"],
  }
}
function toFirelensConfiguration(root: jsonP.JSONValue): s.FirelensConfiguration {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FirelensConfigurationType>(x),
    },
    optional: {
      "options": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromVolume(input?: s.Volume | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    host: fromHostVolumeProperties(input["host"]),
    dockerVolumeConfiguration: fromDockerVolumeConfiguration(input["dockerVolumeConfiguration"]),
    efsVolumeConfiguration: fromEFSVolumeConfiguration(input["efsVolumeConfiguration"]),
    fsxWindowsFileServerVolumeConfiguration: fromFSxWindowsFileServerVolumeConfiguration(input["fsxWindowsFileServerVolumeConfiguration"]),
  }
}
function toVolume(root: jsonP.JSONValue): s.Volume {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "host": toHostVolumeProperties,
      "dockerVolumeConfiguration": toDockerVolumeConfiguration,
      "efsVolumeConfiguration": toEFSVolumeConfiguration,
      "fsxWindowsFileServerVolumeConfiguration": toFSxWindowsFileServerVolumeConfiguration,
    },
  }, root);
}

function fromHostVolumeProperties(input?: s.HostVolumeProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourcePath: input["sourcePath"],
  }
}
function toHostVolumeProperties(root: jsonP.JSONValue): s.HostVolumeProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourcePath": "s",
    },
  }, root);
}

function fromDockerVolumeConfiguration(input?: s.DockerVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scope: input["scope"],
    autoprovision: input["autoprovision"],
    driver: input["driver"],
    driverOpts: input["driverOpts"],
    labels: input["labels"],
  }
}
function toDockerVolumeConfiguration(root: jsonP.JSONValue): s.DockerVolumeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "scope": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scope>(x),
      "autoprovision": "b",
      "driver": "s",
      "driverOpts": x => jsonP.readMap(String, String, x),
      "labels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromEFSVolumeConfiguration(input?: s.EFSVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileSystemId: input["fileSystemId"],
    rootDirectory: input["rootDirectory"],
    transitEncryption: input["transitEncryption"],
    transitEncryptionPort: input["transitEncryptionPort"],
    authorizationConfig: fromEFSAuthorizationConfig(input["authorizationConfig"]),
  }
}
function toEFSVolumeConfiguration(root: jsonP.JSONValue): s.EFSVolumeConfiguration {
  return jsonP.readObj({
    required: {
      "fileSystemId": "s",
    },
    optional: {
      "rootDirectory": "s",
      "transitEncryption": (x: jsonP.JSONValue) => cmnP.readEnum<s.EFSTransitEncryption>(x),
      "transitEncryptionPort": "n",
      "authorizationConfig": toEFSAuthorizationConfig,
    },
  }, root);
}

function fromEFSAuthorizationConfig(input?: s.EFSAuthorizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessPointId: input["accessPointId"],
    iam: input["iam"],
  }
}
function toEFSAuthorizationConfig(root: jsonP.JSONValue): s.EFSAuthorizationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPointId": "s",
      "iam": (x: jsonP.JSONValue) => cmnP.readEnum<s.EFSAuthorizationConfigIAM>(x),
    },
  }, root);
}

function fromFSxWindowsFileServerVolumeConfiguration(input?: s.FSxWindowsFileServerVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileSystemId: input["fileSystemId"],
    rootDirectory: input["rootDirectory"],
    authorizationConfig: fromFSxWindowsFileServerAuthorizationConfig(input["authorizationConfig"]),
  }
}
function toFSxWindowsFileServerVolumeConfiguration(root: jsonP.JSONValue): s.FSxWindowsFileServerVolumeConfiguration {
  return jsonP.readObj({
    required: {
      "fileSystemId": "s",
      "rootDirectory": "s",
      "authorizationConfig": toFSxWindowsFileServerAuthorizationConfig,
    },
    optional: {},
  }, root);
}

function fromFSxWindowsFileServerAuthorizationConfig(input?: s.FSxWindowsFileServerAuthorizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credentialsParameter: input["credentialsParameter"],
    domain: input["domain"],
  }
}
function toFSxWindowsFileServerAuthorizationConfig(root: jsonP.JSONValue): s.FSxWindowsFileServerAuthorizationConfig {
  return jsonP.readObj({
    required: {
      "credentialsParameter": "s",
      "domain": "s",
    },
    optional: {},
  }, root);
}

function fromTaskDefinitionPlacementConstraint(input?: s.TaskDefinitionPlacementConstraint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    expression: input["expression"],
  }
}
function toTaskDefinitionPlacementConstraint(root: jsonP.JSONValue): s.TaskDefinitionPlacementConstraint {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskDefinitionPlacementConstraintType>(x),
      "expression": "s",
    },
  }, root);
}

function fromProxyConfiguration(input?: s.ProxyConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    containerName: input["containerName"],
    properties: input["properties"]?.map(x => fromKeyValuePair(x)),
  }
}
function toProxyConfiguration(root: jsonP.JSONValue): s.ProxyConfiguration {
  return jsonP.readObj({
    required: {
      "containerName": "s",
    },
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProxyConfigurationType>(x),
      "properties": [toKeyValuePair],
    },
  }, root);
}

function fromInferenceAccelerator(input?: s.InferenceAccelerator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceName: input["deviceName"],
    deviceType: input["deviceType"],
  }
}
function toInferenceAccelerator(root: jsonP.JSONValue): s.InferenceAccelerator {
  return jsonP.readObj({
    required: {
      "deviceName": "s",
      "deviceType": "s",
    },
    optional: {},
  }, root);
}

function fromTaskOverride(input?: s.TaskOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerOverrides: input["containerOverrides"]?.map(x => fromContainerOverride(x)),
    cpu: input["cpu"],
    inferenceAcceleratorOverrides: input["inferenceAcceleratorOverrides"]?.map(x => fromInferenceAcceleratorOverride(x)),
    executionRoleArn: input["executionRoleArn"],
    memory: input["memory"],
    taskRoleArn: input["taskRoleArn"],
  }
}
function toTaskOverride(root: jsonP.JSONValue): s.TaskOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerOverrides": [toContainerOverride],
      "cpu": "s",
      "inferenceAcceleratorOverrides": [toInferenceAcceleratorOverride],
      "executionRoleArn": "s",
      "memory": "s",
      "taskRoleArn": "s",
    },
  }, root);
}

function fromContainerOverride(input?: s.ContainerOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    command: input["command"],
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    environmentFiles: input["environmentFiles"]?.map(x => fromEnvironmentFile(x)),
    cpu: input["cpu"],
    memory: input["memory"],
    memoryReservation: input["memoryReservation"],
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
  }
}
function toContainerOverride(root: jsonP.JSONValue): s.ContainerOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "command": ["s"],
      "environment": [toKeyValuePair],
      "environmentFiles": [toEnvironmentFile],
      "cpu": "n",
      "memory": "n",
      "memoryReservation": "n",
      "resourceRequirements": [toResourceRequirement],
    },
  }, root);
}

function fromInferenceAcceleratorOverride(input?: s.InferenceAcceleratorOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceName: input["deviceName"],
    deviceType: input["deviceType"],
  }
}
function toInferenceAcceleratorOverride(root: jsonP.JSONValue): s.InferenceAcceleratorOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "deviceName": "s",
      "deviceType": "s",
    },
  }, root);
}

function fromAttachmentStateChange(input?: s.AttachmentStateChange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attachmentArn: input["attachmentArn"],
    status: input["status"],
  }
}

function fromNetworkBinding(input?: s.NetworkBinding | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bindIP: input["bindIP"],
    containerPort: input["containerPort"],
    hostPort: input["hostPort"],
    protocol: input["protocol"],
  }
}
function toNetworkBinding(root: jsonP.JSONValue): s.NetworkBinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "bindIP": "s",
      "containerPort": "n",
      "hostPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransportProtocol>(x),
    },
  }, root);
}

function fromContainerStateChange(input?: s.ContainerStateChange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerName: input["containerName"],
    imageDigest: input["imageDigest"],
    runtimeId: input["runtimeId"],
    exitCode: input["exitCode"],
    networkBindings: input["networkBindings"]?.map(x => fromNetworkBinding(x)),
    reason: input["reason"],
    status: input["status"],
  }
}

function fromAutoScalingGroupProviderUpdate(input?: s.AutoScalingGroupProviderUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    managedScaling: fromManagedScaling(input["managedScaling"]),
    managedTerminationProtection: input["managedTerminationProtection"],
  }
}

function toCapacityProvider(root: jsonP.JSONValue): s.CapacityProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "capacityProviderArn": "s",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CapacityProviderStatus>(x),
      "autoScalingGroupProvider": toAutoScalingGroupProvider,
      "updateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CapacityProviderUpdateStatus>(x),
      "updateStatusReason": "s",
      "tags": [toTag],
    },
  }, root);
}

function toCluster(root: jsonP.JSONValue): s.Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterArn": "s",
      "clusterName": "s",
      "status": "s",
      "registeredContainerInstancesCount": "n",
      "runningTasksCount": "n",
      "pendingTasksCount": "n",
      "activeServicesCount": "n",
      "statistics": [toKeyValuePair],
      "tags": [toTag],
      "settings": [toClusterSetting],
      "capacityProviders": ["s"],
      "defaultCapacityProviderStrategy": [toCapacityProviderStrategyItem],
      "attachments": [toAttachment],
      "attachmentsStatus": "s",
    },
  }, root);
}

function toAttachment(root: jsonP.JSONValue): s.Attachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "type": "s",
      "status": "s",
      "details": [toKeyValuePair],
    },
  }, root);
}

function toService(root: jsonP.JSONValue): s.Service {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceArn": "s",
      "serviceName": "s",
      "clusterArn": "s",
      "loadBalancers": [toLoadBalancer],
      "serviceRegistries": [toServiceRegistry],
      "status": "s",
      "desiredCount": "n",
      "runningCount": "n",
      "pendingCount": "n",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LaunchType>(x),
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "platformVersion": "s",
      "taskDefinition": "s",
      "deploymentConfiguration": toDeploymentConfiguration,
      "taskSets": [toTaskSet],
      "deployments": [toDeployment],
      "roleArn": "s",
      "events": [toServiceEvent],
      "createdAt": "d",
      "placementConstraints": [toPlacementConstraint],
      "placementStrategy": [toPlacementStrategy],
      "networkConfiguration": toNetworkConfiguration,
      "healthCheckGracePeriodSeconds": "n",
      "schedulingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchedulingStrategy>(x),
      "deploymentController": toDeploymentController,
      "tags": [toTag],
      "createdBy": "s",
      "enableECSManagedTags": "b",
      "propagateTags": (x: jsonP.JSONValue) => cmnP.readEnum<s.PropagateTags>(x),
    },
  }, root);
}

function toTaskSet(root: jsonP.JSONValue): s.TaskSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "taskSetArn": "s",
      "serviceArn": "s",
      "clusterArn": "s",
      "startedBy": "s",
      "externalId": "s",
      "status": "s",
      "taskDefinition": "s",
      "computedDesiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "createdAt": "d",
      "updatedAt": "d",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LaunchType>(x),
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "platformVersion": "s",
      "networkConfiguration": toNetworkConfiguration,
      "loadBalancers": [toLoadBalancer],
      "serviceRegistries": [toServiceRegistry],
      "scale": toScale,
      "stabilityStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StabilityStatus>(x),
      "stabilityStatusAt": "d",
      "tags": [toTag],
    },
  }, root);
}

function toDeployment(root: jsonP.JSONValue): s.Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": "s",
      "taskDefinition": "s",
      "desiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "failedTasks": "n",
      "createdAt": "d",
      "updatedAt": "d",
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LaunchType>(x),
      "platformVersion": "s",
      "networkConfiguration": toNetworkConfiguration,
      "rolloutState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentRolloutState>(x),
      "rolloutStateReason": "s",
    },
  }, root);
}

function toServiceEvent(root: jsonP.JSONValue): s.ServiceEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "createdAt": "d",
      "message": "s",
    },
  }, root);
}

function toSetting(root: jsonP.JSONValue): s.Setting {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.SettingName>(x),
      "value": "s",
      "principalArn": "s",
    },
  }, root);
}

function toContainerInstance(root: jsonP.JSONValue): s.ContainerInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerInstanceArn": "s",
      "ec2InstanceId": "s",
      "capacityProviderName": "s",
      "version": "n",
      "versionInfo": toVersionInfo,
      "remainingResources": [toResource],
      "registeredResources": [toResource],
      "status": "s",
      "statusReason": "s",
      "agentConnected": "b",
      "runningTasksCount": "n",
      "pendingTasksCount": "n",
      "agentUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AgentUpdateStatus>(x),
      "attributes": [toAttribute],
      "registeredAt": "d",
      "attachments": [toAttachment],
      "tags": [toTag],
    },
  }, root);
}

function toTaskDefinition(root: jsonP.JSONValue): s.TaskDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskDefinitionArn": "s",
      "containerDefinitions": [toContainerDefinition],
      "family": "s",
      "taskRoleArn": "s",
      "executionRoleArn": "s",
      "networkMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkMode>(x),
      "revision": "n",
      "volumes": [toVolume],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskDefinitionStatus>(x),
      "requiresAttributes": [toAttribute],
      "placementConstraints": [toTaskDefinitionPlacementConstraint],
      "compatibilities": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Compatibility>(x)],
      "requiresCompatibilities": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Compatibility>(x)],
      "cpu": "s",
      "memory": "s",
      "inferenceAccelerators": [toInferenceAccelerator],
      "pidMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.PidMode>(x),
      "ipcMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpcMode>(x),
      "proxyConfiguration": toProxyConfiguration,
      "registeredAt": "d",
      "deregisteredAt": "d",
      "registeredBy": "s",
    },
  }, root);
}

function toFailure(root: jsonP.JSONValue): s.Failure {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "reason": "s",
      "detail": "s",
    },
  }, root);
}

function toTask(root: jsonP.JSONValue): s.Task {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachments": [toAttachment],
      "attributes": [toAttribute],
      "availabilityZone": "s",
      "capacityProviderName": "s",
      "clusterArn": "s",
      "connectivity": (x: jsonP.JSONValue) => cmnP.readEnum<s.Connectivity>(x),
      "connectivityAt": "d",
      "containerInstanceArn": "s",
      "containers": [toContainer],
      "cpu": "s",
      "createdAt": "d",
      "desiredStatus": "s",
      "executionStoppedAt": "d",
      "group": "s",
      "healthStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.HealthStatus>(x),
      "inferenceAccelerators": [toInferenceAccelerator],
      "lastStatus": "s",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LaunchType>(x),
      "memory": "s",
      "overrides": toTaskOverride,
      "platformVersion": "s",
      "pullStartedAt": "d",
      "pullStoppedAt": "d",
      "startedAt": "d",
      "startedBy": "s",
      "stopCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskStopCode>(x),
      "stoppedAt": "d",
      "stoppedReason": "s",
      "stoppingAt": "d",
      "tags": [toTag],
      "taskArn": "s",
      "taskDefinitionArn": "s",
      "version": "n",
    },
  }, root);
}

function toContainer(root: jsonP.JSONValue): s.Container {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerArn": "s",
      "taskArn": "s",
      "name": "s",
      "image": "s",
      "imageDigest": "s",
      "runtimeId": "s",
      "lastStatus": "s",
      "exitCode": "n",
      "reason": "s",
      "networkBindings": [toNetworkBinding],
      "networkInterfaces": [toNetworkInterface],
      "healthStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.HealthStatus>(x),
      "cpu": "s",
      "memory": "s",
      "memoryReservation": "s",
      "gpuIds": ["s"],
    },
  }, root);
}

function toNetworkInterface(root: jsonP.JSONValue): s.NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachmentId": "s",
      "privateIpv4Address": "s",
      "ipv6Address": "s",
    },
  }, root);
}
