// Autogenerated API client for: Amazon EC2 Container Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ECS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ECS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2014-11-13",
    "endpointPrefix": "ecs",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon ECS",
    "serviceFullName": "Amazon EC2 Container Service",
    "serviceId": "ECS",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonEC2ContainerServiceV20141113",
    "uid": "ecs-2014-11-13"
  };

  async createCapacityProvider(
    {abortSignal, ...params}: RequestConfig & CreateCapacityProviderRequest,
  ): Promise<CreateCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      autoScalingGroupProvider: fromAutoScalingGroupProvider(params["autoScalingGroupProvider"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & CreateClusterRequest = {},
  ): Promise<CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      clusterName: params["clusterName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      settings: params["settings"]?.map(x => fromClusterSetting(x)),
      capacityProviders: params["capacityProviders"],
      defaultCapacityProviderStrategy: params["defaultCapacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async createService(
    {abortSignal, ...params}: RequestConfig & CreateServiceRequest,
  ): Promise<CreateServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      serviceName: params["serviceName"],
      taskDefinition: params["taskDefinition"],
      loadBalancers: params["loadBalancers"]?.map(x => fromLoadBalancer(x)),
      serviceRegistries: params["serviceRegistries"]?.map(x => fromServiceRegistry(x)),
      desiredCount: params["desiredCount"],
      clientToken: params["clientToken"],
      launchType: params["launchType"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      platformVersion: params["platformVersion"],
      role: params["role"],
      deploymentConfiguration: fromDeploymentConfiguration(params["deploymentConfiguration"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      healthCheckGracePeriodSeconds: params["healthCheckGracePeriodSeconds"],
      schedulingStrategy: params["schedulingStrategy"],
      deploymentController: fromDeploymentController(params["deploymentController"]),
      tags: params["tags"]?.map(x => fromTag(x)),
      enableECSManagedTags: params["enableECSManagedTags"],
      propagateTags: params["propagateTags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async createTaskSet(
    {abortSignal, ...params}: RequestConfig & CreateTaskSetRequest,
  ): Promise<CreateTaskSetResponse> {
    const body: jsonP.JSONObject = {
      service: params["service"],
      cluster: params["cluster"],
      externalId: params["externalId"],
      taskDefinition: params["taskDefinition"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      loadBalancers: params["loadBalancers"]?.map(x => fromLoadBalancer(x)),
      serviceRegistries: params["serviceRegistries"]?.map(x => fromServiceRegistry(x)),
      launchType: params["launchType"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      platformVersion: params["platformVersion"],
      scale: fromScale(params["scale"]),
      clientToken: params["clientToken"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async deleteAccountSetting(
    {abortSignal, ...params}: RequestConfig & DeleteAccountSettingRequest,
  ): Promise<DeleteAccountSettingResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      principalArn: params["principalArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAccountSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async deleteAttributes(
    {abortSignal, ...params}: RequestConfig & DeleteAttributesRequest,
  ): Promise<DeleteAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
      },
    }, await resp.json());
  }

  async deleteCapacityProvider(
    {abortSignal, ...params}: RequestConfig & DeleteCapacityProviderRequest,
  ): Promise<DeleteCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      capacityProvider: params["capacityProvider"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & DeleteClusterRequest,
  ): Promise<DeleteClusterResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteService(
    {abortSignal, ...params}: RequestConfig & DeleteServiceRequest,
  ): Promise<DeleteServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async deleteTaskSet(
    {abortSignal, ...params}: RequestConfig & DeleteTaskSetRequest,
  ): Promise<DeleteTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSet: params["taskSet"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async deregisterContainerInstance(
    {abortSignal, ...params}: RequestConfig & DeregisterContainerInstanceRequest,
  ): Promise<DeregisterContainerInstanceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterContainerInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async deregisterTaskDefinition(
    {abortSignal, ...params}: RequestConfig & DeregisterTaskDefinitionRequest,
  ): Promise<DeregisterTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
      },
    }, await resp.json());
  }

  async describeCapacityProviders(
    {abortSignal, ...params}: RequestConfig & DescribeCapacityProvidersRequest = {},
  ): Promise<DescribeCapacityProvidersResponse> {
    const body: jsonP.JSONObject = {
      capacityProviders: params["capacityProviders"],
      include: params["include"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCapacityProviders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProviders": [toCapacityProvider],
        "failures": [toFailure],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & DescribeClustersRequest = {},
  ): Promise<DescribeClustersResponse> {
    const body: jsonP.JSONObject = {
      clusters: params["clusters"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusters": [toCluster],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeContainerInstances(
    {abortSignal, ...params}: RequestConfig & DescribeContainerInstancesRequest,
  ): Promise<DescribeContainerInstancesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContainerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstances": [toContainerInstance],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeServices(
    {abortSignal, ...params}: RequestConfig & DescribeServicesRequest,
  ): Promise<DescribeServicesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      services: params["services"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "services": [toService],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeTaskDefinition(
    {abortSignal, ...params}: RequestConfig & DescribeTaskDefinitionRequest,
  ): Promise<DescribeTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      taskDefinition: params["taskDefinition"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async describeTaskSets(
    {abortSignal, ...params}: RequestConfig & DescribeTaskSetsRequest,
  ): Promise<DescribeTaskSetsResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSets: params["taskSets"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTaskSets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSets": [toTaskSet],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async describeTasks(
    {abortSignal, ...params}: RequestConfig & DescribeTasksRequest,
  ): Promise<DescribeTasksResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      tasks: params["tasks"],
      include: params["include"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async discoverPollEndpoint(
    {abortSignal, ...params}: RequestConfig & DiscoverPollEndpointRequest = {},
  ): Promise<DiscoverPollEndpointResponse> {
    const body: jsonP.JSONObject = {
      containerInstance: params["containerInstance"],
      cluster: params["cluster"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DiscoverPollEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "endpoint": "s",
        "telemetryEndpoint": "s",
      },
    }, await resp.json());
  }

  async listAccountSettings(
    {abortSignal, ...params}: RequestConfig & ListAccountSettingsRequest = {},
  ): Promise<ListAccountSettingsResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
      principalArn: params["principalArn"],
      effectiveSettings: params["effectiveSettings"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAccountSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "settings": [toSetting],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listAttributes(
    {abortSignal, ...params}: RequestConfig & ListAttributesRequest,
  ): Promise<ListAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      targetType: params["targetType"],
      attributeName: params["attributeName"],
      attributeValue: params["attributeValue"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & ListClustersRequest = {},
  ): Promise<ListClustersResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clusterArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listContainerInstances(
    {abortSignal, ...params}: RequestConfig & ListContainerInstancesRequest = {},
  ): Promise<ListContainerInstancesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      filter: params["filter"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContainerInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstanceArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listServices(
    {abortSignal, ...params}: RequestConfig & ListServicesRequest = {},
  ): Promise<ListServicesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      launchType: params["launchType"],
      schedulingStrategy: params["schedulingStrategy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "serviceArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async listTaskDefinitionFamilies(
    {abortSignal, ...params}: RequestConfig & ListTaskDefinitionFamiliesRequest = {},
  ): Promise<ListTaskDefinitionFamiliesResponse> {
    const body: jsonP.JSONObject = {
      familyPrefix: params["familyPrefix"],
      status: params["status"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTaskDefinitionFamilies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "families": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTaskDefinitions(
    {abortSignal, ...params}: RequestConfig & ListTaskDefinitionsRequest = {},
  ): Promise<ListTaskDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      familyPrefix: params["familyPrefix"],
      status: params["status"],
      sort: params["sort"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTaskDefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinitionArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTasks(
    {abortSignal, ...params}: RequestConfig & ListTasksRequest = {},
  ): Promise<ListTasksResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
      family: params["family"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      startedBy: params["startedBy"],
      serviceName: params["serviceName"],
      desiredStatus: params["desiredStatus"],
      launchType: params["launchType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskArns": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async putAccountSetting(
    {abortSignal, ...params}: RequestConfig & PutAccountSettingRequest,
  ): Promise<PutAccountSettingResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
      principalArn: params["principalArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAccountSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async putAccountSettingDefault(
    {abortSignal, ...params}: RequestConfig & PutAccountSettingDefaultRequest,
  ): Promise<PutAccountSettingDefaultResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      value: params["value"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAccountSettingDefault",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "setting": toSetting,
      },
    }, await resp.json());
  }

  async putAttributes(
    {abortSignal, ...params}: RequestConfig & PutAttributesRequest,
  ): Promise<PutAttributesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "attributes": [toAttribute],
      },
    }, await resp.json());
  }

  async putClusterCapacityProviders(
    {abortSignal, ...params}: RequestConfig & PutClusterCapacityProvidersRequest,
  ): Promise<PutClusterCapacityProvidersResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      capacityProviders: params["capacityProviders"],
      defaultCapacityProviderStrategy: params["defaultCapacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutClusterCapacityProviders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async registerContainerInstance(
    {abortSignal, ...params}: RequestConfig & RegisterContainerInstanceRequest = {},
  ): Promise<RegisterContainerInstanceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      instanceIdentityDocument: params["instanceIdentityDocument"],
      instanceIdentityDocumentSignature: params["instanceIdentityDocumentSignature"],
      totalResources: params["totalResources"]?.map(x => fromResource(x)),
      versionInfo: fromVersionInfo(params["versionInfo"]),
      containerInstanceArn: params["containerInstanceArn"],
      attributes: params["attributes"]?.map(x => fromAttribute(x)),
      platformDevices: params["platformDevices"]?.map(x => fromPlatformDevice(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterContainerInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async registerTaskDefinition(
    {abortSignal, ...params}: RequestConfig & RegisterTaskDefinitionRequest,
  ): Promise<RegisterTaskDefinitionResponse> {
    const body: jsonP.JSONObject = {
      family: params["family"],
      taskRoleArn: params["taskRoleArn"],
      executionRoleArn: params["executionRoleArn"],
      networkMode: params["networkMode"],
      containerDefinitions: params["containerDefinitions"]?.map(x => fromContainerDefinition(x)),
      volumes: params["volumes"]?.map(x => fromVolume(x)),
      placementConstraints: params["placementConstraints"]?.map(x => fromTaskDefinitionPlacementConstraint(x)),
      requiresCompatibilities: params["requiresCompatibilities"],
      cpu: params["cpu"],
      memory: params["memory"],
      tags: params["tags"]?.map(x => fromTag(x)),
      pidMode: params["pidMode"],
      ipcMode: params["ipcMode"],
      proxyConfiguration: fromProxyConfiguration(params["proxyConfiguration"]),
      inferenceAccelerators: params["inferenceAccelerators"]?.map(x => fromInferenceAccelerator(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTaskDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskDefinition": toTaskDefinition,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async runTask(
    {abortSignal, ...params}: RequestConfig & RunTaskRequest,
  ): Promise<RunTaskResponse> {
    const body: jsonP.JSONObject = {
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      cluster: params["cluster"],
      count: params["count"],
      enableECSManagedTags: params["enableECSManagedTags"],
      group: params["group"],
      launchType: params["launchType"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      overrides: fromTaskOverride(params["overrides"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      platformVersion: params["platformVersion"],
      propagateTags: params["propagateTags"],
      referenceId: params["referenceId"],
      startedBy: params["startedBy"],
      tags: params["tags"]?.map(x => fromTag(x)),
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async startTask(
    {abortSignal, ...params}: RequestConfig & StartTaskRequest,
  ): Promise<StartTaskResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      enableECSManagedTags: params["enableECSManagedTags"],
      group: params["group"],
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      overrides: fromTaskOverride(params["overrides"]),
      propagateTags: params["propagateTags"],
      referenceId: params["referenceId"],
      startedBy: params["startedBy"],
      tags: params["tags"]?.map(x => fromTag(x)),
      taskDefinition: params["taskDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tasks": [toTask],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async stopTask(
    {abortSignal, ...params}: RequestConfig & StopTaskRequest,
  ): Promise<StopTaskResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "task": toTask,
      },
    }, await resp.json());
  }

  async submitAttachmentStateChanges(
    {abortSignal, ...params}: RequestConfig & SubmitAttachmentStateChangesRequest,
  ): Promise<SubmitAttachmentStateChangesResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      attachments: params["attachments"]?.map(x => fromAttachmentStateChange(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitAttachmentStateChanges",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async submitContainerStateChange(
    {abortSignal, ...params}: RequestConfig & SubmitContainerStateChangeRequest = {},
  ): Promise<SubmitContainerStateChangeResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      containerName: params["containerName"],
      runtimeId: params["runtimeId"],
      status: params["status"],
      exitCode: params["exitCode"],
      reason: params["reason"],
      networkBindings: params["networkBindings"]?.map(x => fromNetworkBinding(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitContainerStateChange",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async submitTaskStateChange(
    {abortSignal, ...params}: RequestConfig & SubmitTaskStateChangeRequest = {},
  ): Promise<SubmitTaskStateChangeResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      task: params["task"],
      status: params["status"],
      reason: params["reason"],
      containers: params["containers"]?.map(x => fromContainerStateChange(x)),
      attachments: params["attachments"]?.map(x => fromAttachmentStateChange(x)),
      pullStartedAt: jsonP.serializeDate_unixTimestamp(params["pullStartedAt"]),
      pullStoppedAt: jsonP.serializeDate_unixTimestamp(params["pullStoppedAt"]),
      executionStoppedAt: jsonP.serializeDate_unixTimestamp(params["executionStoppedAt"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitTaskStateChange",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acknowledgment": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateCapacityProvider(
    {abortSignal, ...params}: RequestConfig & UpdateCapacityProviderRequest,
  ): Promise<UpdateCapacityProviderResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      autoScalingGroupProvider: fromAutoScalingGroupProviderUpdate(params["autoScalingGroupProvider"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCapacityProvider",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "capacityProvider": toCapacityProvider,
      },
    }, await resp.json());
  }

  async updateClusterSettings(
    {abortSignal, ...params}: RequestConfig & UpdateClusterSettingsRequest,
  ): Promise<UpdateClusterSettingsResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      settings: params["settings"]?.map(x => fromClusterSetting(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClusterSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cluster": toCluster,
      },
    }, await resp.json());
  }

  async updateContainerAgent(
    {abortSignal, ...params}: RequestConfig & UpdateContainerAgentRequest,
  ): Promise<UpdateContainerAgentResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstance: params["containerInstance"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContainerAgent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstance": toContainerInstance,
      },
    }, await resp.json());
  }

  async updateContainerInstancesState(
    {abortSignal, ...params}: RequestConfig & UpdateContainerInstancesStateRequest,
  ): Promise<UpdateContainerInstancesStateResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      containerInstances: params["containerInstances"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContainerInstancesState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerInstances": [toContainerInstance],
        "failures": [toFailure],
      },
    }, await resp.json());
  }

  async updateService(
    {abortSignal, ...params}: RequestConfig & UpdateServiceRequest,
  ): Promise<UpdateServiceResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      desiredCount: params["desiredCount"],
      taskDefinition: params["taskDefinition"],
      capacityProviderStrategy: params["capacityProviderStrategy"]?.map(x => fromCapacityProviderStrategyItem(x)),
      deploymentConfiguration: fromDeploymentConfiguration(params["deploymentConfiguration"]),
      networkConfiguration: fromNetworkConfiguration(params["networkConfiguration"]),
      placementConstraints: params["placementConstraints"]?.map(x => fromPlacementConstraint(x)),
      placementStrategy: params["placementStrategy"]?.map(x => fromPlacementStrategy(x)),
      platformVersion: params["platformVersion"],
      forceNewDeployment: params["forceNewDeployment"],
      healthCheckGracePeriodSeconds: params["healthCheckGracePeriodSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "service": toService,
      },
    }, await resp.json());
  }

  async updateServicePrimaryTaskSet(
    {abortSignal, ...params}: RequestConfig & UpdateServicePrimaryTaskSetRequest,
  ): Promise<UpdateServicePrimaryTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      primaryTaskSet: params["primaryTaskSet"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServicePrimaryTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  async updateTaskSet(
    {abortSignal, ...params}: RequestConfig & UpdateTaskSetRequest,
  ): Promise<UpdateTaskSetResponse> {
    const body: jsonP.JSONObject = {
      cluster: params["cluster"],
      service: params["service"],
      taskSet: params["taskSet"],
      scale: fromScale(params["scale"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTaskSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskSet": toTaskSet,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 100 times, 6 seconds apart (about 10 minutes max wait time). */
  async waitForTasksRunning(
    params: RequestConfig & DescribeTasksRequest,
  ): Promise<DescribeTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TasksRunning';
    for (let i = 0; i < 100; i++) {
      const resp = await this.describeTasks(params);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.some(x => x === "STOPPED")) throw new Error(errMessage);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.every(x => x === "RUNNING")) return resp;
      await new Promise(r => setTimeout(r, 6000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 100 times, 6 seconds apart (about 10 minutes max wait time). */
  async waitForTasksStopped(
    params: RequestConfig & DescribeTasksRequest,
  ): Promise<DescribeTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TasksStopped';
    for (let i = 0; i < 100; i++) {
      const resp = await this.describeTasks(params);
      if (resp?.tasks?.flatMap(x => x?.lastStatus)?.every(x => x === "STOPPED")) return resp;
      await new Promise(r => setTimeout(r, 6000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForServicesStable(
    params: RequestConfig & DescribeServicesRequest,
  ): Promise<DescribeServicesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ServicesStable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeServices(params);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "DRAINING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "INACTIVE")) throw new Error(errMessage);
      if ((resp?.services?.filter(x => !((x?.deployments || '').length == 1 && x?.runningCount == x?.desiredCount)) || '').length == 0) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForServicesInactive(
    params: RequestConfig & DescribeServicesRequest,
  ): Promise<DescribeServicesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ServicesInactive';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeServices(params);
      if (resp?.failures?.flatMap(x => x?.reason)?.some(x => x === "MISSING")) throw new Error(errMessage);
      if (resp?.services?.flatMap(x => x?.status)?.some(x => x === "INACTIVE")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CreateCapacityProviderRequest {
  name: string;
  autoScalingGroupProvider: AutoScalingGroupProvider;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateClusterRequest {
  clusterName?: string | null;
  tags?: Tag[] | null;
  settings?: ClusterSetting[] | null;
  capacityProviders?: string[] | null;
  defaultCapacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
}

// refs: 1 - tags: named, input
export interface CreateServiceRequest {
  cluster?: string | null;
  serviceName: string;
  taskDefinition?: string | null;
  loadBalancers?: LoadBalancer[] | null;
  serviceRegistries?: ServiceRegistry[] | null;
  desiredCount?: number | null;
  clientToken?: string | null;
  launchType?: LaunchType | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  platformVersion?: string | null;
  role?: string | null;
  deploymentConfiguration?: DeploymentConfiguration | null;
  placementConstraints?: PlacementConstraint[] | null;
  placementStrategy?: PlacementStrategy[] | null;
  networkConfiguration?: NetworkConfiguration | null;
  healthCheckGracePeriodSeconds?: number | null;
  schedulingStrategy?: SchedulingStrategy | null;
  deploymentController?: DeploymentController | null;
  tags?: Tag[] | null;
  enableECSManagedTags?: boolean | null;
  propagateTags?: PropagateTags | null;
}

// refs: 1 - tags: named, input
export interface CreateTaskSetRequest {
  service: string;
  cluster: string;
  externalId?: string | null;
  taskDefinition: string;
  networkConfiguration?: NetworkConfiguration | null;
  loadBalancers?: LoadBalancer[] | null;
  serviceRegistries?: ServiceRegistry[] | null;
  launchType?: LaunchType | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  platformVersion?: string | null;
  scale?: Scale | null;
  clientToken?: string | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAccountSettingRequest {
  name: SettingName;
  principalArn?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteAttributesRequest {
  cluster?: string | null;
  attributes: Attribute[];
}

// refs: 1 - tags: named, input
export interface DeleteCapacityProviderRequest {
  capacityProvider: string;
}

// refs: 1 - tags: named, input
export interface DeleteClusterRequest {
  cluster: string;
}

// refs: 1 - tags: named, input
export interface DeleteServiceRequest {
  cluster?: string | null;
  service: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTaskSetRequest {
  cluster: string;
  service: string;
  taskSet: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterContainerInstanceRequest {
  cluster?: string | null;
  containerInstance: string;
  force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterTaskDefinitionRequest {
  taskDefinition: string;
}

// refs: 1 - tags: named, input
export interface DescribeCapacityProvidersRequest {
  capacityProviders?: string[] | null;
  include?: CapacityProviderField[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClustersRequest {
  clusters?: string[] | null;
  include?: ClusterField[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeContainerInstancesRequest {
  cluster?: string | null;
  containerInstances: string[];
  include?: ContainerInstanceField[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeServicesRequest {
  cluster?: string | null;
  services: string[];
  include?: ServiceField[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeTaskDefinitionRequest {
  taskDefinition: string;
  include?: TaskDefinitionField[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeTaskSetsRequest {
  cluster: string;
  service: string;
  taskSets?: string[] | null;
  include?: TaskSetField[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeTasksRequest {
  cluster?: string | null;
  tasks: string[];
  include?: TaskField[] | null;
}

// refs: 1 - tags: named, input
export interface DiscoverPollEndpointRequest {
  containerInstance?: string | null;
  cluster?: string | null;
}

// refs: 1 - tags: named, input
export interface ListAccountSettingsRequest {
  name?: SettingName | null;
  value?: string | null;
  principalArn?: string | null;
  effectiveSettings?: boolean | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListAttributesRequest {
  cluster?: string | null;
  targetType: TargetType;
  attributeName?: string | null;
  attributeValue?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListClustersRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListContainerInstancesRequest {
  cluster?: string | null;
  filter?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
  status?: ContainerInstanceStatus | null;
}

// refs: 1 - tags: named, input
export interface ListServicesRequest {
  cluster?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
  launchType?: LaunchType | null;
  schedulingStrategy?: SchedulingStrategy | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListTaskDefinitionFamiliesRequest {
  familyPrefix?: string | null;
  status?: TaskDefinitionFamilyStatus | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTaskDefinitionsRequest {
  familyPrefix?: string | null;
  status?: TaskDefinitionStatus | null;
  sort?: SortOrder | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTasksRequest {
  cluster?: string | null;
  containerInstance?: string | null;
  family?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
  startedBy?: string | null;
  serviceName?: string | null;
  desiredStatus?: DesiredStatus | null;
  launchType?: LaunchType | null;
}

// refs: 1 - tags: named, input
export interface PutAccountSettingRequest {
  name: SettingName;
  value: string;
  principalArn?: string | null;
}

// refs: 1 - tags: named, input
export interface PutAccountSettingDefaultRequest {
  name: SettingName;
  value: string;
}

// refs: 1 - tags: named, input
export interface PutAttributesRequest {
  cluster?: string | null;
  attributes: Attribute[];
}

// refs: 1 - tags: named, input
export interface PutClusterCapacityProvidersRequest {
  cluster: string;
  capacityProviders: string[];
  defaultCapacityProviderStrategy: CapacityProviderStrategyItem[];
}

// refs: 1 - tags: named, input
export interface RegisterContainerInstanceRequest {
  cluster?: string | null;
  instanceIdentityDocument?: string | null;
  instanceIdentityDocumentSignature?: string | null;
  totalResources?: Resource[] | null;
  versionInfo?: VersionInfo | null;
  containerInstanceArn?: string | null;
  attributes?: Attribute[] | null;
  platformDevices?: PlatformDevice[] | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface RegisterTaskDefinitionRequest {
  family: string;
  taskRoleArn?: string | null;
  executionRoleArn?: string | null;
  networkMode?: NetworkMode | null;
  containerDefinitions: ContainerDefinition[];
  volumes?: Volume[] | null;
  placementConstraints?: TaskDefinitionPlacementConstraint[] | null;
  requiresCompatibilities?: Compatibility[] | null;
  cpu?: string | null;
  memory?: string | null;
  tags?: Tag[] | null;
  pidMode?: PidMode | null;
  ipcMode?: IpcMode | null;
  proxyConfiguration?: ProxyConfiguration | null;
  inferenceAccelerators?: InferenceAccelerator[] | null;
}

// refs: 1 - tags: named, input
export interface RunTaskRequest {
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  cluster?: string | null;
  count?: number | null;
  enableECSManagedTags?: boolean | null;
  group?: string | null;
  launchType?: LaunchType | null;
  networkConfiguration?: NetworkConfiguration | null;
  overrides?: TaskOverride | null;
  placementConstraints?: PlacementConstraint[] | null;
  placementStrategy?: PlacementStrategy[] | null;
  platformVersion?: string | null;
  propagateTags?: PropagateTags | null;
  referenceId?: string | null;
  startedBy?: string | null;
  tags?: Tag[] | null;
  taskDefinition: string;
}

// refs: 1 - tags: named, input
export interface StartTaskRequest {
  cluster?: string | null;
  containerInstances: string[];
  enableECSManagedTags?: boolean | null;
  group?: string | null;
  networkConfiguration?: NetworkConfiguration | null;
  overrides?: TaskOverride | null;
  propagateTags?: PropagateTags | null;
  referenceId?: string | null;
  startedBy?: string | null;
  tags?: Tag[] | null;
  taskDefinition: string;
}

// refs: 1 - tags: named, input
export interface StopTaskRequest {
  cluster?: string | null;
  task: string;
  reason?: string | null;
}

// refs: 1 - tags: named, input
export interface SubmitAttachmentStateChangesRequest {
  cluster?: string | null;
  attachments: AttachmentStateChange[];
}

// refs: 1 - tags: named, input
export interface SubmitContainerStateChangeRequest {
  cluster?: string | null;
  task?: string | null;
  containerName?: string | null;
  runtimeId?: string | null;
  status?: string | null;
  exitCode?: number | null;
  reason?: string | null;
  networkBindings?: NetworkBinding[] | null;
}

// refs: 1 - tags: named, input
export interface SubmitTaskStateChangeRequest {
  cluster?: string | null;
  task?: string | null;
  status?: string | null;
  reason?: string | null;
  containers?: ContainerStateChange[] | null;
  attachments?: AttachmentStateChange[] | null;
  pullStartedAt?: Date | number | null;
  pullStoppedAt?: Date | number | null;
  executionStoppedAt?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateCapacityProviderRequest {
  name: string;
  autoScalingGroupProvider: AutoScalingGroupProviderUpdate;
}

// refs: 1 - tags: named, input
export interface UpdateClusterSettingsRequest {
  cluster: string;
  settings: ClusterSetting[];
}

// refs: 1 - tags: named, input
export interface UpdateContainerAgentRequest {
  cluster?: string | null;
  containerInstance: string;
}

// refs: 1 - tags: named, input
export interface UpdateContainerInstancesStateRequest {
  cluster?: string | null;
  containerInstances: string[];
  status: ContainerInstanceStatus;
}

// refs: 1 - tags: named, input
export interface UpdateServiceRequest {
  cluster?: string | null;
  service: string;
  desiredCount?: number | null;
  taskDefinition?: string | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  deploymentConfiguration?: DeploymentConfiguration | null;
  networkConfiguration?: NetworkConfiguration | null;
  placementConstraints?: PlacementConstraint[] | null;
  placementStrategy?: PlacementStrategy[] | null;
  platformVersion?: string | null;
  forceNewDeployment?: boolean | null;
  healthCheckGracePeriodSeconds?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateServicePrimaryTaskSetRequest {
  cluster: string;
  service: string;
  primaryTaskSet: string;
}

// refs: 1 - tags: named, input
export interface UpdateTaskSetRequest {
  cluster: string;
  service: string;
  taskSet: string;
  scale: Scale;
}

// refs: 1 - tags: named, output
export interface CreateCapacityProviderResponse {
  capacityProvider?: CapacityProvider | null;
}

// refs: 1 - tags: named, output
export interface CreateClusterResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface CreateServiceResponse {
  service?: Service | null;
}

// refs: 1 - tags: named, output
export interface CreateTaskSetResponse {
  taskSet?: TaskSet | null;
}

// refs: 1 - tags: named, output
export interface DeleteAccountSettingResponse {
  setting?: Setting | null;
}

// refs: 1 - tags: named, output
export interface DeleteAttributesResponse {
  attributes?: Attribute[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteCapacityProviderResponse {
  capacityProvider?: CapacityProvider | null;
}

// refs: 1 - tags: named, output
export interface DeleteClusterResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteServiceResponse {
  service?: Service | null;
}

// refs: 1 - tags: named, output
export interface DeleteTaskSetResponse {
  taskSet?: TaskSet | null;
}

// refs: 1 - tags: named, output
export interface DeregisterContainerInstanceResponse {
  containerInstance?: ContainerInstance | null;
}

// refs: 1 - tags: named, output
export interface DeregisterTaskDefinitionResponse {
  taskDefinition?: TaskDefinition | null;
}

// refs: 1 - tags: named, output
export interface DescribeCapacityProvidersResponse {
  capacityProviders?: CapacityProvider[] | null;
  failures?: Failure[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClustersResponse {
  clusters?: Cluster[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeContainerInstancesResponse {
  containerInstances?: ContainerInstance[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeServicesResponse {
  services?: Service[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTaskDefinitionResponse {
  taskDefinition?: TaskDefinition | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTaskSetsResponse {
  taskSets?: TaskSet[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTasksResponse {
  tasks?: Task[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface DiscoverPollEndpointResponse {
  endpoint?: string | null;
  telemetryEndpoint?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAccountSettingsResponse {
  settings?: Setting[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAttributesResponse {
  attributes?: Attribute[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListClustersResponse {
  clusterArns?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListContainerInstancesResponse {
  containerInstanceArns?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListServicesResponse {
  serviceArns?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface ListTaskDefinitionFamiliesResponse {
  families?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTaskDefinitionsResponse {
  taskDefinitionArns?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTasksResponse {
  taskArns?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutAccountSettingResponse {
  setting?: Setting | null;
}

// refs: 1 - tags: named, output
export interface PutAccountSettingDefaultResponse {
  setting?: Setting | null;
}

// refs: 1 - tags: named, output
export interface PutAttributesResponse {
  attributes?: Attribute[] | null;
}

// refs: 1 - tags: named, output
export interface PutClusterCapacityProvidersResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface RegisterContainerInstanceResponse {
  containerInstance?: ContainerInstance | null;
}

// refs: 1 - tags: named, output
export interface RegisterTaskDefinitionResponse {
  taskDefinition?: TaskDefinition | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface RunTaskResponse {
  tasks?: Task[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface StartTaskResponse {
  tasks?: Task[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface StopTaskResponse {
  task?: Task | null;
}

// refs: 1 - tags: named, output
export interface SubmitAttachmentStateChangesResponse {
  acknowledgment?: string | null;
}

// refs: 1 - tags: named, output
export interface SubmitContainerStateChangeResponse {
  acknowledgment?: string | null;
}

// refs: 1 - tags: named, output
export interface SubmitTaskStateChangeResponse {
  acknowledgment?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateCapacityProviderResponse {
  capacityProvider?: CapacityProvider | null;
}

// refs: 1 - tags: named, output
export interface UpdateClusterSettingsResponse {
  cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface UpdateContainerAgentResponse {
  containerInstance?: ContainerInstance | null;
}

// refs: 1 - tags: named, output
export interface UpdateContainerInstancesStateResponse {
  containerInstances?: ContainerInstance[] | null;
  failures?: Failure[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateServiceResponse {
  service?: Service | null;
}

// refs: 1 - tags: named, output
export interface UpdateServicePrimaryTaskSetResponse {
  taskSet?: TaskSet | null;
}

// refs: 1 - tags: named, output
export interface UpdateTaskSetResponse {
  taskSet?: TaskSet | null;
}

// refs: 5 - tags: input, named, interface, output
export interface AutoScalingGroupProvider {
  autoScalingGroupArn: string;
  managedScaling?: ManagedScaling | null;
  managedTerminationProtection?: ManagedTerminationProtection | null;
}
function fromAutoScalingGroupProvider(input?: AutoScalingGroupProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    autoScalingGroupArn: input["autoScalingGroupArn"],
    managedScaling: fromManagedScaling(input["managedScaling"]),
    managedTerminationProtection: input["managedTerminationProtection"],
  }
}
function toAutoScalingGroupProvider(root: jsonP.JSONValue): AutoScalingGroupProvider {
  return jsonP.readObj({
    required: {
      "autoScalingGroupArn": "s",
    },
    optional: {
      "managedScaling": toManagedScaling,
      "managedTerminationProtection": (x: jsonP.JSONValue) => cmnP.readEnum<ManagedTerminationProtection>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ManagedScaling {
  status?: ManagedScalingStatus | null;
  targetCapacity?: number | null;
  minimumScalingStepSize?: number | null;
  maximumScalingStepSize?: number | null;
  instanceWarmupPeriod?: number | null;
}
function fromManagedScaling(input?: ManagedScaling | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    targetCapacity: input["targetCapacity"],
    minimumScalingStepSize: input["minimumScalingStepSize"],
    maximumScalingStepSize: input["maximumScalingStepSize"],
    instanceWarmupPeriod: input["instanceWarmupPeriod"],
  }
}
function toManagedScaling(root: jsonP.JSONValue): ManagedScaling {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ManagedScalingStatus>(x),
      "targetCapacity": "n",
      "minimumScalingStepSize": "n",
      "maximumScalingStepSize": "n",
      "instanceWarmupPeriod": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ManagedScalingStatus =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ManagedTerminationProtection =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 43 - tags: input, named, interface, output
export interface Tag {
  key?: string | null;
  value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface ClusterSetting {
  name?: ClusterSettingName | null;
  value?: string | null;
}
function fromClusterSetting(input?: ClusterSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toClusterSetting(root: jsonP.JSONValue): ClusterSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterSettingName>(x),
      "value": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type ClusterSettingName =
| "containerInsights"
| cmnP.UnexpectedEnumValue;

// refs: 28 - tags: input, named, interface, output
export interface CapacityProviderStrategyItem {
  capacityProvider: string;
  weight?: number | null;
  base?: number | null;
}
function fromCapacityProviderStrategyItem(input?: CapacityProviderStrategyItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    capacityProvider: input["capacityProvider"],
    weight: input["weight"],
    base: input["base"],
  }
}
function toCapacityProviderStrategyItem(root: jsonP.JSONValue): CapacityProviderStrategyItem {
  return jsonP.readObj({
    required: {
      "capacityProvider": "s",
    },
    optional: {
      "weight": "n",
      "base": "n",
    },
  }, root);
}

// refs: 15 - tags: input, named, interface, output
export interface LoadBalancer {
  targetGroupArn?: string | null;
  loadBalancerName?: string | null;
  containerName?: string | null;
  containerPort?: number | null;
}
function fromLoadBalancer(input?: LoadBalancer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetGroupArn: input["targetGroupArn"],
    loadBalancerName: input["loadBalancerName"],
    containerName: input["containerName"],
    containerPort: input["containerPort"],
  }
}
function toLoadBalancer(root: jsonP.JSONValue): LoadBalancer {
  return jsonP.readObj({
    required: {},
    optional: {
      "targetGroupArn": "s",
      "loadBalancerName": "s",
      "containerName": "s",
      "containerPort": "n",
    },
  }, root);
}

// refs: 15 - tags: input, named, interface, output
export interface ServiceRegistry {
  registryArn?: string | null;
  port?: number | null;
  containerName?: string | null;
  containerPort?: number | null;
}
function fromServiceRegistry(input?: ServiceRegistry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    registryArn: input["registryArn"],
    port: input["port"],
    containerName: input["containerName"],
    containerPort: input["containerPort"],
  }
}
function toServiceRegistry(root: jsonP.JSONValue): ServiceRegistry {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryArn": "s",
      "port": "n",
      "containerName": "s",
      "containerPort": "n",
    },
  }, root);
}

// refs: 26 - tags: input, named, enum, output
export type LaunchType =
| "EC2"
| "FARGATE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface DeploymentConfiguration {
  deploymentCircuitBreaker?: DeploymentCircuitBreaker | null;
  maximumPercent?: number | null;
  minimumHealthyPercent?: number | null;
}
function fromDeploymentConfiguration(input?: DeploymentConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deploymentCircuitBreaker: fromDeploymentCircuitBreaker(input["deploymentCircuitBreaker"]),
    maximumPercent: input["maximumPercent"],
    minimumHealthyPercent: input["minimumHealthyPercent"],
  }
}
function toDeploymentConfiguration(root: jsonP.JSONValue): DeploymentConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "deploymentCircuitBreaker": toDeploymentCircuitBreaker,
      "maximumPercent": "n",
      "minimumHealthyPercent": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DeploymentCircuitBreaker {
  enable: boolean;
  rollback: boolean;
}
function fromDeploymentCircuitBreaker(input?: DeploymentCircuitBreaker | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enable: input["enable"],
    rollback: input["rollback"],
  }
}
function toDeploymentCircuitBreaker(root: jsonP.JSONValue): DeploymentCircuitBreaker {
  return jsonP.readObj({
    required: {
      "enable": "b",
      "rollback": "b",
    },
    optional: {},
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface PlacementConstraint {
  type?: PlacementConstraintType | null;
  expression?: string | null;
}
function fromPlacementConstraint(input?: PlacementConstraint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    expression: input["expression"],
  }
}
function toPlacementConstraint(root: jsonP.JSONValue): PlacementConstraint {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<PlacementConstraintType>(x),
      "expression": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type PlacementConstraintType =
| "distinctInstance"
| "memberOf"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface PlacementStrategy {
  type?: PlacementStrategyType | null;
  field?: string | null;
}
function fromPlacementStrategy(input?: PlacementStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    field: input["field"],
  }
}
function toPlacementStrategy(root: jsonP.JSONValue): PlacementStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<PlacementStrategyType>(x),
      "field": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type PlacementStrategyType =
| "random"
| "spread"
| "binpack"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, interface, output
export interface NetworkConfiguration {
  awsvpcConfiguration?: AwsVpcConfiguration | null;
}
function fromNetworkConfiguration(input?: NetworkConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsvpcConfiguration: fromAwsVpcConfiguration(input["awsvpcConfiguration"]),
  }
}
function toNetworkConfiguration(root: jsonP.JSONValue): NetworkConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsvpcConfiguration": toAwsVpcConfiguration,
    },
  }, root);
}

// refs: 22 - tags: input, named, interface, output
export interface AwsVpcConfiguration {
  subnets: string[];
  securityGroups?: string[] | null;
  assignPublicIp?: AssignPublicIp | null;
}
function fromAwsVpcConfiguration(input?: AwsVpcConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subnets: input["subnets"],
    securityGroups: input["securityGroups"],
    assignPublicIp: input["assignPublicIp"],
  }
}
function toAwsVpcConfiguration(root: jsonP.JSONValue): AwsVpcConfiguration {
  return jsonP.readObj({
    required: {
      "subnets": ["s"],
    },
    optional: {
      "securityGroups": ["s"],
      "assignPublicIp": (x: jsonP.JSONValue) => cmnP.readEnum<AssignPublicIp>(x),
    },
  }, root);
}

// refs: 22 - tags: input, named, enum, output
export type AssignPublicIp =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type SchedulingStrategy =
| "REPLICA"
| "DAEMON"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface DeploymentController {
  type: DeploymentControllerType;
}
function fromDeploymentController(input?: DeploymentController | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
  }
}
function toDeploymentController(root: jsonP.JSONValue): DeploymentController {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentControllerType>(x),
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type DeploymentControllerType =
| "ECS"
| "CODE_DEPLOY"
| "EXTERNAL"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type PropagateTags =
| "TASK_DEFINITION"
| "SERVICE"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface Scale {
  value?: number | null;
  unit?: ScaleUnit | null;
}
function fromScale(input?: Scale | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    unit: input["unit"],
  }
}
function toScale(root: jsonP.JSONValue): Scale {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": "n",
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<ScaleUnit>(x),
    },
  }, root);
}

// refs: 11 - tags: input, named, enum, output
export type ScaleUnit =
| "PERCENT"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, enum, output
export type SettingName =
| "serviceLongArnFormat"
| "taskLongArnFormat"
| "containerInstanceLongArnFormat"
| "awsvpcTrunking"
| "containerInsights"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, interface, output
export interface Attribute {
  name: string;
  value?: string | null;
  targetType?: TargetType | null;
  targetId?: string | null;
}
function fromAttribute(input?: Attribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
    targetType: input["targetType"],
    targetId: input["targetId"],
  }
}
function toAttribute(root: jsonP.JSONValue): Attribute {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "value": "s",
      "targetType": (x: jsonP.JSONValue) => cmnP.readEnum<TargetType>(x),
      "targetId": "s",
    },
  }, root);
}

// refs: 19 - tags: input, named, enum, output
export type TargetType =
| "container-instance"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type CapacityProviderField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ClusterField =
| "ATTACHMENTS"
| "SETTINGS"
| "STATISTICS"
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ContainerInstanceField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ServiceField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TaskDefinitionField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TaskSetField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TaskField =
| "TAGS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type ContainerInstanceStatus =
| "ACTIVE"
| "DRAINING"
| "REGISTERING"
| "DEREGISTERING"
| "REGISTRATION_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TaskDefinitionFamilyStatus =
| "ACTIVE"
| "INACTIVE"
| "ALL"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type TaskDefinitionStatus =
| "ACTIVE"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortOrder =
| "ASC"
| "DESC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type DesiredStatus =
| "RUNNING"
| "PENDING"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface Resource {
  name?: string | null;
  type?: string | null;
  doubleValue?: number | null;
  longValue?: number | null;
  integerValue?: number | null;
  stringSetValue?: string[] | null;
}
function fromResource(input?: Resource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
    doubleValue: input["doubleValue"],
    longValue: input["longValue"],
    integerValue: input["integerValue"],
    stringSetValue: input["stringSetValue"],
  }
}
function toResource(root: jsonP.JSONValue): Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "type": "s",
      "doubleValue": "n",
      "longValue": "n",
      "integerValue": "n",
      "stringSetValue": ["s"],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VersionInfo {
  agentVersion?: string | null;
  agentHash?: string | null;
  dockerVersion?: string | null;
}
function fromVersionInfo(input?: VersionInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    agentVersion: input["agentVersion"],
    agentHash: input["agentHash"],
    dockerVersion: input["dockerVersion"],
  }
}
function toVersionInfo(root: jsonP.JSONValue): VersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "agentVersion": "s",
      "agentHash": "s",
      "dockerVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface PlatformDevice {
  id: string;
  type: PlatformDeviceType;
}
function fromPlatformDevice(input?: PlatformDevice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    type: input["type"],
  }
}

// refs: 1 - tags: input, named, enum
export type PlatformDeviceType =
| "GPU"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type NetworkMode =
| "bridge"
| "host"
| "awsvpc"
| "none"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ContainerDefinition {
  name?: string | null;
  image?: string | null;
  repositoryCredentials?: RepositoryCredentials | null;
  cpu?: number | null;
  memory?: number | null;
  memoryReservation?: number | null;
  links?: string[] | null;
  portMappings?: PortMapping[] | null;
  essential?: boolean | null;
  entryPoint?: string[] | null;
  command?: string[] | null;
  environment?: KeyValuePair[] | null;
  environmentFiles?: EnvironmentFile[] | null;
  mountPoints?: MountPoint[] | null;
  volumesFrom?: VolumeFrom[] | null;
  linuxParameters?: LinuxParameters | null;
  secrets?: Secret[] | null;
  dependsOn?: ContainerDependency[] | null;
  startTimeout?: number | null;
  stopTimeout?: number | null;
  hostname?: string | null;
  user?: string | null;
  workingDirectory?: string | null;
  disableNetworking?: boolean | null;
  privileged?: boolean | null;
  readonlyRootFilesystem?: boolean | null;
  dnsServers?: string[] | null;
  dnsSearchDomains?: string[] | null;
  extraHosts?: HostEntry[] | null;
  dockerSecurityOptions?: string[] | null;
  interactive?: boolean | null;
  pseudoTerminal?: boolean | null;
  dockerLabels?: { [key: string]: string | null | undefined } | null;
  ulimits?: Ulimit[] | null;
  logConfiguration?: LogConfiguration | null;
  healthCheck?: HealthCheck | null;
  systemControls?: SystemControl[] | null;
  resourceRequirements?: ResourceRequirement[] | null;
  firelensConfiguration?: FirelensConfiguration | null;
}
function fromContainerDefinition(input?: ContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    image: input["image"],
    repositoryCredentials: fromRepositoryCredentials(input["repositoryCredentials"]),
    cpu: input["cpu"],
    memory: input["memory"],
    memoryReservation: input["memoryReservation"],
    links: input["links"],
    portMappings: input["portMappings"]?.map(x => fromPortMapping(x)),
    essential: input["essential"],
    entryPoint: input["entryPoint"],
    command: input["command"],
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    environmentFiles: input["environmentFiles"]?.map(x => fromEnvironmentFile(x)),
    mountPoints: input["mountPoints"]?.map(x => fromMountPoint(x)),
    volumesFrom: input["volumesFrom"]?.map(x => fromVolumeFrom(x)),
    linuxParameters: fromLinuxParameters(input["linuxParameters"]),
    secrets: input["secrets"]?.map(x => fromSecret(x)),
    dependsOn: input["dependsOn"]?.map(x => fromContainerDependency(x)),
    startTimeout: input["startTimeout"],
    stopTimeout: input["stopTimeout"],
    hostname: input["hostname"],
    user: input["user"],
    workingDirectory: input["workingDirectory"],
    disableNetworking: input["disableNetworking"],
    privileged: input["privileged"],
    readonlyRootFilesystem: input["readonlyRootFilesystem"],
    dnsServers: input["dnsServers"],
    dnsSearchDomains: input["dnsSearchDomains"],
    extraHosts: input["extraHosts"]?.map(x => fromHostEntry(x)),
    dockerSecurityOptions: input["dockerSecurityOptions"],
    interactive: input["interactive"],
    pseudoTerminal: input["pseudoTerminal"],
    dockerLabels: input["dockerLabels"],
    ulimits: input["ulimits"]?.map(x => fromUlimit(x)),
    logConfiguration: fromLogConfiguration(input["logConfiguration"]),
    healthCheck: fromHealthCheck(input["healthCheck"]),
    systemControls: input["systemControls"]?.map(x => fromSystemControl(x)),
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
    firelensConfiguration: fromFirelensConfiguration(input["firelensConfiguration"]),
  }
}
function toContainerDefinition(root: jsonP.JSONValue): ContainerDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "image": "s",
      "repositoryCredentials": toRepositoryCredentials,
      "cpu": "n",
      "memory": "n",
      "memoryReservation": "n",
      "links": ["s"],
      "portMappings": [toPortMapping],
      "essential": "b",
      "entryPoint": ["s"],
      "command": ["s"],
      "environment": [toKeyValuePair],
      "environmentFiles": [toEnvironmentFile],
      "mountPoints": [toMountPoint],
      "volumesFrom": [toVolumeFrom],
      "linuxParameters": toLinuxParameters,
      "secrets": [toSecret],
      "dependsOn": [toContainerDependency],
      "startTimeout": "n",
      "stopTimeout": "n",
      "hostname": "s",
      "user": "s",
      "workingDirectory": "s",
      "disableNetworking": "b",
      "privileged": "b",
      "readonlyRootFilesystem": "b",
      "dnsServers": ["s"],
      "dnsSearchDomains": ["s"],
      "extraHosts": [toHostEntry],
      "dockerSecurityOptions": ["s"],
      "interactive": "b",
      "pseudoTerminal": "b",
      "dockerLabels": x => jsonP.readMap(String, String, x),
      "ulimits": [toUlimit],
      "logConfiguration": toLogConfiguration,
      "healthCheck": toHealthCheck,
      "systemControls": [toSystemControl],
      "resourceRequirements": [toResourceRequirement],
      "firelensConfiguration": toFirelensConfiguration,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface RepositoryCredentials {
  credentialsParameter: string;
}
function fromRepositoryCredentials(input?: RepositoryCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credentialsParameter: input["credentialsParameter"],
  }
}
function toRepositoryCredentials(root: jsonP.JSONValue): RepositoryCredentials {
  return jsonP.readObj({
    required: {
      "credentialsParameter": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PortMapping {
  containerPort?: number | null;
  hostPort?: number | null;
  protocol?: TransportProtocol | null;
}
function fromPortMapping(input?: PortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPort: input["containerPort"],
    hostPort: input["hostPort"],
    protocol: input["protocol"],
  }
}
function toPortMapping(root: jsonP.JSONValue): PortMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerPort": "n",
      "hostPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<TransportProtocol>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type TransportProtocol =
| "tcp"
| "udp"
| cmnP.UnexpectedEnumValue;

// refs: 33 - tags: input, named, interface, output
export interface KeyValuePair {
  name?: string | null;
  value?: string | null;
}
function fromKeyValuePair(input?: KeyValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toKeyValuePair(root: jsonP.JSONValue): KeyValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "value": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EnvironmentFile {
  value: string;
  type: EnvironmentFileType;
}
function fromEnvironmentFile(input?: EnvironmentFile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toEnvironmentFile(root: jsonP.JSONValue): EnvironmentFile {
  return jsonP.readObj({
    required: {
      "value": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<EnvironmentFileType>(x),
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type EnvironmentFileType =
| "s3"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface MountPoint {
  sourceVolume?: string | null;
  containerPath?: string | null;
  readOnly?: boolean | null;
}
function fromMountPoint(input?: MountPoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceVolume: input["sourceVolume"],
    containerPath: input["containerPath"],
    readOnly: input["readOnly"],
  }
}
function toMountPoint(root: jsonP.JSONValue): MountPoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourceVolume": "s",
      "containerPath": "s",
      "readOnly": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface VolumeFrom {
  sourceContainer?: string | null;
  readOnly?: boolean | null;
}
function fromVolumeFrom(input?: VolumeFrom | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceContainer: input["sourceContainer"],
    readOnly: input["readOnly"],
  }
}
function toVolumeFrom(root: jsonP.JSONValue): VolumeFrom {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourceContainer": "s",
      "readOnly": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface LinuxParameters {
  capabilities?: KernelCapabilities | null;
  devices?: Device[] | null;
  initProcessEnabled?: boolean | null;
  sharedMemorySize?: number | null;
  tmpfs?: Tmpfs[] | null;
  maxSwap?: number | null;
  swappiness?: number | null;
}
function fromLinuxParameters(input?: LinuxParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    capabilities: fromKernelCapabilities(input["capabilities"]),
    devices: input["devices"]?.map(x => fromDevice(x)),
    initProcessEnabled: input["initProcessEnabled"],
    sharedMemorySize: input["sharedMemorySize"],
    tmpfs: input["tmpfs"]?.map(x => fromTmpfs(x)),
    maxSwap: input["maxSwap"],
    swappiness: input["swappiness"],
  }
}
function toLinuxParameters(root: jsonP.JSONValue): LinuxParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "capabilities": toKernelCapabilities,
      "devices": [toDevice],
      "initProcessEnabled": "b",
      "sharedMemorySize": "n",
      "tmpfs": [toTmpfs],
      "maxSwap": "n",
      "swappiness": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface KernelCapabilities {
  add?: string[] | null;
  drop?: string[] | null;
}
function fromKernelCapabilities(input?: KernelCapabilities | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    add: input["add"],
    drop: input["drop"],
  }
}
function toKernelCapabilities(root: jsonP.JSONValue): KernelCapabilities {
  return jsonP.readObj({
    required: {},
    optional: {
      "add": ["s"],
      "drop": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Device {
  hostPath: string;
  containerPath?: string | null;
  permissions?: DeviceCgroupPermission[] | null;
}
function fromDevice(input?: Device | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostPath: input["hostPath"],
    containerPath: input["containerPath"],
    permissions: input["permissions"],
  }
}
function toDevice(root: jsonP.JSONValue): Device {
  return jsonP.readObj({
    required: {
      "hostPath": "s",
    },
    optional: {
      "containerPath": "s",
      "permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<DeviceCgroupPermission>(x)],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type DeviceCgroupPermission =
| "read"
| "write"
| "mknod"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Tmpfs {
  containerPath: string;
  size: number;
  mountOptions?: string[] | null;
}
function fromTmpfs(input?: Tmpfs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPath: input["containerPath"],
    size: input["size"],
    mountOptions: input["mountOptions"],
  }
}
function toTmpfs(root: jsonP.JSONValue): Tmpfs {
  return jsonP.readObj({
    required: {
      "containerPath": "s",
      "size": "n",
    },
    optional: {
      "mountOptions": ["s"],
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface Secret {
  name: string;
  valueFrom: string;
}
function fromSecret(input?: Secret | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    valueFrom: input["valueFrom"],
  }
}
function toSecret(root: jsonP.JSONValue): Secret {
  return jsonP.readObj({
    required: {
      "name": "s",
      "valueFrom": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ContainerDependency {
  containerName: string;
  condition: ContainerCondition;
}
function fromContainerDependency(input?: ContainerDependency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerName: input["containerName"],
    condition: input["condition"],
  }
}
function toContainerDependency(root: jsonP.JSONValue): ContainerDependency {
  return jsonP.readObj({
    required: {
      "containerName": "s",
      "condition": (x: jsonP.JSONValue) => cmnP.readEnum<ContainerCondition>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ContainerCondition =
| "START"
| "COMPLETE"
| "SUCCESS"
| "HEALTHY"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface HostEntry {
  hostname: string;
  ipAddress: string;
}
function fromHostEntry(input?: HostEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostname: input["hostname"],
    ipAddress: input["ipAddress"],
  }
}
function toHostEntry(root: jsonP.JSONValue): HostEntry {
  return jsonP.readObj({
    required: {
      "hostname": "s",
      "ipAddress": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Ulimit {
  name: UlimitName;
  softLimit: number;
  hardLimit: number;
}
function fromUlimit(input?: Ulimit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    softLimit: input["softLimit"],
    hardLimit: input["hardLimit"],
  }
}
function toUlimit(root: jsonP.JSONValue): Ulimit {
  return jsonP.readObj({
    required: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<UlimitName>(x),
      "softLimit": "n",
      "hardLimit": "n",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type UlimitName =
| "core"
| "cpu"
| "data"
| "fsize"
| "locks"
| "memlock"
| "msgqueue"
| "nice"
| "nofile"
| "nproc"
| "rss"
| "rtprio"
| "rttime"
| "sigpending"
| "stack"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface LogConfiguration {
  logDriver: LogDriver;
  options?: { [key: string]: string | null | undefined } | null;
  secretOptions?: Secret[] | null;
}
function fromLogConfiguration(input?: LogConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logDriver: input["logDriver"],
    options: input["options"],
    secretOptions: input["secretOptions"]?.map(x => fromSecret(x)),
  }
}
function toLogConfiguration(root: jsonP.JSONValue): LogConfiguration {
  return jsonP.readObj({
    required: {
      "logDriver": (x: jsonP.JSONValue) => cmnP.readEnum<LogDriver>(x),
    },
    optional: {
      "options": x => jsonP.readMap(String, String, x),
      "secretOptions": [toSecret],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type LogDriver =
| "json-file"
| "syslog"
| "journald"
| "gelf"
| "fluentd"
| "awslogs"
| "splunk"
| "awsfirelens"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface HealthCheck {
  command: string[];
  interval?: number | null;
  timeout?: number | null;
  retries?: number | null;
  startPeriod?: number | null;
}
function fromHealthCheck(input?: HealthCheck | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    command: input["command"],
    interval: input["interval"],
    timeout: input["timeout"],
    retries: input["retries"],
    startPeriod: input["startPeriod"],
  }
}
function toHealthCheck(root: jsonP.JSONValue): HealthCheck {
  return jsonP.readObj({
    required: {
      "command": ["s"],
    },
    optional: {
      "interval": "n",
      "timeout": "n",
      "retries": "n",
      "startPeriod": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface SystemControl {
  namespace?: string | null;
  value?: string | null;
}
function fromSystemControl(input?: SystemControl | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    namespace: input["namespace"],
    value: input["value"],
  }
}
function toSystemControl(root: jsonP.JSONValue): SystemControl {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "value": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface ResourceRequirement {
  value: string;
  type: ResourceType;
}
function fromResourceRequirement(input?: ResourceRequirement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toResourceRequirement(root: jsonP.JSONValue): ResourceRequirement {
  return jsonP.readObj({
    required: {
      "value": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type ResourceType =
| "GPU"
| "InferenceAccelerator"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface FirelensConfiguration {
  type: FirelensConfigurationType;
  options?: { [key: string]: string | null | undefined } | null;
}
function fromFirelensConfiguration(input?: FirelensConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    options: input["options"],
  }
}
function toFirelensConfiguration(root: jsonP.JSONValue): FirelensConfiguration {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<FirelensConfigurationType>(x),
    },
    optional: {
      "options": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type FirelensConfigurationType =
| "fluentd"
| "fluentbit"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Volume {
  name?: string | null;
  host?: HostVolumeProperties | null;
  dockerVolumeConfiguration?: DockerVolumeConfiguration | null;
  efsVolumeConfiguration?: EFSVolumeConfiguration | null;
  fsxWindowsFileServerVolumeConfiguration?: FSxWindowsFileServerVolumeConfiguration | null;
}
function fromVolume(input?: Volume | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    host: fromHostVolumeProperties(input["host"]),
    dockerVolumeConfiguration: fromDockerVolumeConfiguration(input["dockerVolumeConfiguration"]),
    efsVolumeConfiguration: fromEFSVolumeConfiguration(input["efsVolumeConfiguration"]),
    fsxWindowsFileServerVolumeConfiguration: fromFSxWindowsFileServerVolumeConfiguration(input["fsxWindowsFileServerVolumeConfiguration"]),
  }
}
function toVolume(root: jsonP.JSONValue): Volume {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "host": toHostVolumeProperties,
      "dockerVolumeConfiguration": toDockerVolumeConfiguration,
      "efsVolumeConfiguration": toEFSVolumeConfiguration,
      "fsxWindowsFileServerVolumeConfiguration": toFSxWindowsFileServerVolumeConfiguration,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface HostVolumeProperties {
  sourcePath?: string | null;
}
function fromHostVolumeProperties(input?: HostVolumeProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourcePath: input["sourcePath"],
  }
}
function toHostVolumeProperties(root: jsonP.JSONValue): HostVolumeProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourcePath": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DockerVolumeConfiguration {
  scope?: Scope | null;
  autoprovision?: boolean | null;
  driver?: string | null;
  driverOpts?: { [key: string]: string | null | undefined } | null;
  labels?: { [key: string]: string | null | undefined } | null;
}
function fromDockerVolumeConfiguration(input?: DockerVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scope: input["scope"],
    autoprovision: input["autoprovision"],
    driver: input["driver"],
    driverOpts: input["driverOpts"],
    labels: input["labels"],
  }
}
function toDockerVolumeConfiguration(root: jsonP.JSONValue): DockerVolumeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "scope": (x: jsonP.JSONValue) => cmnP.readEnum<Scope>(x),
      "autoprovision": "b",
      "driver": "s",
      "driverOpts": x => jsonP.readMap(String, String, x),
      "labels": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type Scope =
| "task"
| "shared"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface EFSVolumeConfiguration {
  fileSystemId: string;
  rootDirectory?: string | null;
  transitEncryption?: EFSTransitEncryption | null;
  transitEncryptionPort?: number | null;
  authorizationConfig?: EFSAuthorizationConfig | null;
}
function fromEFSVolumeConfiguration(input?: EFSVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileSystemId: input["fileSystemId"],
    rootDirectory: input["rootDirectory"],
    transitEncryption: input["transitEncryption"],
    transitEncryptionPort: input["transitEncryptionPort"],
    authorizationConfig: fromEFSAuthorizationConfig(input["authorizationConfig"]),
  }
}
function toEFSVolumeConfiguration(root: jsonP.JSONValue): EFSVolumeConfiguration {
  return jsonP.readObj({
    required: {
      "fileSystemId": "s",
    },
    optional: {
      "rootDirectory": "s",
      "transitEncryption": (x: jsonP.JSONValue) => cmnP.readEnum<EFSTransitEncryption>(x),
      "transitEncryptionPort": "n",
      "authorizationConfig": toEFSAuthorizationConfig,
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type EFSTransitEncryption =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface EFSAuthorizationConfig {
  accessPointId?: string | null;
  iam?: EFSAuthorizationConfigIAM | null;
}
function fromEFSAuthorizationConfig(input?: EFSAuthorizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessPointId: input["accessPointId"],
    iam: input["iam"],
  }
}
function toEFSAuthorizationConfig(root: jsonP.JSONValue): EFSAuthorizationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessPointId": "s",
      "iam": (x: jsonP.JSONValue) => cmnP.readEnum<EFSAuthorizationConfigIAM>(x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type EFSAuthorizationConfigIAM =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface FSxWindowsFileServerVolumeConfiguration {
  fileSystemId: string;
  rootDirectory: string;
  authorizationConfig: FSxWindowsFileServerAuthorizationConfig;
}
function fromFSxWindowsFileServerVolumeConfiguration(input?: FSxWindowsFileServerVolumeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fileSystemId: input["fileSystemId"],
    rootDirectory: input["rootDirectory"],
    authorizationConfig: fromFSxWindowsFileServerAuthorizationConfig(input["authorizationConfig"]),
  }
}
function toFSxWindowsFileServerVolumeConfiguration(root: jsonP.JSONValue): FSxWindowsFileServerVolumeConfiguration {
  return jsonP.readObj({
    required: {
      "fileSystemId": "s",
      "rootDirectory": "s",
      "authorizationConfig": toFSxWindowsFileServerAuthorizationConfig,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FSxWindowsFileServerAuthorizationConfig {
  credentialsParameter: string;
  domain: string;
}
function fromFSxWindowsFileServerAuthorizationConfig(input?: FSxWindowsFileServerAuthorizationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credentialsParameter: input["credentialsParameter"],
    domain: input["domain"],
  }
}
function toFSxWindowsFileServerAuthorizationConfig(root: jsonP.JSONValue): FSxWindowsFileServerAuthorizationConfig {
  return jsonP.readObj({
    required: {
      "credentialsParameter": "s",
      "domain": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface TaskDefinitionPlacementConstraint {
  type?: TaskDefinitionPlacementConstraintType | null;
  expression?: string | null;
}
function fromTaskDefinitionPlacementConstraint(input?: TaskDefinitionPlacementConstraint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    expression: input["expression"],
  }
}
function toTaskDefinitionPlacementConstraint(root: jsonP.JSONValue): TaskDefinitionPlacementConstraint {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<TaskDefinitionPlacementConstraintType>(x),
      "expression": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type TaskDefinitionPlacementConstraintType =
| "memberOf"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type Compatibility =
| "EC2"
| "FARGATE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type PidMode =
| "host"
| "task"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type IpcMode =
| "host"
| "task"
| "none"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ProxyConfiguration {
  type?: ProxyConfigurationType | null;
  containerName: string;
  properties?: KeyValuePair[] | null;
}
function fromProxyConfiguration(input?: ProxyConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    containerName: input["containerName"],
    properties: input["properties"]?.map(x => fromKeyValuePair(x)),
  }
}
function toProxyConfiguration(root: jsonP.JSONValue): ProxyConfiguration {
  return jsonP.readObj({
    required: {
      "containerName": "s",
    },
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ProxyConfigurationType>(x),
      "properties": [toKeyValuePair],
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ProxyConfigurationType =
| "APPMESH"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface InferenceAccelerator {
  deviceName: string;
  deviceType: string;
}
function fromInferenceAccelerator(input?: InferenceAccelerator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceName: input["deviceName"],
    deviceType: input["deviceType"],
  }
}
function toInferenceAccelerator(root: jsonP.JSONValue): InferenceAccelerator {
  return jsonP.readObj({
    required: {
      "deviceName": "s",
      "deviceType": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface TaskOverride {
  containerOverrides?: ContainerOverride[] | null;
  cpu?: string | null;
  inferenceAcceleratorOverrides?: InferenceAcceleratorOverride[] | null;
  executionRoleArn?: string | null;
  memory?: string | null;
  taskRoleArn?: string | null;
}
function fromTaskOverride(input?: TaskOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerOverrides: input["containerOverrides"]?.map(x => fromContainerOverride(x)),
    cpu: input["cpu"],
    inferenceAcceleratorOverrides: input["inferenceAcceleratorOverrides"]?.map(x => fromInferenceAcceleratorOverride(x)),
    executionRoleArn: input["executionRoleArn"],
    memory: input["memory"],
    taskRoleArn: input["taskRoleArn"],
  }
}
function toTaskOverride(root: jsonP.JSONValue): TaskOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerOverrides": [toContainerOverride],
      "cpu": "s",
      "inferenceAcceleratorOverrides": [toInferenceAcceleratorOverride],
      "executionRoleArn": "s",
      "memory": "s",
      "taskRoleArn": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ContainerOverride {
  name?: string | null;
  command?: string[] | null;
  environment?: KeyValuePair[] | null;
  environmentFiles?: EnvironmentFile[] | null;
  cpu?: number | null;
  memory?: number | null;
  memoryReservation?: number | null;
  resourceRequirements?: ResourceRequirement[] | null;
}
function fromContainerOverride(input?: ContainerOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    command: input["command"],
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    environmentFiles: input["environmentFiles"]?.map(x => fromEnvironmentFile(x)),
    cpu: input["cpu"],
    memory: input["memory"],
    memoryReservation: input["memoryReservation"],
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
  }
}
function toContainerOverride(root: jsonP.JSONValue): ContainerOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "command": ["s"],
      "environment": [toKeyValuePair],
      "environmentFiles": [toEnvironmentFile],
      "cpu": "n",
      "memory": "n",
      "memoryReservation": "n",
      "resourceRequirements": [toResourceRequirement],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface InferenceAcceleratorOverride {
  deviceName?: string | null;
  deviceType?: string | null;
}
function fromInferenceAcceleratorOverride(input?: InferenceAcceleratorOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deviceName: input["deviceName"],
    deviceType: input["deviceType"],
  }
}
function toInferenceAcceleratorOverride(root: jsonP.JSONValue): InferenceAcceleratorOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "deviceName": "s",
      "deviceType": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface AttachmentStateChange {
  attachmentArn: string;
  status: string;
}
function fromAttachmentStateChange(input?: AttachmentStateChange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attachmentArn: input["attachmentArn"],
    status: input["status"],
  }
}

// refs: 6 - tags: input, named, interface, output
export interface NetworkBinding {
  bindIP?: string | null;
  containerPort?: number | null;
  hostPort?: number | null;
  protocol?: TransportProtocol | null;
}
function fromNetworkBinding(input?: NetworkBinding | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bindIP: input["bindIP"],
    containerPort: input["containerPort"],
    hostPort: input["hostPort"],
    protocol: input["protocol"],
  }
}
function toNetworkBinding(root: jsonP.JSONValue): NetworkBinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "bindIP": "s",
      "containerPort": "n",
      "hostPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<TransportProtocol>(x),
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ContainerStateChange {
  containerName?: string | null;
  imageDigest?: string | null;
  runtimeId?: string | null;
  exitCode?: number | null;
  networkBindings?: NetworkBinding[] | null;
  reason?: string | null;
  status?: string | null;
}
function fromContainerStateChange(input?: ContainerStateChange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerName: input["containerName"],
    imageDigest: input["imageDigest"],
    runtimeId: input["runtimeId"],
    exitCode: input["exitCode"],
    networkBindings: input["networkBindings"]?.map(x => fromNetworkBinding(x)),
    reason: input["reason"],
    status: input["status"],
  }
}

// refs: 1 - tags: input, named, interface
export interface AutoScalingGroupProviderUpdate {
  managedScaling?: ManagedScaling | null;
  managedTerminationProtection?: ManagedTerminationProtection | null;
}
function fromAutoScalingGroupProviderUpdate(input?: AutoScalingGroupProviderUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    managedScaling: fromManagedScaling(input["managedScaling"]),
    managedTerminationProtection: input["managedTerminationProtection"],
  }
}

// refs: 4 - tags: output, named, interface
export interface CapacityProvider {
  capacityProviderArn?: string | null;
  name?: string | null;
  status?: CapacityProviderStatus | null;
  autoScalingGroupProvider?: AutoScalingGroupProvider | null;
  updateStatus?: CapacityProviderUpdateStatus | null;
  updateStatusReason?: string | null;
  tags?: Tag[] | null;
}
function toCapacityProvider(root: jsonP.JSONValue): CapacityProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "capacityProviderArn": "s",
      "name": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<CapacityProviderStatus>(x),
      "autoScalingGroupProvider": toAutoScalingGroupProvider,
      "updateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CapacityProviderUpdateStatus>(x),
      "updateStatusReason": "s",
      "tags": [toTag],
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type CapacityProviderStatus =
| "ACTIVE"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type CapacityProviderUpdateStatus =
| "DELETE_IN_PROGRESS"
| "DELETE_COMPLETE"
| "DELETE_FAILED"
| "UPDATE_IN_PROGRESS"
| "UPDATE_COMPLETE"
| "UPDATE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface Cluster {
  clusterArn?: string | null;
  clusterName?: string | null;
  status?: string | null;
  registeredContainerInstancesCount?: number | null;
  runningTasksCount?: number | null;
  pendingTasksCount?: number | null;
  activeServicesCount?: number | null;
  statistics?: KeyValuePair[] | null;
  tags?: Tag[] | null;
  settings?: ClusterSetting[] | null;
  capacityProviders?: string[] | null;
  defaultCapacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  attachments?: Attachment[] | null;
  attachmentsStatus?: string | null;
}
function toCluster(root: jsonP.JSONValue): Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "clusterArn": "s",
      "clusterName": "s",
      "status": "s",
      "registeredContainerInstancesCount": "n",
      "runningTasksCount": "n",
      "pendingTasksCount": "n",
      "activeServicesCount": "n",
      "statistics": [toKeyValuePair],
      "tags": [toTag],
      "settings": [toClusterSetting],
      "capacityProviders": ["s"],
      "defaultCapacityProviderStrategy": [toCapacityProviderStrategyItem],
      "attachments": [toAttachment],
      "attachmentsStatus": "s",
    },
  }, root);
}

// refs: 14 - tags: output, named, interface
export interface Attachment {
  id?: string | null;
  type?: string | null;
  status?: string | null;
  details?: KeyValuePair[] | null;
}
function toAttachment(root: jsonP.JSONValue): Attachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "type": "s",
      "status": "s",
      "details": [toKeyValuePair],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Service {
  serviceArn?: string | null;
  serviceName?: string | null;
  clusterArn?: string | null;
  loadBalancers?: LoadBalancer[] | null;
  serviceRegistries?: ServiceRegistry[] | null;
  status?: string | null;
  desiredCount?: number | null;
  runningCount?: number | null;
  pendingCount?: number | null;
  launchType?: LaunchType | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  platformVersion?: string | null;
  taskDefinition?: string | null;
  deploymentConfiguration?: DeploymentConfiguration | null;
  taskSets?: TaskSet[] | null;
  deployments?: Deployment[] | null;
  roleArn?: string | null;
  events?: ServiceEvent[] | null;
  createdAt?: Date | number | null;
  placementConstraints?: PlacementConstraint[] | null;
  placementStrategy?: PlacementStrategy[] | null;
  networkConfiguration?: NetworkConfiguration | null;
  healthCheckGracePeriodSeconds?: number | null;
  schedulingStrategy?: SchedulingStrategy | null;
  deploymentController?: DeploymentController | null;
  tags?: Tag[] | null;
  createdBy?: string | null;
  enableECSManagedTags?: boolean | null;
  propagateTags?: PropagateTags | null;
}
function toService(root: jsonP.JSONValue): Service {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceArn": "s",
      "serviceName": "s",
      "clusterArn": "s",
      "loadBalancers": [toLoadBalancer],
      "serviceRegistries": [toServiceRegistry],
      "status": "s",
      "desiredCount": "n",
      "runningCount": "n",
      "pendingCount": "n",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<LaunchType>(x),
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "platformVersion": "s",
      "taskDefinition": "s",
      "deploymentConfiguration": toDeploymentConfiguration,
      "taskSets": [toTaskSet],
      "deployments": [toDeployment],
      "roleArn": "s",
      "events": [toServiceEvent],
      "createdAt": "d",
      "placementConstraints": [toPlacementConstraint],
      "placementStrategy": [toPlacementStrategy],
      "networkConfiguration": toNetworkConfiguration,
      "healthCheckGracePeriodSeconds": "n",
      "schedulingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SchedulingStrategy>(x),
      "deploymentController": toDeploymentController,
      "tags": [toTag],
      "createdBy": "s",
      "enableECSManagedTags": "b",
      "propagateTags": (x: jsonP.JSONValue) => cmnP.readEnum<PropagateTags>(x),
    },
  }, root);
}

// refs: 9 - tags: output, named, interface
export interface TaskSet {
  id?: string | null;
  taskSetArn?: string | null;
  serviceArn?: string | null;
  clusterArn?: string | null;
  startedBy?: string | null;
  externalId?: string | null;
  status?: string | null;
  taskDefinition?: string | null;
  computedDesiredCount?: number | null;
  pendingCount?: number | null;
  runningCount?: number | null;
  createdAt?: Date | number | null;
  updatedAt?: Date | number | null;
  launchType?: LaunchType | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  platformVersion?: string | null;
  networkConfiguration?: NetworkConfiguration | null;
  loadBalancers?: LoadBalancer[] | null;
  serviceRegistries?: ServiceRegistry[] | null;
  scale?: Scale | null;
  stabilityStatus?: StabilityStatus | null;
  stabilityStatusAt?: Date | number | null;
  tags?: Tag[] | null;
}
function toTaskSet(root: jsonP.JSONValue): TaskSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "taskSetArn": "s",
      "serviceArn": "s",
      "clusterArn": "s",
      "startedBy": "s",
      "externalId": "s",
      "status": "s",
      "taskDefinition": "s",
      "computedDesiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "createdAt": "d",
      "updatedAt": "d",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<LaunchType>(x),
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "platformVersion": "s",
      "networkConfiguration": toNetworkConfiguration,
      "loadBalancers": [toLoadBalancer],
      "serviceRegistries": [toServiceRegistry],
      "scale": toScale,
      "stabilityStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StabilityStatus>(x),
      "stabilityStatusAt": "d",
      "tags": [toTag],
    },
  }, root);
}

// refs: 9 - tags: output, named, enum
export type StabilityStatus =
| "STEADY_STATE"
| "STABILIZING"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Deployment {
  id?: string | null;
  status?: string | null;
  taskDefinition?: string | null;
  desiredCount?: number | null;
  pendingCount?: number | null;
  runningCount?: number | null;
  failedTasks?: number | null;
  createdAt?: Date | number | null;
  updatedAt?: Date | number | null;
  capacityProviderStrategy?: CapacityProviderStrategyItem[] | null;
  launchType?: LaunchType | null;
  platformVersion?: string | null;
  networkConfiguration?: NetworkConfiguration | null;
  rolloutState?: DeploymentRolloutState | null;
  rolloutStateReason?: string | null;
}
function toDeployment(root: jsonP.JSONValue): Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "status": "s",
      "taskDefinition": "s",
      "desiredCount": "n",
      "pendingCount": "n",
      "runningCount": "n",
      "failedTasks": "n",
      "createdAt": "d",
      "updatedAt": "d",
      "capacityProviderStrategy": [toCapacityProviderStrategyItem],
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<LaunchType>(x),
      "platformVersion": "s",
      "networkConfiguration": toNetworkConfiguration,
      "rolloutState": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentRolloutState>(x),
      "rolloutStateReason": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type DeploymentRolloutState =
| "COMPLETED"
| "FAILED"
| "IN_PROGRESS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface ServiceEvent {
  id?: string | null;
  createdAt?: Date | number | null;
  message?: string | null;
}
function toServiceEvent(root: jsonP.JSONValue): ServiceEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "createdAt": "d",
      "message": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Setting {
  name?: SettingName | null;
  value?: string | null;
  principalArn?: string | null;
}
function toSetting(root: jsonP.JSONValue): Setting {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<SettingName>(x),
      "value": "s",
      "principalArn": "s",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface ContainerInstance {
  containerInstanceArn?: string | null;
  ec2InstanceId?: string | null;
  capacityProviderName?: string | null;
  version?: number | null;
  versionInfo?: VersionInfo | null;
  remainingResources?: Resource[] | null;
  registeredResources?: Resource[] | null;
  status?: string | null;
  statusReason?: string | null;
  agentConnected?: boolean | null;
  runningTasksCount?: number | null;
  pendingTasksCount?: number | null;
  agentUpdateStatus?: AgentUpdateStatus | null;
  attributes?: Attribute[] | null;
  registeredAt?: Date | number | null;
  attachments?: Attachment[] | null;
  tags?: Tag[] | null;
}
function toContainerInstance(root: jsonP.JSONValue): ContainerInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerInstanceArn": "s",
      "ec2InstanceId": "s",
      "capacityProviderName": "s",
      "version": "n",
      "versionInfo": toVersionInfo,
      "remainingResources": [toResource],
      "registeredResources": [toResource],
      "status": "s",
      "statusReason": "s",
      "agentConnected": "b",
      "runningTasksCount": "n",
      "pendingTasksCount": "n",
      "agentUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AgentUpdateStatus>(x),
      "attributes": [toAttribute],
      "registeredAt": "d",
      "attachments": [toAttachment],
      "tags": [toTag],
    },
  }, root);
}

// refs: 5 - tags: output, named, enum
export type AgentUpdateStatus =
| "PENDING"
| "STAGING"
| "STAGED"
| "UPDATING"
| "UPDATED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface TaskDefinition {
  taskDefinitionArn?: string | null;
  containerDefinitions?: ContainerDefinition[] | null;
  family?: string | null;
  taskRoleArn?: string | null;
  executionRoleArn?: string | null;
  networkMode?: NetworkMode | null;
  revision?: number | null;
  volumes?: Volume[] | null;
  status?: TaskDefinitionStatus | null;
  requiresAttributes?: Attribute[] | null;
  placementConstraints?: TaskDefinitionPlacementConstraint[] | null;
  compatibilities?: Compatibility[] | null;
  requiresCompatibilities?: Compatibility[] | null;
  cpu?: string | null;
  memory?: string | null;
  inferenceAccelerators?: InferenceAccelerator[] | null;
  pidMode?: PidMode | null;
  ipcMode?: IpcMode | null;
  proxyConfiguration?: ProxyConfiguration | null;
  registeredAt?: Date | number | null;
  deregisteredAt?: Date | number | null;
  registeredBy?: string | null;
}
function toTaskDefinition(root: jsonP.JSONValue): TaskDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskDefinitionArn": "s",
      "containerDefinitions": [toContainerDefinition],
      "family": "s",
      "taskRoleArn": "s",
      "executionRoleArn": "s",
      "networkMode": (x: jsonP.JSONValue) => cmnP.readEnum<NetworkMode>(x),
      "revision": "n",
      "volumes": [toVolume],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<TaskDefinitionStatus>(x),
      "requiresAttributes": [toAttribute],
      "placementConstraints": [toTaskDefinitionPlacementConstraint],
      "compatibilities": [(x: jsonP.JSONValue) => cmnP.readEnum<Compatibility>(x)],
      "requiresCompatibilities": [(x: jsonP.JSONValue) => cmnP.readEnum<Compatibility>(x)],
      "cpu": "s",
      "memory": "s",
      "inferenceAccelerators": [toInferenceAccelerator],
      "pidMode": (x: jsonP.JSONValue) => cmnP.readEnum<PidMode>(x),
      "ipcMode": (x: jsonP.JSONValue) => cmnP.readEnum<IpcMode>(x),
      "proxyConfiguration": toProxyConfiguration,
      "registeredAt": "d",
      "deregisteredAt": "d",
      "registeredBy": "s",
    },
  }, root);
}

// refs: 9 - tags: output, named, interface
export interface Failure {
  arn?: string | null;
  reason?: string | null;
  detail?: string | null;
}
function toFailure(root: jsonP.JSONValue): Failure {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "reason": "s",
      "detail": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Task {
  attachments?: Attachment[] | null;
  attributes?: Attribute[] | null;
  availabilityZone?: string | null;
  capacityProviderName?: string | null;
  clusterArn?: string | null;
  connectivity?: Connectivity | null;
  connectivityAt?: Date | number | null;
  containerInstanceArn?: string | null;
  containers?: Container[] | null;
  cpu?: string | null;
  createdAt?: Date | number | null;
  desiredStatus?: string | null;
  executionStoppedAt?: Date | number | null;
  group?: string | null;
  healthStatus?: HealthStatus | null;
  inferenceAccelerators?: InferenceAccelerator[] | null;
  lastStatus?: string | null;
  launchType?: LaunchType | null;
  memory?: string | null;
  overrides?: TaskOverride | null;
  platformVersion?: string | null;
  pullStartedAt?: Date | number | null;
  pullStoppedAt?: Date | number | null;
  startedAt?: Date | number | null;
  startedBy?: string | null;
  stopCode?: TaskStopCode | null;
  stoppedAt?: Date | number | null;
  stoppedReason?: string | null;
  stoppingAt?: Date | number | null;
  tags?: Tag[] | null;
  taskArn?: string | null;
  taskDefinitionArn?: string | null;
  version?: number | null;
}
function toTask(root: jsonP.JSONValue): Task {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachments": [toAttachment],
      "attributes": [toAttribute],
      "availabilityZone": "s",
      "capacityProviderName": "s",
      "clusterArn": "s",
      "connectivity": (x: jsonP.JSONValue) => cmnP.readEnum<Connectivity>(x),
      "connectivityAt": "d",
      "containerInstanceArn": "s",
      "containers": [toContainer],
      "cpu": "s",
      "createdAt": "d",
      "desiredStatus": "s",
      "executionStoppedAt": "d",
      "group": "s",
      "healthStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HealthStatus>(x),
      "inferenceAccelerators": [toInferenceAccelerator],
      "lastStatus": "s",
      "launchType": (x: jsonP.JSONValue) => cmnP.readEnum<LaunchType>(x),
      "memory": "s",
      "overrides": toTaskOverride,
      "platformVersion": "s",
      "pullStartedAt": "d",
      "pullStoppedAt": "d",
      "startedAt": "d",
      "startedBy": "s",
      "stopCode": (x: jsonP.JSONValue) => cmnP.readEnum<TaskStopCode>(x),
      "stoppedAt": "d",
      "stoppedReason": "s",
      "stoppingAt": "d",
      "tags": [toTag],
      "taskArn": "s",
      "taskDefinitionArn": "s",
      "version": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type Connectivity =
| "CONNECTED"
| "DISCONNECTED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Container {
  containerArn?: string | null;
  taskArn?: string | null;
  name?: string | null;
  image?: string | null;
  imageDigest?: string | null;
  runtimeId?: string | null;
  lastStatus?: string | null;
  exitCode?: number | null;
  reason?: string | null;
  networkBindings?: NetworkBinding[] | null;
  networkInterfaces?: NetworkInterface[] | null;
  healthStatus?: HealthStatus | null;
  cpu?: string | null;
  memory?: string | null;
  memoryReservation?: string | null;
  gpuIds?: string[] | null;
}
function toContainer(root: jsonP.JSONValue): Container {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerArn": "s",
      "taskArn": "s",
      "name": "s",
      "image": "s",
      "imageDigest": "s",
      "runtimeId": "s",
      "lastStatus": "s",
      "exitCode": "n",
      "reason": "s",
      "networkBindings": [toNetworkBinding],
      "networkInterfaces": [toNetworkInterface],
      "healthStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HealthStatus>(x),
      "cpu": "s",
      "memory": "s",
      "memoryReservation": "s",
      "gpuIds": ["s"],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface NetworkInterface {
  attachmentId?: string | null;
  privateIpv4Address?: string | null;
  ipv6Address?: string | null;
}
function toNetworkInterface(root: jsonP.JSONValue): NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachmentId": "s",
      "privateIpv4Address": "s",
      "ipv6Address": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type HealthStatus =
| "HEALTHY"
| "UNHEALTHY"
| "UNKNOWN"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type TaskStopCode =
| "TaskFailedToStart"
| "EssentialContainerExited"
| "UserInitiated"
| cmnP.UnexpectedEnumValue;
