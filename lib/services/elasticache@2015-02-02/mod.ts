// Autogenerated API client for: Amazon ElastiCache

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class ElastiCache {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElastiCache.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-02-02",
    "endpointPrefix": "elasticache",
    "protocol": "query",
    "serviceFullName": "Amazon ElastiCache",
    "serviceId": "ElastiCache",
    "signatureVersion": "v4",
    "uid": "elasticache-2015-02-02",
    "xmlNamespace": "http://elasticache.amazonaws.com/doc/2015-02-02/"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceMessage,
  ): Promise<s.TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddTagsToResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async authorizeCacheSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeCacheSecurityGroupIngressMessage,
  ): Promise<s.AuthorizeCacheSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeCacheSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeCacheSecurityGroupIngressResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async batchApplyUpdateAction(
    {abortSignal, ...params}: RequestConfig & s.BatchApplyUpdateActionMessage,
  ): Promise<s.UpdateActionResultsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchApplyUpdateAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchApplyUpdateActionResult");
    return {
      ProcessedUpdateActions: xml.getList("ProcessedUpdateActions", "ProcessedUpdateAction").map(ProcessedUpdateAction_Parse),
      UnprocessedUpdateActions: xml.getList("UnprocessedUpdateActions", "UnprocessedUpdateAction").map(UnprocessedUpdateAction_Parse),
    };
  }

  async batchStopUpdateAction(
    {abortSignal, ...params}: RequestConfig & s.BatchStopUpdateActionMessage,
  ): Promise<s.UpdateActionResultsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStopUpdateAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchStopUpdateActionResult");
    return {
      ProcessedUpdateActions: xml.getList("ProcessedUpdateActions", "ProcessedUpdateAction").map(ProcessedUpdateAction_Parse),
      UnprocessedUpdateActions: xml.getList("UnprocessedUpdateActions", "UnprocessedUpdateAction").map(UnprocessedUpdateAction_Parse),
    };
  }

  async completeMigration(
    {abortSignal, ...params}: RequestConfig & s.CompleteMigrationMessage,
  ): Promise<s.CompleteMigrationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteMigration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CompleteMigrationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async copySnapshot(
    {abortSignal, ...params}: RequestConfig & s.CopySnapshotMessage,
  ): Promise<s.CopySnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceSnapshotName", (params["SourceSnapshotName"] ?? '').toString());
    body.append(prefix+"TargetSnapshotName", (params["TargetSnapshotName"] ?? '').toString());
    if ("TargetBucket" in params) body.append(prefix+"TargetBucket", (params["TargetBucket"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopySnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopySnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createCacheCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateCacheClusterMessage,
  ): Promise<s.CreateCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("AZMode" in params) body.append(prefix+"AZMode", (params["AZMode"] ?? '').toString());
    if ("PreferredAvailabilityZone" in params) body.append(prefix+"PreferredAvailabilityZone", (params["PreferredAvailabilityZone"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+"PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if ("NumCacheNodes" in params) body.append(prefix+"NumCacheNodes", (params["NumCacheNodes"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if (params["SnapshotArns"]) qsP.appendList(body, prefix+"SnapshotArns", params["SnapshotArns"], {"entryPrefix":".SnapshotArn."})
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("OutpostMode" in params) body.append(prefix+"OutpostMode", (params["OutpostMode"] ?? '').toString());
    if ("PreferredOutpostArn" in params) body.append(prefix+"PreferredOutpostArn", (params["PreferredOutpostArn"] ?? '').toString());
    if (params["PreferredOutpostArns"]) qsP.appendList(body, prefix+"PreferredOutpostArns", params["PreferredOutpostArns"], {"entryPrefix":".PreferredOutpostArn."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async createCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateCacheParameterGroupMessage,
  ): Promise<s.CreateCacheParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheParameterGroupResult");
    return {
      CacheParameterGroup: xml.first("CacheParameterGroup", false, CacheParameterGroup_Parse),
    };
  }

  async createCacheSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateCacheSecurityGroupMessage,
  ): Promise<s.CreateCacheSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheSecurityGroupResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async createCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateCacheSubnetGroupMessage,
  ): Promise<s.CreateCacheSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    body.append(prefix+"CacheSubnetGroupDescription", (params["CacheSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheSubnetGroupResult");
    return {
      CacheSubnetGroup: xml.first("CacheSubnetGroup", false, CacheSubnetGroup_Parse),
    };
  }

  async createGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGlobalReplicationGroupMessage,
  ): Promise<s.CreateGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupIdSuffix", (params["GlobalReplicationGroupIdSuffix"] ?? '').toString());
    if ("GlobalReplicationGroupDescription" in params) body.append(prefix+"GlobalReplicationGroupDescription", (params["GlobalReplicationGroupDescription"] ?? '').toString());
    body.append(prefix+"PrimaryReplicationGroupId", (params["PrimaryReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async createReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateReplicationGroupMessage,
  ): Promise<s.CreateReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupDescription", (params["ReplicationGroupDescription"] ?? '').toString());
    if ("GlobalReplicationGroupId" in params) body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    if ("PrimaryClusterId" in params) body.append(prefix+"PrimaryClusterId", (params["PrimaryClusterId"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    if ("MultiAZEnabled" in params) body.append(prefix+"MultiAZEnabled", (params["MultiAZEnabled"] ?? '').toString());
    if ("NumCacheClusters" in params) body.append(prefix+"NumCacheClusters", (params["NumCacheClusters"] ?? '').toString());
    if (params["PreferredCacheClusterAZs"]) qsP.appendList(body, prefix+"PreferredCacheClusterAZs", params["PreferredCacheClusterAZs"], {"entryPrefix":".AvailabilityZone."})
    if ("NumNodeGroups" in params) body.append(prefix+"NumNodeGroups", (params["NumNodeGroups"] ?? '').toString());
    if ("ReplicasPerNodeGroup" in params) body.append(prefix+"ReplicasPerNodeGroup", (params["ReplicasPerNodeGroup"] ?? '').toString());
    if (params["NodeGroupConfiguration"]) qsP.appendList(body, prefix+"NodeGroupConfiguration", params["NodeGroupConfiguration"], {"appender":NodeGroupConfiguration_Serialize,"entryPrefix":".NodeGroupConfiguration."})
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if (params["SnapshotArns"]) qsP.appendList(body, prefix+"SnapshotArns", params["SnapshotArns"], {"entryPrefix":".SnapshotArn."})
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("TransitEncryptionEnabled" in params) body.append(prefix+"TransitEncryptionEnabled", (params["TransitEncryptionEnabled"] ?? '').toString());
    if ("AtRestEncryptionEnabled" in params) body.append(prefix+"AtRestEncryptionEnabled", (params["AtRestEncryptionEnabled"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["UserGroupIds"]) qsP.appendList(body, prefix+"UserGroupIds", params["UserGroupIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotMessage,
  ): Promise<s.CreateSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & s.CreateUserMessage,
  ): Promise<s.User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["Passwords"]) qsP.appendList(body, prefix+"Passwords", params["Passwords"], {"entryPrefix":".member."})
    body.append(prefix+"AccessString", (params["AccessString"] ?? '').toString());
    if ("NoPasswordRequired" in params) body.append(prefix+"NoPasswordRequired", (params["NoPasswordRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUserResult");
    return User_Parse(xml);
  }

  async createUserGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateUserGroupMessage,
  ): Promise<s.UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserIds", params["UserIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async decreaseNodeGroupsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.DecreaseNodeGroupsInGlobalReplicationGroupMessage,
  ): Promise<s.DecreaseNodeGroupsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    if (params["GlobalNodeGroupsToRemove"]) qsP.appendList(body, prefix+"GlobalNodeGroupsToRemove", params["GlobalNodeGroupsToRemove"], {"entryPrefix":".GlobalNodeGroupId."})
    if (params["GlobalNodeGroupsToRetain"]) qsP.appendList(body, prefix+"GlobalNodeGroupsToRetain", params["GlobalNodeGroupsToRetain"], {"entryPrefix":".GlobalNodeGroupId."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseNodeGroupsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DecreaseNodeGroupsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async decreaseReplicaCount(
    {abortSignal, ...params}: RequestConfig & s.DecreaseReplicaCountMessage,
  ): Promise<s.DecreaseReplicaCountResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("NewReplicaCount" in params) body.append(prefix+"NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["ReplicaConfiguration"]) qsP.appendList(body, prefix+"ReplicaConfiguration", params["ReplicaConfiguration"], {"appender":ConfigureShard_Serialize,"entryPrefix":".ConfigureShard."})
    if (params["ReplicasToRemove"]) qsP.appendList(body, prefix+"ReplicasToRemove", params["ReplicasToRemove"], {"entryPrefix":".member."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseReplicaCount",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DecreaseReplicaCountResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async deleteCacheCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteCacheClusterMessage,
  ): Promise<s.DeleteCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("FinalSnapshotIdentifier" in params) body.append(prefix+"FinalSnapshotIdentifier", (params["FinalSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async deleteCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteCacheParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheParameterGroup",
    });
  }

  async deleteCacheSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteCacheSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheSecurityGroup",
    });
  }

  async deleteCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteCacheSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheSubnetGroup",
    });
  }

  async deleteGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGlobalReplicationGroupMessage,
  ): Promise<s.DeleteGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"RetainPrimaryReplicationGroup", (params["RetainPrimaryReplicationGroup"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async deleteReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteReplicationGroupMessage,
  ): Promise<s.DeleteReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("RetainPrimaryCluster" in params) body.append(prefix+"RetainPrimaryCluster", (params["RetainPrimaryCluster"] ?? '').toString());
    if ("FinalSnapshotIdentifier" in params) body.append(prefix+"FinalSnapshotIdentifier", (params["FinalSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async deleteSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotMessage,
  ): Promise<s.DeleteSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserMessage,
  ): Promise<s.User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteUserResult");
    return User_Parse(xml);
  }

  async deleteUserGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserGroupMessage,
  ): Promise<s.UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async describeCacheClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheClustersMessage = {},
  ): Promise<s.CacheClusterMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("ShowCacheNodeInfo" in params) body.append(prefix+"ShowCacheNodeInfo", (params["ShowCacheNodeInfo"] ?? '').toString());
    if ("ShowCacheClustersNotInReplicationGroups" in params) body.append(prefix+"ShowCacheClustersNotInReplicationGroups", (params["ShowCacheClustersNotInReplicationGroups"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheClusters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheClusters: xml.getList("CacheClusters", "CacheCluster").map(CacheCluster_Parse),
    };
  }

  async describeCacheEngineVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheEngineVersionsMessage = {},
  ): Promise<s.CacheEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupFamily" in params) body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheEngineVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheEngineVersions: xml.getList("CacheEngineVersions", "CacheEngineVersion").map(CacheEngineVersion_Parse),
    };
  }

  async describeCacheParameterGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheParameterGroupsMessage = {},
  ): Promise<s.CacheParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheParameterGroups: xml.getList("CacheParameterGroups", "CacheParameterGroup").map(CacheParameterGroup_Parse),
    };
  }

  async describeCacheParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheParametersMessage,
  ): Promise<s.CacheParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
      CacheNodeTypeSpecificParameters: xml.getList("CacheNodeTypeSpecificParameters", "CacheNodeTypeSpecificParameter").map(CacheNodeTypeSpecificParameter_Parse),
    };
  }

  async describeCacheSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheSecurityGroupsMessage = {},
  ): Promise<s.CacheSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheSecurityGroupName" in params) body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheSecurityGroups: xml.getList("CacheSecurityGroups", "CacheSecurityGroup").map(CacheSecurityGroup_Parse),
    };
  }

  async describeCacheSubnetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeCacheSubnetGroupsMessage = {},
  ): Promise<s.CacheSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheSubnetGroups: xml.getList("CacheSubnetGroups", "CacheSubnetGroup").map(CacheSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeEngineDefaultParametersMessage,
  ): Promise<s.DescribeEngineDefaultParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEngineDefaultParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsMessage = {},
  ): Promise<s.EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeGlobalReplicationGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeGlobalReplicationGroupsMessage = {},
  ): Promise<s.DescribeGlobalReplicationGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalReplicationGroupId" in params) body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("ShowMemberInfo" in params) body.append(prefix+"ShowMemberInfo", (params["ShowMemberInfo"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalReplicationGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeGlobalReplicationGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      GlobalReplicationGroups: xml.getList("GlobalReplicationGroups", "GlobalReplicationGroup").map(GlobalReplicationGroup_Parse),
    };
  }

  async describeReplicationGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationGroupsMessage = {},
  ): Promise<s.ReplicationGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReplicationGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReplicationGroups: xml.getList("ReplicationGroups", "ReplicationGroup").map(ReplicationGroup_Parse),
    };
  }

  async describeReservedCacheNodes(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedCacheNodesMessage = {},
  ): Promise<s.ReservedCacheNodeMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedCacheNodeId" in params) body.append(prefix+"ReservedCacheNodeId", (params["ReservedCacheNodeId"] ?? '').toString());
    if ("ReservedCacheNodesOfferingId" in params) body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedCacheNodes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedCacheNodesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedCacheNodes: xml.getList("ReservedCacheNodes", "ReservedCacheNode").map(ReservedCacheNode_Parse),
    };
  }

  async describeReservedCacheNodesOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedCacheNodesOfferingsMessage = {},
  ): Promise<s.ReservedCacheNodesOfferingMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedCacheNodesOfferingId" in params) body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedCacheNodesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedCacheNodesOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedCacheNodesOfferings: xml.getList("ReservedCacheNodesOfferings", "ReservedCacheNodesOffering").map(ReservedCacheNodesOffering_Parse),
    };
  }

  async describeServiceUpdates(
    {abortSignal, ...params}: RequestConfig & s.DescribeServiceUpdatesMessage = {},
  ): Promise<s.ServiceUpdatesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ServiceUpdateName" in params) body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    if (params["ServiceUpdateStatus"]) qsP.appendList(body, prefix+"ServiceUpdateStatus", params["ServiceUpdateStatus"], {"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceUpdates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeServiceUpdatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ServiceUpdates: xml.getList("ServiceUpdates", "ServiceUpdate").map(ServiceUpdate_Parse),
    };
  }

  async describeSnapshots(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotsMessage = {},
  ): Promise<s.DescribeSnapshotsListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("SnapshotSource" in params) body.append(prefix+"SnapshotSource", (params["SnapshotSource"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("ShowNodeGroupConfig" in params) body.append(prefix+"ShowNodeGroupConfig", (params["ShowNodeGroupConfig"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Snapshots: xml.getList("Snapshots", "Snapshot").map(Snapshot_Parse),
    };
  }

  async describeUpdateActions(
    {abortSignal, ...params}: RequestConfig & s.DescribeUpdateActionsMessage = {},
  ): Promise<s.UpdateActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ServiceUpdateName" in params) body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["ServiceUpdateStatus"]) qsP.appendList(body, prefix+"ServiceUpdateStatus", params["ServiceUpdateStatus"], {"entryPrefix":".member."})
    if (params["ServiceUpdateTimeRange"] != null) TimeRangeFilter_Serialize(body, prefix+"ServiceUpdateTimeRange", params["ServiceUpdateTimeRange"]);
    if (params["UpdateActionStatus"]) qsP.appendList(body, prefix+"UpdateActionStatus", params["UpdateActionStatus"], {"entryPrefix":".member."})
    if ("ShowNodeLevelUpdateStatus" in params) body.append(prefix+"ShowNodeLevelUpdateStatus", (params["ShowNodeLevelUpdateStatus"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUpdateActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUpdateActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UpdateActions: xml.getList("UpdateActions", "UpdateAction").map(UpdateAction_Parse),
    };
  }

  async describeUserGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserGroupsMessage = {},
  ): Promise<s.DescribeUserGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserGroupId" in params) body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUserGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UserGroups: xml.getList("UserGroups", "member").map(UserGroup_Parse),
    };
  }

  async describeUsers(
    {abortSignal, ...params}: RequestConfig & s.DescribeUsersMessage = {},
  ): Promise<s.DescribeUsersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUsersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Users: xml.getList("Users", "member").map(User_Parse),
    };
  }

  async disassociateGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.DisassociateGlobalReplicationGroupMessage,
  ): Promise<s.DisassociateGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupRegion", (params["ReplicationGroupRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisassociateGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async failoverGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.FailoverGlobalReplicationGroupMessage,
  ): Promise<s.FailoverGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"PrimaryRegion", (params["PrimaryRegion"] ?? '').toString());
    body.append(prefix+"PrimaryReplicationGroupId", (params["PrimaryReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "FailoverGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "FailoverGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async increaseNodeGroupsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.IncreaseNodeGroupsInGlobalReplicationGroupMessage,
  ): Promise<s.IncreaseNodeGroupsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    if (params["RegionalConfigurations"]) qsP.appendList(body, prefix+"RegionalConfigurations", params["RegionalConfigurations"], {"appender":RegionalConfiguration_Serialize,"entryPrefix":".RegionalConfiguration."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseNodeGroupsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IncreaseNodeGroupsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async increaseReplicaCount(
    {abortSignal, ...params}: RequestConfig & s.IncreaseReplicaCountMessage,
  ): Promise<s.IncreaseReplicaCountResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("NewReplicaCount" in params) body.append(prefix+"NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["ReplicaConfiguration"]) qsP.appendList(body, prefix+"ReplicaConfiguration", params["ReplicaConfiguration"], {"appender":ConfigureShard_Serialize,"entryPrefix":".ConfigureShard."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseReplicaCount",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IncreaseReplicaCountResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async listAllowedNodeTypeModifications(
    {abortSignal, ...params}: RequestConfig & s.ListAllowedNodeTypeModificationsMessage = {},
  ): Promise<s.AllowedNodeTypeModificationsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAllowedNodeTypeModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAllowedNodeTypeModificationsResult");
    return {
      ScaleUpModifications: xml.getList("ScaleUpModifications", "member").map(x => x.content ?? ''),
      ScaleDownModifications: xml.getList("ScaleDownModifications", "member").map(x => x.content ?? ''),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceMessage,
  ): Promise<s.TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyCacheCluster(
    {abortSignal, ...params}: RequestConfig & s.ModifyCacheClusterMessage,
  ): Promise<s.ModifyCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("NumCacheNodes" in params) body.append(prefix+"NumCacheNodes", (params["NumCacheNodes"] ?? '').toString());
    if (params["CacheNodeIdsToRemove"]) qsP.appendList(body, prefix+"CacheNodeIdsToRemove", params["CacheNodeIdsToRemove"], {"entryPrefix":".CacheNodeId."})
    if ("AZMode" in params) body.append(prefix+"AZMode", (params["AZMode"] ?? '').toString());
    if (params["NewAvailabilityZones"]) qsP.appendList(body, prefix+"NewAvailabilityZones", params["NewAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("NotificationTopicStatus" in params) body.append(prefix+"NotificationTopicStatus", (params["NotificationTopicStatus"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("AuthTokenUpdateStrategy" in params) body.append(prefix+"AuthTokenUpdateStrategy", (params["AuthTokenUpdateStrategy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async modifyCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyCacheParameterGroupMessage,
  ): Promise<s.CacheParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if (params["ParameterNameValues"]) qsP.appendList(body, prefix+"ParameterNameValues", params["ParameterNameValues"], {"appender":ParameterNameValue_Serialize,"entryPrefix":".ParameterNameValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheParameterGroupResult");
    return xml.strings({
      optional: {"CacheParameterGroupName":true},
    });
  }

  async modifyCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyCacheSubnetGroupMessage,
  ): Promise<s.ModifyCacheSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if ("CacheSubnetGroupDescription" in params) body.append(prefix+"CacheSubnetGroupDescription", (params["CacheSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheSubnetGroupResult");
    return {
      CacheSubnetGroup: xml.first("CacheSubnetGroup", false, CacheSubnetGroup_Parse),
    };
  }

  async modifyGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyGlobalReplicationGroupMessage,
  ): Promise<s.ModifyGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("GlobalReplicationGroupDescription" in params) body.append(prefix+"GlobalReplicationGroupDescription", (params["GlobalReplicationGroupDescription"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async modifyReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyReplicationGroupMessage,
  ): Promise<s.ModifyReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("ReplicationGroupDescription" in params) body.append(prefix+"ReplicationGroupDescription", (params["ReplicationGroupDescription"] ?? '').toString());
    if ("PrimaryClusterId" in params) body.append(prefix+"PrimaryClusterId", (params["PrimaryClusterId"] ?? '').toString());
    if ("SnapshottingClusterId" in params) body.append(prefix+"SnapshottingClusterId", (params["SnapshottingClusterId"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    if ("MultiAZEnabled" in params) body.append(prefix+"MultiAZEnabled", (params["MultiAZEnabled"] ?? '').toString());
    if ("NodeGroupId" in params) body.append(prefix+"NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("NotificationTopicStatus" in params) body.append(prefix+"NotificationTopicStatus", (params["NotificationTopicStatus"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("AuthTokenUpdateStrategy" in params) body.append(prefix+"AuthTokenUpdateStrategy", (params["AuthTokenUpdateStrategy"] ?? '').toString());
    if (params["UserGroupIdsToAdd"]) qsP.appendList(body, prefix+"UserGroupIdsToAdd", params["UserGroupIdsToAdd"], {"entryPrefix":".member."})
    if (params["UserGroupIdsToRemove"]) qsP.appendList(body, prefix+"UserGroupIdsToRemove", params["UserGroupIdsToRemove"], {"entryPrefix":".member."})
    if ("RemoveUserGroups" in params) body.append(prefix+"RemoveUserGroups", (params["RemoveUserGroups"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async modifyReplicationGroupShardConfiguration(
    {abortSignal, ...params}: RequestConfig & s.ModifyReplicationGroupShardConfigurationMessage,
  ): Promise<s.ModifyReplicationGroupShardConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if (params["ReshardingConfiguration"]) qsP.appendList(body, prefix+"ReshardingConfiguration", params["ReshardingConfiguration"], {"appender":ReshardingConfiguration_Serialize,"entryPrefix":".ReshardingConfiguration."})
    if (params["NodeGroupsToRemove"]) qsP.appendList(body, prefix+"NodeGroupsToRemove", params["NodeGroupsToRemove"], {"entryPrefix":".NodeGroupToRemove."})
    if (params["NodeGroupsToRetain"]) qsP.appendList(body, prefix+"NodeGroupsToRetain", params["NodeGroupsToRetain"], {"entryPrefix":".NodeGroupToRetain."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationGroupShardConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyReplicationGroupShardConfigurationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async modifyUser(
    {abortSignal, ...params}: RequestConfig & s.ModifyUserMessage,
  ): Promise<s.User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    if ("AccessString" in params) body.append(prefix+"AccessString", (params["AccessString"] ?? '').toString());
    if ("AppendAccessString" in params) body.append(prefix+"AppendAccessString", (params["AppendAccessString"] ?? '').toString());
    if (params["Passwords"]) qsP.appendList(body, prefix+"Passwords", params["Passwords"], {"entryPrefix":".member."})
    if ("NoPasswordRequired" in params) body.append(prefix+"NoPasswordRequired", (params["NoPasswordRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUserResult");
    return User_Parse(xml);
  }

  async modifyUserGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyUserGroupMessage,
  ): Promise<s.UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    if (params["UserIdsToAdd"]) qsP.appendList(body, prefix+"UserIdsToAdd", params["UserIdsToAdd"], {"entryPrefix":".member."})
    if (params["UserIdsToRemove"]) qsP.appendList(body, prefix+"UserIdsToRemove", params["UserIdsToRemove"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async purchaseReservedCacheNodesOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseReservedCacheNodesOfferingMessage,
  ): Promise<s.PurchaseReservedCacheNodesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("ReservedCacheNodeId" in params) body.append(prefix+"ReservedCacheNodeId", (params["ReservedCacheNodeId"] ?? '').toString());
    if ("CacheNodeCount" in params) body.append(prefix+"CacheNodeCount", (params["CacheNodeCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedCacheNodesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedCacheNodesOfferingResult");
    return {
      ReservedCacheNode: xml.first("ReservedCacheNode", false, ReservedCacheNode_Parse),
    };
  }

  async rebalanceSlotsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & s.RebalanceSlotsInGlobalReplicationGroupMessage,
  ): Promise<s.RebalanceSlotsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebalanceSlotsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebalanceSlotsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async rebootCacheCluster(
    {abortSignal, ...params}: RequestConfig & s.RebootCacheClusterMessage,
  ): Promise<s.RebootCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if (params["CacheNodeIdsToReboot"]) qsP.appendList(body, prefix+"CacheNodeIdsToReboot", params["CacheNodeIdsToReboot"], {"entryPrefix":".CacheNodeId."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceMessage,
  ): Promise<s.TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveTagsFromResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async resetCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ResetCacheParameterGroupMessage,
  ): Promise<s.CacheParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["ParameterNameValues"]) qsP.appendList(body, prefix+"ParameterNameValues", params["ParameterNameValues"], {"appender":ParameterNameValue_Serialize,"entryPrefix":".ParameterNameValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetCacheParameterGroupResult");
    return xml.strings({
      optional: {"CacheParameterGroupName":true},
    });
  }

  async revokeCacheSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.RevokeCacheSecurityGroupIngressMessage,
  ): Promise<s.RevokeCacheSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeCacheSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeCacheSecurityGroupIngressResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async startMigration(
    {abortSignal, ...params}: RequestConfig & s.StartMigrationMessage,
  ): Promise<s.StartMigrationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if (params["CustomerNodeEndpointList"]) qsP.appendList(body, prefix+"CustomerNodeEndpointList", params["CustomerNodeEndpointList"], {"appender":CustomerNodeEndpoint_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMigration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StartMigrationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async testFailover(
    {abortSignal, ...params}: RequestConfig & s.TestFailoverMessage,
  ): Promise<s.TestFailoverResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestFailover",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TestFailoverResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  // Resource State Waiters

  /**
   * Wait until ElastiCache cluster is available.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForCacheClusterAvailable(
    params: RequestConfig & s.DescribeCacheClustersMessage,
  ): Promise<s.CacheClusterMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CacheClusterAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCacheClusters(params);
      const field = resp?.CacheClusters?.flatMap(x => x?.CacheClusterStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
      if (field?.some(x => x === "restore-failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache cluster is deleted.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForCacheClusterDeleted(
    params: RequestConfig & s.DescribeCacheClustersMessage,
  ): Promise<Error | s.CacheClusterMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CacheClusterDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeCacheClusters(params);
        const field = resp?.CacheClusters?.flatMap(x => x?.CacheClusterStatus);
        if (field?.every(x => x === "deleted")) return resp;
        if (field?.some(x => x === "available")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
        if (field?.some(x => x === "modifying")) throw new Error(errMessage);
        if (field?.some(x => x === "restore-failed")) throw new Error(errMessage);
        if (field?.some(x => x === "snapshotting")) throw new Error(errMessage);
      } catch (err) {
        if (["CacheClusterNotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache replication group is available.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForReplicationGroupAvailable(
    params: RequestConfig & s.DescribeReplicationGroupsMessage,
  ): Promise<s.ReplicationGroupMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationGroupAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeReplicationGroups(params);
      const field = resp?.ReplicationGroups?.flatMap(x => x?.Status);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache replication group is deleted.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForReplicationGroupDeleted(
    params: RequestConfig & s.DescribeReplicationGroupsMessage,
  ): Promise<Error | s.ReplicationGroupMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationGroupDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeReplicationGroups(params);
        const field = resp?.ReplicationGroups?.flatMap(x => x?.Status);
        if (field?.every(x => x === "deleted")) return resp;
        if (field?.some(x => x === "available")) throw new Error(errMessage);
      } catch (err) {
        if (["ReplicationGroupNotFoundFault"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function User_Parse(node: xmlP.XmlNode): s.User {
  return {
    ...node.strings({
      optional: {"UserId":true,"UserName":true,"Status":true,"Engine":true,"AccessString":true,"ARN":true},
    }),
    UserGroupIds: node.getList("UserGroupIds", "member").map(x => x.content ?? ''),
    Authentication: node.first("Authentication", false, Authentication_Parse),
  };
}

function UserGroup_Parse(node: xmlP.XmlNode): s.UserGroup {
  return {
    ...node.strings({
      optional: {"UserGroupId":true,"Status":true,"Engine":true,"ARN":true},
    }),
    UserIds: node.getList("UserIds", "member").map(x => x.content ?? ''),
    PendingChanges: node.first("PendingChanges", false, UserGroupPendingChanges_Parse),
    ReplicationGroups: node.getList("ReplicationGroups", "member").map(x => x.content ?? ''),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function NodeGroupConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.NodeGroupConfiguration) {
    if ("NodeGroupId" in params) body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if ("Slots" in params) body.append(prefix+".Slots", (params["Slots"] ?? '').toString());
    if ("ReplicaCount" in params) body.append(prefix+".ReplicaCount", (params["ReplicaCount"] ?? '').toString());
    if ("PrimaryAvailabilityZone" in params) body.append(prefix+".PrimaryAvailabilityZone", (params["PrimaryAvailabilityZone"] ?? '').toString());
    if (params["ReplicaAvailabilityZones"]) qsP.appendList(body, prefix+".ReplicaAvailabilityZones", params["ReplicaAvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    if ("PrimaryOutpostArn" in params) body.append(prefix+".PrimaryOutpostArn", (params["PrimaryOutpostArn"] ?? '').toString());
    if (params["ReplicaOutpostArns"]) qsP.appendList(body, prefix+".ReplicaOutpostArns", params["ReplicaOutpostArns"], {"entryPrefix":".OutpostArn."})
}
function NodeGroupConfiguration_Parse(node: xmlP.XmlNode): s.NodeGroupConfiguration {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true,"Slots":true,"PrimaryAvailabilityZone":true,"PrimaryOutpostArn":true},
    }),
    ReplicaCount: node.first("ReplicaCount", false, x => parseInt(x.content ?? '0')),
    ReplicaAvailabilityZones: node.getList("ReplicaAvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    ReplicaOutpostArns: node.getList("ReplicaOutpostArns", "OutpostArn").map(x => x.content ?? ''),
  };
}

function ConfigureShard_Serialize(body: URLSearchParams, prefix: string, params: s.ConfigureShard) {
    body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    body.append(prefix+".NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+".PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if (params["PreferredOutpostArns"]) qsP.appendList(body, prefix+".PreferredOutpostArns", params["PreferredOutpostArns"], {"entryPrefix":".PreferredOutpostArn."})
}

function TimeRangeFilter_Serialize(body: URLSearchParams, prefix: string, params: s.TimeRangeFilter) {
    if ("StartTime" in params) body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
}

function Filter_Serialize(body: URLSearchParams, prefix: string, params: s.Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

function RegionalConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.RegionalConfiguration) {
    body.append(prefix+".ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+".ReplicationGroupRegion", (params["ReplicationGroupRegion"] ?? '').toString());
    if (params["ReshardingConfiguration"]) qsP.appendList(body, prefix+".ReshardingConfiguration", params["ReshardingConfiguration"], {"appender":ReshardingConfiguration_Serialize,"entryPrefix":".ReshardingConfiguration."})
}

function ReshardingConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.ReshardingConfiguration) {
    if ("NodeGroupId" in params) body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+".PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
}

function ParameterNameValue_Serialize(body: URLSearchParams, prefix: string, params: s.ParameterNameValue) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
}

function CustomerNodeEndpoint_Serialize(body: URLSearchParams, prefix: string, params: s.CustomerNodeEndpoint) {
    if ("Address" in params) body.append(prefix+".Address", (params["Address"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
}

function CacheSecurityGroup_Parse(node: xmlP.XmlNode): s.CacheSecurityGroup {
  return {
    ...node.strings({
      optional: {"OwnerId":true,"CacheSecurityGroupName":true,"Description":true,"ARN":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
  };
}

function EC2SecurityGroup_Parse(node: xmlP.XmlNode): s.EC2SecurityGroup {
  return node.strings({
    optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupOwnerId":true},
  });
}

function ProcessedUpdateAction_Parse(node: xmlP.XmlNode): s.ProcessedUpdateAction {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true},
    }),
    UpdateActionStatus: node.first("UpdateActionStatus", false, x => (x.content ?? '') as s.UpdateActionStatus),
  };
}

function UnprocessedUpdateAction_Parse(node: xmlP.XmlNode): s.UnprocessedUpdateAction {
  return node.strings({
    optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true,"ErrorType":true,"ErrorMessage":true},
  });
}

function ReplicationGroup_Parse(node: xmlP.XmlNode): s.ReplicationGroup {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"Description":true,"Status":true,"SnapshottingClusterId":true,"SnapshotWindow":true,"CacheNodeType":true,"KmsKeyId":true,"ARN":true},
    }),
    GlobalReplicationGroupInfo: node.first("GlobalReplicationGroupInfo", false, GlobalReplicationGroupInfo_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, ReplicationGroupPendingModifiedValues_Parse),
    MemberClusters: node.getList("MemberClusters", "ClusterId").map(x => x.content ?? ''),
    NodeGroups: node.getList("NodeGroups", "NodeGroup").map(NodeGroup_Parse),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as s.AutomaticFailoverStatus),
    MultiAZ: node.first("MultiAZ", false, x => (x.content ?? '') as s.MultiAZStatus),
    ConfigurationEndpoint: node.first("ConfigurationEndpoint", false, Endpoint_Parse),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    ClusterEnabled: node.first("ClusterEnabled", false, x => x.content === 'true'),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    AuthTokenLastModifiedDate: node.first("AuthTokenLastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
    MemberClustersOutpostArns: node.getList("MemberClustersOutpostArns", "ReplicationGroupOutpostArn").map(x => x.content ?? ''),
    UserGroupIds: node.getList("UserGroupIds", "member").map(x => x.content ?? ''),
  };
}

function GlobalReplicationGroupInfo_Parse(node: xmlP.XmlNode): s.GlobalReplicationGroupInfo {
  return node.strings({
    optional: {"GlobalReplicationGroupId":true,"GlobalReplicationGroupMemberRole":true},
  });
}

function ReplicationGroupPendingModifiedValues_Parse(node: xmlP.XmlNode): s.ReplicationGroupPendingModifiedValues {
  return {
    ...node.strings({
      optional: {"PrimaryClusterId":true},
    }),
    AutomaticFailoverStatus: node.first("AutomaticFailoverStatus", false, x => (x.content ?? '') as s.PendingAutomaticFailoverStatus),
    Resharding: node.first("Resharding", false, ReshardingStatus_Parse),
    AuthTokenStatus: node.first("AuthTokenStatus", false, x => (x.content ?? '') as s.AuthTokenUpdateStatus),
    UserGroups: node.first("UserGroups", false, UserGroupsUpdateStatus_Parse),
  };
}

function ReshardingStatus_Parse(node: xmlP.XmlNode): s.ReshardingStatus {
  return {
    SlotMigration: node.first("SlotMigration", false, SlotMigration_Parse),
  };
}

function SlotMigration_Parse(node: xmlP.XmlNode): s.SlotMigration {
  return {
    ProgressPercentage: node.first("ProgressPercentage", false, x => parseFloat(x.content ?? '0')),
  };
}

function UserGroupsUpdateStatus_Parse(node: xmlP.XmlNode): s.UserGroupsUpdateStatus {
  return {
    UserGroupIdsToAdd: node.getList("UserGroupIdsToAdd", "member").map(x => x.content ?? ''),
    UserGroupIdsToRemove: node.getList("UserGroupIdsToRemove", "member").map(x => x.content ?? ''),
  };
}

function NodeGroup_Parse(node: xmlP.XmlNode): s.NodeGroup {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true,"Status":true,"Slots":true},
    }),
    PrimaryEndpoint: node.first("PrimaryEndpoint", false, Endpoint_Parse),
    ReaderEndpoint: node.first("ReaderEndpoint", false, Endpoint_Parse),
    NodeGroupMembers: node.getList("NodeGroupMembers", "NodeGroupMember").map(NodeGroupMember_Parse),
  };
}

function Endpoint_Parse(node: xmlP.XmlNode): s.Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

function NodeGroupMember_Parse(node: xmlP.XmlNode): s.NodeGroupMember {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"CacheNodeId":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"CurrentRole":true},
    }),
    ReadEndpoint: node.first("ReadEndpoint", false, Endpoint_Parse),
  };
}

function Snapshot_Parse(node: xmlP.XmlNode): s.Snapshot {
  return {
    ...node.strings({
      optional: {"SnapshotName":true,"ReplicationGroupId":true,"ReplicationGroupDescription":true,"CacheClusterId":true,"SnapshotStatus":true,"SnapshotSource":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"PreferredMaintenanceWindow":true,"TopicArn":true,"CacheParameterGroupName":true,"CacheSubnetGroupName":true,"VpcId":true,"SnapshotWindow":true,"KmsKeyId":true,"ARN":true},
    }),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheClusterCreateTime: node.first("CacheClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    NumNodeGroups: node.first("NumNodeGroups", false, x => parseInt(x.content ?? '0')),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as s.AutomaticFailoverStatus),
    NodeSnapshots: node.getList("NodeSnapshots", "NodeSnapshot").map(NodeSnapshot_Parse),
  };
}

function NodeSnapshot_Parse(node: xmlP.XmlNode): s.NodeSnapshot {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"NodeGroupId":true,"CacheNodeId":true,"CacheSize":true},
    }),
    NodeGroupConfiguration: node.first("NodeGroupConfiguration", false, NodeGroupConfiguration_Parse),
    CacheNodeCreateTime: node.first("CacheNodeCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function CacheCluster_Parse(node: xmlP.XmlNode): s.CacheCluster {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"ClientDownloadLandingPage":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"CacheClusterStatus":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"PreferredMaintenanceWindow":true,"CacheSubnetGroupName":true,"ReplicationGroupId":true,"SnapshotWindow":true,"ARN":true},
    }),
    ConfigurationEndpoint: node.first("ConfigurationEndpoint", false, Endpoint_Parse),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheClusterCreateTime: node.first("CacheClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    NotificationConfiguration: node.first("NotificationConfiguration", false, NotificationConfiguration_Parse),
    CacheSecurityGroups: node.getList("CacheSecurityGroups", "CacheSecurityGroup").map(CacheSecurityGroupMembership_Parse),
    CacheParameterGroup: node.first("CacheParameterGroup", false, CacheParameterGroupStatus_Parse),
    CacheNodes: node.getList("CacheNodes", "CacheNode").map(CacheNode_Parse),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    SecurityGroups: node.getList("SecurityGroups", "member").map(SecurityGroupMembership_Parse),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    AuthTokenLastModifiedDate: node.first("AuthTokenLastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
  };
}

function PendingModifiedValues_Parse(node: xmlP.XmlNode): s.PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"EngineVersion":true,"CacheNodeType":true},
    }),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheNodeIdsToRemove: node.getList("CacheNodeIdsToRemove", "CacheNodeId").map(x => x.content ?? ''),
    AuthTokenStatus: node.first("AuthTokenStatus", false, x => (x.content ?? '') as s.AuthTokenUpdateStatus),
  };
}

function NotificationConfiguration_Parse(node: xmlP.XmlNode): s.NotificationConfiguration {
  return node.strings({
    optional: {"TopicArn":true,"TopicStatus":true},
  });
}

function CacheSecurityGroupMembership_Parse(node: xmlP.XmlNode): s.CacheSecurityGroupMembership {
  return node.strings({
    optional: {"CacheSecurityGroupName":true,"Status":true},
  });
}

function CacheParameterGroupStatus_Parse(node: xmlP.XmlNode): s.CacheParameterGroupStatus {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupName":true,"ParameterApplyStatus":true},
    }),
    CacheNodeIdsToReboot: node.getList("CacheNodeIdsToReboot", "CacheNodeId").map(x => x.content ?? ''),
  };
}

function CacheNode_Parse(node: xmlP.XmlNode): s.CacheNode {
  return {
    ...node.strings({
      optional: {"CacheNodeId":true,"CacheNodeStatus":true,"ParameterGroupStatus":true,"SourceCacheNodeId":true,"CustomerAvailabilityZone":true,"CustomerOutpostArn":true},
    }),
    CacheNodeCreateTime: node.first("CacheNodeCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
  };
}

function SecurityGroupMembership_Parse(node: xmlP.XmlNode): s.SecurityGroupMembership {
  return node.strings({
    optional: {"SecurityGroupId":true,"Status":true},
  });
}

function CacheParameterGroup_Parse(node: xmlP.XmlNode): s.CacheParameterGroup {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupName":true,"CacheParameterGroupFamily":true,"Description":true,"ARN":true},
    }),
    IsGlobal: node.first("IsGlobal", false, x => x.content === 'true'),
  };
}

function CacheSubnetGroup_Parse(node: xmlP.XmlNode): s.CacheSubnetGroup {
  return {
    ...node.strings({
      optional: {"CacheSubnetGroupName":true,"CacheSubnetGroupDescription":true,"VpcId":true,"ARN":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

function Subnet_Parse(node: xmlP.XmlNode): s.Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
    SubnetOutpost: node.first("SubnetOutpost", false, SubnetOutpost_Parse),
  };
}

function AvailabilityZone_Parse(node: xmlP.XmlNode): s.AvailabilityZone {
  return node.strings({
    optional: {"Name":true},
  });
}

function SubnetOutpost_Parse(node: xmlP.XmlNode): s.SubnetOutpost {
  return node.strings({
    optional: {"SubnetOutpostArn":true},
  });
}

function GlobalReplicationGroup_Parse(node: xmlP.XmlNode): s.GlobalReplicationGroup {
  return {
    ...node.strings({
      optional: {"GlobalReplicationGroupId":true,"GlobalReplicationGroupDescription":true,"Status":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"ARN":true},
    }),
    Members: node.getList("Members", "GlobalReplicationGroupMember").map(GlobalReplicationGroupMember_Parse),
    ClusterEnabled: node.first("ClusterEnabled", false, x => x.content === 'true'),
    GlobalNodeGroups: node.getList("GlobalNodeGroups", "GlobalNodeGroup").map(GlobalNodeGroup_Parse),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
  };
}

function GlobalReplicationGroupMember_Parse(node: xmlP.XmlNode): s.GlobalReplicationGroupMember {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"ReplicationGroupRegion":true,"Role":true,"Status":true},
    }),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as s.AutomaticFailoverStatus),
  };
}

function GlobalNodeGroup_Parse(node: xmlP.XmlNode): s.GlobalNodeGroup {
  return node.strings({
    optional: {"GlobalNodeGroupId":true,"Slots":true},
  });
}

function Authentication_Parse(node: xmlP.XmlNode): s.Authentication {
  return {
    Type: node.first("Type", false, x => (x.content ?? '') as s.AuthenticationType),
    PasswordCount: node.first("PasswordCount", false, x => parseInt(x.content ?? '0')),
  };
}

function UserGroupPendingChanges_Parse(node: xmlP.XmlNode): s.UserGroupPendingChanges {
  return {
    UserIdsToRemove: node.getList("UserIdsToRemove", "member").map(x => x.content ?? ''),
    UserIdsToAdd: node.getList("UserIdsToAdd", "member").map(x => x.content ?? ''),
  };
}

function CacheEngineVersion_Parse(node: xmlP.XmlNode): s.CacheEngineVersion {
  return node.strings({
    optional: {"Engine":true,"EngineVersion":true,"CacheParameterGroupFamily":true,"CacheEngineDescription":true,"CacheEngineVersionDescription":true},
  });
}

function Parameter_Parse(node: xmlP.XmlNode): s.Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ChangeType: node.first("ChangeType", false, x => (x.content ?? '') as s.ChangeType),
  };
}

function CacheNodeTypeSpecificParameter_Parse(node: xmlP.XmlNode): s.CacheNodeTypeSpecificParameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    CacheNodeTypeSpecificValues: node.getList("CacheNodeTypeSpecificValues", "CacheNodeTypeSpecificValue").map(CacheNodeTypeSpecificValue_Parse),
    ChangeType: node.first("ChangeType", false, x => (x.content ?? '') as s.ChangeType),
  };
}

function CacheNodeTypeSpecificValue_Parse(node: xmlP.XmlNode): s.CacheNodeTypeSpecificValue {
  return node.strings({
    optional: {"CacheNodeType":true,"Value":true},
  });
}

function EngineDefaults_Parse(node: xmlP.XmlNode): s.EngineDefaults {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
    CacheNodeTypeSpecificParameters: node.getList("CacheNodeTypeSpecificParameters", "CacheNodeTypeSpecificParameter").map(CacheNodeTypeSpecificParameter_Parse),
  };
}

function Event_Parse(node: xmlP.XmlNode): s.Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as s.SourceType),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ReservedCacheNode_Parse(node: xmlP.XmlNode): s.ReservedCacheNode {
  return {
    ...node.strings({
      optional: {"ReservedCacheNodeId":true,"ReservedCacheNodesOfferingId":true,"CacheNodeType":true,"ProductDescription":true,"OfferingType":true,"State":true,"ReservationARN":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    CacheNodeCount: node.first("CacheNodeCount", false, x => parseInt(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

function RecurringCharge_Parse(node: xmlP.XmlNode): s.RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

function ReservedCacheNodesOffering_Parse(node: xmlP.XmlNode): s.ReservedCacheNodesOffering {
  return {
    ...node.strings({
      optional: {"ReservedCacheNodesOfferingId":true,"CacheNodeType":true,"ProductDescription":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

function ServiceUpdate_Parse(node: xmlP.XmlNode): s.ServiceUpdate {
  return {
    ...node.strings({
      optional: {"ServiceUpdateName":true,"ServiceUpdateDescription":true,"Engine":true,"EngineVersion":true,"EstimatedUpdateTime":true},
    }),
    ServiceUpdateReleaseDate: node.first("ServiceUpdateReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateEndDate: node.first("ServiceUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateSeverity: node.first("ServiceUpdateSeverity", false, x => (x.content ?? '') as s.ServiceUpdateSeverity),
    ServiceUpdateRecommendedApplyByDate: node.first("ServiceUpdateRecommendedApplyByDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateStatus: node.first("ServiceUpdateStatus", false, x => (x.content ?? '') as s.ServiceUpdateStatus),
    ServiceUpdateType: node.first("ServiceUpdateType", false, x => (x.content ?? '') as s.ServiceUpdateType),
    AutoUpdateAfterRecommendedApplyByDate: node.first("AutoUpdateAfterRecommendedApplyByDate", false, x => x.content === 'true'),
  };
}

function UpdateAction_Parse(node: xmlP.XmlNode): s.UpdateAction {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true,"NodesUpdated":true,"EstimatedUpdateTime":true,"Engine":true},
    }),
    ServiceUpdateReleaseDate: node.first("ServiceUpdateReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateSeverity: node.first("ServiceUpdateSeverity", false, x => (x.content ?? '') as s.ServiceUpdateSeverity),
    ServiceUpdateStatus: node.first("ServiceUpdateStatus", false, x => (x.content ?? '') as s.ServiceUpdateStatus),
    ServiceUpdateRecommendedApplyByDate: node.first("ServiceUpdateRecommendedApplyByDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateType: node.first("ServiceUpdateType", false, x => (x.content ?? '') as s.ServiceUpdateType),
    UpdateActionAvailableDate: node.first("UpdateActionAvailableDate", false, x => xmlP.parseTimestamp(x.content)),
    UpdateActionStatus: node.first("UpdateActionStatus", false, x => (x.content ?? '') as s.UpdateActionStatus),
    UpdateActionStatusModifiedDate: node.first("UpdateActionStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    SlaMet: node.first("SlaMet", false, x => (x.content ?? '') as s.SlaMet),
    NodeGroupUpdateStatus: node.getList("NodeGroupUpdateStatus", "NodeGroupUpdateStatus").map(NodeGroupUpdateStatus_Parse),
    CacheNodeUpdateStatus: node.getList("CacheNodeUpdateStatus", "CacheNodeUpdateStatus").map(CacheNodeUpdateStatus_Parse),
  };
}

function NodeGroupUpdateStatus_Parse(node: xmlP.XmlNode): s.NodeGroupUpdateStatus {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true},
    }),
    NodeGroupMemberUpdateStatus: node.getList("NodeGroupMemberUpdateStatus", "NodeGroupMemberUpdateStatus").map(NodeGroupMemberUpdateStatus_Parse),
  };
}

function NodeGroupMemberUpdateStatus_Parse(node: xmlP.XmlNode): s.NodeGroupMemberUpdateStatus {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"CacheNodeId":true},
    }),
    NodeUpdateStatus: node.first("NodeUpdateStatus", false, x => (x.content ?? '') as s.NodeUpdateStatus),
    NodeDeletionDate: node.first("NodeDeletionDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStartDate: node.first("NodeUpdateStartDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateEndDate: node.first("NodeUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateInitiatedBy: node.first("NodeUpdateInitiatedBy", false, x => (x.content ?? '') as s.NodeUpdateInitiatedBy),
    NodeUpdateInitiatedDate: node.first("NodeUpdateInitiatedDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStatusModifiedDate: node.first("NodeUpdateStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function CacheNodeUpdateStatus_Parse(node: xmlP.XmlNode): s.CacheNodeUpdateStatus {
  return {
    ...node.strings({
      optional: {"CacheNodeId":true},
    }),
    NodeUpdateStatus: node.first("NodeUpdateStatus", false, x => (x.content ?? '') as s.NodeUpdateStatus),
    NodeDeletionDate: node.first("NodeDeletionDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStartDate: node.first("NodeUpdateStartDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateEndDate: node.first("NodeUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateInitiatedBy: node.first("NodeUpdateInitiatedBy", false, x => (x.content ?? '') as s.NodeUpdateInitiatedBy),
    NodeUpdateInitiatedDate: node.first("NodeUpdateInitiatedDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStatusModifiedDate: node.first("NodeUpdateStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}
