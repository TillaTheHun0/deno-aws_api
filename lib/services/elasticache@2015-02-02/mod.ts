// Autogenerated API client for: Amazon ElastiCache

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class ElastiCache {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElastiCache.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-02-02",
    "endpointPrefix": "elasticache",
    "protocol": "query",
    "serviceFullName": "Amazon ElastiCache",
    "serviceId": "ElastiCache",
    "signatureVersion": "v4",
    "uid": "elasticache-2015-02-02",
    "xmlNamespace": "http://elasticache.amazonaws.com/doc/2015-02-02/"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddTagsToResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async authorizeCacheSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeCacheSecurityGroupIngressMessage,
  ): Promise<AuthorizeCacheSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeCacheSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeCacheSecurityGroupIngressResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async batchApplyUpdateAction(
    {abortSignal, ...params}: RequestConfig & BatchApplyUpdateActionMessage,
  ): Promise<UpdateActionResultsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchApplyUpdateAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchApplyUpdateActionResult");
    return {
      ProcessedUpdateActions: xml.getList("ProcessedUpdateActions", "ProcessedUpdateAction").map(ProcessedUpdateAction_Parse),
      UnprocessedUpdateActions: xml.getList("UnprocessedUpdateActions", "UnprocessedUpdateAction").map(UnprocessedUpdateAction_Parse),
    };
  }

  async batchStopUpdateAction(
    {abortSignal, ...params}: RequestConfig & BatchStopUpdateActionMessage,
  ): Promise<UpdateActionResultsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStopUpdateAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BatchStopUpdateActionResult");
    return {
      ProcessedUpdateActions: xml.getList("ProcessedUpdateActions", "ProcessedUpdateAction").map(ProcessedUpdateAction_Parse),
      UnprocessedUpdateActions: xml.getList("UnprocessedUpdateActions", "UnprocessedUpdateAction").map(UnprocessedUpdateAction_Parse),
    };
  }

  async completeMigration(
    {abortSignal, ...params}: RequestConfig & CompleteMigrationMessage,
  ): Promise<CompleteMigrationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompleteMigration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CompleteMigrationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async copySnapshot(
    {abortSignal, ...params}: RequestConfig & CopySnapshotMessage,
  ): Promise<CopySnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceSnapshotName", (params["SourceSnapshotName"] ?? '').toString());
    body.append(prefix+"TargetSnapshotName", (params["TargetSnapshotName"] ?? '').toString());
    if ("TargetBucket" in params) body.append(prefix+"TargetBucket", (params["TargetBucket"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopySnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopySnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createCacheCluster(
    {abortSignal, ...params}: RequestConfig & CreateCacheClusterMessage,
  ): Promise<CreateCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("AZMode" in params) body.append(prefix+"AZMode", (params["AZMode"] ?? '').toString());
    if ("PreferredAvailabilityZone" in params) body.append(prefix+"PreferredAvailabilityZone", (params["PreferredAvailabilityZone"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+"PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if ("NumCacheNodes" in params) body.append(prefix+"NumCacheNodes", (params["NumCacheNodes"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if (params["SnapshotArns"]) qsP.appendList(body, prefix+"SnapshotArns", params["SnapshotArns"], {"entryPrefix":".SnapshotArn."})
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("OutpostMode" in params) body.append(prefix+"OutpostMode", (params["OutpostMode"] ?? '').toString());
    if ("PreferredOutpostArn" in params) body.append(prefix+"PreferredOutpostArn", (params["PreferredOutpostArn"] ?? '').toString());
    if (params["PreferredOutpostArns"]) qsP.appendList(body, prefix+"PreferredOutpostArns", params["PreferredOutpostArns"], {"entryPrefix":".PreferredOutpostArn."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async createCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateCacheParameterGroupMessage,
  ): Promise<CreateCacheParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheParameterGroupResult");
    return {
      CacheParameterGroup: xml.first("CacheParameterGroup", false, CacheParameterGroup_Parse),
    };
  }

  async createCacheSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateCacheSecurityGroupMessage,
  ): Promise<CreateCacheSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheSecurityGroupResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async createCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateCacheSubnetGroupMessage,
  ): Promise<CreateCacheSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    body.append(prefix+"CacheSubnetGroupDescription", (params["CacheSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCacheSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateCacheSubnetGroupResult");
    return {
      CacheSubnetGroup: xml.first("CacheSubnetGroup", false, CacheSubnetGroup_Parse),
    };
  }

  async createGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & CreateGlobalReplicationGroupMessage,
  ): Promise<CreateGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupIdSuffix", (params["GlobalReplicationGroupIdSuffix"] ?? '').toString());
    if ("GlobalReplicationGroupDescription" in params) body.append(prefix+"GlobalReplicationGroupDescription", (params["GlobalReplicationGroupDescription"] ?? '').toString());
    body.append(prefix+"PrimaryReplicationGroupId", (params["PrimaryReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async createReplicationGroup(
    {abortSignal, ...params}: RequestConfig & CreateReplicationGroupMessage,
  ): Promise<CreateReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupDescription", (params["ReplicationGroupDescription"] ?? '').toString());
    if ("GlobalReplicationGroupId" in params) body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    if ("PrimaryClusterId" in params) body.append(prefix+"PrimaryClusterId", (params["PrimaryClusterId"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    if ("MultiAZEnabled" in params) body.append(prefix+"MultiAZEnabled", (params["MultiAZEnabled"] ?? '').toString());
    if ("NumCacheClusters" in params) body.append(prefix+"NumCacheClusters", (params["NumCacheClusters"] ?? '').toString());
    if (params["PreferredCacheClusterAZs"]) qsP.appendList(body, prefix+"PreferredCacheClusterAZs", params["PreferredCacheClusterAZs"], {"entryPrefix":".AvailabilityZone."})
    if ("NumNodeGroups" in params) body.append(prefix+"NumNodeGroups", (params["NumNodeGroups"] ?? '').toString());
    if ("ReplicasPerNodeGroup" in params) body.append(prefix+"ReplicasPerNodeGroup", (params["ReplicasPerNodeGroup"] ?? '').toString());
    if (params["NodeGroupConfiguration"]) qsP.appendList(body, prefix+"NodeGroupConfiguration", params["NodeGroupConfiguration"], {"appender":NodeGroupConfiguration_Serialize,"entryPrefix":".NodeGroupConfiguration."})
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if (params["SnapshotArns"]) qsP.appendList(body, prefix+"SnapshotArns", params["SnapshotArns"], {"entryPrefix":".SnapshotArn."})
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("TransitEncryptionEnabled" in params) body.append(prefix+"TransitEncryptionEnabled", (params["TransitEncryptionEnabled"] ?? '').toString());
    if ("AtRestEncryptionEnabled" in params) body.append(prefix+"AtRestEncryptionEnabled", (params["AtRestEncryptionEnabled"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["UserGroupIds"]) qsP.appendList(body, prefix+"UserGroupIds", params["UserGroupIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotMessage,
  ): Promise<CreateSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & CreateUserMessage,
  ): Promise<User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    body.append(prefix+"UserName", (params["UserName"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["Passwords"]) qsP.appendList(body, prefix+"Passwords", params["Passwords"], {"entryPrefix":".member."})
    body.append(prefix+"AccessString", (params["AccessString"] ?? '').toString());
    if ("NoPasswordRequired" in params) body.append(prefix+"NoPasswordRequired", (params["NoPasswordRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUserResult");
    return User_Parse(xml);
  }

  async createUserGroup(
    {abortSignal, ...params}: RequestConfig & CreateUserGroupMessage,
  ): Promise<UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserIds", params["UserIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async decreaseNodeGroupsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & DecreaseNodeGroupsInGlobalReplicationGroupMessage,
  ): Promise<DecreaseNodeGroupsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    if (params["GlobalNodeGroupsToRemove"]) qsP.appendList(body, prefix+"GlobalNodeGroupsToRemove", params["GlobalNodeGroupsToRemove"], {"entryPrefix":".GlobalNodeGroupId."})
    if (params["GlobalNodeGroupsToRetain"]) qsP.appendList(body, prefix+"GlobalNodeGroupsToRetain", params["GlobalNodeGroupsToRetain"], {"entryPrefix":".GlobalNodeGroupId."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseNodeGroupsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DecreaseNodeGroupsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async decreaseReplicaCount(
    {abortSignal, ...params}: RequestConfig & DecreaseReplicaCountMessage,
  ): Promise<DecreaseReplicaCountResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("NewReplicaCount" in params) body.append(prefix+"NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["ReplicaConfiguration"]) qsP.appendList(body, prefix+"ReplicaConfiguration", params["ReplicaConfiguration"], {"appender":ConfigureShard_Serialize,"entryPrefix":".ConfigureShard."})
    if (params["ReplicasToRemove"]) qsP.appendList(body, prefix+"ReplicasToRemove", params["ReplicasToRemove"], {"entryPrefix":".member."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseReplicaCount",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DecreaseReplicaCountResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async deleteCacheCluster(
    {abortSignal, ...params}: RequestConfig & DeleteCacheClusterMessage,
  ): Promise<DeleteCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("FinalSnapshotIdentifier" in params) body.append(prefix+"FinalSnapshotIdentifier", (params["FinalSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async deleteCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteCacheParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheParameterGroup",
    });
  }

  async deleteCacheSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteCacheSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheSecurityGroup",
    });
  }

  async deleteCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteCacheSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCacheSubnetGroup",
    });
  }

  async deleteGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & DeleteGlobalReplicationGroupMessage,
  ): Promise<DeleteGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"RetainPrimaryReplicationGroup", (params["RetainPrimaryReplicationGroup"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async deleteReplicationGroup(
    {abortSignal, ...params}: RequestConfig & DeleteReplicationGroupMessage,
  ): Promise<DeleteReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("RetainPrimaryCluster" in params) body.append(prefix+"RetainPrimaryCluster", (params["RetainPrimaryCluster"] ?? '').toString());
    if ("FinalSnapshotIdentifier" in params) body.append(prefix+"FinalSnapshotIdentifier", (params["FinalSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async deleteSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteSnapshotMessage,
  ): Promise<DeleteSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteSnapshotResult");
    return {
      Snapshot: xml.first("Snapshot", false, Snapshot_Parse),
    };
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & DeleteUserMessage,
  ): Promise<User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteUserResult");
    return User_Parse(xml);
  }

  async deleteUserGroup(
    {abortSignal, ...params}: RequestConfig & DeleteUserGroupMessage,
  ): Promise<UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async describeCacheClusters(
    {abortSignal, ...params}: RequestConfig & DescribeCacheClustersMessage = {},
  ): Promise<CacheClusterMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("ShowCacheNodeInfo" in params) body.append(prefix+"ShowCacheNodeInfo", (params["ShowCacheNodeInfo"] ?? '').toString());
    if ("ShowCacheClustersNotInReplicationGroups" in params) body.append(prefix+"ShowCacheClustersNotInReplicationGroups", (params["ShowCacheClustersNotInReplicationGroups"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheClusters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheClusters: xml.getList("CacheClusters", "CacheCluster").map(CacheCluster_Parse),
    };
  }

  async describeCacheEngineVersions(
    {abortSignal, ...params}: RequestConfig & DescribeCacheEngineVersionsMessage = {},
  ): Promise<CacheEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("CacheParameterGroupFamily" in params) body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheEngineVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheEngineVersions: xml.getList("CacheEngineVersions", "CacheEngineVersion").map(CacheEngineVersion_Parse),
    };
  }

  async describeCacheParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeCacheParameterGroupsMessage = {},
  ): Promise<CacheParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheParameterGroups: xml.getList("CacheParameterGroups", "CacheParameterGroup").map(CacheParameterGroup_Parse),
    };
  }

  async describeCacheParameters(
    {abortSignal, ...params}: RequestConfig & DescribeCacheParametersMessage,
  ): Promise<CacheParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
      CacheNodeTypeSpecificParameters: xml.getList("CacheNodeTypeSpecificParameters", "CacheNodeTypeSpecificParameter").map(CacheNodeTypeSpecificParameter_Parse),
    };
  }

  async describeCacheSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeCacheSecurityGroupsMessage = {},
  ): Promise<CacheSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheSecurityGroupName" in params) body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheSecurityGroups: xml.getList("CacheSecurityGroups", "CacheSecurityGroup").map(CacheSecurityGroup_Parse),
    };
  }

  async describeCacheSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeCacheSubnetGroupsMessage = {},
  ): Promise<CacheSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheSubnetGroupName" in params) body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCacheSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCacheSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      CacheSubnetGroups: xml.getList("CacheSubnetGroups", "CacheSubnetGroup").map(CacheSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultParameters(
    {abortSignal, ...params}: RequestConfig & DescribeEngineDefaultParametersMessage,
  ): Promise<DescribeEngineDefaultParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupFamily", (params["CacheParameterGroupFamily"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEngineDefaultParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeGlobalReplicationGroups(
    {abortSignal, ...params}: RequestConfig & DescribeGlobalReplicationGroupsMessage = {},
  ): Promise<DescribeGlobalReplicationGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GlobalReplicationGroupId" in params) body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("ShowMemberInfo" in params) body.append(prefix+"ShowMemberInfo", (params["ShowMemberInfo"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalReplicationGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeGlobalReplicationGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      GlobalReplicationGroups: xml.getList("GlobalReplicationGroups", "GlobalReplicationGroup").map(GlobalReplicationGroup_Parse),
    };
  }

  async describeReplicationGroups(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationGroupsMessage = {},
  ): Promise<ReplicationGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReplicationGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReplicationGroups: xml.getList("ReplicationGroups", "ReplicationGroup").map(ReplicationGroup_Parse),
    };
  }

  async describeReservedCacheNodes(
    {abortSignal, ...params}: RequestConfig & DescribeReservedCacheNodesMessage = {},
  ): Promise<ReservedCacheNodeMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedCacheNodeId" in params) body.append(prefix+"ReservedCacheNodeId", (params["ReservedCacheNodeId"] ?? '').toString());
    if ("ReservedCacheNodesOfferingId" in params) body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedCacheNodes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedCacheNodesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedCacheNodes: xml.getList("ReservedCacheNodes", "ReservedCacheNode").map(ReservedCacheNode_Parse),
    };
  }

  async describeReservedCacheNodesOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedCacheNodesOfferingsMessage = {},
  ): Promise<ReservedCacheNodesOfferingMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedCacheNodesOfferingId" in params) body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedCacheNodesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedCacheNodesOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedCacheNodesOfferings: xml.getList("ReservedCacheNodesOfferings", "ReservedCacheNodesOffering").map(ReservedCacheNodesOffering_Parse),
    };
  }

  async describeServiceUpdates(
    {abortSignal, ...params}: RequestConfig & DescribeServiceUpdatesMessage = {},
  ): Promise<ServiceUpdatesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ServiceUpdateName" in params) body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    if (params["ServiceUpdateStatus"]) qsP.appendList(body, prefix+"ServiceUpdateStatus", params["ServiceUpdateStatus"], {"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceUpdates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeServiceUpdatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ServiceUpdates: xml.getList("ServiceUpdates", "ServiceUpdate").map(ServiceUpdate_Parse),
    };
  }

  async describeSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotsMessage = {},
  ): Promise<DescribeSnapshotsListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("SnapshotName" in params) body.append(prefix+"SnapshotName", (params["SnapshotName"] ?? '').toString());
    if ("SnapshotSource" in params) body.append(prefix+"SnapshotSource", (params["SnapshotSource"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("ShowNodeGroupConfig" in params) body.append(prefix+"ShowNodeGroupConfig", (params["ShowNodeGroupConfig"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Snapshots: xml.getList("Snapshots", "Snapshot").map(Snapshot_Parse),
    };
  }

  async describeUpdateActions(
    {abortSignal, ...params}: RequestConfig & DescribeUpdateActionsMessage = {},
  ): Promise<UpdateActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ServiceUpdateName" in params) body.append(prefix+"ServiceUpdateName", (params["ServiceUpdateName"] ?? '').toString());
    if (params["ReplicationGroupIds"]) qsP.appendList(body, prefix+"ReplicationGroupIds", params["ReplicationGroupIds"], {"entryPrefix":".member."})
    if (params["CacheClusterIds"]) qsP.appendList(body, prefix+"CacheClusterIds", params["CacheClusterIds"], {"entryPrefix":".member."})
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if (params["ServiceUpdateStatus"]) qsP.appendList(body, prefix+"ServiceUpdateStatus", params["ServiceUpdateStatus"], {"entryPrefix":".member."})
    if (params["ServiceUpdateTimeRange"] != null) TimeRangeFilter_Serialize(body, prefix+"ServiceUpdateTimeRange", params["ServiceUpdateTimeRange"]);
    if (params["UpdateActionStatus"]) qsP.appendList(body, prefix+"UpdateActionStatus", params["UpdateActionStatus"], {"entryPrefix":".member."})
    if ("ShowNodeLevelUpdateStatus" in params) body.append(prefix+"ShowNodeLevelUpdateStatus", (params["ShowNodeLevelUpdateStatus"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUpdateActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUpdateActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UpdateActions: xml.getList("UpdateActions", "UpdateAction").map(UpdateAction_Parse),
    };
  }

  async describeUserGroups(
    {abortSignal, ...params}: RequestConfig & DescribeUserGroupsMessage = {},
  ): Promise<DescribeUserGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("UserGroupId" in params) body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUserGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      UserGroups: xml.getList("UserGroups", "member").map(UserGroup_Parse),
    };
  }

  async describeUsers(
    {abortSignal, ...params}: RequestConfig & DescribeUsersMessage = {},
  ): Promise<DescribeUsersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeUsersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Users: xml.getList("Users", "member").map(User_Parse),
    };
  }

  async disassociateGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & DisassociateGlobalReplicationGroupMessage,
  ): Promise<DisassociateGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ReplicationGroupRegion", (params["ReplicationGroupRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DisassociateGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async failoverGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & FailoverGlobalReplicationGroupMessage,
  ): Promise<FailoverGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"PrimaryRegion", (params["PrimaryRegion"] ?? '').toString());
    body.append(prefix+"PrimaryReplicationGroupId", (params["PrimaryReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "FailoverGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "FailoverGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async increaseNodeGroupsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & IncreaseNodeGroupsInGlobalReplicationGroupMessage,
  ): Promise<IncreaseNodeGroupsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    if (params["RegionalConfigurations"]) qsP.appendList(body, prefix+"RegionalConfigurations", params["RegionalConfigurations"], {"appender":RegionalConfiguration_Serialize,"entryPrefix":".RegionalConfiguration."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseNodeGroupsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IncreaseNodeGroupsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async increaseReplicaCount(
    {abortSignal, ...params}: RequestConfig & IncreaseReplicaCountMessage,
  ): Promise<IncreaseReplicaCountResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("NewReplicaCount" in params) body.append(prefix+"NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["ReplicaConfiguration"]) qsP.appendList(body, prefix+"ReplicaConfiguration", params["ReplicaConfiguration"], {"appender":ConfigureShard_Serialize,"entryPrefix":".ConfigureShard."})
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseReplicaCount",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IncreaseReplicaCountResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async listAllowedNodeTypeModifications(
    {abortSignal, ...params}: RequestConfig & ListAllowedNodeTypeModificationsMessage = {},
  ): Promise<AllowedNodeTypeModificationsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CacheClusterId" in params) body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("ReplicationGroupId" in params) body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAllowedNodeTypeModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAllowedNodeTypeModificationsResult");
    return {
      ScaleUpModifications: xml.getList("ScaleUpModifications", "member").map(x => x.content ?? ''),
      ScaleDownModifications: xml.getList("ScaleDownModifications", "member").map(x => x.content ?? ''),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyCacheCluster(
    {abortSignal, ...params}: RequestConfig & ModifyCacheClusterMessage,
  ): Promise<ModifyCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if ("NumCacheNodes" in params) body.append(prefix+"NumCacheNodes", (params["NumCacheNodes"] ?? '').toString());
    if (params["CacheNodeIdsToRemove"]) qsP.appendList(body, prefix+"CacheNodeIdsToRemove", params["CacheNodeIdsToRemove"], {"entryPrefix":".CacheNodeId."})
    if ("AZMode" in params) body.append(prefix+"AZMode", (params["AZMode"] ?? '').toString());
    if (params["NewAvailabilityZones"]) qsP.appendList(body, prefix+"NewAvailabilityZones", params["NewAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("NotificationTopicStatus" in params) body.append(prefix+"NotificationTopicStatus", (params["NotificationTopicStatus"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("AuthTokenUpdateStrategy" in params) body.append(prefix+"AuthTokenUpdateStrategy", (params["AuthTokenUpdateStrategy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async modifyCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyCacheParameterGroupMessage,
  ): Promise<CacheParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if (params["ParameterNameValues"]) qsP.appendList(body, prefix+"ParameterNameValues", params["ParameterNameValues"], {"appender":ParameterNameValue_Serialize,"entryPrefix":".ParameterNameValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheParameterGroupResult");
    return xml.strings({
      optional: {"CacheParameterGroupName":true},
    });
  }

  async modifyCacheSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyCacheSubnetGroupMessage,
  ): Promise<ModifyCacheSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSubnetGroupName", (params["CacheSubnetGroupName"] ?? '').toString());
    if ("CacheSubnetGroupDescription" in params) body.append(prefix+"CacheSubnetGroupDescription", (params["CacheSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCacheSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyCacheSubnetGroupResult");
    return {
      CacheSubnetGroup: xml.first("CacheSubnetGroup", false, CacheSubnetGroup_Parse),
    };
  }

  async modifyGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & ModifyGlobalReplicationGroupMessage,
  ): Promise<ModifyGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("GlobalReplicationGroupDescription" in params) body.append(prefix+"GlobalReplicationGroupDescription", (params["GlobalReplicationGroupDescription"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async modifyReplicationGroup(
    {abortSignal, ...params}: RequestConfig & ModifyReplicationGroupMessage,
  ): Promise<ModifyReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if ("ReplicationGroupDescription" in params) body.append(prefix+"ReplicationGroupDescription", (params["ReplicationGroupDescription"] ?? '').toString());
    if ("PrimaryClusterId" in params) body.append(prefix+"PrimaryClusterId", (params["PrimaryClusterId"] ?? '').toString());
    if ("SnapshottingClusterId" in params) body.append(prefix+"SnapshottingClusterId", (params["SnapshottingClusterId"] ?? '').toString());
    if ("AutomaticFailoverEnabled" in params) body.append(prefix+"AutomaticFailoverEnabled", (params["AutomaticFailoverEnabled"] ?? '').toString());
    if ("MultiAZEnabled" in params) body.append(prefix+"MultiAZEnabled", (params["MultiAZEnabled"] ?? '').toString());
    if ("NodeGroupId" in params) body.append(prefix+"NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if (params["CacheSecurityGroupNames"]) qsP.appendList(body, prefix+"CacheSecurityGroupNames", params["CacheSecurityGroupNames"], {"entryPrefix":".CacheSecurityGroupName."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupIds", params["SecurityGroupIds"], {"entryPrefix":".SecurityGroupId."})
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("NotificationTopicArn" in params) body.append(prefix+"NotificationTopicArn", (params["NotificationTopicArn"] ?? '').toString());
    if ("CacheParameterGroupName" in params) body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("NotificationTopicStatus" in params) body.append(prefix+"NotificationTopicStatus", (params["NotificationTopicStatus"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("SnapshotRetentionLimit" in params) body.append(prefix+"SnapshotRetentionLimit", (params["SnapshotRetentionLimit"] ?? '').toString());
    if ("SnapshotWindow" in params) body.append(prefix+"SnapshotWindow", (params["SnapshotWindow"] ?? '').toString());
    if ("CacheNodeType" in params) body.append(prefix+"CacheNodeType", (params["CacheNodeType"] ?? '').toString());
    if ("AuthToken" in params) body.append(prefix+"AuthToken", (params["AuthToken"] ?? '').toString());
    if ("AuthTokenUpdateStrategy" in params) body.append(prefix+"AuthTokenUpdateStrategy", (params["AuthTokenUpdateStrategy"] ?? '').toString());
    if (params["UserGroupIdsToAdd"]) qsP.appendList(body, prefix+"UserGroupIdsToAdd", params["UserGroupIdsToAdd"], {"entryPrefix":".member."})
    if (params["UserGroupIdsToRemove"]) qsP.appendList(body, prefix+"UserGroupIdsToRemove", params["UserGroupIdsToRemove"], {"entryPrefix":".member."})
    if ("RemoveUserGroups" in params) body.append(prefix+"RemoveUserGroups", (params["RemoveUserGroups"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyReplicationGroupResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async modifyReplicationGroupShardConfiguration(
    {abortSignal, ...params}: RequestConfig & ModifyReplicationGroupShardConfigurationMessage,
  ): Promise<ModifyReplicationGroupShardConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupCount", (params["NodeGroupCount"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if (params["ReshardingConfiguration"]) qsP.appendList(body, prefix+"ReshardingConfiguration", params["ReshardingConfiguration"], {"appender":ReshardingConfiguration_Serialize,"entryPrefix":".ReshardingConfiguration."})
    if (params["NodeGroupsToRemove"]) qsP.appendList(body, prefix+"NodeGroupsToRemove", params["NodeGroupsToRemove"], {"entryPrefix":".NodeGroupToRemove."})
    if (params["NodeGroupsToRetain"]) qsP.appendList(body, prefix+"NodeGroupsToRetain", params["NodeGroupsToRetain"], {"entryPrefix":".NodeGroupToRetain."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationGroupShardConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyReplicationGroupShardConfigurationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async modifyUser(
    {abortSignal, ...params}: RequestConfig & ModifyUserMessage,
  ): Promise<User> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserId", (params["UserId"] ?? '').toString());
    if ("AccessString" in params) body.append(prefix+"AccessString", (params["AccessString"] ?? '').toString());
    if ("AppendAccessString" in params) body.append(prefix+"AppendAccessString", (params["AppendAccessString"] ?? '').toString());
    if (params["Passwords"]) qsP.appendList(body, prefix+"Passwords", params["Passwords"], {"entryPrefix":".member."})
    if ("NoPasswordRequired" in params) body.append(prefix+"NoPasswordRequired", (params["NoPasswordRequired"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUser",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUserResult");
    return User_Parse(xml);
  }

  async modifyUserGroup(
    {abortSignal, ...params}: RequestConfig & ModifyUserGroupMessage,
  ): Promise<UserGroup> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"UserGroupId", (params["UserGroupId"] ?? '').toString());
    if (params["UserIdsToAdd"]) qsP.appendList(body, prefix+"UserIdsToAdd", params["UserIdsToAdd"], {"entryPrefix":".member."})
    if (params["UserIdsToRemove"]) qsP.appendList(body, prefix+"UserIdsToRemove", params["UserIdsToRemove"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyUserGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyUserGroupResult");
    return UserGroup_Parse(xml);
  }

  async purchaseReservedCacheNodesOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedCacheNodesOfferingMessage,
  ): Promise<PurchaseReservedCacheNodesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedCacheNodesOfferingId", (params["ReservedCacheNodesOfferingId"] ?? '').toString());
    if ("ReservedCacheNodeId" in params) body.append(prefix+"ReservedCacheNodeId", (params["ReservedCacheNodeId"] ?? '').toString());
    if ("CacheNodeCount" in params) body.append(prefix+"CacheNodeCount", (params["CacheNodeCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedCacheNodesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedCacheNodesOfferingResult");
    return {
      ReservedCacheNode: xml.first("ReservedCacheNode", false, ReservedCacheNode_Parse),
    };
  }

  async rebalanceSlotsInGlobalReplicationGroup(
    {abortSignal, ...params}: RequestConfig & RebalanceSlotsInGlobalReplicationGroupMessage,
  ): Promise<RebalanceSlotsInGlobalReplicationGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GlobalReplicationGroupId", (params["GlobalReplicationGroupId"] ?? '').toString());
    body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebalanceSlotsInGlobalReplicationGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebalanceSlotsInGlobalReplicationGroupResult");
    return {
      GlobalReplicationGroup: xml.first("GlobalReplicationGroup", false, GlobalReplicationGroup_Parse),
    };
  }

  async rebootCacheCluster(
    {abortSignal, ...params}: RequestConfig & RebootCacheClusterMessage,
  ): Promise<RebootCacheClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheClusterId", (params["CacheClusterId"] ?? '').toString());
    if (params["CacheNodeIdsToReboot"]) qsP.appendList(body, prefix+"CacheNodeIdsToReboot", params["CacheNodeIdsToReboot"], {"entryPrefix":".CacheNodeId."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootCacheCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootCacheClusterResult");
    return {
      CacheCluster: xml.first("CacheCluster", false, CacheCluster_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveTagsFromResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async resetCacheParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetCacheParameterGroupMessage,
  ): Promise<CacheParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheParameterGroupName", (params["CacheParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["ParameterNameValues"]) qsP.appendList(body, prefix+"ParameterNameValues", params["ParameterNameValues"], {"appender":ParameterNameValue_Serialize,"entryPrefix":".ParameterNameValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetCacheParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetCacheParameterGroupResult");
    return xml.strings({
      optional: {"CacheParameterGroupName":true},
    });
  }

  async revokeCacheSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & RevokeCacheSecurityGroupIngressMessage,
  ): Promise<RevokeCacheSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CacheSecurityGroupName", (params["CacheSecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeCacheSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeCacheSecurityGroupIngressResult");
    return {
      CacheSecurityGroup: xml.first("CacheSecurityGroup", false, CacheSecurityGroup_Parse),
    };
  }

  async startMigration(
    {abortSignal, ...params}: RequestConfig & StartMigrationMessage,
  ): Promise<StartMigrationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    if (params["CustomerNodeEndpointList"]) qsP.appendList(body, prefix+"CustomerNodeEndpointList", params["CustomerNodeEndpointList"], {"appender":CustomerNodeEndpoint_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMigration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StartMigrationResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  async testFailover(
    {abortSignal, ...params}: RequestConfig & TestFailoverMessage,
  ): Promise<TestFailoverResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+"NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestFailover",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TestFailoverResult");
    return {
      ReplicationGroup: xml.first("ReplicationGroup", false, ReplicationGroup_Parse),
    };
  }

  // Resource State Waiters

  /**
   * Wait until ElastiCache cluster is available.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForCacheClusterAvailable(
    params: RequestConfig & DescribeCacheClustersMessage,
  ): Promise<CacheClusterMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CacheClusterAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCacheClusters(params);
      const field = resp?.CacheClusters?.flatMap(x => x?.CacheClusterStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
      if (field?.some(x => x === "restore-failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache cluster is deleted.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForCacheClusterDeleted(
    params: RequestConfig & DescribeCacheClustersMessage,
  ): Promise<Error | CacheClusterMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CacheClusterDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeCacheClusters(params);
        const field = resp?.CacheClusters?.flatMap(x => x?.CacheClusterStatus);
        if (field?.every(x => x === "deleted")) return resp;
        if (field?.some(x => x === "available")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
        if (field?.some(x => x === "modifying")) throw new Error(errMessage);
        if (field?.some(x => x === "restore-failed")) throw new Error(errMessage);
        if (field?.some(x => x === "snapshotting")) throw new Error(errMessage);
      } catch (err) {
        if (["CacheClusterNotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache replication group is available.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForReplicationGroupAvailable(
    params: RequestConfig & DescribeReplicationGroupsMessage,
  ): Promise<ReplicationGroupMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationGroupAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeReplicationGroups(params);
      const field = resp?.ReplicationGroups?.flatMap(x => x?.Status);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until ElastiCache replication group is deleted.
   * Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time).
   */
  async waitForReplicationGroupDeleted(
    params: RequestConfig & DescribeReplicationGroupsMessage,
  ): Promise<Error | ReplicationGroupMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationGroupDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeReplicationGroups(params);
        const field = resp?.ReplicationGroups?.flatMap(x => x?.Status);
        if (field?.every(x => x === "deleted")) return resp;
        if (field?.some(x => x === "available")) throw new Error(errMessage);
      } catch (err) {
        if (["ReplicationGroupNotFoundFault"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsToResourceMessage {
  ResourceName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface AuthorizeCacheSecurityGroupIngressMessage {
  CacheSecurityGroupName: string;
  EC2SecurityGroupName: string;
  EC2SecurityGroupOwnerId: string;
}

// refs: 1 - tags: named, input
export interface BatchApplyUpdateActionMessage {
  ReplicationGroupIds?: string[] | null;
  CacheClusterIds?: string[] | null;
  ServiceUpdateName: string;
}

// refs: 1 - tags: named, input
export interface BatchStopUpdateActionMessage {
  ReplicationGroupIds?: string[] | null;
  CacheClusterIds?: string[] | null;
  ServiceUpdateName: string;
}

// refs: 1 - tags: named, input
export interface CompleteMigrationMessage {
  ReplicationGroupId: string;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CopySnapshotMessage {
  SourceSnapshotName: string;
  TargetSnapshotName: string;
  TargetBucket?: string | null;
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateCacheClusterMessage {
  CacheClusterId: string;
  ReplicationGroupId?: string | null;
  AZMode?: AZMode | null;
  PreferredAvailabilityZone?: string | null;
  PreferredAvailabilityZones?: string[] | null;
  NumCacheNodes?: number | null;
  CacheNodeType?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  CacheParameterGroupName?: string | null;
  CacheSubnetGroupName?: string | null;
  CacheSecurityGroupNames?: string[] | null;
  SecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  SnapshotArns?: string[] | null;
  SnapshotName?: string | null;
  PreferredMaintenanceWindow?: string | null;
  Port?: number | null;
  NotificationTopicArn?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  AuthToken?: string | null;
  OutpostMode?: OutpostMode | null;
  PreferredOutpostArn?: string | null;
  PreferredOutpostArns?: string[] | null;
}

// refs: 1 - tags: named, input
export interface CreateCacheParameterGroupMessage {
  CacheParameterGroupName: string;
  CacheParameterGroupFamily: string;
  Description: string;
}

// refs: 1 - tags: named, input
export interface CreateCacheSecurityGroupMessage {
  CacheSecurityGroupName: string;
  Description: string;
}

// refs: 1 - tags: named, input
export interface CreateCacheSubnetGroupMessage {
  CacheSubnetGroupName: string;
  CacheSubnetGroupDescription: string;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface CreateGlobalReplicationGroupMessage {
  GlobalReplicationGroupIdSuffix: string;
  GlobalReplicationGroupDescription?: string | null;
  PrimaryReplicationGroupId: string;
}

// refs: 1 - tags: named, input
export interface CreateReplicationGroupMessage {
  ReplicationGroupId: string;
  ReplicationGroupDescription: string;
  GlobalReplicationGroupId?: string | null;
  PrimaryClusterId?: string | null;
  AutomaticFailoverEnabled?: boolean | null;
  MultiAZEnabled?: boolean | null;
  NumCacheClusters?: number | null;
  PreferredCacheClusterAZs?: string[] | null;
  NumNodeGroups?: number | null;
  ReplicasPerNodeGroup?: number | null;
  NodeGroupConfiguration?: NodeGroupConfiguration[] | null;
  CacheNodeType?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  CacheParameterGroupName?: string | null;
  CacheSubnetGroupName?: string | null;
  CacheSecurityGroupNames?: string[] | null;
  SecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  SnapshotArns?: string[] | null;
  SnapshotName?: string | null;
  PreferredMaintenanceWindow?: string | null;
  Port?: number | null;
  NotificationTopicArn?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  AuthToken?: string | null;
  TransitEncryptionEnabled?: boolean | null;
  AtRestEncryptionEnabled?: boolean | null;
  KmsKeyId?: string | null;
  UserGroupIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotMessage {
  ReplicationGroupId?: string | null;
  CacheClusterId?: string | null;
  SnapshotName: string;
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateUserMessage {
  UserId: string;
  UserName: string;
  Engine: string;
  Passwords?: string[] | null;
  AccessString: string;
  NoPasswordRequired?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateUserGroupMessage {
  UserGroupId: string;
  Engine: string;
  UserIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DecreaseNodeGroupsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  NodeGroupCount: number;
  GlobalNodeGroupsToRemove?: string[] | null;
  GlobalNodeGroupsToRetain?: string[] | null;
  ApplyImmediately: boolean;
}

// refs: 1 - tags: named, input
export interface DecreaseReplicaCountMessage {
  ReplicationGroupId: string;
  NewReplicaCount?: number | null;
  ReplicaConfiguration?: ConfigureShard[] | null;
  ReplicasToRemove?: string[] | null;
  ApplyImmediately: boolean;
}

// refs: 1 - tags: named, input
export interface DeleteCacheClusterMessage {
  CacheClusterId: string;
  FinalSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteCacheParameterGroupMessage {
  CacheParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCacheSecurityGroupMessage {
  CacheSecurityGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCacheSubnetGroupMessage {
  CacheSubnetGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  RetainPrimaryReplicationGroup: boolean;
}

// refs: 1 - tags: named, input
export interface DeleteReplicationGroupMessage {
  ReplicationGroupId: string;
  RetainPrimaryCluster?: boolean | null;
  FinalSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteSnapshotMessage {
  SnapshotName: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserMessage {
  UserId: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserGroupMessage {
  UserGroupId: string;
}

// refs: 1 - tags: named, input
export interface DescribeCacheClustersMessage {
  CacheClusterId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  ShowCacheNodeInfo?: boolean | null;
  ShowCacheClustersNotInReplicationGroups?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeCacheEngineVersionsMessage {
  Engine?: string | null;
  EngineVersion?: string | null;
  CacheParameterGroupFamily?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  DefaultOnly?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeCacheParameterGroupsMessage {
  CacheParameterGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCacheParametersMessage {
  CacheParameterGroupName: string;
  Source?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCacheSecurityGroupsMessage {
  CacheSecurityGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCacheSubnetGroupsMessage {
  CacheSubnetGroupName?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEngineDefaultParametersMessage {
  CacheParameterGroupFamily: string;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeGlobalReplicationGroupsMessage {
  GlobalReplicationGroupId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  ShowMemberInfo?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationGroupsMessage {
  ReplicationGroupId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedCacheNodesMessage {
  ReservedCacheNodeId?: string | null;
  ReservedCacheNodesOfferingId?: string | null;
  CacheNodeType?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedCacheNodesOfferingsMessage {
  ReservedCacheNodesOfferingId?: string | null;
  CacheNodeType?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeServiceUpdatesMessage {
  ServiceUpdateName?: string | null;
  ServiceUpdateStatus?: ServiceUpdateStatus[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotsMessage {
  ReplicationGroupId?: string | null;
  CacheClusterId?: string | null;
  SnapshotName?: string | null;
  SnapshotSource?: string | null;
  Marker?: string | null;
  MaxRecords?: number | null;
  ShowNodeGroupConfig?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeUpdateActionsMessage {
  ServiceUpdateName?: string | null;
  ReplicationGroupIds?: string[] | null;
  CacheClusterIds?: string[] | null;
  Engine?: string | null;
  ServiceUpdateStatus?: ServiceUpdateStatus[] | null;
  ServiceUpdateTimeRange?: TimeRangeFilter | null;
  UpdateActionStatus?: UpdateActionStatus[] | null;
  ShowNodeLevelUpdateStatus?: boolean | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeUserGroupsMessage {
  UserGroupId?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeUsersMessage {
  Engine?: string | null;
  UserId?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DisassociateGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  ReplicationGroupId: string;
  ReplicationGroupRegion: string;
}

// refs: 1 - tags: named, input
export interface FailoverGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  PrimaryRegion: string;
  PrimaryReplicationGroupId: string;
}

// refs: 1 - tags: named, input
export interface IncreaseNodeGroupsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  NodeGroupCount: number;
  RegionalConfigurations?: RegionalConfiguration[] | null;
  ApplyImmediately: boolean;
}

// refs: 1 - tags: named, input
export interface IncreaseReplicaCountMessage {
  ReplicationGroupId: string;
  NewReplicaCount?: number | null;
  ReplicaConfiguration?: ConfigureShard[] | null;
  ApplyImmediately: boolean;
}

// refs: 1 - tags: named, input
export interface ListAllowedNodeTypeModificationsMessage {
  CacheClusterId?: string | null;
  ReplicationGroupId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceMessage {
  ResourceName: string;
}

// refs: 1 - tags: named, input
export interface ModifyCacheClusterMessage {
  CacheClusterId: string;
  NumCacheNodes?: number | null;
  CacheNodeIdsToRemove?: string[] | null;
  AZMode?: AZMode | null;
  NewAvailabilityZones?: string[] | null;
  CacheSecurityGroupNames?: string[] | null;
  SecurityGroupIds?: string[] | null;
  PreferredMaintenanceWindow?: string | null;
  NotificationTopicArn?: string | null;
  CacheParameterGroupName?: string | null;
  NotificationTopicStatus?: string | null;
  ApplyImmediately?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  CacheNodeType?: string | null;
  AuthToken?: string | null;
  AuthTokenUpdateStrategy?: AuthTokenUpdateStrategyType | null;
}

// refs: 1 - tags: named, input
export interface ModifyCacheParameterGroupMessage {
  CacheParameterGroupName: string;
  ParameterNameValues: ParameterNameValue[];
}

// refs: 1 - tags: named, input
export interface ModifyCacheSubnetGroupMessage {
  CacheSubnetGroupName: string;
  CacheSubnetGroupDescription?: string | null;
  SubnetIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  ApplyImmediately: boolean;
  CacheNodeType?: string | null;
  EngineVersion?: string | null;
  GlobalReplicationGroupDescription?: string | null;
  AutomaticFailoverEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyReplicationGroupMessage {
  ReplicationGroupId: string;
  ReplicationGroupDescription?: string | null;
  PrimaryClusterId?: string | null;
  SnapshottingClusterId?: string | null;
  AutomaticFailoverEnabled?: boolean | null;
  MultiAZEnabled?: boolean | null;
  NodeGroupId?: string | null;
  CacheSecurityGroupNames?: string[] | null;
  SecurityGroupIds?: string[] | null;
  PreferredMaintenanceWindow?: string | null;
  NotificationTopicArn?: string | null;
  CacheParameterGroupName?: string | null;
  NotificationTopicStatus?: string | null;
  ApplyImmediately?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  CacheNodeType?: string | null;
  AuthToken?: string | null;
  AuthTokenUpdateStrategy?: AuthTokenUpdateStrategyType | null;
  UserGroupIdsToAdd?: string[] | null;
  UserGroupIdsToRemove?: string[] | null;
  RemoveUserGroups?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyReplicationGroupShardConfigurationMessage {
  ReplicationGroupId: string;
  NodeGroupCount: number;
  ApplyImmediately: boolean;
  ReshardingConfiguration?: ReshardingConfiguration[] | null;
  NodeGroupsToRemove?: string[] | null;
  NodeGroupsToRetain?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyUserMessage {
  UserId: string;
  AccessString?: string | null;
  AppendAccessString?: string | null;
  Passwords?: string[] | null;
  NoPasswordRequired?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyUserGroupMessage {
  UserGroupId: string;
  UserIdsToAdd?: string[] | null;
  UserIdsToRemove?: string[] | null;
}

// refs: 1 - tags: named, input
export interface PurchaseReservedCacheNodesOfferingMessage {
  ReservedCacheNodesOfferingId: string;
  ReservedCacheNodeId?: string | null;
  CacheNodeCount?: number | null;
}

// refs: 1 - tags: named, input
export interface RebalanceSlotsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string;
  ApplyImmediately: boolean;
}

// refs: 1 - tags: named, input
export interface RebootCacheClusterMessage {
  CacheClusterId: string;
  CacheNodeIdsToReboot: string[];
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceMessage {
  ResourceName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface ResetCacheParameterGroupMessage {
  CacheParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  ParameterNameValues?: ParameterNameValue[] | null;
}

// refs: 1 - tags: named, input
export interface RevokeCacheSecurityGroupIngressMessage {
  CacheSecurityGroupName: string;
  EC2SecurityGroupName: string;
  EC2SecurityGroupOwnerId: string;
}

// refs: 1 - tags: named, input
export interface StartMigrationMessage {
  ReplicationGroupId: string;
  CustomerNodeEndpointList: CustomerNodeEndpoint[];
}

// refs: 1 - tags: named, input
export interface TestFailoverMessage {
  ReplicationGroupId: string;
  NodeGroupId: string;
}

// refs: 1 - tags: named, output
export interface TagListMessage {
  TagList: Tag[];
}

// refs: 1 - tags: named, output
export interface AuthorizeCacheSecurityGroupIngressResult {
  CacheSecurityGroup?: CacheSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface UpdateActionResultsMessage {
  ProcessedUpdateActions: ProcessedUpdateAction[];
  UnprocessedUpdateActions: UnprocessedUpdateAction[];
}

// refs: 1 - tags: named, output
export interface CompleteMigrationResponse {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface CopySnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateCacheClusterResult {
  CacheCluster?: CacheCluster | null;
}

// refs: 1 - tags: named, output
export interface CreateCacheParameterGroupResult {
  CacheParameterGroup?: CacheParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateCacheSecurityGroupResult {
  CacheSecurityGroup?: CacheSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateCacheSubnetGroupResult {
  CacheSubnetGroup?: CacheSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 2 - tags: named, output, interface
export interface User {
  UserId?: string | null;
  UserName?: string | null;
  Status?: string | null;
  Engine?: string | null;
  AccessString?: string | null;
  UserGroupIds: string[];
  Authentication?: Authentication | null;
  ARN?: string | null;
}
function User_Parse(node: xmlP.XmlNode): User {
  return {
    ...node.strings({
      optional: {"UserId":true,"UserName":true,"Status":true,"Engine":true,"AccessString":true,"ARN":true},
    }),
    UserGroupIds: node.getList("UserGroupIds", "member").map(x => x.content ?? ''),
    Authentication: node.first("Authentication", false, Authentication_Parse),
  };
}

// refs: 2 - tags: named, output, interface
export interface UserGroup {
  UserGroupId?: string | null;
  Status?: string | null;
  Engine?: string | null;
  UserIds: string[];
  PendingChanges?: UserGroupPendingChanges | null;
  ReplicationGroups: string[];
  ARN?: string | null;
}
function UserGroup_Parse(node: xmlP.XmlNode): UserGroup {
  return {
    ...node.strings({
      optional: {"UserGroupId":true,"Status":true,"Engine":true,"ARN":true},
    }),
    UserIds: node.getList("UserIds", "member").map(x => x.content ?? ''),
    PendingChanges: node.first("PendingChanges", false, UserGroupPendingChanges_Parse),
    ReplicationGroups: node.getList("ReplicationGroups", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: named, output
export interface DecreaseNodeGroupsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface DecreaseReplicaCountResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteCacheClusterResult {
  CacheCluster?: CacheCluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteSnapshotResult {
  Snapshot?: Snapshot | null;
}

// refs: 1 - tags: named, output
export interface CacheClusterMessage {
  Marker?: string | null;
  CacheClusters: CacheCluster[];
}

// refs: 1 - tags: named, output
export interface CacheEngineVersionMessage {
  Marker?: string | null;
  CacheEngineVersions: CacheEngineVersion[];
}

// refs: 1 - tags: named, output
export interface CacheParameterGroupsMessage {
  Marker?: string | null;
  CacheParameterGroups: CacheParameterGroup[];
}

// refs: 1 - tags: named, output
export interface CacheParameterGroupDetails {
  Marker?: string | null;
  Parameters: Parameter[];
  CacheNodeTypeSpecificParameters: CacheNodeTypeSpecificParameter[];
}

// refs: 1 - tags: named, output
export interface CacheSecurityGroupMessage {
  Marker?: string | null;
  CacheSecurityGroups: CacheSecurityGroup[];
}

// refs: 1 - tags: named, output
export interface CacheSubnetGroupMessage {
  Marker?: string | null;
  CacheSubnetGroups: CacheSubnetGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeEngineDefaultParametersResult {
  EngineDefaults?: EngineDefaults | null;
}

// refs: 1 - tags: named, output
export interface EventsMessage {
  Marker?: string | null;
  Events: Event[];
}

// refs: 1 - tags: named, output
export interface DescribeGlobalReplicationGroupsResult {
  Marker?: string | null;
  GlobalReplicationGroups: GlobalReplicationGroup[];
}

// refs: 1 - tags: named, output
export interface ReplicationGroupMessage {
  Marker?: string | null;
  ReplicationGroups: ReplicationGroup[];
}

// refs: 1 - tags: named, output
export interface ReservedCacheNodeMessage {
  Marker?: string | null;
  ReservedCacheNodes: ReservedCacheNode[];
}

// refs: 1 - tags: named, output
export interface ReservedCacheNodesOfferingMessage {
  Marker?: string | null;
  ReservedCacheNodesOfferings: ReservedCacheNodesOffering[];
}

// refs: 1 - tags: named, output
export interface ServiceUpdatesMessage {
  Marker?: string | null;
  ServiceUpdates: ServiceUpdate[];
}

// refs: 1 - tags: named, output
export interface DescribeSnapshotsListMessage {
  Marker?: string | null;
  Snapshots: Snapshot[];
}

// refs: 1 - tags: named, output
export interface UpdateActionsMessage {
  Marker?: string | null;
  UpdateActions: UpdateAction[];
}

// refs: 1 - tags: named, output
export interface DescribeUserGroupsResult {
  UserGroups: UserGroup[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeUsersResult {
  Users: User[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DisassociateGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface FailoverGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface IncreaseNodeGroupsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface IncreaseReplicaCountResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface AllowedNodeTypeModificationsMessage {
  ScaleUpModifications: string[];
  ScaleDownModifications: string[];
}

// refs: 1 - tags: named, output
export interface ModifyCacheClusterResult {
  CacheCluster?: CacheCluster | null;
}

// refs: 1 - tags: named, output
export interface CacheParameterGroupNameMessage {
  CacheParameterGroupName?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyCacheSubnetGroupResult {
  CacheSubnetGroup?: CacheSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyReplicationGroupShardConfigurationResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedCacheNodesOfferingResult {
  ReservedCacheNode?: ReservedCacheNode | null;
}

// refs: 1 - tags: named, output
export interface RebalanceSlotsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface RebootCacheClusterResult {
  CacheCluster?: CacheCluster | null;
}

// refs: 1 - tags: named, output
export interface RevokeCacheSecurityGroupIngressResult {
  CacheSecurityGroup?: CacheSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface StartMigrationResponse {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 1 - tags: named, output
export interface TestFailoverResult {
  ReplicationGroup?: ReplicationGroup | null;
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 2 - tags: input, named, enum
export type AZMode =
| "single-az"
| "cross-az"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type OutpostMode =
| "single-outpost"
| "cross-outpost"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface NodeGroupConfiguration {
  NodeGroupId?: string | null;
  Slots?: string | null;
  ReplicaCount?: number | null;
  PrimaryAvailabilityZone?: string | null;
  ReplicaAvailabilityZones: string[];
  PrimaryOutpostArn?: string | null;
  ReplicaOutpostArns: string[];
}
function NodeGroupConfiguration_Serialize(body: URLSearchParams, prefix: string, params: NodeGroupConfiguration) {
    if ("NodeGroupId" in params) body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if ("Slots" in params) body.append(prefix+".Slots", (params["Slots"] ?? '').toString());
    if ("ReplicaCount" in params) body.append(prefix+".ReplicaCount", (params["ReplicaCount"] ?? '').toString());
    if ("PrimaryAvailabilityZone" in params) body.append(prefix+".PrimaryAvailabilityZone", (params["PrimaryAvailabilityZone"] ?? '').toString());
    if (params["ReplicaAvailabilityZones"]) qsP.appendList(body, prefix+".ReplicaAvailabilityZones", params["ReplicaAvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    if ("PrimaryOutpostArn" in params) body.append(prefix+".PrimaryOutpostArn", (params["PrimaryOutpostArn"] ?? '').toString());
    if (params["ReplicaOutpostArns"]) qsP.appendList(body, prefix+".ReplicaOutpostArns", params["ReplicaOutpostArns"], {"entryPrefix":".OutpostArn."})
}
function NodeGroupConfiguration_Parse(node: xmlP.XmlNode): NodeGroupConfiguration {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true,"Slots":true,"PrimaryAvailabilityZone":true,"PrimaryOutpostArn":true},
    }),
    ReplicaCount: node.first("ReplicaCount", false, x => parseInt(x.content ?? '0')),
    ReplicaAvailabilityZones: node.getList("ReplicaAvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    ReplicaOutpostArns: node.getList("ReplicaOutpostArns", "OutpostArn").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface
export interface ConfigureShard {
  NodeGroupId: string;
  NewReplicaCount: number;
  PreferredAvailabilityZones?: string[] | null;
  PreferredOutpostArns?: string[] | null;
}
function ConfigureShard_Serialize(body: URLSearchParams, prefix: string, params: ConfigureShard) {
    body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    body.append(prefix+".NewReplicaCount", (params["NewReplicaCount"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+".PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".PreferredAvailabilityZone."})
    if (params["PreferredOutpostArns"]) qsP.appendList(body, prefix+".PreferredOutpostArns", params["PreferredOutpostArns"], {"entryPrefix":".PreferredOutpostArn."})
}

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "cache-cluster"
| "cache-parameter-group"
| "cache-security-group"
| "cache-subnet-group"
| "replication-group"
| "user"
| "user-group"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ServiceUpdateStatus =
| "available"
| "cancelled"
| "expired"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TimeRangeFilter {
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
}
function TimeRangeFilter_Serialize(body: URLSearchParams, prefix: string, params: TimeRangeFilter) {
    if ("StartTime" in params) body.append(prefix+".StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+".EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
}

// refs: 3 - tags: input, named, enum, output
export type UpdateActionStatus =
| "not-applied"
| "waiting-to-start"
| "in-progress"
| "stopping"
| "stopped"
| "complete"
| "scheduling"
| "scheduled"
| "not-applicable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Filter {
  Name: string;
  Values: string[];
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

// refs: 1 - tags: input, named, interface
export interface RegionalConfiguration {
  ReplicationGroupId: string;
  ReplicationGroupRegion: string;
  ReshardingConfiguration: ReshardingConfiguration[];
}
function RegionalConfiguration_Serialize(body: URLSearchParams, prefix: string, params: RegionalConfiguration) {
    body.append(prefix+".ReplicationGroupId", (params["ReplicationGroupId"] ?? '').toString());
    body.append(prefix+".ReplicationGroupRegion", (params["ReplicationGroupRegion"] ?? '').toString());
    if (params["ReshardingConfiguration"]) qsP.appendList(body, prefix+".ReshardingConfiguration", params["ReshardingConfiguration"], {"appender":ReshardingConfiguration_Serialize,"entryPrefix":".ReshardingConfiguration."})
}

// refs: 2 - tags: input, named, interface
export interface ReshardingConfiguration {
  NodeGroupId?: string | null;
  PreferredAvailabilityZones?: string[] | null;
}
function ReshardingConfiguration_Serialize(body: URLSearchParams, prefix: string, params: ReshardingConfiguration) {
    if ("NodeGroupId" in params) body.append(prefix+".NodeGroupId", (params["NodeGroupId"] ?? '').toString());
    if (params["PreferredAvailabilityZones"]) qsP.appendList(body, prefix+".PreferredAvailabilityZones", params["PreferredAvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
}

// refs: 2 - tags: input, named, enum
export type AuthTokenUpdateStrategyType =
| "SET"
| "ROTATE"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ParameterNameValue {
  ParameterName?: string | null;
  ParameterValue?: string | null;
}
function ParameterNameValue_Serialize(body: URLSearchParams, prefix: string, params: ParameterNameValue) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface CustomerNodeEndpoint {
  Address?: string | null;
  Port?: number | null;
}
function CustomerNodeEndpoint_Serialize(body: URLSearchParams, prefix: string, params: CustomerNodeEndpoint) {
    if ("Address" in params) body.append(prefix+".Address", (params["Address"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
}

// refs: 4 - tags: output, named, interface
export interface CacheSecurityGroup {
  OwnerId?: string | null;
  CacheSecurityGroupName?: string | null;
  Description?: string | null;
  EC2SecurityGroups: EC2SecurityGroup[];
  ARN?: string | null;
}
function CacheSecurityGroup_Parse(node: xmlP.XmlNode): CacheSecurityGroup {
  return {
    ...node.strings({
      optional: {"OwnerId":true,"CacheSecurityGroupName":true,"Description":true,"ARN":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface EC2SecurityGroup {
  Status?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}
function EC2SecurityGroup_Parse(node: xmlP.XmlNode): EC2SecurityGroup {
  return node.strings({
    optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupOwnerId":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface ProcessedUpdateAction {
  ReplicationGroupId?: string | null;
  CacheClusterId?: string | null;
  ServiceUpdateName?: string | null;
  UpdateActionStatus?: UpdateActionStatus | null;
}
function ProcessedUpdateAction_Parse(node: xmlP.XmlNode): ProcessedUpdateAction {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true},
    }),
    UpdateActionStatus: node.first("UpdateActionStatus", false, x => (x.content ?? '') as UpdateActionStatus),
  };
}

// refs: 1 - tags: output, named, interface
export interface UnprocessedUpdateAction {
  ReplicationGroupId?: string | null;
  CacheClusterId?: string | null;
  ServiceUpdateName?: string | null;
  ErrorType?: string | null;
  ErrorMessage?: string | null;
}
function UnprocessedUpdateAction_Parse(node: xmlP.XmlNode): UnprocessedUpdateAction {
  return node.strings({
    optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true,"ErrorType":true,"ErrorMessage":true},
  });
}

// refs: 10 - tags: output, named, interface
export interface ReplicationGroup {
  ReplicationGroupId?: string | null;
  Description?: string | null;
  GlobalReplicationGroupInfo?: GlobalReplicationGroupInfo | null;
  Status?: string | null;
  PendingModifiedValues?: ReplicationGroupPendingModifiedValues | null;
  MemberClusters: string[];
  NodeGroups: NodeGroup[];
  SnapshottingClusterId?: string | null;
  AutomaticFailover?: AutomaticFailoverStatus | null;
  MultiAZ?: MultiAZStatus | null;
  ConfigurationEndpoint?: Endpoint | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  ClusterEnabled?: boolean | null;
  CacheNodeType?: string | null;
  AuthTokenEnabled?: boolean | null;
  AuthTokenLastModifiedDate?: Date | number | null;
  TransitEncryptionEnabled?: boolean | null;
  AtRestEncryptionEnabled?: boolean | null;
  MemberClustersOutpostArns: string[];
  KmsKeyId?: string | null;
  ARN?: string | null;
  UserGroupIds: string[];
}
function ReplicationGroup_Parse(node: xmlP.XmlNode): ReplicationGroup {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"Description":true,"Status":true,"SnapshottingClusterId":true,"SnapshotWindow":true,"CacheNodeType":true,"KmsKeyId":true,"ARN":true},
    }),
    GlobalReplicationGroupInfo: node.first("GlobalReplicationGroupInfo", false, GlobalReplicationGroupInfo_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, ReplicationGroupPendingModifiedValues_Parse),
    MemberClusters: node.getList("MemberClusters", "ClusterId").map(x => x.content ?? ''),
    NodeGroups: node.getList("NodeGroups", "NodeGroup").map(NodeGroup_Parse),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as AutomaticFailoverStatus),
    MultiAZ: node.first("MultiAZ", false, x => (x.content ?? '') as MultiAZStatus),
    ConfigurationEndpoint: node.first("ConfigurationEndpoint", false, Endpoint_Parse),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    ClusterEnabled: node.first("ClusterEnabled", false, x => x.content === 'true'),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    AuthTokenLastModifiedDate: node.first("AuthTokenLastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
    MemberClustersOutpostArns: node.getList("MemberClustersOutpostArns", "ReplicationGroupOutpostArn").map(x => x.content ?? ''),
    UserGroupIds: node.getList("UserGroupIds", "member").map(x => x.content ?? ''),
  };
}

// refs: 10 - tags: output, named, interface
export interface GlobalReplicationGroupInfo {
  GlobalReplicationGroupId?: string | null;
  GlobalReplicationGroupMemberRole?: string | null;
}
function GlobalReplicationGroupInfo_Parse(node: xmlP.XmlNode): GlobalReplicationGroupInfo {
  return node.strings({
    optional: {"GlobalReplicationGroupId":true,"GlobalReplicationGroupMemberRole":true},
  });
}

// refs: 10 - tags: output, named, interface
export interface ReplicationGroupPendingModifiedValues {
  PrimaryClusterId?: string | null;
  AutomaticFailoverStatus?: PendingAutomaticFailoverStatus | null;
  Resharding?: ReshardingStatus | null;
  AuthTokenStatus?: AuthTokenUpdateStatus | null;
  UserGroups?: UserGroupsUpdateStatus | null;
}
function ReplicationGroupPendingModifiedValues_Parse(node: xmlP.XmlNode): ReplicationGroupPendingModifiedValues {
  return {
    ...node.strings({
      optional: {"PrimaryClusterId":true},
    }),
    AutomaticFailoverStatus: node.first("AutomaticFailoverStatus", false, x => (x.content ?? '') as PendingAutomaticFailoverStatus),
    Resharding: node.first("Resharding", false, ReshardingStatus_Parse),
    AuthTokenStatus: node.first("AuthTokenStatus", false, x => (x.content ?? '') as AuthTokenUpdateStatus),
    UserGroups: node.first("UserGroups", false, UserGroupsUpdateStatus_Parse),
  };
}

// refs: 10 - tags: output, named, enum
export type PendingAutomaticFailoverStatus =
| "enabled"
| "disabled"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: output, named, interface
export interface ReshardingStatus {
  SlotMigration?: SlotMigration | null;
}
function ReshardingStatus_Parse(node: xmlP.XmlNode): ReshardingStatus {
  return {
    SlotMigration: node.first("SlotMigration", false, SlotMigration_Parse),
  };
}

// refs: 10 - tags: output, named, interface
export interface SlotMigration {
  ProgressPercentage?: number | null;
}
function SlotMigration_Parse(node: xmlP.XmlNode): SlotMigration {
  return {
    ProgressPercentage: node.first("ProgressPercentage", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 15 - tags: output, named, enum
export type AuthTokenUpdateStatus =
| "SETTING"
| "ROTATING"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: output, named, interface
export interface UserGroupsUpdateStatus {
  UserGroupIdsToAdd: string[];
  UserGroupIdsToRemove: string[];
}
function UserGroupsUpdateStatus_Parse(node: xmlP.XmlNode): UserGroupsUpdateStatus {
  return {
    UserGroupIdsToAdd: node.getList("UserGroupIdsToAdd", "member").map(x => x.content ?? ''),
    UserGroupIdsToRemove: node.getList("UserGroupIdsToRemove", "member").map(x => x.content ?? ''),
  };
}

// refs: 10 - tags: output, named, interface
export interface NodeGroup {
  NodeGroupId?: string | null;
  Status?: string | null;
  PrimaryEndpoint?: Endpoint | null;
  ReaderEndpoint?: Endpoint | null;
  Slots?: string | null;
  NodeGroupMembers: NodeGroupMember[];
}
function NodeGroup_Parse(node: xmlP.XmlNode): NodeGroup {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true,"Status":true,"Slots":true},
    }),
    PrimaryEndpoint: node.first("PrimaryEndpoint", false, Endpoint_Parse),
    ReaderEndpoint: node.first("ReaderEndpoint", false, Endpoint_Parse),
    NodeGroupMembers: node.getList("NodeGroupMembers", "NodeGroupMember").map(NodeGroupMember_Parse),
  };
}

// refs: 50 - tags: output, named, interface
export interface Endpoint {
  Address?: string | null;
  Port?: number | null;
}
function Endpoint_Parse(node: xmlP.XmlNode): Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 10 - tags: output, named, interface
export interface NodeGroupMember {
  CacheClusterId?: string | null;
  CacheNodeId?: string | null;
  ReadEndpoint?: Endpoint | null;
  PreferredAvailabilityZone?: string | null;
  PreferredOutpostArn?: string | null;
  CurrentRole?: string | null;
}
function NodeGroupMember_Parse(node: xmlP.XmlNode): NodeGroupMember {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"CacheNodeId":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"CurrentRole":true},
    }),
    ReadEndpoint: node.first("ReadEndpoint", false, Endpoint_Parse),
  };
}

// refs: 23 - tags: output, named, enum
export type AutomaticFailoverStatus =
| "enabled"
| "disabled"
| "enabling"
| "disabling"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: output, named, enum
export type MultiAZStatus =
| "enabled"
| "disabled"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Snapshot {
  SnapshotName?: string | null;
  ReplicationGroupId?: string | null;
  ReplicationGroupDescription?: string | null;
  CacheClusterId?: string | null;
  SnapshotStatus?: string | null;
  SnapshotSource?: string | null;
  CacheNodeType?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  NumCacheNodes?: number | null;
  PreferredAvailabilityZone?: string | null;
  PreferredOutpostArn?: string | null;
  CacheClusterCreateTime?: Date | number | null;
  PreferredMaintenanceWindow?: string | null;
  TopicArn?: string | null;
  Port?: number | null;
  CacheParameterGroupName?: string | null;
  CacheSubnetGroupName?: string | null;
  VpcId?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  NumNodeGroups?: number | null;
  AutomaticFailover?: AutomaticFailoverStatus | null;
  NodeSnapshots: NodeSnapshot[];
  KmsKeyId?: string | null;
  ARN?: string | null;
}
function Snapshot_Parse(node: xmlP.XmlNode): Snapshot {
  return {
    ...node.strings({
      optional: {"SnapshotName":true,"ReplicationGroupId":true,"ReplicationGroupDescription":true,"CacheClusterId":true,"SnapshotStatus":true,"SnapshotSource":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"PreferredMaintenanceWindow":true,"TopicArn":true,"CacheParameterGroupName":true,"CacheSubnetGroupName":true,"VpcId":true,"SnapshotWindow":true,"KmsKeyId":true,"ARN":true},
    }),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheClusterCreateTime: node.first("CacheClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    NumNodeGroups: node.first("NumNodeGroups", false, x => parseInt(x.content ?? '0')),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as AutomaticFailoverStatus),
    NodeSnapshots: node.getList("NodeSnapshots", "NodeSnapshot").map(NodeSnapshot_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface NodeSnapshot {
  CacheClusterId?: string | null;
  NodeGroupId?: string | null;
  CacheNodeId?: string | null;
  NodeGroupConfiguration?: NodeGroupConfiguration | null;
  CacheSize?: string | null;
  CacheNodeCreateTime?: Date | number | null;
  SnapshotCreateTime?: Date | number | null;
}
function NodeSnapshot_Parse(node: xmlP.XmlNode): NodeSnapshot {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"NodeGroupId":true,"CacheNodeId":true,"CacheSize":true},
    }),
    NodeGroupConfiguration: node.first("NodeGroupConfiguration", false, NodeGroupConfiguration_Parse),
    CacheNodeCreateTime: node.first("CacheNodeCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 5 - tags: output, named, interface
export interface CacheCluster {
  CacheClusterId?: string | null;
  ConfigurationEndpoint?: Endpoint | null;
  ClientDownloadLandingPage?: string | null;
  CacheNodeType?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  CacheClusterStatus?: string | null;
  NumCacheNodes?: number | null;
  PreferredAvailabilityZone?: string | null;
  PreferredOutpostArn?: string | null;
  CacheClusterCreateTime?: Date | number | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: PendingModifiedValues | null;
  NotificationConfiguration?: NotificationConfiguration | null;
  CacheSecurityGroups: CacheSecurityGroupMembership[];
  CacheParameterGroup?: CacheParameterGroupStatus | null;
  CacheSubnetGroupName?: string | null;
  CacheNodes: CacheNode[];
  AutoMinorVersionUpgrade?: boolean | null;
  SecurityGroups: SecurityGroupMembership[];
  ReplicationGroupId?: string | null;
  SnapshotRetentionLimit?: number | null;
  SnapshotWindow?: string | null;
  AuthTokenEnabled?: boolean | null;
  AuthTokenLastModifiedDate?: Date | number | null;
  TransitEncryptionEnabled?: boolean | null;
  AtRestEncryptionEnabled?: boolean | null;
  ARN?: string | null;
}
function CacheCluster_Parse(node: xmlP.XmlNode): CacheCluster {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"ClientDownloadLandingPage":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"CacheClusterStatus":true,"PreferredAvailabilityZone":true,"PreferredOutpostArn":true,"PreferredMaintenanceWindow":true,"CacheSubnetGroupName":true,"ReplicationGroupId":true,"SnapshotWindow":true,"ARN":true},
    }),
    ConfigurationEndpoint: node.first("ConfigurationEndpoint", false, Endpoint_Parse),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheClusterCreateTime: node.first("CacheClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    NotificationConfiguration: node.first("NotificationConfiguration", false, NotificationConfiguration_Parse),
    CacheSecurityGroups: node.getList("CacheSecurityGroups", "CacheSecurityGroup").map(CacheSecurityGroupMembership_Parse),
    CacheParameterGroup: node.first("CacheParameterGroup", false, CacheParameterGroupStatus_Parse),
    CacheNodes: node.getList("CacheNodes", "CacheNode").map(CacheNode_Parse),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    SecurityGroups: node.getList("SecurityGroups", "member").map(SecurityGroupMembership_Parse),
    SnapshotRetentionLimit: node.first("SnapshotRetentionLimit", false, x => parseInt(x.content ?? '0')),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    AuthTokenLastModifiedDate: node.first("AuthTokenLastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
  };
}

// refs: 5 - tags: output, named, interface
export interface PendingModifiedValues {
  NumCacheNodes?: number | null;
  CacheNodeIdsToRemove: string[];
  EngineVersion?: string | null;
  CacheNodeType?: string | null;
  AuthTokenStatus?: AuthTokenUpdateStatus | null;
}
function PendingModifiedValues_Parse(node: xmlP.XmlNode): PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"EngineVersion":true,"CacheNodeType":true},
    }),
    NumCacheNodes: node.first("NumCacheNodes", false, x => parseInt(x.content ?? '0')),
    CacheNodeIdsToRemove: node.getList("CacheNodeIdsToRemove", "CacheNodeId").map(x => x.content ?? ''),
    AuthTokenStatus: node.first("AuthTokenStatus", false, x => (x.content ?? '') as AuthTokenUpdateStatus),
  };
}

// refs: 5 - tags: output, named, interface
export interface NotificationConfiguration {
  TopicArn?: string | null;
  TopicStatus?: string | null;
}
function NotificationConfiguration_Parse(node: xmlP.XmlNode): NotificationConfiguration {
  return node.strings({
    optional: {"TopicArn":true,"TopicStatus":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface CacheSecurityGroupMembership {
  CacheSecurityGroupName?: string | null;
  Status?: string | null;
}
function CacheSecurityGroupMembership_Parse(node: xmlP.XmlNode): CacheSecurityGroupMembership {
  return node.strings({
    optional: {"CacheSecurityGroupName":true,"Status":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface CacheParameterGroupStatus {
  CacheParameterGroupName?: string | null;
  ParameterApplyStatus?: string | null;
  CacheNodeIdsToReboot: string[];
}
function CacheParameterGroupStatus_Parse(node: xmlP.XmlNode): CacheParameterGroupStatus {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupName":true,"ParameterApplyStatus":true},
    }),
    CacheNodeIdsToReboot: node.getList("CacheNodeIdsToReboot", "CacheNodeId").map(x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, interface
export interface CacheNode {
  CacheNodeId?: string | null;
  CacheNodeStatus?: string | null;
  CacheNodeCreateTime?: Date | number | null;
  Endpoint?: Endpoint | null;
  ParameterGroupStatus?: string | null;
  SourceCacheNodeId?: string | null;
  CustomerAvailabilityZone?: string | null;
  CustomerOutpostArn?: string | null;
}
function CacheNode_Parse(node: xmlP.XmlNode): CacheNode {
  return {
    ...node.strings({
      optional: {"CacheNodeId":true,"CacheNodeStatus":true,"ParameterGroupStatus":true,"SourceCacheNodeId":true,"CustomerAvailabilityZone":true,"CustomerOutpostArn":true},
    }),
    CacheNodeCreateTime: node.first("CacheNodeCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface SecurityGroupMembership {
  SecurityGroupId?: string | null;
  Status?: string | null;
}
function SecurityGroupMembership_Parse(node: xmlP.XmlNode): SecurityGroupMembership {
  return node.strings({
    optional: {"SecurityGroupId":true,"Status":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface CacheParameterGroup {
  CacheParameterGroupName?: string | null;
  CacheParameterGroupFamily?: string | null;
  Description?: string | null;
  IsGlobal?: boolean | null;
  ARN?: string | null;
}
function CacheParameterGroup_Parse(node: xmlP.XmlNode): CacheParameterGroup {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupName":true,"CacheParameterGroupFamily":true,"Description":true,"ARN":true},
    }),
    IsGlobal: node.first("IsGlobal", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface CacheSubnetGroup {
  CacheSubnetGroupName?: string | null;
  CacheSubnetGroupDescription?: string | null;
  VpcId?: string | null;
  Subnets: Subnet[];
  ARN?: string | null;
}
function CacheSubnetGroup_Parse(node: xmlP.XmlNode): CacheSubnetGroup {
  return {
    ...node.strings({
      optional: {"CacheSubnetGroupName":true,"CacheSubnetGroupDescription":true,"VpcId":true,"ARN":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetOutpost?: SubnetOutpost | null;
}
function Subnet_Parse(node: xmlP.XmlNode): Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
    SubnetOutpost: node.first("SubnetOutpost", false, SubnetOutpost_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
}
function AvailabilityZone_Parse(node: xmlP.XmlNode): AvailabilityZone {
  return node.strings({
    optional: {"Name":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface SubnetOutpost {
  SubnetOutpostArn?: string | null;
}
function SubnetOutpost_Parse(node: xmlP.XmlNode): SubnetOutpost {
  return node.strings({
    optional: {"SubnetOutpostArn":true},
  });
}

// refs: 9 - tags: output, named, interface
export interface GlobalReplicationGroup {
  GlobalReplicationGroupId?: string | null;
  GlobalReplicationGroupDescription?: string | null;
  Status?: string | null;
  CacheNodeType?: string | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  Members: GlobalReplicationGroupMember[];
  ClusterEnabled?: boolean | null;
  GlobalNodeGroups: GlobalNodeGroup[];
  AuthTokenEnabled?: boolean | null;
  TransitEncryptionEnabled?: boolean | null;
  AtRestEncryptionEnabled?: boolean | null;
  ARN?: string | null;
}
function GlobalReplicationGroup_Parse(node: xmlP.XmlNode): GlobalReplicationGroup {
  return {
    ...node.strings({
      optional: {"GlobalReplicationGroupId":true,"GlobalReplicationGroupDescription":true,"Status":true,"CacheNodeType":true,"Engine":true,"EngineVersion":true,"ARN":true},
    }),
    Members: node.getList("Members", "GlobalReplicationGroupMember").map(GlobalReplicationGroupMember_Parse),
    ClusterEnabled: node.first("ClusterEnabled", false, x => x.content === 'true'),
    GlobalNodeGroups: node.getList("GlobalNodeGroups", "GlobalNodeGroup").map(GlobalNodeGroup_Parse),
    AuthTokenEnabled: node.first("AuthTokenEnabled", false, x => x.content === 'true'),
    TransitEncryptionEnabled: node.first("TransitEncryptionEnabled", false, x => x.content === 'true'),
    AtRestEncryptionEnabled: node.first("AtRestEncryptionEnabled", false, x => x.content === 'true'),
  };
}

// refs: 9 - tags: output, named, interface
export interface GlobalReplicationGroupMember {
  ReplicationGroupId?: string | null;
  ReplicationGroupRegion?: string | null;
  Role?: string | null;
  AutomaticFailover?: AutomaticFailoverStatus | null;
  Status?: string | null;
}
function GlobalReplicationGroupMember_Parse(node: xmlP.XmlNode): GlobalReplicationGroupMember {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"ReplicationGroupRegion":true,"Role":true,"Status":true},
    }),
    AutomaticFailover: node.first("AutomaticFailover", false, x => (x.content ?? '') as AutomaticFailoverStatus),
  };
}

// refs: 9 - tags: output, named, interface
export interface GlobalNodeGroup {
  GlobalNodeGroupId?: string | null;
  Slots?: string | null;
}
function GlobalNodeGroup_Parse(node: xmlP.XmlNode): GlobalNodeGroup {
  return node.strings({
    optional: {"GlobalNodeGroupId":true,"Slots":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface Authentication {
  Type?: AuthenticationType | null;
  PasswordCount?: number | null;
}
function Authentication_Parse(node: xmlP.XmlNode): Authentication {
  return {
    Type: node.first("Type", false, x => (x.content ?? '') as AuthenticationType),
    PasswordCount: node.first("PasswordCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, enum
export type AuthenticationType =
| "password"
| "no-password"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface UserGroupPendingChanges {
  UserIdsToRemove: string[];
  UserIdsToAdd: string[];
}
function UserGroupPendingChanges_Parse(node: xmlP.XmlNode): UserGroupPendingChanges {
  return {
    UserIdsToRemove: node.getList("UserIdsToRemove", "member").map(x => x.content ?? ''),
    UserIdsToAdd: node.getList("UserIdsToAdd", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CacheEngineVersion {
  Engine?: string | null;
  EngineVersion?: string | null;
  CacheParameterGroupFamily?: string | null;
  CacheEngineDescription?: string | null;
  CacheEngineVersionDescription?: string | null;
}
function CacheEngineVersion_Parse(node: xmlP.XmlNode): CacheEngineVersion {
  return node.strings({
    optional: {"Engine":true,"EngineVersion":true,"CacheParameterGroupFamily":true,"CacheEngineDescription":true,"CacheEngineVersionDescription":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface Parameter {
  ParameterName?: string | null;
  ParameterValue?: string | null;
  Description?: string | null;
  Source?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
  ChangeType?: ChangeType | null;
}
function Parameter_Parse(node: xmlP.XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ChangeType: node.first("ChangeType", false, x => (x.content ?? '') as ChangeType),
  };
}

// refs: 4 - tags: output, named, enum
export type ChangeType =
| "immediate"
| "requires-reboot"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface CacheNodeTypeSpecificParameter {
  ParameterName?: string | null;
  Description?: string | null;
  Source?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
  CacheNodeTypeSpecificValues: CacheNodeTypeSpecificValue[];
  ChangeType?: ChangeType | null;
}
function CacheNodeTypeSpecificParameter_Parse(node: xmlP.XmlNode): CacheNodeTypeSpecificParameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"Description":true,"Source":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    CacheNodeTypeSpecificValues: node.getList("CacheNodeTypeSpecificValues", "CacheNodeTypeSpecificValue").map(CacheNodeTypeSpecificValue_Parse),
    ChangeType: node.first("ChangeType", false, x => (x.content ?? '') as ChangeType),
  };
}

// refs: 2 - tags: output, named, interface
export interface CacheNodeTypeSpecificValue {
  CacheNodeType?: string | null;
  Value?: string | null;
}
function CacheNodeTypeSpecificValue_Parse(node: xmlP.XmlNode): CacheNodeTypeSpecificValue {
  return node.strings({
    optional: {"CacheNodeType":true,"Value":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface EngineDefaults {
  CacheParameterGroupFamily?: string | null;
  Marker?: string | null;
  Parameters: Parameter[];
  CacheNodeTypeSpecificParameters: CacheNodeTypeSpecificParameter[];
}
function EngineDefaults_Parse(node: xmlP.XmlNode): EngineDefaults {
  return {
    ...node.strings({
      optional: {"CacheParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
    CacheNodeTypeSpecificParameters: node.getList("CacheNodeTypeSpecificParameters", "CacheNodeTypeSpecificParameter").map(CacheNodeTypeSpecificParameter_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  Date?: Date | number | null;
}
function Event_Parse(node: xmlP.XmlNode): Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as SourceType),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface ReservedCacheNode {
  ReservedCacheNodeId?: string | null;
  ReservedCacheNodesOfferingId?: string | null;
  CacheNodeType?: string | null;
  StartTime?: Date | number | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CacheNodeCount?: number | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  State?: string | null;
  RecurringCharges: RecurringCharge[];
  ReservationARN?: string | null;
}
function ReservedCacheNode_Parse(node: xmlP.XmlNode): ReservedCacheNode {
  return {
    ...node.strings({
      optional: {"ReservedCacheNodeId":true,"ReservedCacheNodesOfferingId":true,"CacheNodeType":true,"ProductDescription":true,"OfferingType":true,"State":true,"ReservationARN":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    CacheNodeCount: node.first("CacheNodeCount", false, x => parseInt(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface RecurringCharge {
  RecurringChargeAmount?: number | null;
  RecurringChargeFrequency?: string | null;
}
function RecurringCharge_Parse(node: xmlP.XmlNode): RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedCacheNodesOffering {
  ReservedCacheNodesOfferingId?: string | null;
  CacheNodeType?: string | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  RecurringCharges: RecurringCharge[];
}
function ReservedCacheNodesOffering_Parse(node: xmlP.XmlNode): ReservedCacheNodesOffering {
  return {
    ...node.strings({
      optional: {"ReservedCacheNodesOfferingId":true,"CacheNodeType":true,"ProductDescription":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ServiceUpdate {
  ServiceUpdateName?: string | null;
  ServiceUpdateReleaseDate?: Date | number | null;
  ServiceUpdateEndDate?: Date | number | null;
  ServiceUpdateSeverity?: ServiceUpdateSeverity | null;
  ServiceUpdateRecommendedApplyByDate?: Date | number | null;
  ServiceUpdateStatus?: ServiceUpdateStatus | null;
  ServiceUpdateDescription?: string | null;
  ServiceUpdateType?: ServiceUpdateType | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  AutoUpdateAfterRecommendedApplyByDate?: boolean | null;
  EstimatedUpdateTime?: string | null;
}
function ServiceUpdate_Parse(node: xmlP.XmlNode): ServiceUpdate {
  return {
    ...node.strings({
      optional: {"ServiceUpdateName":true,"ServiceUpdateDescription":true,"Engine":true,"EngineVersion":true,"EstimatedUpdateTime":true},
    }),
    ServiceUpdateReleaseDate: node.first("ServiceUpdateReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateEndDate: node.first("ServiceUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateSeverity: node.first("ServiceUpdateSeverity", false, x => (x.content ?? '') as ServiceUpdateSeverity),
    ServiceUpdateRecommendedApplyByDate: node.first("ServiceUpdateRecommendedApplyByDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateStatus: node.first("ServiceUpdateStatus", false, x => (x.content ?? '') as ServiceUpdateStatus),
    ServiceUpdateType: node.first("ServiceUpdateType", false, x => (x.content ?? '') as ServiceUpdateType),
    AutoUpdateAfterRecommendedApplyByDate: node.first("AutoUpdateAfterRecommendedApplyByDate", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, enum
export type ServiceUpdateSeverity =
| "critical"
| "important"
| "medium"
| "low"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ServiceUpdateType =
| "security-update"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface UpdateAction {
  ReplicationGroupId?: string | null;
  CacheClusterId?: string | null;
  ServiceUpdateName?: string | null;
  ServiceUpdateReleaseDate?: Date | number | null;
  ServiceUpdateSeverity?: ServiceUpdateSeverity | null;
  ServiceUpdateStatus?: ServiceUpdateStatus | null;
  ServiceUpdateRecommendedApplyByDate?: Date | number | null;
  ServiceUpdateType?: ServiceUpdateType | null;
  UpdateActionAvailableDate?: Date | number | null;
  UpdateActionStatus?: UpdateActionStatus | null;
  NodesUpdated?: string | null;
  UpdateActionStatusModifiedDate?: Date | number | null;
  SlaMet?: SlaMet | null;
  NodeGroupUpdateStatus: NodeGroupUpdateStatus[];
  CacheNodeUpdateStatus: CacheNodeUpdateStatus[];
  EstimatedUpdateTime?: string | null;
  Engine?: string | null;
}
function UpdateAction_Parse(node: xmlP.XmlNode): UpdateAction {
  return {
    ...node.strings({
      optional: {"ReplicationGroupId":true,"CacheClusterId":true,"ServiceUpdateName":true,"NodesUpdated":true,"EstimatedUpdateTime":true,"Engine":true},
    }),
    ServiceUpdateReleaseDate: node.first("ServiceUpdateReleaseDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateSeverity: node.first("ServiceUpdateSeverity", false, x => (x.content ?? '') as ServiceUpdateSeverity),
    ServiceUpdateStatus: node.first("ServiceUpdateStatus", false, x => (x.content ?? '') as ServiceUpdateStatus),
    ServiceUpdateRecommendedApplyByDate: node.first("ServiceUpdateRecommendedApplyByDate", false, x => xmlP.parseTimestamp(x.content)),
    ServiceUpdateType: node.first("ServiceUpdateType", false, x => (x.content ?? '') as ServiceUpdateType),
    UpdateActionAvailableDate: node.first("UpdateActionAvailableDate", false, x => xmlP.parseTimestamp(x.content)),
    UpdateActionStatus: node.first("UpdateActionStatus", false, x => (x.content ?? '') as UpdateActionStatus),
    UpdateActionStatusModifiedDate: node.first("UpdateActionStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
    SlaMet: node.first("SlaMet", false, x => (x.content ?? '') as SlaMet),
    NodeGroupUpdateStatus: node.getList("NodeGroupUpdateStatus", "NodeGroupUpdateStatus").map(NodeGroupUpdateStatus_Parse),
    CacheNodeUpdateStatus: node.getList("CacheNodeUpdateStatus", "CacheNodeUpdateStatus").map(CacheNodeUpdateStatus_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type SlaMet =
| "yes"
| "no"
| "n/a"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface NodeGroupUpdateStatus {
  NodeGroupId?: string | null;
  NodeGroupMemberUpdateStatus: NodeGroupMemberUpdateStatus[];
}
function NodeGroupUpdateStatus_Parse(node: xmlP.XmlNode): NodeGroupUpdateStatus {
  return {
    ...node.strings({
      optional: {"NodeGroupId":true},
    }),
    NodeGroupMemberUpdateStatus: node.getList("NodeGroupMemberUpdateStatus", "NodeGroupMemberUpdateStatus").map(NodeGroupMemberUpdateStatus_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface NodeGroupMemberUpdateStatus {
  CacheClusterId?: string | null;
  CacheNodeId?: string | null;
  NodeUpdateStatus?: NodeUpdateStatus | null;
  NodeDeletionDate?: Date | number | null;
  NodeUpdateStartDate?: Date | number | null;
  NodeUpdateEndDate?: Date | number | null;
  NodeUpdateInitiatedBy?: NodeUpdateInitiatedBy | null;
  NodeUpdateInitiatedDate?: Date | number | null;
  NodeUpdateStatusModifiedDate?: Date | number | null;
}
function NodeGroupMemberUpdateStatus_Parse(node: xmlP.XmlNode): NodeGroupMemberUpdateStatus {
  return {
    ...node.strings({
      optional: {"CacheClusterId":true,"CacheNodeId":true},
    }),
    NodeUpdateStatus: node.first("NodeUpdateStatus", false, x => (x.content ?? '') as NodeUpdateStatus),
    NodeDeletionDate: node.first("NodeDeletionDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStartDate: node.first("NodeUpdateStartDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateEndDate: node.first("NodeUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateInitiatedBy: node.first("NodeUpdateInitiatedBy", false, x => (x.content ?? '') as NodeUpdateInitiatedBy),
    NodeUpdateInitiatedDate: node.first("NodeUpdateInitiatedDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStatusModifiedDate: node.first("NodeUpdateStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, enum
export type NodeUpdateStatus =
| "not-applied"
| "waiting-to-start"
| "in-progress"
| "stopping"
| "stopped"
| "complete"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type NodeUpdateInitiatedBy =
| "system"
| "customer"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CacheNodeUpdateStatus {
  CacheNodeId?: string | null;
  NodeUpdateStatus?: NodeUpdateStatus | null;
  NodeDeletionDate?: Date | number | null;
  NodeUpdateStartDate?: Date | number | null;
  NodeUpdateEndDate?: Date | number | null;
  NodeUpdateInitiatedBy?: NodeUpdateInitiatedBy | null;
  NodeUpdateInitiatedDate?: Date | number | null;
  NodeUpdateStatusModifiedDate?: Date | number | null;
}
function CacheNodeUpdateStatus_Parse(node: xmlP.XmlNode): CacheNodeUpdateStatus {
  return {
    ...node.strings({
      optional: {"CacheNodeId":true},
    }),
    NodeUpdateStatus: node.first("NodeUpdateStatus", false, x => (x.content ?? '') as NodeUpdateStatus),
    NodeDeletionDate: node.first("NodeDeletionDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStartDate: node.first("NodeUpdateStartDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateEndDate: node.first("NodeUpdateEndDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateInitiatedBy: node.first("NodeUpdateInitiatedBy", false, x => (x.content ?? '') as NodeUpdateInitiatedBy),
    NodeUpdateInitiatedDate: node.first("NodeUpdateInitiatedDate", false, x => xmlP.parseTimestamp(x.content)),
    NodeUpdateStatusModifiedDate: node.first("NodeUpdateStatusModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}
