// Autogenerated API client for: Amazon Glacier

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Glacier {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Glacier.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2012-06-01",
    "checksumFormat": "sha256",
    "endpointPrefix": "glacier",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Glacier",
    "serviceId": "Glacier",
    "signatureVersion": "v4",
    "uid": "glacier-2012-06-01"
  };

  async abortMultipartUpload(
    {abortSignal, ...params}: RequestConfig & AbortMultipartUploadInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AbortMultipartUpload",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads/${params["uploadId"]}`,
      responseCode: 204,
    });
  }

  async abortVaultLock(
    {abortSignal, ...params}: RequestConfig & AbortVaultLockInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AbortVaultLock",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/lock-policy`,
      responseCode: 204,
    });
  }

  async addTagsToVault(
    {abortSignal, ...params}: RequestConfig & AddTagsToVaultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      Tags: params["Tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToVault",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/tags?operation=add`,
      responseCode: 204,
    });
  }

  async completeMultipartUpload(
    {abortSignal, ...params}: RequestConfig & CompleteMultipartUploadInput,
  ): Promise<ArchiveCreationOutput> {
    const headers = new Headers;
    if (params["archiveSize"] != null) headers.append("x-amz-archive-size", params["archiveSize"]);
    if (params["checksum"] != null) headers.append("x-amz-sha256-tree-hash", params["checksum"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "CompleteMultipartUpload",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads/${params["uploadId"]}`,
      responseCode: 201,
    });
  return {
    location: resp.headers.get("Location"),
    checksum: resp.headers.get("x-amz-sha256-tree-hash"),
    archiveId: resp.headers.get("x-amz-archive-id"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async completeVaultLock(
    {abortSignal, ...params}: RequestConfig & CompleteVaultLockInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CompleteVaultLock",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/lock-policy/${params["lockId"]}`,
      responseCode: 204,
    });
  }

  async createVault(
    {abortSignal, ...params}: RequestConfig & CreateVaultInput,
  ): Promise<CreateVaultOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CreateVault",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}`,
      responseCode: 201,
    });
  return {
    location: resp.headers.get("Location"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteArchive(
    {abortSignal, ...params}: RequestConfig & DeleteArchiveInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteArchive",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/archives/${params["archiveId"]}`,
      responseCode: 204,
    });
  }

  async deleteVault(
    {abortSignal, ...params}: RequestConfig & DeleteVaultInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVault",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}`,
      responseCode: 204,
    });
  }

  async deleteVaultAccessPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteVaultAccessPolicyInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVaultAccessPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/access-policy`,
      responseCode: 204,
    });
  }

  async deleteVaultNotifications(
    {abortSignal, ...params}: RequestConfig & DeleteVaultNotificationsInput,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVaultNotifications",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/notification-configuration`,
      responseCode: 204,
    });
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & DescribeJobInput,
  ): Promise<GlacierJobDescription> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/jobs/${params["jobId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "JobId": "s",
          "JobDescription": "s",
          "Action": (x: jsonP.JSONValue) => cmnP.readEnum<ActionCode>(x),
          "ArchiveId": "s",
          "VaultARN": "s",
          "CreationDate": "s",
          "Completed": "b",
          "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<StatusCode>(x),
          "StatusMessage": "s",
          "ArchiveSizeInBytes": "n",
          "InventorySizeInBytes": "n",
          "SNSTopic": "s",
          "CompletionDate": "s",
          "SHA256TreeHash": "s",
          "ArchiveSHA256TreeHash": "s",
          "RetrievalByteRange": "s",
          "Tier": "s",
          "InventoryRetrievalParameters": toInventoryRetrievalJobDescription,
          "JobOutputPath": "s",
          "SelectParameters": toSelectParameters,
          "OutputLocation": toOutputLocation,
        },
      }, await resp.json()),
  };
  }

  async describeVault(
    {abortSignal, ...params}: RequestConfig & DescribeVaultInput,
  ): Promise<DescribeVaultOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeVault",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "VaultARN": "s",
          "VaultName": "s",
          "CreationDate": "s",
          "LastInventoryDate": "s",
          "NumberOfArchives": "n",
          "SizeInBytes": "n",
        },
      }, await resp.json()),
  };
  }

  async getDataRetrievalPolicy(
    {abortSignal, ...params}: RequestConfig & GetDataRetrievalPolicyInput,
  ): Promise<GetDataRetrievalPolicyOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDataRetrievalPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/policies/data-retrieval`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Policy": toDataRetrievalPolicy,
        },
      }, await resp.json()),
  };
  }

  async getJobOutput(
    {abortSignal, ...params}: RequestConfig & GetJobOutputInput,
  ): Promise<GetJobOutputOutput> {
    const headers = new Headers;
    if (params["range"] != null) headers.append("Range", params["range"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetJobOutput",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/jobs/${params["jobId"]}/output`,
    });
  return {
    checksum: resp.headers.get("x-amz-sha256-tree-hash"),
    status: resp.status,
    contentRange: resp.headers.get("Content-Range"),
    acceptRanges: resp.headers.get("Accept-Ranges"),
    contentType: resp.headers.get("Content-Type"),
    archiveDescription: resp.headers.get("x-amz-archive-description"),
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getVaultAccessPolicy(
    {abortSignal, ...params}: RequestConfig & GetVaultAccessPolicyInput,
  ): Promise<GetVaultAccessPolicyOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVaultAccessPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/access-policy`,
    });
  return {
    policy: toVaultAccessPolicy(await resp.json()),
  };
  }

  async getVaultLock(
    {abortSignal, ...params}: RequestConfig & GetVaultLockInput,
  ): Promise<GetVaultLockOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVaultLock",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/lock-policy`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Policy": "s",
          "State": "s",
          "ExpirationDate": "s",
          "CreationDate": "s",
        },
      }, await resp.json()),
  };
  }

  async getVaultNotifications(
    {abortSignal, ...params}: RequestConfig & GetVaultNotificationsInput,
  ): Promise<GetVaultNotificationsOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVaultNotifications",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/notification-configuration`,
    });
  return {
    vaultNotificationConfig: toVaultNotificationConfig(await resp.json()),
  };
  }

  async initiateJob(
    {abortSignal, ...params}: RequestConfig & InitiateJobInput,
  ): Promise<InitiateJobOutput> {
    const inner = params["jobParameters"];
    const body: jsonP.JSONObject = inner ? {
      Format: inner["Format"],
      Type: inner["Type"],
      ArchiveId: inner["ArchiveId"],
      Description: inner["Description"],
      SNSTopic: inner["SNSTopic"],
      RetrievalByteRange: inner["RetrievalByteRange"],
      Tier: inner["Tier"],
      InventoryRetrievalParameters: fromInventoryRetrievalJobInput(inner["InventoryRetrievalParameters"]),
      SelectParameters: fromSelectParameters(inner["SelectParameters"]),
      OutputLocation: fromOutputLocation(inner["OutputLocation"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitiateJob",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/jobs`,
      responseCode: 202,
    });
  return {
    location: resp.headers.get("Location"),
    jobId: resp.headers.get("x-amz-job-id"),
    jobOutputPath: resp.headers.get("x-amz-job-output-path"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async initiateMultipartUpload(
    {abortSignal, ...params}: RequestConfig & InitiateMultipartUploadInput,
  ): Promise<InitiateMultipartUploadOutput> {
    const headers = new Headers;
    if (params["archiveDescription"] != null) headers.append("x-amz-archive-description", params["archiveDescription"]);
    if (params["partSize"] != null) headers.append("x-amz-part-size", params["partSize"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "InitiateMultipartUpload",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads`,
      responseCode: 201,
    });
  return {
    location: resp.headers.get("Location"),
    uploadId: resp.headers.get("x-amz-multipart-upload-id"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async initiateVaultLock(
    {abortSignal, ...params}: RequestConfig & InitiateVaultLockInput,
  ): Promise<InitiateVaultLockOutput> {
    const inner = params["policy"];
    const body: jsonP.JSONObject = inner ? {
      Policy: inner["Policy"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitiateVaultLock",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/lock-policy`,
      responseCode: 201,
    });
  return {
    lockId: resp.headers.get("x-amz-lock-id"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsInput,
  ): Promise<ListJobsOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["statuscode"] != null) query.set("statuscode", params["statuscode"]?.toString() ?? "");
    if (params["completed"] != null) query.set("completed", params["completed"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/jobs`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "JobList": [toGlacierJobDescription],
          "Marker": "s",
        },
      }, await resp.json()),
  };
  }

  async listMultipartUploads(
    {abortSignal, ...params}: RequestConfig & ListMultipartUploadsInput,
  ): Promise<ListMultipartUploadsOutput> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMultipartUploads",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "UploadsList": [toUploadListElement],
          "Marker": "s",
        },
      }, await resp.json()),
  };
  }

  async listParts(
    {abortSignal, ...params}: RequestConfig & ListPartsInput,
  ): Promise<ListPartsOutput> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListParts",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads/${params["uploadId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "MultipartUploadId": "s",
          "VaultARN": "s",
          "ArchiveDescription": "s",
          "PartSizeInBytes": "n",
          "CreationDate": "s",
          "Parts": [toPartListElement],
          "Marker": "s",
        },
      }, await resp.json()),
  };
  }

  async listProvisionedCapacity(
    {abortSignal, ...params}: RequestConfig & ListProvisionedCapacityInput,
  ): Promise<ListProvisionedCapacityOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListProvisionedCapacity",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/provisioned-capacity`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ProvisionedCapacityList": [toProvisionedCapacityDescription],
        },
      }, await resp.json()),
  };
  }

  async listTagsForVault(
    {abortSignal, ...params}: RequestConfig & ListTagsForVaultInput,
  ): Promise<ListTagsForVaultOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForVault",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/tags`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async listVaults(
    {abortSignal, ...params}: RequestConfig & ListVaultsInput,
  ): Promise<ListVaultsOutput> {
    const query = new URLSearchParams;
    if (params["marker"] != null) query.set("marker", params["marker"]?.toString() ?? "");
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVaults",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "VaultList": [toDescribeVaultOutput],
          "Marker": "s",
        },
      }, await resp.json()),
  };
  }

  async purchaseProvisionedCapacity(
    {abortSignal, ...params}: RequestConfig & PurchaseProvisionedCapacityInput,
  ): Promise<PurchaseProvisionedCapacityOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "PurchaseProvisionedCapacity",
      requestUri: cmnP.encodePath`/${params["accountId"]}/provisioned-capacity`,
      responseCode: 201,
    });
  return {
    capacityId: resp.headers.get("x-amz-capacity-id"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async removeTagsFromVault(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromVaultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromVault",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/tags?operation=remove`,
      responseCode: 204,
    });
  }

  async setDataRetrievalPolicy(
    {abortSignal, ...params}: RequestConfig & SetDataRetrievalPolicyInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      Policy: fromDataRetrievalPolicy(params["Policy"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetDataRetrievalPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["accountId"]}/policies/data-retrieval`,
      responseCode: 204,
    });
  }

  async setVaultAccessPolicy(
    {abortSignal, ...params}: RequestConfig & SetVaultAccessPolicyInput,
  ): Promise<void> {
    const inner = params["policy"];
    const body: jsonP.JSONObject = inner ? {
      Policy: inner["Policy"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetVaultAccessPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/access-policy`,
      responseCode: 204,
    });
  }

  async setVaultNotifications(
    {abortSignal, ...params}: RequestConfig & SetVaultNotificationsInput,
  ): Promise<void> {
    const inner = params["vaultNotificationConfig"];
    const body: jsonP.JSONObject = inner ? {
      SNSTopic: inner["SNSTopic"],
      Events: inner["Events"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetVaultNotifications",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/notification-configuration`,
      responseCode: 204,
    });
  }

  async uploadArchive(
    {abortSignal, ...params}: RequestConfig & UploadArchiveInput,
  ): Promise<ArchiveCreationOutput> {
    const headers = new Headers;
    if (params["archiveDescription"] != null) headers.append("x-amz-archive-description", params["archiveDescription"]);
    if (params["checksum"] != null) headers.append("x-amz-sha256-tree-hash", params["checksum"]);
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UploadArchive",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/archives`,
      responseCode: 201,
    });
  return {
    location: resp.headers.get("Location"),
    checksum: resp.headers.get("x-amz-sha256-tree-hash"),
    archiveId: resp.headers.get("x-amz-archive-id"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async uploadMultipartPart(
    {abortSignal, ...params}: RequestConfig & UploadMultipartPartInput,
  ): Promise<UploadMultipartPartOutput> {
    const headers = new Headers;
    if (params["checksum"] != null) headers.append("x-amz-sha256-tree-hash", params["checksum"]);
    if (params["range"] != null) headers.append("Content-Range", params["range"]);
    const body = typeof params["body"] === 'string' ? new TextEncoder().encode(params["body"]) : params["body"];
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UploadMultipartPart",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["accountId"]}/vaults/${params["vaultName"]}/multipart-uploads/${params["uploadId"]}`,
      responseCode: 204,
    });
  return {
    checksum: resp.headers.get("x-amz-sha256-tree-hash"),
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  // Resource State Waiters

  /** Checks state up to 15 times, 3 seconds apart (about 1 minutes max wait time). */
  async waitForVaultExists(
    params: RequestConfig & DescribeVaultInput,
  ): Promise<DescribeVaultOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VaultExists';
    for (let i = 0; i < 15; i++) {
      try {
        const resp = await this.describeVault(params);
        return resp; // for status 200
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 15 times, 3 seconds apart (about 1 minutes max wait time). */
  async waitForVaultNotExists(
    params: RequestConfig & DescribeVaultInput,
  ): Promise<Error | DescribeVaultOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VaultNotExists';
    for (let i = 0; i < 15; i++) {
      try {
        const resp = await this.describeVault(params);
        continue; // for status 200
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AbortMultipartUploadInput {
  accountId: string;
  vaultName: string;
  uploadId: string;
}

// refs: 1 - tags: named, input
export interface AbortVaultLockInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface AddTagsToVaultInput {
  accountId: string;
  vaultName: string;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CompleteMultipartUploadInput {
  accountId: string;
  vaultName: string;
  uploadId: string;
  archiveSize?: string | null;
  checksum?: string | null;
}

// refs: 1 - tags: named, input
export interface CompleteVaultLockInput {
  accountId: string;
  vaultName: string;
  lockId: string;
}

// refs: 1 - tags: named, input
export interface CreateVaultInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface DeleteArchiveInput {
  accountId: string;
  vaultName: string;
  archiveId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVaultInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVaultAccessPolicyInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVaultNotificationsInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobInput {
  accountId: string;
  vaultName: string;
  jobId: string;
}

// refs: 1 - tags: named, input
export interface DescribeVaultInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface GetDataRetrievalPolicyInput {
  accountId: string;
}

// refs: 1 - tags: named, input
export interface GetJobOutputInput {
  accountId: string;
  vaultName: string;
  jobId: string;
  range?: string | null;
}

// refs: 1 - tags: named, input
export interface GetVaultAccessPolicyInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface GetVaultLockInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface GetVaultNotificationsInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface InitiateJobInput {
  accountId: string;
  vaultName: string;
  jobParameters?: JobParameters | null;
}

// refs: 1 - tags: named, input
export interface InitiateMultipartUploadInput {
  accountId: string;
  vaultName: string;
  archiveDescription?: string | null;
  partSize?: string | null;
}

// refs: 1 - tags: named, input
export interface InitiateVaultLockInput {
  accountId: string;
  vaultName: string;
  policy?: VaultLockPolicy | null;
}

// refs: 1 - tags: named, input
export interface ListJobsInput {
  accountId: string;
  vaultName: string;
  limit?: string | null;
  marker?: string | null;
  statuscode?: string | null;
  completed?: string | null;
}

// refs: 1 - tags: named, input
export interface ListMultipartUploadsInput {
  accountId: string;
  vaultName: string;
  marker?: string | null;
  limit?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPartsInput {
  accountId: string;
  vaultName: string;
  uploadId: string;
  marker?: string | null;
  limit?: string | null;
}

// refs: 1 - tags: named, input
export interface ListProvisionedCapacityInput {
  accountId: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForVaultInput {
  accountId: string;
  vaultName: string;
}

// refs: 1 - tags: named, input
export interface ListVaultsInput {
  accountId: string;
  marker?: string | null;
  limit?: string | null;
}

// refs: 1 - tags: named, input
export interface PurchaseProvisionedCapacityInput {
  accountId: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromVaultInput {
  accountId: string;
  vaultName: string;
  TagKeys?: string[] | null;
}

// refs: 1 - tags: named, input
export interface SetDataRetrievalPolicyInput {
  accountId: string;
  Policy?: DataRetrievalPolicy | null;
}

// refs: 1 - tags: named, input
export interface SetVaultAccessPolicyInput {
  accountId: string;
  vaultName: string;
  policy?: VaultAccessPolicy | null;
}

// refs: 1 - tags: named, input
export interface SetVaultNotificationsInput {
  accountId: string;
  vaultName: string;
  vaultNotificationConfig?: VaultNotificationConfig | null;
}

// refs: 1 - tags: named, input
export interface UploadArchiveInput {
  vaultName: string;
  accountId: string;
  archiveDescription?: string | null;
  checksum?: string | null;
  body?: Uint8Array | string | null;
}

// refs: 1 - tags: named, input
export interface UploadMultipartPartInput {
  accountId: string;
  vaultName: string;
  uploadId: string;
  checksum?: string | null;
  range?: string | null;
  body?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface ArchiveCreationOutput {
  location?: string | null;
  checksum?: string | null;
  archiveId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVaultOutput {
  location?: string | null;
}

// refs: 2 - tags: named, output, interface
export interface GlacierJobDescription {
  JobId?: string | null;
  JobDescription?: string | null;
  Action?: ActionCode | null;
  ArchiveId?: string | null;
  VaultARN?: string | null;
  CreationDate?: string | null;
  Completed?: boolean | null;
  StatusCode?: StatusCode | null;
  StatusMessage?: string | null;
  ArchiveSizeInBytes?: number | null;
  InventorySizeInBytes?: number | null;
  SNSTopic?: string | null;
  CompletionDate?: string | null;
  SHA256TreeHash?: string | null;
  ArchiveSHA256TreeHash?: string | null;
  RetrievalByteRange?: string | null;
  Tier?: string | null;
  InventoryRetrievalParameters?: InventoryRetrievalJobDescription | null;
  JobOutputPath?: string | null;
  SelectParameters?: SelectParameters | null;
  OutputLocation?: OutputLocation | null;
}
function toGlacierJobDescription(root: jsonP.JSONValue): GlacierJobDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobDescription": "s",
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<ActionCode>(x),
      "ArchiveId": "s",
      "VaultARN": "s",
      "CreationDate": "s",
      "Completed": "b",
      "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<StatusCode>(x),
      "StatusMessage": "s",
      "ArchiveSizeInBytes": "n",
      "InventorySizeInBytes": "n",
      "SNSTopic": "s",
      "CompletionDate": "s",
      "SHA256TreeHash": "s",
      "ArchiveSHA256TreeHash": "s",
      "RetrievalByteRange": "s",
      "Tier": "s",
      "InventoryRetrievalParameters": toInventoryRetrievalJobDescription,
      "JobOutputPath": "s",
      "SelectParameters": toSelectParameters,
      "OutputLocation": toOutputLocation,
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface DescribeVaultOutput {
  VaultARN?: string | null;
  VaultName?: string | null;
  CreationDate?: string | null;
  LastInventoryDate?: string | null;
  NumberOfArchives?: number | null;
  SizeInBytes?: number | null;
}
function toDescribeVaultOutput(root: jsonP.JSONValue): DescribeVaultOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "VaultARN": "s",
      "VaultName": "s",
      "CreationDate": "s",
      "LastInventoryDate": "s",
      "NumberOfArchives": "n",
      "SizeInBytes": "n",
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface GetDataRetrievalPolicyOutput {
  Policy?: DataRetrievalPolicy | null;
}

// refs: 1 - tags: named, output
export interface GetJobOutputOutput {
  body?: Uint8Array | string | null;
  checksum?: string | null;
  status?: number | null;
  contentRange?: string | null;
  acceptRanges?: string | null;
  contentType?: string | null;
  archiveDescription?: string | null;
}

// refs: 1 - tags: named, output
export interface GetVaultAccessPolicyOutput {
  policy?: VaultAccessPolicy | null;
}

// refs: 1 - tags: named, output
export interface GetVaultLockOutput {
  Policy?: string | null;
  State?: string | null;
  ExpirationDate?: string | null;
  CreationDate?: string | null;
}

// refs: 1 - tags: named, output
export interface GetVaultNotificationsOutput {
  vaultNotificationConfig?: VaultNotificationConfig | null;
}

// refs: 1 - tags: named, output
export interface InitiateJobOutput {
  location?: string | null;
  jobId?: string | null;
  jobOutputPath?: string | null;
}

// refs: 1 - tags: named, output
export interface InitiateMultipartUploadOutput {
  location?: string | null;
  uploadId?: string | null;
}

// refs: 1 - tags: named, output
export interface InitiateVaultLockOutput {
  lockId?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsOutput {
  JobList?: GlacierJobDescription[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMultipartUploadsOutput {
  UploadsList?: UploadListElement[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPartsOutput {
  MultipartUploadId?: string | null;
  VaultARN?: string | null;
  ArchiveDescription?: string | null;
  PartSizeInBytes?: number | null;
  CreationDate?: string | null;
  Parts?: PartListElement[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListProvisionedCapacityOutput {
  ProvisionedCapacityList?: ProvisionedCapacityDescription[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForVaultOutput {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListVaultsOutput {
  VaultList?: DescribeVaultOutput[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface PurchaseProvisionedCapacityOutput {
  capacityId?: string | null;
}

// refs: 1 - tags: named, output
export interface UploadMultipartPartOutput {
  checksum?: string | null;
}

// refs: 1 - tags: input, named, interface
export interface JobParameters {
  Format?: string | null;
  Type?: string | null;
  ArchiveId?: string | null;
  Description?: string | null;
  SNSTopic?: string | null;
  RetrievalByteRange?: string | null;
  Tier?: string | null;
  InventoryRetrievalParameters?: InventoryRetrievalJobInput | null;
  SelectParameters?: SelectParameters | null;
  OutputLocation?: OutputLocation | null;
}
function fromJobParameters(input?: JobParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    Type: input["Type"],
    ArchiveId: input["ArchiveId"],
    Description: input["Description"],
    SNSTopic: input["SNSTopic"],
    RetrievalByteRange: input["RetrievalByteRange"],
    Tier: input["Tier"],
    InventoryRetrievalParameters: fromInventoryRetrievalJobInput(input["InventoryRetrievalParameters"]),
    SelectParameters: fromSelectParameters(input["SelectParameters"]),
    OutputLocation: fromOutputLocation(input["OutputLocation"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface InventoryRetrievalJobInput {
  StartDate?: string | null;
  EndDate?: string | null;
  Limit?: string | null;
  Marker?: string | null;
}
function fromInventoryRetrievalJobInput(input?: InventoryRetrievalJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartDate: input["StartDate"],
    EndDate: input["EndDate"],
    Limit: input["Limit"],
    Marker: input["Marker"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface SelectParameters {
  InputSerialization?: InputSerialization | null;
  ExpressionType?: ExpressionType | null;
  Expression?: string | null;
  OutputSerialization?: OutputSerialization | null;
}
function fromSelectParameters(input?: SelectParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputSerialization: fromInputSerialization(input["InputSerialization"]),
    ExpressionType: input["ExpressionType"],
    Expression: input["Expression"],
    OutputSerialization: fromOutputSerialization(input["OutputSerialization"]),
  }
}
function toSelectParameters(root: jsonP.JSONValue): SelectParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputSerialization": toInputSerialization,
      "ExpressionType": (x: jsonP.JSONValue) => cmnP.readEnum<ExpressionType>(x),
      "Expression": "s",
      "OutputSerialization": toOutputSerialization,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface InputSerialization {
  csv?: CSVInput | null;
}
function fromInputSerialization(input?: InputSerialization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    csv: fromCSVInput(input["csv"]),
  }
}
function toInputSerialization(root: jsonP.JSONValue): InputSerialization {
  return jsonP.readObj({
    required: {},
    optional: {
      "csv": toCSVInput,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CSVInput {
  FileHeaderInfo?: FileHeaderInfo | null;
  Comments?: string | null;
  QuoteEscapeCharacter?: string | null;
  RecordDelimiter?: string | null;
  FieldDelimiter?: string | null;
  QuoteCharacter?: string | null;
}
function fromCSVInput(input?: CSVInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FileHeaderInfo: input["FileHeaderInfo"],
    Comments: input["Comments"],
    QuoteEscapeCharacter: input["QuoteEscapeCharacter"],
    RecordDelimiter: input["RecordDelimiter"],
    FieldDelimiter: input["FieldDelimiter"],
    QuoteCharacter: input["QuoteCharacter"],
  }
}
function toCSVInput(root: jsonP.JSONValue): CSVInput {
  return jsonP.readObj({
    required: {},
    optional: {
      "FileHeaderInfo": (x: jsonP.JSONValue) => cmnP.readEnum<FileHeaderInfo>(x),
      "Comments": "s",
      "QuoteEscapeCharacter": "s",
      "RecordDelimiter": "s",
      "FieldDelimiter": "s",
      "QuoteCharacter": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type FileHeaderInfo =
| "USE"
| "IGNORE"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ExpressionType =
| "SQL"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface OutputSerialization {
  csv?: CSVOutput | null;
}
function fromOutputSerialization(input?: OutputSerialization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    csv: fromCSVOutput(input["csv"]),
  }
}
function toOutputSerialization(root: jsonP.JSONValue): OutputSerialization {
  return jsonP.readObj({
    required: {},
    optional: {
      "csv": toCSVOutput,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CSVOutput {
  QuoteFields?: QuoteFields | null;
  QuoteEscapeCharacter?: string | null;
  RecordDelimiter?: string | null;
  FieldDelimiter?: string | null;
  QuoteCharacter?: string | null;
}
function fromCSVOutput(input?: CSVOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    QuoteFields: input["QuoteFields"],
    QuoteEscapeCharacter: input["QuoteEscapeCharacter"],
    RecordDelimiter: input["RecordDelimiter"],
    FieldDelimiter: input["FieldDelimiter"],
    QuoteCharacter: input["QuoteCharacter"],
  }
}
function toCSVOutput(root: jsonP.JSONValue): CSVOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "QuoteFields": (x: jsonP.JSONValue) => cmnP.readEnum<QuoteFields>(x),
      "QuoteEscapeCharacter": "s",
      "RecordDelimiter": "s",
      "FieldDelimiter": "s",
      "QuoteCharacter": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type QuoteFields =
| "ALWAYS"
| "ASNEEDED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface OutputLocation {
  S3?: S3Location | null;
}
function fromOutputLocation(input?: OutputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3: fromS3Location(input["S3"]),
  }
}
function toOutputLocation(root: jsonP.JSONValue): OutputLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3": toS3Location,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface S3Location {
  BucketName?: string | null;
  Prefix?: string | null;
  Encryption?: Encryption | null;
  CannedACL?: CannedACL | null;
  AccessControlList?: Grant[] | null;
  Tagging?: { [key: string]: string | null | undefined } | null;
  UserMetadata?: { [key: string]: string | null | undefined } | null;
  StorageClass?: StorageClass | null;
}
function fromS3Location(input?: S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BucketName: input["BucketName"],
    Prefix: input["Prefix"],
    Encryption: fromEncryption(input["Encryption"]),
    CannedACL: input["CannedACL"],
    AccessControlList: input["AccessControlList"]?.map(x => fromGrant(x)),
    Tagging: input["Tagging"],
    UserMetadata: input["UserMetadata"],
    StorageClass: input["StorageClass"],
  }
}
function toS3Location(root: jsonP.JSONValue): S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "BucketName": "s",
      "Prefix": "s",
      "Encryption": toEncryption,
      "CannedACL": (x: jsonP.JSONValue) => cmnP.readEnum<CannedACL>(x),
      "AccessControlList": [toGrant],
      "Tagging": x => jsonP.readMap(String, String, x),
      "UserMetadata": x => jsonP.readMap(String, String, x),
      "StorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<StorageClass>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Encryption {
  EncryptionType?: EncryptionType | null;
  KMSKeyId?: string | null;
  KMSContext?: string | null;
}
function fromEncryption(input?: Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionType: input["EncryptionType"],
    KMSKeyId: input["KMSKeyId"],
    KMSContext: input["KMSContext"],
  }
}
function toEncryption(root: jsonP.JSONValue): Encryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionType>(x),
      "KMSKeyId": "s",
      "KMSContext": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type EncryptionType =
| "aws:kms"
| "AES256"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CannedACL =
| "private"
| "public-read"
| "public-read-write"
| "aws-exec-read"
| "authenticated-read"
| "bucket-owner-read"
| "bucket-owner-full-control"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Grant {
  Grantee?: Grantee | null;
  Permission?: Permission | null;
}
function fromGrant(input?: Grant | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Grantee: fromGrantee(input["Grantee"]),
    Permission: input["Permission"],
  }
}
function toGrant(root: jsonP.JSONValue): Grant {
  return jsonP.readObj({
    required: {},
    optional: {
      "Grantee": toGrantee,
      "Permission": (x: jsonP.JSONValue) => cmnP.readEnum<Permission>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Grantee {
  Type: Type;
  DisplayName?: string | null;
  URI?: string | null;
  ID?: string | null;
  EmailAddress?: string | null;
}
function fromGrantee(input?: Grantee | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    DisplayName: input["DisplayName"],
    URI: input["URI"],
    ID: input["ID"],
    EmailAddress: input["EmailAddress"],
  }
}
function toGrantee(root: jsonP.JSONValue): Grantee {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<Type>(x),
    },
    optional: {
      "DisplayName": "s",
      "URI": "s",
      "ID": "s",
      "EmailAddress": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type Type =
| "AmazonCustomerByEmail"
| "CanonicalUser"
| "Group"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type Permission =
| "FULL_CONTROL"
| "WRITE"
| "WRITE_ACP"
| "READ"
| "READ_ACP"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type StorageClass =
| "STANDARD"
| "REDUCED_REDUNDANCY"
| "STANDARD_IA"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface VaultLockPolicy {
  Policy?: string | null;
}
function fromVaultLockPolicy(input?: VaultLockPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Policy: input["Policy"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface DataRetrievalPolicy {
  Rules?: DataRetrievalRule[] | null;
}
function fromDataRetrievalPolicy(input?: DataRetrievalPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Rules: input["Rules"]?.map(x => fromDataRetrievalRule(x)),
  }
}
function toDataRetrievalPolicy(root: jsonP.JSONValue): DataRetrievalPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Rules": [toDataRetrievalRule],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DataRetrievalRule {
  Strategy?: string | null;
  BytesPerHour?: number | null;
}
function fromDataRetrievalRule(input?: DataRetrievalRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Strategy: input["Strategy"],
    BytesPerHour: input["BytesPerHour"],
  }
}
function toDataRetrievalRule(root: jsonP.JSONValue): DataRetrievalRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Strategy": "s",
      "BytesPerHour": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface VaultAccessPolicy {
  Policy?: string | null;
}
function fromVaultAccessPolicy(input?: VaultAccessPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Policy: input["Policy"],
  }
}
function toVaultAccessPolicy(root: jsonP.JSONValue): VaultAccessPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Policy": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface VaultNotificationConfig {
  SNSTopic?: string | null;
  Events?: string[] | null;
}
function fromVaultNotificationConfig(input?: VaultNotificationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SNSTopic: input["SNSTopic"],
    Events: input["Events"],
  }
}
function toVaultNotificationConfig(root: jsonP.JSONValue): VaultNotificationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "SNSTopic": "s",
      "Events": ["s"],
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ActionCode =
| "ArchiveRetrieval"
| "InventoryRetrieval"
| "Select"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type StatusCode =
| "InProgress"
| "Succeeded"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface InventoryRetrievalJobDescription {
  Format?: string | null;
  StartDate?: string | null;
  EndDate?: string | null;
  Limit?: string | null;
  Marker?: string | null;
}
function toInventoryRetrievalJobDescription(root: jsonP.JSONValue): InventoryRetrievalJobDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "StartDate": "s",
      "EndDate": "s",
      "Limit": "s",
      "Marker": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UploadListElement {
  MultipartUploadId?: string | null;
  VaultARN?: string | null;
  ArchiveDescription?: string | null;
  PartSizeInBytes?: number | null;
  CreationDate?: string | null;
}
function toUploadListElement(root: jsonP.JSONValue): UploadListElement {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultipartUploadId": "s",
      "VaultARN": "s",
      "ArchiveDescription": "s",
      "PartSizeInBytes": "n",
      "CreationDate": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PartListElement {
  RangeInBytes?: string | null;
  SHA256TreeHash?: string | null;
}
function toPartListElement(root: jsonP.JSONValue): PartListElement {
  return jsonP.readObj({
    required: {},
    optional: {
      "RangeInBytes": "s",
      "SHA256TreeHash": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ProvisionedCapacityDescription {
  CapacityId?: string | null;
  StartDate?: string | null;
  ExpirationDate?: string | null;
}
function toProvisionedCapacityDescription(root: jsonP.JSONValue): ProvisionedCapacityDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "CapacityId": "s",
      "StartDate": "s",
      "ExpirationDate": "s",
    },
  }, root);
}
