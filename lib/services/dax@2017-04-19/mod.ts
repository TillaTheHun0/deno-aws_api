// Autogenerated API client for: Amazon DynamoDB Accelerator (DAX)

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class DAX {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DAX.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-04-19",
    "endpointPrefix": "dax",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon DAX",
    "serviceFullName": "Amazon DynamoDB Accelerator (DAX)",
    "serviceId": "DAX",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonDAXV3",
    "uid": "dax-2017-04-19"
  };

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterRequest,
  ): Promise<s.CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
      NodeType: params["NodeType"],
      Description: params["Description"],
      ReplicationFactor: params["ReplicationFactor"],
      AvailabilityZones: params["AvailabilityZones"],
      SubnetGroupName: params["SubnetGroupName"],
      SecurityGroupIds: params["SecurityGroupIds"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      NotificationTopicArn: params["NotificationTopicArn"],
      IamRoleArn: params["IamRoleArn"],
      ParameterGroupName: params["ParameterGroupName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      SSESpecification: fromSSESpecification(params["SSESpecification"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async createParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateParameterGroupRequest,
  ): Promise<s.CreateParameterGroupResponse> {
    const body: jsonP.JSONObject = {
      ParameterGroupName: params["ParameterGroupName"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateParameterGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParameterGroup": toParameterGroup,
      },
    }, await resp.json());
  }

  async createSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateSubnetGroupRequest,
  ): Promise<s.CreateSubnetGroupResponse> {
    const body: jsonP.JSONObject = {
      SubnetGroupName: params["SubnetGroupName"],
      Description: params["Description"],
      SubnetIds: params["SubnetIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SubnetGroup": toSubnetGroup,
      },
    }, await resp.json());
  }

  async decreaseReplicationFactor(
    {abortSignal, ...params}: RequestConfig & s.DecreaseReplicationFactorRequest,
  ): Promise<s.DecreaseReplicationFactorResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
      NewReplicationFactor: params["NewReplicationFactor"],
      AvailabilityZones: params["AvailabilityZones"],
      NodeIdsToRemove: params["NodeIdsToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DecreaseReplicationFactor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterRequest,
  ): Promise<s.DeleteClusterResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteParameterGroupRequest,
  ): Promise<s.DeleteParameterGroupResponse> {
    const body: jsonP.JSONObject = {
      ParameterGroupName: params["ParameterGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteParameterGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeletionMessage": "s",
      },
    }, await resp.json());
  }

  async deleteSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteSubnetGroupRequest,
  ): Promise<s.DeleteSubnetGroupResponse> {
    const body: jsonP.JSONObject = {
      SubnetGroupName: params["SubnetGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeletionMessage": "s",
      },
    }, await resp.json());
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeClustersRequest = {},
  ): Promise<s.DescribeClustersResponse> {
    const body: jsonP.JSONObject = {
      ClusterNames: params["ClusterNames"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Clusters": [toCluster],
      },
    }, await resp.json());
  }

  async describeDefaultParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeDefaultParametersRequest = {},
  ): Promise<s.DescribeDefaultParametersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDefaultParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Parameters": [toParameter],
      },
    }, await resp.json());
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsRequest = {},
  ): Promise<s.DescribeEventsResponse> {
    const body: jsonP.JSONObject = {
      SourceName: params["SourceName"],
      SourceType: params["SourceType"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Duration: params["Duration"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Events": [toEvent],
      },
    }, await resp.json());
  }

  async describeParameterGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeParameterGroupsRequest = {},
  ): Promise<s.DescribeParameterGroupsResponse> {
    const body: jsonP.JSONObject = {
      ParameterGroupNames: params["ParameterGroupNames"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeParameterGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ParameterGroups": [toParameterGroup],
      },
    }, await resp.json());
  }

  async describeParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeParametersRequest,
  ): Promise<s.DescribeParametersResponse> {
    const body: jsonP.JSONObject = {
      ParameterGroupName: params["ParameterGroupName"],
      Source: params["Source"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Parameters": [toParameter],
      },
    }, await resp.json());
  }

  async describeSubnetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeSubnetGroupsRequest = {},
  ): Promise<s.DescribeSubnetGroupsResponse> {
    const body: jsonP.JSONObject = {
      SubnetGroupNames: params["SubnetGroupNames"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubnetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "SubnetGroups": [toSubnetGroup],
      },
    }, await resp.json());
  }

  async increaseReplicationFactor(
    {abortSignal, ...params}: RequestConfig & s.IncreaseReplicationFactorRequest,
  ): Promise<s.IncreaseReplicationFactorResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
      NewReplicationFactor: params["NewReplicationFactor"],
      AvailabilityZones: params["AvailabilityZones"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IncreaseReplicationFactor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & s.ListTagsRequest,
  ): Promise<s.ListTagsResponse> {
    const body: jsonP.JSONObject = {
      ResourceName: params["ResourceName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async rebootNode(
    {abortSignal, ...params}: RequestConfig & s.RebootNodeRequest,
  ): Promise<s.RebootNodeResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
      NodeId: params["NodeId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootNode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceName: params["ResourceName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceName: params["ResourceName"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async updateCluster(
    {abortSignal, ...params}: RequestConfig & s.UpdateClusterRequest,
  ): Promise<s.UpdateClusterResponse> {
    const body: jsonP.JSONObject = {
      ClusterName: params["ClusterName"],
      Description: params["Description"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      NotificationTopicArn: params["NotificationTopicArn"],
      NotificationTopicStatus: params["NotificationTopicStatus"],
      ParameterGroupName: params["ParameterGroupName"],
      SecurityGroupIds: params["SecurityGroupIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async updateParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateParameterGroupRequest,
  ): Promise<s.UpdateParameterGroupResponse> {
    const body: jsonP.JSONObject = {
      ParameterGroupName: params["ParameterGroupName"],
      ParameterNameValues: params["ParameterNameValues"]?.map(x => fromParameterNameValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateParameterGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParameterGroup": toParameterGroup,
      },
    }, await resp.json());
  }

  async updateSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateSubnetGroupRequest,
  ): Promise<s.UpdateSubnetGroupResponse> {
    const body: jsonP.JSONObject = {
      SubnetGroupName: params["SubnetGroupName"],
      Description: params["Description"],
      SubnetIds: params["SubnetIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SubnetGroup": toSubnetGroup,
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromSSESpecification(input?: s.SSESpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}

function fromParameterNameValue(input?: s.ParameterNameValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParameterName: input["ParameterName"],
    ParameterValue: input["ParameterValue"],
  }
}

function toCluster(root: jsonP.JSONValue): s.Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClusterName": "s",
      "Description": "s",
      "ClusterArn": "s",
      "TotalNodes": "n",
      "ActiveNodes": "n",
      "NodeType": "s",
      "Status": "s",
      "ClusterDiscoveryEndpoint": toEndpoint,
      "NodeIdsToRemove": ["s"],
      "Nodes": [toNode],
      "PreferredMaintenanceWindow": "s",
      "NotificationConfiguration": toNotificationConfiguration,
      "SubnetGroup": "s",
      "SecurityGroups": [toSecurityGroupMembership],
      "IamRoleArn": "s",
      "ParameterGroup": toParameterGroupStatus,
      "SSEDescription": toSSEDescription,
    },
  }, root);
}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "Port": "n",
    },
  }, root);
}

function toNode(root: jsonP.JSONValue): s.Node {
  return jsonP.readObj({
    required: {},
    optional: {
      "NodeId": "s",
      "Endpoint": toEndpoint,
      "NodeCreateTime": "d",
      "AvailabilityZone": "s",
      "NodeStatus": "s",
      "ParameterGroupStatus": "s",
    },
  }, root);
}

function toNotificationConfiguration(root: jsonP.JSONValue): s.NotificationConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "TopicArn": "s",
      "TopicStatus": "s",
    },
  }, root);
}

function toSecurityGroupMembership(root: jsonP.JSONValue): s.SecurityGroupMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "SecurityGroupIdentifier": "s",
      "Status": "s",
    },
  }, root);
}

function toParameterGroupStatus(root: jsonP.JSONValue): s.ParameterGroupStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterGroupName": "s",
      "ParameterApplyStatus": "s",
      "NodeIdsToReboot": ["s"],
    },
  }, root);
}

function toSSEDescription(root: jsonP.JSONValue): s.SSEDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SSEStatus>(x),
    },
  }, root);
}

function toParameterGroup(root: jsonP.JSONValue): s.ParameterGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterGroupName": "s",
      "Description": "s",
    },
  }, root);
}

function toSubnetGroup(root: jsonP.JSONValue): s.SubnetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetGroupName": "s",
      "Description": "s",
      "VpcId": "s",
      "Subnets": [toSubnet],
    },
  }, root);
}

function toSubnet(root: jsonP.JSONValue): s.Subnet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIdentifier": "s",
      "SubnetAvailabilityZone": "s",
    },
  }, root);
}

function toParameter(root: jsonP.JSONValue): s.Parameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterName": "s",
      "ParameterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterType>(x),
      "ParameterValue": "s",
      "NodeTypeSpecificValues": [toNodeTypeSpecificValue],
      "Description": "s",
      "Source": "s",
      "DataType": "s",
      "AllowedValues": "s",
      "IsModifiable": (x: jsonP.JSONValue) => cmnP.readEnum<s.IsModifiable>(x),
      "ChangeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChangeType>(x),
    },
  }, root);
}

function toNodeTypeSpecificValue(root: jsonP.JSONValue): s.NodeTypeSpecificValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "NodeType": "s",
      "Value": "s",
    },
  }, root);
}

function toEvent(root: jsonP.JSONValue): s.Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceName": "s",
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
      "Message": "s",
      "Date": "d",
    },
  }, root);
}
