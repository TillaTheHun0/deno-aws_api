// Autogenerated API client for: Amazon Lex Runtime V2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class LexRuntimeV2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexRuntimeV2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-08-07",
    "endpointPrefix": "runtime-v2-lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "protocolSettings": {
      "h2": "eventstream"
    },
    "serviceAbbreviation": "Lex Runtime V2",
    "serviceFullName": "Amazon Lex Runtime V2",
    "serviceId": "Lex Runtime V2",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "runtime.lex.v2-2020-08-07"
  };

  async deleteSession(
    {abortSignal, ...params}: RequestConfig & s.DeleteSessionRequest,
  ): Promise<s.DeleteSessionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSession",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botAliasId": "s",
        "localeId": "s",
        "sessionId": "s",
      },
    }, await resp.json());
  }

  async getSession(
    {abortSignal, ...params}: RequestConfig & s.GetSessionRequest,
  ): Promise<s.GetSessionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSession",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sessionId": "s",
        "messages": [toMessage],
        "interpretations": [toInterpretation],
        "sessionState": toSessionState,
      },
    }, await resp.json());
  }

  async putSession(
    {abortSignal, ...params}: RequestConfig & s.PutSessionRequest,
  ): Promise<s.PutSessionResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      messages: params["messages"]?.map(x => fromMessage(x)),
      sessionState: fromSessionState(params["sessionState"]),
      requestAttributes: params["requestAttributes"],
    };
    if (params["responseContentType"] != null) headers.append("ResponseContentType", params["responseContentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSession",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    messages: resp.headers.get("x-amz-lex-messages"),
    sessionState: resp.headers.get("x-amz-lex-session-state"),
    requestAttributes: resp.headers.get("x-amz-lex-request-attributes"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async recognizeText(
    {abortSignal, ...params}: RequestConfig & s.RecognizeTextRequest,
  ): Promise<s.RecognizeTextResponse> {
    const body: jsonP.JSONObject = {
      text: params["text"],
      sessionState: fromSessionState(params["sessionState"]),
      requestAttributes: params["requestAttributes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecognizeText",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}/text`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "messages": [toMessage],
        "sessionState": toSessionState,
        "interpretations": [toInterpretation],
        "requestAttributes": x => jsonP.readMap(String, String, x),
        "sessionId": "s",
      },
    }, await resp.json());
  }

  async recognizeUtterance(
    {abortSignal, ...params}: RequestConfig & s.RecognizeUtteranceRequest,
  ): Promise<s.RecognizeUtteranceResponse> {
    const body = typeof params["inputStream"] === 'string' ? new TextEncoder().encode(params["inputStream"]) : params["inputStream"];
    const headers = new Headers;
    if (params["sessionState"] != null) headers.append("x-amz-lex-session-state", params["sessionState"]);
    if (params["requestAttributes"] != null) headers.append("x-amz-lex-request-attributes", params["requestAttributes"]);
    headers.append("Content-Type", params["requestContentType"]);
    if (params["responseContentType"] != null) headers.append("Response-Content-Type", params["responseContentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "RecognizeUtterance",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}/utterance`,
    });
  return {
    inputMode: resp.headers.get("x-amz-lex-input-mode"),
    contentType: resp.headers.get("Content-Type"),
    messages: resp.headers.get("x-amz-lex-messages"),
    interpretations: resp.headers.get("x-amz-lex-interpretations"),
    sessionState: resp.headers.get("x-amz-lex-session-state"),
    requestAttributes: resp.headers.get("x-amz-lex-request-attributes"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    inputTranscript: resp.headers.get("x-amz-lex-input-transcript"),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

}

function fromMessage(input?: s.Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    contentType: input["contentType"],
    imageResponseCard: fromImageResponseCard(input["imageResponseCard"]),
  }
}
function toMessage(root: jsonP.JSONValue): s.Message {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "contentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageContentType>(x),
      "imageResponseCard": toImageResponseCard,
    },
  }, root);
}

function fromImageResponseCard(input?: s.ImageResponseCard | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    title: input["title"],
    subtitle: input["subtitle"],
    imageUrl: input["imageUrl"],
    buttons: input["buttons"]?.map(x => fromButton(x)),
  }
}
function toImageResponseCard(root: jsonP.JSONValue): s.ImageResponseCard {
  return jsonP.readObj({
    required: {
      "title": "s",
    },
    optional: {
      "subtitle": "s",
      "imageUrl": "s",
      "buttons": [toButton],
    },
  }, root);
}

function fromButton(input?: s.Button | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    text: input["text"],
    value: input["value"],
  }
}
function toButton(root: jsonP.JSONValue): s.Button {
  return jsonP.readObj({
    required: {
      "text": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromSessionState(input?: s.SessionState | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dialogAction: fromDialogAction(input["dialogAction"]),
    intent: fromIntent(input["intent"]),
    activeContexts: input["activeContexts"]?.map(x => fromActiveContext(x)),
    sessionAttributes: input["sessionAttributes"],
    originatingRequestId: input["originatingRequestId"],
  }
}
function toSessionState(root: jsonP.JSONValue): s.SessionState {
  return jsonP.readObj({
    required: {},
    optional: {
      "dialogAction": toDialogAction,
      "intent": toIntent,
      "activeContexts": [toActiveContext],
      "sessionAttributes": x => jsonP.readMap(String, String, x),
      "originatingRequestId": "s",
    },
  }, root);
}

function fromDialogAction(input?: s.DialogAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    slotToElicit: input["slotToElicit"],
  }
}
function toDialogAction(root: jsonP.JSONValue): s.DialogAction {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DialogActionType>(x),
    },
    optional: {
      "slotToElicit": "s",
    },
  }, root);
}

function fromIntent(input?: s.Intent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    slots: jsonP.serializeMap(input["slots"], x => fromSlot(x)),
    state: input["state"],
    confirmationState: input["confirmationState"],
  }
}
function toIntent(root: jsonP.JSONValue): s.Intent {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "slots": x => jsonP.readMap(String, toSlot, x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntentState>(x),
      "confirmationState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfirmationState>(x),
    },
  }, root);
}

function fromSlot(input?: s.Slot | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: fromValue(input["value"]),
  }
}
function toSlot(root: jsonP.JSONValue): s.Slot {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": toValue,
    },
  }, root);
}

function fromValue(input?: s.Value | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    originalValue: input["originalValue"],
    interpretedValue: input["interpretedValue"],
    resolvedValues: input["resolvedValues"],
  }
}
function toValue(root: jsonP.JSONValue): s.Value {
  return jsonP.readObj({
    required: {
      "interpretedValue": "s",
    },
    optional: {
      "originalValue": "s",
      "resolvedValues": ["s"],
    },
  }, root);
}

function fromActiveContext(input?: s.ActiveContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    timeToLive: fromActiveContextTimeToLive(input["timeToLive"]),
    contextAttributes: input["contextAttributes"],
  }
}
function toActiveContext(root: jsonP.JSONValue): s.ActiveContext {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timeToLive": toActiveContextTimeToLive,
    },
    optional: {
      "contextAttributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromActiveContextTimeToLive(input?: s.ActiveContextTimeToLive | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeToLiveInSeconds: input["timeToLiveInSeconds"],
    turnsToLive: input["turnsToLive"],
  }
}
function toActiveContextTimeToLive(root: jsonP.JSONValue): s.ActiveContextTimeToLive {
  return jsonP.readObj({
    required: {
      "timeToLiveInSeconds": "n",
      "turnsToLive": "n",
    },
    optional: {},
  }, root);
}

function toInterpretation(root: jsonP.JSONValue): s.Interpretation {
  return jsonP.readObj({
    required: {},
    optional: {
      "nluConfidence": toConfidenceScore,
      "sentimentResponse": toSentimentResponse,
      "intent": toIntent,
    },
  }, root);
}

function toConfidenceScore(root: jsonP.JSONValue): s.ConfidenceScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "score": "n",
    },
  }, root);
}

function toSentimentResponse(root: jsonP.JSONValue): s.SentimentResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<s.SentimentType>(x),
      "sentimentScore": toSentimentScore,
    },
  }, root);
}

function toSentimentScore(root: jsonP.JSONValue): s.SentimentScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "positive": "n",
      "negative": "n",
      "neutral": "n",
      "mixed": "n",
    },
  }, root);
}
