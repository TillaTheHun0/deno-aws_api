// Autogenerated API client for: Amazon Lex Runtime V2

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class LexRuntimeV2 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexRuntimeV2.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-08-07",
    "endpointPrefix": "runtime-v2-lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "protocolSettings": {
      "h2": "eventstream"
    },
    "serviceAbbreviation": "Lex Runtime V2",
    "serviceFullName": "Amazon Lex Runtime V2",
    "serviceId": "Lex Runtime V2",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "runtime.lex.v2-2020-08-07"
  };

  async deleteSession(
    {abortSignal, ...params}: RequestConfig & DeleteSessionRequest,
  ): Promise<DeleteSessionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSession",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botAliasId": "s",
        "localeId": "s",
        "sessionId": "s",
      },
    }, await resp.json());
  }

  async getSession(
    {abortSignal, ...params}: RequestConfig & GetSessionRequest,
  ): Promise<GetSessionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSession",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sessionId": "s",
        "messages": [toMessage],
        "interpretations": [toInterpretation],
        "sessionState": toSessionState,
      },
    }, await resp.json());
  }

  async putSession(
    {abortSignal, ...params}: RequestConfig & PutSessionRequest,
  ): Promise<PutSessionResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      messages: params["messages"]?.map(x => fromMessage(x)),
      sessionState: fromSessionState(params["sessionState"]),
      requestAttributes: params["requestAttributes"],
    };
    if (params["responseContentType"] != null) headers.append("ResponseContentType", params["responseContentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSession",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}`,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    messages: resp.headers.get("x-amz-lex-messages"),
    sessionState: resp.headers.get("x-amz-lex-session-state"),
    requestAttributes: resp.headers.get("x-amz-lex-request-attributes"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async recognizeText(
    {abortSignal, ...params}: RequestConfig & RecognizeTextRequest,
  ): Promise<RecognizeTextResponse> {
    const body: jsonP.JSONObject = {
      text: params["text"],
      sessionState: fromSessionState(params["sessionState"]),
      requestAttributes: params["requestAttributes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecognizeText",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}/text`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "messages": [toMessage],
        "sessionState": toSessionState,
        "interpretations": [toInterpretation],
        "requestAttributes": x => jsonP.readMap(String, String, x),
        "sessionId": "s",
      },
    }, await resp.json());
  }

  async recognizeUtterance(
    {abortSignal, ...params}: RequestConfig & RecognizeUtteranceRequest,
  ): Promise<RecognizeUtteranceResponse> {
    const body = typeof params["inputStream"] === 'string' ? new TextEncoder().encode(params["inputStream"]) : params["inputStream"];
    const headers = new Headers;
    if (params["sessionState"] != null) headers.append("x-amz-lex-session-state", params["sessionState"]);
    if (params["requestAttributes"] != null) headers.append("x-amz-lex-request-attributes", params["requestAttributes"]);
    headers.append("Content-Type", params["requestContentType"]);
    if (params["responseContentType"] != null) headers.append("Response-Content-Type", params["responseContentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "RecognizeUtterance",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botAliases/${params["botAliasId"]}/botLocales/${params["localeId"]}/sessions/${params["sessionId"]}/utterance`,
    });
  return {
    inputMode: resp.headers.get("x-amz-lex-input-mode"),
    contentType: resp.headers.get("Content-Type"),
    messages: resp.headers.get("x-amz-lex-messages"),
    interpretations: resp.headers.get("x-amz-lex-interpretations"),
    sessionState: resp.headers.get("x-amz-lex-session-state"),
    requestAttributes: resp.headers.get("x-amz-lex-request-attributes"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    inputTranscript: resp.headers.get("x-amz-lex-input-transcript"),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

}

// refs: 1 - tags: named, input
export interface DeleteSessionRequest {
  botId: string;
  botAliasId: string;
  localeId: string;
  sessionId: string;
}

// refs: 1 - tags: named, input
export interface GetSessionRequest {
  botId: string;
  botAliasId: string;
  localeId: string;
  sessionId: string;
}

// refs: 1 - tags: named, input
export interface PutSessionRequest {
  botId: string;
  botAliasId: string;
  localeId: string;
  sessionId: string;
  messages?: Message[] | null;
  sessionState: SessionState;
  requestAttributes?: { [key: string]: string | null | undefined } | null;
  responseContentType?: string | null;
}

// refs: 1 - tags: named, input
export interface RecognizeTextRequest {
  botId: string;
  botAliasId: string;
  localeId: string;
  sessionId: string;
  text: string;
  sessionState?: SessionState | null;
  requestAttributes?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface RecognizeUtteranceRequest {
  botId: string;
  botAliasId: string;
  localeId: string;
  sessionId: string;
  sessionState?: string | null;
  requestAttributes?: string | null;
  requestContentType: string;
  responseContentType?: string | null;
  inputStream?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface DeleteSessionResponse {
  botId?: string | null;
  botAliasId?: string | null;
  localeId?: string | null;
  sessionId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSessionResponse {
  sessionId?: string | null;
  messages?: Message[] | null;
  interpretations?: Interpretation[] | null;
  sessionState?: SessionState | null;
}

// refs: 1 - tags: named, output
export interface PutSessionResponse {
  contentType?: string | null;
  messages?: string | null;
  sessionState?: string | null;
  requestAttributes?: string | null;
  sessionId?: string | null;
  audioStream?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface RecognizeTextResponse {
  messages?: Message[] | null;
  sessionState?: SessionState | null;
  interpretations?: Interpretation[] | null;
  requestAttributes?: { [key: string]: string | null | undefined } | null;
  sessionId?: string | null;
}

// refs: 1 - tags: named, output
export interface RecognizeUtteranceResponse {
  inputMode?: string | null;
  contentType?: string | null;
  messages?: string | null;
  interpretations?: string | null;
  sessionState?: string | null;
  requestAttributes?: string | null;
  sessionId?: string | null;
  inputTranscript?: string | null;
  audioStream?: Uint8Array | string | null;
}

// refs: 3 - tags: input, named, interface, output
export interface Message {
  content?: string | null;
  contentType?: MessageContentType | null;
  imageResponseCard?: ImageResponseCard | null;
}
function fromMessage(input?: Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    content: input["content"],
    contentType: input["contentType"],
    imageResponseCard: fromImageResponseCard(input["imageResponseCard"]),
  }
}
function toMessage(root: jsonP.JSONValue): Message {
  return jsonP.readObj({
    required: {},
    optional: {
      "content": "s",
      "contentType": (x: jsonP.JSONValue) => cmnP.readEnum<MessageContentType>(x),
      "imageResponseCard": toImageResponseCard,
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type MessageContentType =
| "CustomPayload"
| "ImageResponseCard"
| "PlainText"
| "SSML"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ImageResponseCard {
  title: string;
  subtitle?: string | null;
  imageUrl?: string | null;
  buttons?: Button[] | null;
}
function fromImageResponseCard(input?: ImageResponseCard | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    title: input["title"],
    subtitle: input["subtitle"],
    imageUrl: input["imageUrl"],
    buttons: input["buttons"]?.map(x => fromButton(x)),
  }
}
function toImageResponseCard(root: jsonP.JSONValue): ImageResponseCard {
  return jsonP.readObj({
    required: {
      "title": "s",
    },
    optional: {
      "subtitle": "s",
      "imageUrl": "s",
      "buttons": [toButton],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Button {
  text: string;
  value: string;
}
function fromButton(input?: Button | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    text: input["text"],
    value: input["value"],
  }
}
function toButton(root: jsonP.JSONValue): Button {
  return jsonP.readObj({
    required: {
      "text": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface SessionState {
  dialogAction?: DialogAction | null;
  intent?: Intent | null;
  activeContexts?: ActiveContext[] | null;
  sessionAttributes?: { [key: string]: string | null | undefined } | null;
  originatingRequestId?: string | null;
}
function fromSessionState(input?: SessionState | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dialogAction: fromDialogAction(input["dialogAction"]),
    intent: fromIntent(input["intent"]),
    activeContexts: input["activeContexts"]?.map(x => fromActiveContext(x)),
    sessionAttributes: input["sessionAttributes"],
    originatingRequestId: input["originatingRequestId"],
  }
}
function toSessionState(root: jsonP.JSONValue): SessionState {
  return jsonP.readObj({
    required: {},
    optional: {
      "dialogAction": toDialogAction,
      "intent": toIntent,
      "activeContexts": [toActiveContext],
      "sessionAttributes": x => jsonP.readMap(String, String, x),
      "originatingRequestId": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DialogAction {
  type: DialogActionType;
  slotToElicit?: string | null;
}
function fromDialogAction(input?: DialogAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    slotToElicit: input["slotToElicit"],
  }
}
function toDialogAction(root: jsonP.JSONValue): DialogAction {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<DialogActionType>(x),
    },
    optional: {
      "slotToElicit": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type DialogActionType =
| "Close"
| "ConfirmIntent"
| "Delegate"
| "ElicitIntent"
| "ElicitSlot"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Intent {
  name: string;
  slots?: { [key: string]: Slot | null | undefined } | null;
  state?: IntentState | null;
  confirmationState?: ConfirmationState | null;
}
function fromIntent(input?: Intent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    slots: jsonP.serializeMap(input["slots"], x => fromSlot(x)),
    state: input["state"],
    confirmationState: input["confirmationState"],
  }
}
function toIntent(root: jsonP.JSONValue): Intent {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "slots": x => jsonP.readMap(String, toSlot, x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<IntentState>(x),
      "confirmationState": (x: jsonP.JSONValue) => cmnP.readEnum<ConfirmationState>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Slot {
  value?: Value | null;
}
function fromSlot(input?: Slot | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: fromValue(input["value"]),
  }
}
function toSlot(root: jsonP.JSONValue): Slot {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": toValue,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Value {
  originalValue?: string | null;
  interpretedValue: string;
  resolvedValues?: string[] | null;
}
function fromValue(input?: Value | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    originalValue: input["originalValue"],
    interpretedValue: input["interpretedValue"],
    resolvedValues: input["resolvedValues"],
  }
}
function toValue(root: jsonP.JSONValue): Value {
  return jsonP.readObj({
    required: {
      "interpretedValue": "s",
    },
    optional: {
      "originalValue": "s",
      "resolvedValues": ["s"],
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type IntentState =
| "Failed"
| "Fulfilled"
| "InProgress"
| "ReadyForFulfillment"
| "Waiting"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ConfirmationState =
| "Confirmed"
| "Denied"
| "None"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ActiveContext {
  name: string;
  timeToLive: ActiveContextTimeToLive;
  contextAttributes?: { [key: string]: string | null | undefined } | null;
}
function fromActiveContext(input?: ActiveContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    timeToLive: fromActiveContextTimeToLive(input["timeToLive"]),
    contextAttributes: input["contextAttributes"],
  }
}
function toActiveContext(root: jsonP.JSONValue): ActiveContext {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timeToLive": toActiveContextTimeToLive,
    },
    optional: {
      "contextAttributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ActiveContextTimeToLive {
  timeToLiveInSeconds: number;
  turnsToLive: number;
}
function fromActiveContextTimeToLive(input?: ActiveContextTimeToLive | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeToLiveInSeconds: input["timeToLiveInSeconds"],
    turnsToLive: input["turnsToLive"],
  }
}
function toActiveContextTimeToLive(root: jsonP.JSONValue): ActiveContextTimeToLive {
  return jsonP.readObj({
    required: {
      "timeToLiveInSeconds": "n",
      "turnsToLive": "n",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Interpretation {
  nluConfidence?: ConfidenceScore | null;
  sentimentResponse?: SentimentResponse | null;
  intent?: Intent | null;
}
function toInterpretation(root: jsonP.JSONValue): Interpretation {
  return jsonP.readObj({
    required: {},
    optional: {
      "nluConfidence": toConfidenceScore,
      "sentimentResponse": toSentimentResponse,
      "intent": toIntent,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ConfidenceScore {
  score?: number | null;
}
function toConfidenceScore(root: jsonP.JSONValue): ConfidenceScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "score": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SentimentResponse {
  sentiment?: SentimentType | null;
  sentimentScore?: SentimentScore | null;
}
function toSentimentResponse(root: jsonP.JSONValue): SentimentResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "sentiment": (x: jsonP.JSONValue) => cmnP.readEnum<SentimentType>(x),
      "sentimentScore": toSentimentScore,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type SentimentType =
| "MIXED"
| "NEGATIVE"
| "NEUTRAL"
| "POSITIVE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SentimentScore {
  positive?: number | null;
  negative?: number | null;
  neutral?: number | null;
  mixed?: number | null;
}
function toSentimentScore(root: jsonP.JSONValue): SentimentScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "positive": "n",
      "negative": "n",
      "neutral": "n",
      "mixed": "n",
    },
  }, root);
}
