// Autogenerated API client for: Amazon Personalize

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Personalize {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Personalize.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-05-22",
    "endpointPrefix": "personalize",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Personalize",
    "serviceId": "Personalize",
    "signatureVersion": "v4",
    "signingName": "personalize",
    "targetPrefix": "AmazonPersonalize",
    "uid": "personalize-2018-05-22"
  };

  async createBatchInferenceJob(
    {abortSignal, ...params}: RequestConfig & CreateBatchInferenceJobRequest,
  ): Promise<CreateBatchInferenceJobResponse> {
    const body: jsonP.JSONObject = params ? {
      jobName: params["jobName"],
      solutionVersionArn: params["solutionVersionArn"],
      filterArn: params["filterArn"],
      numResults: params["numResults"],
      jobInput: fromBatchInferenceJobInput(params["jobInput"]),
      jobOutput: fromBatchInferenceJobOutput(params["jobOutput"]),
      roleArn: params["roleArn"],
      batchInferenceJobConfig: fromBatchInferenceJobConfig(params["batchInferenceJobConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBatchInferenceJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJobArn": "s",
      },
    }, await resp.json());
  }

  async createCampaign(
    {abortSignal, ...params}: RequestConfig & CreateCampaignRequest,
  ): Promise<CreateCampaignResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      solutionVersionArn: params["solutionVersionArn"],
      minProvisionedTPS: params["minProvisionedTPS"],
      campaignConfig: fromCampaignConfig(params["campaignConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaignArn": "s",
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & CreateDatasetRequest,
  ): Promise<CreateDatasetResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      schemaArn: params["schemaArn"],
      datasetGroupArn: params["datasetGroupArn"],
      datasetType: params["datasetType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDatasetGroupRequest,
  ): Promise<CreateDatasetGroupResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      roleArn: params["roleArn"],
      kmsKeyArn: params["kmsKeyArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroupArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & CreateDatasetImportJobRequest,
  ): Promise<CreateDatasetImportJobResponse> {
    const body: jsonP.JSONObject = params ? {
      jobName: params["jobName"],
      datasetArn: params["datasetArn"],
      dataSource: fromDataSource(params["dataSource"]),
      roleArn: params["roleArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJobArn": "s",
      },
    }, await resp.json());
  }

  async createEventTracker(
    {abortSignal, ...params}: RequestConfig & CreateEventTrackerRequest,
  ): Promise<CreateEventTrackerResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      datasetGroupArn: params["datasetGroupArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventTracker",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTrackerArn": "s",
        "trackingId": "s",
      },
    }, await resp.json());
  }

  async createFilter(
    {abortSignal, ...params}: RequestConfig & CreateFilterRequest,
  ): Promise<CreateFilterResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      datasetGroupArn: params["datasetGroupArn"],
      filterExpression: params["filterExpression"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "filterArn": "s",
      },
    }, await resp.json());
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & CreateSchemaRequest,
  ): Promise<CreateSchemaResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      schema: params["schema"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schemaArn": "s",
      },
    }, await resp.json());
  }

  async createSolution(
    {abortSignal, ...params}: RequestConfig & CreateSolutionRequest,
  ): Promise<CreateSolutionResponse> {
    const body: jsonP.JSONObject = params ? {
      name: params["name"],
      performHPO: params["performHPO"],
      performAutoML: params["performAutoML"],
      recipeArn: params["recipeArn"],
      datasetGroupArn: params["datasetGroupArn"],
      eventType: params["eventType"],
      solutionConfig: fromSolutionConfig(params["solutionConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSolution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionArn": "s",
      },
    }, await resp.json());
  }

  async createSolutionVersion(
    {abortSignal, ...params}: RequestConfig & CreateSolutionVersionRequest,
  ): Promise<CreateSolutionVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionArn: params["solutionArn"],
      trainingMode: params["trainingMode"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSolutionVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersionArn": "s",
      },
    }, await resp.json());
  }

  async deleteCampaign(
    {abortSignal, ...params}: RequestConfig & DeleteCampaignRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      campaignArn: params["campaignArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCampaign",
    });
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      datasetArn: params["datasetArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataset",
    });
  }

  async deleteDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetGroup",
    });
  }

  async deleteEventTracker(
    {abortSignal, ...params}: RequestConfig & DeleteEventTrackerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      eventTrackerArn: params["eventTrackerArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventTracker",
    });
  }

  async deleteFilter(
    {abortSignal, ...params}: RequestConfig & DeleteFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      filterArn: params["filterArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFilter",
    });
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & DeleteSchemaRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      schemaArn: params["schemaArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchema",
    });
  }

  async deleteSolution(
    {abortSignal, ...params}: RequestConfig & DeleteSolutionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      solutionArn: params["solutionArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSolution",
    });
  }

  async describeAlgorithm(
    {abortSignal, ...params}: RequestConfig & DescribeAlgorithmRequest,
  ): Promise<DescribeAlgorithmResponse> {
    const body: jsonP.JSONObject = params ? {
      algorithmArn: params["algorithmArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlgorithm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "algorithm": toAlgorithm,
      },
    }, await resp.json());
  }

  async describeBatchInferenceJob(
    {abortSignal, ...params}: RequestConfig & DescribeBatchInferenceJobRequest,
  ): Promise<DescribeBatchInferenceJobResponse> {
    const body: jsonP.JSONObject = params ? {
      batchInferenceJobArn: params["batchInferenceJobArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBatchInferenceJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJob": toBatchInferenceJob,
      },
    }, await resp.json());
  }

  async describeCampaign(
    {abortSignal, ...params}: RequestConfig & DescribeCampaignRequest,
  ): Promise<DescribeCampaignResponse> {
    const body: jsonP.JSONObject = params ? {
      campaignArn: params["campaignArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaign": toCampaign,
      },
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetRequest,
  ): Promise<DescribeDatasetResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetArn: params["datasetArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataset": toDataset,
      },
    }, await resp.json());
  }

  async describeDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetGroupRequest,
  ): Promise<DescribeDatasetGroupResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroup": toDatasetGroup,
      },
    }, await resp.json());
  }

  async describeDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetImportJobRequest,
  ): Promise<DescribeDatasetImportJobResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetImportJobArn: params["datasetImportJobArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJob": toDatasetImportJob,
      },
    }, await resp.json());
  }

  async describeEventTracker(
    {abortSignal, ...params}: RequestConfig & DescribeEventTrackerRequest,
  ): Promise<DescribeEventTrackerResponse> {
    const body: jsonP.JSONObject = params ? {
      eventTrackerArn: params["eventTrackerArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventTracker",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTracker": toEventTracker,
      },
    }, await resp.json());
  }

  async describeFeatureTransformation(
    {abortSignal, ...params}: RequestConfig & DescribeFeatureTransformationRequest,
  ): Promise<DescribeFeatureTransformationResponse> {
    const body: jsonP.JSONObject = params ? {
      featureTransformationArn: params["featureTransformationArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFeatureTransformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "featureTransformation": toFeatureTransformation,
      },
    }, await resp.json());
  }

  async describeFilter(
    {abortSignal, ...params}: RequestConfig & DescribeFilterRequest,
  ): Promise<DescribeFilterResponse> {
    const body: jsonP.JSONObject = params ? {
      filterArn: params["filterArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "filter": toFilter,
      },
    }, await resp.json());
  }

  async describeRecipe(
    {abortSignal, ...params}: RequestConfig & DescribeRecipeRequest,
  ): Promise<DescribeRecipeResponse> {
    const body: jsonP.JSONObject = params ? {
      recipeArn: params["recipeArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "recipe": toRecipe,
      },
    }, await resp.json());
  }

  async describeSchema(
    {abortSignal, ...params}: RequestConfig & DescribeSchemaRequest,
  ): Promise<DescribeSchemaResponse> {
    const body: jsonP.JSONObject = params ? {
      schemaArn: params["schemaArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schema": toDatasetSchema,
      },
    }, await resp.json());
  }

  async describeSolution(
    {abortSignal, ...params}: RequestConfig & DescribeSolutionRequest,
  ): Promise<DescribeSolutionResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionArn: params["solutionArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSolution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solution": toSolution,
      },
    }, await resp.json());
  }

  async describeSolutionVersion(
    {abortSignal, ...params}: RequestConfig & DescribeSolutionVersionRequest,
  ): Promise<DescribeSolutionVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionVersionArn: params["solutionVersionArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSolutionVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersion": toSolutionVersion,
      },
    }, await resp.json());
  }

  async getSolutionMetrics(
    {abortSignal, ...params}: RequestConfig & GetSolutionMetricsRequest,
  ): Promise<GetSolutionMetricsResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionVersionArn: params["solutionVersionArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSolutionMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersionArn": "s",
        "metrics": x => jsonP.readMap(String, Number, x),
      },
    }, await resp.json());
  }

  async listBatchInferenceJobs(
    {abortSignal, ...params}: RequestConfig & ListBatchInferenceJobsRequest = {},
  ): Promise<ListBatchInferenceJobsResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionVersionArn: params["solutionVersionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBatchInferenceJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJobs": [toBatchInferenceJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCampaigns(
    {abortSignal, ...params}: RequestConfig & ListCampaignsRequest = {},
  ): Promise<ListCampaignsResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionArn: params["solutionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCampaigns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaigns": [toCampaignSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetGroups(
    {abortSignal, ...params}: RequestConfig & ListDatasetGroupsRequest = {},
  ): Promise<ListDatasetGroupsResponse> {
    const body: jsonP.JSONObject = params ? {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroups": [toDatasetGroupSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetImportJobs(
    {abortSignal, ...params}: RequestConfig & ListDatasetImportJobsRequest = {},
  ): Promise<ListDatasetImportJobsResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetArn: params["datasetArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetImportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJobs": [toDatasetImportJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & ListDatasetsRequest = {},
  ): Promise<ListDatasetsResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasets": [toDatasetSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listEventTrackers(
    {abortSignal, ...params}: RequestConfig & ListEventTrackersRequest = {},
  ): Promise<ListEventTrackersResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEventTrackers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTrackers": [toEventTrackerSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFilters(
    {abortSignal, ...params}: RequestConfig & ListFiltersRequest = {},
  ): Promise<ListFiltersResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFilters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Filters": [toFilterSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipes(
    {abortSignal, ...params}: RequestConfig & ListRecipesRequest = {},
  ): Promise<ListRecipesResponse> {
    const body: jsonP.JSONObject = params ? {
      recipeProvider: params["recipeProvider"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRecipes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "recipes": [toRecipeSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemas(
    {abortSignal, ...params}: RequestConfig & ListSchemasRequest = {},
  ): Promise<ListSchemasResponse> {
    const body: jsonP.JSONObject = params ? {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schemas": [toDatasetSchemaSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSolutionVersions(
    {abortSignal, ...params}: RequestConfig & ListSolutionVersionsRequest = {},
  ): Promise<ListSolutionVersionsResponse> {
    const body: jsonP.JSONObject = params ? {
      solutionArn: params["solutionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSolutionVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersions": [toSolutionVersionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSolutions(
    {abortSignal, ...params}: RequestConfig & ListSolutionsRequest = {},
  ): Promise<ListSolutionsResponse> {
    const body: jsonP.JSONObject = params ? {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSolutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutions": [toSolutionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async updateCampaign(
    {abortSignal, ...params}: RequestConfig & UpdateCampaignRequest,
  ): Promise<UpdateCampaignResponse> {
    const body: jsonP.JSONObject = params ? {
      campaignArn: params["campaignArn"],
      solutionVersionArn: params["solutionVersionArn"],
      minProvisionedTPS: params["minProvisionedTPS"],
      campaignConfig: fromCampaignConfig(params["campaignConfig"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaignArn": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateBatchInferenceJobRequest {
  jobName: string;
  solutionVersionArn: string;
  filterArn?: string | null;
  numResults?: number | null;
  jobInput: BatchInferenceJobInput;
  jobOutput: BatchInferenceJobOutput;
  roleArn: string;
  batchInferenceJobConfig?: BatchInferenceJobConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateCampaignRequest {
  name: string;
  solutionVersionArn: string;
  minProvisionedTPS: number;
  campaignConfig?: CampaignConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetRequest {
  name: string;
  schemaArn: string;
  datasetGroupArn: string;
  datasetType: string;
}

// refs: 1 - tags: named, input
export interface CreateDatasetGroupRequest {
  name: string;
  roleArn?: string | null;
  kmsKeyArn?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetImportJobRequest {
  jobName: string;
  datasetArn: string;
  dataSource: DataSource;
  roleArn: string;
}

// refs: 1 - tags: named, input
export interface CreateEventTrackerRequest {
  name: string;
  datasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface CreateFilterRequest {
  name: string;
  datasetGroupArn: string;
  filterExpression: string;
}

// refs: 1 - tags: named, input
export interface CreateSchemaRequest {
  name: string;
  schema: string;
}

// refs: 1 - tags: named, input
export interface CreateSolutionRequest {
  name: string;
  performHPO?: boolean | null;
  performAutoML?: boolean | null;
  recipeArn?: string | null;
  datasetGroupArn: string;
  eventType?: string | null;
  solutionConfig?: SolutionConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateSolutionVersionRequest {
  solutionArn: string;
  trainingMode?: TrainingMode | null;
}

// refs: 1 - tags: named, input
export interface DeleteCampaignRequest {
  campaignArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetRequest {
  datasetArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetGroupRequest {
  datasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventTrackerRequest {
  eventTrackerArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteFilterRequest {
  filterArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteSchemaRequest {
  schemaArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteSolutionRequest {
  solutionArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeAlgorithmRequest {
  algorithmArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeBatchInferenceJobRequest {
  batchInferenceJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeCampaignRequest {
  campaignArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetRequest {
  datasetArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetGroupRequest {
  datasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetImportJobRequest {
  datasetImportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeEventTrackerRequest {
  eventTrackerArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeFeatureTransformationRequest {
  featureTransformationArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeFilterRequest {
  filterArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeRecipeRequest {
  recipeArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeSchemaRequest {
  schemaArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeSolutionRequest {
  solutionArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeSolutionVersionRequest {
  solutionVersionArn: string;
}

// refs: 1 - tags: named, input
export interface GetSolutionMetricsRequest {
  solutionVersionArn: string;
}

// refs: 1 - tags: named, input
export interface ListBatchInferenceJobsRequest {
  solutionVersionArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListCampaignsRequest {
  solutionArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetGroupsRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetImportJobsRequest {
  datasetArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetsRequest {
  datasetGroupArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListEventTrackersRequest {
  datasetGroupArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListFiltersRequest {
  datasetGroupArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRecipesRequest {
  recipeProvider?: RecipeProvider | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSchemasRequest {
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSolutionVersionsRequest {
  solutionArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSolutionsRequest {
  datasetGroupArn?: string | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateCampaignRequest {
  campaignArn: string;
  solutionVersionArn?: string | null;
  minProvisionedTPS?: number | null;
  campaignConfig?: CampaignConfig | null;
}

// refs: 1 - tags: named, output
export interface CreateBatchInferenceJobResponse {
  batchInferenceJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCampaignResponse {
  campaignArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetResponse {
  datasetArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetGroupResponse {
  datasetGroupArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetImportJobResponse {
  datasetImportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateEventTrackerResponse {
  eventTrackerArn?: string | null;
  trackingId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateFilterResponse {
  filterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSchemaResponse {
  schemaArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSolutionResponse {
  solutionArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSolutionVersionResponse {
  solutionVersionArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeAlgorithmResponse {
  algorithm?: Algorithm | null;
}

// refs: 1 - tags: named, output
export interface DescribeBatchInferenceJobResponse {
  batchInferenceJob?: BatchInferenceJob | null;
}

// refs: 1 - tags: named, output
export interface DescribeCampaignResponse {
  campaign?: Campaign | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetResponse {
  dataset?: Dataset | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetGroupResponse {
  datasetGroup?: DatasetGroup | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetImportJobResponse {
  datasetImportJob?: DatasetImportJob | null;
}

// refs: 1 - tags: named, output
export interface DescribeEventTrackerResponse {
  eventTracker?: EventTracker | null;
}

// refs: 1 - tags: named, output
export interface DescribeFeatureTransformationResponse {
  featureTransformation?: FeatureTransformation | null;
}

// refs: 1 - tags: named, output
export interface DescribeFilterResponse {
  filter?: Filter | null;
}

// refs: 1 - tags: named, output
export interface DescribeRecipeResponse {
  recipe?: Recipe | null;
}

// refs: 1 - tags: named, output
export interface DescribeSchemaResponse {
  schema?: DatasetSchema | null;
}

// refs: 1 - tags: named, output
export interface DescribeSolutionResponse {
  solution?: Solution | null;
}

// refs: 1 - tags: named, output
export interface DescribeSolutionVersionResponse {
  solutionVersion?: SolutionVersion | null;
}

// refs: 1 - tags: named, output
export interface GetSolutionMetricsResponse {
  solutionVersionArn?: string | null;
  metrics?: { [key: string]: number | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListBatchInferenceJobsResponse {
  batchInferenceJobs?: BatchInferenceJobSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCampaignsResponse {
  campaigns?: CampaignSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetGroupsResponse {
  datasetGroups?: DatasetGroupSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetImportJobsResponse {
  datasetImportJobs?: DatasetImportJobSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetsResponse {
  datasets?: DatasetSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListEventTrackersResponse {
  eventTrackers?: EventTrackerSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFiltersResponse {
  Filters?: FilterSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRecipesResponse {
  recipes?: RecipeSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSchemasResponse {
  schemas?: DatasetSchemaSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSolutionVersionsResponse {
  solutionVersions?: SolutionVersionSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSolutionsResponse {
  solutions?: SolutionSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateCampaignResponse {
  campaignArn?: string | null;
}

// refs: 2 - tags: input, named, interface, output
export interface BatchInferenceJobInput {
  s3DataSource: S3DataConfig;
}
function fromBatchInferenceJobInput(input?: BatchInferenceJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3DataSource: fromS3DataConfig(input["s3DataSource"]),
  }
}
function toBatchInferenceJobInput(root: jsonP.JSONValue): BatchInferenceJobInput {
  return jsonP.readObj({
    required: {
      "s3DataSource": toS3DataConfig,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface S3DataConfig {
  path: string;
  kmsKeyArn?: string | null;
}
function fromS3DataConfig(input?: S3DataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
    kmsKeyArn: input["kmsKeyArn"],
  }
}
function toS3DataConfig(root: jsonP.JSONValue): S3DataConfig {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {
      "kmsKeyArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BatchInferenceJobOutput {
  s3DataDestination: S3DataConfig;
}
function fromBatchInferenceJobOutput(input?: BatchInferenceJobOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3DataDestination: fromS3DataConfig(input["s3DataDestination"]),
  }
}
function toBatchInferenceJobOutput(root: jsonP.JSONValue): BatchInferenceJobOutput {
  return jsonP.readObj({
    required: {
      "s3DataDestination": toS3DataConfig,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BatchInferenceJobConfig {
  itemExplorationConfig?: { [key: string]: string | null | undefined } | null;
}
function fromBatchInferenceJobConfig(input?: BatchInferenceJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    itemExplorationConfig: input["itemExplorationConfig"],
  }
}
function toBatchInferenceJobConfig(root: jsonP.JSONValue): BatchInferenceJobConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "itemExplorationConfig": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface CampaignConfig {
  itemExplorationConfig?: { [key: string]: string | null | undefined } | null;
}
function fromCampaignConfig(input?: CampaignConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    itemExplorationConfig: input["itemExplorationConfig"],
  }
}
function toCampaignConfig(root: jsonP.JSONValue): CampaignConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "itemExplorationConfig": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DataSource {
  dataLocation?: string | null;
}
function fromDataSource(input?: DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataLocation: input["dataLocation"],
  }
}
function toDataSource(root: jsonP.JSONValue): DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "dataLocation": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SolutionConfig {
  eventValueThreshold?: string | null;
  hpoConfig?: HPOConfig | null;
  algorithmHyperParameters?: { [key: string]: string | null | undefined } | null;
  featureTransformationParameters?: { [key: string]: string | null | undefined } | null;
  autoMLConfig?: AutoMLConfig | null;
}
function fromSolutionConfig(input?: SolutionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventValueThreshold: input["eventValueThreshold"],
    hpoConfig: fromHPOConfig(input["hpoConfig"]),
    algorithmHyperParameters: input["algorithmHyperParameters"],
    featureTransformationParameters: input["featureTransformationParameters"],
    autoMLConfig: fromAutoMLConfig(input["autoMLConfig"]),
  }
}
function toSolutionConfig(root: jsonP.JSONValue): SolutionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventValueThreshold": "s",
      "hpoConfig": toHPOConfig,
      "algorithmHyperParameters": x => jsonP.readMap(String, String, x),
      "featureTransformationParameters": x => jsonP.readMap(String, String, x),
      "autoMLConfig": toAutoMLConfig,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HPOConfig {
  hpoObjective?: HPOObjective | null;
  hpoResourceConfig?: HPOResourceConfig | null;
  algorithmHyperParameterRanges?: HyperParameterRanges | null;
}
function fromHPOConfig(input?: HPOConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hpoObjective: fromHPOObjective(input["hpoObjective"]),
    hpoResourceConfig: fromHPOResourceConfig(input["hpoResourceConfig"]),
    algorithmHyperParameterRanges: fromHyperParameterRanges(input["algorithmHyperParameterRanges"]),
  }
}
function toHPOConfig(root: jsonP.JSONValue): HPOConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "hpoObjective": toHPOObjective,
      "hpoResourceConfig": toHPOResourceConfig,
      "algorithmHyperParameterRanges": toHyperParameterRanges,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HPOObjective {
  type?: string | null;
  metricName?: string | null;
  metricRegex?: string | null;
}
function fromHPOObjective(input?: HPOObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    metricName: input["metricName"],
    metricRegex: input["metricRegex"],
  }
}
function toHPOObjective(root: jsonP.JSONValue): HPOObjective {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": "s",
      "metricName": "s",
      "metricRegex": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HPOResourceConfig {
  maxNumberOfTrainingJobs?: string | null;
  maxParallelTrainingJobs?: string | null;
}
function fromHPOResourceConfig(input?: HPOResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxNumberOfTrainingJobs: input["maxNumberOfTrainingJobs"],
    maxParallelTrainingJobs: input["maxParallelTrainingJobs"],
  }
}
function toHPOResourceConfig(root: jsonP.JSONValue): HPOResourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "maxNumberOfTrainingJobs": "s",
      "maxParallelTrainingJobs": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface HyperParameterRanges {
  integerHyperParameterRanges?: IntegerHyperParameterRange[] | null;
  continuousHyperParameterRanges?: ContinuousHyperParameterRange[] | null;
  categoricalHyperParameterRanges?: CategoricalHyperParameterRange[] | null;
}
function fromHyperParameterRanges(input?: HyperParameterRanges | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    integerHyperParameterRanges: input["integerHyperParameterRanges"]?.map(x => fromIntegerHyperParameterRange(x)),
    continuousHyperParameterRanges: input["continuousHyperParameterRanges"]?.map(x => fromContinuousHyperParameterRange(x)),
    categoricalHyperParameterRanges: input["categoricalHyperParameterRanges"]?.map(x => fromCategoricalHyperParameterRange(x)),
  }
}
function toHyperParameterRanges(root: jsonP.JSONValue): HyperParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "integerHyperParameterRanges": [toIntegerHyperParameterRange],
      "continuousHyperParameterRanges": [toContinuousHyperParameterRange],
      "categoricalHyperParameterRanges": [toCategoricalHyperParameterRange],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface IntegerHyperParameterRange {
  name?: string | null;
  minValue?: number | null;
  maxValue?: number | null;
}
function fromIntegerHyperParameterRange(input?: IntegerHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    minValue: input["minValue"],
    maxValue: input["maxValue"],
  }
}
function toIntegerHyperParameterRange(root: jsonP.JSONValue): IntegerHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ContinuousHyperParameterRange {
  name?: string | null;
  minValue?: number | null;
  maxValue?: number | null;
}
function fromContinuousHyperParameterRange(input?: ContinuousHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    minValue: input["minValue"],
    maxValue: input["maxValue"],
  }
}
function toContinuousHyperParameterRange(root: jsonP.JSONValue): ContinuousHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CategoricalHyperParameterRange {
  name?: string | null;
  values?: string[] | null;
}
function fromCategoricalHyperParameterRange(input?: CategoricalHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}
function toCategoricalHyperParameterRange(root: jsonP.JSONValue): CategoricalHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "values": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface AutoMLConfig {
  metricName?: string | null;
  recipeList?: string[] | null;
}
function fromAutoMLConfig(input?: AutoMLConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metricName: input["metricName"],
    recipeList: input["recipeList"],
  }
}
function toAutoMLConfig(root: jsonP.JSONValue): AutoMLConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "metricName": "s",
      "recipeList": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type TrainingMode =
| "FULL"
| "UPDATE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type RecipeProvider =
| "SERVICE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Algorithm {
  name?: string | null;
  algorithmArn?: string | null;
  algorithmImage?: AlgorithmImage | null;
  defaultHyperParameters?: { [key: string]: string | null | undefined } | null;
  defaultHyperParameterRanges?: DefaultHyperParameterRanges | null;
  defaultResourceConfig?: { [key: string]: string | null | undefined } | null;
  trainingInputMode?: string | null;
  roleArn?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toAlgorithm(root: jsonP.JSONValue): Algorithm {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "algorithmArn": "s",
      "algorithmImage": toAlgorithmImage,
      "defaultHyperParameters": x => jsonP.readMap(String, String, x),
      "defaultHyperParameterRanges": toDefaultHyperParameterRanges,
      "defaultResourceConfig": x => jsonP.readMap(String, String, x),
      "trainingInputMode": "s",
      "roleArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AlgorithmImage {
  name?: string | null;
  dockerURI: string;
}
function toAlgorithmImage(root: jsonP.JSONValue): AlgorithmImage {
  return jsonP.readObj({
    required: {
      "dockerURI": "s",
    },
    optional: {
      "name": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DefaultHyperParameterRanges {
  integerHyperParameterRanges?: DefaultIntegerHyperParameterRange[] | null;
  continuousHyperParameterRanges?: DefaultContinuousHyperParameterRange[] | null;
  categoricalHyperParameterRanges?: DefaultCategoricalHyperParameterRange[] | null;
}
function toDefaultHyperParameterRanges(root: jsonP.JSONValue): DefaultHyperParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "integerHyperParameterRanges": [toDefaultIntegerHyperParameterRange],
      "continuousHyperParameterRanges": [toDefaultContinuousHyperParameterRange],
      "categoricalHyperParameterRanges": [toDefaultCategoricalHyperParameterRange],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DefaultIntegerHyperParameterRange {
  name?: string | null;
  minValue?: number | null;
  maxValue?: number | null;
  isTunable?: boolean | null;
}
function toDefaultIntegerHyperParameterRange(root: jsonP.JSONValue): DefaultIntegerHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
      "isTunable": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DefaultContinuousHyperParameterRange {
  name?: string | null;
  minValue?: number | null;
  maxValue?: number | null;
  isTunable?: boolean | null;
}
function toDefaultContinuousHyperParameterRange(root: jsonP.JSONValue): DefaultContinuousHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
      "isTunable": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DefaultCategoricalHyperParameterRange {
  name?: string | null;
  values?: string[] | null;
  isTunable?: boolean | null;
}
function toDefaultCategoricalHyperParameterRange(root: jsonP.JSONValue): DefaultCategoricalHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "values": ["s"],
      "isTunable": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchInferenceJob {
  jobName?: string | null;
  batchInferenceJobArn?: string | null;
  filterArn?: string | null;
  failureReason?: string | null;
  solutionVersionArn?: string | null;
  numResults?: number | null;
  jobInput?: BatchInferenceJobInput | null;
  jobOutput?: BatchInferenceJobOutput | null;
  batchInferenceJobConfig?: BatchInferenceJobConfig | null;
  roleArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toBatchInferenceJob(root: jsonP.JSONValue): BatchInferenceJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobName": "s",
      "batchInferenceJobArn": "s",
      "filterArn": "s",
      "failureReason": "s",
      "solutionVersionArn": "s",
      "numResults": "n",
      "jobInput": toBatchInferenceJobInput,
      "jobOutput": toBatchInferenceJobOutput,
      "batchInferenceJobConfig": toBatchInferenceJobConfig,
      "roleArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Campaign {
  name?: string | null;
  campaignArn?: string | null;
  solutionVersionArn?: string | null;
  minProvisionedTPS?: number | null;
  campaignConfig?: CampaignConfig | null;
  status?: string | null;
  failureReason?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  latestCampaignUpdate?: CampaignUpdateSummary | null;
}
function toCampaign(root: jsonP.JSONValue): Campaign {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "campaignArn": "s",
      "solutionVersionArn": "s",
      "minProvisionedTPS": "n",
      "campaignConfig": toCampaignConfig,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "latestCampaignUpdate": toCampaignUpdateSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CampaignUpdateSummary {
  solutionVersionArn?: string | null;
  minProvisionedTPS?: number | null;
  campaignConfig?: CampaignConfig | null;
  status?: string | null;
  failureReason?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toCampaignUpdateSummary(root: jsonP.JSONValue): CampaignUpdateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "minProvisionedTPS": "n",
      "campaignConfig": toCampaignConfig,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Dataset {
  name?: string | null;
  datasetArn?: string | null;
  datasetGroupArn?: string | null;
  datasetType?: string | null;
  schemaArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toDataset(root: jsonP.JSONValue): Dataset {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetArn": "s",
      "datasetGroupArn": "s",
      "datasetType": "s",
      "schemaArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetGroup {
  name?: string | null;
  datasetGroupArn?: string | null;
  status?: string | null;
  roleArn?: string | null;
  kmsKeyArn?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toDatasetGroup(root: jsonP.JSONValue): DatasetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "roleArn": "s",
      "kmsKeyArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetImportJob {
  jobName?: string | null;
  datasetImportJobArn?: string | null;
  datasetArn?: string | null;
  dataSource?: DataSource | null;
  roleArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toDatasetImportJob(root: jsonP.JSONValue): DatasetImportJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobName": "s",
      "datasetImportJobArn": "s",
      "datasetArn": "s",
      "dataSource": toDataSource,
      "roleArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EventTracker {
  name?: string | null;
  eventTrackerArn?: string | null;
  accountId?: string | null;
  trackingId?: string | null;
  datasetGroupArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toEventTracker(root: jsonP.JSONValue): EventTracker {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "eventTrackerArn": "s",
      "accountId": "s",
      "trackingId": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FeatureTransformation {
  name?: string | null;
  featureTransformationArn?: string | null;
  defaultParameters?: { [key: string]: string | null | undefined } | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  status?: string | null;
}
function toFeatureTransformation(root: jsonP.JSONValue): FeatureTransformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "featureTransformationArn": "s",
      "defaultParameters": x => jsonP.readMap(String, String, x),
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "status": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Filter {
  name?: string | null;
  filterArn?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  datasetGroupArn?: string | null;
  failureReason?: string | null;
  filterExpression?: string | null;
  status?: string | null;
}
function toFilter(root: jsonP.JSONValue): Filter {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "filterArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "datasetGroupArn": "s",
      "failureReason": "s",
      "filterExpression": "s",
      "status": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Recipe {
  name?: string | null;
  recipeArn?: string | null;
  algorithmArn?: string | null;
  featureTransformationArn?: string | null;
  status?: string | null;
  description?: string | null;
  creationDateTime?: Date | number | null;
  recipeType?: string | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toRecipe(root: jsonP.JSONValue): Recipe {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "recipeArn": "s",
      "algorithmArn": "s",
      "featureTransformationArn": "s",
      "status": "s",
      "description": "s",
      "creationDateTime": "d",
      "recipeType": "s",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSchema {
  name?: string | null;
  schemaArn?: string | null;
  schema?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toDatasetSchema(root: jsonP.JSONValue): DatasetSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "schemaArn": "s",
      "schema": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Solution {
  name?: string | null;
  solutionArn?: string | null;
  performHPO?: boolean | null;
  performAutoML?: boolean | null;
  recipeArn?: string | null;
  datasetGroupArn?: string | null;
  eventType?: string | null;
  solutionConfig?: SolutionConfig | null;
  autoMLResult?: AutoMLResult | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  latestSolutionVersion?: SolutionVersionSummary | null;
}
function toSolution(root: jsonP.JSONValue): Solution {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "solutionArn": "s",
      "performHPO": "b",
      "performAutoML": "b",
      "recipeArn": "s",
      "datasetGroupArn": "s",
      "eventType": "s",
      "solutionConfig": toSolutionConfig,
      "autoMLResult": toAutoMLResult,
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "latestSolutionVersion": toSolutionVersionSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AutoMLResult {
  bestRecipeArn?: string | null;
}
function toAutoMLResult(root: jsonP.JSONValue): AutoMLResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "bestRecipeArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SolutionVersionSummary {
  solutionVersionArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toSolutionVersionSummary(root: jsonP.JSONValue): SolutionVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SolutionVersion {
  solutionVersionArn?: string | null;
  solutionArn?: string | null;
  performHPO?: boolean | null;
  performAutoML?: boolean | null;
  recipeArn?: string | null;
  eventType?: string | null;
  datasetGroupArn?: string | null;
  solutionConfig?: SolutionConfig | null;
  trainingHours?: number | null;
  trainingMode?: TrainingMode | null;
  tunedHPOParams?: TunedHPOParams | null;
  status?: string | null;
  failureReason?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toSolutionVersion(root: jsonP.JSONValue): SolutionVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "solutionArn": "s",
      "performHPO": "b",
      "performAutoML": "b",
      "recipeArn": "s",
      "eventType": "s",
      "datasetGroupArn": "s",
      "solutionConfig": toSolutionConfig,
      "trainingHours": "n",
      "trainingMode": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingMode>(x),
      "tunedHPOParams": toTunedHPOParams,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TunedHPOParams {
  algorithmHyperParameters?: { [key: string]: string | null | undefined } | null;
}
function toTunedHPOParams(root: jsonP.JSONValue): TunedHPOParams {
  return jsonP.readObj({
    required: {},
    optional: {
      "algorithmHyperParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchInferenceJobSummary {
  batchInferenceJobArn?: string | null;
  jobName?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
  solutionVersionArn?: string | null;
}
function toBatchInferenceJobSummary(root: jsonP.JSONValue): BatchInferenceJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "batchInferenceJobArn": "s",
      "jobName": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
      "solutionVersionArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CampaignSummary {
  name?: string | null;
  campaignArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toCampaignSummary(root: jsonP.JSONValue): CampaignSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "campaignArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetGroupSummary {
  name?: string | null;
  datasetGroupArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toDatasetGroupSummary(root: jsonP.JSONValue): DatasetGroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetImportJobSummary {
  datasetImportJobArn?: string | null;
  jobName?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  failureReason?: string | null;
}
function toDatasetImportJobSummary(root: jsonP.JSONValue): DatasetImportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datasetImportJobArn": "s",
      "jobName": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSummary {
  name?: string | null;
  datasetArn?: string | null;
  datasetType?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toDatasetSummary(root: jsonP.JSONValue): DatasetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetArn": "s",
      "datasetType": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EventTrackerSummary {
  name?: string | null;
  eventTrackerArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toEventTrackerSummary(root: jsonP.JSONValue): EventTrackerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "eventTrackerArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FilterSummary {
  name?: string | null;
  filterArn?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
  datasetGroupArn?: string | null;
  failureReason?: string | null;
  status?: string | null;
}
function toFilterSummary(root: jsonP.JSONValue): FilterSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "filterArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "datasetGroupArn": "s",
      "failureReason": "s",
      "status": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RecipeSummary {
  name?: string | null;
  recipeArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toRecipeSummary(root: jsonP.JSONValue): RecipeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "recipeArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSchemaSummary {
  name?: string | null;
  schemaArn?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toDatasetSchemaSummary(root: jsonP.JSONValue): DatasetSchemaSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "schemaArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SolutionSummary {
  name?: string | null;
  solutionArn?: string | null;
  status?: string | null;
  creationDateTime?: Date | number | null;
  lastUpdatedDateTime?: Date | number | null;
}
function toSolutionSummary(root: jsonP.JSONValue): SolutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "solutionArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}
