// Autogenerated API client for: Amazon Personalize

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class Personalize {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Personalize.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-05-22",
    "endpointPrefix": "personalize",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Personalize",
    "serviceId": "Personalize",
    "signatureVersion": "v4",
    "signingName": "personalize",
    "targetPrefix": "AmazonPersonalize",
    "uid": "personalize-2018-05-22"
  };

  async createBatchInferenceJob(
    {abortSignal, ...params}: RequestConfig & s.CreateBatchInferenceJobRequest,
  ): Promise<s.CreateBatchInferenceJobResponse> {
    const body: jsonP.JSONObject = {
      jobName: params["jobName"],
      solutionVersionArn: params["solutionVersionArn"],
      filterArn: params["filterArn"],
      numResults: params["numResults"],
      jobInput: fromBatchInferenceJobInput(params["jobInput"]),
      jobOutput: fromBatchInferenceJobOutput(params["jobOutput"]),
      roleArn: params["roleArn"],
      batchInferenceJobConfig: fromBatchInferenceJobConfig(params["batchInferenceJobConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBatchInferenceJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJobArn": "s",
      },
    }, await resp.json());
  }

  async createCampaign(
    {abortSignal, ...params}: RequestConfig & s.CreateCampaignRequest,
  ): Promise<s.CreateCampaignResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      solutionVersionArn: params["solutionVersionArn"],
      minProvisionedTPS: params["minProvisionedTPS"],
      campaignConfig: fromCampaignConfig(params["campaignConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaignArn": "s",
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetRequest,
  ): Promise<s.CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      schemaArn: params["schemaArn"],
      datasetGroupArn: params["datasetGroupArn"],
      datasetType: params["datasetType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetGroupRequest,
  ): Promise<s.CreateDatasetGroupResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      roleArn: params["roleArn"],
      kmsKeyArn: params["kmsKeyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroupArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetImportJobRequest,
  ): Promise<s.CreateDatasetImportJobResponse> {
    const body: jsonP.JSONObject = {
      jobName: params["jobName"],
      datasetArn: params["datasetArn"],
      dataSource: fromDataSource(params["dataSource"]),
      roleArn: params["roleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJobArn": "s",
      },
    }, await resp.json());
  }

  async createEventTracker(
    {abortSignal, ...params}: RequestConfig & s.CreateEventTrackerRequest,
  ): Promise<s.CreateEventTrackerResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      datasetGroupArn: params["datasetGroupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventTracker",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTrackerArn": "s",
        "trackingId": "s",
      },
    }, await resp.json());
  }

  async createFilter(
    {abortSignal, ...params}: RequestConfig & s.CreateFilterRequest,
  ): Promise<s.CreateFilterResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      datasetGroupArn: params["datasetGroupArn"],
      filterExpression: params["filterExpression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "filterArn": "s",
      },
    }, await resp.json());
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & s.CreateSchemaRequest,
  ): Promise<s.CreateSchemaResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      schema: params["schema"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schemaArn": "s",
      },
    }, await resp.json());
  }

  async createSolution(
    {abortSignal, ...params}: RequestConfig & s.CreateSolutionRequest,
  ): Promise<s.CreateSolutionResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      performHPO: params["performHPO"],
      performAutoML: params["performAutoML"],
      recipeArn: params["recipeArn"],
      datasetGroupArn: params["datasetGroupArn"],
      eventType: params["eventType"],
      solutionConfig: fromSolutionConfig(params["solutionConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSolution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionArn": "s",
      },
    }, await resp.json());
  }

  async createSolutionVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateSolutionVersionRequest,
  ): Promise<s.CreateSolutionVersionResponse> {
    const body: jsonP.JSONObject = {
      solutionArn: params["solutionArn"],
      trainingMode: params["trainingMode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSolutionVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersionArn": "s",
      },
    }, await resp.json());
  }

  async deleteCampaign(
    {abortSignal, ...params}: RequestConfig & s.DeleteCampaignRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      campaignArn: params["campaignArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCampaign",
    });
    await resp.text();
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      datasetArn: params["datasetArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataset",
    });
    await resp.text();
  }

  async deleteDatasetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetGroup",
    });
    await resp.text();
  }

  async deleteEventTracker(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventTrackerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      eventTrackerArn: params["eventTrackerArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventTracker",
    });
    await resp.text();
  }

  async deleteFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteFilterRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      filterArn: params["filterArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFilter",
    });
    await resp.text();
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & s.DeleteSchemaRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      schemaArn: params["schemaArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchema",
    });
    await resp.text();
  }

  async deleteSolution(
    {abortSignal, ...params}: RequestConfig & s.DeleteSolutionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      solutionArn: params["solutionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSolution",
    });
    await resp.text();
  }

  async describeAlgorithm(
    {abortSignal, ...params}: RequestConfig & s.DescribeAlgorithmRequest,
  ): Promise<s.DescribeAlgorithmResponse> {
    const body: jsonP.JSONObject = {
      algorithmArn: params["algorithmArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlgorithm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "algorithm": toAlgorithm,
      },
    }, await resp.json());
  }

  async describeBatchInferenceJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeBatchInferenceJobRequest,
  ): Promise<s.DescribeBatchInferenceJobResponse> {
    const body: jsonP.JSONObject = {
      batchInferenceJobArn: params["batchInferenceJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBatchInferenceJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJob": toBatchInferenceJob,
      },
    }, await resp.json());
  }

  async describeCampaign(
    {abortSignal, ...params}: RequestConfig & s.DescribeCampaignRequest,
  ): Promise<s.DescribeCampaignResponse> {
    const body: jsonP.JSONObject = {
      campaignArn: params["campaignArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaign": toCampaign,
      },
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetRequest,
  ): Promise<s.DescribeDatasetResponse> {
    const body: jsonP.JSONObject = {
      datasetArn: params["datasetArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "dataset": toDataset,
      },
    }, await resp.json());
  }

  async describeDatasetGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetGroupRequest,
  ): Promise<s.DescribeDatasetGroupResponse> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroup": toDatasetGroup,
      },
    }, await resp.json());
  }

  async describeDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetImportJobRequest,
  ): Promise<s.DescribeDatasetImportJobResponse> {
    const body: jsonP.JSONObject = {
      datasetImportJobArn: params["datasetImportJobArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJob": toDatasetImportJob,
      },
    }, await resp.json());
  }

  async describeEventTracker(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventTrackerRequest,
  ): Promise<s.DescribeEventTrackerResponse> {
    const body: jsonP.JSONObject = {
      eventTrackerArn: params["eventTrackerArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventTracker",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTracker": toEventTracker,
      },
    }, await resp.json());
  }

  async describeFeatureTransformation(
    {abortSignal, ...params}: RequestConfig & s.DescribeFeatureTransformationRequest,
  ): Promise<s.DescribeFeatureTransformationResponse> {
    const body: jsonP.JSONObject = {
      featureTransformationArn: params["featureTransformationArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFeatureTransformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "featureTransformation": toFeatureTransformation,
      },
    }, await resp.json());
  }

  async describeFilter(
    {abortSignal, ...params}: RequestConfig & s.DescribeFilterRequest,
  ): Promise<s.DescribeFilterResponse> {
    const body: jsonP.JSONObject = {
      filterArn: params["filterArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFilter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "filter": toFilter,
      },
    }, await resp.json());
  }

  async describeRecipe(
    {abortSignal, ...params}: RequestConfig & s.DescribeRecipeRequest,
  ): Promise<s.DescribeRecipeResponse> {
    const body: jsonP.JSONObject = {
      recipeArn: params["recipeArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRecipe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "recipe": toRecipe,
      },
    }, await resp.json());
  }

  async describeSchema(
    {abortSignal, ...params}: RequestConfig & s.DescribeSchemaRequest,
  ): Promise<s.DescribeSchemaResponse> {
    const body: jsonP.JSONObject = {
      schemaArn: params["schemaArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schema": toDatasetSchema,
      },
    }, await resp.json());
  }

  async describeSolution(
    {abortSignal, ...params}: RequestConfig & s.DescribeSolutionRequest,
  ): Promise<s.DescribeSolutionResponse> {
    const body: jsonP.JSONObject = {
      solutionArn: params["solutionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSolution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solution": toSolution,
      },
    }, await resp.json());
  }

  async describeSolutionVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribeSolutionVersionRequest,
  ): Promise<s.DescribeSolutionVersionResponse> {
    const body: jsonP.JSONObject = {
      solutionVersionArn: params["solutionVersionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSolutionVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersion": toSolutionVersion,
      },
    }, await resp.json());
  }

  async getSolutionMetrics(
    {abortSignal, ...params}: RequestConfig & s.GetSolutionMetricsRequest,
  ): Promise<s.GetSolutionMetricsResponse> {
    const body: jsonP.JSONObject = {
      solutionVersionArn: params["solutionVersionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSolutionMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersionArn": "s",
        "metrics": x => jsonP.readMap(String, Number, x),
      },
    }, await resp.json());
  }

  async listBatchInferenceJobs(
    {abortSignal, ...params}: RequestConfig & s.ListBatchInferenceJobsRequest = {},
  ): Promise<s.ListBatchInferenceJobsResponse> {
    const body: jsonP.JSONObject = {
      solutionVersionArn: params["solutionVersionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBatchInferenceJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "batchInferenceJobs": [toBatchInferenceJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCampaigns(
    {abortSignal, ...params}: RequestConfig & s.ListCampaignsRequest = {},
  ): Promise<s.ListCampaignsResponse> {
    const body: jsonP.JSONObject = {
      solutionArn: params["solutionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCampaigns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaigns": [toCampaignSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetGroups(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetGroupsRequest = {},
  ): Promise<s.ListDatasetGroupsResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetGroups": [toDatasetGroupSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetImportJobs(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetImportJobsRequest = {},
  ): Promise<s.ListDatasetImportJobsResponse> {
    const body: jsonP.JSONObject = {
      datasetArn: params["datasetArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetImportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasetImportJobs": [toDatasetImportJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetsRequest = {},
  ): Promise<s.ListDatasetsResponse> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "datasets": [toDatasetSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listEventTrackers(
    {abortSignal, ...params}: RequestConfig & s.ListEventTrackersRequest = {},
  ): Promise<s.ListEventTrackersResponse> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEventTrackers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTrackers": [toEventTrackerSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFilters(
    {abortSignal, ...params}: RequestConfig & s.ListFiltersRequest = {},
  ): Promise<s.ListFiltersResponse> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFilters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Filters": [toFilterSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipes(
    {abortSignal, ...params}: RequestConfig & s.ListRecipesRequest = {},
  ): Promise<s.ListRecipesResponse> {
    const body: jsonP.JSONObject = {
      recipeProvider: params["recipeProvider"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRecipes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "recipes": [toRecipeSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemas(
    {abortSignal, ...params}: RequestConfig & s.ListSchemasRequest = {},
  ): Promise<s.ListSchemasResponse> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "schemas": [toDatasetSchemaSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSolutionVersions(
    {abortSignal, ...params}: RequestConfig & s.ListSolutionVersionsRequest = {},
  ): Promise<s.ListSolutionVersionsResponse> {
    const body: jsonP.JSONObject = {
      solutionArn: params["solutionArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSolutionVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutionVersions": [toSolutionVersionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSolutions(
    {abortSignal, ...params}: RequestConfig & s.ListSolutionsRequest = {},
  ): Promise<s.ListSolutionsResponse> {
    const body: jsonP.JSONObject = {
      datasetGroupArn: params["datasetGroupArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSolutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "solutions": [toSolutionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async updateCampaign(
    {abortSignal, ...params}: RequestConfig & s.UpdateCampaignRequest,
  ): Promise<s.UpdateCampaignResponse> {
    const body: jsonP.JSONObject = {
      campaignArn: params["campaignArn"],
      solutionVersionArn: params["solutionVersionArn"],
      minProvisionedTPS: params["minProvisionedTPS"],
      campaignConfig: fromCampaignConfig(params["campaignConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCampaign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "campaignArn": "s",
      },
    }, await resp.json());
  }

}

function fromBatchInferenceJobInput(input?: s.BatchInferenceJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3DataSource: fromS3DataConfig(input["s3DataSource"]),
  }
}
function toBatchInferenceJobInput(root: jsonP.JSONValue): s.BatchInferenceJobInput {
  return jsonP.readObj({
    required: {
      "s3DataSource": toS3DataConfig,
    },
    optional: {},
  }, root);
}

function fromS3DataConfig(input?: s.S3DataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
    kmsKeyArn: input["kmsKeyArn"],
  }
}
function toS3DataConfig(root: jsonP.JSONValue): s.S3DataConfig {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {
      "kmsKeyArn": "s",
    },
  }, root);
}

function fromBatchInferenceJobOutput(input?: s.BatchInferenceJobOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3DataDestination: fromS3DataConfig(input["s3DataDestination"]),
  }
}
function toBatchInferenceJobOutput(root: jsonP.JSONValue): s.BatchInferenceJobOutput {
  return jsonP.readObj({
    required: {
      "s3DataDestination": toS3DataConfig,
    },
    optional: {},
  }, root);
}

function fromBatchInferenceJobConfig(input?: s.BatchInferenceJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    itemExplorationConfig: input["itemExplorationConfig"],
  }
}
function toBatchInferenceJobConfig(root: jsonP.JSONValue): s.BatchInferenceJobConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "itemExplorationConfig": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromCampaignConfig(input?: s.CampaignConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    itemExplorationConfig: input["itemExplorationConfig"],
  }
}
function toCampaignConfig(root: jsonP.JSONValue): s.CampaignConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "itemExplorationConfig": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromDataSource(input?: s.DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataLocation: input["dataLocation"],
  }
}
function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "dataLocation": "s",
    },
  }, root);
}

function fromSolutionConfig(input?: s.SolutionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventValueThreshold: input["eventValueThreshold"],
    hpoConfig: fromHPOConfig(input["hpoConfig"]),
    algorithmHyperParameters: input["algorithmHyperParameters"],
    featureTransformationParameters: input["featureTransformationParameters"],
    autoMLConfig: fromAutoMLConfig(input["autoMLConfig"]),
  }
}
function toSolutionConfig(root: jsonP.JSONValue): s.SolutionConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventValueThreshold": "s",
      "hpoConfig": toHPOConfig,
      "algorithmHyperParameters": x => jsonP.readMap(String, String, x),
      "featureTransformationParameters": x => jsonP.readMap(String, String, x),
      "autoMLConfig": toAutoMLConfig,
    },
  }, root);
}

function fromHPOConfig(input?: s.HPOConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hpoObjective: fromHPOObjective(input["hpoObjective"]),
    hpoResourceConfig: fromHPOResourceConfig(input["hpoResourceConfig"]),
    algorithmHyperParameterRanges: fromHyperParameterRanges(input["algorithmHyperParameterRanges"]),
  }
}
function toHPOConfig(root: jsonP.JSONValue): s.HPOConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "hpoObjective": toHPOObjective,
      "hpoResourceConfig": toHPOResourceConfig,
      "algorithmHyperParameterRanges": toHyperParameterRanges,
    },
  }, root);
}

function fromHPOObjective(input?: s.HPOObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    metricName: input["metricName"],
    metricRegex: input["metricRegex"],
  }
}
function toHPOObjective(root: jsonP.JSONValue): s.HPOObjective {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": "s",
      "metricName": "s",
      "metricRegex": "s",
    },
  }, root);
}

function fromHPOResourceConfig(input?: s.HPOResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxNumberOfTrainingJobs: input["maxNumberOfTrainingJobs"],
    maxParallelTrainingJobs: input["maxParallelTrainingJobs"],
  }
}
function toHPOResourceConfig(root: jsonP.JSONValue): s.HPOResourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "maxNumberOfTrainingJobs": "s",
      "maxParallelTrainingJobs": "s",
    },
  }, root);
}

function fromHyperParameterRanges(input?: s.HyperParameterRanges | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    integerHyperParameterRanges: input["integerHyperParameterRanges"]?.map(x => fromIntegerHyperParameterRange(x)),
    continuousHyperParameterRanges: input["continuousHyperParameterRanges"]?.map(x => fromContinuousHyperParameterRange(x)),
    categoricalHyperParameterRanges: input["categoricalHyperParameterRanges"]?.map(x => fromCategoricalHyperParameterRange(x)),
  }
}
function toHyperParameterRanges(root: jsonP.JSONValue): s.HyperParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "integerHyperParameterRanges": [toIntegerHyperParameterRange],
      "continuousHyperParameterRanges": [toContinuousHyperParameterRange],
      "categoricalHyperParameterRanges": [toCategoricalHyperParameterRange],
    },
  }, root);
}

function fromIntegerHyperParameterRange(input?: s.IntegerHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    minValue: input["minValue"],
    maxValue: input["maxValue"],
  }
}
function toIntegerHyperParameterRange(root: jsonP.JSONValue): s.IntegerHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
    },
  }, root);
}

function fromContinuousHyperParameterRange(input?: s.ContinuousHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    minValue: input["minValue"],
    maxValue: input["maxValue"],
  }
}
function toContinuousHyperParameterRange(root: jsonP.JSONValue): s.ContinuousHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
    },
  }, root);
}

function fromCategoricalHyperParameterRange(input?: s.CategoricalHyperParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}
function toCategoricalHyperParameterRange(root: jsonP.JSONValue): s.CategoricalHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "values": ["s"],
    },
  }, root);
}

function fromAutoMLConfig(input?: s.AutoMLConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metricName: input["metricName"],
    recipeList: input["recipeList"],
  }
}
function toAutoMLConfig(root: jsonP.JSONValue): s.AutoMLConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "metricName": "s",
      "recipeList": ["s"],
    },
  }, root);
}

function toAlgorithm(root: jsonP.JSONValue): s.Algorithm {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "algorithmArn": "s",
      "algorithmImage": toAlgorithmImage,
      "defaultHyperParameters": x => jsonP.readMap(String, String, x),
      "defaultHyperParameterRanges": toDefaultHyperParameterRanges,
      "defaultResourceConfig": x => jsonP.readMap(String, String, x),
      "trainingInputMode": "s",
      "roleArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toAlgorithmImage(root: jsonP.JSONValue): s.AlgorithmImage {
  return jsonP.readObj({
    required: {
      "dockerURI": "s",
    },
    optional: {
      "name": "s",
    },
  }, root);
}

function toDefaultHyperParameterRanges(root: jsonP.JSONValue): s.DefaultHyperParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "integerHyperParameterRanges": [toDefaultIntegerHyperParameterRange],
      "continuousHyperParameterRanges": [toDefaultContinuousHyperParameterRange],
      "categoricalHyperParameterRanges": [toDefaultCategoricalHyperParameterRange],
    },
  }, root);
}

function toDefaultIntegerHyperParameterRange(root: jsonP.JSONValue): s.DefaultIntegerHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
      "isTunable": "b",
    },
  }, root);
}

function toDefaultContinuousHyperParameterRange(root: jsonP.JSONValue): s.DefaultContinuousHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "minValue": "n",
      "maxValue": "n",
      "isTunable": "b",
    },
  }, root);
}

function toDefaultCategoricalHyperParameterRange(root: jsonP.JSONValue): s.DefaultCategoricalHyperParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "values": ["s"],
      "isTunable": "b",
    },
  }, root);
}

function toBatchInferenceJob(root: jsonP.JSONValue): s.BatchInferenceJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobName": "s",
      "batchInferenceJobArn": "s",
      "filterArn": "s",
      "failureReason": "s",
      "solutionVersionArn": "s",
      "numResults": "n",
      "jobInput": toBatchInferenceJobInput,
      "jobOutput": toBatchInferenceJobOutput,
      "batchInferenceJobConfig": toBatchInferenceJobConfig,
      "roleArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toCampaign(root: jsonP.JSONValue): s.Campaign {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "campaignArn": "s",
      "solutionVersionArn": "s",
      "minProvisionedTPS": "n",
      "campaignConfig": toCampaignConfig,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "latestCampaignUpdate": toCampaignUpdateSummary,
    },
  }, root);
}

function toCampaignUpdateSummary(root: jsonP.JSONValue): s.CampaignUpdateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "minProvisionedTPS": "n",
      "campaignConfig": toCampaignConfig,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toDataset(root: jsonP.JSONValue): s.Dataset {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetArn": "s",
      "datasetGroupArn": "s",
      "datasetType": "s",
      "schemaArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toDatasetGroup(root: jsonP.JSONValue): s.DatasetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "roleArn": "s",
      "kmsKeyArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toDatasetImportJob(root: jsonP.JSONValue): s.DatasetImportJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobName": "s",
      "datasetImportJobArn": "s",
      "datasetArn": "s",
      "dataSource": toDataSource,
      "roleArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toEventTracker(root: jsonP.JSONValue): s.EventTracker {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "eventTrackerArn": "s",
      "accountId": "s",
      "trackingId": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toFeatureTransformation(root: jsonP.JSONValue): s.FeatureTransformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "featureTransformationArn": "s",
      "defaultParameters": x => jsonP.readMap(String, String, x),
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "status": "s",
    },
  }, root);
}

function toFilter(root: jsonP.JSONValue): s.Filter {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "filterArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "datasetGroupArn": "s",
      "failureReason": "s",
      "filterExpression": "s",
      "status": "s",
    },
  }, root);
}

function toRecipe(root: jsonP.JSONValue): s.Recipe {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "recipeArn": "s",
      "algorithmArn": "s",
      "featureTransformationArn": "s",
      "status": "s",
      "description": "s",
      "creationDateTime": "d",
      "recipeType": "s",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toDatasetSchema(root: jsonP.JSONValue): s.DatasetSchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "schemaArn": "s",
      "schema": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toSolution(root: jsonP.JSONValue): s.Solution {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "solutionArn": "s",
      "performHPO": "b",
      "performAutoML": "b",
      "recipeArn": "s",
      "datasetGroupArn": "s",
      "eventType": "s",
      "solutionConfig": toSolutionConfig,
      "autoMLResult": toAutoMLResult,
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "latestSolutionVersion": toSolutionVersionSummary,
    },
  }, root);
}

function toAutoMLResult(root: jsonP.JSONValue): s.AutoMLResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "bestRecipeArn": "s",
    },
  }, root);
}

function toSolutionVersionSummary(root: jsonP.JSONValue): s.SolutionVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toSolutionVersion(root: jsonP.JSONValue): s.SolutionVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "solutionVersionArn": "s",
      "solutionArn": "s",
      "performHPO": "b",
      "performAutoML": "b",
      "recipeArn": "s",
      "eventType": "s",
      "datasetGroupArn": "s",
      "solutionConfig": toSolutionConfig,
      "trainingHours": "n",
      "trainingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingMode>(x),
      "tunedHPOParams": toTunedHPOParams,
      "status": "s",
      "failureReason": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toTunedHPOParams(root: jsonP.JSONValue): s.TunedHPOParams {
  return jsonP.readObj({
    required: {},
    optional: {
      "algorithmHyperParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toBatchInferenceJobSummary(root: jsonP.JSONValue): s.BatchInferenceJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "batchInferenceJobArn": "s",
      "jobName": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
      "solutionVersionArn": "s",
    },
  }, root);
}

function toCampaignSummary(root: jsonP.JSONValue): s.CampaignSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "campaignArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toDatasetGroupSummary(root: jsonP.JSONValue): s.DatasetGroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetGroupArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toDatasetImportJobSummary(root: jsonP.JSONValue): s.DatasetImportJobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "datasetImportJobArn": "s",
      "jobName": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "failureReason": "s",
    },
  }, root);
}

function toDatasetSummary(root: jsonP.JSONValue): s.DatasetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "datasetArn": "s",
      "datasetType": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toEventTrackerSummary(root: jsonP.JSONValue): s.EventTrackerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "eventTrackerArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toFilterSummary(root: jsonP.JSONValue): s.FilterSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "filterArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
      "datasetGroupArn": "s",
      "failureReason": "s",
      "status": "s",
    },
  }, root);
}

function toRecipeSummary(root: jsonP.JSONValue): s.RecipeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "recipeArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toDatasetSchemaSummary(root: jsonP.JSONValue): s.DatasetSchemaSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "schemaArn": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toSolutionSummary(root: jsonP.JSONValue): s.SolutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "solutionArn": "s",
      "status": "s",
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}
