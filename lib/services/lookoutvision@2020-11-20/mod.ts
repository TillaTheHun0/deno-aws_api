// Autogenerated API client for: Amazon Lookout for Vision

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class LookoutVision {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LookoutVision.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-11-20",
    "endpointPrefix": "lookoutvision",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Lookout for Vision",
    "serviceId": "LookoutVision",
    "signatureVersion": "v4",
    "signingName": "lookoutvision",
    "uid": "lookoutvision-2020-11-20"
  };

  async createDataset(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetRequest,
  ): Promise<s.CreateDatasetResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      DatasetType: params["DatasetType"],
      DatasetSource: fromDatasetSource(params["DatasetSource"]),
    };
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateDataset",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/datasets`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetMetadata": toDatasetMetadata,
      },
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & s.CreateModelRequest,
  ): Promise<s.CreateModelResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateModel",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelMetadata": toModelMetadata,
      },
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectRequest,
  ): Promise<s.CreateProjectResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ProjectName: params["ProjectName"],
    };
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateProject",
      requestUri: "/2020-11-20/projects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectMetadata": toProjectMetadata,
      },
    }, await resp.json());
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDataset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/datasets/${params["DatasetType"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelRequest,
  ): Promise<s.DeleteModelResponse> {
    const headers = new Headers;
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteModel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models/${params["ModelVersion"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelArn": "s",
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectRequest,
  ): Promise<s.DeleteProjectResponse> {
    const headers = new Headers;
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteProject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectArn": "s",
      },
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetRequest,
  ): Promise<s.DescribeDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataset",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/datasets/${params["DatasetType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetDescription": toDatasetDescription,
      },
    }, await resp.json());
  }

  async describeModel(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelRequest,
  ): Promise<s.DescribeModelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeModel",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models/${params["ModelVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelDescription": toModelDescription,
      },
    }, await resp.json());
  }

  async describeProject(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectRequest,
  ): Promise<s.DescribeProjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProject",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectDescription": toProjectDescription,
      },
    }, await resp.json());
  }

  async detectAnomalies(
    {abortSignal, ...params}: RequestConfig & s.DetectAnomaliesRequest,
  ): Promise<s.DetectAnomaliesResponse> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    headers.append("Content-Type", params["ContentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "DetectAnomalies",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models/${params["ModelVersion"]}/detect`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DetectAnomalyResult": toDetectAnomalyResult,
      },
    }, await resp.json());
  }

  async listDatasetEntries(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetEntriesRequest,
  ): Promise<s.ListDatasetEntriesResponse> {
    const query = new URLSearchParams;
    if (params["Labeled"] != null) query.set("labeled", params["Labeled"]?.toString() ?? "");
    if (params["AnomalyClass"] != null) query.set("anomalyClass", params["AnomalyClass"]?.toString() ?? "");
    if (params["BeforeCreationDate"] != null) query.set("createdBefore", cmnP.serializeDate_iso8601(params["BeforeCreationDate"]) ?? "");
    if (params["AfterCreationDate"] != null) query.set("createdAfter", cmnP.serializeDate_iso8601(params["AfterCreationDate"]) ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["SourceRefContains"] != null) query.set("sourceRefContains", params["SourceRefContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasetEntries",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/datasets/${params["DatasetType"]}/entries`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DatasetEntries": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModels(
    {abortSignal, ...params}: RequestConfig & s.ListModelsRequest,
  ): Promise<s.ListModelsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListModels",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Models": [toModelMetadata],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & s.ListProjectsRequest = {},
  ): Promise<s.ListProjectsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProjects",
      method: "GET",
      requestUri: "/2020-11-20/projects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Projects": [toProjectMetadata],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-11-20/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async startModel(
    {abortSignal, ...params}: RequestConfig & s.StartModelRequest,
  ): Promise<s.StartModelResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      MinInferenceUnits: params["MinInferenceUnits"],
    };
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "StartModel",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models/${params["ModelVersion"]}/start`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelHostingStatus>(x),
      },
    }, await resp.json());
  }

  async stopModel(
    {abortSignal, ...params}: RequestConfig & s.StopModelRequest,
  ): Promise<s.StopModelResponse> {
    const headers = new Headers;
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "StopModel",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/models/${params["ModelVersion"]}/stop`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelHostingStatus>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/2020-11-20/tags/${params["ResourceArn"]}`,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-11-20/tags/${params["ResourceArn"]}`,
    });
    await resp.text();
  }

  async updateDatasetEntries(
    {abortSignal, ...params}: RequestConfig & s.UpdateDatasetEntriesRequest,
  ): Promise<s.UpdateDatasetEntriesResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Changes: serializeBlob(params["Changes"]),
    };
    if (params["ClientToken"] != null) headers.append("X-Amzn-Client-Token", params["ClientToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDatasetEntries",
      method: "PATCH",
      requestUri: cmnP.encodePath`/2020-11-20/projects/${params["ProjectName"]}/datasets/${params["DatasetType"]}/entries`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetStatus>(x),
      },
    }, await resp.json());
  }

}

function fromDatasetSource(input?: s.DatasetSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroundTruthManifest: fromDatasetGroundTruthManifest(input["GroundTruthManifest"]),
  }
}

function fromDatasetGroundTruthManifest(input?: s.DatasetGroundTruthManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Object: fromInputS3Object(input["S3Object"]),
  }
}

function fromInputS3Object(input?: s.InputS3Object | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
    VersionId: input["VersionId"],
  }
}

function fromOutputConfig(input?: s.OutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Location: fromS3Location(input["S3Location"]),
  }
}
function toOutputConfig(root: jsonP.JSONValue): s.OutputConfig {
  return jsonP.readObj({
    required: {
      "S3Location": toS3Location,
    },
    optional: {},
  }, root);
}

function fromS3Location(input?: s.S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Prefix: input["Prefix"],
  }
}
function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
    },
    optional: {
      "Prefix": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function toDatasetMetadata(root: jsonP.JSONValue): s.DatasetMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatasetType": "s",
      "CreationTimestamp": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetStatus>(x),
      "StatusMessage": "s",
    },
  }, root);
}

function toModelMetadata(root: jsonP.JSONValue): s.ModelMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationTimestamp": "d",
      "ModelVersion": "s",
      "ModelArn": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelStatus>(x),
      "StatusMessage": "s",
      "Performance": toModelPerformance,
    },
  }, root);
}

function toModelPerformance(root: jsonP.JSONValue): s.ModelPerformance {
  return jsonP.readObj({
    required: {},
    optional: {
      "F1Score": "n",
      "Recall": "n",
      "Precision": "n",
    },
  }, root);
}

function toProjectMetadata(root: jsonP.JSONValue): s.ProjectMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectArn": "s",
      "ProjectName": "s",
      "CreationTimestamp": "d",
    },
  }, root);
}

function toDatasetDescription(root: jsonP.JSONValue): s.DatasetDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectName": "s",
      "DatasetType": "s",
      "CreationTimestamp": "d",
      "LastUpdatedTimestamp": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatasetStatus>(x),
      "StatusMessage": "s",
      "ImageStats": toDatasetImageStats,
    },
  }, root);
}

function toDatasetImageStats(root: jsonP.JSONValue): s.DatasetImageStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "Total": "n",
      "Labeled": "n",
      "Normal": "n",
      "Anomaly": "n",
    },
  }, root);
}

function toModelDescription(root: jsonP.JSONValue): s.ModelDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelVersion": "s",
      "ModelArn": "s",
      "CreationTimestamp": "d",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelStatus>(x),
      "StatusMessage": "s",
      "Performance": toModelPerformance,
      "OutputConfig": toOutputConfig,
      "EvaluationManifest": toOutputS3Object,
      "EvaluationResult": toOutputS3Object,
      "EvaluationEndTimestamp": "d",
      "KmsKeyId": "s",
    },
  }, root);
}

function toOutputS3Object(root: jsonP.JSONValue): s.OutputS3Object {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
      "Key": "s",
    },
    optional: {},
  }, root);
}

function toProjectDescription(root: jsonP.JSONValue): s.ProjectDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectArn": "s",
      "ProjectName": "s",
      "CreationTimestamp": "d",
      "Datasets": [toDatasetMetadata],
    },
  }, root);
}

function toDetectAnomalyResult(root: jsonP.JSONValue): s.DetectAnomalyResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Source": toImageSource,
      "IsAnomalous": "b",
      "Confidence": "n",
    },
  }, root);
}

function toImageSource(root: jsonP.JSONValue): s.ImageSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
    },
  }, root);
}
