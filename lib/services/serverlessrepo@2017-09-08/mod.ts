// Autogenerated API client for: AWSServerlessApplicationRepository

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ServerlessApplicationRepository {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ServerlessApplicationRepository.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-09-08",
    "endpointPrefix": "serverlessrepo",
    "signingName": "serverlessrepo",
    "serviceFullName": "AWSServerlessApplicationRepository",
    "serviceId": "ServerlessApplicationRepository",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "serverlessrepo-2017-09-08",
    "signatureVersion": "v4"
  };

  async createApplication(
    {abortSignal, ...params}: RequestConfig & CreateApplicationRequest,
  ): Promise<CreateApplicationResponse> {
    const body: jsonP.JSONObject = params ? {
      author: params["Author"],
      description: params["Description"],
      homePageUrl: params["HomePageUrl"],
      labels: params["Labels"],
      licenseBody: params["LicenseBody"],
      licenseUrl: params["LicenseUrl"],
      name: params["Name"],
      readmeBody: params["ReadmeBody"],
      readmeUrl: params["ReadmeUrl"],
      semanticVersion: params["SemanticVersion"],
      sourceCodeArchiveUrl: params["SourceCodeArchiveUrl"],
      sourceCodeUrl: params["SourceCodeUrl"],
      spdxLicenseId: params["SpdxLicenseId"],
      templateBody: params["TemplateBody"],
      templateUrl: params["TemplateUrl"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
      requestUri: "/applications",
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "Author": "s",
          "CreationTime": "s",
          "Description": "s",
          "HomePageUrl": "s",
          "IsVerifiedAuthor": "b",
          "Labels": ["s"],
          "LicenseUrl": "s",
          "Name": "s",
          "ReadmeUrl": "s",
          "SpdxLicenseId": "s",
          "VerifiedAuthorUrl": "s",
          "Version": toVersion,
        },
      }, await resp.json()),
  };
  }

  async createApplicationVersion(
    {abortSignal, ...params}: RequestConfig & CreateApplicationVersionRequest,
  ): Promise<CreateApplicationVersionResponse> {
    const body: jsonP.JSONObject = params ? {
      sourceCodeArchiveUrl: params["SourceCodeArchiveUrl"],
      sourceCodeUrl: params["SourceCodeUrl"],
      templateBody: params["TemplateBody"],
      templateUrl: params["TemplateUrl"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplicationVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/versions/${params["SemanticVersion"]}`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "CreationTime": "s",
          "ParameterDefinitions": [toParameterDefinition],
          "RequiredCapabilities": [(x: jsonP.JSONValue) => cmnP.readEnum<Capability>(x)],
          "ResourcesSupported": "b",
          "SemanticVersion": "s",
          "SourceCodeArchiveUrl": "s",
          "SourceCodeUrl": "s",
          "TemplateUrl": "s",
        },
      }, await resp.json()),
  };
  }

  async createCloudFormationChangeSet(
    {abortSignal, ...params}: RequestConfig & CreateCloudFormationChangeSetRequest,
  ): Promise<CreateCloudFormationChangeSetResponse> {
    const body: jsonP.JSONObject = params ? {
      capabilities: params["Capabilities"],
      changeSetName: params["ChangeSetName"],
      clientToken: params["ClientToken"],
      description: params["Description"],
      notificationArns: params["NotificationArns"],
      parameterOverrides: params["ParameterOverrides"]?.map(x => fromParameterValue(x)),
      resourceTypes: params["ResourceTypes"],
      rollbackConfiguration: fromRollbackConfiguration(params["RollbackConfiguration"]),
      semanticVersion: params["SemanticVersion"],
      stackName: params["StackName"],
      tags: params["Tags"]?.map(x => fromTag(x)),
      templateId: params["TemplateId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFormationChangeSet",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/changesets`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "ChangeSetId": "s",
          "SemanticVersion": "s",
          "StackId": "s",
        },
      }, await resp.json()),
  };
  }

  async createCloudFormationTemplate(
    {abortSignal, ...params}: RequestConfig & CreateCloudFormationTemplateRequest,
  ): Promise<CreateCloudFormationTemplateResponse> {
    const body: jsonP.JSONObject = params ? {
      semanticVersion: params["SemanticVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFormationTemplate",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/templates`,
      responseCode: 201,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "CreationTime": "s",
          "ExpirationTime": "s",
          "SemanticVersion": "s",
          "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
          "TemplateId": "s",
          "TemplateUrl": "s",
        },
      }, await resp.json()),
  };
  }

  async deleteApplication(
    {abortSignal, ...params}: RequestConfig & DeleteApplicationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApplication",
      method: "DELETE",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}`,
      responseCode: 204,
    });
  }

  async getApplication(
    {abortSignal, ...params}: RequestConfig & GetApplicationRequest,
  ): Promise<GetApplicationResponse> {
    const query = new URLSearchParams;
    if (params["SemanticVersion"] != null) query.set("semanticVersion", params["SemanticVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApplication",
      method: "GET",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "Author": "s",
          "CreationTime": "s",
          "Description": "s",
          "HomePageUrl": "s",
          "IsVerifiedAuthor": "b",
          "Labels": ["s"],
          "LicenseUrl": "s",
          "Name": "s",
          "ReadmeUrl": "s",
          "SpdxLicenseId": "s",
          "VerifiedAuthorUrl": "s",
          "Version": toVersion,
        },
      }, await resp.json()),
  };
  }

  async getApplicationPolicy(
    {abortSignal, ...params}: RequestConfig & GetApplicationPolicyRequest,
  ): Promise<GetApplicationPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApplicationPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/policy`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Statements": [toApplicationPolicyStatement],
        },
      }, await resp.json()),
  };
  }

  async getCloudFormationTemplate(
    {abortSignal, ...params}: RequestConfig & GetCloudFormationTemplateRequest,
  ): Promise<GetCloudFormationTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFormationTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/templates/${params["TemplateId"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "CreationTime": "s",
          "ExpirationTime": "s",
          "SemanticVersion": "s",
          "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
          "TemplateId": "s",
          "TemplateUrl": "s",
        },
      }, await resp.json()),
  };
  }

  async listApplicationDependencies(
    {abortSignal, ...params}: RequestConfig & ListApplicationDependenciesRequest,
  ): Promise<ListApplicationDependenciesResponse> {
    const query = new URLSearchParams;
    if (params["MaxItems"] != null) query.set("maxItems", params["MaxItems"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["SemanticVersion"] != null) query.set("semanticVersion", params["SemanticVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListApplicationDependencies",
      method: "GET",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/dependencies`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Dependencies": [toApplicationDependencySummary],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listApplicationVersions(
    {abortSignal, ...params}: RequestConfig & ListApplicationVersionsRequest,
  ): Promise<ListApplicationVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxItems"] != null) query.set("maxItems", params["MaxItems"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListApplicationVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/versions`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "NextToken": "s",
          "Versions": [toVersionSummary],
        },
      }, await resp.json()),
  };
  }

  async listApplications(
    {abortSignal, ...params}: RequestConfig & ListApplicationsRequest = {},
  ): Promise<ListApplicationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxItems"] != null) query.set("maxItems", params["MaxItems"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListApplications",
      method: "GET",
      requestUri: "/applications",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Applications": [toApplicationSummary],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async putApplicationPolicy(
    {abortSignal, ...params}: RequestConfig & PutApplicationPolicyRequest,
  ): Promise<PutApplicationPolicyResponse> {
    const body: jsonP.JSONObject = params ? {
      statements: params["Statements"]?.map(x => fromApplicationPolicyStatement(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutApplicationPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/policy`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Statements": [toApplicationPolicyStatement],
        },
      }, await resp.json()),
  };
  }

  async unshareApplication(
    {abortSignal, ...params}: RequestConfig & UnshareApplicationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      organizationId: params["OrganizationId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnshareApplication",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}/unshare`,
      responseCode: 204,
    });
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & UpdateApplicationRequest,
  ): Promise<UpdateApplicationResponse> {
    const body: jsonP.JSONObject = params ? {
      author: params["Author"],
      description: params["Description"],
      homePageUrl: params["HomePageUrl"],
      labels: params["Labels"],
      readmeBody: params["ReadmeBody"],
      readmeUrl: params["ReadmeUrl"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
      method: "PATCH",
      requestUri: cmnP.encodePath`/applications/${params["ApplicationId"]}`,
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ApplicationId": "s",
          "Author": "s",
          "CreationTime": "s",
          "Description": "s",
          "HomePageUrl": "s",
          "IsVerifiedAuthor": "b",
          "Labels": ["s"],
          "LicenseUrl": "s",
          "Name": "s",
          "ReadmeUrl": "s",
          "SpdxLicenseId": "s",
          "VerifiedAuthorUrl": "s",
          "Version": toVersion,
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CreateApplicationRequest {
  Author: string;
  Description: string;
  HomePageUrl?: string | null;
  Labels?: string[] | null;
  LicenseBody?: string | null;
  LicenseUrl?: string | null;
  Name: string;
  ReadmeBody?: string | null;
  ReadmeUrl?: string | null;
  SemanticVersion?: string | null;
  SourceCodeArchiveUrl?: string | null;
  SourceCodeUrl?: string | null;
  SpdxLicenseId?: string | null;
  TemplateBody?: string | null;
  TemplateUrl?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateApplicationVersionRequest {
  ApplicationId: string;
  SemanticVersion: string;
  SourceCodeArchiveUrl?: string | null;
  SourceCodeUrl?: string | null;
  TemplateBody?: string | null;
  TemplateUrl?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateCloudFormationChangeSetRequest {
  ApplicationId: string;
  Capabilities?: string[] | null;
  ChangeSetName?: string | null;
  ClientToken?: string | null;
  Description?: string | null;
  NotificationArns?: string[] | null;
  ParameterOverrides?: ParameterValue[] | null;
  ResourceTypes?: string[] | null;
  RollbackConfiguration?: RollbackConfiguration | null;
  SemanticVersion?: string | null;
  StackName: string;
  Tags?: Tag[] | null;
  TemplateId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateCloudFormationTemplateRequest {
  ApplicationId: string;
  SemanticVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteApplicationRequest {
  ApplicationId: string;
}

// refs: 1 - tags: named, input
export interface GetApplicationRequest {
  ApplicationId: string;
  SemanticVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface GetApplicationPolicyRequest {
  ApplicationId: string;
}

// refs: 1 - tags: named, input
export interface GetCloudFormationTemplateRequest {
  ApplicationId: string;
  TemplateId: string;
}

// refs: 1 - tags: named, input
export interface ListApplicationDependenciesRequest {
  ApplicationId: string;
  MaxItems?: number | null;
  NextToken?: string | null;
  SemanticVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface ListApplicationVersionsRequest {
  ApplicationId: string;
  MaxItems?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListApplicationsRequest {
  MaxItems?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutApplicationPolicyRequest {
  ApplicationId: string;
  Statements: ApplicationPolicyStatement[];
}

// refs: 1 - tags: named, input
export interface UnshareApplicationRequest {
  ApplicationId: string;
  OrganizationId: string;
}

// refs: 1 - tags: named, input
export interface UpdateApplicationRequest {
  ApplicationId: string;
  Author?: string | null;
  Description?: string | null;
  HomePageUrl?: string | null;
  Labels?: string[] | null;
  ReadmeBody?: string | null;
  ReadmeUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateApplicationResponse {
  ApplicationId?: string | null;
  Author?: string | null;
  CreationTime?: string | null;
  Description?: string | null;
  HomePageUrl?: string | null;
  IsVerifiedAuthor?: boolean | null;
  Labels?: string[] | null;
  LicenseUrl?: string | null;
  Name?: string | null;
  ReadmeUrl?: string | null;
  SpdxLicenseId?: string | null;
  VerifiedAuthorUrl?: string | null;
  Version?: Version | null;
}

// refs: 1 - tags: named, output
export interface CreateApplicationVersionResponse {
  ApplicationId?: string | null;
  CreationTime?: string | null;
  ParameterDefinitions?: ParameterDefinition[] | null;
  RequiredCapabilities?: Capability[] | null;
  ResourcesSupported?: boolean | null;
  SemanticVersion?: string | null;
  SourceCodeArchiveUrl?: string | null;
  SourceCodeUrl?: string | null;
  TemplateUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCloudFormationChangeSetResponse {
  ApplicationId?: string | null;
  ChangeSetId?: string | null;
  SemanticVersion?: string | null;
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCloudFormationTemplateResponse {
  ApplicationId?: string | null;
  CreationTime?: string | null;
  ExpirationTime?: string | null;
  SemanticVersion?: string | null;
  Status?: Status | null;
  TemplateId?: string | null;
  TemplateUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface GetApplicationResponse {
  ApplicationId?: string | null;
  Author?: string | null;
  CreationTime?: string | null;
  Description?: string | null;
  HomePageUrl?: string | null;
  IsVerifiedAuthor?: boolean | null;
  Labels?: string[] | null;
  LicenseUrl?: string | null;
  Name?: string | null;
  ReadmeUrl?: string | null;
  SpdxLicenseId?: string | null;
  VerifiedAuthorUrl?: string | null;
  Version?: Version | null;
}

// refs: 1 - tags: named, output
export interface GetApplicationPolicyResponse {
  Statements?: ApplicationPolicyStatement[] | null;
}

// refs: 1 - tags: named, output
export interface GetCloudFormationTemplateResponse {
  ApplicationId?: string | null;
  CreationTime?: string | null;
  ExpirationTime?: string | null;
  SemanticVersion?: string | null;
  Status?: Status | null;
  TemplateId?: string | null;
  TemplateUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface ListApplicationDependenciesResponse {
  Dependencies?: ApplicationDependencySummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListApplicationVersionsResponse {
  NextToken?: string | null;
  Versions?: VersionSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListApplicationsResponse {
  Applications?: ApplicationSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutApplicationPolicyResponse {
  Statements?: ApplicationPolicyStatement[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateApplicationResponse {
  ApplicationId?: string | null;
  Author?: string | null;
  CreationTime?: string | null;
  Description?: string | null;
  HomePageUrl?: string | null;
  IsVerifiedAuthor?: boolean | null;
  Labels?: string[] | null;
  LicenseUrl?: string | null;
  Name?: string | null;
  ReadmeUrl?: string | null;
  SpdxLicenseId?: string | null;
  VerifiedAuthorUrl?: string | null;
  Version?: Version | null;
}

// refs: 1 - tags: input, named, interface
export interface ParameterValue {
  Name: string;
  Value: string;
}
function fromParameterValue(input?: ParameterValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    value: input["Value"],
  }
}

// refs: 1 - tags: input, named, interface
export interface RollbackConfiguration {
  MonitoringTimeInMinutes?: number | null;
  RollbackTriggers?: RollbackTrigger[] | null;
}
function fromRollbackConfiguration(input?: RollbackConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    monitoringTimeInMinutes: input["MonitoringTimeInMinutes"],
    rollbackTriggers: input["RollbackTriggers"]?.map(x => fromRollbackTrigger(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface RollbackTrigger {
  Arn: string;
  Type: string;
}
function fromRollbackTrigger(input?: RollbackTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    arn: input["Arn"],
    type: input["Type"],
  }
}

// refs: 1 - tags: input, named, interface
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["Key"],
    value: input["Value"],
  }
}

// refs: 3 - tags: input, named, interface, output
export interface ApplicationPolicyStatement {
  Actions: string[];
  PrincipalOrgIDs?: string[] | null;
  Principals: string[];
  StatementId?: string | null;
}
function fromApplicationPolicyStatement(input?: ApplicationPolicyStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actions: input["Actions"],
    principalOrgIDs: input["PrincipalOrgIDs"],
    principals: input["Principals"],
    statementId: input["StatementId"],
  }
}
function toApplicationPolicyStatement(root: jsonP.JSONValue): ApplicationPolicyStatement {
  return jsonP.readObj({
    required: {
      "Actions": ["s"],
      "Principals": ["s"],
    },
    optional: {
      "PrincipalOrgIDs": ["s"],
      "StatementId": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Version {
  ApplicationId: string;
  CreationTime: string;
  ParameterDefinitions: ParameterDefinition[];
  RequiredCapabilities: Capability[];
  ResourcesSupported: boolean;
  SemanticVersion: string;
  SourceCodeArchiveUrl?: string | null;
  SourceCodeUrl?: string | null;
  TemplateUrl: string;
}
function toVersion(root: jsonP.JSONValue): Version {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CreationTime": "s",
      "ParameterDefinitions": [toParameterDefinition],
      "RequiredCapabilities": [(x: jsonP.JSONValue) => cmnP.readEnum<Capability>(x)],
      "ResourcesSupported": "b",
      "SemanticVersion": "s",
      "TemplateUrl": "s",
    },
    optional: {
      "SourceCodeArchiveUrl": "s",
      "SourceCodeUrl": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ParameterDefinition {
  AllowedPattern?: string | null;
  AllowedValues?: string[] | null;
  ConstraintDescription?: string | null;
  DefaultValue?: string | null;
  Description?: string | null;
  MaxLength?: number | null;
  MaxValue?: number | null;
  MinLength?: number | null;
  MinValue?: number | null;
  Name: string;
  NoEcho?: boolean | null;
  ReferencedByResources: string[];
  Type?: string | null;
}
function toParameterDefinition(root: jsonP.JSONValue): ParameterDefinition {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "ReferencedByResources": ["s"],
    },
    optional: {
      "AllowedPattern": "s",
      "AllowedValues": ["s"],
      "ConstraintDescription": "s",
      "DefaultValue": "s",
      "Description": "s",
      "MaxLength": "n",
      "MaxValue": "n",
      "MinLength": "n",
      "MinValue": "n",
      "NoEcho": "b",
      "Type": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type Capability =
| "CAPABILITY_IAM"
| "CAPABILITY_NAMED_IAM"
| "CAPABILITY_AUTO_EXPAND"
| "CAPABILITY_RESOURCE_POLICY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type Status =
| "PREPARING"
| "ACTIVE"
| "EXPIRED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ApplicationDependencySummary {
  ApplicationId: string;
  SemanticVersion: string;
}
function toApplicationDependencySummary(root: jsonP.JSONValue): ApplicationDependencySummary {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "SemanticVersion": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VersionSummary {
  ApplicationId: string;
  CreationTime: string;
  SemanticVersion: string;
  SourceCodeUrl?: string | null;
}
function toVersionSummary(root: jsonP.JSONValue): VersionSummary {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CreationTime": "s",
      "SemanticVersion": "s",
    },
    optional: {
      "SourceCodeUrl": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ApplicationSummary {
  ApplicationId: string;
  Author: string;
  CreationTime?: string | null;
  Description: string;
  HomePageUrl?: string | null;
  Labels?: string[] | null;
  Name: string;
  SpdxLicenseId?: string | null;
}
function toApplicationSummary(root: jsonP.JSONValue): ApplicationSummary {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "Author": "s",
      "Description": "s",
      "Name": "s",
    },
    optional: {
      "CreationTime": "s",
      "HomePageUrl": "s",
      "Labels": ["s"],
      "SpdxLicenseId": "s",
    },
  }, root);
}
