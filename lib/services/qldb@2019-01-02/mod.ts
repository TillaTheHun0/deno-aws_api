// Autogenerated API client for: Amazon QLDB

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class QLDB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(QLDB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-01-02",
    "endpointPrefix": "qldb",
    "jsonVersion": "1.0",
    "protocol": "rest-json",
    "serviceAbbreviation": "QLDB",
    "serviceFullName": "Amazon QLDB",
    "serviceId": "QLDB",
    "signatureVersion": "v4",
    "signingName": "qldb",
    "uid": "qldb-2019-01-02"
  };

  async cancelJournalKinesisStream(
    {abortSignal, ...params}: RequestConfig & CancelJournalKinesisStreamRequest,
  ): Promise<CancelJournalKinesisStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJournalKinesisStream",
      method: "DELETE",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams/${params["StreamId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StreamId": "s",
        },
      }, await resp.json()),
  };
  }

  async createLedger(
    {abortSignal, ...params}: RequestConfig & CreateLedgerRequest,
  ): Promise<CreateLedgerResponse> {
    const body: jsonP.JSONObject = params ? {
      Name: params["Name"],
      Tags: params["Tags"],
      PermissionsMode: params["PermissionsMode"],
      DeletionProtection: params["DeletionProtection"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLedger",
      requestUri: "/ledgers",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Name": "s",
          "Arn": "s",
          "State": (x: jsonP.JSONValue) => cmnP.readEnum<LedgerState>(x),
          "CreationDateTime": "d",
          "DeletionProtection": "b",
        },
      }, await resp.json()),
  };
  }

  async deleteLedger(
    {abortSignal, ...params}: RequestConfig & DeleteLedgerRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteLedger",
      method: "DELETE",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
  }

  async describeJournalKinesisStream(
    {abortSignal, ...params}: RequestConfig & DescribeJournalKinesisStreamRequest,
  ): Promise<DescribeJournalKinesisStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJournalKinesisStream",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams/${params["StreamId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Stream": toJournalKinesisStreamDescription,
        },
      }, await resp.json()),
  };
  }

  async describeJournalS3Export(
    {abortSignal, ...params}: RequestConfig & DescribeJournalS3ExportRequest,
  ): Promise<DescribeJournalS3ExportResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJournalS3Export",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports/${params["ExportId"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "ExportDescription": toJournalS3ExportDescription,
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async describeLedger(
    {abortSignal, ...params}: RequestConfig & DescribeLedgerRequest,
  ): Promise<DescribeLedgerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Name": "s",
          "Arn": "s",
          "State": (x: jsonP.JSONValue) => cmnP.readEnum<LedgerState>(x),
          "CreationDateTime": "d",
          "DeletionProtection": "b",
        },
      }, await resp.json()),
  };
  }

  async exportJournalToS3(
    {abortSignal, ...params}: RequestConfig & ExportJournalToS3Request,
  ): Promise<ExportJournalToS3Response> {
    const body: jsonP.JSONObject = params ? {
      InclusiveStartTime: jsonP.serializeDate_unixTimestamp(params["InclusiveStartTime"]),
      ExclusiveEndTime: jsonP.serializeDate_unixTimestamp(params["ExclusiveEndTime"]),
      S3ExportConfiguration: fromS3ExportConfiguration(params["S3ExportConfiguration"]),
      RoleArn: params["RoleArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportJournalToS3",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "ExportId": "s",
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getBlock(
    {abortSignal, ...params}: RequestConfig & GetBlockRequest,
  ): Promise<GetBlockResponse> {
    const body: jsonP.JSONObject = params ? {
      BlockAddress: fromValueHolder(params["BlockAddress"]),
      DigestTipAddress: fromValueHolder(params["DigestTipAddress"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlock",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/block`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "Block": toValueHolder,
        },
        optional: {
          "Proof": toValueHolder,
        },
      }, await resp.json()),
  };
  }

  async getDigest(
    {abortSignal, ...params}: RequestConfig & GetDigestRequest,
  ): Promise<GetDigestResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDigest",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/digest`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "Digest": "a",
          "DigestTipAddress": toValueHolder,
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getRevision(
    {abortSignal, ...params}: RequestConfig & GetRevisionRequest,
  ): Promise<GetRevisionResponse> {
    const body: jsonP.JSONObject = params ? {
      BlockAddress: fromValueHolder(params["BlockAddress"]),
      DocumentId: params["DocumentId"],
      DigestTipAddress: fromValueHolder(params["DigestTipAddress"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRevision",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/revision`,
    });
  return {
    ...jsonP.readObj({
        required: {
          "Revision": toValueHolder,
        },
        optional: {
          "Proof": toValueHolder,
        },
      }, await resp.json()),
  };
  }

  async listJournalKinesisStreamsForLedger(
    {abortSignal, ...params}: RequestConfig & ListJournalKinesisStreamsForLedgerRequest,
  ): Promise<ListJournalKinesisStreamsForLedgerResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalKinesisStreamsForLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Streams": [toJournalKinesisStreamDescription],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listJournalS3Exports(
    {abortSignal, ...params}: RequestConfig & ListJournalS3ExportsRequest = {},
  ): Promise<ListJournalS3ExportsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalS3Exports",
      method: "GET",
      requestUri: "/journal-s3-exports",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "JournalS3Exports": [toJournalS3ExportDescription],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listJournalS3ExportsForLedger(
    {abortSignal, ...params}: RequestConfig & ListJournalS3ExportsForLedgerRequest,
  ): Promise<ListJournalS3ExportsForLedgerResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalS3ExportsForLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "JournalS3Exports": [toJournalS3ExportDescription],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listLedgers(
    {abortSignal, ...params}: RequestConfig & ListLedgersRequest = {},
  ): Promise<ListLedgersResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListLedgers",
      method: "GET",
      requestUri: "/ledgers",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Ledgers": [toLedgerSummary],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async streamJournalToKinesis(
    {abortSignal, ...params}: RequestConfig & StreamJournalToKinesisRequest,
  ): Promise<StreamJournalToKinesisResponse> {
    const body: jsonP.JSONObject = params ? {
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      InclusiveStartTime: jsonP.serializeDate_unixTimestamp(params["InclusiveStartTime"]),
      ExclusiveEndTime: jsonP.serializeDate_unixTimestamp(params["ExclusiveEndTime"]),
      KinesisConfiguration: fromKinesisConfiguration(params["KinesisConfiguration"]),
      StreamName: params["StreamName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StreamJournalToKinesis",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StreamId": "s",
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      Tags: params["Tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateLedger(
    {abortSignal, ...params}: RequestConfig & UpdateLedgerRequest,
  ): Promise<UpdateLedgerResponse> {
    const body: jsonP.JSONObject = params ? {
      DeletionProtection: params["DeletionProtection"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLedger",
      method: "PATCH",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "Name": "s",
          "Arn": "s",
          "State": (x: jsonP.JSONValue) => cmnP.readEnum<LedgerState>(x),
          "CreationDateTime": "d",
          "DeletionProtection": "b",
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CancelJournalKinesisStreamRequest {
  LedgerName: string;
  StreamId: string;
}

// refs: 1 - tags: named, input
export interface CreateLedgerRequest {
  Name: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  PermissionsMode: PermissionsMode;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteLedgerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeJournalKinesisStreamRequest {
  LedgerName: string;
  StreamId: string;
}

// refs: 1 - tags: named, input
export interface DescribeJournalS3ExportRequest {
  Name: string;
  ExportId: string;
}

// refs: 1 - tags: named, input
export interface DescribeLedgerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface ExportJournalToS3Request {
  Name: string;
  InclusiveStartTime: Date | number;
  ExclusiveEndTime: Date | number;
  S3ExportConfiguration: S3ExportConfiguration;
  RoleArn: string;
}

// refs: 1 - tags: named, input
export interface GetBlockRequest {
  Name: string;
  BlockAddress: ValueHolder;
  DigestTipAddress?: ValueHolder | null;
}

// refs: 1 - tags: named, input
export interface GetDigestRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetRevisionRequest {
  Name: string;
  BlockAddress: ValueHolder;
  DocumentId: string;
  DigestTipAddress?: ValueHolder | null;
}

// refs: 1 - tags: named, input
export interface ListJournalKinesisStreamsForLedgerRequest {
  LedgerName: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListJournalS3ExportsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListJournalS3ExportsForLedgerRequest {
  Name: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListLedgersRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface StreamJournalToKinesisRequest {
  LedgerName: string;
  RoleArn: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  InclusiveStartTime: Date | number;
  ExclusiveEndTime?: Date | number | null;
  KinesisConfiguration: KinesisConfiguration;
  StreamName: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateLedgerRequest {
  Name: string;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, output
export interface CancelJournalKinesisStreamResponse {
  StreamId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateLedgerResponse {
  Name?: string | null;
  Arn?: string | null;
  State?: LedgerState | null;
  CreationDateTime?: Date | number | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeJournalKinesisStreamResponse {
  Stream?: JournalKinesisStreamDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeJournalS3ExportResponse {
  ExportDescription: JournalS3ExportDescription;
}

// refs: 1 - tags: named, output
export interface DescribeLedgerResponse {
  Name?: string | null;
  Arn?: string | null;
  State?: LedgerState | null;
  CreationDateTime?: Date | number | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ExportJournalToS3Response {
  ExportId: string;
}

// refs: 1 - tags: named, output
export interface GetBlockResponse {
  Block: ValueHolder;
  Proof?: ValueHolder | null;
}

// refs: 1 - tags: named, output
export interface GetDigestResponse {
  Digest: Uint8Array | string;
  DigestTipAddress: ValueHolder;
}

// refs: 1 - tags: named, output
export interface GetRevisionResponse {
  Proof?: ValueHolder | null;
  Revision: ValueHolder;
}

// refs: 1 - tags: named, output
export interface ListJournalKinesisStreamsForLedgerResponse {
  Streams?: JournalKinesisStreamDescription[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJournalS3ExportsResponse {
  JournalS3Exports?: JournalS3ExportDescription[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJournalS3ExportsForLedgerResponse {
  JournalS3Exports?: JournalS3ExportDescription[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListLedgersResponse {
  Ledgers?: LedgerSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface StreamJournalToKinesisResponse {
  StreamId?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateLedgerResponse {
  Name?: string | null;
  Arn?: string | null;
  State?: LedgerState | null;
  CreationDateTime?: Date | number | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: input, named, enum
export type PermissionsMode =
| "ALLOW_ALL"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface S3ExportConfiguration {
  Bucket: string;
  Prefix: string;
  EncryptionConfiguration: S3EncryptionConfiguration;
}
function fromS3ExportConfiguration(input?: S3ExportConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Prefix: input["Prefix"],
    EncryptionConfiguration: fromS3EncryptionConfiguration(input["EncryptionConfiguration"]),
  }
}
function toS3ExportConfiguration(root: jsonP.JSONValue): S3ExportConfiguration {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
      "Prefix": "s",
      "EncryptionConfiguration": toS3EncryptionConfiguration,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface S3EncryptionConfiguration {
  ObjectEncryptionType: S3ObjectEncryptionType;
  KmsKeyArn?: string | null;
}
function fromS3EncryptionConfiguration(input?: S3EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectEncryptionType: input["ObjectEncryptionType"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3EncryptionConfiguration(root: jsonP.JSONValue): S3EncryptionConfiguration {
  return jsonP.readObj({
    required: {
      "ObjectEncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<S3ObjectEncryptionType>(x),
    },
    optional: {
      "KmsKeyArn": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type S3ObjectEncryptionType =
| "SSE_KMS"
| "SSE_S3"
| "NO_ENCRYPTION"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface ValueHolder {
  IonText?: string | null;
}
function fromValueHolder(input?: ValueHolder | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IonText: input["IonText"],
  }
}
function toValueHolder(root: jsonP.JSONValue): ValueHolder {
  return jsonP.readObj({
    required: {},
    optional: {
      "IonText": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface KinesisConfiguration {
  StreamArn: string;
  AggregationEnabled?: boolean | null;
}
function fromKinesisConfiguration(input?: KinesisConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamArn: input["StreamArn"],
    AggregationEnabled: input["AggregationEnabled"],
  }
}
function toKinesisConfiguration(root: jsonP.JSONValue): KinesisConfiguration {
  return jsonP.readObj({
    required: {
      "StreamArn": "s",
    },
    optional: {
      "AggregationEnabled": "b",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type LedgerState =
| "CREATING"
| "ACTIVE"
| "DELETING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface JournalKinesisStreamDescription {
  LedgerName: string;
  CreationTime?: Date | number | null;
  InclusiveStartTime?: Date | number | null;
  ExclusiveEndTime?: Date | number | null;
  RoleArn: string;
  StreamId: string;
  Arn?: string | null;
  Status: StreamStatus;
  KinesisConfiguration: KinesisConfiguration;
  ErrorCause?: ErrorCause | null;
  StreamName: string;
}
function toJournalKinesisStreamDescription(root: jsonP.JSONValue): JournalKinesisStreamDescription {
  return jsonP.readObj({
    required: {
      "LedgerName": "s",
      "RoleArn": "s",
      "StreamId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<StreamStatus>(x),
      "KinesisConfiguration": toKinesisConfiguration,
      "StreamName": "s",
    },
    optional: {
      "CreationTime": "d",
      "InclusiveStartTime": "d",
      "ExclusiveEndTime": "d",
      "Arn": "s",
      "ErrorCause": (x: jsonP.JSONValue) => cmnP.readEnum<ErrorCause>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type StreamStatus =
| "ACTIVE"
| "COMPLETED"
| "CANCELED"
| "FAILED"
| "IMPAIRED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ErrorCause =
| "KINESIS_STREAM_NOT_FOUND"
| "IAM_PERMISSION_REVOKED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface JournalS3ExportDescription {
  LedgerName: string;
  ExportId: string;
  ExportCreationTime: Date | number;
  Status: ExportStatus;
  InclusiveStartTime: Date | number;
  ExclusiveEndTime: Date | number;
  S3ExportConfiguration: S3ExportConfiguration;
  RoleArn: string;
}
function toJournalS3ExportDescription(root: jsonP.JSONValue): JournalS3ExportDescription {
  return jsonP.readObj({
    required: {
      "LedgerName": "s",
      "ExportId": "s",
      "ExportCreationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ExportStatus>(x),
      "InclusiveStartTime": "d",
      "ExclusiveEndTime": "d",
      "S3ExportConfiguration": toS3ExportConfiguration,
      "RoleArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ExportStatus =
| "IN_PROGRESS"
| "COMPLETED"
| "CANCELLED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface LedgerSummary {
  Name?: string | null;
  State?: LedgerState | null;
  CreationDateTime?: Date | number | null;
}
function toLedgerSummary(root: jsonP.JSONValue): LedgerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<LedgerState>(x),
      "CreationDateTime": "d",
    },
  }, root);
}
