// Autogenerated API client for: Amazon QLDB

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class QLDB {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(QLDB.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-01-02",
    "endpointPrefix": "qldb",
    "jsonVersion": "1.0",
    "protocol": "rest-json",
    "serviceAbbreviation": "QLDB",
    "serviceFullName": "Amazon QLDB",
    "serviceId": "QLDB",
    "signatureVersion": "v4",
    "signingName": "qldb",
    "uid": "qldb-2019-01-02"
  };

  async cancelJournalKinesisStream(
    {abortSignal, ...params}: RequestConfig & s.CancelJournalKinesisStreamRequest,
  ): Promise<s.CancelJournalKinesisStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJournalKinesisStream",
      method: "DELETE",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams/${params["StreamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamId": "s",
      },
    }, await resp.json());
  }

  async createLedger(
    {abortSignal, ...params}: RequestConfig & s.CreateLedgerRequest,
  ): Promise<s.CreateLedgerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Tags: params["Tags"],
      PermissionsMode: params["PermissionsMode"],
      DeletionProtection: params["DeletionProtection"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLedger",
      requestUri: "/ledgers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Arn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.LedgerState>(x),
        "CreationDateTime": "d",
        "DeletionProtection": "b",
      },
    }, await resp.json());
  }

  async deleteLedger(
    {abortSignal, ...params}: RequestConfig & s.DeleteLedgerRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteLedger",
      method: "DELETE",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
  }

  async describeJournalKinesisStream(
    {abortSignal, ...params}: RequestConfig & s.DescribeJournalKinesisStreamRequest,
  ): Promise<s.DescribeJournalKinesisStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJournalKinesisStream",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams/${params["StreamId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stream": toJournalKinesisStreamDescription,
      },
    }, await resp.json());
  }

  async describeJournalS3Export(
    {abortSignal, ...params}: RequestConfig & s.DescribeJournalS3ExportRequest,
  ): Promise<s.DescribeJournalS3ExportResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJournalS3Export",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports/${params["ExportId"]}`,
    });
    return jsonP.readObj({
      required: {
        "ExportDescription": toJournalS3ExportDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async describeLedger(
    {abortSignal, ...params}: RequestConfig & s.DescribeLedgerRequest,
  ): Promise<s.DescribeLedgerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Arn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.LedgerState>(x),
        "CreationDateTime": "d",
        "DeletionProtection": "b",
      },
    }, await resp.json());
  }

  async exportJournalToS3(
    {abortSignal, ...params}: RequestConfig & s.ExportJournalToS3Request,
  ): Promise<s.ExportJournalToS3Response> {
    const body: jsonP.JSONObject = {
      InclusiveStartTime: jsonP.serializeDate_unixTimestamp(params["InclusiveStartTime"]),
      ExclusiveEndTime: jsonP.serializeDate_unixTimestamp(params["ExclusiveEndTime"]),
      S3ExportConfiguration: fromS3ExportConfiguration(params["S3ExportConfiguration"]),
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportJournalToS3",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports`,
    });
    return jsonP.readObj({
      required: {
        "ExportId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getBlock(
    {abortSignal, ...params}: RequestConfig & s.GetBlockRequest,
  ): Promise<s.GetBlockResponse> {
    const body: jsonP.JSONObject = {
      BlockAddress: fromValueHolder(params["BlockAddress"]),
      DigestTipAddress: fromValueHolder(params["DigestTipAddress"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlock",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/block`,
    });
    return jsonP.readObj({
      required: {
        "Block": toValueHolder,
      },
      optional: {
        "Proof": toValueHolder,
      },
    }, await resp.json());
  }

  async getDigest(
    {abortSignal, ...params}: RequestConfig & s.GetDigestRequest,
  ): Promise<s.GetDigestResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDigest",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/digest`,
    });
    return jsonP.readObj({
      required: {
        "Digest": "a",
        "DigestTipAddress": toValueHolder,
      },
      optional: {},
    }, await resp.json());
  }

  async getRevision(
    {abortSignal, ...params}: RequestConfig & s.GetRevisionRequest,
  ): Promise<s.GetRevisionResponse> {
    const body: jsonP.JSONObject = {
      BlockAddress: fromValueHolder(params["BlockAddress"]),
      DocumentId: params["DocumentId"],
      DigestTipAddress: fromValueHolder(params["DigestTipAddress"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRevision",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/revision`,
    });
    return jsonP.readObj({
      required: {
        "Revision": toValueHolder,
      },
      optional: {
        "Proof": toValueHolder,
      },
    }, await resp.json());
  }

  async listJournalKinesisStreamsForLedger(
    {abortSignal, ...params}: RequestConfig & s.ListJournalKinesisStreamsForLedgerRequest,
  ): Promise<s.ListJournalKinesisStreamsForLedgerResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalKinesisStreamsForLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Streams": [toJournalKinesisStreamDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJournalS3Exports(
    {abortSignal, ...params}: RequestConfig & s.ListJournalS3ExportsRequest = {},
  ): Promise<s.ListJournalS3ExportsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalS3Exports",
      method: "GET",
      requestUri: "/journal-s3-exports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JournalS3Exports": [toJournalS3ExportDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJournalS3ExportsForLedger(
    {abortSignal, ...params}: RequestConfig & s.ListJournalS3ExportsForLedgerRequest,
  ): Promise<s.ListJournalS3ExportsForLedgerResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJournalS3ExportsForLedger",
      method: "GET",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}/journal-s3-exports`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JournalS3Exports": [toJournalS3ExportDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLedgers(
    {abortSignal, ...params}: RequestConfig & s.ListLedgersRequest = {},
  ): Promise<s.ListLedgersResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("max_results", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("next_token", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListLedgers",
      method: "GET",
      requestUri: "/ledgers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Ledgers": [toLedgerSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async streamJournalToKinesis(
    {abortSignal, ...params}: RequestConfig & s.StreamJournalToKinesisRequest,
  ): Promise<s.StreamJournalToKinesisResponse> {
    const body: jsonP.JSONObject = {
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      InclusiveStartTime: jsonP.serializeDate_unixTimestamp(params["InclusiveStartTime"]),
      ExclusiveEndTime: jsonP.serializeDate_unixTimestamp(params["ExclusiveEndTime"]),
      KinesisConfiguration: fromKinesisConfiguration(params["KinesisConfiguration"]),
      StreamName: params["StreamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StreamJournalToKinesis",
      requestUri: cmnP.encodePath`/ledgers/${params["LedgerName"]}/journal-kinesis-streams`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateLedger(
    {abortSignal, ...params}: RequestConfig & s.UpdateLedgerRequest,
  ): Promise<s.UpdateLedgerResponse> {
    const body: jsonP.JSONObject = {
      DeletionProtection: params["DeletionProtection"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLedger",
      method: "PATCH",
      requestUri: cmnP.encodePath`/ledgers/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Arn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.LedgerState>(x),
        "CreationDateTime": "d",
        "DeletionProtection": "b",
      },
    }, await resp.json());
  }

}

function fromS3ExportConfiguration(input?: s.S3ExportConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Prefix: input["Prefix"],
    EncryptionConfiguration: fromS3EncryptionConfiguration(input["EncryptionConfiguration"]),
  }
}
function toS3ExportConfiguration(root: jsonP.JSONValue): s.S3ExportConfiguration {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
      "Prefix": "s",
      "EncryptionConfiguration": toS3EncryptionConfiguration,
    },
    optional: {},
  }, root);
}

function fromS3EncryptionConfiguration(input?: s.S3EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ObjectEncryptionType: input["ObjectEncryptionType"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3EncryptionConfiguration(root: jsonP.JSONValue): s.S3EncryptionConfiguration {
  return jsonP.readObj({
    required: {
      "ObjectEncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3ObjectEncryptionType>(x),
    },
    optional: {
      "KmsKeyArn": "s",
    },
  }, root);
}

function fromValueHolder(input?: s.ValueHolder | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IonText: input["IonText"],
  }
}
function toValueHolder(root: jsonP.JSONValue): s.ValueHolder {
  return jsonP.readObj({
    required: {},
    optional: {
      "IonText": "s",
    },
  }, root);
}

function fromKinesisConfiguration(input?: s.KinesisConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamArn: input["StreamArn"],
    AggregationEnabled: input["AggregationEnabled"],
  }
}
function toKinesisConfiguration(root: jsonP.JSONValue): s.KinesisConfiguration {
  return jsonP.readObj({
    required: {
      "StreamArn": "s",
    },
    optional: {
      "AggregationEnabled": "b",
    },
  }, root);
}

function toJournalKinesisStreamDescription(root: jsonP.JSONValue): s.JournalKinesisStreamDescription {
  return jsonP.readObj({
    required: {
      "LedgerName": "s",
      "RoleArn": "s",
      "StreamId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamStatus>(x),
      "KinesisConfiguration": toKinesisConfiguration,
      "StreamName": "s",
    },
    optional: {
      "CreationTime": "d",
      "InclusiveStartTime": "d",
      "ExclusiveEndTime": "d",
      "Arn": "s",
      "ErrorCause": (x: jsonP.JSONValue) => cmnP.readEnum<s.ErrorCause>(x),
    },
  }, root);
}

function toJournalS3ExportDescription(root: jsonP.JSONValue): s.JournalS3ExportDescription {
  return jsonP.readObj({
    required: {
      "LedgerName": "s",
      "ExportId": "s",
      "ExportCreationTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportStatus>(x),
      "InclusiveStartTime": "d",
      "ExclusiveEndTime": "d",
      "S3ExportConfiguration": toS3ExportConfiguration,
      "RoleArn": "s",
    },
    optional: {},
  }, root);
}

function toLedgerSummary(root: jsonP.JSONValue): s.LedgerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.LedgerState>(x),
      "CreationDateTime": "d",
    },
  }, root);
}
