// Autogenerated API client for: Amazon Cognito Identity Provider

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class CognitoIdentityServiceProvider {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CognitoIdentityServiceProvider.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-04-18",
    "endpointPrefix": "cognito-idp",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Cognito Identity Provider",
    "serviceId": "Cognito Identity Provider",
    "signatureVersion": "v4",
    "targetPrefix": "AWSCognitoIdentityProviderService",
    "uid": "cognito-idp-2016-04-18"
  };

  async addCustomAttributes(
    {abortSignal, ...params}: RequestConfig & s.AddCustomAttributesRequest,
  ): Promise<s.AddCustomAttributesResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      CustomAttributes: params["CustomAttributes"]?.map(x => fromSchemaAttributeType(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddCustomAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminAddUserToGroup(
    {abortSignal, ...params}: RequestConfig & s.AdminAddUserToGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      GroupName: params["GroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminAddUserToGroup",
    });
  }

  async adminConfirmSignUp(
    {abortSignal, ...params}: RequestConfig & s.AdminConfirmSignUpRequest,
  ): Promise<s.AdminConfirmSignUpResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminConfirmSignUp",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminCreateUser(
    {abortSignal, ...params}: RequestConfig & s.AdminCreateUserRequest,
  ): Promise<s.AdminCreateUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      UserAttributes: params["UserAttributes"]?.map(x => fromAttributeType(x)),
      ValidationData: params["ValidationData"]?.map(x => fromAttributeType(x)),
      TemporaryPassword: params["TemporaryPassword"],
      ForceAliasCreation: params["ForceAliasCreation"],
      MessageAction: params["MessageAction"],
      DesiredDeliveryMediums: params["DesiredDeliveryMediums"],
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminCreateUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "User": toUserType,
      },
    }, await resp.json());
  }

  async adminDeleteUser(
    {abortSignal, ...params}: RequestConfig & s.AdminDeleteUserRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminDeleteUser",
    });
  }

  async adminDeleteUserAttributes(
    {abortSignal, ...params}: RequestConfig & s.AdminDeleteUserAttributesRequest,
  ): Promise<s.AdminDeleteUserAttributesResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      UserAttributeNames: params["UserAttributeNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminDeleteUserAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminDisableProviderForUser(
    {abortSignal, ...params}: RequestConfig & s.AdminDisableProviderForUserRequest,
  ): Promise<s.AdminDisableProviderForUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      User: fromProviderUserIdentifierType(params["User"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminDisableProviderForUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminDisableUser(
    {abortSignal, ...params}: RequestConfig & s.AdminDisableUserRequest,
  ): Promise<s.AdminDisableUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminDisableUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminEnableUser(
    {abortSignal, ...params}: RequestConfig & s.AdminEnableUserRequest,
  ): Promise<s.AdminEnableUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminEnableUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminForgetDevice(
    {abortSignal, ...params}: RequestConfig & s.AdminForgetDeviceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      DeviceKey: params["DeviceKey"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminForgetDevice",
    });
  }

  async adminGetDevice(
    {abortSignal, ...params}: RequestConfig & s.AdminGetDeviceRequest,
  ): Promise<s.AdminGetDeviceResponse> {
    const body: jsonP.JSONObject = {
      DeviceKey: params["DeviceKey"],
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminGetDevice",
    });
    return jsonP.readObj({
      required: {
        "Device": toDeviceType,
      },
      optional: {},
    }, await resp.json());
  }

  async adminGetUser(
    {abortSignal, ...params}: RequestConfig & s.AdminGetUserRequest,
  ): Promise<s.AdminGetUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminGetUser",
    });
    return jsonP.readObj({
      required: {
        "Username": "s",
      },
      optional: {
        "UserAttributes": [toAttributeType],
        "UserCreateDate": "d",
        "UserLastModifiedDate": "d",
        "Enabled": "b",
        "UserStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserStatusType>(x),
        "MFAOptions": [toMFAOptionType],
        "PreferredMfaSetting": "s",
        "UserMFASettingList": ["s"],
      },
    }, await resp.json());
  }

  async adminInitiateAuth(
    {abortSignal, ...params}: RequestConfig & s.AdminInitiateAuthRequest,
  ): Promise<s.AdminInitiateAuthResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
      AuthFlow: params["AuthFlow"],
      AuthParameters: params["AuthParameters"],
      ClientMetadata: params["ClientMetadata"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      ContextData: fromContextDataType(params["ContextData"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminInitiateAuth",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChallengeName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeNameType>(x),
        "Session": "s",
        "ChallengeParameters": x => jsonP.readMap(String, String, x),
        "AuthenticationResult": toAuthenticationResultType,
      },
    }, await resp.json());
  }

  async adminLinkProviderForUser(
    {abortSignal, ...params}: RequestConfig & s.AdminLinkProviderForUserRequest,
  ): Promise<s.AdminLinkProviderForUserResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      DestinationUser: fromProviderUserIdentifierType(params["DestinationUser"]),
      SourceUser: fromProviderUserIdentifierType(params["SourceUser"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminLinkProviderForUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminListDevices(
    {abortSignal, ...params}: RequestConfig & s.AdminListDevicesRequest,
  ): Promise<s.AdminListDevicesResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      Limit: params["Limit"],
      PaginationToken: params["PaginationToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminListDevices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Devices": [toDeviceType],
        "PaginationToken": "s",
      },
    }, await resp.json());
  }

  async adminListGroupsForUser(
    {abortSignal, ...params}: RequestConfig & s.AdminListGroupsForUserRequest,
  ): Promise<s.AdminListGroupsForUserResponse> {
    const body: jsonP.JSONObject = {
      Username: params["Username"],
      UserPoolId: params["UserPoolId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminListGroupsForUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Groups": [toGroupType],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async adminListUserAuthEvents(
    {abortSignal, ...params}: RequestConfig & s.AdminListUserAuthEventsRequest,
  ): Promise<s.AdminListUserAuthEventsResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminListUserAuthEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthEvents": [toAuthEventType],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async adminRemoveUserFromGroup(
    {abortSignal, ...params}: RequestConfig & s.AdminRemoveUserFromGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      GroupName: params["GroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminRemoveUserFromGroup",
    });
  }

  async adminResetUserPassword(
    {abortSignal, ...params}: RequestConfig & s.AdminResetUserPasswordRequest,
  ): Promise<s.AdminResetUserPasswordResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminResetUserPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminRespondToAuthChallenge(
    {abortSignal, ...params}: RequestConfig & s.AdminRespondToAuthChallengeRequest,
  ): Promise<s.AdminRespondToAuthChallengeResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
      ChallengeName: params["ChallengeName"],
      ChallengeResponses: params["ChallengeResponses"],
      Session: params["Session"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      ContextData: fromContextDataType(params["ContextData"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminRespondToAuthChallenge",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChallengeName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeNameType>(x),
        "Session": "s",
        "ChallengeParameters": x => jsonP.readMap(String, String, x),
        "AuthenticationResult": toAuthenticationResultType,
      },
    }, await resp.json());
  }

  async adminSetUserMFAPreference(
    {abortSignal, ...params}: RequestConfig & s.AdminSetUserMFAPreferenceRequest,
  ): Promise<s.AdminSetUserMFAPreferenceResponse> {
    const body: jsonP.JSONObject = {
      SMSMfaSettings: fromSMSMfaSettingsType(params["SMSMfaSettings"]),
      SoftwareTokenMfaSettings: fromSoftwareTokenMfaSettingsType(params["SoftwareTokenMfaSettings"]),
      Username: params["Username"],
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminSetUserMFAPreference",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminSetUserPassword(
    {abortSignal, ...params}: RequestConfig & s.AdminSetUserPasswordRequest,
  ): Promise<s.AdminSetUserPasswordResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      Password: params["Password"],
      Permanent: params["Permanent"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminSetUserPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminSetUserSettings(
    {abortSignal, ...params}: RequestConfig & s.AdminSetUserSettingsRequest,
  ): Promise<s.AdminSetUserSettingsResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      MFAOptions: params["MFAOptions"]?.map(x => fromMFAOptionType(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminSetUserSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminUpdateAuthEventFeedback(
    {abortSignal, ...params}: RequestConfig & s.AdminUpdateAuthEventFeedbackRequest,
  ): Promise<s.AdminUpdateAuthEventFeedbackResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      EventId: params["EventId"],
      FeedbackValue: params["FeedbackValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminUpdateAuthEventFeedback",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminUpdateDeviceStatus(
    {abortSignal, ...params}: RequestConfig & s.AdminUpdateDeviceStatusRequest,
  ): Promise<s.AdminUpdateDeviceStatusResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      DeviceKey: params["DeviceKey"],
      DeviceRememberedStatus: params["DeviceRememberedStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminUpdateDeviceStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminUpdateUserAttributes(
    {abortSignal, ...params}: RequestConfig & s.AdminUpdateUserAttributesRequest,
  ): Promise<s.AdminUpdateUserAttributesResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      UserAttributes: params["UserAttributes"]?.map(x => fromAttributeType(x)),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminUpdateUserAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async adminUserGlobalSignOut(
    {abortSignal, ...params}: RequestConfig & s.AdminUserGlobalSignOutRequest,
  ): Promise<s.AdminUserGlobalSignOutResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdminUserGlobalSignOut",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async associateSoftwareToken(
    {abortSignal, ...params}: RequestConfig & s.AssociateSoftwareTokenRequest = {},
  ): Promise<s.AssociateSoftwareTokenResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      Session: params["Session"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateSoftwareToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecretCode": "s",
        "Session": "s",
      },
    }, await resp.json());
  }

  async changePassword(
    {abortSignal, ...params}: RequestConfig & s.ChangePasswordRequest,
  ): Promise<s.ChangePasswordResponse> {
    const body: jsonP.JSONObject = {
      PreviousPassword: params["PreviousPassword"],
      ProposedPassword: params["ProposedPassword"],
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ChangePassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async confirmDevice(
    {abortSignal, ...params}: RequestConfig & s.ConfirmDeviceRequest,
  ): Promise<s.ConfirmDeviceResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      DeviceKey: params["DeviceKey"],
      DeviceSecretVerifierConfig: fromDeviceSecretVerifierConfigType(params["DeviceSecretVerifierConfig"]),
      DeviceName: params["DeviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmDevice",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserConfirmationNecessary": "b",
      },
    }, await resp.json());
  }

  async confirmForgotPassword(
    {abortSignal, ...params}: RequestConfig & s.ConfirmForgotPasswordRequest,
  ): Promise<s.ConfirmForgotPasswordResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      SecretHash: params["SecretHash"],
      Username: params["Username"],
      ConfirmationCode: params["ConfirmationCode"],
      Password: params["Password"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmForgotPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async confirmSignUp(
    {abortSignal, ...params}: RequestConfig & s.ConfirmSignUpRequest,
  ): Promise<s.ConfirmSignUpResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      SecretHash: params["SecretHash"],
      Username: params["Username"],
      ConfirmationCode: params["ConfirmationCode"],
      ForceAliasCreation: params["ForceAliasCreation"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmSignUp",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateGroupRequest,
  ): Promise<s.CreateGroupResponse> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      UserPoolId: params["UserPoolId"],
      Description: params["Description"],
      RoleArn: params["RoleArn"],
      Precedence: params["Precedence"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroupType,
      },
    }, await resp.json());
  }

  async createIdentityProvider(
    {abortSignal, ...params}: RequestConfig & s.CreateIdentityProviderRequest,
  ): Promise<s.CreateIdentityProviderResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ProviderName: params["ProviderName"],
      ProviderType: params["ProviderType"],
      ProviderDetails: params["ProviderDetails"],
      AttributeMapping: params["AttributeMapping"],
      IdpIdentifiers: params["IdpIdentifiers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIdentityProvider",
    });
    return jsonP.readObj({
      required: {
        "IdentityProvider": toIdentityProviderType,
      },
      optional: {},
    }, await resp.json());
  }

  async createResourceServer(
    {abortSignal, ...params}: RequestConfig & s.CreateResourceServerRequest,
  ): Promise<s.CreateResourceServerResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Identifier: params["Identifier"],
      Name: params["Name"],
      Scopes: params["Scopes"]?.map(x => fromResourceServerScopeType(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateResourceServer",
    });
    return jsonP.readObj({
      required: {
        "ResourceServer": toResourceServerType,
      },
      optional: {},
    }, await resp.json());
  }

  async createUserImportJob(
    {abortSignal, ...params}: RequestConfig & s.CreateUserImportJobRequest,
  ): Promise<s.CreateUserImportJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      UserPoolId: params["UserPoolId"],
      CloudWatchLogsRoleArn: params["CloudWatchLogsRoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserImportJob": toUserImportJobType,
      },
    }, await resp.json());
  }

  async createUserPool(
    {abortSignal, ...params}: RequestConfig & s.CreateUserPoolRequest,
  ): Promise<s.CreateUserPoolResponse> {
    const body: jsonP.JSONObject = {
      PoolName: params["PoolName"],
      Policies: fromUserPoolPolicyType(params["Policies"]),
      LambdaConfig: fromLambdaConfigType(params["LambdaConfig"]),
      AutoVerifiedAttributes: params["AutoVerifiedAttributes"],
      AliasAttributes: params["AliasAttributes"],
      UsernameAttributes: params["UsernameAttributes"],
      SmsVerificationMessage: params["SmsVerificationMessage"],
      EmailVerificationMessage: params["EmailVerificationMessage"],
      EmailVerificationSubject: params["EmailVerificationSubject"],
      VerificationMessageTemplate: fromVerificationMessageTemplateType(params["VerificationMessageTemplate"]),
      SmsAuthenticationMessage: params["SmsAuthenticationMessage"],
      MfaConfiguration: params["MfaConfiguration"],
      DeviceConfiguration: fromDeviceConfigurationType(params["DeviceConfiguration"]),
      EmailConfiguration: fromEmailConfigurationType(params["EmailConfiguration"]),
      SmsConfiguration: fromSmsConfigurationType(params["SmsConfiguration"]),
      UserPoolTags: params["UserPoolTags"],
      AdminCreateUserConfig: fromAdminCreateUserConfigType(params["AdminCreateUserConfig"]),
      Schema: params["Schema"]?.map(x => fromSchemaAttributeType(x)),
      UserPoolAddOns: fromUserPoolAddOnsType(params["UserPoolAddOns"]),
      UsernameConfiguration: fromUsernameConfigurationType(params["UsernameConfiguration"]),
      AccountRecoverySetting: fromAccountRecoverySettingType(params["AccountRecoverySetting"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserPool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPool": toUserPoolType,
      },
    }, await resp.json());
  }

  async createUserPoolClient(
    {abortSignal, ...params}: RequestConfig & s.CreateUserPoolClientRequest,
  ): Promise<s.CreateUserPoolClientResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientName: params["ClientName"],
      GenerateSecret: params["GenerateSecret"],
      RefreshTokenValidity: params["RefreshTokenValidity"],
      AccessTokenValidity: params["AccessTokenValidity"],
      IdTokenValidity: params["IdTokenValidity"],
      TokenValidityUnits: fromTokenValidityUnitsType(params["TokenValidityUnits"]),
      ReadAttributes: params["ReadAttributes"],
      WriteAttributes: params["WriteAttributes"],
      ExplicitAuthFlows: params["ExplicitAuthFlows"],
      SupportedIdentityProviders: params["SupportedIdentityProviders"],
      CallbackURLs: params["CallbackURLs"],
      LogoutURLs: params["LogoutURLs"],
      DefaultRedirectURI: params["DefaultRedirectURI"],
      AllowedOAuthFlows: params["AllowedOAuthFlows"],
      AllowedOAuthScopes: params["AllowedOAuthScopes"],
      AllowedOAuthFlowsUserPoolClient: params["AllowedOAuthFlowsUserPoolClient"],
      AnalyticsConfiguration: fromAnalyticsConfigurationType(params["AnalyticsConfiguration"]),
      PreventUserExistenceErrors: params["PreventUserExistenceErrors"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserPoolClient",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPoolClient": toUserPoolClientType,
      },
    }, await resp.json());
  }

  async createUserPoolDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateUserPoolDomainRequest,
  ): Promise<s.CreateUserPoolDomainResponse> {
    const body: jsonP.JSONObject = {
      Domain: params["Domain"],
      UserPoolId: params["UserPoolId"],
      CustomDomainConfig: fromCustomDomainConfigType(params["CustomDomainConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserPoolDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CloudFrontDomain": "s",
      },
    }, await resp.json());
  }

  async deleteGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteGroup",
    });
  }

  async deleteIdentityProvider(
    {abortSignal, ...params}: RequestConfig & s.DeleteIdentityProviderRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ProviderName: params["ProviderName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIdentityProvider",
    });
  }

  async deleteResourceServer(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourceServerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Identifier: params["Identifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourceServer",
    });
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
  }

  async deleteUserAttributes(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserAttributesRequest,
  ): Promise<s.DeleteUserAttributesResponse> {
    const body: jsonP.JSONObject = {
      UserAttributeNames: params["UserAttributeNames"],
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteUserPool(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserPoolRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPool",
    });
  }

  async deleteUserPoolClient(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserPoolClientRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPoolClient",
    });
  }

  async deleteUserPoolDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserPoolDomainRequest,
  ): Promise<s.DeleteUserPoolDomainResponse> {
    const body: jsonP.JSONObject = {
      Domain: params["Domain"],
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserPoolDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeIdentityProvider(
    {abortSignal, ...params}: RequestConfig & s.DescribeIdentityProviderRequest,
  ): Promise<s.DescribeIdentityProviderResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ProviderName: params["ProviderName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIdentityProvider",
    });
    return jsonP.readObj({
      required: {
        "IdentityProvider": toIdentityProviderType,
      },
      optional: {},
    }, await resp.json());
  }

  async describeResourceServer(
    {abortSignal, ...params}: RequestConfig & s.DescribeResourceServerRequest,
  ): Promise<s.DescribeResourceServerResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Identifier: params["Identifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeResourceServer",
    });
    return jsonP.readObj({
      required: {
        "ResourceServer": toResourceServerType,
      },
      optional: {},
    }, await resp.json());
  }

  async describeRiskConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeRiskConfigurationRequest,
  ): Promise<s.DescribeRiskConfigurationResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRiskConfiguration",
    });
    return jsonP.readObj({
      required: {
        "RiskConfiguration": toRiskConfigurationType,
      },
      optional: {},
    }, await resp.json());
  }

  async describeUserImportJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserImportJobRequest,
  ): Promise<s.DescribeUserImportJobResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserImportJob": toUserImportJobType,
      },
    }, await resp.json());
  }

  async describeUserPool(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserPoolRequest,
  ): Promise<s.DescribeUserPoolResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserPool",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPool": toUserPoolType,
      },
    }, await resp.json());
  }

  async describeUserPoolClient(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserPoolClientRequest,
  ): Promise<s.DescribeUserPoolClientResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserPoolClient",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPoolClient": toUserPoolClientType,
      },
    }, await resp.json());
  }

  async describeUserPoolDomain(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserPoolDomainRequest,
  ): Promise<s.DescribeUserPoolDomainResponse> {
    const body: jsonP.JSONObject = {
      Domain: params["Domain"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserPoolDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainDescription": toDomainDescriptionType,
      },
    }, await resp.json());
  }

  async forgetDevice(
    {abortSignal, ...params}: RequestConfig & s.ForgetDeviceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      DeviceKey: params["DeviceKey"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ForgetDevice",
    });
  }

  async forgotPassword(
    {abortSignal, ...params}: RequestConfig & s.ForgotPasswordRequest,
  ): Promise<s.ForgotPasswordResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      SecretHash: params["SecretHash"],
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      Username: params["Username"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ForgotPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CodeDeliveryDetails": toCodeDeliveryDetailsType,
      },
    }, await resp.json());
  }

  async getCSVHeader(
    {abortSignal, ...params}: RequestConfig & s.GetCSVHeaderRequest,
  ): Promise<s.GetCSVHeaderResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCSVHeader",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPoolId": "s",
        "CSVHeader": ["s"],
      },
    }, await resp.json());
  }

  async getDevice(
    {abortSignal, ...params}: RequestConfig & s.GetDeviceRequest,
  ): Promise<s.GetDeviceResponse> {
    const body: jsonP.JSONObject = {
      DeviceKey: params["DeviceKey"],
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDevice",
    });
    return jsonP.readObj({
      required: {
        "Device": toDeviceType,
      },
      optional: {},
    }, await resp.json());
  }

  async getGroup(
    {abortSignal, ...params}: RequestConfig & s.GetGroupRequest,
  ): Promise<s.GetGroupResponse> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroupType,
      },
    }, await resp.json());
  }

  async getIdentityProviderByIdentifier(
    {abortSignal, ...params}: RequestConfig & s.GetIdentityProviderByIdentifierRequest,
  ): Promise<s.GetIdentityProviderByIdentifierResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      IdpIdentifier: params["IdpIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityProviderByIdentifier",
    });
    return jsonP.readObj({
      required: {
        "IdentityProvider": toIdentityProviderType,
      },
      optional: {},
    }, await resp.json());
  }

  async getSigningCertificate(
    {abortSignal, ...params}: RequestConfig & s.GetSigningCertificateRequest,
  ): Promise<s.GetSigningCertificateResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSigningCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": "s",
      },
    }, await resp.json());
  }

  async getUICustomization(
    {abortSignal, ...params}: RequestConfig & s.GetUICustomizationRequest,
  ): Promise<s.GetUICustomizationResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUICustomization",
    });
    return jsonP.readObj({
      required: {
        "UICustomization": toUICustomizationType,
      },
      optional: {},
    }, await resp.json());
  }

  async getUser(
    {abortSignal, ...params}: RequestConfig & s.GetUserRequest,
  ): Promise<s.GetUserResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUser",
    });
    return jsonP.readObj({
      required: {
        "Username": "s",
        "UserAttributes": [toAttributeType],
      },
      optional: {
        "MFAOptions": [toMFAOptionType],
        "PreferredMfaSetting": "s",
        "UserMFASettingList": ["s"],
      },
    }, await resp.json());
  }

  async getUserAttributeVerificationCode(
    {abortSignal, ...params}: RequestConfig & s.GetUserAttributeVerificationCodeRequest,
  ): Promise<s.GetUserAttributeVerificationCodeResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      AttributeName: params["AttributeName"],
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserAttributeVerificationCode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CodeDeliveryDetails": toCodeDeliveryDetailsType,
      },
    }, await resp.json());
  }

  async getUserPoolMfaConfig(
    {abortSignal, ...params}: RequestConfig & s.GetUserPoolMfaConfigRequest,
  ): Promise<s.GetUserPoolMfaConfigResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserPoolMfaConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SmsMfaConfiguration": toSmsMfaConfigType,
        "SoftwareTokenMfaConfiguration": toSoftwareTokenMfaConfigType,
        "MfaConfiguration": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserPoolMfaType>(x),
      },
    }, await resp.json());
  }

  async globalSignOut(
    {abortSignal, ...params}: RequestConfig & s.GlobalSignOutRequest,
  ): Promise<s.GlobalSignOutResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GlobalSignOut",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async initiateAuth(
    {abortSignal, ...params}: RequestConfig & s.InitiateAuthRequest,
  ): Promise<s.InitiateAuthResponse> {
    const body: jsonP.JSONObject = {
      AuthFlow: params["AuthFlow"],
      AuthParameters: params["AuthParameters"],
      ClientMetadata: params["ClientMetadata"],
      ClientId: params["ClientId"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      UserContextData: fromUserContextDataType(params["UserContextData"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitiateAuth",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChallengeName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeNameType>(x),
        "Session": "s",
        "ChallengeParameters": x => jsonP.readMap(String, String, x),
        "AuthenticationResult": toAuthenticationResultType,
      },
    }, await resp.json());
  }

  async listDevices(
    {abortSignal, ...params}: RequestConfig & s.ListDevicesRequest,
  ): Promise<s.ListDevicesResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      Limit: params["Limit"],
      PaginationToken: params["PaginationToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Devices": [toDeviceType],
        "PaginationToken": "s",
      },
    }, await resp.json());
  }

  async listGroups(
    {abortSignal, ...params}: RequestConfig & s.ListGroupsRequest,
  ): Promise<s.ListGroupsResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Groups": [toGroupType],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listIdentityProviders(
    {abortSignal, ...params}: RequestConfig & s.ListIdentityProvidersRequest,
  ): Promise<s.ListIdentityProvidersResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIdentityProviders",
    });
    return jsonP.readObj({
      required: {
        "Providers": [toProviderDescription],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listResourceServers(
    {abortSignal, ...params}: RequestConfig & s.ListResourceServersRequest,
  ): Promise<s.ListResourceServersResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourceServers",
    });
    return jsonP.readObj({
      required: {
        "ResourceServers": [toResourceServerType],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listUserImportJobs(
    {abortSignal, ...params}: RequestConfig & s.ListUserImportJobsRequest,
  ): Promise<s.ListUserImportJobsResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      MaxResults: params["MaxResults"],
      PaginationToken: params["PaginationToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserImportJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserImportJobs": [toUserImportJobType],
        "PaginationToken": "s",
      },
    }, await resp.json());
  }

  async listUserPoolClients(
    {abortSignal, ...params}: RequestConfig & s.ListUserPoolClientsRequest,
  ): Promise<s.ListUserPoolClientsResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserPoolClients",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPoolClients": [toUserPoolClientDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listUserPools(
    {abortSignal, ...params}: RequestConfig & s.ListUserPoolsRequest,
  ): Promise<s.ListUserPoolsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserPools",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPools": [toUserPoolDescriptionType],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listUsers(
    {abortSignal, ...params}: RequestConfig & s.ListUsersRequest,
  ): Promise<s.ListUsersResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      PaginationToken: params["PaginationToken"],
      Filter: params["Filter"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUsers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Users": [toUserType],
        "PaginationToken": "s",
      },
    }, await resp.json());
  }

  async listUsersInGroup(
    {abortSignal, ...params}: RequestConfig & s.ListUsersInGroupRequest,
  ): Promise<s.ListUsersInGroupResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      GroupName: params["GroupName"],
      Limit: params["Limit"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUsersInGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Users": [toUserType],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async resendConfirmationCode(
    {abortSignal, ...params}: RequestConfig & s.ResendConfirmationCodeRequest,
  ): Promise<s.ResendConfirmationCodeResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      SecretHash: params["SecretHash"],
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      Username: params["Username"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResendConfirmationCode",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CodeDeliveryDetails": toCodeDeliveryDetailsType,
      },
    }, await resp.json());
  }

  async respondToAuthChallenge(
    {abortSignal, ...params}: RequestConfig & s.RespondToAuthChallengeRequest,
  ): Promise<s.RespondToAuthChallengeResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      ChallengeName: params["ChallengeName"],
      Session: params["Session"],
      ChallengeResponses: params["ChallengeResponses"],
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RespondToAuthChallenge",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChallengeName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeNameType>(x),
        "Session": "s",
        "ChallengeParameters": x => jsonP.readMap(String, String, x),
        "AuthenticationResult": toAuthenticationResultType,
      },
    }, await resp.json());
  }

  async setRiskConfiguration(
    {abortSignal, ...params}: RequestConfig & s.SetRiskConfigurationRequest,
  ): Promise<s.SetRiskConfigurationResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
      CompromisedCredentialsRiskConfiguration: fromCompromisedCredentialsRiskConfigurationType(params["CompromisedCredentialsRiskConfiguration"]),
      AccountTakeoverRiskConfiguration: fromAccountTakeoverRiskConfigurationType(params["AccountTakeoverRiskConfiguration"]),
      RiskExceptionConfiguration: fromRiskExceptionConfigurationType(params["RiskExceptionConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetRiskConfiguration",
    });
    return jsonP.readObj({
      required: {
        "RiskConfiguration": toRiskConfigurationType,
      },
      optional: {},
    }, await resp.json());
  }

  async setUICustomization(
    {abortSignal, ...params}: RequestConfig & s.SetUICustomizationRequest,
  ): Promise<s.SetUICustomizationResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
      CSS: params["CSS"],
      ImageFile: serializeBlob(params["ImageFile"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetUICustomization",
    });
    return jsonP.readObj({
      required: {
        "UICustomization": toUICustomizationType,
      },
      optional: {},
    }, await resp.json());
  }

  async setUserMFAPreference(
    {abortSignal, ...params}: RequestConfig & s.SetUserMFAPreferenceRequest,
  ): Promise<s.SetUserMFAPreferenceResponse> {
    const body: jsonP.JSONObject = {
      SMSMfaSettings: fromSMSMfaSettingsType(params["SMSMfaSettings"]),
      SoftwareTokenMfaSettings: fromSoftwareTokenMfaSettingsType(params["SoftwareTokenMfaSettings"]),
      AccessToken: params["AccessToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetUserMFAPreference",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async setUserPoolMfaConfig(
    {abortSignal, ...params}: RequestConfig & s.SetUserPoolMfaConfigRequest,
  ): Promise<s.SetUserPoolMfaConfigResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      SmsMfaConfiguration: fromSmsMfaConfigType(params["SmsMfaConfiguration"]),
      SoftwareTokenMfaConfiguration: fromSoftwareTokenMfaConfigType(params["SoftwareTokenMfaConfiguration"]),
      MfaConfiguration: params["MfaConfiguration"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetUserPoolMfaConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SmsMfaConfiguration": toSmsMfaConfigType,
        "SoftwareTokenMfaConfiguration": toSoftwareTokenMfaConfigType,
        "MfaConfiguration": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserPoolMfaType>(x),
      },
    }, await resp.json());
  }

  async setUserSettings(
    {abortSignal, ...params}: RequestConfig & s.SetUserSettingsRequest,
  ): Promise<s.SetUserSettingsResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      MFAOptions: params["MFAOptions"]?.map(x => fromMFAOptionType(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetUserSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async signUp(
    {abortSignal, ...params}: RequestConfig & s.SignUpRequest,
  ): Promise<s.SignUpResponse> {
    const body: jsonP.JSONObject = {
      ClientId: params["ClientId"],
      SecretHash: params["SecretHash"],
      Username: params["Username"],
      Password: params["Password"],
      UserAttributes: params["UserAttributes"]?.map(x => fromAttributeType(x)),
      ValidationData: params["ValidationData"]?.map(x => fromAttributeType(x)),
      AnalyticsMetadata: fromAnalyticsMetadataType(params["AnalyticsMetadata"]),
      UserContextData: fromUserContextDataType(params["UserContextData"]),
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SignUp",
    });
    return jsonP.readObj({
      required: {
        "UserConfirmed": "b",
        "UserSub": "s",
      },
      optional: {
        "CodeDeliveryDetails": toCodeDeliveryDetailsType,
      },
    }, await resp.json());
  }

  async startUserImportJob(
    {abortSignal, ...params}: RequestConfig & s.StartUserImportJobRequest,
  ): Promise<s.StartUserImportJobResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartUserImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserImportJob": toUserImportJobType,
      },
    }, await resp.json());
  }

  async stopUserImportJob(
    {abortSignal, ...params}: RequestConfig & s.StopUserImportJobRequest,
  ): Promise<s.StopUserImportJobResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopUserImportJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserImportJob": toUserImportJobType,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateAuthEventFeedback(
    {abortSignal, ...params}: RequestConfig & s.UpdateAuthEventFeedbackRequest,
  ): Promise<s.UpdateAuthEventFeedbackResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Username: params["Username"],
      EventId: params["EventId"],
      FeedbackToken: params["FeedbackToken"],
      FeedbackValue: params["FeedbackValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuthEventFeedback",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDeviceStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdateDeviceStatusRequest,
  ): Promise<s.UpdateDeviceStatusResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      DeviceKey: params["DeviceKey"],
      DeviceRememberedStatus: params["DeviceRememberedStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeviceStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateGroupRequest,
  ): Promise<s.UpdateGroupResponse> {
    const body: jsonP.JSONObject = {
      GroupName: params["GroupName"],
      UserPoolId: params["UserPoolId"],
      Description: params["Description"],
      RoleArn: params["RoleArn"],
      Precedence: params["Precedence"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Group": toGroupType,
      },
    }, await resp.json());
  }

  async updateIdentityProvider(
    {abortSignal, ...params}: RequestConfig & s.UpdateIdentityProviderRequest,
  ): Promise<s.UpdateIdentityProviderResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ProviderName: params["ProviderName"],
      ProviderDetails: params["ProviderDetails"],
      AttributeMapping: params["AttributeMapping"],
      IdpIdentifiers: params["IdpIdentifiers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIdentityProvider",
    });
    return jsonP.readObj({
      required: {
        "IdentityProvider": toIdentityProviderType,
      },
      optional: {},
    }, await resp.json());
  }

  async updateResourceServer(
    {abortSignal, ...params}: RequestConfig & s.UpdateResourceServerRequest,
  ): Promise<s.UpdateResourceServerResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Identifier: params["Identifier"],
      Name: params["Name"],
      Scopes: params["Scopes"]?.map(x => fromResourceServerScopeType(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResourceServer",
    });
    return jsonP.readObj({
      required: {
        "ResourceServer": toResourceServerType,
      },
      optional: {},
    }, await resp.json());
  }

  async updateUserAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserAttributesRequest,
  ): Promise<s.UpdateUserAttributesResponse> {
    const body: jsonP.JSONObject = {
      UserAttributes: params["UserAttributes"]?.map(x => fromAttributeType(x)),
      AccessToken: params["AccessToken"],
      ClientMetadata: params["ClientMetadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CodeDeliveryDetailsList": [toCodeDeliveryDetailsType],
      },
    }, await resp.json());
  }

  async updateUserPool(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserPoolRequest,
  ): Promise<s.UpdateUserPoolResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      Policies: fromUserPoolPolicyType(params["Policies"]),
      LambdaConfig: fromLambdaConfigType(params["LambdaConfig"]),
      AutoVerifiedAttributes: params["AutoVerifiedAttributes"],
      SmsVerificationMessage: params["SmsVerificationMessage"],
      EmailVerificationMessage: params["EmailVerificationMessage"],
      EmailVerificationSubject: params["EmailVerificationSubject"],
      VerificationMessageTemplate: fromVerificationMessageTemplateType(params["VerificationMessageTemplate"]),
      SmsAuthenticationMessage: params["SmsAuthenticationMessage"],
      MfaConfiguration: params["MfaConfiguration"],
      DeviceConfiguration: fromDeviceConfigurationType(params["DeviceConfiguration"]),
      EmailConfiguration: fromEmailConfigurationType(params["EmailConfiguration"]),
      SmsConfiguration: fromSmsConfigurationType(params["SmsConfiguration"]),
      UserPoolTags: params["UserPoolTags"],
      AdminCreateUserConfig: fromAdminCreateUserConfigType(params["AdminCreateUserConfig"]),
      UserPoolAddOns: fromUserPoolAddOnsType(params["UserPoolAddOns"]),
      AccountRecoverySetting: fromAccountRecoverySettingType(params["AccountRecoverySetting"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserPool",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateUserPoolClient(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserPoolClientRequest,
  ): Promise<s.UpdateUserPoolClientResponse> {
    const body: jsonP.JSONObject = {
      UserPoolId: params["UserPoolId"],
      ClientId: params["ClientId"],
      ClientName: params["ClientName"],
      RefreshTokenValidity: params["RefreshTokenValidity"],
      AccessTokenValidity: params["AccessTokenValidity"],
      IdTokenValidity: params["IdTokenValidity"],
      TokenValidityUnits: fromTokenValidityUnitsType(params["TokenValidityUnits"]),
      ReadAttributes: params["ReadAttributes"],
      WriteAttributes: params["WriteAttributes"],
      ExplicitAuthFlows: params["ExplicitAuthFlows"],
      SupportedIdentityProviders: params["SupportedIdentityProviders"],
      CallbackURLs: params["CallbackURLs"],
      LogoutURLs: params["LogoutURLs"],
      DefaultRedirectURI: params["DefaultRedirectURI"],
      AllowedOAuthFlows: params["AllowedOAuthFlows"],
      AllowedOAuthScopes: params["AllowedOAuthScopes"],
      AllowedOAuthFlowsUserPoolClient: params["AllowedOAuthFlowsUserPoolClient"],
      AnalyticsConfiguration: fromAnalyticsConfigurationType(params["AnalyticsConfiguration"]),
      PreventUserExistenceErrors: params["PreventUserExistenceErrors"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserPoolClient",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserPoolClient": toUserPoolClientType,
      },
    }, await resp.json());
  }

  async updateUserPoolDomain(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserPoolDomainRequest,
  ): Promise<s.UpdateUserPoolDomainResponse> {
    const body: jsonP.JSONObject = {
      Domain: params["Domain"],
      UserPoolId: params["UserPoolId"],
      CustomDomainConfig: fromCustomDomainConfigType(params["CustomDomainConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserPoolDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CloudFrontDomain": "s",
      },
    }, await resp.json());
  }

  async verifySoftwareToken(
    {abortSignal, ...params}: RequestConfig & s.VerifySoftwareTokenRequest,
  ): Promise<s.VerifySoftwareTokenResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      Session: params["Session"],
      UserCode: params["UserCode"],
      FriendlyDeviceName: params["FriendlyDeviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifySoftwareToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VerifySoftwareTokenResponseType>(x),
        "Session": "s",
      },
    }, await resp.json());
  }

  async verifyUserAttribute(
    {abortSignal, ...params}: RequestConfig & s.VerifyUserAttributeRequest,
  ): Promise<s.VerifyUserAttributeResponse> {
    const body: jsonP.JSONObject = {
      AccessToken: params["AccessToken"],
      AttributeName: params["AttributeName"],
      Code: params["Code"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyUserAttribute",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromSchemaAttributeType(input?: s.SchemaAttributeType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    AttributeDataType: input["AttributeDataType"],
    DeveloperOnlyAttribute: input["DeveloperOnlyAttribute"],
    Mutable: input["Mutable"],
    Required: input["Required"],
    NumberAttributeConstraints: fromNumberAttributeConstraintsType(input["NumberAttributeConstraints"]),
    StringAttributeConstraints: fromStringAttributeConstraintsType(input["StringAttributeConstraints"]),
  }
}
function toSchemaAttributeType(root: jsonP.JSONValue): s.SchemaAttributeType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "AttributeDataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AttributeDataType>(x),
      "DeveloperOnlyAttribute": "b",
      "Mutable": "b",
      "Required": "b",
      "NumberAttributeConstraints": toNumberAttributeConstraintsType,
      "StringAttributeConstraints": toStringAttributeConstraintsType,
    },
  }, root);
}

function fromNumberAttributeConstraintsType(input?: s.NumberAttributeConstraintsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
  }
}
function toNumberAttributeConstraintsType(root: jsonP.JSONValue): s.NumberAttributeConstraintsType {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinValue": "s",
      "MaxValue": "s",
    },
  }, root);
}

function fromStringAttributeConstraintsType(input?: s.StringAttributeConstraintsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinLength: input["MinLength"],
    MaxLength: input["MaxLength"],
  }
}
function toStringAttributeConstraintsType(root: jsonP.JSONValue): s.StringAttributeConstraintsType {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinLength": "s",
      "MaxLength": "s",
    },
  }, root);
}

function fromAttributeType(input?: s.AttributeType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toAttributeType(root: jsonP.JSONValue): s.AttributeType {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromProviderUserIdentifierType(input?: s.ProviderUserIdentifierType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProviderName: input["ProviderName"],
    ProviderAttributeName: input["ProviderAttributeName"],
    ProviderAttributeValue: input["ProviderAttributeValue"],
  }
}

function fromAnalyticsMetadataType(input?: s.AnalyticsMetadataType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AnalyticsEndpointId: input["AnalyticsEndpointId"],
  }
}

function fromContextDataType(input?: s.ContextDataType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IpAddress: input["IpAddress"],
    ServerName: input["ServerName"],
    ServerPath: input["ServerPath"],
    HttpHeaders: input["HttpHeaders"]?.map(x => fromHttpHeader(x)),
    EncodedData: input["EncodedData"],
  }
}

function fromHttpHeader(input?: s.HttpHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    headerName: input["headerName"],
    headerValue: input["headerValue"],
  }
}

function fromSMSMfaSettingsType(input?: s.SMSMfaSettingsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    PreferredMfa: input["PreferredMfa"],
  }
}

function fromSoftwareTokenMfaSettingsType(input?: s.SoftwareTokenMfaSettingsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    PreferredMfa: input["PreferredMfa"],
  }
}

function fromMFAOptionType(input?: s.MFAOptionType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeliveryMedium: input["DeliveryMedium"],
    AttributeName: input["AttributeName"],
  }
}
function toMFAOptionType(root: jsonP.JSONValue): s.MFAOptionType {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeliveryMedium": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryMediumType>(x),
      "AttributeName": "s",
    },
  }, root);
}

function fromDeviceSecretVerifierConfigType(input?: s.DeviceSecretVerifierConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PasswordVerifier: input["PasswordVerifier"],
    Salt: input["Salt"],
  }
}

function fromUserContextDataType(input?: s.UserContextDataType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncodedData: input["EncodedData"],
  }
}

function fromResourceServerScopeType(input?: s.ResourceServerScopeType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ScopeName: input["ScopeName"],
    ScopeDescription: input["ScopeDescription"],
  }
}
function toResourceServerScopeType(root: jsonP.JSONValue): s.ResourceServerScopeType {
  return jsonP.readObj({
    required: {
      "ScopeName": "s",
      "ScopeDescription": "s",
    },
    optional: {},
  }, root);
}

function fromUserPoolPolicyType(input?: s.UserPoolPolicyType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PasswordPolicy: fromPasswordPolicyType(input["PasswordPolicy"]),
  }
}
function toUserPoolPolicyType(root: jsonP.JSONValue): s.UserPoolPolicyType {
  return jsonP.readObj({
    required: {},
    optional: {
      "PasswordPolicy": toPasswordPolicyType,
    },
  }, root);
}

function fromPasswordPolicyType(input?: s.PasswordPolicyType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumLength: input["MinimumLength"],
    RequireUppercase: input["RequireUppercase"],
    RequireLowercase: input["RequireLowercase"],
    RequireNumbers: input["RequireNumbers"],
    RequireSymbols: input["RequireSymbols"],
    TemporaryPasswordValidityDays: input["TemporaryPasswordValidityDays"],
  }
}
function toPasswordPolicyType(root: jsonP.JSONValue): s.PasswordPolicyType {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinimumLength": "n",
      "RequireUppercase": "b",
      "RequireLowercase": "b",
      "RequireNumbers": "b",
      "RequireSymbols": "b",
      "TemporaryPasswordValidityDays": "n",
    },
  }, root);
}

function fromLambdaConfigType(input?: s.LambdaConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PreSignUp: input["PreSignUp"],
    CustomMessage: input["CustomMessage"],
    PostConfirmation: input["PostConfirmation"],
    PreAuthentication: input["PreAuthentication"],
    PostAuthentication: input["PostAuthentication"],
    DefineAuthChallenge: input["DefineAuthChallenge"],
    CreateAuthChallenge: input["CreateAuthChallenge"],
    VerifyAuthChallengeResponse: input["VerifyAuthChallengeResponse"],
    PreTokenGeneration: input["PreTokenGeneration"],
    UserMigration: input["UserMigration"],
    CustomSMSSender: fromCustomSMSLambdaVersionConfigType(input["CustomSMSSender"]),
    CustomEmailSender: fromCustomEmailLambdaVersionConfigType(input["CustomEmailSender"]),
    KMSKeyID: input["KMSKeyID"],
  }
}
function toLambdaConfigType(root: jsonP.JSONValue): s.LambdaConfigType {
  return jsonP.readObj({
    required: {},
    optional: {
      "PreSignUp": "s",
      "CustomMessage": "s",
      "PostConfirmation": "s",
      "PreAuthentication": "s",
      "PostAuthentication": "s",
      "DefineAuthChallenge": "s",
      "CreateAuthChallenge": "s",
      "VerifyAuthChallengeResponse": "s",
      "PreTokenGeneration": "s",
      "UserMigration": "s",
      "CustomSMSSender": toCustomSMSLambdaVersionConfigType,
      "CustomEmailSender": toCustomEmailLambdaVersionConfigType,
      "KMSKeyID": "s",
    },
  }, root);
}

function fromCustomSMSLambdaVersionConfigType(input?: s.CustomSMSLambdaVersionConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LambdaVersion: input["LambdaVersion"],
    LambdaArn: input["LambdaArn"],
  }
}
function toCustomSMSLambdaVersionConfigType(root: jsonP.JSONValue): s.CustomSMSLambdaVersionConfigType {
  return jsonP.readObj({
    required: {
      "LambdaVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomSMSSenderLambdaVersionType>(x),
      "LambdaArn": "s",
    },
    optional: {},
  }, root);
}

function fromCustomEmailLambdaVersionConfigType(input?: s.CustomEmailLambdaVersionConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LambdaVersion: input["LambdaVersion"],
    LambdaArn: input["LambdaArn"],
  }
}
function toCustomEmailLambdaVersionConfigType(root: jsonP.JSONValue): s.CustomEmailLambdaVersionConfigType {
  return jsonP.readObj({
    required: {
      "LambdaVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomEmailSenderLambdaVersionType>(x),
      "LambdaArn": "s",
    },
    optional: {},
  }, root);
}

function fromVerificationMessageTemplateType(input?: s.VerificationMessageTemplateType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SmsMessage: input["SmsMessage"],
    EmailMessage: input["EmailMessage"],
    EmailSubject: input["EmailSubject"],
    EmailMessageByLink: input["EmailMessageByLink"],
    EmailSubjectByLink: input["EmailSubjectByLink"],
    DefaultEmailOption: input["DefaultEmailOption"],
  }
}
function toVerificationMessageTemplateType(root: jsonP.JSONValue): s.VerificationMessageTemplateType {
  return jsonP.readObj({
    required: {},
    optional: {
      "SmsMessage": "s",
      "EmailMessage": "s",
      "EmailSubject": "s",
      "EmailMessageByLink": "s",
      "EmailSubjectByLink": "s",
      "DefaultEmailOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.DefaultEmailOptionType>(x),
    },
  }, root);
}

function fromDeviceConfigurationType(input?: s.DeviceConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ChallengeRequiredOnNewDevice: input["ChallengeRequiredOnNewDevice"],
    DeviceOnlyRememberedOnUserPrompt: input["DeviceOnlyRememberedOnUserPrompt"],
  }
}
function toDeviceConfigurationType(root: jsonP.JSONValue): s.DeviceConfigurationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChallengeRequiredOnNewDevice": "b",
      "DeviceOnlyRememberedOnUserPrompt": "b",
    },
  }, root);
}

function fromEmailConfigurationType(input?: s.EmailConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceArn: input["SourceArn"],
    ReplyToEmailAddress: input["ReplyToEmailAddress"],
    EmailSendingAccount: input["EmailSendingAccount"],
    From: input["From"],
    ConfigurationSet: input["ConfigurationSet"],
  }
}
function toEmailConfigurationType(root: jsonP.JSONValue): s.EmailConfigurationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceArn": "s",
      "ReplyToEmailAddress": "s",
      "EmailSendingAccount": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmailSendingAccountType>(x),
      "From": "s",
      "ConfigurationSet": "s",
    },
  }, root);
}

function fromSmsConfigurationType(input?: s.SmsConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SnsCallerArn: input["SnsCallerArn"],
    ExternalId: input["ExternalId"],
  }
}
function toSmsConfigurationType(root: jsonP.JSONValue): s.SmsConfigurationType {
  return jsonP.readObj({
    required: {
      "SnsCallerArn": "s",
    },
    optional: {
      "ExternalId": "s",
    },
  }, root);
}

function fromAdminCreateUserConfigType(input?: s.AdminCreateUserConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowAdminCreateUserOnly: input["AllowAdminCreateUserOnly"],
    UnusedAccountValidityDays: input["UnusedAccountValidityDays"],
    InviteMessageTemplate: fromMessageTemplateType(input["InviteMessageTemplate"]),
  }
}
function toAdminCreateUserConfigType(root: jsonP.JSONValue): s.AdminCreateUserConfigType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowAdminCreateUserOnly": "b",
      "UnusedAccountValidityDays": "n",
      "InviteMessageTemplate": toMessageTemplateType,
    },
  }, root);
}

function fromMessageTemplateType(input?: s.MessageTemplateType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SMSMessage: input["SMSMessage"],
    EmailMessage: input["EmailMessage"],
    EmailSubject: input["EmailSubject"],
  }
}
function toMessageTemplateType(root: jsonP.JSONValue): s.MessageTemplateType {
  return jsonP.readObj({
    required: {},
    optional: {
      "SMSMessage": "s",
      "EmailMessage": "s",
      "EmailSubject": "s",
    },
  }, root);
}

function fromUserPoolAddOnsType(input?: s.UserPoolAddOnsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdvancedSecurityMode: input["AdvancedSecurityMode"],
  }
}
function toUserPoolAddOnsType(root: jsonP.JSONValue): s.UserPoolAddOnsType {
  return jsonP.readObj({
    required: {
      "AdvancedSecurityMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdvancedSecurityModeType>(x),
    },
    optional: {},
  }, root);
}

function fromUsernameConfigurationType(input?: s.UsernameConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CaseSensitive: input["CaseSensitive"],
  }
}
function toUsernameConfigurationType(root: jsonP.JSONValue): s.UsernameConfigurationType {
  return jsonP.readObj({
    required: {
      "CaseSensitive": "b",
    },
    optional: {},
  }, root);
}

function fromAccountRecoverySettingType(input?: s.AccountRecoverySettingType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecoveryMechanisms: input["RecoveryMechanisms"]?.map(x => fromRecoveryOptionType(x)),
  }
}
function toAccountRecoverySettingType(root: jsonP.JSONValue): s.AccountRecoverySettingType {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecoveryMechanisms": [toRecoveryOptionType],
    },
  }, root);
}

function fromRecoveryOptionType(input?: s.RecoveryOptionType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Priority: input["Priority"],
    Name: input["Name"],
  }
}
function toRecoveryOptionType(root: jsonP.JSONValue): s.RecoveryOptionType {
  return jsonP.readObj({
    required: {
      "Priority": "n",
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecoveryOptionNameType>(x),
    },
    optional: {},
  }, root);
}

function fromTokenValidityUnitsType(input?: s.TokenValidityUnitsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccessToken: input["AccessToken"],
    IdToken: input["IdToken"],
    RefreshToken: input["RefreshToken"],
  }
}
function toTokenValidityUnitsType(root: jsonP.JSONValue): s.TokenValidityUnitsType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessToken": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnitsType>(x),
      "IdToken": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnitsType>(x),
      "RefreshToken": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnitsType>(x),
    },
  }, root);
}

function fromAnalyticsConfigurationType(input?: s.AnalyticsConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApplicationId: input["ApplicationId"],
    ApplicationArn: input["ApplicationArn"],
    RoleArn: input["RoleArn"],
    ExternalId: input["ExternalId"],
    UserDataShared: input["UserDataShared"],
  }
}
function toAnalyticsConfigurationType(root: jsonP.JSONValue): s.AnalyticsConfigurationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApplicationId": "s",
      "ApplicationArn": "s",
      "RoleArn": "s",
      "ExternalId": "s",
      "UserDataShared": "b",
    },
  }, root);
}

function fromCustomDomainConfigType(input?: s.CustomDomainConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateArn: input["CertificateArn"],
  }
}
function toCustomDomainConfigType(root: jsonP.JSONValue): s.CustomDomainConfigType {
  return jsonP.readObj({
    required: {
      "CertificateArn": "s",
    },
    optional: {},
  }, root);
}

function fromCompromisedCredentialsRiskConfigurationType(input?: s.CompromisedCredentialsRiskConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EventFilter: input["EventFilter"],
    Actions: fromCompromisedCredentialsActionsType(input["Actions"]),
  }
}
function toCompromisedCredentialsRiskConfigurationType(root: jsonP.JSONValue): s.CompromisedCredentialsRiskConfigurationType {
  return jsonP.readObj({
    required: {
      "Actions": toCompromisedCredentialsActionsType,
    },
    optional: {
      "EventFilter": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EventFilterType>(x)],
    },
  }, root);
}

function fromCompromisedCredentialsActionsType(input?: s.CompromisedCredentialsActionsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EventAction: input["EventAction"],
  }
}
function toCompromisedCredentialsActionsType(root: jsonP.JSONValue): s.CompromisedCredentialsActionsType {
  return jsonP.readObj({
    required: {
      "EventAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompromisedCredentialsEventActionType>(x),
    },
    optional: {},
  }, root);
}

function fromAccountTakeoverRiskConfigurationType(input?: s.AccountTakeoverRiskConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotifyConfiguration: fromNotifyConfigurationType(input["NotifyConfiguration"]),
    Actions: fromAccountTakeoverActionsType(input["Actions"]),
  }
}
function toAccountTakeoverRiskConfigurationType(root: jsonP.JSONValue): s.AccountTakeoverRiskConfigurationType {
  return jsonP.readObj({
    required: {
      "Actions": toAccountTakeoverActionsType,
    },
    optional: {
      "NotifyConfiguration": toNotifyConfigurationType,
    },
  }, root);
}

function fromNotifyConfigurationType(input?: s.NotifyConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    From: input["From"],
    ReplyTo: input["ReplyTo"],
    SourceArn: input["SourceArn"],
    BlockEmail: fromNotifyEmailType(input["BlockEmail"]),
    NoActionEmail: fromNotifyEmailType(input["NoActionEmail"]),
    MfaEmail: fromNotifyEmailType(input["MfaEmail"]),
  }
}
function toNotifyConfigurationType(root: jsonP.JSONValue): s.NotifyConfigurationType {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "From": "s",
      "ReplyTo": "s",
      "BlockEmail": toNotifyEmailType,
      "NoActionEmail": toNotifyEmailType,
      "MfaEmail": toNotifyEmailType,
    },
  }, root);
}

function fromNotifyEmailType(input?: s.NotifyEmailType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Subject: input["Subject"],
    HtmlBody: input["HtmlBody"],
    TextBody: input["TextBody"],
  }
}
function toNotifyEmailType(root: jsonP.JSONValue): s.NotifyEmailType {
  return jsonP.readObj({
    required: {
      "Subject": "s",
    },
    optional: {
      "HtmlBody": "s",
      "TextBody": "s",
    },
  }, root);
}

function fromAccountTakeoverActionsType(input?: s.AccountTakeoverActionsType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LowAction: fromAccountTakeoverActionType(input["LowAction"]),
    MediumAction: fromAccountTakeoverActionType(input["MediumAction"]),
    HighAction: fromAccountTakeoverActionType(input["HighAction"]),
  }
}
function toAccountTakeoverActionsType(root: jsonP.JSONValue): s.AccountTakeoverActionsType {
  return jsonP.readObj({
    required: {},
    optional: {
      "LowAction": toAccountTakeoverActionType,
      "MediumAction": toAccountTakeoverActionType,
      "HighAction": toAccountTakeoverActionType,
    },
  }, root);
}

function fromAccountTakeoverActionType(input?: s.AccountTakeoverActionType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Notify: input["Notify"],
    EventAction: input["EventAction"],
  }
}
function toAccountTakeoverActionType(root: jsonP.JSONValue): s.AccountTakeoverActionType {
  return jsonP.readObj({
    required: {
      "Notify": "b",
      "EventAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccountTakeoverEventActionType>(x),
    },
    optional: {},
  }, root);
}

function fromRiskExceptionConfigurationType(input?: s.RiskExceptionConfigurationType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlockedIPRangeList: input["BlockedIPRangeList"],
    SkippedIPRangeList: input["SkippedIPRangeList"],
  }
}
function toRiskExceptionConfigurationType(root: jsonP.JSONValue): s.RiskExceptionConfigurationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockedIPRangeList": ["s"],
      "SkippedIPRangeList": ["s"],
    },
  }, root);
}

function fromSmsMfaConfigType(input?: s.SmsMfaConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SmsAuthenticationMessage: input["SmsAuthenticationMessage"],
    SmsConfiguration: fromSmsConfigurationType(input["SmsConfiguration"]),
  }
}
function toSmsMfaConfigType(root: jsonP.JSONValue): s.SmsMfaConfigType {
  return jsonP.readObj({
    required: {},
    optional: {
      "SmsAuthenticationMessage": "s",
      "SmsConfiguration": toSmsConfigurationType,
    },
  }, root);
}

function fromSoftwareTokenMfaConfigType(input?: s.SoftwareTokenMfaConfigType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toSoftwareTokenMfaConfigType(root: jsonP.JSONValue): s.SoftwareTokenMfaConfigType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function toUserType(root: jsonP.JSONValue): s.UserType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Attributes": [toAttributeType],
      "UserCreateDate": "d",
      "UserLastModifiedDate": "d",
      "Enabled": "b",
      "UserStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserStatusType>(x),
      "MFAOptions": [toMFAOptionType],
    },
  }, root);
}

function toDeviceType(root: jsonP.JSONValue): s.DeviceType {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeviceKey": "s",
      "DeviceAttributes": [toAttributeType],
      "DeviceCreateDate": "d",
      "DeviceLastModifiedDate": "d",
      "DeviceLastAuthenticatedDate": "d",
    },
  }, root);
}

function toAuthenticationResultType(root: jsonP.JSONValue): s.AuthenticationResultType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessToken": "s",
      "ExpiresIn": "n",
      "TokenType": "s",
      "RefreshToken": "s",
      "IdToken": "s",
      "NewDeviceMetadata": toNewDeviceMetadataType,
    },
  }, root);
}

function toNewDeviceMetadataType(root: jsonP.JSONValue): s.NewDeviceMetadataType {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeviceKey": "s",
      "DeviceGroupKey": "s",
    },
  }, root);
}

function toGroupType(root: jsonP.JSONValue): s.GroupType {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "UserPoolId": "s",
      "Description": "s",
      "RoleArn": "s",
      "Precedence": "n",
      "LastModifiedDate": "d",
      "CreationDate": "d",
    },
  }, root);
}

function toAuthEventType(root: jsonP.JSONValue): s.AuthEventType {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventId": "s",
      "EventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventType>(x),
      "CreationDate": "d",
      "EventResponse": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventResponseType>(x),
      "EventRisk": toEventRiskType,
      "ChallengeResponses": [toChallengeResponseType],
      "EventContextData": toEventContextDataType,
      "EventFeedback": toEventFeedbackType,
    },
  }, root);
}

function toEventRiskType(root: jsonP.JSONValue): s.EventRiskType {
  return jsonP.readObj({
    required: {},
    optional: {
      "RiskDecision": (x: jsonP.JSONValue) => cmnP.readEnum<s.RiskDecisionType>(x),
      "RiskLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.RiskLevelType>(x),
      "CompromisedCredentialsDetected": "b",
    },
  }, root);
}

function toChallengeResponseType(root: jsonP.JSONValue): s.ChallengeResponseType {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChallengeName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeName>(x),
      "ChallengeResponse": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChallengeResponse>(x),
    },
  }, root);
}

function toEventContextDataType(root: jsonP.JSONValue): s.EventContextDataType {
  return jsonP.readObj({
    required: {},
    optional: {
      "IpAddress": "s",
      "DeviceName": "s",
      "Timezone": "s",
      "City": "s",
      "Country": "s",
    },
  }, root);
}

function toEventFeedbackType(root: jsonP.JSONValue): s.EventFeedbackType {
  return jsonP.readObj({
    required: {
      "FeedbackValue": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeedbackValueType>(x),
      "Provider": "s",
    },
    optional: {
      "FeedbackDate": "d",
    },
  }, root);
}

function toIdentityProviderType(root: jsonP.JSONValue): s.IdentityProviderType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "ProviderName": "s",
      "ProviderType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityProviderTypeType>(x),
      "ProviderDetails": x => jsonP.readMap(String, String, x),
      "AttributeMapping": x => jsonP.readMap(String, String, x),
      "IdpIdentifiers": ["s"],
      "LastModifiedDate": "d",
      "CreationDate": "d",
    },
  }, root);
}

function toResourceServerType(root: jsonP.JSONValue): s.ResourceServerType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "Identifier": "s",
      "Name": "s",
      "Scopes": [toResourceServerScopeType],
    },
  }, root);
}

function toUserImportJobType(root: jsonP.JSONValue): s.UserImportJobType {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "JobId": "s",
      "UserPoolId": "s",
      "PreSignedUrl": "s",
      "CreationDate": "d",
      "StartDate": "d",
      "CompletionDate": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserImportJobStatusType>(x),
      "CloudWatchLogsRoleArn": "s",
      "ImportedUsers": "n",
      "SkippedUsers": "n",
      "FailedUsers": "n",
      "CompletionMessage": "s",
    },
  }, root);
}

function toUserPoolType(root: jsonP.JSONValue): s.UserPoolType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Policies": toUserPoolPolicyType,
      "LambdaConfig": toLambdaConfigType,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "LastModifiedDate": "d",
      "CreationDate": "d",
      "SchemaAttributes": [toSchemaAttributeType],
      "AutoVerifiedAttributes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.VerifiedAttributeType>(x)],
      "AliasAttributes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.AliasAttributeType>(x)],
      "UsernameAttributes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.UsernameAttributeType>(x)],
      "SmsVerificationMessage": "s",
      "EmailVerificationMessage": "s",
      "EmailVerificationSubject": "s",
      "VerificationMessageTemplate": toVerificationMessageTemplateType,
      "SmsAuthenticationMessage": "s",
      "MfaConfiguration": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserPoolMfaType>(x),
      "DeviceConfiguration": toDeviceConfigurationType,
      "EstimatedNumberOfUsers": "n",
      "EmailConfiguration": toEmailConfigurationType,
      "SmsConfiguration": toSmsConfigurationType,
      "UserPoolTags": x => jsonP.readMap(String, String, x),
      "SmsConfigurationFailure": "s",
      "EmailConfigurationFailure": "s",
      "Domain": "s",
      "CustomDomain": "s",
      "AdminCreateUserConfig": toAdminCreateUserConfigType,
      "UserPoolAddOns": toUserPoolAddOnsType,
      "UsernameConfiguration": toUsernameConfigurationType,
      "Arn": "s",
      "AccountRecoverySetting": toAccountRecoverySettingType,
    },
  }, root);
}

function toUserPoolClientType(root: jsonP.JSONValue): s.UserPoolClientType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "ClientName": "s",
      "ClientId": "s",
      "ClientSecret": "s",
      "LastModifiedDate": "d",
      "CreationDate": "d",
      "RefreshTokenValidity": "n",
      "AccessTokenValidity": "n",
      "IdTokenValidity": "n",
      "TokenValidityUnits": toTokenValidityUnitsType,
      "ReadAttributes": ["s"],
      "WriteAttributes": ["s"],
      "ExplicitAuthFlows": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ExplicitAuthFlowsType>(x)],
      "SupportedIdentityProviders": ["s"],
      "CallbackURLs": ["s"],
      "LogoutURLs": ["s"],
      "DefaultRedirectURI": "s",
      "AllowedOAuthFlows": [(x: jsonP.JSONValue) => cmnP.readEnum<s.OAuthFlowType>(x)],
      "AllowedOAuthScopes": ["s"],
      "AllowedOAuthFlowsUserPoolClient": "b",
      "AnalyticsConfiguration": toAnalyticsConfigurationType,
      "PreventUserExistenceErrors": (x: jsonP.JSONValue) => cmnP.readEnum<s.PreventUserExistenceErrorTypes>(x),
    },
  }, root);
}

function toRiskConfigurationType(root: jsonP.JSONValue): s.RiskConfigurationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "ClientId": "s",
      "CompromisedCredentialsRiskConfiguration": toCompromisedCredentialsRiskConfigurationType,
      "AccountTakeoverRiskConfiguration": toAccountTakeoverRiskConfigurationType,
      "RiskExceptionConfiguration": toRiskExceptionConfigurationType,
      "LastModifiedDate": "d",
    },
  }, root);
}

function toDomainDescriptionType(root: jsonP.JSONValue): s.DomainDescriptionType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "AWSAccountId": "s",
      "Domain": "s",
      "S3Bucket": "s",
      "CloudFrontDistribution": "s",
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatusType>(x),
      "CustomDomainConfig": toCustomDomainConfigType,
    },
  }, root);
}

function toCodeDeliveryDetailsType(root: jsonP.JSONValue): s.CodeDeliveryDetailsType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
      "DeliveryMedium": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryMediumType>(x),
      "AttributeName": "s",
    },
  }, root);
}

function toUICustomizationType(root: jsonP.JSONValue): s.UICustomizationType {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserPoolId": "s",
      "ClientId": "s",
      "ImageUrl": "s",
      "CSS": "s",
      "CSSVersion": "s",
      "LastModifiedDate": "d",
      "CreationDate": "d",
    },
  }, root);
}

function toProviderDescription(root: jsonP.JSONValue): s.ProviderDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProviderName": "s",
      "ProviderType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IdentityProviderTypeType>(x),
      "LastModifiedDate": "d",
      "CreationDate": "d",
    },
  }, root);
}

function toUserPoolClientDescription(root: jsonP.JSONValue): s.UserPoolClientDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientId": "s",
      "UserPoolId": "s",
      "ClientName": "s",
    },
  }, root);
}

function toUserPoolDescriptionType(root: jsonP.JSONValue): s.UserPoolDescriptionType {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "LambdaConfig": toLambdaConfigType,
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "LastModifiedDate": "d",
      "CreationDate": "d",
    },
  }, root);
}
