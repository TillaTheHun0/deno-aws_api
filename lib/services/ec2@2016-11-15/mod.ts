// Autogenerated API client for: Amazon Elastic Compute Cloud

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as Base64 from "https://deno.land/x/base64@v0.2.1/mod.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class EC2 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EC2.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-11-15",
    "endpointPrefix": "ec2",
    "protocol": "ec2",
    "serviceAbbreviation": "Amazon EC2",
    "serviceFullName": "Amazon Elastic Compute Cloud",
    "serviceId": "EC2",
    "signatureVersion": "v4",
    "uid": "ec2-2016-11-15",
    "xmlNamespace": "http://ec2.amazonaws.com/doc/2016-11-15"
  };

  async acceptReservedInstancesExchangeQuote(
    {abortSignal, ...params}: RequestConfig & AcceptReservedInstancesExchangeQuoteRequest,
  ): Promise<AcceptReservedInstancesExchangeQuoteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstanceIds"]) qsP.appendList(body, prefix+"ReservedInstanceId", params["ReservedInstanceIds"], {"entryPrefix":"."})
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"TargetConfiguration", params["TargetConfigurations"], {"appender":TargetConfigurationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptReservedInstancesExchangeQuote",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExchangeId: xml.first("exchangeId", false, x => x.content ?? ''),
    };
  }

  async acceptTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & AcceptTransitGatewayPeeringAttachmentRequest,
  ): Promise<AcceptTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async acceptTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & AcceptTransitGatewayVpcAttachmentRequest,
  ): Promise<AcceptTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async acceptVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & AcceptVpcEndpointConnectionsRequest,
  ): Promise<AcceptVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async acceptVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & AcceptVpcPeeringConnectionRequest = {},
  ): Promise<AcceptVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnection: xml.first("vpcPeeringConnection", false, VpcPeeringConnection_Parse),
    };
  }

  async advertiseByoipCidr(
    {abortSignal, ...params}: RequestConfig & AdvertiseByoipCidrRequest,
  ): Promise<AdvertiseByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AdvertiseByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async allocateAddress(
    {abortSignal, ...params}: RequestConfig & AllocateAddressRequest = {},
  ): Promise<AllocateAddressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Domain" in params) body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    if ("Address" in params) body.append(prefix+"Address", (params["Address"] ?? '').toString());
    if ("PublicIpv4Pool" in params) body.append(prefix+"PublicIpv4Pool", (params["PublicIpv4Pool"] ?? '').toString());
    if ("NetworkBorderGroup" in params) body.append(prefix+"NetworkBorderGroup", (params["NetworkBorderGroup"] ?? '').toString());
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateAddress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIp: xml.first("publicIp", false, x => x.content ?? ''),
      AllocationId: xml.first("allocationId", false, x => x.content ?? ''),
      PublicIpv4Pool: xml.first("publicIpv4Pool", false, x => x.content ?? ''),
      NetworkBorderGroup: xml.first("networkBorderGroup", false, x => x.content ?? ''),
      Domain: xml.first("domain", false, x => (x.content ?? '') as DomainType),
      CustomerOwnedIp: xml.first("customerOwnedIp", false, x => x.content ?? ''),
      CustomerOwnedIpv4Pool: xml.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
      CarrierIp: xml.first("carrierIp", false, x => x.content ?? ''),
    };
  }

  async allocateHosts(
    {abortSignal, ...params}: RequestConfig & AllocateHostsRequest,
  ): Promise<AllocateHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoPlacement" in params) body.append(prefix+"AutoPlacement", (params["AutoPlacement"] ?? '').toString());
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("InstanceFamily" in params) body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    body.append(prefix+"Quantity", (params["Quantity"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("HostRecovery" in params) body.append(prefix+"HostRecovery", (params["HostRecovery"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostIds: xml.getList("hostIdSet", "item").map(x => x.content ?? ''),
    };
  }

  async applySecurityGroupsToClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  ): Promise<ApplySecurityGroupsToClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplySecurityGroupsToClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroupIds: xml.getList("securityGroupIds", "item").map(x => x.content ?? ''),
    };
  }

  async assignIpv6Addresses(
    {abortSignal, ...params}: RequestConfig & AssignIpv6AddressesRequest,
  ): Promise<AssignIpv6AddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignIpv6Addresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssignedIpv6Addresses: xml.getList("assignedIpv6Addresses", "item").map(x => x.content ?? ''),
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
    };
  }

  async assignPrivateIpAddresses(
    {abortSignal, ...params}: RequestConfig & AssignPrivateIpAddressesRequest,
  ): Promise<AssignPrivateIpAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllowReassignment" in params) body.append(prefix+"AllowReassignment", (params["AllowReassignment"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddress", params["PrivateIpAddresses"], {"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+"SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssignPrivateIpAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      AssignedPrivateIpAddresses: xml.getList("assignedPrivateIpAddressesSet", "item").map(AssignedPrivateIpAddress_Parse),
    };
  }

  async associateAddress(
    {abortSignal, ...params}: RequestConfig & AssociateAddressRequest = {},
  ): Promise<AssociateAddressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllocationId" in params) body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("AllowReassociation" in params) body.append(prefix+"AllowReassociation", (params["AllowReassociation"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateAddress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
    };
  }

  async associateClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & AssociateClientVpnTargetNetworkRequest,
  ): Promise<AssociateClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, AssociationStatus_Parse),
    };
  }

  async associateDhcpOptions(
    {abortSignal, ...params}: RequestConfig & AssociateDhcpOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DhcpOptionsId", (params["DhcpOptionsId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateDhcpOptions",
    });
  }

  async associateIamInstanceProfile(
    {abortSignal, ...params}: RequestConfig & AssociateIamInstanceProfileRequest,
  ): Promise<AssociateIamInstanceProfileResult> {
    const body = new URLSearchParams;
    const prefix = '';
    IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateIamInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async associateRouteTable(
    {abortSignal, ...params}: RequestConfig & AssociateRouteTableRequest,
  ): Promise<AssociateRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      AssociationState: xml.first("associationState", false, RouteTableAssociationState_Parse),
    };
  }

  async associateSubnetCidrBlock(
    {abortSignal, ...params}: RequestConfig & AssociateSubnetCidrBlockRequest,
  ): Promise<AssociateSubnetCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateSubnetCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, SubnetIpv6CidrBlockAssociation_Parse),
      SubnetId: xml.first("subnetId", false, x => x.content ?? ''),
    };
  }

  async associateTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & AssociateTransitGatewayMulticastDomainRequest = {},
  ): Promise<AssociateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async associateTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & AssociateTransitGatewayRouteTableRequest,
  ): Promise<AssociateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Association: xml.first("association", false, TransitGatewayAssociation_Parse),
    };
  }

  async associateVpcCidrBlock(
    {abortSignal, ...params}: RequestConfig & AssociateVpcCidrBlockRequest,
  ): Promise<AssociateVpcCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AmazonProvidedIpv6CidrBlock" in params) body.append(prefix+"AmazonProvidedIpv6CidrBlock", (params["AmazonProvidedIpv6CidrBlock"] ?? '').toString());
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("Ipv6CidrBlockNetworkBorderGroup" in params) body.append(prefix+"Ipv6CidrBlockNetworkBorderGroup", (params["Ipv6CidrBlockNetworkBorderGroup"] ?? '').toString());
    if ("Ipv6Pool" in params) body.append(prefix+"Ipv6Pool", (params["Ipv6Pool"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateVpcCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, VpcIpv6CidrBlockAssociation_Parse),
      CidrBlockAssociation: xml.first("cidrBlockAssociation", false, VpcCidrBlockAssociation_Parse),
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
    };
  }

  async attachClassicLinkVpc(
    {abortSignal, ...params}: RequestConfig & AttachClassicLinkVpcRequest,
  ): Promise<AttachClassicLinkVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachClassicLinkVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async attachInternetGateway(
    {abortSignal, ...params}: RequestConfig & AttachInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachInternetGateway",
    });
  }

  async attachNetworkInterface(
    {abortSignal, ...params}: RequestConfig & AttachNetworkInterfaceRequest,
  ): Promise<AttachNetworkInterfaceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachNetworkInterface",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AttachmentId: xml.first("attachmentId", false, x => x.content ?? ''),
    };
  }

  async attachVolume(
    {abortSignal, ...params}: RequestConfig & AttachVolumeRequest,
  ): Promise<VolumeAttachment> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Device", (params["Device"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return VolumeAttachment_Parse(xml);
  }

  async attachVpnGateway(
    {abortSignal, ...params}: RequestConfig & AttachVpnGatewayRequest,
  ): Promise<AttachVpnGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachVpnGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcAttachment: xml.first("attachment", false, VpcAttachment_Parse),
    };
  }

  async authorizeClientVpnIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeClientVpnIngressRequest,
  ): Promise<AuthorizeClientVpnIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"TargetNetworkCidr", (params["TargetNetworkCidr"] ?? '').toString());
    if ("AccessGroupId" in params) body.append(prefix+"AccessGroupId", (params["AccessGroupId"] ?? '').toString());
    if ("AuthorizeAllGroups" in params) body.append(prefix+"AuthorizeAllGroups", (params["AuthorizeAllGroups"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeClientVpnIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
    };
  }

  async authorizeSecurityGroupEgress(
    {abortSignal, ...params}: RequestConfig & AuthorizeSecurityGroupEgressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"ipPermissions", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSecurityGroupEgress",
    });
  }

  async authorizeSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeSecurityGroupIngressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeSecurityGroupIngress",
    });
  }

  async bundleInstance(
    {abortSignal, ...params}: RequestConfig & BundleInstanceRequest,
  ): Promise<BundleInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    Storage_Serialize(body, prefix+"Storage", params["Storage"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BundleInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTask: xml.first("bundleInstanceTask", false, BundleTask_Parse),
    };
  }

  async cancelBundleTask(
    {abortSignal, ...params}: RequestConfig & CancelBundleTaskRequest,
  ): Promise<CancelBundleTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BundleId", (params["BundleId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelBundleTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTask: xml.first("bundleInstanceTask", false, BundleTask_Parse),
    };
  }

  async cancelCapacityReservation(
    {abortSignal, ...params}: RequestConfig & CancelCapacityReservationRequest,
  ): Promise<CancelCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async cancelConversionTask(
    {abortSignal, ...params}: RequestConfig & CancelConversionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConversionTaskId", (params["ConversionTaskId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ReasonMessage" in params) body.append(prefix+"ReasonMessage", (params["ReasonMessage"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelConversionTask",
    });
  }

  async cancelExportTask(
    {abortSignal, ...params}: RequestConfig & CancelExportTaskRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportTaskId", (params["ExportTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelExportTask",
    });
  }

  async cancelImportTask(
    {abortSignal, ...params}: RequestConfig & CancelImportTaskRequest = {},
  ): Promise<CancelImportTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CancelReason" in params) body.append(prefix+"CancelReason", (params["CancelReason"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ImportTaskId" in params) body.append(prefix+"ImportTaskId", (params["ImportTaskId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelImportTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      PreviousState: xml.first("previousState", false, x => x.content ?? ''),
      State: xml.first("state", false, x => x.content ?? ''),
    };
  }

  async cancelReservedInstancesListing(
    {abortSignal, ...params}: RequestConfig & CancelReservedInstancesListingRequest,
  ): Promise<CancelReservedInstancesListingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedInstancesListingId", (params["ReservedInstancesListingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelReservedInstancesListing",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async cancelSpotFleetRequests(
    {abortSignal, ...params}: RequestConfig & CancelSpotFleetRequestsRequest,
  ): Promise<CancelSpotFleetRequestsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotFleetRequestIds"]) qsP.appendList(body, prefix+"spotFleetRequestId", params["SpotFleetRequestIds"], {"entryPrefix":"."})
    body.append(prefix+"TerminateInstances", (params["TerminateInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSpotFleetRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulFleetRequests: xml.getList("successfulFleetRequestSet", "item").map(CancelSpotFleetRequestsSuccessItem_Parse),
      UnsuccessfulFleetRequests: xml.getList("unsuccessfulFleetRequestSet", "item").map(CancelSpotFleetRequestsErrorItem_Parse),
    };
  }

  async cancelSpotInstanceRequests(
    {abortSignal, ...params}: RequestConfig & CancelSpotInstanceRequestsRequest,
  ): Promise<CancelSpotInstanceRequestsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotInstanceRequestIds"]) qsP.appendList(body, prefix+"SpotInstanceRequestId", params["SpotInstanceRequestIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSpotInstanceRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CancelledSpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(CancelledSpotInstanceRequest_Parse),
    };
  }

  async confirmProductInstance(
    {abortSignal, ...params}: RequestConfig & ConfirmProductInstanceRequest,
  ): Promise<ConfirmProductInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"ProductCode", (params["ProductCode"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmProductInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      OwnerId: xml.first("ownerId", false, x => x.content ?? ''),
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async copyFpgaImage(
    {abortSignal, ...params}: RequestConfig & CopyFpgaImageRequest,
  ): Promise<CopyFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"SourceFpgaImageId", (params["SourceFpgaImageId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageId: xml.first("fpgaImageId", false, x => x.content ?? ''),
    };
  }

  async copyImage(
    {abortSignal, ...params}: RequestConfig & CopyImageRequest,
  ): Promise<CopyImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    body.append(prefix+"SourceImageId", (params["SourceImageId"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async copySnapshot(
    {abortSignal, ...params}: RequestConfig & CopySnapshotRequest,
  ): Promise<CopySnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DestinationRegion" in params) body.append(prefix+"DestinationRegion", (params["DestinationRegion"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PresignedUrl" in params) body.append(prefix+"PresignedUrl", (params["PresignedUrl"] ?? '').toString());
    body.append(prefix+"SourceRegion", (params["SourceRegion"] ?? '').toString());
    body.append(prefix+"SourceSnapshotId", (params["SourceSnapshotId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopySnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SnapshotId: xml.first("snapshotId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createCapacityReservation(
    {abortSignal, ...params}: RequestConfig & CreateCapacityReservationRequest,
  ): Promise<CreateCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    body.append(prefix+"InstancePlatform", (params["InstancePlatform"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AvailabilityZoneId" in params) body.append(prefix+"AvailabilityZoneId", (params["AvailabilityZoneId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+"Tenancy", (params["Tenancy"] ?? '').toString());
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if ("EphemeralStorage" in params) body.append(prefix+"EphemeralStorage", (params["EphemeralStorage"] ?? '').toString());
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("EndDateType" in params) body.append(prefix+"EndDateType", (params["EndDateType"] ?? '').toString());
    if ("InstanceMatchCriteria" in params) body.append(prefix+"InstanceMatchCriteria", (params["InstanceMatchCriteria"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CapacityReservation: xml.first("capacityReservation", false, CapacityReservation_Parse),
    };
  }

  async createCarrierGateway(
    {abortSignal, ...params}: RequestConfig & CreateCarrierGatewayRequest,
  ): Promise<CreateCarrierGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCarrierGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateway: xml.first("carrierGateway", false, CarrierGateway_Parse),
    };
  }

  async createClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateClientVpnEndpointRequest,
  ): Promise<CreateClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientCidrBlock", (params["ClientCidrBlock"] ?? '').toString());
    body.append(prefix+"ServerCertificateArn", (params["ServerCertificateArn"] ?? '').toString());
    if (params["AuthenticationOptions"]) qsP.appendList(body, prefix+"Authentication", params["AuthenticationOptions"], {"appender":ClientVpnAuthenticationRequest_Serialize,"entryPrefix":"."})
    ConnectionLogOptions_Serialize(body, prefix+"ConnectionLogOptions", params["ConnectionLogOptions"]);
    if (params["DnsServers"]) qsP.appendList(body, prefix+"item", params["DnsServers"], {"entryPrefix":"."})
    if ("TransportProtocol" in params) body.append(prefix+"TransportProtocol", (params["TransportProtocol"] ?? '').toString());
    if ("VpnPort" in params) body.append(prefix+"VpnPort", (params["VpnPort"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("SplitTunnel" in params) body.append(prefix+"SplitTunnel", (params["SplitTunnel"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpointId: xml.first("clientVpnEndpointId", false, x => x.content ?? ''),
      Status: xml.first("status", false, ClientVpnEndpointStatus_Parse),
      DnsName: xml.first("dnsName", false, x => x.content ?? ''),
    };
  }

  async createClientVpnRoute(
    {abortSignal, ...params}: RequestConfig & CreateClientVpnRouteRequest,
  ): Promise<CreateClientVpnRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TargetVpcSubnetId", (params["TargetVpcSubnetId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClientVpnRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnRouteStatus_Parse),
    };
  }

  async createCustomerGateway(
    {abortSignal, ...params}: RequestConfig & CreateCustomerGatewayRequest,
  ): Promise<CreateCustomerGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BgpAsn", (params["BgpAsn"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"IpAddress", (params["PublicIp"] ?? '').toString());
    if ("CertificateArn" in params) body.append(prefix+"CertificateArn", (params["CertificateArn"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DeviceName" in params) body.append(prefix+"DeviceName", (params["DeviceName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomerGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CustomerGateway: xml.first("customerGateway", false, CustomerGateway_Parse),
    };
  }

  async createDefaultSubnet(
    {abortSignal, ...params}: RequestConfig & CreateDefaultSubnetRequest,
  ): Promise<CreateDefaultSubnetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDefaultSubnet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnet: xml.first("subnet", false, Subnet_Parse),
    };
  }

  async createDefaultVpc(
    {abortSignal, ...params}: RequestConfig & CreateDefaultVpcRequest = {},
  ): Promise<CreateDefaultVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDefaultVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpc: xml.first("vpc", false, Vpc_Parse),
    };
  }

  async createDhcpOptions(
    {abortSignal, ...params}: RequestConfig & CreateDhcpOptionsRequest,
  ): Promise<CreateDhcpOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DhcpConfigurations"]) qsP.appendList(body, prefix+"dhcpConfiguration", params["DhcpConfigurations"], {"appender":NewDhcpConfiguration_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDhcpOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DhcpOptions: xml.first("dhcpOptions", false, DhcpOptions_Parse),
    };
  }

  async createEgressOnlyInternetGateway(
    {abortSignal, ...params}: RequestConfig & CreateEgressOnlyInternetGatewayRequest,
  ): Promise<CreateEgressOnlyInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEgressOnlyInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      EgressOnlyInternetGateway: xml.first("egressOnlyInternetGateway", false, EgressOnlyInternetGateway_Parse),
    };
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & CreateFleetRequest,
  ): Promise<CreateFleetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["SpotOptions"] != null) SpotOptionsRequest_Serialize(body, prefix+"SpotOptions", params["SpotOptions"]);
    if (params["OnDemandOptions"] != null) OnDemandOptionsRequest_Serialize(body, prefix+"OnDemandOptions", params["OnDemandOptions"]);
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"item", params["LaunchTemplateConfigs"], {"appender":FleetLaunchTemplateConfigRequest_Serialize,"entryPrefix":"."})
    TargetCapacitySpecificationRequest_Serialize(body, prefix+"TargetCapacitySpecification", params["TargetCapacitySpecification"]);
    if ("TerminateInstancesWithExpiration" in params) body.append(prefix+"TerminateInstancesWithExpiration", (params["TerminateInstancesWithExpiration"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+"ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+"ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("ReplaceUnhealthyInstances" in params) body.append(prefix+"ReplaceUnhealthyInstances", (params["ReplaceUnhealthyInstances"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
      Errors: xml.getList("errorSet", "item").map(CreateFleetError_Parse),
      Instances: xml.getList("fleetInstanceSet", "item").map(CreateFleetInstance_Parse),
    };
  }

  async createFlowLogs(
    {abortSignal, ...params}: RequestConfig & CreateFlowLogsRequest,
  ): Promise<CreateFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DeliverLogsPermissionArn" in params) body.append(prefix+"DeliverLogsPermissionArn", (params["DeliverLogsPermissionArn"] ?? '').toString());
    if ("LogGroupName" in params) body.append(prefix+"LogGroupName", (params["LogGroupName"] ?? '').toString());
    if (params["ResourceIds"]) qsP.appendList(body, prefix+"ResourceId", params["ResourceIds"], {"entryPrefix":"."})
    body.append(prefix+"ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+"TrafficType", (params["TrafficType"] ?? '').toString());
    if ("LogDestinationType" in params) body.append(prefix+"LogDestinationType", (params["LogDestinationType"] ?? '').toString());
    if ("LogDestination" in params) body.append(prefix+"LogDestination", (params["LogDestination"] ?? '').toString());
    if ("LogFormat" in params) body.append(prefix+"LogFormat", (params["LogFormat"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("MaxAggregationInterval" in params) body.append(prefix+"MaxAggregationInterval", (params["MaxAggregationInterval"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      FlowLogIds: xml.getList("flowLogIdSet", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async createFpgaImage(
    {abortSignal, ...params}: RequestConfig & CreateFpgaImageRequest,
  ): Promise<CreateFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    StorageLocation_Serialize(body, prefix+"InputStorageLocation", params["InputStorageLocation"]);
    if (params["LogsStorageLocation"] != null) StorageLocation_Serialize(body, prefix+"LogsStorageLocation", params["LogsStorageLocation"]);
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageId: xml.first("fpgaImageId", false, x => x.content ?? ''),
      FpgaImageGlobalId: xml.first("fpgaImageGlobalId", false, x => x.content ?? ''),
    };
  }

  async createImage(
    {abortSignal, ...params}: RequestConfig & CreateImageRequest,
  ): Promise<CreateImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("NoReboot" in params) body.append(prefix+"NoReboot", (params["NoReboot"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async createInstanceExportTask(
    {abortSignal, ...params}: RequestConfig & CreateInstanceExportTaskRequest,
  ): Promise<CreateInstanceExportTaskResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["ExportToS3Task"] != null) ExportToS3TaskSpecification_Serialize(body, prefix+"ExportToS3", params["ExportToS3Task"]);
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("TargetEnvironment" in params) body.append(prefix+"TargetEnvironment", (params["TargetEnvironment"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstanceExportTask",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportTask: xml.first("exportTask", false, ExportTask_Parse),
    };
  }

  async createInternetGateway(
    {abortSignal, ...params}: RequestConfig & CreateInternetGatewayRequest = {},
  ): Promise<CreateInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InternetGateway: xml.first("internetGateway", false, InternetGateway_Parse),
    };
  }

  async createKeyPair(
    {abortSignal, ...params}: RequestConfig & CreateKeyPairRequest,
  ): Promise<KeyPair> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeyPair",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyFingerprint: xml.first("keyFingerprint", false, x => x.content ?? ''),
      KeyMaterial: xml.first("keyMaterial", false, x => x.content ?? ''),
      KeyName: xml.first("keyName", false, x => x.content ?? ''),
      KeyPairId: xml.first("keyPairId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & CreateLaunchTemplateRequest,
  ): Promise<CreateLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("VersionDescription" in params) body.append(prefix+"VersionDescription", (params["VersionDescription"] ?? '').toString());
    RequestLaunchTemplateData_Serialize(body, prefix+"LaunchTemplateData", params["LaunchTemplateData"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
      Warning: xml.first("warning", false, ValidationWarning_Parse),
    };
  }

  async createLaunchTemplateVersion(
    {abortSignal, ...params}: RequestConfig & CreateLaunchTemplateVersionRequest,
  ): Promise<CreateLaunchTemplateVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("SourceVersion" in params) body.append(prefix+"SourceVersion", (params["SourceVersion"] ?? '').toString());
    if ("VersionDescription" in params) body.append(prefix+"VersionDescription", (params["VersionDescription"] ?? '').toString());
    RequestLaunchTemplateData_Serialize(body, prefix+"LaunchTemplateData", params["LaunchTemplateData"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLaunchTemplateVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateVersion: xml.first("launchTemplateVersion", false, LaunchTemplateVersion_Parse),
      Warning: xml.first("warning", false, ValidationWarning_Parse),
    };
  }

  async createLocalGatewayRoute(
    {abortSignal, ...params}: RequestConfig & CreateLocalGatewayRouteRequest,
  ): Promise<CreateLocalGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"LocalGatewayVirtualInterfaceGroupId", (params["LocalGatewayVirtualInterfaceGroupId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLocalGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, LocalGatewayRoute_Parse),
    };
  }

  async createLocalGatewayRouteTableVpcAssociation(
    {abortSignal, ...params}: RequestConfig & CreateLocalGatewayRouteTableVpcAssociationRequest,
  ): Promise<CreateLocalGatewayRouteTableVpcAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLocalGatewayRouteTableVpcAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociation: xml.first("localGatewayRouteTableVpcAssociation", false, LocalGatewayRouteTableVpcAssociation_Parse),
    };
  }

  async createManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & CreateManagedPrefixListRequest,
  ): Promise<CreateManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListName", (params["PrefixListName"] ?? '').toString());
    if (params["Entries"]) qsP.appendList(body, prefix+"Entry", params["Entries"], {"appender":AddPrefixListEntry_Serialize,"entryPrefix":"."})
    body.append(prefix+"MaxEntries", (params["MaxEntries"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    body.append(prefix+"AddressFamily", (params["AddressFamily"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async createNatGateway(
    {abortSignal, ...params}: RequestConfig & CreateNatGatewayRequest,
  ): Promise<CreateNatGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNatGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      NatGateway: xml.first("natGateway", false, NatGateway_Parse),
    };
  }

  async createNetworkAcl(
    {abortSignal, ...params}: RequestConfig & CreateNetworkAclRequest,
  ): Promise<CreateNetworkAclResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkAcl",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkAcl: xml.first("networkAcl", false, NetworkAcl_Parse),
    };
  }

  async createNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & CreateNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    if (params["IcmpTypeCode"] != null) IcmpTypeCode_Serialize(body, prefix+"Icmp", params["IcmpTypeCode"]);
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    if (params["PortRange"] != null) PortRange_Serialize(body, prefix+"PortRange", params["PortRange"]);
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkAclEntry",
    });
  }

  async createNetworkInterface(
    {abortSignal, ...params}: RequestConfig & CreateNetworkInterfaceRequest,
  ): Promise<CreateNetworkInterfaceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddresses", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+"SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("InterfaceType" in params) body.append(prefix+"InterfaceType", (params["InterfaceType"] ?? '').toString());
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkInterface",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterface: xml.first("networkInterface", false, NetworkInterface_Parse),
    };
  }

  async createNetworkInterfacePermission(
    {abortSignal, ...params}: RequestConfig & CreateNetworkInterfacePermissionRequest,
  ): Promise<CreateNetworkInterfacePermissionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("AwsAccountId" in params) body.append(prefix+"AwsAccountId", (params["AwsAccountId"] ?? '').toString());
    if ("AwsService" in params) body.append(prefix+"AwsService", (params["AwsService"] ?? '').toString());
    body.append(prefix+"Permission", (params["Permission"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNetworkInterfacePermission",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InterfacePermission: xml.first("interfacePermission", false, NetworkInterfacePermission_Parse),
    };
  }

  async createPlacementGroup(
    {abortSignal, ...params}: RequestConfig & CreatePlacementGroupRequest = {},
  ): Promise<CreatePlacementGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Strategy" in params) body.append(prefix+"Strategy", (params["Strategy"] ?? '').toString());
    if ("PartitionCount" in params) body.append(prefix+"PartitionCount", (params["PartitionCount"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlacementGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PlacementGroup: xml.first("placementGroup", false, PlacementGroup_Parse),
    };
  }

  async createReservedInstancesListing(
    {abortSignal, ...params}: RequestConfig & CreateReservedInstancesListingRequest,
  ): Promise<CreateReservedInstancesListingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if (params["PriceSchedules"]) qsP.appendList(body, prefix+"priceSchedules", params["PriceSchedules"], {"appender":PriceScheduleSpecification_Serialize,"entryPrefix":"."})
    body.append(prefix+"ReservedInstancesId", (params["ReservedInstancesId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReservedInstancesListing",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async createRoute(
    {abortSignal, ...params}: RequestConfig & CreateRouteRequest,
  ): Promise<CreateRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EgressOnlyInternetGatewayId" in params) body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("NatGatewayId" in params) body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("LocalGatewayId" in params) body.append(prefix+"LocalGatewayId", (params["LocalGatewayId"] ?? '').toString());
    if ("CarrierGatewayId" in params) body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async createRouteTable(
    {abortSignal, ...params}: RequestConfig & CreateRouteTableRequest,
  ): Promise<CreateRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RouteTable: xml.first("routeTable", false, RouteTable_Parse),
    };
  }

  async createSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateSecurityGroupRequest,
  ): Promise<CreateSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupDescription", (params["Description"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      GroupId: xml.first("groupId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotRequest,
  ): Promise<Snapshot> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Snapshot_Parse(xml);
  }

  async createSnapshots(
    {abortSignal, ...params}: RequestConfig & CreateSnapshotsRequest,
  ): Promise<CreateSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    InstanceSpecification_Serialize(body, prefix+"InstanceSpecification", params["InstanceSpecification"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("CopyTagsFromSource" in params) body.append(prefix+"CopyTagsFromSource", (params["CopyTagsFromSource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Snapshots: xml.getList("snapshotSet", "item").map(SnapshotInfo_Parse),
    };
  }

  async createSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & CreateSpotDatafeedSubscriptionRequest,
  ): Promise<CreateSpotDatafeedSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Bucket", (params["Bucket"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Prefix" in params) body.append(prefix+"Prefix", (params["Prefix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSpotDatafeedSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotDatafeedSubscription: xml.first("spotDatafeedSubscription", false, SpotDatafeedSubscription_Parse),
    };
  }

  async createSubnet(
    {abortSignal, ...params}: RequestConfig & CreateSubnetRequest,
  ): Promise<CreateSubnetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("AvailabilityZoneId" in params) body.append(prefix+"AvailabilityZoneId", (params["AvailabilityZoneId"] ?? '').toString());
    body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSubnet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnet: xml.first("subnet", false, Subnet_Parse),
    };
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & CreateTagsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"ResourceId", params["Resources"], {"entryPrefix":"."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
    });
  }

  async createTrafficMirrorFilter(
    {abortSignal, ...params}: RequestConfig & CreateTrafficMirrorFilterRequest = {},
  ): Promise<CreateTrafficMirrorFilterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorFilter",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilter: xml.first("trafficMirrorFilter", false, TrafficMirrorFilter_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & CreateTrafficMirrorFilterRuleRequest,
  ): Promise<CreateTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    body.append(prefix+"TrafficDirection", (params["TrafficDirection"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    if (params["DestinationPortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"DestinationPortRange", params["DestinationPortRange"]);
    if (params["SourcePortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"SourcePortRange", params["SourcePortRange"]);
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"SourceCidrBlock", (params["SourceCidrBlock"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRule: xml.first("trafficMirrorFilterRule", false, TrafficMirrorFilterRule_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & CreateTrafficMirrorSessionRequest,
  ): Promise<CreateTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("PacketLength" in params) body.append(prefix+"PacketLength", (params["PacketLength"] ?? '').toString());
    body.append(prefix+"SessionNumber", (params["SessionNumber"] ?? '').toString());
    if ("VirtualNetworkId" in params) body.append(prefix+"VirtualNetworkId", (params["VirtualNetworkId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSession: xml.first("trafficMirrorSession", false, TrafficMirrorSession_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTrafficMirrorTarget(
    {abortSignal, ...params}: RequestConfig & CreateTrafficMirrorTargetRequest = {},
  ): Promise<CreateTrafficMirrorTargetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("NetworkLoadBalancerArn" in params) body.append(prefix+"NetworkLoadBalancerArn", (params["NetworkLoadBalancerArn"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficMirrorTarget",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTarget: xml.first("trafficMirrorTarget", false, TrafficMirrorTarget_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createTransitGateway(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayRequest = {},
  ): Promise<CreateTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Options"] != null) TransitGatewayRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async createTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayMulticastDomainRequest,
  ): Promise<CreateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomain: xml.first("transitGatewayMulticastDomain", false, TransitGatewayMulticastDomain_Parse),
    };
  }

  async createTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayPeeringAttachmentRequest,
  ): Promise<CreateTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    body.append(prefix+"PeerTransitGatewayId", (params["PeerTransitGatewayId"] ?? '').toString());
    body.append(prefix+"PeerAccountId", (params["PeerAccountId"] ?? '').toString());
    body.append(prefix+"PeerRegion", (params["PeerRegion"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async createTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayPrefixListReferenceRequest,
  ): Promise<CreateTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async createTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayRouteRequest,
  ): Promise<CreateTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async createTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayRouteTableRequest,
  ): Promise<CreateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTable: xml.first("transitGatewayRouteTable", false, TransitGatewayRouteTable_Parse),
    };
  }

  async createTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & CreateTransitGatewayVpcAttachmentRequest,
  ): Promise<CreateTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if (params["Options"] != null) CreateTransitGatewayVpcAttachmentRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"item", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async createVolume(
    {abortSignal, ...params}: RequestConfig & CreateVolumeRequest,
  ): Promise<Volume> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("OutpostArn" in params) body.append(prefix+"OutpostArn", (params["OutpostArn"] ?? '').toString());
    if ("Size" in params) body.append(prefix+"Size", (params["Size"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+"VolumeType", (params["VolumeType"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("MultiAttachEnabled" in params) body.append(prefix+"MultiAttachEnabled", (params["MultiAttachEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Volume_Parse(xml);
  }

  async createVpc(
    {abortSignal, ...params}: RequestConfig & CreateVpcRequest,
  ): Promise<CreateVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("AmazonProvidedIpv6CidrBlock" in params) body.append(prefix+"AmazonProvidedIpv6CidrBlock", (params["AmazonProvidedIpv6CidrBlock"] ?? '').toString());
    if ("Ipv6Pool" in params) body.append(prefix+"Ipv6Pool", (params["Ipv6Pool"] ?? '').toString());
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceTenancy" in params) body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("Ipv6CidrBlockNetworkBorderGroup" in params) body.append(prefix+"Ipv6CidrBlockNetworkBorderGroup", (params["Ipv6CidrBlockNetworkBorderGroup"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpc: xml.first("vpc", false, Vpc_Parse),
    };
  }

  async createVpcEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateVpcEndpointRequest,
  ): Promise<CreateVpcEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("VpcEndpointType" in params) body.append(prefix+"VpcEndpointType", (params["VpcEndpointType"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"ServiceName", (params["ServiceName"] ?? '').toString());
    if ("PolicyDocument" in params) body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if (params["RouteTableIds"]) qsP.appendList(body, prefix+"RouteTableId", params["RouteTableIds"], {"entryPrefix":"."})
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetId", params["SubnetIds"], {"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("PrivateDnsEnabled" in params) body.append(prefix+"PrivateDnsEnabled", (params["PrivateDnsEnabled"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpoint: xml.first("vpcEndpoint", false, VpcEndpoint_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcEndpointConnectionNotification(
    {abortSignal, ...params}: RequestConfig & CreateVpcEndpointConnectionNotificationRequest,
  ): Promise<CreateVpcEndpointConnectionNotificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ServiceId" in params) body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if ("VpcEndpointId" in params) body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    body.append(prefix+"ConnectionNotificationArn", (params["ConnectionNotificationArn"] ?? '').toString());
    if (params["ConnectionEvents"]) qsP.appendList(body, prefix+"item", params["ConnectionEvents"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpointConnectionNotification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConnectionNotification: xml.first("connectionNotification", false, ConnectionNotification_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcEndpointServiceConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateVpcEndpointServiceConfigurationRequest,
  ): Promise<CreateVpcEndpointServiceConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("AcceptanceRequired" in params) body.append(prefix+"AcceptanceRequired", (params["AcceptanceRequired"] ?? '').toString());
    if ("PrivateDnsName" in params) body.append(prefix+"PrivateDnsName", (params["PrivateDnsName"] ?? '').toString());
    if (params["NetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"NetworkLoadBalancerArn", params["NetworkLoadBalancerArns"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcEndpointServiceConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceConfiguration: xml.first("serviceConfiguration", false, ServiceConfiguration_Parse),
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
    };
  }

  async createVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & CreateVpcPeeringConnectionRequest = {},
  ): Promise<CreateVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("PeerOwnerId" in params) body.append(prefix+"PeerOwnerId", (params["PeerOwnerId"] ?? '').toString());
    if ("PeerVpcId" in params) body.append(prefix+"PeerVpcId", (params["PeerVpcId"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("PeerRegion" in params) body.append(prefix+"PeerRegion", (params["PeerRegion"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnection: xml.first("vpcPeeringConnection", false, VpcPeeringConnection_Parse),
    };
  }

  async createVpnConnection(
    {abortSignal, ...params}: RequestConfig & CreateVpnConnectionRequest,
  ): Promise<CreateVpnConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("VpnGatewayId" in params) body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Options"] != null) VpnConnectionOptionsSpecification_Serialize(body, prefix+"Options", params["Options"]);
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async createVpnConnectionRoute(
    {abortSignal, ...params}: RequestConfig & CreateVpnConnectionRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnConnectionRoute",
    });
  }

  async createVpnGateway(
    {abortSignal, ...params}: RequestConfig & CreateVpnGatewayRequest,
  ): Promise<CreateVpnGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("AmazonSideAsn" in params) body.append(prefix+"AmazonSideAsn", (params["AmazonSideAsn"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpnGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnGateway: xml.first("vpnGateway", false, VpnGateway_Parse),
    };
  }

  async deleteCarrierGateway(
    {abortSignal, ...params}: RequestConfig & DeleteCarrierGatewayRequest,
  ): Promise<DeleteCarrierGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCarrierGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateway: xml.first("carrierGateway", false, CarrierGateway_Parse),
    };
  }

  async deleteClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteClientVpnEndpointRequest,
  ): Promise<DeleteClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnEndpointStatus_Parse),
    };
  }

  async deleteClientVpnRoute(
    {abortSignal, ...params}: RequestConfig & DeleteClientVpnRouteRequest,
  ): Promise<DeleteClientVpnRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("TargetVpcSubnetId" in params) body.append(prefix+"TargetVpcSubnetId", (params["TargetVpcSubnetId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClientVpnRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnRouteStatus_Parse),
    };
  }

  async deleteCustomerGateway(
    {abortSignal, ...params}: RequestConfig & DeleteCustomerGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomerGateway",
    });
  }

  async deleteDhcpOptions(
    {abortSignal, ...params}: RequestConfig & DeleteDhcpOptionsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DhcpOptionsId", (params["DhcpOptionsId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDhcpOptions",
    });
  }

  async deleteEgressOnlyInternetGateway(
    {abortSignal, ...params}: RequestConfig & DeleteEgressOnlyInternetGatewayRequest,
  ): Promise<DeleteEgressOnlyInternetGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEgressOnlyInternetGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnCode: xml.first("returnCode", false, x => x.content === 'true'),
    };
  }

  async deleteFleets(
    {abortSignal, ...params}: RequestConfig & DeleteFleetsRequest,
  ): Promise<DeleteFleetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FleetIds"]) qsP.appendList(body, prefix+"FleetId", params["FleetIds"], {"entryPrefix":"."})
    body.append(prefix+"TerminateInstances", (params["TerminateInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulFleetDeletions: xml.getList("successfulFleetDeletionSet", "item").map(DeleteFleetSuccessItem_Parse),
      UnsuccessfulFleetDeletions: xml.getList("unsuccessfulFleetDeletionSet", "item").map(DeleteFleetErrorItem_Parse),
    };
  }

  async deleteFlowLogs(
    {abortSignal, ...params}: RequestConfig & DeleteFlowLogsRequest,
  ): Promise<DeleteFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FlowLogIds"]) qsP.appendList(body, prefix+"FlowLogId", params["FlowLogIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteFpgaImage(
    {abortSignal, ...params}: RequestConfig & DeleteFpgaImageRequest,
  ): Promise<DeleteFpgaImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFpgaImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deleteInternetGateway(
    {abortSignal, ...params}: RequestConfig & DeleteInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInternetGateway",
    });
  }

  async deleteKeyPair(
    {abortSignal, ...params}: RequestConfig & DeleteKeyPairRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    if ("KeyPairId" in params) body.append(prefix+"KeyPairId", (params["KeyPairId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteKeyPair",
    });
  }

  async deleteLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & DeleteLaunchTemplateRequest = {},
  ): Promise<DeleteLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
    };
  }

  async deleteLaunchTemplateVersions(
    {abortSignal, ...params}: RequestConfig & DeleteLaunchTemplateVersionsRequest,
  ): Promise<DeleteLaunchTemplateVersionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if (params["Versions"]) qsP.appendList(body, prefix+"LaunchTemplateVersion", params["Versions"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLaunchTemplateVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfullyDeletedLaunchTemplateVersions: xml.getList("successfullyDeletedLaunchTemplateVersionSet", "item").map(DeleteLaunchTemplateVersionsResponseSuccessItem_Parse),
      UnsuccessfullyDeletedLaunchTemplateVersions: xml.getList("unsuccessfullyDeletedLaunchTemplateVersionSet", "item").map(DeleteLaunchTemplateVersionsResponseErrorItem_Parse),
    };
  }

  async deleteLocalGatewayRoute(
    {abortSignal, ...params}: RequestConfig & DeleteLocalGatewayRouteRequest,
  ): Promise<DeleteLocalGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLocalGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, LocalGatewayRoute_Parse),
    };
  }

  async deleteLocalGatewayRouteTableVpcAssociation(
    {abortSignal, ...params}: RequestConfig & DeleteLocalGatewayRouteTableVpcAssociationRequest,
  ): Promise<DeleteLocalGatewayRouteTableVpcAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableVpcAssociationId", (params["LocalGatewayRouteTableVpcAssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLocalGatewayRouteTableVpcAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociation: xml.first("localGatewayRouteTableVpcAssociation", false, LocalGatewayRouteTableVpcAssociation_Parse),
    };
  }

  async deleteManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & DeleteManagedPrefixListRequest,
  ): Promise<DeleteManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async deleteNatGateway(
    {abortSignal, ...params}: RequestConfig & DeleteNatGatewayRequest,
  ): Promise<DeleteNatGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNatGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NatGatewayId: xml.first("natGatewayId", false, x => x.content ?? ''),
    };
  }

  async deleteNetworkAcl(
    {abortSignal, ...params}: RequestConfig & DeleteNetworkAclRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkAcl",
    });
  }

  async deleteNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & DeleteNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkAclEntry",
    });
  }

  async deleteNetworkInterface(
    {abortSignal, ...params}: RequestConfig & DeleteNetworkInterfaceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInterface",
    });
  }

  async deleteNetworkInterfacePermission(
    {abortSignal, ...params}: RequestConfig & DeleteNetworkInterfacePermissionRequest,
  ): Promise<DeleteNetworkInterfacePermissionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfacePermissionId", (params["NetworkInterfacePermissionId"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNetworkInterfacePermission",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deletePlacementGroup(
    {abortSignal, ...params}: RequestConfig & DeletePlacementGroupRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePlacementGroup",
    });
  }

  async deleteQueuedReservedInstances(
    {abortSignal, ...params}: RequestConfig & DeleteQueuedReservedInstancesRequest,
  ): Promise<DeleteQueuedReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteQueuedReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulQueuedPurchaseDeletions: xml.getList("successfulQueuedPurchaseDeletionSet", "item").map(SuccessfulQueuedPurchaseDeletion_Parse),
      FailedQueuedPurchaseDeletions: xml.getList("failedQueuedPurchaseDeletionSet", "item").map(FailedQueuedPurchaseDeletion_Parse),
    };
  }

  async deleteRoute(
    {abortSignal, ...params}: RequestConfig & DeleteRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRoute",
    });
  }

  async deleteRouteTable(
    {abortSignal, ...params}: RequestConfig & DeleteRouteTableRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRouteTable",
    });
  }

  async deleteSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteSecurityGroupRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityGroup",
    });
  }

  async deleteSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteSnapshotRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshot",
    });
  }

  async deleteSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & DeleteSpotDatafeedSubscriptionRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSpotDatafeedSubscription",
    });
  }

  async deleteSubnet(
    {abortSignal, ...params}: RequestConfig & DeleteSubnetRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSubnet",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"resourceId", params["Resources"], {"entryPrefix":"."})
    if (params["Tags"]) qsP.appendList(body, prefix+"tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
  }

  async deleteTrafficMirrorFilter(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficMirrorFilterRequest,
  ): Promise<DeleteTrafficMirrorFilterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorFilter",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterId: xml.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficMirrorFilterRuleRequest,
  ): Promise<DeleteTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterRuleId", (params["TrafficMirrorFilterRuleId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRuleId: xml.first("trafficMirrorFilterRuleId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficMirrorSessionRequest,
  ): Promise<DeleteTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorSessionId", (params["TrafficMirrorSessionId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSessionId: xml.first("trafficMirrorSessionId", false, x => x.content ?? ''),
    };
  }

  async deleteTrafficMirrorTarget(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficMirrorTargetRequest,
  ): Promise<DeleteTrafficMirrorTargetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrafficMirrorTarget",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTargetId: xml.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    };
  }

  async deleteTransitGateway(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayRequest,
  ): Promise<DeleteTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async deleteTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayMulticastDomainRequest,
  ): Promise<DeleteTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomain: xml.first("transitGatewayMulticastDomain", false, TransitGatewayMulticastDomain_Parse),
    };
  }

  async deleteTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayPeeringAttachmentRequest,
  ): Promise<DeleteTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async deleteTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayPrefixListReferenceRequest,
  ): Promise<DeleteTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async deleteTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayRouteRequest,
  ): Promise<DeleteTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async deleteTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayRouteTableRequest,
  ): Promise<DeleteTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTable: xml.first("transitGatewayRouteTable", false, TransitGatewayRouteTable_Parse),
    };
  }

  async deleteTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & DeleteTransitGatewayVpcAttachmentRequest,
  ): Promise<DeleteTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async deleteVolume(
    {abortSignal, ...params}: RequestConfig & DeleteVolumeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVolume",
    });
  }

  async deleteVpc(
    {abortSignal, ...params}: RequestConfig & DeleteVpcRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpc",
    });
  }

  async deleteVpcEndpointConnectionNotifications(
    {abortSignal, ...params}: RequestConfig & DeleteVpcEndpointConnectionNotificationsRequest,
  ): Promise<DeleteVpcEndpointConnectionNotificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ConnectionNotificationIds"]) qsP.appendList(body, prefix+"ConnectionNotificationId", params["ConnectionNotificationIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpointConnectionNotifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcEndpointServiceConfigurations(
    {abortSignal, ...params}: RequestConfig & DeleteVpcEndpointServiceConfigurationsRequest,
  ): Promise<DeleteVpcEndpointServiceConfigurationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceIds"]) qsP.appendList(body, prefix+"ServiceId", params["ServiceIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpointServiceConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcEndpoints(
    {abortSignal, ...params}: RequestConfig & DeleteVpcEndpointsRequest,
  ): Promise<DeleteVpcEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async deleteVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & DeleteVpcPeeringConnectionRequest,
  ): Promise<DeleteVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async deleteVpnConnection(
    {abortSignal, ...params}: RequestConfig & DeleteVpnConnectionRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnConnection",
    });
  }

  async deleteVpnConnectionRoute(
    {abortSignal, ...params}: RequestConfig & DeleteVpnConnectionRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnConnectionRoute",
    });
  }

  async deleteVpnGateway(
    {abortSignal, ...params}: RequestConfig & DeleteVpnGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVpnGateway",
    });
  }

  async deprovisionByoipCidr(
    {abortSignal, ...params}: RequestConfig & DeprovisionByoipCidrRequest,
  ): Promise<DeprovisionByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeprovisionByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async deregisterImage(
    {abortSignal, ...params}: RequestConfig & DeregisterImageRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterImage",
    });
  }

  async deregisterInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & DeregisterInstanceEventNotificationAttributesRequest = {},
  ): Promise<DeregisterInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTagAttribute"] != null) DeregisterInstanceTagAttributeRequest_Serialize(body, prefix+"InstanceTagAttribute", params["InstanceTagAttribute"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async deregisterTransitGatewayMulticastGroupMembers(
    {abortSignal, ...params}: RequestConfig & DeregisterTransitGatewayMulticastGroupMembersRequest = {},
  ): Promise<DeregisterTransitGatewayMulticastGroupMembersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTransitGatewayMulticastGroupMembers",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DeregisteredMulticastGroupMembers: xml.first("deregisteredMulticastGroupMembers", false, TransitGatewayMulticastDeregisteredGroupMembers_Parse),
    };
  }

  async deregisterTransitGatewayMulticastGroupSources(
    {abortSignal, ...params}: RequestConfig & DeregisterTransitGatewayMulticastGroupSourcesRequest = {},
  ): Promise<DeregisterTransitGatewayMulticastGroupSourcesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTransitGatewayMulticastGroupSources",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DeregisteredMulticastGroupSources: xml.first("deregisteredMulticastGroupSources", false, TransitGatewayMulticastDeregisteredGroupSources_Parse),
    };
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeAccountAttributesRequest = {},
  ): Promise<DescribeAccountAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"attributeName", params["AttributeNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AccountAttributes: xml.getList("accountAttributeSet", "item").map(AccountAttribute_Parse),
    };
  }

  async describeAddresses(
    {abortSignal, ...params}: RequestConfig & DescribeAddressesRequest = {},
  ): Promise<DescribeAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["PublicIps"]) qsP.appendList(body, prefix+"PublicIp", params["PublicIps"], {"entryPrefix":"."})
    if (params["AllocationIds"]) qsP.appendList(body, prefix+"AllocationId", params["AllocationIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Addresses: xml.getList("addressesSet", "item").map(Address_Parse),
    };
  }

  async describeAggregateIdFormat(
    {abortSignal, ...params}: RequestConfig & DescribeAggregateIdFormatRequest = {},
  ): Promise<DescribeAggregateIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAggregateIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      UseLongIdsAggregated: xml.first("useLongIdsAggregated", false, x => x.content === 'true'),
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeAvailabilityZones(
    {abortSignal, ...params}: RequestConfig & DescribeAvailabilityZonesRequest = {},
  ): Promise<DescribeAvailabilityZonesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ZoneNames"]) qsP.appendList(body, prefix+"ZoneName", params["ZoneNames"], {"entryPrefix":"."})
    if (params["ZoneIds"]) qsP.appendList(body, prefix+"ZoneId", params["ZoneIds"], {"entryPrefix":"."})
    if ("AllAvailabilityZones" in params) body.append(prefix+"AllAvailabilityZones", (params["AllAvailabilityZones"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityZones",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AvailabilityZones: xml.getList("availabilityZoneInfo", "item").map(AvailabilityZone_Parse),
    };
  }

  async describeBundleTasks(
    {abortSignal, ...params}: RequestConfig & DescribeBundleTasksRequest = {},
  ): Promise<DescribeBundleTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BundleIds"]) qsP.appendList(body, prefix+"BundleId", params["BundleIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBundleTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BundleTasks: xml.getList("bundleInstanceTasksSet", "item").map(BundleTask_Parse),
    };
  }

  async describeByoipCidrs(
    {abortSignal, ...params}: RequestConfig & DescribeByoipCidrsRequest,
  ): Promise<DescribeByoipCidrsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeByoipCidrs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidrs: xml.getList("byoipCidrSet", "item").map(ByoipCidr_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeCapacityReservations(
    {abortSignal, ...params}: RequestConfig & DescribeCapacityReservationsRequest = {},
  ): Promise<DescribeCapacityReservationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CapacityReservationIds"]) qsP.appendList(body, prefix+"CapacityReservationId", params["CapacityReservationIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCapacityReservations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservations: xml.getList("capacityReservationSet", "item").map(CapacityReservation_Parse),
    };
  }

  async describeCarrierGateways(
    {abortSignal, ...params}: RequestConfig & DescribeCarrierGatewaysRequest = {},
  ): Promise<DescribeCarrierGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CarrierGatewayIds"]) qsP.appendList(body, prefix+"CarrierGatewayId", params["CarrierGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCarrierGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CarrierGateways: xml.getList("carrierGatewaySet", "item").map(CarrierGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClassicLinkInstances(
    {abortSignal, ...params}: RequestConfig & DescribeClassicLinkInstancesRequest = {},
  ): Promise<DescribeClassicLinkInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClassicLinkInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Instances: xml.getList("instancesSet", "item").map(ClassicLinkInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnAuthorizationRules(
    {abortSignal, ...params}: RequestConfig & DescribeClientVpnAuthorizationRulesRequest,
  ): Promise<DescribeClientVpnAuthorizationRulesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnAuthorizationRules",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AuthorizationRules: xml.getList("authorizationRule", "item").map(AuthorizationRule_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnConnections(
    {abortSignal, ...params}: RequestConfig & DescribeClientVpnConnectionsRequest,
  ): Promise<DescribeClientVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Connections: xml.getList("connections", "item").map(ClientVpnConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeClientVpnEndpointsRequest = {},
  ): Promise<DescribeClientVpnEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ClientVpnEndpointIds"]) qsP.appendList(body, prefix+"ClientVpnEndpointId", params["ClientVpnEndpointIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpoints: xml.getList("clientVpnEndpoint", "item").map(ClientVpnEndpoint_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnRoutes(
    {abortSignal, ...params}: RequestConfig & DescribeClientVpnRoutesRequest,
  ): Promise<DescribeClientVpnRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routes", "item").map(ClientVpnRoute_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeClientVpnTargetNetworks(
    {abortSignal, ...params}: RequestConfig & DescribeClientVpnTargetNetworksRequest,
  ): Promise<DescribeClientVpnTargetNetworksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if (params["AssociationIds"]) qsP.appendList(body, prefix+"item", params["AssociationIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClientVpnTargetNetworks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnTargetNetworks: xml.getList("clientVpnTargetNetworks", "item").map(TargetNetwork_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeCoipPools(
    {abortSignal, ...params}: RequestConfig & DescribeCoipPoolsRequest = {},
  ): Promise<DescribeCoipPoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCoipPools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CoipPools: xml.getList("coipPoolSet", "item").map(CoipPool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeConversionTasks(
    {abortSignal, ...params}: RequestConfig & DescribeConversionTasksRequest = {},
  ): Promise<DescribeConversionTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ConversionTaskIds"]) qsP.appendList(body, prefix+"conversionTaskId", params["ConversionTaskIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConversionTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTasks: xml.getList("conversionTasks", "item").map(ConversionTask_Parse),
    };
  }

  async describeCustomerGateways(
    {abortSignal, ...params}: RequestConfig & DescribeCustomerGatewaysRequest = {},
  ): Promise<DescribeCustomerGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["CustomerGatewayIds"]) qsP.appendList(body, prefix+"CustomerGatewayId", params["CustomerGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCustomerGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CustomerGateways: xml.getList("customerGatewaySet", "item").map(CustomerGateway_Parse),
    };
  }

  async describeDhcpOptions(
    {abortSignal, ...params}: RequestConfig & DescribeDhcpOptionsRequest = {},
  ): Promise<DescribeDhcpOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DhcpOptionsIds"]) qsP.appendList(body, prefix+"DhcpOptionsId", params["DhcpOptionsIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDhcpOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DhcpOptions: xml.getList("dhcpOptionsSet", "item").map(DhcpOptions_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeEgressOnlyInternetGateways(
    {abortSignal, ...params}: RequestConfig & DescribeEgressOnlyInternetGatewaysRequest = {},
  ): Promise<DescribeEgressOnlyInternetGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["EgressOnlyInternetGatewayIds"]) qsP.appendList(body, prefix+"EgressOnlyInternetGatewayId", params["EgressOnlyInternetGatewayIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEgressOnlyInternetGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EgressOnlyInternetGateways: xml.getList("egressOnlyInternetGatewaySet", "item").map(EgressOnlyInternetGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeElasticGpus(
    {abortSignal, ...params}: RequestConfig & DescribeElasticGpusRequest = {},
  ): Promise<DescribeElasticGpusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ElasticGpuIds"]) qsP.appendList(body, prefix+"ElasticGpuId", params["ElasticGpuIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticGpus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ElasticGpuSet: xml.getList("elasticGpuSet", "item").map(ElasticGpus_Parse),
      MaxResults: xml.first("maxResults", false, x => parseInt(x.content ?? '0')),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeExportImageTasks(
    {abortSignal, ...params}: RequestConfig & DescribeExportImageTasksRequest = {},
  ): Promise<DescribeExportImageTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ExportImageTaskIds"]) qsP.appendList(body, prefix+"ExportImageTaskId", params["ExportImageTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportImageTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportImageTasks: xml.getList("exportImageTaskSet", "item").map(ExportImageTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeExportTasks(
    {abortSignal, ...params}: RequestConfig & DescribeExportTasksRequest = {},
  ): Promise<DescribeExportTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ExportTaskIds"]) qsP.appendList(body, prefix+"exportTaskId", params["ExportTaskIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExportTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ExportTasks: xml.getList("exportTaskSet", "item").map(ExportTask_Parse),
    };
  }

  async describeFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & DescribeFastSnapshotRestoresRequest = {},
  ): Promise<DescribeFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FastSnapshotRestores: xml.getList("fastSnapshotRestoreSet", "item").map(DescribeFastSnapshotRestoreSuccessItem_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeFleetHistory(
    {abortSignal, ...params}: RequestConfig & DescribeFleetHistoryRequest,
  ): Promise<DescribeFleetHistoryResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EventType" in params) body.append(prefix+"EventType", (params["EventType"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HistoryRecords: xml.getList("historyRecordSet", "item").map(HistoryRecordEntry_Parse),
      LastEvaluatedTime: xml.first("lastEvaluatedTime", false, x => xmlP.parseTimestamp(x.content)),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
      StartTime: xml.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeFleetInstances(
    {abortSignal, ...params}: RequestConfig & DescribeFleetInstancesRequest,
  ): Promise<DescribeFleetInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleetInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ActiveInstances: xml.getList("activeInstanceSet", "item").map(ActiveInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      FleetId: xml.first("fleetId", false, x => x.content ?? ''),
    };
  }

  async describeFleets(
    {abortSignal, ...params}: RequestConfig & DescribeFleetsRequest = {},
  ): Promise<DescribeFleetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["FleetIds"]) qsP.appendList(body, prefix+"FleetId", params["FleetIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Fleets: xml.getList("fleetSet", "item").map(FleetData_Parse),
    };
  }

  async describeFlowLogs(
    {abortSignal, ...params}: RequestConfig & DescribeFlowLogsRequest = {},
  ): Promise<DescribeFlowLogsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["FlowLogIds"]) qsP.appendList(body, prefix+"FlowLogId", params["FlowLogIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFlowLogs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FlowLogs: xml.getList("flowLogSet", "item").map(FlowLog_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeFpgaImageAttributeRequest,
  ): Promise<DescribeFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageAttribute: xml.first("fpgaImageAttribute", false, FpgaImageAttribute_Parse),
    };
  }

  async describeFpgaImages(
    {abortSignal, ...params}: RequestConfig & DescribeFpgaImagesRequest = {},
  ): Promise<DescribeFpgaImagesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["FpgaImageIds"]) qsP.appendList(body, prefix+"FpgaImageId", params["FpgaImageIds"], {"entryPrefix":"."})
    if (params["Owners"]) qsP.appendList(body, prefix+"Owner", params["Owners"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFpgaImages",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImages: xml.getList("fpgaImageSet", "item").map(FpgaImage_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeHostReservationOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeHostReservationOfferingsRequest = {},
  ): Promise<DescribeHostReservationOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxDuration" in params) body.append(prefix+"MaxDuration", (params["MaxDuration"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("MinDuration" in params) body.append(prefix+"MinDuration", (params["MinDuration"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("OfferingId" in params) body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHostReservationOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      OfferingSet: xml.getList("offeringSet", "item").map(HostOffering_Parse),
    };
  }

  async describeHostReservations(
    {abortSignal, ...params}: RequestConfig & DescribeHostReservationsRequest = {},
  ): Promise<DescribeHostReservationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["HostReservationIdSet"]) qsP.appendList(body, prefix+"item", params["HostReservationIdSet"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHostReservations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostReservationSet: xml.getList("hostReservationSet", "item").map(HostReservation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeHosts(
    {abortSignal, ...params}: RequestConfig & DescribeHostsRequest = {},
  ): Promise<DescribeHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filter"]) qsP.appendList(body, prefix+"filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Hosts: xml.getList("hostSet", "item").map(Host_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIamInstanceProfileAssociations(
    {abortSignal, ...params}: RequestConfig & DescribeIamInstanceProfileAssociationsRequest = {},
  ): Promise<DescribeIamInstanceProfileAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AssociationIds"]) qsP.appendList(body, prefix+"AssociationId", params["AssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIamInstanceProfileAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociations: xml.getList("iamInstanceProfileAssociationSet", "item").map(IamInstanceProfileAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIdFormat(
    {abortSignal, ...params}: RequestConfig & DescribeIdFormatRequest = {},
  ): Promise<DescribeIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Resource" in params) body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeIdentityIdFormat(
    {abortSignal, ...params}: RequestConfig & DescribeIdentityIdFormatRequest,
  ): Promise<DescribeIdentityIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PrincipalArn", (params["PrincipalArn"] ?? '').toString());
    if ("Resource" in params) body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIdentityIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Statuses: xml.getList("statusSet", "item").map(IdFormat_Parse),
    };
  }

  async describeImageAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeImageAttributeRequest,
  ): Promise<ImageAttribute> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      BlockDeviceMappings: xml.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      LaunchPermissions: xml.getList("launchPermission", "item").map(LaunchPermission_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      Description: xml.first("description", false, AttributeValue_Parse),
      KernelId: xml.first("kernel", false, AttributeValue_Parse),
      RamdiskId: xml.first("ramdisk", false, AttributeValue_Parse),
      SriovNetSupport: xml.first("sriovNetSupport", false, AttributeValue_Parse),
    };
  }

  async describeImages(
    {abortSignal, ...params}: RequestConfig & DescribeImagesRequest = {},
  ): Promise<DescribeImagesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ExecutableUsers"]) qsP.appendList(body, prefix+"ExecutableBy", params["ExecutableUsers"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImageIds"]) qsP.appendList(body, prefix+"ImageId", params["ImageIds"], {"entryPrefix":"."})
    if (params["Owners"]) qsP.appendList(body, prefix+"Owner", params["Owners"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImages",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Images: xml.getList("imagesSet", "item").map(Image_Parse),
    };
  }

  async describeImportImageTasks(
    {abortSignal, ...params}: RequestConfig & DescribeImportImageTasksRequest = {},
  ): Promise<DescribeImportImageTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImportTaskIds"]) qsP.appendList(body, prefix+"ImportTaskId", params["ImportTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImportImageTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportImageTasks: xml.getList("importImageTaskSet", "item").map(ImportImageTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeImportSnapshotTasks(
    {abortSignal, ...params}: RequestConfig & DescribeImportSnapshotTasksRequest = {},
  ): Promise<DescribeImportSnapshotTasksResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ImportTaskIds"]) qsP.appendList(body, prefix+"ImportTaskId", params["ImportTaskIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImportSnapshotTasks",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImportSnapshotTasks: xml.getList("importSnapshotTaskSet", "item").map(ImportSnapshotTask_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceAttributeRequest,
  ): Promise<InstanceAttribute> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Groups: xml.getList("groupSet", "item").map(GroupIdentifier_Parse),
      BlockDeviceMappings: xml.getList("blockDeviceMapping", "item").map(InstanceBlockDeviceMapping_Parse),
      DisableApiTermination: xml.first("disableApiTermination", false, AttributeBooleanValue_Parse),
      EnaSupport: xml.first("enaSupport", false, AttributeBooleanValue_Parse),
      EbsOptimized: xml.first("ebsOptimized", false, AttributeBooleanValue_Parse),
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      InstanceInitiatedShutdownBehavior: xml.first("instanceInitiatedShutdownBehavior", false, AttributeValue_Parse),
      InstanceType: xml.first("instanceType", false, AttributeValue_Parse),
      KernelId: xml.first("kernel", false, AttributeValue_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      RamdiskId: xml.first("ramdisk", false, AttributeValue_Parse),
      RootDeviceName: xml.first("rootDeviceName", false, AttributeValue_Parse),
      SourceDestCheck: xml.first("sourceDestCheck", false, AttributeBooleanValue_Parse),
      SriovNetSupport: xml.first("sriovNetSupport", false, AttributeValue_Parse),
      UserData: xml.first("userData", false, AttributeValue_Parse),
    };
  }

  async describeInstanceCreditSpecifications(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceCreditSpecificationsRequest = {},
  ): Promise<DescribeInstanceCreditSpecificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceCreditSpecifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceCreditSpecifications: xml.getList("instanceCreditSpecificationSet", "item").map(InstanceCreditSpecification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceEventNotificationAttributesRequest = {},
  ): Promise<DescribeInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async describeInstanceStatus(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceStatusRequest = {},
  ): Promise<DescribeInstanceStatusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("IncludeAllInstances" in params) body.append(prefix+"IncludeAllInstances", (params["IncludeAllInstances"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceStatuses: xml.getList("instanceStatusSet", "item").map(InstanceStatus_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceTypeOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceTypeOfferingsRequest = {},
  ): Promise<DescribeInstanceTypeOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LocationType" in params) body.append(prefix+"LocationType", (params["LocationType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceTypeOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTypeOfferings: xml.getList("instanceTypeOfferingSet", "item").map(InstanceTypeOffering_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstanceTypes(
    {abortSignal, ...params}: RequestConfig & DescribeInstanceTypesRequest = {},
  ): Promise<DescribeInstanceTypesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTypes"]) qsP.appendList(body, prefix+"InstanceType", params["InstanceTypes"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTypes: xml.getList("instanceTypeSet", "item").map(InstanceTypeInfo_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInstances(
    {abortSignal, ...params}: RequestConfig & DescribeInstancesRequest = {},
  ): Promise<DescribeInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Reservations: xml.getList("reservationSet", "item").map(Reservation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeInternetGateways(
    {abortSignal, ...params}: RequestConfig & DescribeInternetGatewaysRequest = {},
  ): Promise<DescribeInternetGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InternetGatewayIds"]) qsP.appendList(body, prefix+"internetGatewayId", params["InternetGatewayIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInternetGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InternetGateways: xml.getList("internetGatewaySet", "item").map(InternetGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeIpv6Pools(
    {abortSignal, ...params}: RequestConfig & DescribeIpv6PoolsRequest = {},
  ): Promise<DescribeIpv6PoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIpv6Pools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6Pools: xml.getList("ipv6PoolSet", "item").map(Ipv6Pool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeKeyPairs(
    {abortSignal, ...params}: RequestConfig & DescribeKeyPairsRequest = {},
  ): Promise<DescribeKeyPairsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["KeyNames"]) qsP.appendList(body, prefix+"KeyName", params["KeyNames"], {"entryPrefix":"."})
    if (params["KeyPairIds"]) qsP.appendList(body, prefix+"KeyPairId", params["KeyPairIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKeyPairs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyPairs: xml.getList("keySet", "item").map(KeyPairInfo_Parse),
    };
  }

  async describeLaunchTemplateVersions(
    {abortSignal, ...params}: RequestConfig & DescribeLaunchTemplateVersionsRequest = {},
  ): Promise<DescribeLaunchTemplateVersionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if (params["Versions"]) qsP.appendList(body, prefix+"LaunchTemplateVersion", params["Versions"], {"entryPrefix":"."})
    if ("MinVersion" in params) body.append(prefix+"MinVersion", (params["MinVersion"] ?? '').toString());
    if ("MaxVersion" in params) body.append(prefix+"MaxVersion", (params["MaxVersion"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchTemplateVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateVersions: xml.getList("launchTemplateVersionSet", "item").map(LaunchTemplateVersion_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLaunchTemplates(
    {abortSignal, ...params}: RequestConfig & DescribeLaunchTemplatesRequest = {},
  ): Promise<DescribeLaunchTemplatesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LaunchTemplateIds"]) qsP.appendList(body, prefix+"LaunchTemplateId", params["LaunchTemplateIds"], {"entryPrefix":"."})
    if (params["LaunchTemplateNames"]) qsP.appendList(body, prefix+"LaunchTemplateName", params["LaunchTemplateNames"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLaunchTemplates",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplates: xml.getList("launchTemplates", "item").map(LaunchTemplate_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = {},
  ): Promise<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableVirtualInterfaceGroupAssociationId", params["LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVirtualInterfaceGroupAssociations: xml.getList("localGatewayRouteTableVirtualInterfaceGroupAssociationSet", "item").map(LocalGatewayRouteTableVirtualInterfaceGroupAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTableVpcAssociations(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewayRouteTableVpcAssociationsRequest = {},
  ): Promise<DescribeLocalGatewayRouteTableVpcAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableVpcAssociationIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableVpcAssociationId", params["LocalGatewayRouteTableVpcAssociationIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTableVpcAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTableVpcAssociations: xml.getList("localGatewayRouteTableVpcAssociationSet", "item").map(LocalGatewayRouteTableVpcAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayRouteTables(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewayRouteTablesRequest = {},
  ): Promise<DescribeLocalGatewayRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayRouteTableIds"]) qsP.appendList(body, prefix+"LocalGatewayRouteTableId", params["LocalGatewayRouteTableIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayRouteTables: xml.getList("localGatewayRouteTableSet", "item").map(LocalGatewayRouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayVirtualInterfaceGroups(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewayVirtualInterfaceGroupsRequest = {},
  ): Promise<DescribeLocalGatewayVirtualInterfaceGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayVirtualInterfaceGroupIds"]) qsP.appendList(body, prefix+"LocalGatewayVirtualInterfaceGroupId", params["LocalGatewayVirtualInterfaceGroupIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayVirtualInterfaceGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayVirtualInterfaceGroups: xml.getList("localGatewayVirtualInterfaceGroupSet", "item").map(LocalGatewayVirtualInterfaceGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGatewayVirtualInterfaces(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewayVirtualInterfacesRequest = {},
  ): Promise<DescribeLocalGatewayVirtualInterfacesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayVirtualInterfaceIds"]) qsP.appendList(body, prefix+"LocalGatewayVirtualInterfaceId", params["LocalGatewayVirtualInterfaceIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGatewayVirtualInterfaces",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGatewayVirtualInterfaces: xml.getList("localGatewayVirtualInterfaceSet", "item").map(LocalGatewayVirtualInterface_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeLocalGateways(
    {abortSignal, ...params}: RequestConfig & DescribeLocalGatewaysRequest = {},
  ): Promise<DescribeLocalGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LocalGatewayIds"]) qsP.appendList(body, prefix+"LocalGatewayId", params["LocalGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLocalGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocalGateways: xml.getList("localGatewaySet", "item").map(LocalGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeManagedPrefixLists(
    {abortSignal, ...params}: RequestConfig & DescribeManagedPrefixListsRequest = {},
  ): Promise<DescribeManagedPrefixListsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+"PrefixListId", params["PrefixListIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeManagedPrefixLists",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      PrefixLists: xml.getList("prefixListSet", "item").map(ManagedPrefixList_Parse),
    };
  }

  async describeMovingAddresses(
    {abortSignal, ...params}: RequestConfig & DescribeMovingAddressesRequest = {},
  ): Promise<DescribeMovingAddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PublicIps"]) qsP.appendList(body, prefix+"publicIp", params["PublicIps"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMovingAddresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MovingAddressStatuses: xml.getList("movingAddressStatusSet", "item").map(MovingAddressStatus_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNatGateways(
    {abortSignal, ...params}: RequestConfig & DescribeNatGatewaysRequest = {},
  ): Promise<DescribeNatGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filter"]) qsP.appendList(body, prefix+"Filter", params["Filter"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["NatGatewayIds"]) qsP.appendList(body, prefix+"NatGatewayId", params["NatGatewayIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNatGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NatGateways: xml.getList("natGatewaySet", "item").map(NatGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkAcls(
    {abortSignal, ...params}: RequestConfig & DescribeNetworkAclsRequest = {},
  ): Promise<DescribeNetworkAclsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["NetworkAclIds"]) qsP.appendList(body, prefix+"NetworkAclId", params["NetworkAclIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkAcls",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkAcls: xml.getList("networkAclSet", "item").map(NetworkAcl_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeNetworkInterfaceAttributeRequest,
  ): Promise<DescribeNetworkInterfaceAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfaceAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Attachment: xml.first("attachment", false, NetworkInterfaceAttachment_Parse),
      Description: xml.first("description", false, AttributeValue_Parse),
      Groups: xml.getList("groupSet", "item").map(GroupIdentifier_Parse),
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      SourceDestCheck: xml.first("sourceDestCheck", false, AttributeBooleanValue_Parse),
    };
  }

  async describeNetworkInterfacePermissions(
    {abortSignal, ...params}: RequestConfig & DescribeNetworkInterfacePermissionsRequest = {},
  ): Promise<DescribeNetworkInterfacePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["NetworkInterfacePermissionIds"]) qsP.appendList(body, prefix+"NetworkInterfacePermissionId", params["NetworkInterfacePermissionIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfacePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfacePermissions: xml.getList("networkInterfacePermissions", "item").map(NetworkInterfacePermission_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeNetworkInterfaces(
    {abortSignal, ...params}: RequestConfig & DescribeNetworkInterfacesRequest = {},
  ): Promise<DescribeNetworkInterfacesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"NetworkInterfaceId", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNetworkInterfaces",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaces: xml.getList("networkInterfaceSet", "item").map(NetworkInterface_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describePlacementGroups(
    {abortSignal, ...params}: RequestConfig & DescribePlacementGroupsRequest = {},
  ): Promise<DescribePlacementGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["GroupNames"]) qsP.appendList(body, prefix+"groupName", params["GroupNames"], {"entryPrefix":"."})
    if (params["GroupIds"]) qsP.appendList(body, prefix+"GroupId", params["GroupIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePlacementGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PlacementGroups: xml.getList("placementGroupSet", "item").map(PlacementGroup_Parse),
    };
  }

  async describePrefixLists(
    {abortSignal, ...params}: RequestConfig & DescribePrefixListsRequest = {},
  ): Promise<DescribePrefixListsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+"PrefixListId", params["PrefixListIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePrefixLists",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      PrefixLists: xml.getList("prefixListSet", "item").map(PrefixList_Parse),
    };
  }

  async describePrincipalIdFormat(
    {abortSignal, ...params}: RequestConfig & DescribePrincipalIdFormatRequest = {},
  ): Promise<DescribePrincipalIdFormatResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Resources"]) qsP.appendList(body, prefix+"Resource", params["Resources"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePrincipalIdFormat",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Principals: xml.getList("principalSet", "item").map(PrincipalIdFormat_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describePublicIpv4Pools(
    {abortSignal, ...params}: RequestConfig & DescribePublicIpv4PoolsRequest = {},
  ): Promise<DescribePublicIpv4PoolsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PoolIds"]) qsP.appendList(body, prefix+"PoolId", params["PoolIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePublicIpv4Pools",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIpv4Pools: xml.getList("publicIpv4PoolSet", "item").map(PublicIpv4Pool_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeRegions(
    {abortSignal, ...params}: RequestConfig & DescribeRegionsRequest = {},
  ): Promise<DescribeRegionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["RegionNames"]) qsP.appendList(body, prefix+"RegionName", params["RegionNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("AllRegions" in params) body.append(prefix+"AllRegions", (params["AllRegions"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRegions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Regions: xml.getList("regionInfo", "item").map(Region_Parse),
    };
  }

  async describeReservedInstances(
    {abortSignal, ...params}: RequestConfig & DescribeReservedInstancesRequest = {},
  ): Promise<DescribeReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("OfferingClass" in params) body.append(prefix+"OfferingClass", (params["OfferingClass"] ?? '').toString());
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstances: xml.getList("reservedInstancesSet", "item").map(ReservedInstances_Parse),
    };
  }

  async describeReservedInstancesListings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedInstancesListingsRequest = {},
  ): Promise<DescribeReservedInstancesListingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("ReservedInstancesId" in params) body.append(prefix+"ReservedInstancesId", (params["ReservedInstancesId"] ?? '').toString());
    if ("ReservedInstancesListingId" in params) body.append(prefix+"ReservedInstancesListingId", (params["ReservedInstancesListingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesListings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesListings: xml.getList("reservedInstancesListingsSet", "item").map(ReservedInstancesListing_Parse),
    };
  }

  async describeReservedInstancesModifications(
    {abortSignal, ...params}: RequestConfig & DescribeReservedInstancesModificationsRequest = {},
  ): Promise<DescribeReservedInstancesModificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["ReservedInstancesModificationIds"]) qsP.appendList(body, prefix+"ReservedInstancesModificationId", params["ReservedInstancesModificationIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ReservedInstancesModifications: xml.getList("reservedInstancesModificationsSet", "item").map(ReservedInstancesModification_Parse),
    };
  }

  async describeReservedInstancesOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedInstancesOfferingsRequest = {},
  ): Promise<DescribeReservedInstancesOfferingsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("IncludeMarketplace" in params) body.append(prefix+"IncludeMarketplace", (params["IncludeMarketplace"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("MaxDuration" in params) body.append(prefix+"MaxDuration", (params["MaxDuration"] ?? '').toString());
    if ("MaxInstanceCount" in params) body.append(prefix+"MaxInstanceCount", (params["MaxInstanceCount"] ?? '').toString());
    if ("MinDuration" in params) body.append(prefix+"MinDuration", (params["MinDuration"] ?? '').toString());
    if ("OfferingClass" in params) body.append(prefix+"OfferingClass", (params["OfferingClass"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if (params["ReservedInstancesOfferingIds"]) qsP.appendList(body, prefix+"ReservedInstancesOfferingId", params["ReservedInstancesOfferingIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceTenancy" in params) body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedInstancesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesOfferings: xml.getList("reservedInstancesOfferingsSet", "item").map(ReservedInstancesOffering_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeRouteTables(
    {abortSignal, ...params}: RequestConfig & DescribeRouteTablesRequest = {},
  ): Promise<DescribeRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["RouteTableIds"]) qsP.appendList(body, prefix+"RouteTableId", params["RouteTableIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RouteTables: xml.getList("routeTableSet", "item").map(RouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeScheduledInstanceAvailability(
    {abortSignal, ...params}: RequestConfig & DescribeScheduledInstanceAvailabilityRequest,
  ): Promise<DescribeScheduledInstanceAvailabilityResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    SlotDateTimeRangeRequest_Serialize(body, prefix+"FirstSlotStartTimeRange", params["FirstSlotStartTimeRange"]);
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("MaxSlotDurationInHours" in params) body.append(prefix+"MaxSlotDurationInHours", (params["MaxSlotDurationInHours"] ?? '').toString());
    if ("MinSlotDurationInHours" in params) body.append(prefix+"MinSlotDurationInHours", (params["MinSlotDurationInHours"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    ScheduledInstanceRecurrenceRequest_Serialize(body, prefix+"Recurrence", params["Recurrence"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledInstanceAvailability",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ScheduledInstanceAvailabilitySet: xml.getList("scheduledInstanceAvailabilitySet", "item").map(ScheduledInstanceAvailability_Parse),
    };
  }

  async describeScheduledInstances(
    {abortSignal, ...params}: RequestConfig & DescribeScheduledInstancesRequest = {},
  ): Promise<DescribeScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["ScheduledInstanceIds"]) qsP.appendList(body, prefix+"ScheduledInstanceId", params["ScheduledInstanceIds"], {"entryPrefix":"."})
    if (params["SlotStartTimeRange"] != null) SlotStartTimeRangeRequest_Serialize(body, prefix+"SlotStartTimeRange", params["SlotStartTimeRange"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      ScheduledInstanceSet: xml.getList("scheduledInstanceSet", "item").map(ScheduledInstance_Parse),
    };
  }

  async describeSecurityGroupReferences(
    {abortSignal, ...params}: RequestConfig & DescribeSecurityGroupReferencesRequest,
  ): Promise<DescribeSecurityGroupReferencesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["GroupId"]) qsP.appendList(body, prefix+"item", params["GroupId"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityGroupReferences",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroupReferenceSet: xml.getList("securityGroupReferenceSet", "item").map(SecurityGroupReference_Parse),
    };
  }

  async describeSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeSecurityGroupsRequest = {},
  ): Promise<DescribeSecurityGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["GroupIds"]) qsP.appendList(body, prefix+"GroupId", params["GroupIds"], {"entryPrefix":"."})
    if (params["GroupNames"]) qsP.appendList(body, prefix+"GroupName", params["GroupNames"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SecurityGroups: xml.getList("securityGroupInfo", "item").map(SecurityGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotAttributeRequest,
  ): Promise<DescribeSnapshotAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshotAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CreateVolumePermissions: xml.getList("createVolumePermission", "item").map(CreateVolumePermission_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      SnapshotId: xml.first("snapshotId", false, x => x.content ?? ''),
    };
  }

  async describeSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeSnapshotsRequest = {},
  ): Promise<DescribeSnapshotsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["OwnerIds"]) qsP.appendList(body, prefix+"Owner", params["OwnerIds"], {"entryPrefix":"."})
    if (params["RestorableByUserIds"]) qsP.appendList(body, prefix+"RestorableBy", params["RestorableByUserIds"], {"entryPrefix":"."})
    if (params["SnapshotIds"]) qsP.appendList(body, prefix+"SnapshotId", params["SnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Snapshots: xml.getList("snapshotSet", "item").map(Snapshot_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSpotDatafeedSubscription(
    {abortSignal, ...params}: RequestConfig & DescribeSpotDatafeedSubscriptionRequest = {},
  ): Promise<DescribeSpotDatafeedSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotDatafeedSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotDatafeedSubscription: xml.first("spotDatafeedSubscription", false, SpotDatafeedSubscription_Parse),
    };
  }

  async describeSpotFleetInstances(
    {abortSignal, ...params}: RequestConfig & DescribeSpotFleetInstancesRequest,
  ): Promise<DescribeSpotFleetInstancesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ActiveInstances: xml.getList("activeInstanceSet", "item").map(ActiveInstance_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
    };
  }

  async describeSpotFleetRequestHistory(
    {abortSignal, ...params}: RequestConfig & DescribeSpotFleetRequestHistoryRequest,
  ): Promise<DescribeSpotFleetRequestHistoryResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EventType" in params) body.append(prefix+"EventType", (params["EventType"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetRequestHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HistoryRecords: xml.getList("historyRecordSet", "item").map(HistoryRecord_Parse),
      LastEvaluatedTime: xml.first("lastEvaluatedTime", false, x => xmlP.parseTimestamp(x.content)),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
      StartTime: xml.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeSpotFleetRequests(
    {abortSignal, ...params}: RequestConfig & DescribeSpotFleetRequestsRequest = {},
  ): Promise<DescribeSpotFleetRequestsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["SpotFleetRequestIds"]) qsP.appendList(body, prefix+"spotFleetRequestId", params["SpotFleetRequestIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotFleetRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotFleetRequestConfigs: xml.getList("spotFleetRequestConfigSet", "item").map(SpotFleetRequestConfig_Parse),
    };
  }

  async describeSpotInstanceRequests(
    {abortSignal, ...params}: RequestConfig & DescribeSpotInstanceRequestsRequest = {},
  ): Promise<DescribeSpotInstanceRequestsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SpotInstanceRequestIds"]) qsP.appendList(body, prefix+"SpotInstanceRequestId", params["SpotInstanceRequestIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotInstanceRequests",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(SpotInstanceRequest_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeSpotPriceHistory(
    {abortSignal, ...params}: RequestConfig & DescribeSpotPriceHistoryRequest = {},
  ): Promise<DescribeSpotPriceHistoryResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if (params["InstanceTypes"]) qsP.appendList(body, prefix+"InstanceType", params["InstanceTypes"], {"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["ProductDescriptions"]) qsP.appendList(body, prefix+"ProductDescription", params["ProductDescriptions"], {"entryPrefix":"."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSpotPriceHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      SpotPriceHistory: xml.getList("spotPriceHistorySet", "item").map(SpotPrice_Parse),
    };
  }

  async describeStaleSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeStaleSecurityGroupsRequest,
  ): Promise<DescribeStaleSecurityGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStaleSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      StaleSecurityGroupSet: xml.getList("staleSecurityGroupSet", "item").map(StaleSecurityGroup_Parse),
    };
  }

  async describeSubnets(
    {abortSignal, ...params}: RequestConfig & DescribeSubnetsRequest = {},
  ): Promise<DescribeSubnetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetId", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubnets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Subnets: xml.getList("subnetSet", "item").map(Subnet_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsRequest = {},
  ): Promise<DescribeTagsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(TagDescription_Parse),
    };
  }

  async describeTrafficMirrorFilters(
    {abortSignal, ...params}: RequestConfig & DescribeTrafficMirrorFiltersRequest = {},
  ): Promise<DescribeTrafficMirrorFiltersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorFilterIds"]) qsP.appendList(body, prefix+"TrafficMirrorFilterId", params["TrafficMirrorFilterIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorFilters",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilters: xml.getList("trafficMirrorFilterSet", "item").map(TrafficMirrorFilter_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTrafficMirrorSessions(
    {abortSignal, ...params}: RequestConfig & DescribeTrafficMirrorSessionsRequest = {},
  ): Promise<DescribeTrafficMirrorSessionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorSessionIds"]) qsP.appendList(body, prefix+"TrafficMirrorSessionId", params["TrafficMirrorSessionIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorSessions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSessions: xml.getList("trafficMirrorSessionSet", "item").map(TrafficMirrorSession_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTrafficMirrorTargets(
    {abortSignal, ...params}: RequestConfig & DescribeTrafficMirrorTargetsRequest = {},
  ): Promise<DescribeTrafficMirrorTargetsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TrafficMirrorTargetIds"]) qsP.appendList(body, prefix+"TrafficMirrorTargetId", params["TrafficMirrorTargetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrafficMirrorTargets",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorTargets: xml.getList("trafficMirrorTargetSet", "item").map(TrafficMirrorTarget_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayAttachments(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewayAttachmentsRequest = {},
  ): Promise<DescribeTransitGatewayAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayAttachments: xml.getList("transitGatewayAttachments", "item").map(TransitGatewayAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayMulticastDomains(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewayMulticastDomainsRequest = {},
  ): Promise<DescribeTransitGatewayMulticastDomainsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayMulticastDomainIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayMulticastDomainIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayMulticastDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayMulticastDomains: xml.getList("transitGatewayMulticastDomains", "item").map(TransitGatewayMulticastDomain_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayPeeringAttachments(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewayPeeringAttachmentsRequest = {},
  ): Promise<DescribeTransitGatewayPeeringAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayPeeringAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachments: xml.getList("transitGatewayPeeringAttachments", "item").map(TransitGatewayPeeringAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayRouteTables(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewayRouteTablesRequest = {},
  ): Promise<DescribeTransitGatewayRouteTablesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayRouteTableIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayRouteTableIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayRouteTables",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTables: xml.getList("transitGatewayRouteTables", "item").map(TransitGatewayRouteTable_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGatewayVpcAttachments(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewayVpcAttachmentsRequest = {},
  ): Promise<DescribeTransitGatewayVpcAttachmentsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayAttachmentIds"]) qsP.appendList(body, prefix+"TransitGatewayAttachmentIds", params["TransitGatewayAttachmentIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGatewayVpcAttachments",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachments: xml.getList("transitGatewayVpcAttachments", "item").map(TransitGatewayVpcAttachment_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeTransitGateways(
    {abortSignal, ...params}: RequestConfig & DescribeTransitGatewaysRequest = {},
  ): Promise<DescribeTransitGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["TransitGatewayIds"]) qsP.appendList(body, prefix+"item", params["TransitGatewayIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransitGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateways: xml.getList("transitGatewaySet", "item").map(TransitGateway_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVolumeAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeVolumeAttributeRequest,
  ): Promise<DescribeVolumeAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumeAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AutoEnableIO: xml.first("autoEnableIO", false, AttributeBooleanValue_Parse),
      ProductCodes: xml.getList("productCodes", "item").map(ProductCode_Parse),
      VolumeId: xml.first("volumeId", false, x => x.content ?? ''),
    };
  }

  async describeVolumeStatus(
    {abortSignal, ...params}: RequestConfig & DescribeVolumeStatusRequest = {},
  ): Promise<DescribeVolumeStatusResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumeStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      VolumeStatuses: xml.getList("volumeStatusSet", "item").map(VolumeStatusItem_Parse),
    };
  }

  async describeVolumes(
    {abortSignal, ...params}: RequestConfig & DescribeVolumesRequest = {},
  ): Promise<DescribeVolumesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Volumes: xml.getList("volumeSet", "item").map(Volume_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVolumesModifications(
    {abortSignal, ...params}: RequestConfig & DescribeVolumesModificationsRequest = {},
  ): Promise<DescribeVolumesModificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VolumeIds"]) qsP.appendList(body, prefix+"VolumeId", params["VolumeIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVolumesModifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VolumesModifications: xml.getList("volumeModificationSet", "item").map(VolumeModification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcAttribute(
    {abortSignal, ...params}: RequestConfig & DescribeVpcAttributeRequest,
  ): Promise<DescribeVpcAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
      EnableDnsHostnames: xml.first("enableDnsHostnames", false, AttributeBooleanValue_Parse),
      EnableDnsSupport: xml.first("enableDnsSupport", false, AttributeBooleanValue_Parse),
    };
  }

  async describeVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & DescribeVpcClassicLinkRequest = {},
  ): Promise<DescribeVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpcs: xml.getList("vpcSet", "item").map(VpcClassicLink_Parse),
    };
  }

  async describeVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & DescribeVpcClassicLinkDnsSupportRequest = {},
  ): Promise<DescribeVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      Vpcs: xml.getList("vpcs", "item").map(ClassicLinkDnsSupport_Parse),
    };
  }

  async describeVpcEndpointConnectionNotifications(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointConnectionNotificationsRequest = {},
  ): Promise<DescribeVpcEndpointConnectionNotificationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ConnectionNotificationId" in params) body.append(prefix+"ConnectionNotificationId", (params["ConnectionNotificationId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointConnectionNotifications",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConnectionNotificationSet: xml.getList("connectionNotificationSet", "item").map(ConnectionNotification_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointConnectionsRequest = {},
  ): Promise<DescribeVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpointConnections: xml.getList("vpcEndpointConnectionSet", "item").map(VpcEndpointConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServiceConfigurations(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointServiceConfigurationsRequest = {},
  ): Promise<DescribeVpcEndpointServiceConfigurationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceIds"]) qsP.appendList(body, prefix+"ServiceId", params["ServiceIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServiceConfigurations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceConfigurations: xml.getList("serviceConfigurationSet", "item").map(ServiceConfiguration_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServicePermissions(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointServicePermissionsRequest,
  ): Promise<DescribeVpcEndpointServicePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServicePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AllowedPrincipals: xml.getList("allowedPrincipals", "item").map(AllowedPrincipal_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpointServices(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointServicesRequest = {},
  ): Promise<DescribeVpcEndpointServicesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ServiceNames"]) qsP.appendList(body, prefix+"ServiceName", params["ServiceNames"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpointServices",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServiceNames: xml.getList("serviceNameSet", "item").map(x => x.content ?? ''),
      ServiceDetails: xml.getList("serviceDetailSet", "item").map(ServiceDetail_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeVpcEndpointsRequest = {},
  ): Promise<DescribeVpcEndpointsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcEndpoints",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcEndpoints: xml.getList("vpcEndpointSet", "item").map(VpcEndpoint_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcPeeringConnections(
    {abortSignal, ...params}: RequestConfig & DescribeVpcPeeringConnectionsRequest = {},
  ): Promise<DescribeVpcPeeringConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["VpcPeeringConnectionIds"]) qsP.appendList(body, prefix+"VpcPeeringConnectionId", params["VpcPeeringConnectionIds"], {"entryPrefix":"."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcPeeringConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpcPeeringConnections: xml.getList("vpcPeeringConnectionSet", "item").map(VpcPeeringConnection_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpcs(
    {abortSignal, ...params}: RequestConfig & DescribeVpcsRequest = {},
  ): Promise<DescribeVpcsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpcIds"]) qsP.appendList(body, prefix+"VpcId", params["VpcIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpcs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Vpcs: xml.getList("vpcSet", "item").map(Vpc_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async describeVpnConnections(
    {abortSignal, ...params}: RequestConfig & DescribeVpnConnectionsRequest = {},
  ): Promise<DescribeVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpnConnectionIds"]) qsP.appendList(body, prefix+"VpnConnectionId", params["VpnConnectionIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnections: xml.getList("vpnConnectionSet", "item").map(VpnConnection_Parse),
    };
  }

  async describeVpnGateways(
    {abortSignal, ...params}: RequestConfig & DescribeVpnGatewaysRequest = {},
  ): Promise<DescribeVpnGatewaysResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if (params["VpnGatewayIds"]) qsP.appendList(body, prefix+"VpnGatewayId", params["VpnGatewayIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVpnGateways",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnGateways: xml.getList("vpnGatewaySet", "item").map(VpnGateway_Parse),
    };
  }

  async detachClassicLinkVpc(
    {abortSignal, ...params}: RequestConfig & DetachClassicLinkVpcRequest,
  ): Promise<DetachClassicLinkVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachClassicLinkVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async detachInternetGateway(
    {abortSignal, ...params}: RequestConfig & DetachInternetGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InternetGatewayId", (params["InternetGatewayId"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachInternetGateway",
    });
  }

  async detachNetworkInterface(
    {abortSignal, ...params}: RequestConfig & DetachNetworkInterfaceRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AttachmentId", (params["AttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachNetworkInterface",
    });
  }

  async detachVolume(
    {abortSignal, ...params}: RequestConfig & DetachVolumeRequest,
  ): Promise<VolumeAttachment> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Device" in params) body.append(prefix+"Device", (params["Device"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return VolumeAttachment_Parse(xml);
  }

  async detachVpnGateway(
    {abortSignal, ...params}: RequestConfig & DetachVpnGatewayRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachVpnGateway",
    });
  }

  async disableEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & DisableEbsEncryptionByDefaultRequest = {},
  ): Promise<DisableEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async disableFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & DisableFastSnapshotRestoresRequest,
  ): Promise<DisableFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZone", params["AvailabilityZones"], {"entryPrefix":"."})
    if (params["SourceSnapshotIds"]) qsP.appendList(body, prefix+"SourceSnapshotId", params["SourceSnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(DisableFastSnapshotRestoreSuccessItem_Parse),
      Unsuccessful: xml.getList("unsuccessful", "item").map(DisableFastSnapshotRestoreErrorItem_Parse),
    };
  }

  async disableTransitGatewayRouteTablePropagation(
    {abortSignal, ...params}: RequestConfig & DisableTransitGatewayRouteTablePropagationRequest,
  ): Promise<DisableTransitGatewayRouteTablePropagationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableTransitGatewayRouteTablePropagation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Propagation: xml.first("propagation", false, TransitGatewayPropagation_Parse),
    };
  }

  async disableVgwRoutePropagation(
    {abortSignal, ...params}: RequestConfig & DisableVgwRoutePropagationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVgwRoutePropagation",
    });
  }

  async disableVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & DisableVpcClassicLinkRequest,
  ): Promise<DisableVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async disableVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & DisableVpcClassicLinkDnsSupportRequest = {},
  ): Promise<DisableVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async disassociateAddress(
    {abortSignal, ...params}: RequestConfig & DisassociateAddressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AssociationId" in params) body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateAddress",
    });
  }

  async disassociateClientVpnTargetNetwork(
    {abortSignal, ...params}: RequestConfig & DisassociateClientVpnTargetNetworkRequest,
  ): Promise<DisassociateClientVpnTargetNetworkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateClientVpnTargetNetwork",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AssociationId: xml.first("associationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, AssociationStatus_Parse),
    };
  }

  async disassociateIamInstanceProfile(
    {abortSignal, ...params}: RequestConfig & DisassociateIamInstanceProfileRequest,
  ): Promise<DisassociateIamInstanceProfileResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateIamInstanceProfile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async disassociateRouteTable(
    {abortSignal, ...params}: RequestConfig & DisassociateRouteTableRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateRouteTable",
    });
  }

  async disassociateSubnetCidrBlock(
    {abortSignal, ...params}: RequestConfig & DisassociateSubnetCidrBlockRequest,
  ): Promise<DisassociateSubnetCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateSubnetCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, SubnetIpv6CidrBlockAssociation_Parse),
      SubnetId: xml.first("subnetId", false, x => x.content ?? ''),
    };
  }

  async disassociateTransitGatewayMulticastDomain(
    {abortSignal, ...params}: RequestConfig & DisassociateTransitGatewayMulticastDomainRequest = {},
  ): Promise<DisassociateTransitGatewayMulticastDomainResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"item", params["SubnetIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTransitGatewayMulticastDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.first("associations", false, TransitGatewayMulticastDomainAssociations_Parse),
    };
  }

  async disassociateTransitGatewayRouteTable(
    {abortSignal, ...params}: RequestConfig & DisassociateTransitGatewayRouteTableRequest,
  ): Promise<DisassociateTransitGatewayRouteTableResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTransitGatewayRouteTable",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Association: xml.first("association", false, TransitGatewayAssociation_Parse),
    };
  }

  async disassociateVpcCidrBlock(
    {abortSignal, ...params}: RequestConfig & DisassociateVpcCidrBlockRequest,
  ): Promise<DisassociateVpcCidrBlockResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateVpcCidrBlock",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrBlockAssociation: xml.first("ipv6CidrBlockAssociation", false, VpcIpv6CidrBlockAssociation_Parse),
      CidrBlockAssociation: xml.first("cidrBlockAssociation", false, VpcCidrBlockAssociation_Parse),
      VpcId: xml.first("vpcId", false, x => x.content ?? ''),
    };
  }

  async enableEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & EnableEbsEncryptionByDefaultRequest = {},
  ): Promise<EnableEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async enableFastSnapshotRestores(
    {abortSignal, ...params}: RequestConfig & EnableFastSnapshotRestoresRequest,
  ): Promise<EnableFastSnapshotRestoresResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZone", params["AvailabilityZones"], {"entryPrefix":"."})
    if (params["SourceSnapshotIds"]) qsP.appendList(body, prefix+"SourceSnapshotId", params["SourceSnapshotIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableFastSnapshotRestores",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(EnableFastSnapshotRestoreSuccessItem_Parse),
      Unsuccessful: xml.getList("unsuccessful", "item").map(EnableFastSnapshotRestoreErrorItem_Parse),
    };
  }

  async enableTransitGatewayRouteTablePropagation(
    {abortSignal, ...params}: RequestConfig & EnableTransitGatewayRouteTablePropagationRequest,
  ): Promise<EnableTransitGatewayRouteTablePropagationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableTransitGatewayRouteTablePropagation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Propagation: xml.first("propagation", false, TransitGatewayPropagation_Parse),
    };
  }

  async enableVgwRoutePropagation(
    {abortSignal, ...params}: RequestConfig & EnableVgwRoutePropagationRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVgwRoutePropagation",
    });
  }

  async enableVolumeIO(
    {abortSignal, ...params}: RequestConfig & EnableVolumeIORequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVolumeIO",
    });
  }

  async enableVpcClassicLink(
    {abortSignal, ...params}: RequestConfig & EnableVpcClassicLinkRequest,
  ): Promise<EnableVpcClassicLinkResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVpcClassicLink",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async enableVpcClassicLinkDnsSupport(
    {abortSignal, ...params}: RequestConfig & EnableVpcClassicLinkDnsSupportRequest = {},
  ): Promise<EnableVpcClassicLinkDnsSupportResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableVpcClassicLinkDnsSupport",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async exportClientVpnClientCertificateRevocationList(
    {abortSignal, ...params}: RequestConfig & ExportClientVpnClientCertificateRevocationListRequest,
  ): Promise<ExportClientVpnClientCertificateRevocationListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportClientVpnClientCertificateRevocationList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CertificateRevocationList: xml.first("certificateRevocationList", false, x => x.content ?? ''),
      Status: xml.first("status", false, ClientCertificateRevocationListStatus_Parse),
    };
  }

  async exportClientVpnClientConfiguration(
    {abortSignal, ...params}: RequestConfig & ExportClientVpnClientConfigurationRequest,
  ): Promise<ExportClientVpnClientConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportClientVpnClientConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientConfiguration: xml.first("clientConfiguration", false, x => x.content ?? ''),
    };
  }

  async exportImage(
    {abortSignal, ...params}: RequestConfig & ExportImageRequest,
  ): Promise<ExportImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    body.append(prefix+"DiskImageFormat", (params["DiskImageFormat"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    ExportTaskS3LocationRequest_Serialize(body, prefix+"S3ExportLocation", params["S3ExportLocation"]);
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Description: xml.first("description", false, x => x.content ?? ''),
      DiskImageFormat: xml.first("diskImageFormat", false, x => (x.content ?? '') as DiskImageFormat),
      ExportImageTaskId: xml.first("exportImageTaskId", false, x => x.content ?? ''),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      RoleName: xml.first("roleName", false, x => x.content ?? ''),
      Progress: xml.first("progress", false, x => x.content ?? ''),
      S3ExportLocation: xml.first("s3ExportLocation", false, ExportTaskS3Location_Parse),
      Status: xml.first("status", false, x => x.content ?? ''),
      StatusMessage: xml.first("statusMessage", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async exportTransitGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & ExportTransitGatewayRoutesRequest,
  ): Promise<ExportTransitGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    body.append(prefix+"S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportTransitGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      S3Location: xml.first("s3Location", false, x => x.content ?? ''),
    };
  }

  async getAssociatedIpv6PoolCidrs(
    {abortSignal, ...params}: RequestConfig & GetAssociatedIpv6PoolCidrsRequest,
  ): Promise<GetAssociatedIpv6PoolCidrsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PoolId", (params["PoolId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAssociatedIpv6PoolCidrs",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Ipv6CidrAssociations: xml.getList("ipv6CidrAssociationSet", "item").map(Ipv6CidrAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getCapacityReservationUsage(
    {abortSignal, ...params}: RequestConfig & GetCapacityReservationUsageRequest,
  ): Promise<GetCapacityReservationUsageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCapacityReservationUsage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservationId: xml.first("capacityReservationId", false, x => x.content ?? ''),
      InstanceType: xml.first("instanceType", false, x => x.content ?? ''),
      TotalInstanceCount: xml.first("totalInstanceCount", false, x => parseInt(x.content ?? '0')),
      AvailableInstanceCount: xml.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
      State: xml.first("state", false, x => (x.content ?? '') as CapacityReservationState),
      InstanceUsages: xml.getList("instanceUsageSet", "item").map(InstanceUsage_Parse),
    };
  }

  async getCoipPoolUsage(
    {abortSignal, ...params}: RequestConfig & GetCoipPoolUsageRequest,
  ): Promise<GetCoipPoolUsageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PoolId", (params["PoolId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCoipPoolUsage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CoipPoolId: xml.first("coipPoolId", false, x => x.content ?? ''),
      CoipAddressUsages: xml.getList("coipAddressUsageSet", "item").map(CoipAddressUsage_Parse),
      LocalGatewayRouteTableId: xml.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    };
  }

  async getConsoleOutput(
    {abortSignal, ...params}: RequestConfig & GetConsoleOutputRequest,
  ): Promise<GetConsoleOutputResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Latest" in params) body.append(prefix+"Latest", (params["Latest"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConsoleOutput",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      Output: xml.first("output", false, x => x.content ?? ''),
      Timestamp: xml.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getConsoleScreenshot(
    {abortSignal, ...params}: RequestConfig & GetConsoleScreenshotRequest,
  ): Promise<GetConsoleScreenshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("WakeUp" in params) body.append(prefix+"WakeUp", (params["WakeUp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConsoleScreenshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageData: xml.first("imageData", false, x => x.content ?? ''),
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
    };
  }

  async getDefaultCreditSpecification(
    {abortSignal, ...params}: RequestConfig & GetDefaultCreditSpecificationRequest,
  ): Promise<GetDefaultCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDefaultCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceFamilyCreditSpecification: xml.first("instanceFamilyCreditSpecification", false, InstanceFamilyCreditSpecification_Parse),
    };
  }

  async getEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & GetEbsDefaultKmsKeyIdRequest = {},
  ): Promise<GetEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async getEbsEncryptionByDefault(
    {abortSignal, ...params}: RequestConfig & GetEbsEncryptionByDefaultRequest = {},
  ): Promise<GetEbsEncryptionByDefaultResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEbsEncryptionByDefault",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      EbsEncryptionByDefault: xml.first("ebsEncryptionByDefault", false, x => x.content === 'true'),
    };
  }

  async getGroupsForCapacityReservation(
    {abortSignal, ...params}: RequestConfig & GetGroupsForCapacityReservationRequest,
  ): Promise<GetGroupsForCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetGroupsForCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
      CapacityReservationGroups: xml.getList("capacityReservationGroupSet", "item").map(CapacityReservationGroup_Parse),
    };
  }

  async getHostReservationPurchasePreview(
    {abortSignal, ...params}: RequestConfig & GetHostReservationPurchasePreviewRequest,
  ): Promise<GetHostReservationPurchasePreviewResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["HostIdSet"]) qsP.appendList(body, prefix+"item", params["HostIdSet"], {"entryPrefix":"."})
    body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHostReservationPurchasePreview",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CurrencyCode: xml.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
      Purchase: xml.getList("purchase", "item").map(Purchase_Parse),
      TotalHourlyPrice: xml.first("totalHourlyPrice", false, x => x.content ?? ''),
      TotalUpfrontPrice: xml.first("totalUpfrontPrice", false, x => x.content ?? ''),
    };
  }

  async getLaunchTemplateData(
    {abortSignal, ...params}: RequestConfig & GetLaunchTemplateDataRequest,
  ): Promise<GetLaunchTemplateDataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLaunchTemplateData",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplateData: xml.first("launchTemplateData", false, ResponseLaunchTemplateData_Parse),
    };
  }

  async getManagedPrefixListAssociations(
    {abortSignal, ...params}: RequestConfig & GetManagedPrefixListAssociationsRequest,
  ): Promise<GetManagedPrefixListAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedPrefixListAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixListAssociations: xml.getList("prefixListAssociationSet", "item").map(PrefixListAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getManagedPrefixListEntries(
    {abortSignal, ...params}: RequestConfig & GetManagedPrefixListEntriesRequest,
  ): Promise<GetManagedPrefixListEntriesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TargetVersion" in params) body.append(prefix+"TargetVersion", (params["TargetVersion"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedPrefixListEntries",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Entries: xml.getList("entrySet", "item").map(PrefixListEntry_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getPasswordData(
    {abortSignal, ...params}: RequestConfig & GetPasswordDataRequest,
  ): Promise<GetPasswordDataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPasswordData",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      PasswordData: xml.first("passwordData", false, x => x.content ?? ''),
      Timestamp: xml.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getReservedInstancesExchangeQuote(
    {abortSignal, ...params}: RequestConfig & GetReservedInstancesExchangeQuoteRequest,
  ): Promise<GetReservedInstancesExchangeQuoteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["ReservedInstanceIds"]) qsP.appendList(body, prefix+"ReservedInstanceId", params["ReservedInstanceIds"], {"entryPrefix":"."})
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"TargetConfiguration", params["TargetConfigurations"], {"appender":TargetConfigurationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReservedInstancesExchangeQuote",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CurrencyCode: xml.first("currencyCode", false, x => x.content ?? ''),
      IsValidExchange: xml.first("isValidExchange", false, x => x.content === 'true'),
      OutputReservedInstancesWillExpireAt: xml.first("outputReservedInstancesWillExpireAt", false, x => xmlP.parseTimestamp(x.content)),
      PaymentDue: xml.first("paymentDue", false, x => x.content ?? ''),
      ReservedInstanceValueRollup: xml.first("reservedInstanceValueRollup", false, ReservationValue_Parse),
      ReservedInstanceValueSet: xml.getList("reservedInstanceValueSet", "item").map(ReservedInstanceReservationValue_Parse),
      TargetConfigurationValueRollup: xml.first("targetConfigurationValueRollup", false, ReservationValue_Parse),
      TargetConfigurationValueSet: xml.getList("targetConfigurationValueSet", "item").map(TargetReservationValue_Parse),
      ValidationFailureReason: xml.first("validationFailureReason", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayAttachmentPropagations(
    {abortSignal, ...params}: RequestConfig & GetTransitGatewayAttachmentPropagationsRequest,
  ): Promise<GetTransitGatewayAttachmentPropagationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayAttachmentPropagations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayAttachmentPropagations: xml.getList("transitGatewayAttachmentPropagations", "item").map(TransitGatewayAttachmentPropagation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayMulticastDomainAssociations(
    {abortSignal, ...params}: RequestConfig & GetTransitGatewayMulticastDomainAssociationsRequest = {},
  ): Promise<GetTransitGatewayMulticastDomainAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayMulticastDomainAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MulticastDomainAssociations: xml.getList("multicastDomainAssociations", "item").map(TransitGatewayMulticastDomainAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayPrefixListReferences(
    {abortSignal, ...params}: RequestConfig & GetTransitGatewayPrefixListReferencesRequest,
  ): Promise<GetTransitGatewayPrefixListReferencesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayPrefixListReferences",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReferences: xml.getList("transitGatewayPrefixListReferenceSet", "item").map(TransitGatewayPrefixListReference_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayRouteTableAssociations(
    {abortSignal, ...params}: RequestConfig & GetTransitGatewayRouteTableAssociationsRequest,
  ): Promise<GetTransitGatewayRouteTableAssociationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayRouteTableAssociations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Associations: xml.getList("associations", "item").map(TransitGatewayRouteTableAssociation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async getTransitGatewayRouteTablePropagations(
    {abortSignal, ...params}: RequestConfig & GetTransitGatewayRouteTablePropagationsRequest,
  ): Promise<GetTransitGatewayRouteTablePropagationsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTransitGatewayRouteTablePropagations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayRouteTablePropagations: xml.getList("transitGatewayRouteTablePropagations", "item").map(TransitGatewayRouteTablePropagation_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async importClientVpnClientCertificateRevocationList(
    {abortSignal, ...params}: RequestConfig & ImportClientVpnClientCertificateRevocationListRequest,
  ): Promise<ImportClientVpnClientCertificateRevocationListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"CertificateRevocationList", (params["CertificateRevocationList"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportClientVpnClientCertificateRevocationList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async importImage(
    {abortSignal, ...params}: RequestConfig & ImportImageRequest = {},
  ): Promise<ImportImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Architecture" in params) body.append(prefix+"Architecture", (params["Architecture"] ?? '').toString());
    if (params["ClientData"] != null) ClientData_Serialize(body, prefix+"ClientData", params["ClientData"]);
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskContainers"]) qsP.appendList(body, prefix+"DiskContainer", params["DiskContainers"], {"appender":ImageDiskContainer_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Hypervisor" in params) body.append(prefix+"Hypervisor", (params["Hypervisor"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("LicenseType" in params) body.append(prefix+"LicenseType", (params["LicenseType"] ?? '').toString());
    if ("Platform" in params) body.append(prefix+"Platform", (params["Platform"] ?? '').toString());
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+"item", params["LicenseSpecifications"], {"appender":ImportImageLicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Architecture: xml.first("architecture", false, x => x.content ?? ''),
      Description: xml.first("description", false, x => x.content ?? ''),
      Encrypted: xml.first("encrypted", false, x => x.content === 'true'),
      Hypervisor: xml.first("hypervisor", false, x => x.content ?? ''),
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
      LicenseType: xml.first("licenseType", false, x => x.content ?? ''),
      Platform: xml.first("platform", false, x => x.content ?? ''),
      Progress: xml.first("progress", false, x => x.content ?? ''),
      SnapshotDetails: xml.getList("snapshotDetailSet", "item").map(SnapshotDetail_Parse),
      Status: xml.first("status", false, x => x.content ?? ''),
      StatusMessage: xml.first("statusMessage", false, x => x.content ?? ''),
      LicenseSpecifications: xml.getList("licenseSpecifications", "item").map(ImportImageLicenseConfigurationResponse_Parse),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importInstance(
    {abortSignal, ...params}: RequestConfig & ImportInstanceRequest,
  ): Promise<ImportInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskImages"]) qsP.appendList(body, prefix+"diskImage", params["DiskImages"], {"appender":DiskImage_Serialize,"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LaunchSpecification"] != null) ImportInstanceLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    body.append(prefix+"Platform", (params["Platform"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTask: xml.first("conversionTask", false, ConversionTask_Parse),
    };
  }

  async importKeyPair(
    {abortSignal, ...params}: RequestConfig & ImportKeyPairRequest,
  ): Promise<ImportKeyPairResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    body.append(prefix+"PublicKeyMaterial", qsP.encodeBlob(params["PublicKeyMaterial"]));
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportKeyPair",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KeyFingerprint: xml.first("keyFingerprint", false, x => x.content ?? ''),
      KeyName: xml.first("keyName", false, x => x.content ?? ''),
      KeyPairId: xml.first("keyPairId", false, x => x.content ?? ''),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importSnapshot(
    {abortSignal, ...params}: RequestConfig & ImportSnapshotRequest = {},
  ): Promise<ImportSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ClientData"] != null) ClientData_Serialize(body, prefix+"ClientData", params["ClientData"]);
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["DiskContainer"] != null) SnapshotDiskContainer_Serialize(body, prefix+"DiskContainer", params["DiskContainer"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+"Encrypted", (params["Encrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("RoleName" in params) body.append(prefix+"RoleName", (params["RoleName"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Description: xml.first("description", false, x => x.content ?? ''),
      ImportTaskId: xml.first("importTaskId", false, x => x.content ?? ''),
      SnapshotTaskDetail: xml.first("snapshotTaskDetail", false, SnapshotTaskDetail_Parse),
      Tags: xml.getList("tagSet", "item").map(Tag_Parse),
    };
  }

  async importVolume(
    {abortSignal, ...params}: RequestConfig & ImportVolumeRequest,
  ): Promise<ImportVolumeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    DiskImageDetail_Serialize(body, prefix+"Image", params["Image"]);
    VolumeDetail_Serialize(body, prefix+"Volume", params["Volume"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ConversionTask: xml.first("conversionTask", false, ConversionTask_Parse),
    };
  }

  async modifyAvailabilityZoneGroup(
    {abortSignal, ...params}: RequestConfig & ModifyAvailabilityZoneGroupRequest,
  ): Promise<ModifyAvailabilityZoneGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    body.append(prefix+"OptInStatus", (params["OptInStatus"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyAvailabilityZoneGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyCapacityReservation(
    {abortSignal, ...params}: RequestConfig & ModifyCapacityReservationRequest,
  ): Promise<ModifyCapacityReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("EndDate" in params) body.append(prefix+"EndDate", qsP.encodeDate_iso8601(params["EndDate"]));
    if ("EndDateType" in params) body.append(prefix+"EndDateType", (params["EndDateType"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCapacityReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyClientVpnEndpoint(
    {abortSignal, ...params}: RequestConfig & ModifyClientVpnEndpointRequest,
  ): Promise<ModifyClientVpnEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("ServerCertificateArn" in params) body.append(prefix+"ServerCertificateArn", (params["ServerCertificateArn"] ?? '').toString());
    if (params["ConnectionLogOptions"] != null) ConnectionLogOptions_Serialize(body, prefix+"ConnectionLogOptions", params["ConnectionLogOptions"]);
    if (params["DnsServers"] != null) DnsServersOptionsModifyStructure_Serialize(body, prefix+"DnsServers", params["DnsServers"]);
    if ("VpnPort" in params) body.append(prefix+"VpnPort", (params["VpnPort"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("SplitTunnel" in params) body.append(prefix+"SplitTunnel", (params["SplitTunnel"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyClientVpnEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyDefaultCreditSpecification(
    {abortSignal, ...params}: RequestConfig & ModifyDefaultCreditSpecificationRequest,
  ): Promise<ModifyDefaultCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    body.append(prefix+"CpuCredits", (params["CpuCredits"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDefaultCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceFamilyCreditSpecification: xml.first("instanceFamilyCreditSpecification", false, InstanceFamilyCreditSpecification_Parse),
    };
  }

  async modifyEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & ModifyEbsDefaultKmsKeyIdRequest,
  ): Promise<ModifyEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async modifyFleet(
    {abortSignal, ...params}: RequestConfig & ModifyFleetRequest,
  ): Promise<ModifyFleetResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"LaunchTemplateConfig", params["LaunchTemplateConfigs"], {"appender":FleetLaunchTemplateConfigRequest_Serialize,"entryPrefix":"."})
    body.append(prefix+"FleetId", (params["FleetId"] ?? '').toString());
    TargetCapacitySpecificationRequest_Serialize(body, prefix+"TargetCapacitySpecification", params["TargetCapacitySpecification"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyFpgaImageAttributeRequest,
  ): Promise<ModifyFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if (params["UserGroups"]) qsP.appendList(body, prefix+"UserGroup", params["UserGroups"], {"entryPrefix":"."})
    if (params["ProductCodes"]) qsP.appendList(body, prefix+"ProductCode", params["ProductCodes"], {"entryPrefix":"."})
    if (params["LoadPermission"] != null) LoadPermissionModifications_Serialize(body, prefix+"LoadPermission", params["LoadPermission"]);
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("Name" in params) body.append(prefix+"Name", (params["Name"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      FpgaImageAttribute: xml.first("fpgaImageAttribute", false, FpgaImageAttribute_Parse),
    };
  }

  async modifyHosts(
    {abortSignal, ...params}: RequestConfig & ModifyHostsRequest,
  ): Promise<ModifyHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AutoPlacement" in params) body.append(prefix+"AutoPlacement", (params["AutoPlacement"] ?? '').toString());
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    if ("HostRecovery" in params) body.append(prefix+"HostRecovery", (params["HostRecovery"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("InstanceFamily" in params) body.append(prefix+"InstanceFamily", (params["InstanceFamily"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async modifyIdFormat(
    {abortSignal, ...params}: RequestConfig & ModifyIdFormatRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    body.append(prefix+"UseLongIds", (params["UseLongIds"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyIdFormat",
    });
  }

  async modifyIdentityIdFormat(
    {abortSignal, ...params}: RequestConfig & ModifyIdentityIdFormatRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PrincipalArn", (params["PrincipalArn"] ?? '').toString());
    body.append(prefix+"Resource", (params["Resource"] ?? '').toString());
    body.append(prefix+"UseLongIds", (params["UseLongIds"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyIdentityIdFormat",
    });
  }

  async modifyImageAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyImageAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["Description"] != null) AttributeValue_Serialize(body, prefix+"Description", params["Description"]);
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if (params["LaunchPermission"] != null) LaunchPermissionModifications_Serialize(body, prefix+"LaunchPermission", params["LaunchPermission"]);
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    if (params["ProductCodes"]) qsP.appendList(body, prefix+"ProductCode", params["ProductCodes"], {"entryPrefix":"."})
    if (params["UserGroups"]) qsP.appendList(body, prefix+"UserGroup", params["UserGroups"], {"entryPrefix":"."})
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if ("Value" in params) body.append(prefix+"Value", (params["Value"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyImageAttribute",
    });
  }

  async modifyInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["SourceDestCheck"] != null) AttributeBooleanValue_Serialize(body, prefix+"SourceDestCheck", params["SourceDestCheck"]);
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"blockDeviceMapping", params["BlockDeviceMappings"], {"appender":InstanceBlockDeviceMappingSpecification_Serialize,"entryPrefix":"."})
    if (params["DisableApiTermination"] != null) AttributeBooleanValue_Serialize(body, prefix+"DisableApiTermination", params["DisableApiTermination"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["EbsOptimized"] != null) AttributeBooleanValue_Serialize(body, prefix+"EbsOptimized", params["EbsOptimized"]);
    if (params["EnaSupport"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnaSupport", params["EnaSupport"]);
    if (params["Groups"]) qsP.appendList(body, prefix+"GroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if (params["InstanceInitiatedShutdownBehavior"] != null) AttributeValue_Serialize(body, prefix+"InstanceInitiatedShutdownBehavior", params["InstanceInitiatedShutdownBehavior"]);
    if (params["InstanceType"] != null) AttributeValue_Serialize(body, prefix+"InstanceType", params["InstanceType"]);
    if (params["Kernel"] != null) AttributeValue_Serialize(body, prefix+"Kernel", params["Kernel"]);
    if (params["Ramdisk"] != null) AttributeValue_Serialize(body, prefix+"Ramdisk", params["Ramdisk"]);
    if (params["SriovNetSupport"] != null) AttributeValue_Serialize(body, prefix+"SriovNetSupport", params["SriovNetSupport"]);
    if (params["UserData"] != null) BlobAttributeValue_Serialize(body, prefix+"UserData", params["UserData"]);
    if ("Value" in params) body.append(prefix+"Value", (params["Value"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceAttribute",
    });
  }

  async modifyInstanceCapacityReservationAttributes(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceCapacityReservationAttributesRequest,
  ): Promise<ModifyInstanceCapacityReservationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    CapacityReservationSpecification_Serialize(body, prefix+"CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceCapacityReservationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyInstanceCreditSpecification(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceCreditSpecificationRequest,
  ): Promise<ModifyInstanceCreditSpecificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["InstanceCreditSpecifications"]) qsP.appendList(body, prefix+"InstanceCreditSpecification", params["InstanceCreditSpecifications"], {"appender":InstanceCreditSpecificationRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceCreditSpecification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SuccessfulInstanceCreditSpecifications: xml.getList("successfulInstanceCreditSpecificationSet", "item").map(SuccessfulInstanceCreditSpecificationItem_Parse),
      UnsuccessfulInstanceCreditSpecifications: xml.getList("unsuccessfulInstanceCreditSpecificationSet", "item").map(UnsuccessfulInstanceCreditSpecificationItem_Parse),
    };
  }

  async modifyInstanceEventStartTime(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceEventStartTimeRequest,
  ): Promise<ModifyInstanceEventStartTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    body.append(prefix+"InstanceEventId", (params["InstanceEventId"] ?? '').toString());
    body.append(prefix+"NotBefore", qsP.encodeDate_iso8601(params["NotBefore"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceEventStartTime",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Event: xml.first("event", false, InstanceStatusEvent_Parse),
    };
  }

  async modifyInstanceMetadataOptions(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceMetadataOptionsRequest,
  ): Promise<ModifyInstanceMetadataOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("HttpTokens" in params) body.append(prefix+"HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+"HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+"HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceMetadataOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceId: xml.first("instanceId", false, x => x.content ?? ''),
      InstanceMetadataOptions: xml.first("instanceMetadataOptions", false, InstanceMetadataOptionsResponse_Parse),
    };
  }

  async modifyInstancePlacement(
    {abortSignal, ...params}: RequestConfig & ModifyInstancePlacementRequest,
  ): Promise<ModifyInstancePlacementResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Affinity" in params) body.append(prefix+"Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+"HostId", (params["HostId"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+"Tenancy", (params["Tenancy"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+"PartitionNumber", (params["PartitionNumber"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+"HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstancePlacement",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyLaunchTemplate(
    {abortSignal, ...params}: RequestConfig & ModifyLaunchTemplateRequest = {},
  ): Promise<ModifyLaunchTemplateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("LaunchTemplateId" in params) body.append(prefix+"LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+"LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("DefaultVersion" in params) body.append(prefix+"SetDefaultVersion", (params["DefaultVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyLaunchTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LaunchTemplate: xml.first("launchTemplate", false, LaunchTemplate_Parse),
    };
  }

  async modifyManagedPrefixList(
    {abortSignal, ...params}: RequestConfig & ModifyManagedPrefixListRequest,
  ): Promise<ModifyManagedPrefixListResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("CurrentVersion" in params) body.append(prefix+"CurrentVersion", (params["CurrentVersion"] ?? '').toString());
    if ("PrefixListName" in params) body.append(prefix+"PrefixListName", (params["PrefixListName"] ?? '').toString());
    if (params["AddEntries"]) qsP.appendList(body, prefix+"AddEntry", params["AddEntries"], {"appender":AddPrefixListEntry_Serialize,"entryPrefix":"."})
    if (params["RemoveEntries"]) qsP.appendList(body, prefix+"RemoveEntry", params["RemoveEntries"], {"appender":RemovePrefixListEntry_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyManagedPrefixList",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async modifyNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyNetworkInterfaceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Attachment"] != null) NetworkInterfaceAttachmentChanges_Serialize(body, prefix+"Attachment", params["Attachment"]);
    if (params["Description"] != null) AttributeValue_Serialize(body, prefix+"Description", params["Description"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+"SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["SourceDestCheck"] != null) AttributeBooleanValue_Serialize(body, prefix+"SourceDestCheck", params["SourceDestCheck"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyNetworkInterfaceAttribute",
    });
  }

  async modifyReservedInstances(
    {abortSignal, ...params}: RequestConfig & ModifyReservedInstancesRequest,
  ): Promise<ModifyReservedInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ReservedInstancesIds"]) qsP.appendList(body, prefix+"ReservedInstancesId", params["ReservedInstancesIds"], {"entryPrefix":"."})
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if (params["TargetConfigurations"]) qsP.appendList(body, prefix+"ReservedInstancesConfigurationSetItemType", params["TargetConfigurations"], {"appender":ReservedInstancesConfiguration_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReservedInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesModificationId: xml.first("reservedInstancesModificationId", false, x => x.content ?? ''),
    };
  }

  async modifySnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & ModifySnapshotAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if (params["CreateVolumePermission"] != null) CreateVolumePermissionModifications_Serialize(body, prefix+"CreateVolumePermission", params["CreateVolumePermission"]);
    if (params["GroupNames"]) qsP.appendList(body, prefix+"UserGroup", params["GroupNames"], {"entryPrefix":"."})
    if ("OperationType" in params) body.append(prefix+"OperationType", (params["OperationType"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if (params["UserIds"]) qsP.appendList(body, prefix+"UserId", params["UserIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySnapshotAttribute",
    });
  }

  async modifySpotFleetRequest(
    {abortSignal, ...params}: RequestConfig & ModifySpotFleetRequestRequest,
  ): Promise<ModifySpotFleetRequestResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+"ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+"LaunchTemplateConfig", params["LaunchTemplateConfigs"], {"appender":LaunchTemplateConfig_Serialize,"entryPrefix":"."})
    body.append(prefix+"SpotFleetRequestId", (params["SpotFleetRequestId"] ?? '').toString());
    if ("TargetCapacity" in params) body.append(prefix+"TargetCapacity", (params["TargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+"OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySpotFleetRequest",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifySubnetAttribute(
    {abortSignal, ...params}: RequestConfig & ModifySubnetAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AssignIpv6AddressOnCreation"] != null) AttributeBooleanValue_Serialize(body, prefix+"AssignIpv6AddressOnCreation", params["AssignIpv6AddressOnCreation"]);
    if (params["MapPublicIpOnLaunch"] != null) AttributeBooleanValue_Serialize(body, prefix+"MapPublicIpOnLaunch", params["MapPublicIpOnLaunch"]);
    body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["MapCustomerOwnedIpOnLaunch"] != null) AttributeBooleanValue_Serialize(body, prefix+"MapCustomerOwnedIpOnLaunch", params["MapCustomerOwnedIpOnLaunch"]);
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifySubnetAttribute",
    });
  }

  async modifyTrafficMirrorFilterNetworkServices(
    {abortSignal, ...params}: RequestConfig & ModifyTrafficMirrorFilterNetworkServicesRequest,
  ): Promise<ModifyTrafficMirrorFilterNetworkServicesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if (params["AddNetworkServices"]) qsP.appendList(body, prefix+"AddNetworkService", params["AddNetworkServices"], {"entryPrefix":"."})
    if (params["RemoveNetworkServices"]) qsP.appendList(body, prefix+"RemoveNetworkService", params["RemoveNetworkServices"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorFilterNetworkServices",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilter: xml.first("trafficMirrorFilter", false, TrafficMirrorFilter_Parse),
    };
  }

  async modifyTrafficMirrorFilterRule(
    {abortSignal, ...params}: RequestConfig & ModifyTrafficMirrorFilterRuleRequest,
  ): Promise<ModifyTrafficMirrorFilterRuleResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorFilterRuleId", (params["TrafficMirrorFilterRuleId"] ?? '').toString());
    if ("TrafficDirection" in params) body.append(prefix+"TrafficDirection", (params["TrafficDirection"] ?? '').toString());
    if ("RuleNumber" in params) body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    if ("RuleAction" in params) body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    if (params["DestinationPortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"DestinationPortRange", params["DestinationPortRange"]);
    if (params["SourcePortRange"] != null) TrafficMirrorPortRangeRequest_Serialize(body, prefix+"SourcePortRange", params["SourcePortRange"]);
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("SourceCidrBlock" in params) body.append(prefix+"SourceCidrBlock", (params["SourceCidrBlock"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["RemoveFields"]) qsP.appendList(body, prefix+"RemoveField", params["RemoveFields"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorFilterRule",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorFilterRule: xml.first("trafficMirrorFilterRule", false, TrafficMirrorFilterRule_Parse),
    };
  }

  async modifyTrafficMirrorSession(
    {abortSignal, ...params}: RequestConfig & ModifyTrafficMirrorSessionRequest,
  ): Promise<ModifyTrafficMirrorSessionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TrafficMirrorSessionId", (params["TrafficMirrorSessionId"] ?? '').toString());
    if ("TrafficMirrorTargetId" in params) body.append(prefix+"TrafficMirrorTargetId", (params["TrafficMirrorTargetId"] ?? '').toString());
    if ("TrafficMirrorFilterId" in params) body.append(prefix+"TrafficMirrorFilterId", (params["TrafficMirrorFilterId"] ?? '').toString());
    if ("PacketLength" in params) body.append(prefix+"PacketLength", (params["PacketLength"] ?? '').toString());
    if ("SessionNumber" in params) body.append(prefix+"SessionNumber", (params["SessionNumber"] ?? '').toString());
    if ("VirtualNetworkId" in params) body.append(prefix+"VirtualNetworkId", (params["VirtualNetworkId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["RemoveFields"]) qsP.appendList(body, prefix+"RemoveField", params["RemoveFields"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTrafficMirrorSession",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficMirrorSession: xml.first("trafficMirrorSession", false, TrafficMirrorSession_Parse),
    };
  }

  async modifyTransitGateway(
    {abortSignal, ...params}: RequestConfig & ModifyTransitGatewayRequest,
  ): Promise<ModifyTransitGatewayResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Options"] != null) ModifyTransitGatewayOptions_Serialize(body, prefix+"Options", params["Options"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGateway",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGateway: xml.first("transitGateway", false, TransitGateway_Parse),
    };
  }

  async modifyTransitGatewayPrefixListReference(
    {abortSignal, ...params}: RequestConfig & ModifyTransitGatewayPrefixListReferenceRequest,
  ): Promise<ModifyTransitGatewayPrefixListReferenceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGatewayPrefixListReference",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPrefixListReference: xml.first("transitGatewayPrefixListReference", false, TransitGatewayPrefixListReference_Parse),
    };
  }

  async modifyTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & ModifyTransitGatewayVpcAttachmentRequest,
  ): Promise<ModifyTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if (params["AddSubnetIds"]) qsP.appendList(body, prefix+"item", params["AddSubnetIds"], {"entryPrefix":"."})
    if (params["RemoveSubnetIds"]) qsP.appendList(body, prefix+"item", params["RemoveSubnetIds"], {"entryPrefix":"."})
    if (params["Options"] != null) ModifyTransitGatewayVpcAttachmentRequestOptions_Serialize(body, prefix+"Options", params["Options"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async modifyVolume(
    {abortSignal, ...params}: RequestConfig & ModifyVolumeRequest,
  ): Promise<ModifyVolumeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("Size" in params) body.append(prefix+"Size", (params["Size"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+"VolumeType", (params["VolumeType"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVolume",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VolumeModification: xml.first("volumeModification", false, VolumeModification_Parse),
    };
  }

  async modifyVolumeAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyVolumeAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AutoEnableIO"] != null) AttributeBooleanValue_Serialize(body, prefix+"AutoEnableIO", params["AutoEnableIO"]);
    body.append(prefix+"VolumeId", (params["VolumeId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVolumeAttribute",
    });
  }

  async modifyVpcAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyVpcAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["EnableDnsHostnames"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnableDnsHostnames", params["EnableDnsHostnames"]);
    if (params["EnableDnsSupport"] != null) AttributeBooleanValue_Serialize(body, prefix+"EnableDnsSupport", params["EnableDnsSupport"]);
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcAttribute",
    });
  }

  async modifyVpcEndpoint(
    {abortSignal, ...params}: RequestConfig & ModifyVpcEndpointRequest,
  ): Promise<ModifyVpcEndpointResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcEndpointId", (params["VpcEndpointId"] ?? '').toString());
    if ("ResetPolicy" in params) body.append(prefix+"ResetPolicy", (params["ResetPolicy"] ?? '').toString());
    if ("PolicyDocument" in params) body.append(prefix+"PolicyDocument", (params["PolicyDocument"] ?? '').toString());
    if (params["AddRouteTableIds"]) qsP.appendList(body, prefix+"AddRouteTableId", params["AddRouteTableIds"], {"entryPrefix":"."})
    if (params["RemoveRouteTableIds"]) qsP.appendList(body, prefix+"RemoveRouteTableId", params["RemoveRouteTableIds"], {"entryPrefix":"."})
    if (params["AddSubnetIds"]) qsP.appendList(body, prefix+"AddSubnetId", params["AddSubnetIds"], {"entryPrefix":"."})
    if (params["RemoveSubnetIds"]) qsP.appendList(body, prefix+"RemoveSubnetId", params["RemoveSubnetIds"], {"entryPrefix":"."})
    if (params["AddSecurityGroupIds"]) qsP.appendList(body, prefix+"AddSecurityGroupId", params["AddSecurityGroupIds"], {"entryPrefix":"."})
    if (params["RemoveSecurityGroupIds"]) qsP.appendList(body, prefix+"RemoveSecurityGroupId", params["RemoveSecurityGroupIds"], {"entryPrefix":"."})
    if ("PrivateDnsEnabled" in params) body.append(prefix+"PrivateDnsEnabled", (params["PrivateDnsEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpoint",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointConnectionNotification(
    {abortSignal, ...params}: RequestConfig & ModifyVpcEndpointConnectionNotificationRequest,
  ): Promise<ModifyVpcEndpointConnectionNotificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ConnectionNotificationId", (params["ConnectionNotificationId"] ?? '').toString());
    if ("ConnectionNotificationArn" in params) body.append(prefix+"ConnectionNotificationArn", (params["ConnectionNotificationArn"] ?? '').toString());
    if (params["ConnectionEvents"]) qsP.appendList(body, prefix+"item", params["ConnectionEvents"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointConnectionNotification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointServiceConfiguration(
    {abortSignal, ...params}: RequestConfig & ModifyVpcEndpointServiceConfigurationRequest,
  ): Promise<ModifyVpcEndpointServiceConfigurationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if ("PrivateDnsName" in params) body.append(prefix+"PrivateDnsName", (params["PrivateDnsName"] ?? '').toString());
    if ("RemovePrivateDnsName" in params) body.append(prefix+"RemovePrivateDnsName", (params["RemovePrivateDnsName"] ?? '').toString());
    if ("AcceptanceRequired" in params) body.append(prefix+"AcceptanceRequired", (params["AcceptanceRequired"] ?? '').toString());
    if (params["AddNetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"AddNetworkLoadBalancerArn", params["AddNetworkLoadBalancerArns"], {"entryPrefix":"."})
    if (params["RemoveNetworkLoadBalancerArns"]) qsP.appendList(body, prefix+"RemoveNetworkLoadBalancerArn", params["RemoveNetworkLoadBalancerArns"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointServiceConfiguration",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcEndpointServicePermissions(
    {abortSignal, ...params}: RequestConfig & ModifyVpcEndpointServicePermissionsRequest,
  ): Promise<ModifyVpcEndpointServicePermissionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["AddAllowedPrincipals"]) qsP.appendList(body, prefix+"item", params["AddAllowedPrincipals"], {"entryPrefix":"."})
    if (params["RemoveAllowedPrincipals"]) qsP.appendList(body, prefix+"item", params["RemoveAllowedPrincipals"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcEndpointServicePermissions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpcPeeringConnectionOptions(
    {abortSignal, ...params}: RequestConfig & ModifyVpcPeeringConnectionOptionsRequest,
  ): Promise<ModifyVpcPeeringConnectionOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AccepterPeeringConnectionOptions"] != null) PeeringConnectionOptionsRequest_Serialize(body, prefix+"AccepterPeeringConnectionOptions", params["AccepterPeeringConnectionOptions"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["RequesterPeeringConnectionOptions"] != null) PeeringConnectionOptionsRequest_Serialize(body, prefix+"RequesterPeeringConnectionOptions", params["RequesterPeeringConnectionOptions"]);
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcPeeringConnectionOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AccepterPeeringConnectionOptions: xml.first("accepterPeeringConnectionOptions", false, PeeringConnectionOptions_Parse),
      RequesterPeeringConnectionOptions: xml.first("requesterPeeringConnectionOptions", false, PeeringConnectionOptions_Parse),
    };
  }

  async modifyVpcTenancy(
    {abortSignal, ...params}: RequestConfig & ModifyVpcTenancyRequest,
  ): Promise<ModifyVpcTenancyResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    body.append(prefix+"InstanceTenancy", (params["InstanceTenancy"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpcTenancy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async modifyVpnConnection(
    {abortSignal, ...params}: RequestConfig & ModifyVpnConnectionRequest,
  ): Promise<ModifyVpnConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("CustomerGatewayId" in params) body.append(prefix+"CustomerGatewayId", (params["CustomerGatewayId"] ?? '').toString());
    if ("VpnGatewayId" in params) body.append(prefix+"VpnGatewayId", (params["VpnGatewayId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnConnectionOptions(
    {abortSignal, ...params}: RequestConfig & ModifyVpnConnectionOptionsRequest,
  ): Promise<ModifyVpnConnectionOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    if ("LocalIpv4NetworkCidr" in params) body.append(prefix+"LocalIpv4NetworkCidr", (params["LocalIpv4NetworkCidr"] ?? '').toString());
    if ("RemoteIpv4NetworkCidr" in params) body.append(prefix+"RemoteIpv4NetworkCidr", (params["RemoteIpv4NetworkCidr"] ?? '').toString());
    if ("LocalIpv6NetworkCidr" in params) body.append(prefix+"LocalIpv6NetworkCidr", (params["LocalIpv6NetworkCidr"] ?? '').toString());
    if ("RemoteIpv6NetworkCidr" in params) body.append(prefix+"RemoteIpv6NetworkCidr", (params["RemoteIpv6NetworkCidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnConnectionOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnTunnelCertificate(
    {abortSignal, ...params}: RequestConfig & ModifyVpnTunnelCertificateRequest,
  ): Promise<ModifyVpnTunnelCertificateResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    body.append(prefix+"VpnTunnelOutsideIpAddress", (params["VpnTunnelOutsideIpAddress"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnTunnelCertificate",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async modifyVpnTunnelOptions(
    {abortSignal, ...params}: RequestConfig & ModifyVpnTunnelOptionsRequest,
  ): Promise<ModifyVpnTunnelOptionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"VpnConnectionId", (params["VpnConnectionId"] ?? '').toString());
    body.append(prefix+"VpnTunnelOutsideIpAddress", (params["VpnTunnelOutsideIpAddress"] ?? '').toString());
    ModifyVpnTunnelOptionsSpecification_Serialize(body, prefix+"TunnelOptions", params["TunnelOptions"]);
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyVpnTunnelOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VpnConnection: xml.first("vpnConnection", false, VpnConnection_Parse),
    };
  }

  async monitorInstances(
    {abortSignal, ...params}: RequestConfig & MonitorInstancesRequest,
  ): Promise<MonitorInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MonitorInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceMonitorings: xml.getList("instancesSet", "item").map(InstanceMonitoring_Parse),
    };
  }

  async moveAddressToVpc(
    {abortSignal, ...params}: RequestConfig & MoveAddressToVpcRequest,
  ): Promise<MoveAddressToVpcResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MoveAddressToVpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AllocationId: xml.first("allocationId", false, x => x.content ?? ''),
      Status: xml.first("status", false, x => (x.content ?? '') as Status),
    };
  }

  async provisionByoipCidr(
    {abortSignal, ...params}: RequestConfig & ProvisionByoipCidrRequest,
  ): Promise<ProvisionByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if (params["CidrAuthorizationContext"] != null) CidrAuthorizationContext_Serialize(body, prefix+"CidrAuthorizationContext", params["CidrAuthorizationContext"]);
    if ("PubliclyAdvertisable" in params) body.append(prefix+"PubliclyAdvertisable", (params["PubliclyAdvertisable"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["PoolTagSpecifications"]) qsP.appendList(body, prefix+"PoolTagSpecification", params["PoolTagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ProvisionByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  async purchaseHostReservation(
    {abortSignal, ...params}: RequestConfig & PurchaseHostReservationRequest,
  ): Promise<PurchaseHostReservationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("CurrencyCode" in params) body.append(prefix+"CurrencyCode", (params["CurrencyCode"] ?? '').toString());
    if (params["HostIdSet"]) qsP.appendList(body, prefix+"item", params["HostIdSet"], {"entryPrefix":"."})
    if ("LimitPrice" in params) body.append(prefix+"LimitPrice", (params["LimitPrice"] ?? '').toString());
    body.append(prefix+"OfferingId", (params["OfferingId"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseHostReservation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientToken: xml.first("clientToken", false, x => x.content ?? ''),
      CurrencyCode: xml.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
      Purchase: xml.getList("purchase", "item").map(Purchase_Parse),
      TotalHourlyPrice: xml.first("totalHourlyPrice", false, x => x.content ?? ''),
      TotalUpfrontPrice: xml.first("totalUpfrontPrice", false, x => x.content ?? ''),
    };
  }

  async purchaseReservedInstancesOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedInstancesOfferingRequest,
  ): Promise<PurchaseReservedInstancesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+"ReservedInstancesOfferingId", (params["ReservedInstancesOfferingId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["LimitPrice"] != null) ReservedInstanceLimitPrice_Serialize(body, prefix+"LimitPrice", params["LimitPrice"]);
    if ("PurchaseTime" in params) body.append(prefix+"PurchaseTime", qsP.encodeDate_iso8601(params["PurchaseTime"]));
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedInstancesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReservedInstancesId: xml.first("reservedInstancesId", false, x => x.content ?? ''),
    };
  }

  async purchaseScheduledInstances(
    {abortSignal, ...params}: RequestConfig & PurchaseScheduledInstancesRequest,
  ): Promise<PurchaseScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["PurchaseRequests"]) qsP.appendList(body, prefix+"PurchaseRequest", params["PurchaseRequests"], {"appender":PurchaseRequest_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ScheduledInstanceSet: xml.getList("scheduledInstanceSet", "item").map(ScheduledInstance_Parse),
    };
  }

  async rebootInstances(
    {abortSignal, ...params}: RequestConfig & RebootInstancesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootInstances",
    });
  }

  async registerImage(
    {abortSignal, ...params}: RequestConfig & RegisterImageRequest,
  ): Promise<RegisterImageResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ImageLocation" in params) body.append(prefix+"ImageLocation", (params["ImageLocation"] ?? '').toString());
    if ("Architecture" in params) body.append(prefix+"Architecture", (params["Architecture"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EnaSupport" in params) body.append(prefix+"EnaSupport", (params["EnaSupport"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if (params["BillingProducts"]) qsP.appendList(body, prefix+"BillingProduct", params["BillingProducts"], {"entryPrefix":"."})
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("RootDeviceName" in params) body.append(prefix+"RootDeviceName", (params["RootDeviceName"] ?? '').toString());
    if ("SriovNetSupport" in params) body.append(prefix+"SriovNetSupport", (params["SriovNetSupport"] ?? '').toString());
    if ("VirtualizationType" in params) body.append(prefix+"VirtualizationType", (params["VirtualizationType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterImage",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ImageId: xml.first("imageId", false, x => x.content ?? ''),
    };
  }

  async registerInstanceEventNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & RegisterInstanceEventNotificationAttributesRequest = {},
  ): Promise<RegisterInstanceEventNotificationAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if (params["InstanceTagAttribute"] != null) RegisterInstanceTagAttributeRequest_Serialize(body, prefix+"InstanceTagAttribute", params["InstanceTagAttribute"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterInstanceEventNotificationAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceTagAttribute: xml.first("instanceTagAttribute", false, InstanceTagNotificationAttribute_Parse),
    };
  }

  async registerTransitGatewayMulticastGroupMembers(
    {abortSignal, ...params}: RequestConfig & RegisterTransitGatewayMulticastGroupMembersRequest = {},
  ): Promise<RegisterTransitGatewayMulticastGroupMembersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTransitGatewayMulticastGroupMembers",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RegisteredMulticastGroupMembers: xml.first("registeredMulticastGroupMembers", false, TransitGatewayMulticastRegisteredGroupMembers_Parse),
    };
  }

  async registerTransitGatewayMulticastGroupSources(
    {abortSignal, ...params}: RequestConfig & RegisterTransitGatewayMulticastGroupSourcesRequest = {},
  ): Promise<RegisterTransitGatewayMulticastGroupSourcesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if ("GroupIpAddress" in params) body.append(prefix+"GroupIpAddress", (params["GroupIpAddress"] ?? '').toString());
    if (params["NetworkInterfaceIds"]) qsP.appendList(body, prefix+"item", params["NetworkInterfaceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTransitGatewayMulticastGroupSources",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RegisteredMulticastGroupSources: xml.first("registeredMulticastGroupSources", false, TransitGatewayMulticastRegisteredGroupSources_Parse),
    };
  }

  async rejectTransitGatewayPeeringAttachment(
    {abortSignal, ...params}: RequestConfig & RejectTransitGatewayPeeringAttachmentRequest,
  ): Promise<RejectTransitGatewayPeeringAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectTransitGatewayPeeringAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayPeeringAttachment: xml.first("transitGatewayPeeringAttachment", false, TransitGatewayPeeringAttachment_Parse),
    };
  }

  async rejectTransitGatewayVpcAttachment(
    {abortSignal, ...params}: RequestConfig & RejectTransitGatewayVpcAttachmentRequest,
  ): Promise<RejectTransitGatewayVpcAttachmentResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectTransitGatewayVpcAttachment",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TransitGatewayVpcAttachment: xml.first("transitGatewayVpcAttachment", false, TransitGatewayVpcAttachment_Parse),
    };
  }

  async rejectVpcEndpointConnections(
    {abortSignal, ...params}: RequestConfig & RejectVpcEndpointConnectionsRequest,
  ): Promise<RejectVpcEndpointConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    if (params["VpcEndpointIds"]) qsP.appendList(body, prefix+"VpcEndpointId", params["VpcEndpointIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectVpcEndpointConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async rejectVpcPeeringConnection(
    {abortSignal, ...params}: RequestConfig & RejectVpcPeeringConnectionRequest,
  ): Promise<RejectVpcPeeringConnectionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectVpcPeeringConnection",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async releaseAddress(
    {abortSignal, ...params}: RequestConfig & ReleaseAddressRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AllocationId" in params) body.append(prefix+"AllocationId", (params["AllocationId"] ?? '').toString());
    if ("PublicIp" in params) body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    if ("NetworkBorderGroup" in params) body.append(prefix+"NetworkBorderGroup", (params["NetworkBorderGroup"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReleaseAddress",
    });
  }

  async releaseHosts(
    {abortSignal, ...params}: RequestConfig & ReleaseHostsRequest,
  ): Promise<ReleaseHostsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["HostIds"]) qsP.appendList(body, prefix+"hostId", params["HostIds"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReleaseHosts",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Successful: xml.getList("successful", "item").map(x => x.content ?? ''),
      Unsuccessful: xml.getList("unsuccessful", "item").map(UnsuccessfulItem_Parse),
    };
  }

  async replaceIamInstanceProfileAssociation(
    {abortSignal, ...params}: RequestConfig & ReplaceIamInstanceProfileAssociationRequest,
  ): Promise<ReplaceIamInstanceProfileAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceIamInstanceProfileAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IamInstanceProfileAssociation: xml.first("iamInstanceProfileAssociation", false, IamInstanceProfileAssociation_Parse),
    };
  }

  async replaceNetworkAclAssociation(
    {abortSignal, ...params}: RequestConfig & ReplaceNetworkAclAssociationRequest,
  ): Promise<ReplaceNetworkAclAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceNetworkAclAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NewAssociationId: xml.first("newAssociationId", false, x => x.content ?? ''),
    };
  }

  async replaceNetworkAclEntry(
    {abortSignal, ...params}: RequestConfig & ReplaceNetworkAclEntryRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrBlock" in params) body.append(prefix+"CidrBlock", (params["CidrBlock"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"Egress", (params["Egress"] ?? '').toString());
    if (params["IcmpTypeCode"] != null) IcmpTypeCode_Serialize(body, prefix+"Icmp", params["IcmpTypeCode"]);
    if ("Ipv6CidrBlock" in params) body.append(prefix+"Ipv6CidrBlock", (params["Ipv6CidrBlock"] ?? '').toString());
    body.append(prefix+"NetworkAclId", (params["NetworkAclId"] ?? '').toString());
    if (params["PortRange"] != null) PortRange_Serialize(body, prefix+"PortRange", params["PortRange"]);
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"RuleAction", (params["RuleAction"] ?? '').toString());
    body.append(prefix+"RuleNumber", (params["RuleNumber"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceNetworkAclEntry",
    });
  }

  async replaceRoute(
    {abortSignal, ...params}: RequestConfig & ReplaceRouteRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DestinationCidrBlock" in params) body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    if ("DestinationIpv6CidrBlock" in params) body.append(prefix+"DestinationIpv6CidrBlock", (params["DestinationIpv6CidrBlock"] ?? '').toString());
    if ("DestinationPrefixListId" in params) body.append(prefix+"DestinationPrefixListId", (params["DestinationPrefixListId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EgressOnlyInternetGatewayId" in params) body.append(prefix+"EgressOnlyInternetGatewayId", (params["EgressOnlyInternetGatewayId"] ?? '').toString());
    if ("GatewayId" in params) body.append(prefix+"GatewayId", (params["GatewayId"] ?? '').toString());
    if ("InstanceId" in params) body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("LocalTarget" in params) body.append(prefix+"LocalTarget", (params["LocalTarget"] ?? '').toString());
    if ("NatGatewayId" in params) body.append(prefix+"NatGatewayId", (params["NatGatewayId"] ?? '').toString());
    if ("TransitGatewayId" in params) body.append(prefix+"TransitGatewayId", (params["TransitGatewayId"] ?? '').toString());
    if ("LocalGatewayId" in params) body.append(prefix+"LocalGatewayId", (params["LocalGatewayId"] ?? '').toString());
    if ("CarrierGatewayId" in params) body.append(prefix+"CarrierGatewayId", (params["CarrierGatewayId"] ?? '').toString());
    if ("NetworkInterfaceId" in params) body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+"VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceRoute",
    });
  }

  async replaceRouteTableAssociation(
    {abortSignal, ...params}: RequestConfig & ReplaceRouteTableAssociationRequest,
  ): Promise<ReplaceRouteTableAssociationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"AssociationId", (params["AssociationId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"RouteTableId", (params["RouteTableId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceRouteTableAssociation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NewAssociationId: xml.first("newAssociationId", false, x => x.content ?? ''),
      AssociationState: xml.first("associationState", false, RouteTableAssociationState_Parse),
    };
  }

  async replaceTransitGatewayRoute(
    {abortSignal, ...params}: RequestConfig & ReplaceTransitGatewayRouteRequest,
  ): Promise<ReplaceTransitGatewayRouteResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DestinationCidrBlock", (params["DestinationCidrBlock"] ?? '').toString());
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if ("TransitGatewayAttachmentId" in params) body.append(prefix+"TransitGatewayAttachmentId", (params["TransitGatewayAttachmentId"] ?? '').toString());
    if ("Blackhole" in params) body.append(prefix+"Blackhole", (params["Blackhole"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReplaceTransitGatewayRoute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Route: xml.first("route", false, TransitGatewayRoute_Parse),
    };
  }

  async reportInstanceStatus(
    {abortSignal, ...params}: RequestConfig & ReportInstanceStatusRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if (params["Instances"]) qsP.appendList(body, prefix+"instanceId", params["Instances"], {"entryPrefix":"."})
    if (params["ReasonCodes"]) qsP.appendList(body, prefix+"reasonCode", params["ReasonCodes"], {"entryPrefix":"."})
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReportInstanceStatus",
    });
  }

  async requestSpotFleet(
    {abortSignal, ...params}: RequestConfig & RequestSpotFleetRequest,
  ): Promise<RequestSpotFleetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    SpotFleetRequestConfigData_Serialize(body, prefix+"SpotFleetRequestConfig", params["SpotFleetRequestConfig"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestSpotFleet",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotFleetRequestId: xml.first("spotFleetRequestId", false, x => x.content ?? ''),
    };
  }

  async requestSpotInstances(
    {abortSignal, ...params}: RequestConfig & RequestSpotInstancesRequest = {},
  ): Promise<RequestSpotInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("AvailabilityZoneGroup" in params) body.append(prefix+"AvailabilityZoneGroup", (params["AvailabilityZoneGroup"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+"BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("LaunchGroup" in params) body.append(prefix+"LaunchGroup", (params["LaunchGroup"] ?? '').toString());
    if (params["LaunchSpecification"] != null) RequestSpotLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    if ("SpotPrice" in params) body.append(prefix+"SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+"ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+"ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+"InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestSpotInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      SpotInstanceRequests: xml.getList("spotInstanceRequestSet", "item").map(SpotInstanceRequest_Parse),
    };
  }

  async resetEbsDefaultKmsKeyId(
    {abortSignal, ...params}: RequestConfig & ResetEbsDefaultKmsKeyIdRequest = {},
  ): Promise<ResetEbsDefaultKmsKeyIdResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetEbsDefaultKmsKeyId",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      KmsKeyId: xml.first("kmsKeyId", false, x => x.content ?? ''),
    };
  }

  async resetFpgaImageAttribute(
    {abortSignal, ...params}: RequestConfig & ResetFpgaImageAttributeRequest,
  ): Promise<ResetFpgaImageAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"FpgaImageId", (params["FpgaImageId"] ?? '').toString());
    if ("Attribute" in params) body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetFpgaImageAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async resetImageAttribute(
    {abortSignal, ...params}: RequestConfig & ResetImageAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetImageAttribute",
    });
  }

  async resetInstanceAttribute(
    {abortSignal, ...params}: RequestConfig & ResetInstanceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetInstanceAttribute",
    });
  }

  async resetNetworkInterfaceAttribute(
    {abortSignal, ...params}: RequestConfig & ResetNetworkInterfaceAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("SourceDestCheck" in params) body.append(prefix+"SourceDestCheck", (params["SourceDestCheck"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetNetworkInterfaceAttribute",
    });
  }

  async resetSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & ResetSnapshotAttributeRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Attribute", (params["Attribute"] ?? '').toString());
    body.append(prefix+"SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetSnapshotAttribute",
    });
  }

  async restoreAddressToClassic(
    {abortSignal, ...params}: RequestConfig & RestoreAddressToClassicRequest,
  ): Promise<RestoreAddressToClassicResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PublicIp", (params["PublicIp"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreAddressToClassic",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicIp: xml.first("publicIp", false, x => x.content ?? ''),
      Status: xml.first("status", false, x => (x.content ?? '') as Status),
    };
  }

  async restoreManagedPrefixListVersion(
    {abortSignal, ...params}: RequestConfig & RestoreManagedPrefixListVersionRequest,
  ): Promise<RestoreManagedPrefixListVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"PrefixListId", (params["PrefixListId"] ?? '').toString());
    body.append(prefix+"PreviousVersion", (params["PreviousVersion"] ?? '').toString());
    body.append(prefix+"CurrentVersion", (params["CurrentVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreManagedPrefixListVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PrefixList: xml.first("prefixList", false, ManagedPrefixList_Parse),
    };
  }

  async revokeClientVpnIngress(
    {abortSignal, ...params}: RequestConfig & RevokeClientVpnIngressRequest,
  ): Promise<RevokeClientVpnIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    body.append(prefix+"TargetNetworkCidr", (params["TargetNetworkCidr"] ?? '').toString());
    if ("AccessGroupId" in params) body.append(prefix+"AccessGroupId", (params["AccessGroupId"] ?? '').toString());
    if ("RevokeAllGroups" in params) body.append(prefix+"RevokeAllGroups", (params["RevokeAllGroups"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeClientVpnIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
    };
  }

  async revokeSecurityGroupEgress(
    {abortSignal, ...params}: RequestConfig & RevokeSecurityGroupEgressRequest,
  ): Promise<RevokeSecurityGroupEgressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"ipPermissions", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSecurityGroupEgress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
      UnknownIpPermissions: xml.getList("unknownIpPermissionSet", "item").map(IpPermission_Parse),
    };
  }

  async revokeSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & RevokeSecurityGroupIngressRequest = {},
  ): Promise<RevokeSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CidrIp" in params) body.append(prefix+"CidrIp", (params["CidrIp"] ?? '').toString());
    if ("FromPort" in params) body.append(prefix+"FromPort", (params["FromPort"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    if ("IpProtocol" in params) body.append(prefix+"IpProtocol", (params["IpProtocol"] ?? '').toString());
    if ("SourceSecurityGroupName" in params) body.append(prefix+"SourceSecurityGroupName", (params["SourceSecurityGroupName"] ?? '').toString());
    if ("SourceSecurityGroupOwnerId" in params) body.append(prefix+"SourceSecurityGroupOwnerId", (params["SourceSecurityGroupOwnerId"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+"ToPort", (params["ToPort"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
      UnknownIpPermissions: xml.getList("unknownIpPermissionSet", "item").map(IpPermission_Parse),
    };
  }

  async runInstances(
    {abortSignal, ...params}: RequestConfig & RunInstancesRequest,
  ): Promise<Reservation> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+"BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("ImageId" in params) body.append(prefix+"ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+"InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Ipv6AddressCount" in params) body.append(prefix+"Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"Ipv6Address", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("KernelId" in params) body.append(prefix+"KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+"KeyName", (params["KeyName"] ?? '').toString());
    body.append(prefix+"MaxCount", (params["MaxCount"] ?? '').toString());
    body.append(prefix+"MinCount", (params["MinCount"] ?? '').toString());
    if (params["Monitoring"] != null) RunInstancesMonitoringEnabled_Serialize(body, prefix+"Monitoring", params["Monitoring"]);
    if (params["Placement"] != null) Placement_Serialize(body, prefix+"Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+"RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+"SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if ("SubnetId" in params) body.append(prefix+"SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+"UserData", (params["UserData"] ?? '').toString());
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DisableApiTermination" in params) body.append(prefix+"DisableApiTermination", (params["DisableApiTermination"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+"EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+"IamInstanceProfile", params["IamInstanceProfile"]);
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+"InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+"networkInterface", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if ("PrivateIpAddress" in params) body.append(prefix+"PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["ElasticGpuSpecification"]) qsP.appendList(body, prefix+"item", params["ElasticGpuSpecification"], {"appender":ElasticGpuSpecification_Serialize,"entryPrefix":"."})
    if (params["ElasticInferenceAccelerators"]) qsP.appendList(body, prefix+"ElasticInferenceAccelerator", params["ElasticInferenceAccelerators"], {"appender":ElasticInferenceAccelerator_Serialize,"entryPrefix":"."})
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+"TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
    if (params["LaunchTemplate"] != null) LaunchTemplateSpecification_Serialize(body, prefix+"LaunchTemplate", params["LaunchTemplate"]);
    if (params["InstanceMarketOptions"] != null) InstanceMarketOptionsRequest_Serialize(body, prefix+"InstanceMarketOptions", params["InstanceMarketOptions"]);
    if (params["CreditSpecification"] != null) CreditSpecificationRequest_Serialize(body, prefix+"CreditSpecification", params["CreditSpecification"]);
    if (params["CpuOptions"] != null) CpuOptionsRequest_Serialize(body, prefix+"CpuOptions", params["CpuOptions"]);
    if (params["CapacityReservationSpecification"] != null) CapacityReservationSpecification_Serialize(body, prefix+"CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if (params["HibernationOptions"] != null) HibernationOptionsRequest_Serialize(body, prefix+"HibernationOptions", params["HibernationOptions"]);
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+"LicenseSpecification", params["LicenseSpecifications"], {"appender":LicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["MetadataOptions"] != null) InstanceMetadataOptionsRequest_Serialize(body, prefix+"MetadataOptions", params["MetadataOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return Reservation_Parse(xml);
  }

  async runScheduledInstances(
    {abortSignal, ...params}: RequestConfig & RunScheduledInstancesRequest,
  ): Promise<RunScheduledInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientToken", (params["ClientToken"] ?? generateIdemptToken()).toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+"InstanceCount", (params["InstanceCount"] ?? '').toString());
    ScheduledInstancesLaunchSpecification_Serialize(body, prefix+"LaunchSpecification", params["LaunchSpecification"]);
    body.append(prefix+"ScheduledInstanceId", (params["ScheduledInstanceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunScheduledInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceIdSet: xml.getList("instanceIdSet", "item").map(x => x.content ?? ''),
    };
  }

  async searchLocalGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & SearchLocalGatewayRoutesRequest,
  ): Promise<SearchLocalGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LocalGatewayRouteTableId", (params["LocalGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchLocalGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routeSet", "item").map(LocalGatewayRoute_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async searchTransitGatewayMulticastGroups(
    {abortSignal, ...params}: RequestConfig & SearchTransitGatewayMulticastGroupsRequest = {},
  ): Promise<SearchTransitGatewayMulticastGroupsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TransitGatewayMulticastDomainId" in params) body.append(prefix+"TransitGatewayMulticastDomainId", (params["TransitGatewayMulticastDomainId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTransitGatewayMulticastGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MulticastGroups: xml.getList("multicastGroups", "item").map(TransitGatewayMulticastGroup_Parse),
      NextToken: xml.first("nextToken", false, x => x.content ?? ''),
    };
  }

  async searchTransitGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & SearchTransitGatewayRoutesRequest,
  ): Promise<SearchTransitGatewayRoutesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TransitGatewayRouteTableId", (params["TransitGatewayRouteTableId"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filter", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":"."})
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTransitGatewayRoutes",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Routes: xml.getList("routeSet", "item").map(TransitGatewayRoute_Parse),
      AdditionalRoutesAvailable: xml.first("additionalRoutesAvailable", false, x => x.content === 'true'),
    };
  }

  async sendDiagnosticInterrupt(
    {abortSignal, ...params}: RequestConfig & SendDiagnosticInterruptRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"InstanceId", (params["InstanceId"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendDiagnosticInterrupt",
    });
  }

  async startInstances(
    {abortSignal, ...params}: RequestConfig & StartInstancesRequest,
  ): Promise<StartInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("AdditionalInfo" in params) body.append(prefix+"AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      StartingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async startVpcEndpointServicePrivateDnsVerification(
    {abortSignal, ...params}: RequestConfig & StartVpcEndpointServicePrivateDnsVerificationRequest,
  ): Promise<StartVpcEndpointServicePrivateDnsVerificationResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    body.append(prefix+"ServiceId", (params["ServiceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartVpcEndpointServicePrivateDnsVerification",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReturnValue: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async stopInstances(
    {abortSignal, ...params}: RequestConfig & StopInstancesRequest,
  ): Promise<StopInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("Hibernate" in params) body.append(prefix+"Hibernate", (params["Hibernate"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("Force" in params) body.append(prefix+"Force", (params["Force"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      StoppingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async terminateClientVpnConnections(
    {abortSignal, ...params}: RequestConfig & TerminateClientVpnConnectionsRequest,
  ): Promise<TerminateClientVpnConnectionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ClientVpnEndpointId", (params["ClientVpnEndpointId"] ?? '').toString());
    if ("ConnectionId" in params) body.append(prefix+"ConnectionId", (params["ConnectionId"] ?? '').toString());
    if ("Username" in params) body.append(prefix+"Username", (params["Username"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateClientVpnConnections",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ClientVpnEndpointId: xml.first("clientVpnEndpointId", false, x => x.content ?? ''),
      Username: xml.first("username", false, x => x.content ?? ''),
      ConnectionStatuses: xml.getList("connectionStatuses", "item").map(TerminateConnectionStatus_Parse),
    };
  }

  async terminateInstances(
    {abortSignal, ...params}: RequestConfig & TerminateInstancesRequest,
  ): Promise<TerminateInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TerminatingInstances: xml.getList("instancesSet", "item").map(InstanceStateChange_Parse),
    };
  }

  async unassignIpv6Addresses(
    {abortSignal, ...params}: RequestConfig & UnassignIpv6AddressesRequest,
  ): Promise<UnassignIpv6AddressesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+"ipv6Addresses", params["Ipv6Addresses"], {"entryPrefix":"."})
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignIpv6Addresses",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      NetworkInterfaceId: xml.first("networkInterfaceId", false, x => x.content ?? ''),
      UnassignedIpv6Addresses: xml.getList("unassignedIpv6Addresses", "item").map(x => x.content ?? ''),
    };
  }

  async unassignPrivateIpAddresses(
    {abortSignal, ...params}: RequestConfig & UnassignPrivateIpAddressesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+"privateIpAddress", params["PrivateIpAddresses"], {"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnassignPrivateIpAddresses",
    });
  }

  async unmonitorInstances(
    {abortSignal, ...params}: RequestConfig & UnmonitorInstancesRequest,
  ): Promise<UnmonitorInstancesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["InstanceIds"]) qsP.appendList(body, prefix+"InstanceId", params["InstanceIds"], {"entryPrefix":"."})
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnmonitorInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InstanceMonitorings: xml.getList("instancesSet", "item").map(InstanceMonitoring_Parse),
    };
  }

  async updateSecurityGroupRuleDescriptionsEgress(
    {abortSignal, ...params}: RequestConfig & UpdateSecurityGroupRuleDescriptionsEgressRequest,
  ): Promise<UpdateSecurityGroupRuleDescriptionsEgressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecurityGroupRuleDescriptionsEgress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async updateSecurityGroupRuleDescriptionsIngress(
    {abortSignal, ...params}: RequestConfig & UpdateSecurityGroupRuleDescriptionsIngressRequest,
  ): Promise<UpdateSecurityGroupRuleDescriptionsIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+"GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["IpPermissions"]) qsP.appendList(body, prefix+"item", params["IpPermissions"], {"appender":IpPermission_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecurityGroupRuleDescriptionsIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Return: xml.first("return", false, x => x.content === 'true'),
    };
  }

  async withdrawByoipCidr(
    {abortSignal, ...params}: RequestConfig & WithdrawByoipCidrRequest,
  ): Promise<WithdrawByoipCidrResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Cidr", (params["Cidr"] ?? '').toString());
    if ("DryRun" in params) body.append(prefix+"DryRun", (params["DryRun"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "WithdrawByoipCidr",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ByoipCidr: xml.first("byoipCidr", false, ByoipCidr_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 5 seconds apart (about 4 minutes max wait time). */
  async waitForInstanceExists(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        if ((resp?.Reservations || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForBundleTaskComplete(
    params: RequestConfig & DescribeBundleTasksRequest,
  ): Promise<DescribeBundleTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BundleTaskComplete';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeBundleTasks(params);
      const field = resp?.BundleTasks?.flatMap(x => x?.State);
      if (field.every(x => x === "complete")) return resp;
      if (field.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForConversionTaskCancelled(
    params: RequestConfig & DescribeConversionTasksRequest,
  ): Promise<DescribeConversionTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConversionTaskCancelled';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeConversionTasks(params);
      if (resp?.ConversionTasks?.flatMap(x => x?.State).every(x => x === "cancelled")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForConversionTaskCompleted(
    params: RequestConfig & DescribeConversionTasksRequest,
  ): Promise<DescribeConversionTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConversionTaskCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeConversionTasks(params);
      const field = resp?.ConversionTasks?.flatMap(x => x?.State);
      if (field.every(x => x === "completed")) return resp;
      if (field.some(x => x === "cancelled")) throw new Error(errMessage);
      if (field.some(x => x === "cancelling")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForCustomerGatewayAvailable(
    params: RequestConfig & DescribeCustomerGatewaysRequest,
  ): Promise<DescribeCustomerGatewaysResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CustomerGatewayAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeCustomerGateways(params);
      const field = resp?.CustomerGateways?.flatMap(x => x?.State);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      if (field.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForExportTaskCancelled(
    params: RequestConfig & DescribeExportTasksRequest,
  ): Promise<DescribeExportTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ExportTaskCancelled';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeExportTasks(params);
      if (resp?.ExportTasks?.flatMap(x => x?.State).every(x => x === "cancelled")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForExportTaskCompleted(
    params: RequestConfig & DescribeExportTasksRequest,
  ): Promise<DescribeExportTasksResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ExportTaskCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeExportTasks(params);
      if (resp?.ExportTasks?.flatMap(x => x?.State).every(x => x === "completed")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForImageExists(
    params: RequestConfig & DescribeImagesRequest,
  ): Promise<DescribeImagesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeImages(params);
        if ((resp?.Images || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidAMIID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForImageAvailable(
    params: RequestConfig & DescribeImagesRequest,
  ): Promise<DescribeImagesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeImages(params);
      const field = resp?.Images?.flatMap(x => x?.State);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceRunning(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceRunning';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstances(params);
        const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
        if (field.every(x => x === "running")) return resp;
        if (field.some(x => x === "shutting-down")) throw new Error(errMessage);
        if (field.some(x => x === "terminated")) throw new Error(errMessage);
        if (field.some(x => x === "stopping")) throw new Error(errMessage);
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceStatusOk(
    params: RequestConfig & DescribeInstanceStatusRequest,
  ): Promise<DescribeInstanceStatusResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStatusOk';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstanceStatus(params);
        if (resp?.InstanceStatuses?.flatMap(x => x?.InstanceStatus?.Status).every(x => x === "ok")) return resp;
      } catch (err) {
        if (!["InvalidInstanceID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceStopped(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceStopped';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
      if (field.every(x => x === "stopped")) return resp;
      if (field.some(x => x === "pending")) throw new Error(errMessage);
      if (field.some(x => x === "terminated")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceTerminated(
    params: RequestConfig & DescribeInstancesRequest,
  ): Promise<DescribeInstancesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceTerminated';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstances(params);
      const field = resp?.Reservations?.flatMap(x => x?.Instances)?.flatMap(x => x?.State?.Name);
      if (field.every(x => x === "terminated")) return resp;
      if (field.some(x => x === "pending")) throw new Error(errMessage);
      if (field.some(x => x === "stopping")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 6 times, 5 seconds apart (about 1 minutes max wait time). */
  async waitForKeyPairExists(
    params: RequestConfig & DescribeKeyPairsRequest,
  ): Promise<DescribeKeyPairsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state KeyPairExists';
    for (let i = 0; i < 6; i++) {
      try {
        const resp = await this.describeKeyPairs(params);
        if ((resp?.KeyPairs?.flatMap(x => x?.KeyName) || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidKeyPair.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForNatGatewayAvailable(
    params: RequestConfig & DescribeNatGatewaysRequest,
  ): Promise<DescribeNatGatewaysResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NatGatewayAvailable';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeNatGateways(params);
        const field = resp?.NatGateways?.flatMap(x => x?.State);
        if (field.every(x => x === "available")) return resp;
        if (field.some(x => x === "failed")) throw new Error(errMessage);
        if (field.some(x => x === "deleting")) throw new Error(errMessage);
        if (field.some(x => x === "deleted")) throw new Error(errMessage);
      } catch (err) {
        if (!["NatGatewayNotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 10 times, 20 seconds apart (about 4 minutes max wait time). */
  async waitForNetworkInterfaceAvailable(
    params: RequestConfig & DescribeNetworkInterfacesRequest,
  ): Promise<DescribeNetworkInterfacesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NetworkInterfaceAvailable';
    for (let i = 0; i < 10; i++) {
      try {
        const resp = await this.describeNetworkInterfaces(params);
        if (resp?.NetworkInterfaces?.flatMap(x => x?.Status).every(x => x === "available")) return resp;
      } catch (err) {
        if (["InvalidNetworkInterfaceID.NotFound"].includes(err.code)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForPasswordDataAvailable(
    params: RequestConfig & GetPasswordDataRequest,
  ): Promise<GetPasswordDataResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state PasswordDataAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.getPasswordData(params);
      if ((resp?.PasswordData || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSnapshotCompleted(
    params: RequestConfig & DescribeSnapshotsRequest,
  ): Promise<DescribeSnapshotsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SnapshotCompleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeSnapshots(params);
      if (resp?.Snapshots?.flatMap(x => x?.State).every(x => x === "completed")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 6 times, 5 seconds apart (about 1 minutes max wait time). */
  async waitForSecurityGroupExists(
    params: RequestConfig & DescribeSecurityGroupsRequest,
  ): Promise<DescribeSecurityGroupsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SecurityGroupExists';
    for (let i = 0; i < 6; i++) {
      try {
        const resp = await this.describeSecurityGroups(params);
        if ((resp?.SecurityGroups?.flatMap(x => x?.GroupId) || '').length > 0) return resp;
      } catch (err) {
        if (!["InvalidGroupNotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSpotInstanceRequestFulfilled(
    params: RequestConfig & DescribeSpotInstanceRequestsRequest,
  ): Promise<DescribeSpotInstanceRequestsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SpotInstanceRequestFulfilled';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeSpotInstanceRequests(params);
        const field = resp?.SpotInstanceRequests?.flatMap(x => x?.Status?.Code);
        if (field.every(x => x === "fulfilled")) return resp;
        if (field.every(x => x === "request-canceled-and-instance-running")) return resp;
        if (field.some(x => x === "schedule-expired")) throw new Error(errMessage);
        if (field.some(x => x === "canceled-before-fulfillment")) throw new Error(errMessage);
        if (field.some(x => x === "bad-parameters")) throw new Error(errMessage);
        if (field.some(x => x === "system-error")) throw new Error(errMessage);
      } catch (err) {
        if (!["InvalidSpotInstanceRequestID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSubnetAvailable(
    params: RequestConfig & DescribeSubnetsRequest,
  ): Promise<DescribeSubnetsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SubnetAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeSubnets(params);
      if (resp?.Subnets?.flatMap(x => x?.State).every(x => x === "available")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForSystemStatusOk(
    params: RequestConfig & DescribeInstanceStatusRequest,
  ): Promise<DescribeInstanceStatusResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SystemStatusOk';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstanceStatus(params);
      if (resp?.InstanceStatuses?.flatMap(x => x?.SystemStatus?.Status).every(x => x === "ok")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeAvailable(
    params: RequestConfig & DescribeVolumesRequest,
  ): Promise<DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVolumes(params);
      const field = resp?.Volumes?.flatMap(x => x?.State);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeDeleted(
    params: RequestConfig & DescribeVolumesRequest,
  ): Promise<Error | DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVolumes(params);
        if (resp?.Volumes?.flatMap(x => x?.State).every(x => x === "deleted")) return resp;
      } catch (err) {
        if (["InvalidVolume.NotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVolumeInUse(
    params: RequestConfig & DescribeVolumesRequest,
  ): Promise<DescribeVolumesResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VolumeInUse';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVolumes(params);
      const field = resp?.Volumes?.flatMap(x => x?.State);
      if (field.every(x => x === "in-use")) return resp;
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcAvailable(
    params: RequestConfig & DescribeVpcsRequest,
  ): Promise<DescribeVpcsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpcs(params);
      if (resp?.Vpcs?.flatMap(x => x?.State).every(x => x === "available")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 5 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForVpcExists(
    params: RequestConfig & DescribeVpcsRequest,
  ): Promise<DescribeVpcsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcExists';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeVpcs(params);
        return resp; // for status 200
      } catch (err) {
        if (!["InvalidVpcID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpnConnectionAvailable(
    params: RequestConfig & DescribeVpnConnectionsRequest,
  ): Promise<DescribeVpnConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpnConnectionAvailable';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpnConnections(params);
      const field = resp?.VpnConnections?.flatMap(x => x?.State);
      if (field.every(x => x === "available")) return resp;
      if (field.some(x => x === "deleting")) throw new Error(errMessage);
      if (field.some(x => x === "deleted")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpnConnectionDeleted(
    params: RequestConfig & DescribeVpnConnectionsRequest,
  ): Promise<DescribeVpnConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpnConnectionDeleted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeVpnConnections(params);
      const field = resp?.VpnConnections?.flatMap(x => x?.State);
      if (field.every(x => x === "deleted")) return resp;
      if (field.some(x => x === "pending")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcPeeringConnectionExists(
    params: RequestConfig & DescribeVpcPeeringConnectionsRequest,
  ): Promise<DescribeVpcPeeringConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcPeeringConnectionExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVpcPeeringConnections(params);
        return resp; // for status 200
      } catch (err) {
        if (!["InvalidVpcPeeringConnectionID.NotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForVpcPeeringConnectionDeleted(
    params: RequestConfig & DescribeVpcPeeringConnectionsRequest,
  ): Promise<Error | DescribeVpcPeeringConnectionsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state VpcPeeringConnectionDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeVpcPeeringConnections(params);
        if (resp?.VpcPeeringConnections?.flatMap(x => x?.Status?.Code).every(x => x === "deleted")) return resp;
      } catch (err) {
        if (["InvalidVpcPeeringConnectionID.NotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 15 times, 60 seconds apart (about 15 minutes max wait time). */
  async waitForConsoleOutputAvailable(
    params: RequestConfig & GetConsoleOutputRequest,
  ): Promise<GetConsoleOutputResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ConsoleOutputAvailable';
    for (let i = 0; i < 15; i++) {
      const resp = await this.getConsoleOutput(params);
      if ((resp?.Output || '').length > 0) return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AcceptReservedInstancesExchangeQuoteRequest {
  DryRun?: boolean | null;
  ReservedInstanceIds: string[];
  TargetConfigurations?: TargetConfigurationRequest[] | null;
}

// refs: 1 - tags: named, input
export interface AcceptTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AcceptTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AcceptVpcEndpointConnectionsRequest {
  DryRun?: boolean | null;
  ServiceId: string;
  VpcEndpointIds: string[];
}

// refs: 1 - tags: named, input
export interface AcceptVpcPeeringConnectionRequest {
  DryRun?: boolean | null;
  VpcPeeringConnectionId?: string | null;
}

// refs: 1 - tags: named, input
export interface AdvertiseByoipCidrRequest {
  Cidr: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AllocateAddressRequest {
  Domain?: DomainType | null;
  Address?: string | null;
  PublicIpv4Pool?: string | null;
  NetworkBorderGroup?: string | null;
  CustomerOwnedIpv4Pool?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AllocateHostsRequest {
  AutoPlacement?: AutoPlacement | null;
  AvailabilityZone: string;
  ClientToken?: string | null;
  InstanceType?: string | null;
  InstanceFamily?: string | null;
  Quantity: number;
  TagSpecifications?: TagSpecification[] | null;
  HostRecovery?: HostRecovery | null;
}

// refs: 1 - tags: named, input
export interface ApplySecurityGroupsToClientVpnTargetNetworkRequest {
  ClientVpnEndpointId: string;
  VpcId: string;
  SecurityGroupIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssignIpv6AddressesRequest {
  Ipv6AddressCount?: number | null;
  Ipv6Addresses?: string[] | null;
  NetworkInterfaceId: string;
}

// refs: 1 - tags: named, input
export interface AssignPrivateIpAddressesRequest {
  AllowReassignment?: boolean | null;
  NetworkInterfaceId: string;
  PrivateIpAddresses?: string[] | null;
  SecondaryPrivateIpAddressCount?: number | null;
}

// refs: 1 - tags: named, input
export interface AssociateAddressRequest {
  AllocationId?: string | null;
  InstanceId?: string | null;
  PublicIp?: string | null;
  AllowReassociation?: boolean | null;
  DryRun?: boolean | null;
  NetworkInterfaceId?: string | null;
  PrivateIpAddress?: string | null;
}

// refs: 1 - tags: named, input
export interface AssociateClientVpnTargetNetworkRequest {
  ClientVpnEndpointId: string;
  SubnetId: string;
  ClientToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssociateDhcpOptionsRequest {
  DhcpOptionsId: string;
  VpcId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssociateIamInstanceProfileRequest {
  IamInstanceProfile: IamInstanceProfileSpecification;
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface AssociateRouteTableRequest {
  DryRun?: boolean | null;
  RouteTableId: string;
  SubnetId?: string | null;
  GatewayId?: string | null;
}

// refs: 1 - tags: named, input
export interface AssociateSubnetCidrBlockRequest {
  Ipv6CidrBlock: string;
  SubnetId: string;
}

// refs: 1 - tags: named, input
export interface AssociateTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId?: string | null;
  TransitGatewayAttachmentId?: string | null;
  SubnetIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssociateTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AssociateVpcCidrBlockRequest {
  AmazonProvidedIpv6CidrBlock?: boolean | null;
  CidrBlock?: string | null;
  VpcId: string;
  Ipv6CidrBlockNetworkBorderGroup?: string | null;
  Ipv6Pool?: string | null;
  Ipv6CidrBlock?: string | null;
}

// refs: 1 - tags: named, input
export interface AttachClassicLinkVpcRequest {
  DryRun?: boolean | null;
  Groups: string[];
  InstanceId: string;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface AttachInternetGatewayRequest {
  DryRun?: boolean | null;
  InternetGatewayId: string;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface AttachNetworkInterfaceRequest {
  DeviceIndex: number;
  DryRun?: boolean | null;
  InstanceId: string;
  NetworkInterfaceId: string;
}

// refs: 1 - tags: named, input
export interface AttachVolumeRequest {
  Device: string;
  InstanceId: string;
  VolumeId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AttachVpnGatewayRequest {
  VpcId: string;
  VpnGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AuthorizeClientVpnIngressRequest {
  ClientVpnEndpointId: string;
  TargetNetworkCidr: string;
  AccessGroupId?: string | null;
  AuthorizeAllGroups?: boolean | null;
  Description?: string | null;
  ClientToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface AuthorizeSecurityGroupEgressRequest {
  DryRun?: boolean | null;
  GroupId: string;
  IpPermissions?: IpPermission[] | null;
  CidrIp?: string | null;
  FromPort?: number | null;
  IpProtocol?: string | null;
  ToPort?: number | null;
  SourceSecurityGroupName?: string | null;
  SourceSecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface AuthorizeSecurityGroupIngressRequest {
  CidrIp?: string | null;
  FromPort?: number | null;
  GroupId?: string | null;
  GroupName?: string | null;
  IpPermissions?: IpPermission[] | null;
  IpProtocol?: string | null;
  SourceSecurityGroupName?: string | null;
  SourceSecurityGroupOwnerId?: string | null;
  ToPort?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface BundleInstanceRequest {
  InstanceId: string;
  Storage: Storage;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CancelBundleTaskRequest {
  BundleId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CancelCapacityReservationRequest {
  CapacityReservationId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CancelConversionRequest {
  ConversionTaskId: string;
  DryRun?: boolean | null;
  ReasonMessage?: string | null;
}

// refs: 1 - tags: named, input
export interface CancelExportTaskRequest {
  ExportTaskId: string;
}

// refs: 1 - tags: named, input
export interface CancelImportTaskRequest {
  CancelReason?: string | null;
  DryRun?: boolean | null;
  ImportTaskId?: string | null;
}

// refs: 1 - tags: named, input
export interface CancelReservedInstancesListingRequest {
  ReservedInstancesListingId: string;
}

// refs: 1 - tags: named, input
export interface CancelSpotFleetRequestsRequest {
  DryRun?: boolean | null;
  SpotFleetRequestIds: string[];
  TerminateInstances: boolean;
}

// refs: 1 - tags: named, input
export interface CancelSpotInstanceRequestsRequest {
  DryRun?: boolean | null;
  SpotInstanceRequestIds: string[];
}

// refs: 1 - tags: named, input
export interface ConfirmProductInstanceRequest {
  InstanceId: string;
  ProductCode: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CopyFpgaImageRequest {
  DryRun?: boolean | null;
  SourceFpgaImageId: string;
  Description?: string | null;
  Name?: string | null;
  SourceRegion: string;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CopyImageRequest {
  ClientToken?: string | null;
  Description?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  Name: string;
  SourceImageId: string;
  SourceRegion: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CopySnapshotRequest {
  Description?: string | null;
  DestinationRegion?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  PresignedUrl?: string | null;
  SourceRegion: string;
  SourceSnapshotId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateCapacityReservationRequest {
  ClientToken?: string | null;
  InstanceType: string;
  InstancePlatform: CapacityReservationInstancePlatform;
  AvailabilityZone?: string | null;
  AvailabilityZoneId?: string | null;
  Tenancy?: CapacityReservationTenancy | null;
  InstanceCount: number;
  EbsOptimized?: boolean | null;
  EphemeralStorage?: boolean | null;
  EndDate?: Date | number | null;
  EndDateType?: EndDateType | null;
  InstanceMatchCriteria?: InstanceMatchCriteria | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateCarrierGatewayRequest {
  VpcId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateClientVpnEndpointRequest {
  ClientCidrBlock: string;
  ServerCertificateArn: string;
  AuthenticationOptions: ClientVpnAuthenticationRequest[];
  ConnectionLogOptions: ConnectionLogOptions;
  DnsServers?: string[] | null;
  TransportProtocol?: TransportProtocol | null;
  VpnPort?: number | null;
  Description?: string | null;
  SplitTunnel?: boolean | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  SecurityGroupIds?: string[] | null;
  VpcId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateClientVpnRouteRequest {
  ClientVpnEndpointId: string;
  DestinationCidrBlock: string;
  TargetVpcSubnetId: string;
  Description?: string | null;
  ClientToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateCustomerGatewayRequest {
  BgpAsn: number;
  PublicIp?: string | null;
  CertificateArn?: string | null;
  Type: GatewayType;
  TagSpecifications?: TagSpecification[] | null;
  DeviceName?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDefaultSubnetRequest {
  AvailabilityZone: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDefaultVpcRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDhcpOptionsRequest {
  DhcpConfigurations: NewDhcpConfiguration[];
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateEgressOnlyInternetGatewayRequest {
  ClientToken?: string | null;
  DryRun?: boolean | null;
  VpcId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFleetRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  SpotOptions?: SpotOptionsRequest | null;
  OnDemandOptions?: OnDemandOptionsRequest | null;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy | null;
  LaunchTemplateConfigs: FleetLaunchTemplateConfigRequest[];
  TargetCapacitySpecification: TargetCapacitySpecificationRequest;
  TerminateInstancesWithExpiration?: boolean | null;
  Type?: FleetType | null;
  ValidFrom?: Date | number | null;
  ValidUntil?: Date | number | null;
  ReplaceUnhealthyInstances?: boolean | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFlowLogsRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  DeliverLogsPermissionArn?: string | null;
  LogGroupName?: string | null;
  ResourceIds: string[];
  ResourceType: FlowLogsResourceType;
  TrafficType: TrafficType;
  LogDestinationType?: LogDestinationType | null;
  LogDestination?: string | null;
  LogFormat?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  MaxAggregationInterval?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateFpgaImageRequest {
  DryRun?: boolean | null;
  InputStorageLocation: StorageLocation;
  LogsStorageLocation?: StorageLocation | null;
  Description?: string | null;
  Name?: string | null;
  ClientToken?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateImageRequest {
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  Description?: string | null;
  DryRun?: boolean | null;
  InstanceId: string;
  Name: string;
  NoReboot?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateInstanceExportTaskRequest {
  Description?: string | null;
  ExportToS3Task?: ExportToS3TaskSpecification | null;
  InstanceId: string;
  TargetEnvironment?: ExportEnvironment | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateInternetGatewayRequest {
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateKeyPairRequest {
  KeyName: string;
  DryRun?: boolean | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateLaunchTemplateRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  LaunchTemplateName: string;
  VersionDescription?: string | null;
  LaunchTemplateData: RequestLaunchTemplateData;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateLaunchTemplateVersionRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  SourceVersion?: string | null;
  VersionDescription?: string | null;
  LaunchTemplateData: RequestLaunchTemplateData;
}

// refs: 1 - tags: named, input
export interface CreateLocalGatewayRouteRequest {
  DestinationCidrBlock: string;
  LocalGatewayRouteTableId: string;
  LocalGatewayVirtualInterfaceGroupId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateLocalGatewayRouteTableVpcAssociationRequest {
  LocalGatewayRouteTableId: string;
  VpcId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateManagedPrefixListRequest {
  DryRun?: boolean | null;
  PrefixListName: string;
  Entries?: AddPrefixListEntry[] | null;
  MaxEntries: number;
  TagSpecifications?: TagSpecification[] | null;
  AddressFamily: string;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateNatGatewayRequest {
  AllocationId: string;
  ClientToken?: string | null;
  DryRun?: boolean | null;
  SubnetId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateNetworkAclRequest {
  DryRun?: boolean | null;
  VpcId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateNetworkAclEntryRequest {
  CidrBlock?: string | null;
  DryRun?: boolean | null;
  Egress: boolean;
  IcmpTypeCode?: IcmpTypeCode | null;
  Ipv6CidrBlock?: string | null;
  NetworkAclId: string;
  PortRange?: PortRange | null;
  Protocol: string;
  RuleAction: RuleAction;
  RuleNumber: number;
}

// refs: 1 - tags: named, input
export interface CreateNetworkInterfaceRequest {
  Description?: string | null;
  DryRun?: boolean | null;
  Groups?: string[] | null;
  Ipv6AddressCount?: number | null;
  Ipv6Addresses?: InstanceIpv6Address[] | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses?: PrivateIpAddressSpecification[] | null;
  SecondaryPrivateIpAddressCount?: number | null;
  InterfaceType?: NetworkInterfaceCreationType | null;
  SubnetId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateNetworkInterfacePermissionRequest {
  NetworkInterfaceId: string;
  AwsAccountId?: string | null;
  AwsService?: string | null;
  Permission: InterfacePermissionType;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreatePlacementGroupRequest {
  DryRun?: boolean | null;
  GroupName?: string | null;
  Strategy?: PlacementStrategy | null;
  PartitionCount?: number | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateReservedInstancesListingRequest {
  ClientToken: string;
  InstanceCount: number;
  PriceSchedules: PriceScheduleSpecification[];
  ReservedInstancesId: string;
}

// refs: 1 - tags: named, input
export interface CreateRouteRequest {
  DestinationCidrBlock?: string | null;
  DestinationIpv6CidrBlock?: string | null;
  DestinationPrefixListId?: string | null;
  DryRun?: boolean | null;
  EgressOnlyInternetGatewayId?: string | null;
  GatewayId?: string | null;
  InstanceId?: string | null;
  NatGatewayId?: string | null;
  TransitGatewayId?: string | null;
  LocalGatewayId?: string | null;
  CarrierGatewayId?: string | null;
  NetworkInterfaceId?: string | null;
  RouteTableId: string;
  VpcPeeringConnectionId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateRouteTableRequest {
  DryRun?: boolean | null;
  VpcId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateSecurityGroupRequest {
  Description: string;
  GroupName: string;
  VpcId?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotRequest {
  Description?: string | null;
  VolumeId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateSnapshotsRequest {
  Description?: string | null;
  InstanceSpecification: InstanceSpecification;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
  CopyTagsFromSource?: CopyTagsFromSource | null;
}

// refs: 1 - tags: named, input
export interface CreateSpotDatafeedSubscriptionRequest {
  Bucket: string;
  DryRun?: boolean | null;
  Prefix?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateSubnetRequest {
  TagSpecifications?: TagSpecification[] | null;
  AvailabilityZone?: string | null;
  AvailabilityZoneId?: string | null;
  CidrBlock: string;
  Ipv6CidrBlock?: string | null;
  OutpostArn?: string | null;
  VpcId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTagsRequest {
  DryRun?: boolean | null;
  Resources: string[];
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface CreateTrafficMirrorFilterRequest {
  Description?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterId: string;
  TrafficDirection: TrafficDirection;
  RuleNumber: number;
  RuleAction: TrafficMirrorRuleAction;
  DestinationPortRange?: TrafficMirrorPortRangeRequest | null;
  SourcePortRange?: TrafficMirrorPortRangeRequest | null;
  Protocol?: number | null;
  DestinationCidrBlock: string;
  SourceCidrBlock: string;
  Description?: string | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTrafficMirrorSessionRequest {
  NetworkInterfaceId: string;
  TrafficMirrorTargetId: string;
  TrafficMirrorFilterId: string;
  PacketLength?: number | null;
  SessionNumber: number;
  VirtualNetworkId?: number | null;
  Description?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTrafficMirrorTargetRequest {
  NetworkInterfaceId?: string | null;
  NetworkLoadBalancerArn?: string | null;
  Description?: string | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayRequest {
  Description?: string | null;
  Options?: TransitGatewayRequestOptions | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayMulticastDomainRequest {
  TransitGatewayId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayPeeringAttachmentRequest {
  TransitGatewayId: string;
  PeerTransitGatewayId: string;
  PeerAccountId: string;
  PeerRegion: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId: string;
  PrefixListId: string;
  TransitGatewayAttachmentId?: string | null;
  Blackhole?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayRouteRequest {
  DestinationCidrBlock: string;
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId?: string | null;
  Blackhole?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayRouteTableRequest {
  TransitGatewayId: string;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateTransitGatewayVpcAttachmentRequest {
  TransitGatewayId: string;
  VpcId: string;
  SubnetIds: string[];
  Options?: CreateTransitGatewayVpcAttachmentRequestOptions | null;
  TagSpecifications?: TagSpecification[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateVolumeRequest {
  AvailabilityZone: string;
  Encrypted?: boolean | null;
  Iops?: number | null;
  KmsKeyId?: string | null;
  OutpostArn?: string | null;
  Size?: number | null;
  SnapshotId?: string | null;
  VolumeType?: VolumeType | null;
  DryRun?: boolean | null;
  TagSpecifications?: TagSpecification[] | null;
  MultiAttachEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcRequest {
  CidrBlock: string;
  AmazonProvidedIpv6CidrBlock?: boolean | null;
  Ipv6Pool?: string | null;
  Ipv6CidrBlock?: string | null;
  DryRun?: boolean | null;
  InstanceTenancy?: Tenancy | null;
  Ipv6CidrBlockNetworkBorderGroup?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcEndpointRequest {
  DryRun?: boolean | null;
  VpcEndpointType?: VpcEndpointType | null;
  VpcId: string;
  ServiceName: string;
  PolicyDocument?: string | null;
  RouteTableIds?: string[] | null;
  SubnetIds?: string[] | null;
  SecurityGroupIds?: string[] | null;
  ClientToken?: string | null;
  PrivateDnsEnabled?: boolean | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcEndpointConnectionNotificationRequest {
  DryRun?: boolean | null;
  ServiceId?: string | null;
  VpcEndpointId?: string | null;
  ConnectionNotificationArn: string;
  ConnectionEvents: string[];
  ClientToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcEndpointServiceConfigurationRequest {
  DryRun?: boolean | null;
  AcceptanceRequired?: boolean | null;
  PrivateDnsName?: string | null;
  NetworkLoadBalancerArns: string[];
  ClientToken?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpcPeeringConnectionRequest {
  DryRun?: boolean | null;
  PeerOwnerId?: string | null;
  PeerVpcId?: string | null;
  VpcId?: string | null;
  PeerRegion?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpnConnectionRequest {
  CustomerGatewayId: string;
  Type: string;
  VpnGatewayId?: string | null;
  TransitGatewayId?: string | null;
  DryRun?: boolean | null;
  Options?: VpnConnectionOptionsSpecification | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface CreateVpnConnectionRouteRequest {
  DestinationCidrBlock: string;
  VpnConnectionId: string;
}

// refs: 1 - tags: named, input
export interface CreateVpnGatewayRequest {
  AvailabilityZone?: string | null;
  Type: GatewayType;
  TagSpecifications?: TagSpecification[] | null;
  AmazonSideAsn?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteCarrierGatewayRequest {
  CarrierGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteClientVpnEndpointRequest {
  ClientVpnEndpointId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteClientVpnRouteRequest {
  ClientVpnEndpointId: string;
  TargetVpcSubnetId?: string | null;
  DestinationCidrBlock: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteCustomerGatewayRequest {
  CustomerGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteDhcpOptionsRequest {
  DhcpOptionsId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteEgressOnlyInternetGatewayRequest {
  DryRun?: boolean | null;
  EgressOnlyInternetGatewayId: string;
}

// refs: 1 - tags: named, input
export interface DeleteFleetsRequest {
  DryRun?: boolean | null;
  FleetIds: string[];
  TerminateInstances: boolean;
}

// refs: 1 - tags: named, input
export interface DeleteFlowLogsRequest {
  DryRun?: boolean | null;
  FlowLogIds: string[];
}

// refs: 1 - tags: named, input
export interface DeleteFpgaImageRequest {
  DryRun?: boolean | null;
  FpgaImageId: string;
}

// refs: 1 - tags: named, input
export interface DeleteInternetGatewayRequest {
  DryRun?: boolean | null;
  InternetGatewayId: string;
}

// refs: 1 - tags: named, input
export interface DeleteKeyPairRequest {
  KeyName?: string | null;
  KeyPairId?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteLaunchTemplateRequest {
  DryRun?: boolean | null;
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteLaunchTemplateVersionsRequest {
  DryRun?: boolean | null;
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Versions: string[];
}

// refs: 1 - tags: named, input
export interface DeleteLocalGatewayRouteRequest {
  DestinationCidrBlock: string;
  LocalGatewayRouteTableId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteLocalGatewayRouteTableVpcAssociationRequest {
  LocalGatewayRouteTableVpcAssociationId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteManagedPrefixListRequest {
  DryRun?: boolean | null;
  PrefixListId: string;
}

// refs: 1 - tags: named, input
export interface DeleteNatGatewayRequest {
  DryRun?: boolean | null;
  NatGatewayId: string;
}

// refs: 1 - tags: named, input
export interface DeleteNetworkAclRequest {
  DryRun?: boolean | null;
  NetworkAclId: string;
}

// refs: 1 - tags: named, input
export interface DeleteNetworkAclEntryRequest {
  DryRun?: boolean | null;
  Egress: boolean;
  NetworkAclId: string;
  RuleNumber: number;
}

// refs: 1 - tags: named, input
export interface DeleteNetworkInterfaceRequest {
  DryRun?: boolean | null;
  NetworkInterfaceId: string;
}

// refs: 1 - tags: named, input
export interface DeleteNetworkInterfacePermissionRequest {
  NetworkInterfacePermissionId: string;
  Force?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeletePlacementGroupRequest {
  DryRun?: boolean | null;
  GroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteQueuedReservedInstancesRequest {
  DryRun?: boolean | null;
  ReservedInstancesIds: string[];
}

// refs: 1 - tags: named, input
export interface DeleteRouteRequest {
  DestinationCidrBlock?: string | null;
  DestinationIpv6CidrBlock?: string | null;
  DestinationPrefixListId?: string | null;
  DryRun?: boolean | null;
  RouteTableId: string;
}

// refs: 1 - tags: named, input
export interface DeleteRouteTableRequest {
  DryRun?: boolean | null;
  RouteTableId: string;
}

// refs: 1 - tags: named, input
export interface DeleteSecurityGroupRequest {
  GroupId?: string | null;
  GroupName?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteSnapshotRequest {
  SnapshotId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteSpotDatafeedSubscriptionRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteSubnetRequest {
  SubnetId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTagsRequest {
  DryRun?: boolean | null;
  Resources: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficMirrorFilterRequest {
  TrafficMirrorFilterId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterRuleId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficMirrorSessionRequest {
  TrafficMirrorSessionId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficMirrorTargetRequest {
  TrafficMirrorTargetId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayRequest {
  TransitGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId: string;
  PrefixListId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayRouteRequest {
  TransitGatewayRouteTableId: string;
  DestinationCidrBlock: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteVolumeRequest {
  VolumeId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteVpcRequest {
  VpcId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteVpcEndpointConnectionNotificationsRequest {
  DryRun?: boolean | null;
  ConnectionNotificationIds: string[];
}

// refs: 1 - tags: named, input
export interface DeleteVpcEndpointServiceConfigurationsRequest {
  DryRun?: boolean | null;
  ServiceIds: string[];
}

// refs: 1 - tags: named, input
export interface DeleteVpcEndpointsRequest {
  DryRun?: boolean | null;
  VpcEndpointIds: string[];
}

// refs: 1 - tags: named, input
export interface DeleteVpcPeeringConnectionRequest {
  DryRun?: boolean | null;
  VpcPeeringConnectionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVpnConnectionRequest {
  VpnConnectionId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteVpnConnectionRouteRequest {
  DestinationCidrBlock: string;
  VpnConnectionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVpnGatewayRequest {
  VpnGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeprovisionByoipCidrRequest {
  Cidr: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterImageRequest {
  ImageId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterInstanceEventNotificationAttributesRequest {
  DryRun?: boolean | null;
  InstanceTagAttribute?: DeregisterInstanceTagAttributeRequest | null;
}

// refs: 1 - tags: named, input
export interface DeregisterTransitGatewayMulticastGroupMembersRequest {
  TransitGatewayMulticastDomainId?: string | null;
  GroupIpAddress?: string | null;
  NetworkInterfaceIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeregisterTransitGatewayMulticastGroupSourcesRequest {
  TransitGatewayMulticastDomainId?: string | null;
  GroupIpAddress?: string | null;
  NetworkInterfaceIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeAccountAttributesRequest {
  AttributeNames?: AccountAttributeName[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeAddressesRequest {
  Filters?: Filter[] | null;
  PublicIps?: string[] | null;
  AllocationIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeAggregateIdFormatRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeAvailabilityZonesRequest {
  Filters?: Filter[] | null;
  ZoneNames?: string[] | null;
  ZoneIds?: string[] | null;
  AllAvailabilityZones?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeBundleTasksRequest {
  BundleIds?: string[] | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeByoipCidrsRequest {
  DryRun?: boolean | null;
  MaxResults: number;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCapacityReservationsRequest {
  CapacityReservationIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeCarrierGatewaysRequest {
  CarrierGatewayIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeClassicLinkInstancesRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  InstanceIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeClientVpnAuthorizationRulesRequest {
  ClientVpnEndpointId: string;
  DryRun?: boolean | null;
  NextToken?: string | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeClientVpnConnectionsRequest {
  ClientVpnEndpointId: string;
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeClientVpnEndpointsRequest {
  ClientVpnEndpointIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeClientVpnRoutesRequest {
  ClientVpnEndpointId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeClientVpnTargetNetworksRequest {
  ClientVpnEndpointId: string;
  AssociationIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeCoipPoolsRequest {
  PoolIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeConversionTasksRequest {
  ConversionTaskIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeCustomerGatewaysRequest {
  CustomerGatewayIds?: string[] | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDhcpOptionsRequest {
  DhcpOptionsIds?: string[] | null;
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeEgressOnlyInternetGatewaysRequest {
  DryRun?: boolean | null;
  EgressOnlyInternetGatewayIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeElasticGpusRequest {
  ElasticGpuIds?: string[] | null;
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeExportImageTasksRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  ExportImageTaskIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeExportTasksRequest {
  ExportTaskIds?: string[] | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeFastSnapshotRestoresRequest {
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetHistoryRequest {
  DryRun?: boolean | null;
  EventType?: FleetEventType | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  FleetId: string;
  StartTime: Date | number;
}

// refs: 1 - tags: named, input
export interface DescribeFleetInstancesRequest {
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  FleetId: string;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeFleetsRequest {
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  FleetIds?: string[] | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeFlowLogsRequest {
  DryRun?: boolean | null;
  Filter?: Filter[] | null;
  FlowLogIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeFpgaImageAttributeRequest {
  DryRun?: boolean | null;
  FpgaImageId: string;
  Attribute: FpgaImageAttributeName;
}

// refs: 1 - tags: named, input
export interface DescribeFpgaImagesRequest {
  DryRun?: boolean | null;
  FpgaImageIds?: string[] | null;
  Owners?: string[] | null;
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeHostReservationOfferingsRequest {
  Filter?: Filter[] | null;
  MaxDuration?: number | null;
  MaxResults?: number | null;
  MinDuration?: number | null;
  NextToken?: string | null;
  OfferingId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeHostReservationsRequest {
  Filter?: Filter[] | null;
  HostReservationIdSet?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeHostsRequest {
  Filter?: Filter[] | null;
  HostIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeIamInstanceProfileAssociationsRequest {
  AssociationIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeIdFormatRequest {
  Resource?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeIdentityIdFormatRequest {
  PrincipalArn: string;
  Resource?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeImageAttributeRequest {
  Attribute: ImageAttributeName;
  ImageId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeImagesRequest {
  ExecutableUsers?: string[] | null;
  Filters?: Filter[] | null;
  ImageIds?: string[] | null;
  Owners?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeImportImageTasksRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  ImportTaskIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeImportSnapshotTasksRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  ImportTaskIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceAttributeRequest {
  Attribute: InstanceAttributeName;
  DryRun?: boolean | null;
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceCreditSpecificationsRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  InstanceIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceEventNotificationAttributesRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceStatusRequest {
  Filters?: Filter[] | null;
  InstanceIds?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
  IncludeAllInstances?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceTypeOfferingsRequest {
  DryRun?: boolean | null;
  LocationType?: LocationType | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstanceTypesRequest {
  DryRun?: boolean | null;
  InstanceTypes?: InstanceType[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInstancesRequest {
  Filters?: Filter[] | null;
  InstanceIds?: string[] | null;
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeInternetGatewaysRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  InternetGatewayIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeIpv6PoolsRequest {
  PoolIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeKeyPairsRequest {
  Filters?: Filter[] | null;
  KeyNames?: string[] | null;
  KeyPairIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLaunchTemplateVersionsRequest {
  DryRun?: boolean | null;
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Versions?: string[] | null;
  MinVersion?: string | null;
  MaxVersion?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLaunchTemplatesRequest {
  DryRun?: boolean | null;
  LaunchTemplateIds?: string[] | null;
  LaunchTemplateNames?: string[] | null;
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewayRouteTableVpcAssociationsRequest {
  LocalGatewayRouteTableVpcAssociationIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewayRouteTablesRequest {
  LocalGatewayRouteTableIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewayVirtualInterfaceGroupsRequest {
  LocalGatewayVirtualInterfaceGroupIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewayVirtualInterfacesRequest {
  LocalGatewayVirtualInterfaceIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeLocalGatewaysRequest {
  LocalGatewayIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeManagedPrefixListsRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  PrefixListIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeMovingAddressesRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  PublicIps?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeNatGatewaysRequest {
  DryRun?: boolean | null;
  Filter?: Filter[] | null;
  MaxResults?: number | null;
  NatGatewayIds?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeNetworkAclsRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  NetworkAclIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeNetworkInterfaceAttributeRequest {
  Attribute?: NetworkInterfaceAttribute | null;
  DryRun?: boolean | null;
  NetworkInterfaceId: string;
}

// refs: 1 - tags: named, input
export interface DescribeNetworkInterfacePermissionsRequest {
  NetworkInterfacePermissionIds?: string[] | null;
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeNetworkInterfacesRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  NetworkInterfaceIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribePlacementGroupsRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  GroupNames?: string[] | null;
  GroupIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribePrefixListsRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  PrefixListIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribePrincipalIdFormatRequest {
  DryRun?: boolean | null;
  Resources?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePublicIpv4PoolsRequest {
  PoolIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeRegionsRequest {
  Filters?: Filter[] | null;
  RegionNames?: string[] | null;
  DryRun?: boolean | null;
  AllRegions?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedInstancesRequest {
  Filters?: Filter[] | null;
  OfferingClass?: OfferingClassType | null;
  ReservedInstancesIds?: string[] | null;
  DryRun?: boolean | null;
  OfferingType?: OfferingTypeValues | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedInstancesListingsRequest {
  Filters?: Filter[] | null;
  ReservedInstancesId?: string | null;
  ReservedInstancesListingId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedInstancesModificationsRequest {
  Filters?: Filter[] | null;
  ReservedInstancesModificationIds?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedInstancesOfferingsRequest {
  AvailabilityZone?: string | null;
  Filters?: Filter[] | null;
  IncludeMarketplace?: boolean | null;
  InstanceType?: InstanceType | null;
  MaxDuration?: number | null;
  MaxInstanceCount?: number | null;
  MinDuration?: number | null;
  OfferingClass?: OfferingClassType | null;
  ProductDescription?: RIProductDescription | null;
  ReservedInstancesOfferingIds?: string[] | null;
  DryRun?: boolean | null;
  InstanceTenancy?: Tenancy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  OfferingType?: OfferingTypeValues | null;
}

// refs: 1 - tags: named, input
export interface DescribeRouteTablesRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  RouteTableIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeScheduledInstanceAvailabilityRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  FirstSlotStartTimeRange: SlotDateTimeRangeRequest;
  MaxResults?: number | null;
  MaxSlotDurationInHours?: number | null;
  MinSlotDurationInHours?: number | null;
  NextToken?: string | null;
  Recurrence: ScheduledInstanceRecurrenceRequest;
}

// refs: 1 - tags: named, input
export interface DescribeScheduledInstancesRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  ScheduledInstanceIds?: string[] | null;
  SlotStartTimeRange?: SlotStartTimeRangeRequest | null;
}

// refs: 1 - tags: named, input
export interface DescribeSecurityGroupReferencesRequest {
  DryRun?: boolean | null;
  GroupId: string[];
}

// refs: 1 - tags: named, input
export interface DescribeSecurityGroupsRequest {
  Filters?: Filter[] | null;
  GroupIds?: string[] | null;
  GroupNames?: string[] | null;
  DryRun?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotAttributeRequest {
  Attribute: SnapshotAttributeName;
  SnapshotId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSnapshotsRequest {
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  OwnerIds?: string[] | null;
  RestorableByUserIds?: string[] | null;
  SnapshotIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSpotDatafeedSubscriptionRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSpotFleetInstancesRequest {
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  SpotFleetRequestId: string;
}

// refs: 1 - tags: named, input
export interface DescribeSpotFleetRequestHistoryRequest {
  DryRun?: boolean | null;
  EventType?: EventType | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  SpotFleetRequestId: string;
  StartTime: Date | number;
}

// refs: 1 - tags: named, input
export interface DescribeSpotFleetRequestsRequest {
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  SpotFleetRequestIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeSpotInstanceRequestsRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  SpotInstanceRequestIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeSpotPriceHistoryRequest {
  Filters?: Filter[] | null;
  AvailabilityZone?: string | null;
  DryRun?: boolean | null;
  EndTime?: Date | number | null;
  InstanceTypes?: InstanceType[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  ProductDescriptions?: string[] | null;
  StartTime?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface DescribeStaleSecurityGroupsRequest {
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface DescribeSubnetsRequest {
  Filters?: Filter[] | null;
  SubnetIds?: string[] | null;
  DryRun?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTrafficMirrorFiltersRequest {
  TrafficMirrorFilterIds?: string[] | null;
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTrafficMirrorSessionsRequest {
  TrafficMirrorSessionIds?: string[] | null;
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTrafficMirrorTargetsRequest {
  TrafficMirrorTargetIds?: string[] | null;
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewayAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewayMulticastDomainsRequest {
  TransitGatewayMulticastDomainIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewayPeeringAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewayRouteTablesRequest {
  TransitGatewayRouteTableIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewayVpcAttachmentsRequest {
  TransitGatewayAttachmentIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeTransitGatewaysRequest {
  TransitGatewayIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeVolumeAttributeRequest {
  Attribute: VolumeAttributeName;
  VolumeId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeVolumeStatusRequest {
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  VolumeIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeVolumesRequest {
  Filters?: Filter[] | null;
  VolumeIds?: string[] | null;
  DryRun?: boolean | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVolumesModificationsRequest {
  DryRun?: boolean | null;
  VolumeIds?: string[] | null;
  Filters?: Filter[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcAttributeRequest {
  Attribute: VpcAttributeName;
  VpcId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcClassicLinkRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  VpcIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcClassicLinkDnsSupportRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  VpcIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointConnectionNotificationsRequest {
  DryRun?: boolean | null;
  ConnectionNotificationId?: string | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointConnectionsRequest {
  DryRun?: boolean | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointServiceConfigurationsRequest {
  DryRun?: boolean | null;
  ServiceIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointServicePermissionsRequest {
  DryRun?: boolean | null;
  ServiceId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointServicesRequest {
  DryRun?: boolean | null;
  ServiceNames?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcEndpointsRequest {
  DryRun?: boolean | null;
  VpcEndpointIds?: string[] | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcPeeringConnectionsRequest {
  Filters?: Filter[] | null;
  DryRun?: boolean | null;
  VpcPeeringConnectionIds?: string[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpcsRequest {
  Filters?: Filter[] | null;
  VpcIds?: string[] | null;
  DryRun?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpnConnectionsRequest {
  Filters?: Filter[] | null;
  VpnConnectionIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeVpnGatewaysRequest {
  Filters?: Filter[] | null;
  VpnGatewayIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DetachClassicLinkVpcRequest {
  DryRun?: boolean | null;
  InstanceId: string;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface DetachInternetGatewayRequest {
  DryRun?: boolean | null;
  InternetGatewayId: string;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface DetachNetworkInterfaceRequest {
  AttachmentId: string;
  DryRun?: boolean | null;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DetachVolumeRequest {
  Device?: string | null;
  Force?: boolean | null;
  InstanceId?: string | null;
  VolumeId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DetachVpnGatewayRequest {
  VpcId: string;
  VpnGatewayId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableEbsEncryptionByDefaultRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableFastSnapshotRestoresRequest {
  AvailabilityZones: string[];
  SourceSnapshotIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableTransitGatewayRouteTablePropagationRequest {
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableVgwRoutePropagationRequest {
  GatewayId: string;
  RouteTableId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisableVpcClassicLinkRequest {
  DryRun?: boolean | null;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface DisableVpcClassicLinkDnsSupportRequest {
  VpcId?: string | null;
}

// refs: 1 - tags: named, input
export interface DisassociateAddressRequest {
  AssociationId?: string | null;
  PublicIp?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisassociateClientVpnTargetNetworkRequest {
  ClientVpnEndpointId: string;
  AssociationId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisassociateIamInstanceProfileRequest {
  AssociationId: string;
}

// refs: 1 - tags: named, input
export interface DisassociateRouteTableRequest {
  AssociationId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisassociateSubnetCidrBlockRequest {
  AssociationId: string;
}

// refs: 1 - tags: named, input
export interface DisassociateTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId?: string | null;
  TransitGatewayAttachmentId?: string | null;
  SubnetIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisassociateTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DisassociateVpcCidrBlockRequest {
  AssociationId: string;
}

// refs: 1 - tags: named, input
export interface EnableEbsEncryptionByDefaultRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface EnableFastSnapshotRestoresRequest {
  AvailabilityZones: string[];
  SourceSnapshotIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface EnableTransitGatewayRouteTablePropagationRequest {
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface EnableVgwRoutePropagationRequest {
  GatewayId: string;
  RouteTableId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface EnableVolumeIORequest {
  DryRun?: boolean | null;
  VolumeId: string;
}

// refs: 1 - tags: named, input
export interface EnableVpcClassicLinkRequest {
  DryRun?: boolean | null;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface EnableVpcClassicLinkDnsSupportRequest {
  VpcId?: string | null;
}

// refs: 1 - tags: named, input
export interface ExportClientVpnClientCertificateRevocationListRequest {
  ClientVpnEndpointId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ExportClientVpnClientConfigurationRequest {
  ClientVpnEndpointId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ExportImageRequest {
  ClientToken?: string | null;
  Description?: string | null;
  DiskImageFormat: DiskImageFormat;
  DryRun?: boolean | null;
  ImageId: string;
  S3ExportLocation: ExportTaskS3LocationRequest;
  RoleName?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface ExportTransitGatewayRoutesRequest {
  TransitGatewayRouteTableId: string;
  Filters?: Filter[] | null;
  S3Bucket: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetAssociatedIpv6PoolCidrsRequest {
  PoolId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetCapacityReservationUsageRequest {
  CapacityReservationId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetCoipPoolUsageRequest {
  PoolId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetConsoleOutputRequest {
  InstanceId: string;
  DryRun?: boolean | null;
  Latest?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetConsoleScreenshotRequest {
  DryRun?: boolean | null;
  InstanceId: string;
  WakeUp?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetDefaultCreditSpecificationRequest {
  DryRun?: boolean | null;
  InstanceFamily: UnlimitedSupportedInstanceFamily;
}

// refs: 1 - tags: named, input
export interface GetEbsDefaultKmsKeyIdRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetEbsEncryptionByDefaultRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetGroupsForCapacityReservationRequest {
  CapacityReservationId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetHostReservationPurchasePreviewRequest {
  HostIdSet: string[];
  OfferingId: string;
}

// refs: 1 - tags: named, input
export interface GetLaunchTemplateDataRequest {
  DryRun?: boolean | null;
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface GetManagedPrefixListAssociationsRequest {
  DryRun?: boolean | null;
  PrefixListId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetManagedPrefixListEntriesRequest {
  DryRun?: boolean | null;
  PrefixListId: string;
  TargetVersion?: number | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPasswordDataRequest {
  InstanceId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetReservedInstancesExchangeQuoteRequest {
  DryRun?: boolean | null;
  ReservedInstanceIds: string[];
  TargetConfigurations?: TargetConfigurationRequest[] | null;
}

// refs: 1 - tags: named, input
export interface GetTransitGatewayAttachmentPropagationsRequest {
  TransitGatewayAttachmentId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetTransitGatewayMulticastDomainAssociationsRequest {
  TransitGatewayMulticastDomainId?: string | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetTransitGatewayPrefixListReferencesRequest {
  TransitGatewayRouteTableId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetTransitGatewayRouteTableAssociationsRequest {
  TransitGatewayRouteTableId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetTransitGatewayRouteTablePropagationsRequest {
  TransitGatewayRouteTableId: string;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ImportClientVpnClientCertificateRevocationListRequest {
  ClientVpnEndpointId: string;
  CertificateRevocationList: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ImportImageRequest {
  Architecture?: string | null;
  ClientData?: ClientData | null;
  ClientToken?: string | null;
  Description?: string | null;
  DiskContainers?: ImageDiskContainer[] | null;
  DryRun?: boolean | null;
  Encrypted?: boolean | null;
  Hypervisor?: string | null;
  KmsKeyId?: string | null;
  LicenseType?: string | null;
  Platform?: string | null;
  RoleName?: string | null;
  LicenseSpecifications?: ImportImageLicenseConfigurationRequest[] | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface ImportInstanceRequest {
  Description?: string | null;
  DiskImages?: DiskImage[] | null;
  DryRun?: boolean | null;
  LaunchSpecification?: ImportInstanceLaunchSpecification | null;
  Platform: PlatformValues;
}

// refs: 1 - tags: named, input
export interface ImportKeyPairRequest {
  DryRun?: boolean | null;
  KeyName: string;
  PublicKeyMaterial: Uint8Array | string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface ImportSnapshotRequest {
  ClientData?: ClientData | null;
  ClientToken?: string | null;
  Description?: string | null;
  DiskContainer?: SnapshotDiskContainer | null;
  DryRun?: boolean | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  RoleName?: string | null;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface ImportVolumeRequest {
  AvailabilityZone: string;
  Description?: string | null;
  DryRun?: boolean | null;
  Image: DiskImageDetail;
  Volume: VolumeDetail;
}

// refs: 1 - tags: named, input
export interface ModifyAvailabilityZoneGroupRequest {
  GroupName: string;
  OptInStatus: ModifyAvailabilityZoneOptInStatus;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyCapacityReservationRequest {
  CapacityReservationId: string;
  InstanceCount?: number | null;
  EndDate?: Date | number | null;
  EndDateType?: EndDateType | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyClientVpnEndpointRequest {
  ClientVpnEndpointId: string;
  ServerCertificateArn?: string | null;
  ConnectionLogOptions?: ConnectionLogOptions | null;
  DnsServers?: DnsServersOptionsModifyStructure | null;
  VpnPort?: number | null;
  Description?: string | null;
  SplitTunnel?: boolean | null;
  DryRun?: boolean | null;
  SecurityGroupIds?: string[] | null;
  VpcId?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyDefaultCreditSpecificationRequest {
  DryRun?: boolean | null;
  InstanceFamily: UnlimitedSupportedInstanceFamily;
  CpuCredits: string;
}

// refs: 1 - tags: named, input
export interface ModifyEbsDefaultKmsKeyIdRequest {
  KmsKeyId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyFleetRequest {
  DryRun?: boolean | null;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy | null;
  LaunchTemplateConfigs?: FleetLaunchTemplateConfigRequest[] | null;
  FleetId: string;
  TargetCapacitySpecification: TargetCapacitySpecificationRequest;
}

// refs: 1 - tags: named, input
export interface ModifyFpgaImageAttributeRequest {
  DryRun?: boolean | null;
  FpgaImageId: string;
  Attribute?: FpgaImageAttributeName | null;
  OperationType?: OperationType | null;
  UserIds?: string[] | null;
  UserGroups?: string[] | null;
  ProductCodes?: string[] | null;
  LoadPermission?: LoadPermissionModifications | null;
  Description?: string | null;
  Name?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyHostsRequest {
  AutoPlacement?: AutoPlacement | null;
  HostIds: string[];
  HostRecovery?: HostRecovery | null;
  InstanceType?: string | null;
  InstanceFamily?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyIdFormatRequest {
  Resource: string;
  UseLongIds: boolean;
}

// refs: 1 - tags: named, input
export interface ModifyIdentityIdFormatRequest {
  PrincipalArn: string;
  Resource: string;
  UseLongIds: boolean;
}

// refs: 1 - tags: named, input
export interface ModifyImageAttributeRequest {
  Attribute?: string | null;
  Description?: AttributeValue | null;
  ImageId: string;
  LaunchPermission?: LaunchPermissionModifications | null;
  OperationType?: OperationType | null;
  ProductCodes?: string[] | null;
  UserGroups?: string[] | null;
  UserIds?: string[] | null;
  Value?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceAttributeRequest {
  SourceDestCheck?: AttributeBooleanValue | null;
  Attribute?: InstanceAttributeName | null;
  BlockDeviceMappings?: InstanceBlockDeviceMappingSpecification[] | null;
  DisableApiTermination?: AttributeBooleanValue | null;
  DryRun?: boolean | null;
  EbsOptimized?: AttributeBooleanValue | null;
  EnaSupport?: AttributeBooleanValue | null;
  Groups?: string[] | null;
  InstanceId: string;
  InstanceInitiatedShutdownBehavior?: AttributeValue | null;
  InstanceType?: AttributeValue | null;
  Kernel?: AttributeValue | null;
  Ramdisk?: AttributeValue | null;
  SriovNetSupport?: AttributeValue | null;
  UserData?: BlobAttributeValue | null;
  Value?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceCapacityReservationAttributesRequest {
  InstanceId: string;
  CapacityReservationSpecification: CapacityReservationSpecification;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceCreditSpecificationRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  InstanceCreditSpecifications: InstanceCreditSpecificationRequest[];
}

// refs: 1 - tags: named, input
export interface ModifyInstanceEventStartTimeRequest {
  DryRun?: boolean | null;
  InstanceId: string;
  InstanceEventId: string;
  NotBefore: Date | number;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceMetadataOptionsRequest {
  InstanceId: string;
  HttpTokens?: HttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: InstanceMetadataEndpointState | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstancePlacementRequest {
  Affinity?: Affinity | null;
  GroupName?: string | null;
  HostId?: string | null;
  InstanceId: string;
  Tenancy?: HostTenancy | null;
  PartitionNumber?: number | null;
  HostResourceGroupArn?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyLaunchTemplateRequest {
  DryRun?: boolean | null;
  ClientToken?: string | null;
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  DefaultVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyManagedPrefixListRequest {
  DryRun?: boolean | null;
  PrefixListId: string;
  CurrentVersion?: number | null;
  PrefixListName?: string | null;
  AddEntries?: AddPrefixListEntry[] | null;
  RemoveEntries?: RemovePrefixListEntry[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyNetworkInterfaceAttributeRequest {
  Attachment?: NetworkInterfaceAttachmentChanges | null;
  Description?: AttributeValue | null;
  DryRun?: boolean | null;
  Groups?: string[] | null;
  NetworkInterfaceId: string;
  SourceDestCheck?: AttributeBooleanValue | null;
}

// refs: 1 - tags: named, input
export interface ModifyReservedInstancesRequest {
  ReservedInstancesIds: string[];
  ClientToken?: string | null;
  TargetConfigurations: ReservedInstancesConfiguration[];
}

// refs: 1 - tags: named, input
export interface ModifySnapshotAttributeRequest {
  Attribute?: SnapshotAttributeName | null;
  CreateVolumePermission?: CreateVolumePermissionModifications | null;
  GroupNames?: string[] | null;
  OperationType?: OperationType | null;
  SnapshotId: string;
  UserIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifySpotFleetRequestRequest {
  ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy | null;
  LaunchTemplateConfigs?: LaunchTemplateConfig[] | null;
  SpotFleetRequestId: string;
  TargetCapacity?: number | null;
  OnDemandTargetCapacity?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifySubnetAttributeRequest {
  AssignIpv6AddressOnCreation?: AttributeBooleanValue | null;
  MapPublicIpOnLaunch?: AttributeBooleanValue | null;
  SubnetId: string;
  MapCustomerOwnedIpOnLaunch?: AttributeBooleanValue | null;
  CustomerOwnedIpv4Pool?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyTrafficMirrorFilterNetworkServicesRequest {
  TrafficMirrorFilterId: string;
  AddNetworkServices?: TrafficMirrorNetworkService[] | null;
  RemoveNetworkServices?: TrafficMirrorNetworkService[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyTrafficMirrorFilterRuleRequest {
  TrafficMirrorFilterRuleId: string;
  TrafficDirection?: TrafficDirection | null;
  RuleNumber?: number | null;
  RuleAction?: TrafficMirrorRuleAction | null;
  DestinationPortRange?: TrafficMirrorPortRangeRequest | null;
  SourcePortRange?: TrafficMirrorPortRangeRequest | null;
  Protocol?: number | null;
  DestinationCidrBlock?: string | null;
  SourceCidrBlock?: string | null;
  Description?: string | null;
  RemoveFields?: TrafficMirrorFilterRuleField[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyTrafficMirrorSessionRequest {
  TrafficMirrorSessionId: string;
  TrafficMirrorTargetId?: string | null;
  TrafficMirrorFilterId?: string | null;
  PacketLength?: number | null;
  SessionNumber?: number | null;
  VirtualNetworkId?: number | null;
  Description?: string | null;
  RemoveFields?: TrafficMirrorSessionField[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyTransitGatewayRequest {
  TransitGatewayId: string;
  Description?: string | null;
  Options?: ModifyTransitGatewayOptions | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyTransitGatewayPrefixListReferenceRequest {
  TransitGatewayRouteTableId: string;
  PrefixListId: string;
  TransitGatewayAttachmentId?: string | null;
  Blackhole?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId: string;
  AddSubnetIds?: string[] | null;
  RemoveSubnetIds?: string[] | null;
  Options?: ModifyTransitGatewayVpcAttachmentRequestOptions | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVolumeRequest {
  DryRun?: boolean | null;
  VolumeId: string;
  Size?: number | null;
  VolumeType?: VolumeType | null;
  Iops?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyVolumeAttributeRequest {
  AutoEnableIO?: AttributeBooleanValue | null;
  VolumeId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpcAttributeRequest {
  EnableDnsHostnames?: AttributeBooleanValue | null;
  EnableDnsSupport?: AttributeBooleanValue | null;
  VpcId: string;
}

// refs: 1 - tags: named, input
export interface ModifyVpcEndpointRequest {
  DryRun?: boolean | null;
  VpcEndpointId: string;
  ResetPolicy?: boolean | null;
  PolicyDocument?: string | null;
  AddRouteTableIds?: string[] | null;
  RemoveRouteTableIds?: string[] | null;
  AddSubnetIds?: string[] | null;
  RemoveSubnetIds?: string[] | null;
  AddSecurityGroupIds?: string[] | null;
  RemoveSecurityGroupIds?: string[] | null;
  PrivateDnsEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpcEndpointConnectionNotificationRequest {
  DryRun?: boolean | null;
  ConnectionNotificationId: string;
  ConnectionNotificationArn?: string | null;
  ConnectionEvents?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpcEndpointServiceConfigurationRequest {
  DryRun?: boolean | null;
  ServiceId: string;
  PrivateDnsName?: string | null;
  RemovePrivateDnsName?: boolean | null;
  AcceptanceRequired?: boolean | null;
  AddNetworkLoadBalancerArns?: string[] | null;
  RemoveNetworkLoadBalancerArns?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpcEndpointServicePermissionsRequest {
  DryRun?: boolean | null;
  ServiceId: string;
  AddAllowedPrincipals?: string[] | null;
  RemoveAllowedPrincipals?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpcPeeringConnectionOptionsRequest {
  AccepterPeeringConnectionOptions?: PeeringConnectionOptionsRequest | null;
  DryRun?: boolean | null;
  RequesterPeeringConnectionOptions?: PeeringConnectionOptionsRequest | null;
  VpcPeeringConnectionId: string;
}

// refs: 1 - tags: named, input
export interface ModifyVpcTenancyRequest {
  VpcId: string;
  InstanceTenancy: VpcTenancy;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpnConnectionRequest {
  VpnConnectionId: string;
  TransitGatewayId?: string | null;
  CustomerGatewayId?: string | null;
  VpnGatewayId?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpnConnectionOptionsRequest {
  VpnConnectionId: string;
  LocalIpv4NetworkCidr?: string | null;
  RemoteIpv4NetworkCidr?: string | null;
  LocalIpv6NetworkCidr?: string | null;
  RemoteIpv6NetworkCidr?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpnTunnelCertificateRequest {
  VpnConnectionId: string;
  VpnTunnelOutsideIpAddress: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyVpnTunnelOptionsRequest {
  VpnConnectionId: string;
  VpnTunnelOutsideIpAddress: string;
  TunnelOptions: ModifyVpnTunnelOptionsSpecification;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface MonitorInstancesRequest {
  InstanceIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface MoveAddressToVpcRequest {
  DryRun?: boolean | null;
  PublicIp: string;
}

// refs: 1 - tags: named, input
export interface ProvisionByoipCidrRequest {
  Cidr: string;
  CidrAuthorizationContext?: CidrAuthorizationContext | null;
  PubliclyAdvertisable?: boolean | null;
  Description?: string | null;
  DryRun?: boolean | null;
  PoolTagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface PurchaseHostReservationRequest {
  ClientToken?: string | null;
  CurrencyCode?: CurrencyCodeValues | null;
  HostIdSet: string[];
  LimitPrice?: string | null;
  OfferingId: string;
  TagSpecifications?: TagSpecification[] | null;
}

// refs: 1 - tags: named, input
export interface PurchaseReservedInstancesOfferingRequest {
  InstanceCount: number;
  ReservedInstancesOfferingId: string;
  DryRun?: boolean | null;
  LimitPrice?: ReservedInstanceLimitPrice | null;
  PurchaseTime?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface PurchaseScheduledInstancesRequest {
  ClientToken?: string | null;
  DryRun?: boolean | null;
  PurchaseRequests: PurchaseRequest[];
}

// refs: 1 - tags: named, input
export interface RebootInstancesRequest {
  InstanceIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RegisterImageRequest {
  ImageLocation?: string | null;
  Architecture?: ArchitectureValues | null;
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  Description?: string | null;
  DryRun?: boolean | null;
  EnaSupport?: boolean | null;
  KernelId?: string | null;
  Name: string;
  BillingProducts?: string[] | null;
  RamdiskId?: string | null;
  RootDeviceName?: string | null;
  SriovNetSupport?: string | null;
  VirtualizationType?: string | null;
}

// refs: 1 - tags: named, input
export interface RegisterInstanceEventNotificationAttributesRequest {
  DryRun?: boolean | null;
  InstanceTagAttribute?: RegisterInstanceTagAttributeRequest | null;
}

// refs: 1 - tags: named, input
export interface RegisterTransitGatewayMulticastGroupMembersRequest {
  TransitGatewayMulticastDomainId?: string | null;
  GroupIpAddress?: string | null;
  NetworkInterfaceIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RegisterTransitGatewayMulticastGroupSourcesRequest {
  TransitGatewayMulticastDomainId?: string | null;
  GroupIpAddress?: string | null;
  NetworkInterfaceIds?: string[] | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RejectTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RejectTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RejectVpcEndpointConnectionsRequest {
  DryRun?: boolean | null;
  ServiceId: string;
  VpcEndpointIds: string[];
}

// refs: 1 - tags: named, input
export interface RejectVpcPeeringConnectionRequest {
  DryRun?: boolean | null;
  VpcPeeringConnectionId: string;
}

// refs: 1 - tags: named, input
export interface ReleaseAddressRequest {
  AllocationId?: string | null;
  PublicIp?: string | null;
  NetworkBorderGroup?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ReleaseHostsRequest {
  HostIds: string[];
}

// refs: 1 - tags: named, input
export interface ReplaceIamInstanceProfileAssociationRequest {
  IamInstanceProfile: IamInstanceProfileSpecification;
  AssociationId: string;
}

// refs: 1 - tags: named, input
export interface ReplaceNetworkAclAssociationRequest {
  AssociationId: string;
  DryRun?: boolean | null;
  NetworkAclId: string;
}

// refs: 1 - tags: named, input
export interface ReplaceNetworkAclEntryRequest {
  CidrBlock?: string | null;
  DryRun?: boolean | null;
  Egress: boolean;
  IcmpTypeCode?: IcmpTypeCode | null;
  Ipv6CidrBlock?: string | null;
  NetworkAclId: string;
  PortRange?: PortRange | null;
  Protocol: string;
  RuleAction: RuleAction;
  RuleNumber: number;
}

// refs: 1 - tags: named, input
export interface ReplaceRouteRequest {
  DestinationCidrBlock?: string | null;
  DestinationIpv6CidrBlock?: string | null;
  DestinationPrefixListId?: string | null;
  DryRun?: boolean | null;
  EgressOnlyInternetGatewayId?: string | null;
  GatewayId?: string | null;
  InstanceId?: string | null;
  LocalTarget?: boolean | null;
  NatGatewayId?: string | null;
  TransitGatewayId?: string | null;
  LocalGatewayId?: string | null;
  CarrierGatewayId?: string | null;
  NetworkInterfaceId?: string | null;
  RouteTableId: string;
  VpcPeeringConnectionId?: string | null;
}

// refs: 1 - tags: named, input
export interface ReplaceRouteTableAssociationRequest {
  AssociationId: string;
  DryRun?: boolean | null;
  RouteTableId: string;
}

// refs: 1 - tags: named, input
export interface ReplaceTransitGatewayRouteRequest {
  DestinationCidrBlock: string;
  TransitGatewayRouteTableId: string;
  TransitGatewayAttachmentId?: string | null;
  Blackhole?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ReportInstanceStatusRequest {
  Description?: string | null;
  DryRun?: boolean | null;
  EndTime?: Date | number | null;
  Instances: string[];
  ReasonCodes: ReportInstanceReasonCodes[];
  StartTime?: Date | number | null;
  Status: ReportStatusType;
}

// refs: 1 - tags: named, input
export interface RequestSpotFleetRequest {
  DryRun?: boolean | null;
  SpotFleetRequestConfig: SpotFleetRequestConfigData;
}

// refs: 1 - tags: named, input
export interface RequestSpotInstancesRequest {
  AvailabilityZoneGroup?: string | null;
  BlockDurationMinutes?: number | null;
  ClientToken?: string | null;
  DryRun?: boolean | null;
  InstanceCount?: number | null;
  LaunchGroup?: string | null;
  LaunchSpecification?: RequestSpotLaunchSpecification | null;
  SpotPrice?: string | null;
  Type?: SpotInstanceType | null;
  ValidFrom?: Date | number | null;
  ValidUntil?: Date | number | null;
  TagSpecifications?: TagSpecification[] | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
}

// refs: 1 - tags: named, input
export interface ResetEbsDefaultKmsKeyIdRequest {
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ResetFpgaImageAttributeRequest {
  DryRun?: boolean | null;
  FpgaImageId: string;
  Attribute?: ResetFpgaImageAttributeName | null;
}

// refs: 1 - tags: named, input
export interface ResetImageAttributeRequest {
  Attribute: ResetImageAttributeName;
  ImageId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ResetInstanceAttributeRequest {
  Attribute: InstanceAttributeName;
  DryRun?: boolean | null;
  InstanceId: string;
}

// refs: 1 - tags: named, input
export interface ResetNetworkInterfaceAttributeRequest {
  DryRun?: boolean | null;
  NetworkInterfaceId: string;
  SourceDestCheck?: string | null;
}

// refs: 1 - tags: named, input
export interface ResetSnapshotAttributeRequest {
  Attribute: SnapshotAttributeName;
  SnapshotId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RestoreAddressToClassicRequest {
  DryRun?: boolean | null;
  PublicIp: string;
}

// refs: 1 - tags: named, input
export interface RestoreManagedPrefixListVersionRequest {
  DryRun?: boolean | null;
  PrefixListId: string;
  PreviousVersion: number;
  CurrentVersion: number;
}

// refs: 1 - tags: named, input
export interface RevokeClientVpnIngressRequest {
  ClientVpnEndpointId: string;
  TargetNetworkCidr: string;
  AccessGroupId?: string | null;
  RevokeAllGroups?: boolean | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RevokeSecurityGroupEgressRequest {
  DryRun?: boolean | null;
  GroupId: string;
  IpPermissions?: IpPermission[] | null;
  CidrIp?: string | null;
  FromPort?: number | null;
  IpProtocol?: string | null;
  ToPort?: number | null;
  SourceSecurityGroupName?: string | null;
  SourceSecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface RevokeSecurityGroupIngressRequest {
  CidrIp?: string | null;
  FromPort?: number | null;
  GroupId?: string | null;
  GroupName?: string | null;
  IpPermissions?: IpPermission[] | null;
  IpProtocol?: string | null;
  SourceSecurityGroupName?: string | null;
  SourceSecurityGroupOwnerId?: string | null;
  ToPort?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RunInstancesRequest {
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  Ipv6AddressCount?: number | null;
  Ipv6Addresses?: InstanceIpv6Address[] | null;
  KernelId?: string | null;
  KeyName?: string | null;
  MaxCount: number;
  MinCount: number;
  Monitoring?: RunInstancesMonitoringEnabled | null;
  Placement?: Placement | null;
  RamdiskId?: string | null;
  SecurityGroupIds?: string[] | null;
  SecurityGroups?: string[] | null;
  SubnetId?: string | null;
  UserData?: string | null;
  AdditionalInfo?: string | null;
  ClientToken?: string | null;
  DisableApiTermination?: boolean | null;
  DryRun?: boolean | null;
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: IamInstanceProfileSpecification | null;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior | null;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[] | null;
  PrivateIpAddress?: string | null;
  ElasticGpuSpecification?: ElasticGpuSpecification[] | null;
  ElasticInferenceAccelerators?: ElasticInferenceAccelerator[] | null;
  TagSpecifications?: TagSpecification[] | null;
  LaunchTemplate?: LaunchTemplateSpecification | null;
  InstanceMarketOptions?: InstanceMarketOptionsRequest | null;
  CreditSpecification?: CreditSpecificationRequest | null;
  CpuOptions?: CpuOptionsRequest | null;
  CapacityReservationSpecification?: CapacityReservationSpecification | null;
  HibernationOptions?: HibernationOptionsRequest | null;
  LicenseSpecifications?: LicenseConfigurationRequest[] | null;
  MetadataOptions?: InstanceMetadataOptionsRequest | null;
}

// refs: 1 - tags: named, input
export interface RunScheduledInstancesRequest {
  ClientToken?: string | null;
  DryRun?: boolean | null;
  InstanceCount?: number | null;
  LaunchSpecification: ScheduledInstancesLaunchSpecification;
  ScheduledInstanceId: string;
}

// refs: 1 - tags: named, input
export interface SearchLocalGatewayRoutesRequest {
  LocalGatewayRouteTableId: string;
  Filters: Filter[];
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface SearchTransitGatewayMulticastGroupsRequest {
  TransitGatewayMulticastDomainId?: string | null;
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface SearchTransitGatewayRoutesRequest {
  TransitGatewayRouteTableId: string;
  Filters: Filter[];
  MaxResults?: number | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface SendDiagnosticInterruptRequest {
  InstanceId: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartInstancesRequest {
  InstanceIds: string[];
  AdditionalInfo?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartVpcEndpointServicePrivateDnsVerificationRequest {
  DryRun?: boolean | null;
  ServiceId: string;
}

// refs: 1 - tags: named, input
export interface StopInstancesRequest {
  InstanceIds: string[];
  Hibernate?: boolean | null;
  DryRun?: boolean | null;
  Force?: boolean | null;
}

// refs: 1 - tags: named, input
export interface TerminateClientVpnConnectionsRequest {
  ClientVpnEndpointId: string;
  ConnectionId?: string | null;
  Username?: string | null;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface TerminateInstancesRequest {
  InstanceIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UnassignIpv6AddressesRequest {
  Ipv6Addresses: string[];
  NetworkInterfaceId: string;
}

// refs: 1 - tags: named, input
export interface UnassignPrivateIpAddressesRequest {
  NetworkInterfaceId: string;
  PrivateIpAddresses: string[];
}

// refs: 1 - tags: named, input
export interface UnmonitorInstancesRequest {
  InstanceIds: string[];
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateSecurityGroupRuleDescriptionsEgressRequest {
  DryRun?: boolean | null;
  GroupId?: string | null;
  GroupName?: string | null;
  IpPermissions: IpPermission[];
}

// refs: 1 - tags: named, input
export interface UpdateSecurityGroupRuleDescriptionsIngressRequest {
  DryRun?: boolean | null;
  GroupId?: string | null;
  GroupName?: string | null;
  IpPermissions: IpPermission[];
}

// refs: 1 - tags: named, input
export interface WithdrawByoipCidrRequest {
  Cidr: string;
  DryRun?: boolean | null;
}

// refs: 1 - tags: named, output
export interface AcceptReservedInstancesExchangeQuoteResult {
  ExchangeId?: string | null;
}

// refs: 1 - tags: named, output
export interface AcceptTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment | null;
}

// refs: 1 - tags: named, output
export interface AcceptTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment | null;
}

// refs: 1 - tags: named, output
export interface AcceptVpcEndpointConnectionsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface AcceptVpcPeeringConnectionResult {
  VpcPeeringConnection?: VpcPeeringConnection | null;
}

// refs: 1 - tags: named, output
export interface AdvertiseByoipCidrResult {
  ByoipCidr?: ByoipCidr | null;
}

// refs: 1 - tags: named, output
export interface AllocateAddressResult {
  PublicIp?: string | null;
  AllocationId?: string | null;
  PublicIpv4Pool?: string | null;
  NetworkBorderGroup?: string | null;
  Domain?: DomainType | null;
  CustomerOwnedIp?: string | null;
  CustomerOwnedIpv4Pool?: string | null;
  CarrierIp?: string | null;
}

// refs: 1 - tags: named, output
export interface AllocateHostsResult {
  HostIds: string[];
}

// refs: 1 - tags: named, output
export interface ApplySecurityGroupsToClientVpnTargetNetworkResult {
  SecurityGroupIds: string[];
}

// refs: 1 - tags: named, output
export interface AssignIpv6AddressesResult {
  AssignedIpv6Addresses: string[];
  NetworkInterfaceId?: string | null;
}

// refs: 1 - tags: named, output
export interface AssignPrivateIpAddressesResult {
  NetworkInterfaceId?: string | null;
  AssignedPrivateIpAddresses: AssignedPrivateIpAddress[];
}

// refs: 1 - tags: named, output
export interface AssociateAddressResult {
  AssociationId?: string | null;
}

// refs: 1 - tags: named, output
export interface AssociateClientVpnTargetNetworkResult {
  AssociationId?: string | null;
  Status?: AssociationStatus | null;
}

// refs: 1 - tags: named, output
export interface AssociateIamInstanceProfileResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation | null;
}

// refs: 1 - tags: named, output
export interface AssociateRouteTableResult {
  AssociationId?: string | null;
  AssociationState?: RouteTableAssociationState | null;
}

// refs: 1 - tags: named, output
export interface AssociateSubnetCidrBlockResult {
  Ipv6CidrBlockAssociation?: SubnetIpv6CidrBlockAssociation | null;
  SubnetId?: string | null;
}

// refs: 1 - tags: named, output
export interface AssociateTransitGatewayMulticastDomainResult {
  Associations?: TransitGatewayMulticastDomainAssociations | null;
}

// refs: 1 - tags: named, output
export interface AssociateTransitGatewayRouteTableResult {
  Association?: TransitGatewayAssociation | null;
}

// refs: 1 - tags: named, output
export interface AssociateVpcCidrBlockResult {
  Ipv6CidrBlockAssociation?: VpcIpv6CidrBlockAssociation | null;
  CidrBlockAssociation?: VpcCidrBlockAssociation | null;
  VpcId?: string | null;
}

// refs: 1 - tags: named, output
export interface AttachClassicLinkVpcResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface AttachNetworkInterfaceResult {
  AttachmentId?: string | null;
}

// refs: 3 - tags: named, output, interface
export interface VolumeAttachment {
  AttachTime?: Date | number | null;
  Device?: string | null;
  InstanceId?: string | null;
  State?: VolumeAttachmentState | null;
  VolumeId?: string | null;
  DeleteOnTermination?: boolean | null;
}
function VolumeAttachment_Parse(node: xmlP.XmlNode): VolumeAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    Device: node.first("device", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    State: node.first("status", false, x => (x.content ?? '') as VolumeAttachmentState),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: named, output
export interface AttachVpnGatewayResult {
  VpcAttachment?: VpcAttachment | null;
}

// refs: 1 - tags: named, output
export interface AuthorizeClientVpnIngressResult {
  Status?: ClientVpnAuthorizationRuleStatus | null;
}

// refs: 1 - tags: named, output
export interface BundleInstanceResult {
  BundleTask?: BundleTask | null;
}

// refs: 1 - tags: named, output
export interface CancelBundleTaskResult {
  BundleTask?: BundleTask | null;
}

// refs: 1 - tags: named, output
export interface CancelCapacityReservationResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface CancelImportTaskResult {
  ImportTaskId?: string | null;
  PreviousState?: string | null;
  State?: string | null;
}

// refs: 1 - tags: named, output
export interface CancelReservedInstancesListingResult {
  ReservedInstancesListings: ReservedInstancesListing[];
}

// refs: 1 - tags: named, output
export interface CancelSpotFleetRequestsResponse {
  SuccessfulFleetRequests: CancelSpotFleetRequestsSuccessItem[];
  UnsuccessfulFleetRequests: CancelSpotFleetRequestsErrorItem[];
}

// refs: 1 - tags: named, output
export interface CancelSpotInstanceRequestsResult {
  CancelledSpotInstanceRequests: CancelledSpotInstanceRequest[];
}

// refs: 1 - tags: named, output
export interface ConfirmProductInstanceResult {
  OwnerId?: string | null;
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface CopyFpgaImageResult {
  FpgaImageId?: string | null;
}

// refs: 1 - tags: named, output
export interface CopyImageResult {
  ImageId?: string | null;
}

// refs: 1 - tags: named, output
export interface CopySnapshotResult {
  SnapshotId?: string | null;
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface CreateCapacityReservationResult {
  CapacityReservation?: CapacityReservation | null;
}

// refs: 1 - tags: named, output
export interface CreateCarrierGatewayResult {
  CarrierGateway?: CarrierGateway | null;
}

// refs: 1 - tags: named, output
export interface CreateClientVpnEndpointResult {
  ClientVpnEndpointId?: string | null;
  Status?: ClientVpnEndpointStatus | null;
  DnsName?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateClientVpnRouteResult {
  Status?: ClientVpnRouteStatus | null;
}

// refs: 1 - tags: named, output
export interface CreateCustomerGatewayResult {
  CustomerGateway?: CustomerGateway | null;
}

// refs: 1 - tags: named, output
export interface CreateDefaultSubnetResult {
  Subnet?: Subnet | null;
}

// refs: 1 - tags: named, output
export interface CreateDefaultVpcResult {
  Vpc?: Vpc | null;
}

// refs: 1 - tags: named, output
export interface CreateDhcpOptionsResult {
  DhcpOptions?: DhcpOptions | null;
}

// refs: 1 - tags: named, output
export interface CreateEgressOnlyInternetGatewayResult {
  ClientToken?: string | null;
  EgressOnlyInternetGateway?: EgressOnlyInternetGateway | null;
}

// refs: 1 - tags: named, output
export interface CreateFleetResult {
  FleetId?: string | null;
  Errors: CreateFleetError[];
  Instances: CreateFleetInstance[];
}

// refs: 1 - tags: named, output
export interface CreateFlowLogsResult {
  ClientToken?: string | null;
  FlowLogIds: string[];
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface CreateFpgaImageResult {
  FpgaImageId?: string | null;
  FpgaImageGlobalId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateImageResult {
  ImageId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateInstanceExportTaskResult {
  ExportTask?: ExportTask | null;
}

// refs: 1 - tags: named, output
export interface CreateInternetGatewayResult {
  InternetGateway?: InternetGateway | null;
}

// refs: 1 - tags: named, output
export interface KeyPair {
  KeyFingerprint?: string | null;
  KeyMaterial?: string | null;
  KeyName?: string | null;
  KeyPairId?: string | null;
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface CreateLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate | null;
  Warning?: ValidationWarning | null;
}

// refs: 1 - tags: named, output
export interface CreateLaunchTemplateVersionResult {
  LaunchTemplateVersion?: LaunchTemplateVersion | null;
  Warning?: ValidationWarning | null;
}

// refs: 1 - tags: named, output
export interface CreateLocalGatewayRouteResult {
  Route?: LocalGatewayRoute | null;
}

// refs: 1 - tags: named, output
export interface CreateLocalGatewayRouteTableVpcAssociationResult {
  LocalGatewayRouteTableVpcAssociation?: LocalGatewayRouteTableVpcAssociation | null;
}

// refs: 1 - tags: named, output
export interface CreateManagedPrefixListResult {
  PrefixList?: ManagedPrefixList | null;
}

// refs: 1 - tags: named, output
export interface CreateNatGatewayResult {
  ClientToken?: string | null;
  NatGateway?: NatGateway | null;
}

// refs: 1 - tags: named, output
export interface CreateNetworkAclResult {
  NetworkAcl?: NetworkAcl | null;
}

// refs: 1 - tags: named, output
export interface CreateNetworkInterfaceResult {
  NetworkInterface?: NetworkInterface | null;
}

// refs: 1 - tags: named, output
export interface CreateNetworkInterfacePermissionResult {
  InterfacePermission?: NetworkInterfacePermission | null;
}

// refs: 1 - tags: named, output
export interface CreatePlacementGroupResult {
  PlacementGroup?: PlacementGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateReservedInstancesListingResult {
  ReservedInstancesListings: ReservedInstancesListing[];
}

// refs: 1 - tags: named, output
export interface CreateRouteResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface CreateRouteTableResult {
  RouteTable?: RouteTable | null;
}

// refs: 1 - tags: named, output
export interface CreateSecurityGroupResult {
  GroupId?: string | null;
  Tags: Tag[];
}

// refs: 2 - tags: named, output, interface
export interface Snapshot {
  DataEncryptionKeyId?: string | null;
  Description?: string | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  OwnerId?: string | null;
  Progress?: string | null;
  SnapshotId?: string | null;
  StartTime?: Date | number | null;
  State?: SnapshotState | null;
  StateMessage?: string | null;
  VolumeId?: string | null;
  VolumeSize?: number | null;
  OwnerAlias?: string | null;
  Tags: Tag[];
}
function Snapshot_Parse(node: xmlP.XmlNode): Snapshot {
  return {
    DataEncryptionKeyId: node.first("dataEncryptionKeyId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("status", false, x => (x.content ?? '') as SnapshotState),
    StateMessage: node.first("statusMessage", false, x => x.content ?? ''),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: named, output
export interface CreateSnapshotsResult {
  Snapshots: SnapshotInfo[];
}

// refs: 1 - tags: named, output
export interface CreateSpotDatafeedSubscriptionResult {
  SpotDatafeedSubscription?: SpotDatafeedSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateSubnetResult {
  Subnet?: Subnet | null;
}

// refs: 1 - tags: named, output
export interface CreateTrafficMirrorFilterResult {
  TrafficMirrorFilter?: TrafficMirrorFilter | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRule?: TrafficMirrorFilterRule | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTrafficMirrorSessionResult {
  TrafficMirrorSession?: TrafficMirrorSession | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTrafficMirrorTargetResult {
  TrafficMirrorTarget?: TrafficMirrorTarget | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayResult {
  TransitGateway?: TransitGateway | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayMulticastDomainResult {
  TransitGatewayMulticastDomain?: TransitGatewayMulticastDomain | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayRouteResult {
  Route?: TransitGatewayRoute | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayRouteTableResult {
  TransitGatewayRouteTable?: TransitGatewayRouteTable | null;
}

// refs: 1 - tags: named, output
export interface CreateTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment | null;
}

// refs: 2 - tags: named, output, interface
export interface Volume {
  Attachments: VolumeAttachment[];
  AvailabilityZone?: string | null;
  CreateTime?: Date | number | null;
  Encrypted?: boolean | null;
  KmsKeyId?: string | null;
  OutpostArn?: string | null;
  Size?: number | null;
  SnapshotId?: string | null;
  State?: VolumeState | null;
  VolumeId?: string | null;
  Iops?: number | null;
  Tags: Tag[];
  VolumeType?: VolumeType | null;
  FastRestored?: boolean | null;
  MultiAttachEnabled?: boolean | null;
}
function Volume_Parse(node: xmlP.XmlNode): Volume {
  return {
    Attachments: node.getList("attachmentSet", "item").map(VolumeAttachment_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    State: node.first("status", false, x => (x.content ?? '') as VolumeState),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as VolumeType),
    FastRestored: node.first("fastRestored", false, x => x.content === 'true'),
    MultiAttachEnabled: node.first("multiAttachEnabled", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: named, output
export interface CreateVpcResult {
  Vpc?: Vpc | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcEndpointResult {
  VpcEndpoint?: VpcEndpoint | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcEndpointConnectionNotificationResult {
  ConnectionNotification?: ConnectionNotification | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcEndpointServiceConfigurationResult {
  ServiceConfiguration?: ServiceConfiguration | null;
  ClientToken?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVpcPeeringConnectionResult {
  VpcPeeringConnection?: VpcPeeringConnection | null;
}

// refs: 1 - tags: named, output
export interface CreateVpnConnectionResult {
  VpnConnection?: VpnConnection | null;
}

// refs: 1 - tags: named, output
export interface CreateVpnGatewayResult {
  VpnGateway?: VpnGateway | null;
}

// refs: 1 - tags: named, output
export interface DeleteCarrierGatewayResult {
  CarrierGateway?: CarrierGateway | null;
}

// refs: 1 - tags: named, output
export interface DeleteClientVpnEndpointResult {
  Status?: ClientVpnEndpointStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteClientVpnRouteResult {
  Status?: ClientVpnRouteStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteEgressOnlyInternetGatewayResult {
  ReturnCode?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DeleteFleetsResult {
  SuccessfulFleetDeletions: DeleteFleetSuccessItem[];
  UnsuccessfulFleetDeletions: DeleteFleetErrorItem[];
}

// refs: 1 - tags: named, output
export interface DeleteFlowLogsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface DeleteFpgaImageResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DeleteLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate | null;
}

// refs: 1 - tags: named, output
export interface DeleteLaunchTemplateVersionsResult {
  SuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseSuccessItem[];
  UnsuccessfullyDeletedLaunchTemplateVersions: DeleteLaunchTemplateVersionsResponseErrorItem[];
}

// refs: 1 - tags: named, output
export interface DeleteLocalGatewayRouteResult {
  Route?: LocalGatewayRoute | null;
}

// refs: 1 - tags: named, output
export interface DeleteLocalGatewayRouteTableVpcAssociationResult {
  LocalGatewayRouteTableVpcAssociation?: LocalGatewayRouteTableVpcAssociation | null;
}

// refs: 1 - tags: named, output
export interface DeleteManagedPrefixListResult {
  PrefixList?: ManagedPrefixList | null;
}

// refs: 1 - tags: named, output
export interface DeleteNatGatewayResult {
  NatGatewayId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteNetworkInterfacePermissionResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DeleteQueuedReservedInstancesResult {
  SuccessfulQueuedPurchaseDeletions: SuccessfulQueuedPurchaseDeletion[];
  FailedQueuedPurchaseDeletions: FailedQueuedPurchaseDeletion[];
}

// refs: 1 - tags: named, output
export interface DeleteTrafficMirrorFilterResult {
  TrafficMirrorFilterId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRuleId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTrafficMirrorSessionResult {
  TrafficMirrorSessionId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTrafficMirrorTargetResult {
  TrafficMirrorTargetId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayResult {
  TransitGateway?: TransitGateway | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayMulticastDomainResult {
  TransitGatewayMulticastDomain?: TransitGatewayMulticastDomain | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayRouteResult {
  Route?: TransitGatewayRoute | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayRouteTableResult {
  TransitGatewayRouteTable?: TransitGatewayRouteTable | null;
}

// refs: 1 - tags: named, output
export interface DeleteTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment | null;
}

// refs: 1 - tags: named, output
export interface DeleteVpcEndpointConnectionNotificationsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface DeleteVpcEndpointServiceConfigurationsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface DeleteVpcEndpointsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface DeleteVpcPeeringConnectionResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DeprovisionByoipCidrResult {
  ByoipCidr?: ByoipCidr | null;
}

// refs: 1 - tags: named, output
export interface DeregisterInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute | null;
}

// refs: 1 - tags: named, output
export interface DeregisterTransitGatewayMulticastGroupMembersResult {
  DeregisteredMulticastGroupMembers?: TransitGatewayMulticastDeregisteredGroupMembers | null;
}

// refs: 1 - tags: named, output
export interface DeregisterTransitGatewayMulticastGroupSourcesResult {
  DeregisteredMulticastGroupSources?: TransitGatewayMulticastDeregisteredGroupSources | null;
}

// refs: 1 - tags: named, output
export interface DescribeAccountAttributesResult {
  AccountAttributes: AccountAttribute[];
}

// refs: 1 - tags: named, output
export interface DescribeAddressesResult {
  Addresses: Address[];
}

// refs: 1 - tags: named, output
export interface DescribeAggregateIdFormatResult {
  UseLongIdsAggregated?: boolean | null;
  Statuses: IdFormat[];
}

// refs: 1 - tags: named, output
export interface DescribeAvailabilityZonesResult {
  AvailabilityZones: AvailabilityZone[];
}

// refs: 1 - tags: named, output
export interface DescribeBundleTasksResult {
  BundleTasks: BundleTask[];
}

// refs: 1 - tags: named, output
export interface DescribeByoipCidrsResult {
  ByoipCidrs: ByoipCidr[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeCapacityReservationsResult {
  NextToken?: string | null;
  CapacityReservations: CapacityReservation[];
}

// refs: 1 - tags: named, output
export interface DescribeCarrierGatewaysResult {
  CarrierGateways: CarrierGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClassicLinkInstancesResult {
  Instances: ClassicLinkInstance[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClientVpnAuthorizationRulesResult {
  AuthorizationRules: AuthorizationRule[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClientVpnConnectionsResult {
  Connections: ClientVpnConnection[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClientVpnEndpointsResult {
  ClientVpnEndpoints: ClientVpnEndpoint[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClientVpnRoutesResult {
  Routes: ClientVpnRoute[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeClientVpnTargetNetworksResult {
  ClientVpnTargetNetworks: TargetNetwork[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeCoipPoolsResult {
  CoipPools: CoipPool[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeConversionTasksResult {
  ConversionTasks: ConversionTask[];
}

// refs: 1 - tags: named, output
export interface DescribeCustomerGatewaysResult {
  CustomerGateways: CustomerGateway[];
}

// refs: 1 - tags: named, output
export interface DescribeDhcpOptionsResult {
  DhcpOptions: DhcpOptions[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeEgressOnlyInternetGatewaysResult {
  EgressOnlyInternetGateways: EgressOnlyInternetGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeElasticGpusResult {
  ElasticGpuSet: ElasticGpus[];
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeExportImageTasksResult {
  ExportImageTasks: ExportImageTask[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeExportTasksResult {
  ExportTasks: ExportTask[];
}

// refs: 1 - tags: named, output
export interface DescribeFastSnapshotRestoresResult {
  FastSnapshotRestores: DescribeFastSnapshotRestoreSuccessItem[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetHistoryResult {
  HistoryRecords: HistoryRecordEntry[];
  LastEvaluatedTime?: Date | number | null;
  NextToken?: string | null;
  FleetId?: string | null;
  StartTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetInstancesResult {
  ActiveInstances: ActiveInstance[];
  NextToken?: string | null;
  FleetId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFleetsResult {
  NextToken?: string | null;
  Fleets: FleetData[];
}

// refs: 1 - tags: named, output
export interface DescribeFlowLogsResult {
  FlowLogs: FlowLog[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeFpgaImageAttributeResult {
  FpgaImageAttribute?: FpgaImageAttribute | null;
}

// refs: 1 - tags: named, output
export interface DescribeFpgaImagesResult {
  FpgaImages: FpgaImage[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeHostReservationOfferingsResult {
  NextToken?: string | null;
  OfferingSet: HostOffering[];
}

// refs: 1 - tags: named, output
export interface DescribeHostReservationsResult {
  HostReservationSet: HostReservation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeHostsResult {
  Hosts: Host[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeIamInstanceProfileAssociationsResult {
  IamInstanceProfileAssociations: IamInstanceProfileAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeIdFormatResult {
  Statuses: IdFormat[];
}

// refs: 1 - tags: named, output
export interface DescribeIdentityIdFormatResult {
  Statuses: IdFormat[];
}

// refs: 1 - tags: named, output
export interface ImageAttribute {
  BlockDeviceMappings: BlockDeviceMapping[];
  ImageId?: string | null;
  LaunchPermissions: LaunchPermission[];
  ProductCodes: ProductCode[];
  Description?: AttributeValue | null;
  KernelId?: AttributeValue | null;
  RamdiskId?: AttributeValue | null;
  SriovNetSupport?: AttributeValue | null;
}

// refs: 1 - tags: named, output
export interface DescribeImagesResult {
  Images: Image[];
}

// refs: 1 - tags: named, output
export interface DescribeImportImageTasksResult {
  ImportImageTasks: ImportImageTask[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImportSnapshotTasksResult {
  ImportSnapshotTasks: ImportSnapshotTask[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface InstanceAttribute {
  Groups: GroupIdentifier[];
  BlockDeviceMappings: InstanceBlockDeviceMapping[];
  DisableApiTermination?: AttributeBooleanValue | null;
  EnaSupport?: AttributeBooleanValue | null;
  EbsOptimized?: AttributeBooleanValue | null;
  InstanceId?: string | null;
  InstanceInitiatedShutdownBehavior?: AttributeValue | null;
  InstanceType?: AttributeValue | null;
  KernelId?: AttributeValue | null;
  ProductCodes: ProductCode[];
  RamdiskId?: AttributeValue | null;
  RootDeviceName?: AttributeValue | null;
  SourceDestCheck?: AttributeBooleanValue | null;
  SriovNetSupport?: AttributeValue | null;
  UserData?: AttributeValue | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstanceCreditSpecificationsResult {
  InstanceCreditSpecifications: InstanceCreditSpecification[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstanceStatusResult {
  InstanceStatuses: InstanceStatus[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstanceTypeOfferingsResult {
  InstanceTypeOfferings: InstanceTypeOffering[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstanceTypesResult {
  InstanceTypes: InstanceTypeInfo[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInstancesResult {
  Reservations: Reservation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeInternetGatewaysResult {
  InternetGateways: InternetGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeIpv6PoolsResult {
  Ipv6Pools: Ipv6Pool[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeKeyPairsResult {
  KeyPairs: KeyPairInfo[];
}

// refs: 1 - tags: named, output
export interface DescribeLaunchTemplateVersionsResult {
  LaunchTemplateVersions: LaunchTemplateVersion[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLaunchTemplatesResult {
  LaunchTemplates: LaunchTemplate[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociations: LocalGatewayRouteTableVirtualInterfaceGroupAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewayRouteTableVpcAssociationsResult {
  LocalGatewayRouteTableVpcAssociations: LocalGatewayRouteTableVpcAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewayRouteTablesResult {
  LocalGatewayRouteTables: LocalGatewayRouteTable[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewayVirtualInterfaceGroupsResult {
  LocalGatewayVirtualInterfaceGroups: LocalGatewayVirtualInterfaceGroup[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewayVirtualInterfacesResult {
  LocalGatewayVirtualInterfaces: LocalGatewayVirtualInterface[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLocalGatewaysResult {
  LocalGateways: LocalGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeManagedPrefixListsResult {
  NextToken?: string | null;
  PrefixLists: ManagedPrefixList[];
}

// refs: 1 - tags: named, output
export interface DescribeMovingAddressesResult {
  MovingAddressStatuses: MovingAddressStatus[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeNatGatewaysResult {
  NatGateways: NatGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeNetworkAclsResult {
  NetworkAcls: NetworkAcl[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeNetworkInterfaceAttributeResult {
  Attachment?: NetworkInterfaceAttachment | null;
  Description?: AttributeValue | null;
  Groups: GroupIdentifier[];
  NetworkInterfaceId?: string | null;
  SourceDestCheck?: AttributeBooleanValue | null;
}

// refs: 1 - tags: named, output
export interface DescribeNetworkInterfacePermissionsResult {
  NetworkInterfacePermissions: NetworkInterfacePermission[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeNetworkInterfacesResult {
  NetworkInterfaces: NetworkInterface[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePlacementGroupsResult {
  PlacementGroups: PlacementGroup[];
}

// refs: 1 - tags: named, output
export interface DescribePrefixListsResult {
  NextToken?: string | null;
  PrefixLists: PrefixList[];
}

// refs: 1 - tags: named, output
export interface DescribePrincipalIdFormatResult {
  Principals: PrincipalIdFormat[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePublicIpv4PoolsResult {
  PublicIpv4Pools: PublicIpv4Pool[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRegionsResult {
  Regions: Region[];
}

// refs: 1 - tags: named, output
export interface DescribeReservedInstancesResult {
  ReservedInstances: ReservedInstances[];
}

// refs: 1 - tags: named, output
export interface DescribeReservedInstancesListingsResult {
  ReservedInstancesListings: ReservedInstancesListing[];
}

// refs: 1 - tags: named, output
export interface DescribeReservedInstancesModificationsResult {
  NextToken?: string | null;
  ReservedInstancesModifications: ReservedInstancesModification[];
}

// refs: 1 - tags: named, output
export interface DescribeReservedInstancesOfferingsResult {
  ReservedInstancesOfferings: ReservedInstancesOffering[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRouteTablesResult {
  RouteTables: RouteTable[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeScheduledInstanceAvailabilityResult {
  NextToken?: string | null;
  ScheduledInstanceAvailabilitySet: ScheduledInstanceAvailability[];
}

// refs: 1 - tags: named, output
export interface DescribeScheduledInstancesResult {
  NextToken?: string | null;
  ScheduledInstanceSet: ScheduledInstance[];
}

// refs: 1 - tags: named, output
export interface DescribeSecurityGroupReferencesResult {
  SecurityGroupReferenceSet: SecurityGroupReference[];
}

// refs: 1 - tags: named, output
export interface DescribeSecurityGroupsResult {
  SecurityGroups: SecurityGroup[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSnapshotAttributeResult {
  CreateVolumePermissions: CreateVolumePermission[];
  ProductCodes: ProductCode[];
  SnapshotId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSnapshotsResult {
  Snapshots: Snapshot[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSpotDatafeedSubscriptionResult {
  SpotDatafeedSubscription?: SpotDatafeedSubscription | null;
}

// refs: 1 - tags: named, output
export interface DescribeSpotFleetInstancesResponse {
  ActiveInstances: ActiveInstance[];
  NextToken?: string | null;
  SpotFleetRequestId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSpotFleetRequestHistoryResponse {
  HistoryRecords: HistoryRecord[];
  LastEvaluatedTime?: Date | number | null;
  NextToken?: string | null;
  SpotFleetRequestId?: string | null;
  StartTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeSpotFleetRequestsResponse {
  NextToken?: string | null;
  SpotFleetRequestConfigs: SpotFleetRequestConfig[];
}

// refs: 1 - tags: named, output
export interface DescribeSpotInstanceRequestsResult {
  SpotInstanceRequests: SpotInstanceRequest[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSpotPriceHistoryResult {
  NextToken?: string | null;
  SpotPriceHistory: SpotPrice[];
}

// refs: 1 - tags: named, output
export interface DescribeStaleSecurityGroupsResult {
  NextToken?: string | null;
  StaleSecurityGroupSet: StaleSecurityGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeSubnetsResult {
  Subnets: Subnet[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTagsResult {
  NextToken?: string | null;
  Tags: TagDescription[];
}

// refs: 1 - tags: named, output
export interface DescribeTrafficMirrorFiltersResult {
  TrafficMirrorFilters: TrafficMirrorFilter[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTrafficMirrorSessionsResult {
  TrafficMirrorSessions: TrafficMirrorSession[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTrafficMirrorTargetsResult {
  TrafficMirrorTargets: TrafficMirrorTarget[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewayAttachmentsResult {
  TransitGatewayAttachments: TransitGatewayAttachment[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewayMulticastDomainsResult {
  TransitGatewayMulticastDomains: TransitGatewayMulticastDomain[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewayPeeringAttachmentsResult {
  TransitGatewayPeeringAttachments: TransitGatewayPeeringAttachment[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewayRouteTablesResult {
  TransitGatewayRouteTables: TransitGatewayRouteTable[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewayVpcAttachmentsResult {
  TransitGatewayVpcAttachments: TransitGatewayVpcAttachment[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransitGatewaysResult {
  TransitGateways: TransitGateway[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVolumeAttributeResult {
  AutoEnableIO?: AttributeBooleanValue | null;
  ProductCodes: ProductCode[];
  VolumeId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVolumeStatusResult {
  NextToken?: string | null;
  VolumeStatuses: VolumeStatusItem[];
}

// refs: 1 - tags: named, output
export interface DescribeVolumesResult {
  Volumes: Volume[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVolumesModificationsResult {
  VolumesModifications: VolumeModification[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcAttributeResult {
  VpcId?: string | null;
  EnableDnsHostnames?: AttributeBooleanValue | null;
  EnableDnsSupport?: AttributeBooleanValue | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcClassicLinkResult {
  Vpcs: VpcClassicLink[];
}

// refs: 1 - tags: named, output
export interface DescribeVpcClassicLinkDnsSupportResult {
  NextToken?: string | null;
  Vpcs: ClassicLinkDnsSupport[];
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointConnectionNotificationsResult {
  ConnectionNotificationSet: ConnectionNotification[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointConnectionsResult {
  VpcEndpointConnections: VpcEndpointConnection[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointServiceConfigurationsResult {
  ServiceConfigurations: ServiceConfiguration[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointServicePermissionsResult {
  AllowedPrincipals: AllowedPrincipal[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointServicesResult {
  ServiceNames: string[];
  ServiceDetails: ServiceDetail[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcEndpointsResult {
  VpcEndpoints: VpcEndpoint[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcPeeringConnectionsResult {
  VpcPeeringConnections: VpcPeeringConnection[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpcsResult {
  Vpcs: Vpc[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeVpnConnectionsResult {
  VpnConnections: VpnConnection[];
}

// refs: 1 - tags: named, output
export interface DescribeVpnGatewaysResult {
  VpnGateways: VpnGateway[];
}

// refs: 1 - tags: named, output
export interface DetachClassicLinkVpcResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DisableEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DisableFastSnapshotRestoresResult {
  Successful: DisableFastSnapshotRestoreSuccessItem[];
  Unsuccessful: DisableFastSnapshotRestoreErrorItem[];
}

// refs: 1 - tags: named, output
export interface DisableTransitGatewayRouteTablePropagationResult {
  Propagation?: TransitGatewayPropagation | null;
}

// refs: 1 - tags: named, output
export interface DisableVpcClassicLinkResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DisableVpcClassicLinkDnsSupportResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DisassociateClientVpnTargetNetworkResult {
  AssociationId?: string | null;
  Status?: AssociationStatus | null;
}

// refs: 1 - tags: named, output
export interface DisassociateIamInstanceProfileResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation | null;
}

// refs: 1 - tags: named, output
export interface DisassociateSubnetCidrBlockResult {
  Ipv6CidrBlockAssociation?: SubnetIpv6CidrBlockAssociation | null;
  SubnetId?: string | null;
}

// refs: 1 - tags: named, output
export interface DisassociateTransitGatewayMulticastDomainResult {
  Associations?: TransitGatewayMulticastDomainAssociations | null;
}

// refs: 1 - tags: named, output
export interface DisassociateTransitGatewayRouteTableResult {
  Association?: TransitGatewayAssociation | null;
}

// refs: 1 - tags: named, output
export interface DisassociateVpcCidrBlockResult {
  Ipv6CidrBlockAssociation?: VpcIpv6CidrBlockAssociation | null;
  CidrBlockAssociation?: VpcCidrBlockAssociation | null;
  VpcId?: string | null;
}

// refs: 1 - tags: named, output
export interface EnableEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean | null;
}

// refs: 1 - tags: named, output
export interface EnableFastSnapshotRestoresResult {
  Successful: EnableFastSnapshotRestoreSuccessItem[];
  Unsuccessful: EnableFastSnapshotRestoreErrorItem[];
}

// refs: 1 - tags: named, output
export interface EnableTransitGatewayRouteTablePropagationResult {
  Propagation?: TransitGatewayPropagation | null;
}

// refs: 1 - tags: named, output
export interface EnableVpcClassicLinkResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface EnableVpcClassicLinkDnsSupportResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ExportClientVpnClientCertificateRevocationListResult {
  CertificateRevocationList?: string | null;
  Status?: ClientCertificateRevocationListStatus | null;
}

// refs: 1 - tags: named, output
export interface ExportClientVpnClientConfigurationResult {
  ClientConfiguration?: string | null;
}

// refs: 1 - tags: named, output
export interface ExportImageResult {
  Description?: string | null;
  DiskImageFormat?: DiskImageFormat | null;
  ExportImageTaskId?: string | null;
  ImageId?: string | null;
  RoleName?: string | null;
  Progress?: string | null;
  S3ExportLocation?: ExportTaskS3Location | null;
  Status?: string | null;
  StatusMessage?: string | null;
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface ExportTransitGatewayRoutesResult {
  S3Location?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAssociatedIpv6PoolCidrsResult {
  Ipv6CidrAssociations: Ipv6CidrAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCapacityReservationUsageResult {
  NextToken?: string | null;
  CapacityReservationId?: string | null;
  InstanceType?: string | null;
  TotalInstanceCount?: number | null;
  AvailableInstanceCount?: number | null;
  State?: CapacityReservationState | null;
  InstanceUsages: InstanceUsage[];
}

// refs: 1 - tags: named, output
export interface GetCoipPoolUsageResult {
  CoipPoolId?: string | null;
  CoipAddressUsages: CoipAddressUsage[];
  LocalGatewayRouteTableId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetConsoleOutputResult {
  InstanceId?: string | null;
  Output?: string | null;
  Timestamp?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetConsoleScreenshotResult {
  ImageData?: string | null;
  InstanceId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDefaultCreditSpecificationResult {
  InstanceFamilyCreditSpecification?: InstanceFamilyCreditSpecification | null;
}

// refs: 1 - tags: named, output
export interface GetEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetEbsEncryptionByDefaultResult {
  EbsEncryptionByDefault?: boolean | null;
}

// refs: 1 - tags: named, output
export interface GetGroupsForCapacityReservationResult {
  NextToken?: string | null;
  CapacityReservationGroups: CapacityReservationGroup[];
}

// refs: 1 - tags: named, output
export interface GetHostReservationPurchasePreviewResult {
  CurrencyCode?: CurrencyCodeValues | null;
  Purchase: Purchase[];
  TotalHourlyPrice?: string | null;
  TotalUpfrontPrice?: string | null;
}

// refs: 1 - tags: named, output
export interface GetLaunchTemplateDataResult {
  LaunchTemplateData?: ResponseLaunchTemplateData | null;
}

// refs: 1 - tags: named, output
export interface GetManagedPrefixListAssociationsResult {
  PrefixListAssociations: PrefixListAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetManagedPrefixListEntriesResult {
  Entries: PrefixListEntry[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPasswordDataResult {
  InstanceId?: string | null;
  PasswordData?: string | null;
  Timestamp?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetReservedInstancesExchangeQuoteResult {
  CurrencyCode?: string | null;
  IsValidExchange?: boolean | null;
  OutputReservedInstancesWillExpireAt?: Date | number | null;
  PaymentDue?: string | null;
  ReservedInstanceValueRollup?: ReservationValue | null;
  ReservedInstanceValueSet: ReservedInstanceReservationValue[];
  TargetConfigurationValueRollup?: ReservationValue | null;
  TargetConfigurationValueSet: TargetReservationValue[];
  ValidationFailureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTransitGatewayAttachmentPropagationsResult {
  TransitGatewayAttachmentPropagations: TransitGatewayAttachmentPropagation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTransitGatewayMulticastDomainAssociationsResult {
  MulticastDomainAssociations: TransitGatewayMulticastDomainAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTransitGatewayPrefixListReferencesResult {
  TransitGatewayPrefixListReferences: TransitGatewayPrefixListReference[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTransitGatewayRouteTableAssociationsResult {
  Associations: TransitGatewayRouteTableAssociation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTransitGatewayRouteTablePropagationsResult {
  TransitGatewayRouteTablePropagations: TransitGatewayRouteTablePropagation[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ImportClientVpnClientCertificateRevocationListResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ImportImageResult {
  Architecture?: string | null;
  Description?: string | null;
  Encrypted?: boolean | null;
  Hypervisor?: string | null;
  ImageId?: string | null;
  ImportTaskId?: string | null;
  KmsKeyId?: string | null;
  LicenseType?: string | null;
  Platform?: string | null;
  Progress?: string | null;
  SnapshotDetails: SnapshotDetail[];
  Status?: string | null;
  StatusMessage?: string | null;
  LicenseSpecifications: ImportImageLicenseConfigurationResponse[];
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface ImportInstanceResult {
  ConversionTask?: ConversionTask | null;
}

// refs: 1 - tags: named, output
export interface ImportKeyPairResult {
  KeyFingerprint?: string | null;
  KeyName?: string | null;
  KeyPairId?: string | null;
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface ImportSnapshotResult {
  Description?: string | null;
  ImportTaskId?: string | null;
  SnapshotTaskDetail?: SnapshotTaskDetail | null;
  Tags: Tag[];
}

// refs: 1 - tags: named, output
export interface ImportVolumeResult {
  ConversionTask?: ConversionTask | null;
}

// refs: 1 - tags: named, output
export interface ModifyAvailabilityZoneGroupResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyCapacityReservationResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyClientVpnEndpointResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyDefaultCreditSpecificationResult {
  InstanceFamilyCreditSpecification?: InstanceFamilyCreditSpecification | null;
}

// refs: 1 - tags: named, output
export interface ModifyEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyFleetResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyFpgaImageAttributeResult {
  FpgaImageAttribute?: FpgaImageAttribute | null;
}

// refs: 1 - tags: named, output
export interface ModifyHostsResult {
  Successful: string[];
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface ModifyInstanceCapacityReservationAttributesResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyInstanceCreditSpecificationResult {
  SuccessfulInstanceCreditSpecifications: SuccessfulInstanceCreditSpecificationItem[];
  UnsuccessfulInstanceCreditSpecifications: UnsuccessfulInstanceCreditSpecificationItem[];
}

// refs: 1 - tags: named, output
export interface ModifyInstanceEventStartTimeResult {
  Event?: InstanceStatusEvent | null;
}

// refs: 1 - tags: named, output
export interface ModifyInstanceMetadataOptionsResult {
  InstanceId?: string | null;
  InstanceMetadataOptions?: InstanceMetadataOptionsResponse | null;
}

// refs: 1 - tags: named, output
export interface ModifyInstancePlacementResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyLaunchTemplateResult {
  LaunchTemplate?: LaunchTemplate | null;
}

// refs: 1 - tags: named, output
export interface ModifyManagedPrefixListResult {
  PrefixList?: ManagedPrefixList | null;
}

// refs: 1 - tags: named, output
export interface ModifyReservedInstancesResult {
  ReservedInstancesModificationId?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifySpotFleetRequestResponse {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyTrafficMirrorFilterNetworkServicesResult {
  TrafficMirrorFilter?: TrafficMirrorFilter | null;
}

// refs: 1 - tags: named, output
export interface ModifyTrafficMirrorFilterRuleResult {
  TrafficMirrorFilterRule?: TrafficMirrorFilterRule | null;
}

// refs: 1 - tags: named, output
export interface ModifyTrafficMirrorSessionResult {
  TrafficMirrorSession?: TrafficMirrorSession | null;
}

// refs: 1 - tags: named, output
export interface ModifyTransitGatewayResult {
  TransitGateway?: TransitGateway | null;
}

// refs: 1 - tags: named, output
export interface ModifyTransitGatewayPrefixListReferenceResult {
  TransitGatewayPrefixListReference?: TransitGatewayPrefixListReference | null;
}

// refs: 1 - tags: named, output
export interface ModifyTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment | null;
}

// refs: 1 - tags: named, output
export interface ModifyVolumeResult {
  VolumeModification?: VolumeModification | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcEndpointResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcEndpointConnectionNotificationResult {
  ReturnValue?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcEndpointServiceConfigurationResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcEndpointServicePermissionsResult {
  ReturnValue?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcPeeringConnectionOptionsResult {
  AccepterPeeringConnectionOptions?: PeeringConnectionOptions | null;
  RequesterPeeringConnectionOptions?: PeeringConnectionOptions | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpcTenancyResult {
  ReturnValue?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpnConnectionResult {
  VpnConnection?: VpnConnection | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpnConnectionOptionsResult {
  VpnConnection?: VpnConnection | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpnTunnelCertificateResult {
  VpnConnection?: VpnConnection | null;
}

// refs: 1 - tags: named, output
export interface ModifyVpnTunnelOptionsResult {
  VpnConnection?: VpnConnection | null;
}

// refs: 1 - tags: named, output
export interface MonitorInstancesResult {
  InstanceMonitorings: InstanceMonitoring[];
}

// refs: 1 - tags: named, output
export interface MoveAddressToVpcResult {
  AllocationId?: string | null;
  Status?: Status | null;
}

// refs: 1 - tags: named, output
export interface ProvisionByoipCidrResult {
  ByoipCidr?: ByoipCidr | null;
}

// refs: 1 - tags: named, output
export interface PurchaseHostReservationResult {
  ClientToken?: string | null;
  CurrencyCode?: CurrencyCodeValues | null;
  Purchase: Purchase[];
  TotalHourlyPrice?: string | null;
  TotalUpfrontPrice?: string | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedInstancesOfferingResult {
  ReservedInstancesId?: string | null;
}

// refs: 1 - tags: named, output
export interface PurchaseScheduledInstancesResult {
  ScheduledInstanceSet: ScheduledInstance[];
}

// refs: 1 - tags: named, output
export interface RegisterImageResult {
  ImageId?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterInstanceEventNotificationAttributesResult {
  InstanceTagAttribute?: InstanceTagNotificationAttribute | null;
}

// refs: 1 - tags: named, output
export interface RegisterTransitGatewayMulticastGroupMembersResult {
  RegisteredMulticastGroupMembers?: TransitGatewayMulticastRegisteredGroupMembers | null;
}

// refs: 1 - tags: named, output
export interface RegisterTransitGatewayMulticastGroupSourcesResult {
  RegisteredMulticastGroupSources?: TransitGatewayMulticastRegisteredGroupSources | null;
}

// refs: 1 - tags: named, output
export interface RejectTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment | null;
}

// refs: 1 - tags: named, output
export interface RejectTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment | null;
}

// refs: 1 - tags: named, output
export interface RejectVpcEndpointConnectionsResult {
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface RejectVpcPeeringConnectionResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ReleaseHostsResult {
  Successful: string[];
  Unsuccessful: UnsuccessfulItem[];
}

// refs: 1 - tags: named, output
export interface ReplaceIamInstanceProfileAssociationResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation | null;
}

// refs: 1 - tags: named, output
export interface ReplaceNetworkAclAssociationResult {
  NewAssociationId?: string | null;
}

// refs: 1 - tags: named, output
export interface ReplaceRouteTableAssociationResult {
  NewAssociationId?: string | null;
  AssociationState?: RouteTableAssociationState | null;
}

// refs: 1 - tags: named, output
export interface ReplaceTransitGatewayRouteResult {
  Route?: TransitGatewayRoute | null;
}

// refs: 1 - tags: named, output
export interface RequestSpotFleetResponse {
  SpotFleetRequestId?: string | null;
}

// refs: 1 - tags: named, output
export interface RequestSpotInstancesResult {
  SpotInstanceRequests: SpotInstanceRequest[];
}

// refs: 1 - tags: named, output
export interface ResetEbsDefaultKmsKeyIdResult {
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface ResetFpgaImageAttributeResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface RestoreAddressToClassicResult {
  PublicIp?: string | null;
  Status?: Status | null;
}

// refs: 1 - tags: named, output
export interface RestoreManagedPrefixListVersionResult {
  PrefixList?: ManagedPrefixList | null;
}

// refs: 1 - tags: named, output
export interface RevokeClientVpnIngressResult {
  Status?: ClientVpnAuthorizationRuleStatus | null;
}

// refs: 1 - tags: named, output
export interface RevokeSecurityGroupEgressResult {
  Return?: boolean | null;
  UnknownIpPermissions: IpPermission[];
}

// refs: 1 - tags: named, output
export interface RevokeSecurityGroupIngressResult {
  Return?: boolean | null;
  UnknownIpPermissions: IpPermission[];
}

// refs: 2 - tags: output, named, interface
export interface Reservation {
  Groups: GroupIdentifier[];
  Instances: Instance[];
  OwnerId?: string | null;
  RequesterId?: string | null;
  ReservationId?: string | null;
}
function Reservation_Parse(node: xmlP.XmlNode): Reservation {
  return {
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    Instances: node.getList("instancesSet", "item").map(Instance_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    RequesterId: node.first("requesterId", false, x => x.content ?? ''),
    ReservationId: node.first("reservationId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: named, output
export interface RunScheduledInstancesResult {
  InstanceIdSet: string[];
}

// refs: 1 - tags: named, output
export interface SearchLocalGatewayRoutesResult {
  Routes: LocalGatewayRoute[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface SearchTransitGatewayMulticastGroupsResult {
  MulticastGroups: TransitGatewayMulticastGroup[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface SearchTransitGatewayRoutesResult {
  Routes: TransitGatewayRoute[];
  AdditionalRoutesAvailable?: boolean | null;
}

// refs: 1 - tags: named, output
export interface StartInstancesResult {
  StartingInstances: InstanceStateChange[];
}

// refs: 1 - tags: named, output
export interface StartVpcEndpointServicePrivateDnsVerificationResult {
  ReturnValue?: boolean | null;
}

// refs: 1 - tags: named, output
export interface StopInstancesResult {
  StoppingInstances: InstanceStateChange[];
}

// refs: 1 - tags: named, output
export interface TerminateClientVpnConnectionsResult {
  ClientVpnEndpointId?: string | null;
  Username?: string | null;
  ConnectionStatuses: TerminateConnectionStatus[];
}

// refs: 1 - tags: named, output
export interface TerminateInstancesResult {
  TerminatingInstances: InstanceStateChange[];
}

// refs: 1 - tags: named, output
export interface UnassignIpv6AddressesResult {
  NetworkInterfaceId?: string | null;
  UnassignedIpv6Addresses: string[];
}

// refs: 1 - tags: named, output
export interface UnmonitorInstancesResult {
  InstanceMonitorings: InstanceMonitoring[];
}

// refs: 1 - tags: named, output
export interface UpdateSecurityGroupRuleDescriptionsEgressResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface UpdateSecurityGroupRuleDescriptionsIngressResult {
  Return?: boolean | null;
}

// refs: 1 - tags: named, output
export interface WithdrawByoipCidrResult {
  ByoipCidr?: ByoipCidr | null;
}

// refs: 2 - tags: input, named, interface
export interface TargetConfigurationRequest {
  InstanceCount?: number | null;
  OfferingId: string;
}
function TargetConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: TargetConfigurationRequest) {
    if ("InstanceCount" in params) body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+".OfferingId", (params["OfferingId"] ?? '').toString());
}

// refs: 3 - tags: input, named, enum, output
export type DomainType =
| "vpc"
| "standard"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type AutoPlacement =
| "on"
| "off"
| cmnP.UnexpectedEnumValue;

// refs: 51 - tags: input, named, interface, output
export interface TagSpecification {
  ResourceType?: ResourceType | null;
  Tags: Tag[];
}
function TagSpecification_Serialize(body: URLSearchParams, prefix: string, params: TagSpecification) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}
function TagSpecification_Parse(node: xmlP.XmlNode): TagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as ResourceType),
    Tags: node.getList("Tag", "item").map(Tag_Parse),
  };
}

// refs: 59 - tags: input, named, enum, output
export type ResourceType =
| "client-vpn-endpoint"
| "customer-gateway"
| "dedicated-host"
| "dhcp-options"
| "egress-only-internet-gateway"
| "elastic-ip"
| "elastic-gpu"
| "export-image-task"
| "export-instance-task"
| "fleet"
| "fpga-image"
| "host-reservation"
| "image"
| "import-image-task"
| "import-snapshot-task"
| "instance"
| "internet-gateway"
| "key-pair"
| "launch-template"
| "local-gateway-route-table-vpc-association"
| "natgateway"
| "network-acl"
| "network-interface"
| "placement-group"
| "reserved-instances"
| "route-table"
| "security-group"
| "snapshot"
| "spot-fleet-request"
| "spot-instances-request"
| "subnet"
| "traffic-mirror-filter"
| "traffic-mirror-session"
| "traffic-mirror-target"
| "transit-gateway"
| "transit-gateway-attachment"
| "transit-gateway-multicast-domain"
| "transit-gateway-route-table"
| "volume"
| "vpc"
| "vpc-peering-connection"
| "vpn-connection"
| "vpn-gateway"
| "vpc-flow-log"
| cmnP.UnexpectedEnumValue;

// refs: 197 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, enum, output
export type HostRecovery =
| "on"
| "off"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface IamInstanceProfileSpecification {
  Arn?: string | null;
  Name?: string | null;
}
function IamInstanceProfileSpecification_Serialize(body: URLSearchParams, prefix: string, params: IamInstanceProfileSpecification) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function IamInstanceProfileSpecification_Parse(node: xmlP.XmlNode): IamInstanceProfileSpecification {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface IpPermission {
  FromPort?: number | null;
  IpProtocol?: string | null;
  IpRanges: IpRange[];
  Ipv6Ranges: Ipv6Range[];
  PrefixListIds: PrefixListId[];
  ToPort?: number | null;
  UserIdGroupPairs: UserIdGroupPair[];
}
function IpPermission_Serialize(body: URLSearchParams, prefix: string, params: IpPermission) {
    if ("FromPort" in params) body.append(prefix+".FromPort", (params["FromPort"] ?? '').toString());
    if ("IpProtocol" in params) body.append(prefix+".IpProtocol", (params["IpProtocol"] ?? '').toString());
    if (params["IpRanges"]) qsP.appendList(body, prefix+".ipRanges", params["IpRanges"], {"appender":IpRange_Serialize,"entryPrefix":"."})
    if (params["Ipv6Ranges"]) qsP.appendList(body, prefix+".ipv6Ranges", params["Ipv6Ranges"], {"appender":Ipv6Range_Serialize,"entryPrefix":"."})
    if (params["PrefixListIds"]) qsP.appendList(body, prefix+".prefixListIds", params["PrefixListIds"], {"appender":PrefixListId_Serialize,"entryPrefix":"."})
    if ("ToPort" in params) body.append(prefix+".ToPort", (params["ToPort"] ?? '').toString());
    if (params["UserIdGroupPairs"]) qsP.appendList(body, prefix+".groups", params["UserIdGroupPairs"], {"appender":UserIdGroupPair_Serialize,"entryPrefix":"."})
}
function IpPermission_Parse(node: xmlP.XmlNode): IpPermission {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    IpProtocol: node.first("ipProtocol", false, x => x.content ?? ''),
    IpRanges: node.getList("ipRanges", "item").map(IpRange_Parse),
    Ipv6Ranges: node.getList("ipv6Ranges", "item").map(Ipv6Range_Parse),
    PrefixListIds: node.getList("prefixListIds", "item").map(PrefixListId_Parse),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
    UserIdGroupPairs: node.getList("groups", "item").map(UserIdGroupPair_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface IpRange {
  CidrIp?: string | null;
  Description?: string | null;
}
function IpRange_Serialize(body: URLSearchParams, prefix: string, params: IpRange) {
    if ("CidrIp" in params) body.append(prefix+".CidrIp", (params["CidrIp"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}
function IpRange_Parse(node: xmlP.XmlNode): IpRange {
  return {
    CidrIp: node.first("cidrIp", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface Ipv6Range {
  CidrIpv6?: string | null;
  Description?: string | null;
}
function Ipv6Range_Serialize(body: URLSearchParams, prefix: string, params: Ipv6Range) {
    if ("CidrIpv6" in params) body.append(prefix+".CidrIpv6", (params["CidrIpv6"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}
function Ipv6Range_Parse(node: xmlP.XmlNode): Ipv6Range {
  return {
    CidrIpv6: node.first("cidrIpv6", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface PrefixListId {
  Description?: string | null;
  PrefixListId?: string | null;
}
function PrefixListId_Serialize(body: URLSearchParams, prefix: string, params: PrefixListId) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("PrefixListId" in params) body.append(prefix+".PrefixListId", (params["PrefixListId"] ?? '').toString());
}
function PrefixListId_Parse(node: xmlP.XmlNode): PrefixListId {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
  };
}

// refs: 12 - tags: input, named, interface, output
export interface UserIdGroupPair {
  Description?: string | null;
  GroupId?: string | null;
  GroupName?: string | null;
  PeeringStatus?: string | null;
  UserId?: string | null;
  VpcId?: string | null;
  VpcPeeringConnectionId?: string | null;
}
function UserIdGroupPair_Serialize(body: URLSearchParams, prefix: string, params: UserIdGroupPair) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+".GroupId", (params["GroupId"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("PeeringStatus" in params) body.append(prefix+".PeeringStatus", (params["PeeringStatus"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+".VpcId", (params["VpcId"] ?? '').toString());
    if ("VpcPeeringConnectionId" in params) body.append(prefix+".VpcPeeringConnectionId", (params["VpcPeeringConnectionId"] ?? '').toString());
}
function UserIdGroupPair_Parse(node: xmlP.XmlNode): UserIdGroupPair {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    PeeringStatus: node.first("peeringStatus", false, x => x.content ?? ''),
    UserId: node.first("userId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface Storage {
  S3?: S3Storage | null;
}
function Storage_Serialize(body: URLSearchParams, prefix: string, params: Storage) {
    if (params["S3"] != null) S3Storage_Serialize(body, prefix+".S3", params["S3"]);
}
function Storage_Parse(node: xmlP.XmlNode): Storage {
  return {
    S3: node.first("S3", false, S3Storage_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface S3Storage {
  AWSAccessKeyId?: string | null;
  Bucket?: string | null;
  Prefix?: string | null;
  UploadPolicy?: Uint8Array | string | null;
  UploadPolicySignature?: string | null;
}
function S3Storage_Serialize(body: URLSearchParams, prefix: string, params: S3Storage) {
    if ("AWSAccessKeyId" in params) body.append(prefix+".AWSAccessKeyId", (params["AWSAccessKeyId"] ?? '').toString());
    if ("Bucket" in params) body.append(prefix+".Bucket", (params["Bucket"] ?? '').toString());
    if ("Prefix" in params) body.append(prefix+".Prefix", (params["Prefix"] ?? '').toString());
    if ("UploadPolicy" in params) body.append(prefix+".UploadPolicy", qsP.encodeBlob(params["UploadPolicy"]));
    if ("UploadPolicySignature" in params) body.append(prefix+".UploadPolicySignature", (params["UploadPolicySignature"] ?? '').toString());
}
function S3Storage_Parse(node: xmlP.XmlNode): S3Storage {
  return {
    ...node.strings({
      optional: {"AWSAccessKeyId":true},
    }),
    Bucket: node.first("bucket", false, x => x.content ?? ''),
    Prefix: node.first("prefix", false, x => x.content ?? ''),
    UploadPolicy: node.first("uploadPolicy", false, x => Base64.toUint8Array(x.content ?? '')),
    UploadPolicySignature: node.first("uploadPolicySignature", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, enum, output
export type CapacityReservationInstancePlatform =
| "Linux/UNIX"
| "Red Hat Enterprise Linux"
| "SUSE Linux"
| "Windows"
| "Windows with SQL Server"
| "Windows with SQL Server Enterprise"
| "Windows with SQL Server Standard"
| "Windows with SQL Server Web"
| "Linux with SQL Server Standard"
| "Linux with SQL Server Web"
| "Linux with SQL Server Enterprise"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CapacityReservationTenancy =
| "default"
| "dedicated"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type EndDateType =
| "unlimited"
| "limited"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type InstanceMatchCriteria =
| "open"
| "targeted"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ClientVpnAuthenticationRequest {
  Type?: ClientVpnAuthenticationType | null;
  ActiveDirectory?: DirectoryServiceAuthenticationRequest | null;
  MutualAuthentication?: CertificateAuthenticationRequest | null;
  FederatedAuthentication?: FederatedAuthenticationRequest | null;
}
function ClientVpnAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: ClientVpnAuthenticationRequest) {
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if (params["ActiveDirectory"] != null) DirectoryServiceAuthenticationRequest_Serialize(body, prefix+".ActiveDirectory", params["ActiveDirectory"]);
    if (params["MutualAuthentication"] != null) CertificateAuthenticationRequest_Serialize(body, prefix+".MutualAuthentication", params["MutualAuthentication"]);
    if (params["FederatedAuthentication"] != null) FederatedAuthenticationRequest_Serialize(body, prefix+".FederatedAuthentication", params["FederatedAuthentication"]);
}

// refs: 2 - tags: input, named, enum, output
export type ClientVpnAuthenticationType =
| "certificate-authentication"
| "directory-service-authentication"
| "federated-authentication"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DirectoryServiceAuthenticationRequest {
  DirectoryId?: string | null;
}
function DirectoryServiceAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: DirectoryServiceAuthenticationRequest) {
    if ("DirectoryId" in params) body.append(prefix+".DirectoryId", (params["DirectoryId"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface CertificateAuthenticationRequest {
  ClientRootCertificateChainArn?: string | null;
}
function CertificateAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: CertificateAuthenticationRequest) {
    if ("ClientRootCertificateChainArn" in params) body.append(prefix+".ClientRootCertificateChainArn", (params["ClientRootCertificateChainArn"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface FederatedAuthenticationRequest {
  SAMLProviderArn?: string | null;
}
function FederatedAuthenticationRequest_Serialize(body: URLSearchParams, prefix: string, params: FederatedAuthenticationRequest) {
    if ("SAMLProviderArn" in params) body.append(prefix+".SAMLProviderArn", (params["SAMLProviderArn"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface ConnectionLogOptions {
  Enabled?: boolean | null;
  CloudwatchLogGroup?: string | null;
  CloudwatchLogStream?: string | null;
}
function ConnectionLogOptions_Serialize(body: URLSearchParams, prefix: string, params: ConnectionLogOptions) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("CloudwatchLogGroup" in params) body.append(prefix+".CloudwatchLogGroup", (params["CloudwatchLogGroup"] ?? '').toString());
    if ("CloudwatchLogStream" in params) body.append(prefix+".CloudwatchLogStream", (params["CloudwatchLogStream"] ?? '').toString());
}

// refs: 2 - tags: input, named, enum, output
export type TransportProtocol =
| "tcp"
| "udp"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type GatewayType =
| "ipsec.1"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface NewDhcpConfiguration {
  Key?: string | null;
  Values?: string[] | null;
}
function NewDhcpConfiguration_Serialize(body: URLSearchParams, prefix: string, params: NewDhcpConfiguration) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":"."})
}

// refs: 1 - tags: input, named, interface
export interface SpotOptionsRequest {
  AllocationStrategy?: SpotAllocationStrategy | null;
  InstanceInterruptionBehavior?: SpotInstanceInterruptionBehavior | null;
  InstancePoolsToUseCount?: number | null;
  SingleInstanceType?: boolean | null;
  SingleAvailabilityZone?: boolean | null;
  MinTargetCapacity?: number | null;
  MaxTotalPrice?: string | null;
}
function SpotOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: SpotOptionsRequest) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    if ("InstancePoolsToUseCount" in params) body.append(prefix+".InstancePoolsToUseCount", (params["InstancePoolsToUseCount"] ?? '').toString());
    if ("SingleInstanceType" in params) body.append(prefix+".SingleInstanceType", (params["SingleInstanceType"] ?? '').toString());
    if ("SingleAvailabilityZone" in params) body.append(prefix+".SingleAvailabilityZone", (params["SingleAvailabilityZone"] ?? '').toString());
    if ("MinTargetCapacity" in params) body.append(prefix+".MinTargetCapacity", (params["MinTargetCapacity"] ?? '').toString());
    if ("MaxTotalPrice" in params) body.append(prefix+".MaxTotalPrice", (params["MaxTotalPrice"] ?? '').toString());
}

// refs: 2 - tags: input, named, enum, output
export type SpotAllocationStrategy =
| "lowest-price"
| "diversified"
| "capacity-optimized"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type SpotInstanceInterruptionBehavior =
| "hibernate"
| "stop"
| "terminate"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface OnDemandOptionsRequest {
  AllocationStrategy?: FleetOnDemandAllocationStrategy | null;
  CapacityReservationOptions?: CapacityReservationOptionsRequest | null;
  SingleInstanceType?: boolean | null;
  SingleAvailabilityZone?: boolean | null;
  MinTargetCapacity?: number | null;
  MaxTotalPrice?: string | null;
}
function OnDemandOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: OnDemandOptionsRequest) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if (params["CapacityReservationOptions"] != null) CapacityReservationOptionsRequest_Serialize(body, prefix+".CapacityReservationOptions", params["CapacityReservationOptions"]);
    if ("SingleInstanceType" in params) body.append(prefix+".SingleInstanceType", (params["SingleInstanceType"] ?? '').toString());
    if ("SingleAvailabilityZone" in params) body.append(prefix+".SingleAvailabilityZone", (params["SingleAvailabilityZone"] ?? '').toString());
    if ("MinTargetCapacity" in params) body.append(prefix+".MinTargetCapacity", (params["MinTargetCapacity"] ?? '').toString());
    if ("MaxTotalPrice" in params) body.append(prefix+".MaxTotalPrice", (params["MaxTotalPrice"] ?? '').toString());
}

// refs: 2 - tags: input, named, enum, output
export type FleetOnDemandAllocationStrategy =
| "lowest-price"
| "prioritized"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CapacityReservationOptionsRequest {
  UsageStrategy?: FleetCapacityReservationUsageStrategy | null;
}
function CapacityReservationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: CapacityReservationOptionsRequest) {
    if ("UsageStrategy" in params) body.append(prefix+".UsageStrategy", (params["UsageStrategy"] ?? '').toString());
}

// refs: 2 - tags: input, named, enum, output
export type FleetCapacityReservationUsageStrategy =
| "use-capacity-reservations-first"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type FleetExcessCapacityTerminationPolicy =
| "no-termination"
| "termination"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface FleetLaunchTemplateConfigRequest {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecificationRequest | null;
  Overrides?: FleetLaunchTemplateOverridesRequest[] | null;
}
function FleetLaunchTemplateConfigRequest_Serialize(body: URLSearchParams, prefix: string, params: FleetLaunchTemplateConfigRequest) {
    if (params["LaunchTemplateSpecification"] != null) FleetLaunchTemplateSpecificationRequest_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".item", params["Overrides"], {"appender":FleetLaunchTemplateOverridesRequest_Serialize,"entryPrefix":"."})
}

// refs: 2 - tags: input, named, interface
export interface FleetLaunchTemplateSpecificationRequest {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Version?: string | null;
}
function FleetLaunchTemplateSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: FleetLaunchTemplateSpecificationRequest) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface FleetLaunchTemplateOverridesRequest {
  InstanceType?: InstanceType | null;
  MaxPrice?: string | null;
  SubnetId?: string | null;
  AvailabilityZone?: string | null;
  WeightedCapacity?: number | null;
  Priority?: number | null;
  Placement?: Placement | null;
}
function FleetLaunchTemplateOverridesRequest_Serialize(body: URLSearchParams, prefix: string, params: FleetLaunchTemplateOverridesRequest) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
    if (params["Placement"] != null) Placement_Serialize(body, prefix+".Placement", params["Placement"]);
}

// refs: 36 - tags: input, named, enum, output
export type InstanceType =
| "t1.micro"
| "t2.nano"
| "t2.micro"
| "t2.small"
| "t2.medium"
| "t2.large"
| "t2.xlarge"
| "t2.2xlarge"
| "t3.nano"
| "t3.micro"
| "t3.small"
| "t3.medium"
| "t3.large"
| "t3.xlarge"
| "t3.2xlarge"
| "t3a.nano"
| "t3a.micro"
| "t3a.small"
| "t3a.medium"
| "t3a.large"
| "t3a.xlarge"
| "t3a.2xlarge"
| "t4g.nano"
| "t4g.micro"
| "t4g.small"
| "t4g.medium"
| "t4g.large"
| "t4g.xlarge"
| "t4g.2xlarge"
| "m1.small"
| "m1.medium"
| "m1.large"
| "m1.xlarge"
| "m3.medium"
| "m3.large"
| "m3.xlarge"
| "m3.2xlarge"
| "m4.large"
| "m4.xlarge"
| "m4.2xlarge"
| "m4.4xlarge"
| "m4.10xlarge"
| "m4.16xlarge"
| "m2.xlarge"
| "m2.2xlarge"
| "m2.4xlarge"
| "cr1.8xlarge"
| "r3.large"
| "r3.xlarge"
| "r3.2xlarge"
| "r3.4xlarge"
| "r3.8xlarge"
| "r4.large"
| "r4.xlarge"
| "r4.2xlarge"
| "r4.4xlarge"
| "r4.8xlarge"
| "r4.16xlarge"
| "r5.large"
| "r5.xlarge"
| "r5.2xlarge"
| "r5.4xlarge"
| "r5.8xlarge"
| "r5.12xlarge"
| "r5.16xlarge"
| "r5.24xlarge"
| "r5.metal"
| "r5a.large"
| "r5a.xlarge"
| "r5a.2xlarge"
| "r5a.4xlarge"
| "r5a.8xlarge"
| "r5a.12xlarge"
| "r5a.16xlarge"
| "r5a.24xlarge"
| "r5d.large"
| "r5d.xlarge"
| "r5d.2xlarge"
| "r5d.4xlarge"
| "r5d.8xlarge"
| "r5d.12xlarge"
| "r5d.16xlarge"
| "r5d.24xlarge"
| "r5d.metal"
| "r5ad.large"
| "r5ad.xlarge"
| "r5ad.2xlarge"
| "r5ad.4xlarge"
| "r5ad.8xlarge"
| "r5ad.12xlarge"
| "r5ad.16xlarge"
| "r5ad.24xlarge"
| "r6g.metal"
| "r6g.medium"
| "r6g.large"
| "r6g.xlarge"
| "r6g.2xlarge"
| "r6g.4xlarge"
| "r6g.8xlarge"
| "r6g.12xlarge"
| "r6g.16xlarge"
| "r6gd.metal"
| "r6gd.medium"
| "r6gd.large"
| "r6gd.xlarge"
| "r6gd.2xlarge"
| "r6gd.4xlarge"
| "r6gd.8xlarge"
| "r6gd.12xlarge"
| "r6gd.16xlarge"
| "x1.16xlarge"
| "x1.32xlarge"
| "x1e.xlarge"
| "x1e.2xlarge"
| "x1e.4xlarge"
| "x1e.8xlarge"
| "x1e.16xlarge"
| "x1e.32xlarge"
| "i2.xlarge"
| "i2.2xlarge"
| "i2.4xlarge"
| "i2.8xlarge"
| "i3.large"
| "i3.xlarge"
| "i3.2xlarge"
| "i3.4xlarge"
| "i3.8xlarge"
| "i3.16xlarge"
| "i3.metal"
| "i3en.large"
| "i3en.xlarge"
| "i3en.2xlarge"
| "i3en.3xlarge"
| "i3en.6xlarge"
| "i3en.12xlarge"
| "i3en.24xlarge"
| "i3en.metal"
| "hi1.4xlarge"
| "hs1.8xlarge"
| "c1.medium"
| "c1.xlarge"
| "c3.large"
| "c3.xlarge"
| "c3.2xlarge"
| "c3.4xlarge"
| "c3.8xlarge"
| "c4.large"
| "c4.xlarge"
| "c4.2xlarge"
| "c4.4xlarge"
| "c4.8xlarge"
| "c5.large"
| "c5.xlarge"
| "c5.2xlarge"
| "c5.4xlarge"
| "c5.9xlarge"
| "c5.12xlarge"
| "c5.18xlarge"
| "c5.24xlarge"
| "c5.metal"
| "c5a.large"
| "c5a.xlarge"
| "c5a.2xlarge"
| "c5a.4xlarge"
| "c5a.8xlarge"
| "c5a.12xlarge"
| "c5a.16xlarge"
| "c5a.24xlarge"
| "c5ad.large"
| "c5ad.xlarge"
| "c5ad.2xlarge"
| "c5ad.4xlarge"
| "c5ad.8xlarge"
| "c5ad.12xlarge"
| "c5ad.16xlarge"
| "c5ad.24xlarge"
| "c5d.large"
| "c5d.xlarge"
| "c5d.2xlarge"
| "c5d.4xlarge"
| "c5d.9xlarge"
| "c5d.12xlarge"
| "c5d.18xlarge"
| "c5d.24xlarge"
| "c5d.metal"
| "c5n.large"
| "c5n.xlarge"
| "c5n.2xlarge"
| "c5n.4xlarge"
| "c5n.9xlarge"
| "c5n.18xlarge"
| "c6g.metal"
| "c6g.medium"
| "c6g.large"
| "c6g.xlarge"
| "c6g.2xlarge"
| "c6g.4xlarge"
| "c6g.8xlarge"
| "c6g.12xlarge"
| "c6g.16xlarge"
| "c6gd.metal"
| "c6gd.medium"
| "c6gd.large"
| "c6gd.xlarge"
| "c6gd.2xlarge"
| "c6gd.4xlarge"
| "c6gd.8xlarge"
| "c6gd.12xlarge"
| "c6gd.16xlarge"
| "cc1.4xlarge"
| "cc2.8xlarge"
| "g2.2xlarge"
| "g2.8xlarge"
| "g3.4xlarge"
| "g3.8xlarge"
| "g3.16xlarge"
| "g3s.xlarge"
| "g4dn.xlarge"
| "g4dn.2xlarge"
| "g4dn.4xlarge"
| "g4dn.8xlarge"
| "g4dn.12xlarge"
| "g4dn.16xlarge"
| "g4dn.metal"
| "cg1.4xlarge"
| "p2.xlarge"
| "p2.8xlarge"
| "p2.16xlarge"
| "p3.2xlarge"
| "p3.8xlarge"
| "p3.16xlarge"
| "p3dn.24xlarge"
| "d2.xlarge"
| "d2.2xlarge"
| "d2.4xlarge"
| "d2.8xlarge"
| "f1.2xlarge"
| "f1.4xlarge"
| "f1.16xlarge"
| "m5.large"
| "m5.xlarge"
| "m5.2xlarge"
| "m5.4xlarge"
| "m5.8xlarge"
| "m5.12xlarge"
| "m5.16xlarge"
| "m5.24xlarge"
| "m5.metal"
| "m5a.large"
| "m5a.xlarge"
| "m5a.2xlarge"
| "m5a.4xlarge"
| "m5a.8xlarge"
| "m5a.12xlarge"
| "m5a.16xlarge"
| "m5a.24xlarge"
| "m5d.large"
| "m5d.xlarge"
| "m5d.2xlarge"
| "m5d.4xlarge"
| "m5d.8xlarge"
| "m5d.12xlarge"
| "m5d.16xlarge"
| "m5d.24xlarge"
| "m5d.metal"
| "m5ad.large"
| "m5ad.xlarge"
| "m5ad.2xlarge"
| "m5ad.4xlarge"
| "m5ad.8xlarge"
| "m5ad.12xlarge"
| "m5ad.16xlarge"
| "m5ad.24xlarge"
| "h1.2xlarge"
| "h1.4xlarge"
| "h1.8xlarge"
| "h1.16xlarge"
| "z1d.large"
| "z1d.xlarge"
| "z1d.2xlarge"
| "z1d.3xlarge"
| "z1d.6xlarge"
| "z1d.12xlarge"
| "z1d.metal"
| "u-6tb1.metal"
| "u-9tb1.metal"
| "u-12tb1.metal"
| "u-18tb1.metal"
| "u-24tb1.metal"
| "a1.medium"
| "a1.large"
| "a1.xlarge"
| "a1.2xlarge"
| "a1.4xlarge"
| "a1.metal"
| "m5dn.large"
| "m5dn.xlarge"
| "m5dn.2xlarge"
| "m5dn.4xlarge"
| "m5dn.8xlarge"
| "m5dn.12xlarge"
| "m5dn.16xlarge"
| "m5dn.24xlarge"
| "m5n.large"
| "m5n.xlarge"
| "m5n.2xlarge"
| "m5n.4xlarge"
| "m5n.8xlarge"
| "m5n.12xlarge"
| "m5n.16xlarge"
| "m5n.24xlarge"
| "r5dn.large"
| "r5dn.xlarge"
| "r5dn.2xlarge"
| "r5dn.4xlarge"
| "r5dn.8xlarge"
| "r5dn.12xlarge"
| "r5dn.16xlarge"
| "r5dn.24xlarge"
| "r5n.large"
| "r5n.xlarge"
| "r5n.2xlarge"
| "r5n.4xlarge"
| "r5n.8xlarge"
| "r5n.12xlarge"
| "r5n.16xlarge"
| "r5n.24xlarge"
| "inf1.xlarge"
| "inf1.2xlarge"
| "inf1.6xlarge"
| "inf1.24xlarge"
| "m6g.metal"
| "m6g.medium"
| "m6g.large"
| "m6g.xlarge"
| "m6g.2xlarge"
| "m6g.4xlarge"
| "m6g.8xlarge"
| "m6g.12xlarge"
| "m6g.16xlarge"
| "m6gd.metal"
| "m6gd.medium"
| "m6gd.large"
| "m6gd.xlarge"
| "m6gd.2xlarge"
| "m6gd.4xlarge"
| "m6gd.8xlarge"
| "m6gd.12xlarge"
| "m6gd.16xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Placement {
  AvailabilityZone?: string | null;
  Affinity?: string | null;
  GroupName?: string | null;
  PartitionNumber?: number | null;
  HostId?: string | null;
  Tenancy?: Tenancy | null;
  SpreadDomain?: string | null;
  HostResourceGroupArn?: string | null;
}
function Placement_Serialize(body: URLSearchParams, prefix: string, params: Placement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Affinity" in params) body.append(prefix+".Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+".PartitionNumber", (params["PartitionNumber"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+".HostId", (params["HostId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
    if ("SpreadDomain" in params) body.append(prefix+".SpreadDomain", (params["SpreadDomain"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+".HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
}
function Placement_Parse(node: xmlP.XmlNode): Placement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Affinity: node.first("affinity", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    PartitionNumber: node.first("partitionNumber", false, x => parseInt(x.content ?? '0')),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as Tenancy),
    SpreadDomain: node.first("spreadDomain", false, x => x.content ?? ''),
    HostResourceGroupArn: node.first("hostResourceGroupArn", false, x => x.content ?? ''),
  };
}

// refs: 23 - tags: input, named, enum, output
export type Tenancy =
| "default"
| "dedicated"
| "host"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface TargetCapacitySpecificationRequest {
  TotalTargetCapacity: number;
  OnDemandTargetCapacity?: number | null;
  SpotTargetCapacity?: number | null;
  DefaultTargetCapacityType?: DefaultTargetCapacityType | null;
}
function TargetCapacitySpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: TargetCapacitySpecificationRequest) {
    body.append(prefix+".TotalTargetCapacity", (params["TotalTargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+".OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    if ("SpotTargetCapacity" in params) body.append(prefix+".SpotTargetCapacity", (params["SpotTargetCapacity"] ?? '').toString());
    if ("DefaultTargetCapacityType" in params) body.append(prefix+".DefaultTargetCapacityType", (params["DefaultTargetCapacityType"] ?? '').toString());
}

// refs: 3 - tags: input, named, enum, output
export type DefaultTargetCapacityType =
| "spot"
| "on-demand"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type FleetType =
| "request"
| "maintain"
| "instant"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type FlowLogsResourceType =
| "VPC"
| "Subnet"
| "NetworkInterface"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type TrafficType =
| "ACCEPT"
| "REJECT"
| "ALL"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type LogDestinationType =
| "cloud-watch-logs"
| "s3"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface StorageLocation {
  Bucket?: string | null;
  Key?: string | null;
}
function StorageLocation_Serialize(body: URLSearchParams, prefix: string, params: StorageLocation) {
    if ("Bucket" in params) body.append(prefix+".Bucket", (params["Bucket"] ?? '').toString());
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
}

// refs: 10 - tags: input, named, interface, output
export interface BlockDeviceMapping {
  DeviceName?: string | null;
  VirtualName?: string | null;
  Ebs?: EbsBlockDevice | null;
  NoDevice?: string | null;
}
function BlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: BlockDeviceMapping) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    if (params["Ebs"] != null) EbsBlockDevice_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}
function BlockDeviceMapping_Parse(node: xmlP.XmlNode): BlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    VirtualName: node.first("virtualName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, EbsBlockDevice_Parse),
    NoDevice: node.first("noDevice", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface EbsBlockDevice {
  DeleteOnTermination?: boolean | null;
  Iops?: number | null;
  SnapshotId?: string | null;
  VolumeSize?: number | null;
  VolumeType?: VolumeType | null;
  KmsKeyId?: string | null;
  Encrypted?: boolean | null;
}
function EbsBlockDevice_Serialize(body: URLSearchParams, prefix: string, params: EbsBlockDevice) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+".KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
}
function EbsBlockDevice_Parse(node: xmlP.XmlNode): EbsBlockDevice {
  return {
    ...node.strings({
      optional: {"KmsKeyId":true},
    }),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as VolumeType),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
  };
}

// refs: 23 - tags: input, named, enum, output
export type VolumeType =
| "standard"
| "io1"
| "io2"
| "gp2"
| "sc1"
| "st1"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ExportToS3TaskSpecification {
  ContainerFormat?: ContainerFormat | null;
  DiskImageFormat?: DiskImageFormat | null;
  S3Bucket?: string | null;
  S3Prefix?: string | null;
}
function ExportToS3TaskSpecification_Serialize(body: URLSearchParams, prefix: string, params: ExportToS3TaskSpecification) {
    if ("ContainerFormat" in params) body.append(prefix+".ContainerFormat", (params["ContainerFormat"] ?? '').toString());
    if ("DiskImageFormat" in params) body.append(prefix+".DiskImageFormat", (params["DiskImageFormat"] ?? '').toString());
    if ("S3Bucket" in params) body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+".S3Prefix", (params["S3Prefix"] ?? '').toString());
}

// refs: 3 - tags: input, named, enum, output
export type ContainerFormat =
| "ova"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, enum, output
export type DiskImageFormat =
| "VMDK"
| "RAW"
| "VHD"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ExportEnvironment =
| "citrix"
| "vmware"
| "microsoft"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface RequestLaunchTemplateData {
  KernelId?: string | null;
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: LaunchTemplateIamInstanceProfileSpecificationRequest | null;
  BlockDeviceMappings?: LaunchTemplateBlockDeviceMappingRequest[] | null;
  NetworkInterfaces?: LaunchTemplateInstanceNetworkInterfaceSpecificationRequest[] | null;
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  KeyName?: string | null;
  Monitoring?: LaunchTemplatesMonitoringRequest | null;
  Placement?: LaunchTemplatePlacementRequest | null;
  RamDiskId?: string | null;
  DisableApiTermination?: boolean | null;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior | null;
  UserData?: string | null;
  TagSpecifications?: LaunchTemplateTagSpecificationRequest[] | null;
  ElasticGpuSpecifications?: ElasticGpuSpecification[] | null;
  ElasticInferenceAccelerators?: LaunchTemplateElasticInferenceAccelerator[] | null;
  SecurityGroupIds?: string[] | null;
  SecurityGroups?: string[] | null;
  InstanceMarketOptions?: LaunchTemplateInstanceMarketOptionsRequest | null;
  CreditSpecification?: CreditSpecificationRequest | null;
  CpuOptions?: LaunchTemplateCpuOptionsRequest | null;
  CapacityReservationSpecification?: LaunchTemplateCapacityReservationSpecificationRequest | null;
  LicenseSpecifications?: LaunchTemplateLicenseConfigurationRequest[] | null;
  HibernationOptions?: LaunchTemplateHibernationOptionsRequest | null;
  MetadataOptions?: LaunchTemplateInstanceMetadataOptionsRequest | null;
}
function RequestLaunchTemplateData_Serialize(body: URLSearchParams, prefix: string, params: RequestLaunchTemplateData) {
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) LaunchTemplateIamInstanceProfileSpecificationRequest_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":LaunchTemplateBlockDeviceMappingRequest_Serialize,"entryPrefix":"."})
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":LaunchTemplateInstanceNetworkInterfaceSpecificationRequest_Serialize,"entryPrefix":"."})
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) LaunchTemplatesMonitoringRequest_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["Placement"] != null) LaunchTemplatePlacementRequest_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamDiskId" in params) body.append(prefix+".RamDiskId", (params["RamDiskId"] ?? '').toString());
    if ("DisableApiTermination" in params) body.append(prefix+".DisableApiTermination", (params["DisableApiTermination"] ?? '').toString());
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+".InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".TagSpecification", params["TagSpecifications"], {"appender":LaunchTemplateTagSpecificationRequest_Serialize,"entryPrefix":"."})
    if (params["ElasticGpuSpecifications"]) qsP.appendList(body, prefix+".ElasticGpuSpecification", params["ElasticGpuSpecifications"], {"appender":ElasticGpuSpecification_Serialize,"entryPrefix":"."})
    if (params["ElasticInferenceAccelerators"]) qsP.appendList(body, prefix+".ElasticInferenceAccelerator", params["ElasticInferenceAccelerators"], {"appender":LaunchTemplateElasticInferenceAccelerator_Serialize,"entryPrefix":"."})
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if (params["InstanceMarketOptions"] != null) LaunchTemplateInstanceMarketOptionsRequest_Serialize(body, prefix+".InstanceMarketOptions", params["InstanceMarketOptions"]);
    if (params["CreditSpecification"] != null) CreditSpecificationRequest_Serialize(body, prefix+".CreditSpecification", params["CreditSpecification"]);
    if (params["CpuOptions"] != null) LaunchTemplateCpuOptionsRequest_Serialize(body, prefix+".CpuOptions", params["CpuOptions"]);
    if (params["CapacityReservationSpecification"] != null) LaunchTemplateCapacityReservationSpecificationRequest_Serialize(body, prefix+".CapacityReservationSpecification", params["CapacityReservationSpecification"]);
    if (params["LicenseSpecifications"]) qsP.appendList(body, prefix+".LicenseSpecification", params["LicenseSpecifications"], {"appender":LaunchTemplateLicenseConfigurationRequest_Serialize,"entryPrefix":"."})
    if (params["HibernationOptions"] != null) LaunchTemplateHibernationOptionsRequest_Serialize(body, prefix+".HibernationOptions", params["HibernationOptions"]);
    if (params["MetadataOptions"] != null) LaunchTemplateInstanceMetadataOptionsRequest_Serialize(body, prefix+".MetadataOptions", params["MetadataOptions"]);
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateIamInstanceProfileSpecificationRequest {
  Arn?: string | null;
  Name?: string | null;
}
function LaunchTemplateIamInstanceProfileSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateIamInstanceProfileSpecificationRequest) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateBlockDeviceMappingRequest {
  DeviceName?: string | null;
  VirtualName?: string | null;
  Ebs?: LaunchTemplateEbsBlockDeviceRequest | null;
  NoDevice?: string | null;
}
function LaunchTemplateBlockDeviceMappingRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateBlockDeviceMappingRequest) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
    if (params["Ebs"] != null) LaunchTemplateEbsBlockDeviceRequest_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateEbsBlockDeviceRequest {
  Encrypted?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Iops?: number | null;
  KmsKeyId?: string | null;
  SnapshotId?: string | null;
  VolumeSize?: number | null;
  VolumeType?: VolumeType | null;
}
function LaunchTemplateEbsBlockDeviceRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateEbsBlockDeviceRequest) {
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+".KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
  AssociateCarrierIpAddress?: boolean | null;
  AssociatePublicIpAddress?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Description?: string | null;
  DeviceIndex?: number | null;
  Groups?: string[] | null;
  InterfaceType?: string | null;
  Ipv6AddressCount?: number | null;
  Ipv6Addresses?: InstanceIpv6AddressRequest[] | null;
  NetworkInterfaceId?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses?: PrivateIpAddressSpecification[] | null;
  SecondaryPrivateIpAddressCount?: number | null;
  SubnetId?: string | null;
}
function LaunchTemplateInstanceNetworkInterfaceSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateInstanceNetworkInterfaceSpecificationRequest) {
    if ("AssociateCarrierIpAddress" in params) body.append(prefix+".AssociateCarrierIpAddress", (params["AssociateCarrierIpAddress"] ?? '').toString());
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("InterfaceType" in params) body.append(prefix+".InterfaceType", (params["InterfaceType"] ?? '').toString());
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".InstanceIpv6Address", params["Ipv6Addresses"], {"appender":InstanceIpv6AddressRequest_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+".item", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface InstanceIpv6AddressRequest {
  Ipv6Address?: string | null;
}
function InstanceIpv6AddressRequest_Serialize(body: URLSearchParams, prefix: string, params: InstanceIpv6AddressRequest) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}

// refs: 12 - tags: input, named, interface, output
export interface PrivateIpAddressSpecification {
  Primary?: boolean | null;
  PrivateIpAddress?: string | null;
}
function PrivateIpAddressSpecification_Serialize(body: URLSearchParams, prefix: string, params: PrivateIpAddressSpecification) {
    if ("Primary" in params) body.append(prefix+".Primary", (params["Primary"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
}
function PrivateIpAddressSpecification_Parse(node: xmlP.XmlNode): PrivateIpAddressSpecification {
  return {
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplatesMonitoringRequest {
  Enabled?: boolean | null;
}
function LaunchTemplatesMonitoringRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplatesMonitoringRequest) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplatePlacementRequest {
  AvailabilityZone?: string | null;
  Affinity?: string | null;
  GroupName?: string | null;
  HostId?: string | null;
  Tenancy?: Tenancy | null;
  SpreadDomain?: string | null;
  HostResourceGroupArn?: string | null;
  PartitionNumber?: number | null;
}
function LaunchTemplatePlacementRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplatePlacementRequest) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Affinity" in params) body.append(prefix+".Affinity", (params["Affinity"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("HostId" in params) body.append(prefix+".HostId", (params["HostId"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
    if ("SpreadDomain" in params) body.append(prefix+".SpreadDomain", (params["SpreadDomain"] ?? '').toString());
    if ("HostResourceGroupArn" in params) body.append(prefix+".HostResourceGroupArn", (params["HostResourceGroupArn"] ?? '').toString());
    if ("PartitionNumber" in params) body.append(prefix+".PartitionNumber", (params["PartitionNumber"] ?? '').toString());
}

// refs: 7 - tags: input, named, enum, output
export type ShutdownBehavior =
| "stop"
| "terminate"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateTagSpecificationRequest {
  ResourceType?: ResourceType | null;
  Tags?: Tag[] | null;
}
function LaunchTemplateTagSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateTagSpecificationRequest) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".Tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}

// refs: 3 - tags: input, named, interface
export interface ElasticGpuSpecification {
  Type: string;
}
function ElasticGpuSpecification_Serialize(body: URLSearchParams, prefix: string, params: ElasticGpuSpecification) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateElasticInferenceAccelerator {
  Type: string;
  Count?: number | null;
}
function LaunchTemplateElasticInferenceAccelerator_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateElasticInferenceAccelerator) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Count" in params) body.append(prefix+".Count", (params["Count"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateInstanceMarketOptionsRequest {
  MarketType?: MarketType | null;
  SpotOptions?: LaunchTemplateSpotMarketOptionsRequest | null;
}
function LaunchTemplateInstanceMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateInstanceMarketOptionsRequest) {
    if ("MarketType" in params) body.append(prefix+".MarketType", (params["MarketType"] ?? '').toString());
    if (params["SpotOptions"] != null) LaunchTemplateSpotMarketOptionsRequest_Serialize(body, prefix+".SpotOptions", params["SpotOptions"]);
}

// refs: 6 - tags: input, named, enum, output
export type MarketType =
| "spot"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateSpotMarketOptionsRequest {
  MaxPrice?: string | null;
  SpotInstanceType?: SpotInstanceType | null;
  BlockDurationMinutes?: number | null;
  ValidUntil?: Date | number | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
}
function LaunchTemplateSpotMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateSpotMarketOptionsRequest) {
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SpotInstanceType" in params) body.append(prefix+".SpotInstanceType", (params["SpotInstanceType"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+".BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
}

// refs: 9 - tags: input, named, enum, output
export type SpotInstanceType =
| "one-time"
| "persistent"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type InstanceInterruptionBehavior =
| "hibernate"
| "stop"
| "terminate"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface CreditSpecificationRequest {
  CpuCredits: string;
}
function CreditSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: CreditSpecificationRequest) {
    body.append(prefix+".CpuCredits", (params["CpuCredits"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateCpuOptionsRequest {
  CoreCount?: number | null;
  ThreadsPerCore?: number | null;
}
function LaunchTemplateCpuOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateCpuOptionsRequest) {
    if ("CoreCount" in params) body.append(prefix+".CoreCount", (params["CoreCount"] ?? '').toString());
    if ("ThreadsPerCore" in params) body.append(prefix+".ThreadsPerCore", (params["ThreadsPerCore"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateCapacityReservationSpecificationRequest {
  CapacityReservationPreference?: CapacityReservationPreference | null;
  CapacityReservationTarget?: CapacityReservationTarget | null;
}
function LaunchTemplateCapacityReservationSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateCapacityReservationSpecificationRequest) {
    if ("CapacityReservationPreference" in params) body.append(prefix+".CapacityReservationPreference", (params["CapacityReservationPreference"] ?? '').toString());
    if (params["CapacityReservationTarget"] != null) CapacityReservationTarget_Serialize(body, prefix+".CapacityReservationTarget", params["CapacityReservationTarget"]);
}

// refs: 9 - tags: input, named, enum, output
export type CapacityReservationPreference =
| "open"
| "none"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface
export interface CapacityReservationTarget {
  CapacityReservationId?: string | null;
  CapacityReservationResourceGroupArn?: string | null;
}
function CapacityReservationTarget_Serialize(body: URLSearchParams, prefix: string, params: CapacityReservationTarget) {
    if ("CapacityReservationId" in params) body.append(prefix+".CapacityReservationId", (params["CapacityReservationId"] ?? '').toString());
    if ("CapacityReservationResourceGroupArn" in params) body.append(prefix+".CapacityReservationResourceGroupArn", (params["CapacityReservationResourceGroupArn"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateLicenseConfigurationRequest {
  LicenseConfigurationArn?: string | null;
}
function LaunchTemplateLicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateLicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateHibernationOptionsRequest {
  Configured?: boolean | null;
}
function LaunchTemplateHibernationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateHibernationOptionsRequest) {
    if ("Configured" in params) body.append(prefix+".Configured", (params["Configured"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface LaunchTemplateInstanceMetadataOptionsRequest {
  HttpTokens?: LaunchTemplateHttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: LaunchTemplateInstanceMetadataEndpointState | null;
}
function LaunchTemplateInstanceMetadataOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateInstanceMetadataOptionsRequest) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}

// refs: 5 - tags: input, named, enum, output
export type LaunchTemplateHttpTokensState =
| "optional"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type LaunchTemplateInstanceMetadataEndpointState =
| "disabled"
| "enabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface AddPrefixListEntry {
  Cidr: string;
  Description?: string | null;
}
function AddPrefixListEntry_Serialize(body: URLSearchParams, prefix: string, params: AddPrefixListEntry) {
    body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
}

// refs: 4 - tags: input, named, interface, output
export interface IcmpTypeCode {
  Code?: number | null;
  Type?: number | null;
}
function IcmpTypeCode_Serialize(body: URLSearchParams, prefix: string, params: IcmpTypeCode) {
    if ("Code" in params) body.append(prefix+".Code", (params["Code"] ?? '').toString());
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
}
function IcmpTypeCode_Parse(node: xmlP.XmlNode): IcmpTypeCode {
  return {
    Code: node.first("code", false, x => parseInt(x.content ?? '0')),
    Type: node.first("type", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface PortRange {
  From?: number | null;
  To?: number | null;
}
function PortRange_Serialize(body: URLSearchParams, prefix: string, params: PortRange) {
    if ("From" in params) body.append(prefix+".From", (params["From"] ?? '').toString());
    if ("To" in params) body.append(prefix+".To", (params["To"] ?? '').toString());
}
function PortRange_Parse(node: xmlP.XmlNode): PortRange {
  return {
    From: node.first("from", false, x => parseInt(x.content ?? '0')),
    To: node.first("to", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, enum, output
export type RuleAction =
| "allow"
| "deny"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, interface, output
export interface InstanceIpv6Address {
  Ipv6Address?: string | null;
}
function InstanceIpv6Address_Serialize(body: URLSearchParams, prefix: string, params: InstanceIpv6Address) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}
function InstanceIpv6Address_Parse(node: xmlP.XmlNode): InstanceIpv6Address {
  return {
    Ipv6Address: node.first("ipv6Address", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: input, named, enum
export type NetworkInterfaceCreationType =
| "efa"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type InterfacePermissionType =
| "INSTANCE-ATTACH"
| "EIP-ASSOCIATE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type PlacementStrategy =
| "cluster"
| "spread"
| "partition"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface PriceScheduleSpecification {
  CurrencyCode?: CurrencyCodeValues | null;
  Price?: number | null;
  Term?: number | null;
}
function PriceScheduleSpecification_Serialize(body: URLSearchParams, prefix: string, params: PriceScheduleSpecification) {
    if ("CurrencyCode" in params) body.append(prefix+".CurrencyCode", (params["CurrencyCode"] ?? '').toString());
    if ("Price" in params) body.append(prefix+".Price", (params["Price"] ?? '').toString());
    if ("Term" in params) body.append(prefix+".Term", (params["Term"] ?? '').toString());
}

// refs: 14 - tags: input, named, enum, output
export type CurrencyCodeValues =
| "USD"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface InstanceSpecification {
  InstanceId?: string | null;
  ExcludeBootVolume?: boolean | null;
}
function InstanceSpecification_Serialize(body: URLSearchParams, prefix: string, params: InstanceSpecification) {
    if ("InstanceId" in params) body.append(prefix+".InstanceId", (params["InstanceId"] ?? '').toString());
    if ("ExcludeBootVolume" in params) body.append(prefix+".ExcludeBootVolume", (params["ExcludeBootVolume"] ?? '').toString());
}

// refs: 1 - tags: input, named, enum
export type CopyTagsFromSource =
| "volume"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type TrafficDirection =
| "ingress"
| "egress"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type TrafficMirrorRuleAction =
| "accept"
| "reject"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface
export interface TrafficMirrorPortRangeRequest {
  FromPort?: number | null;
  ToPort?: number | null;
}
function TrafficMirrorPortRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: TrafficMirrorPortRangeRequest) {
    if ("FromPort" in params) body.append(prefix+".FromPort", (params["FromPort"] ?? '').toString());
    if ("ToPort" in params) body.append(prefix+".ToPort", (params["ToPort"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface TransitGatewayRequestOptions {
  AmazonSideAsn?: number | null;
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue | null;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue | null;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue | null;
  VpnEcmpSupport?: VpnEcmpSupportValue | null;
  DnsSupport?: DnsSupportValue | null;
  MulticastSupport?: MulticastSupportValue | null;
}
function TransitGatewayRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: TransitGatewayRequestOptions) {
    if ("AmazonSideAsn" in params) body.append(prefix+".AmazonSideAsn", (params["AmazonSideAsn"] ?? '').toString());
    if ("AutoAcceptSharedAttachments" in params) body.append(prefix+".AutoAcceptSharedAttachments", (params["AutoAcceptSharedAttachments"] ?? '').toString());
    if ("DefaultRouteTableAssociation" in params) body.append(prefix+".DefaultRouteTableAssociation", (params["DefaultRouteTableAssociation"] ?? '').toString());
    if ("DefaultRouteTablePropagation" in params) body.append(prefix+".DefaultRouteTablePropagation", (params["DefaultRouteTablePropagation"] ?? '').toString());
    if ("VpnEcmpSupport" in params) body.append(prefix+".VpnEcmpSupport", (params["VpnEcmpSupport"] ?? '').toString());
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("MulticastSupport" in params) body.append(prefix+".MulticastSupport", (params["MulticastSupport"] ?? '').toString());
}

// refs: 6 - tags: input, named, enum, output
export type AutoAcceptSharedAttachmentsValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DefaultRouteTableAssociationValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DefaultRouteTablePropagationValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type VpnEcmpSupportValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type DnsSupportValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type MulticastSupportValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CreateTransitGatewayVpcAttachmentRequestOptions {
  DnsSupport?: DnsSupportValue | null;
  Ipv6Support?: Ipv6SupportValue | null;
}
function CreateTransitGatewayVpcAttachmentRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: CreateTransitGatewayVpcAttachmentRequestOptions) {
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("Ipv6Support" in params) body.append(prefix+".Ipv6Support", (params["Ipv6Support"] ?? '').toString());
}

// refs: 8 - tags: input, named, enum, output
export type Ipv6SupportValue =
| "enable"
| "disable"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type VpcEndpointType =
| "Interface"
| "Gateway"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface VpnConnectionOptionsSpecification {
  EnableAcceleration?: boolean | null;
  StaticRoutesOnly?: boolean | null;
  TunnelInsideIpVersion?: TunnelInsideIpVersion | null;
  TunnelOptions?: VpnTunnelOptionsSpecification[] | null;
  LocalIpv4NetworkCidr?: string | null;
  RemoteIpv4NetworkCidr?: string | null;
  LocalIpv6NetworkCidr?: string | null;
  RemoteIpv6NetworkCidr?: string | null;
}
function VpnConnectionOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: VpnConnectionOptionsSpecification) {
    if ("EnableAcceleration" in params) body.append(prefix+".EnableAcceleration", (params["EnableAcceleration"] ?? '').toString());
    if ("StaticRoutesOnly" in params) body.append(prefix+".StaticRoutesOnly", (params["StaticRoutesOnly"] ?? '').toString());
    if ("TunnelInsideIpVersion" in params) body.append(prefix+".TunnelInsideIpVersion", (params["TunnelInsideIpVersion"] ?? '').toString());
    if (params["TunnelOptions"]) qsP.appendList(body, prefix+".TunnelOptions", params["TunnelOptions"], {"appender":VpnTunnelOptionsSpecification_Serialize,"entryPrefix":"."})
    if ("LocalIpv4NetworkCidr" in params) body.append(prefix+".LocalIpv4NetworkCidr", (params["LocalIpv4NetworkCidr"] ?? '').toString());
    if ("RemoteIpv4NetworkCidr" in params) body.append(prefix+".RemoteIpv4NetworkCidr", (params["RemoteIpv4NetworkCidr"] ?? '').toString());
    if ("LocalIpv6NetworkCidr" in params) body.append(prefix+".LocalIpv6NetworkCidr", (params["LocalIpv6NetworkCidr"] ?? '').toString());
    if ("RemoteIpv6NetworkCidr" in params) body.append(prefix+".RemoteIpv6NetworkCidr", (params["RemoteIpv6NetworkCidr"] ?? '').toString());
}

// refs: 7 - tags: input, named, enum, output
export type TunnelInsideIpVersion =
| "ipv4"
| "ipv6"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface VpnTunnelOptionsSpecification {
  TunnelInsideCidr?: string | null;
  TunnelInsideIpv6Cidr?: string | null;
  PreSharedKey?: string | null;
  Phase1LifetimeSeconds?: number | null;
  Phase2LifetimeSeconds?: number | null;
  RekeyMarginTimeSeconds?: number | null;
  RekeyFuzzPercentage?: number | null;
  ReplayWindowSize?: number | null;
  DPDTimeoutSeconds?: number | null;
  DPDTimeoutAction?: string | null;
  Phase1EncryptionAlgorithms?: Phase1EncryptionAlgorithmsRequestListValue[] | null;
  Phase2EncryptionAlgorithms?: Phase2EncryptionAlgorithmsRequestListValue[] | null;
  Phase1IntegrityAlgorithms?: Phase1IntegrityAlgorithmsRequestListValue[] | null;
  Phase2IntegrityAlgorithms?: Phase2IntegrityAlgorithmsRequestListValue[] | null;
  Phase1DHGroupNumbers?: Phase1DHGroupNumbersRequestListValue[] | null;
  Phase2DHGroupNumbers?: Phase2DHGroupNumbersRequestListValue[] | null;
  IKEVersions?: IKEVersionsRequestListValue[] | null;
  StartupAction?: string | null;
}
function VpnTunnelOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: VpnTunnelOptionsSpecification) {
    if ("TunnelInsideCidr" in params) body.append(prefix+".TunnelInsideCidr", (params["TunnelInsideCidr"] ?? '').toString());
    if ("TunnelInsideIpv6Cidr" in params) body.append(prefix+".TunnelInsideIpv6Cidr", (params["TunnelInsideIpv6Cidr"] ?? '').toString());
    if ("PreSharedKey" in params) body.append(prefix+".PreSharedKey", (params["PreSharedKey"] ?? '').toString());
    if ("Phase1LifetimeSeconds" in params) body.append(prefix+".Phase1LifetimeSeconds", (params["Phase1LifetimeSeconds"] ?? '').toString());
    if ("Phase2LifetimeSeconds" in params) body.append(prefix+".Phase2LifetimeSeconds", (params["Phase2LifetimeSeconds"] ?? '').toString());
    if ("RekeyMarginTimeSeconds" in params) body.append(prefix+".RekeyMarginTimeSeconds", (params["RekeyMarginTimeSeconds"] ?? '').toString());
    if ("RekeyFuzzPercentage" in params) body.append(prefix+".RekeyFuzzPercentage", (params["RekeyFuzzPercentage"] ?? '').toString());
    if ("ReplayWindowSize" in params) body.append(prefix+".ReplayWindowSize", (params["ReplayWindowSize"] ?? '').toString());
    if ("DPDTimeoutSeconds" in params) body.append(prefix+".DPDTimeoutSeconds", (params["DPDTimeoutSeconds"] ?? '').toString());
    if ("DPDTimeoutAction" in params) body.append(prefix+".DPDTimeoutAction", (params["DPDTimeoutAction"] ?? '').toString());
    if (params["Phase1EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase1EncryptionAlgorithm", params["Phase1EncryptionAlgorithms"], {"appender":Phase1EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase2EncryptionAlgorithm", params["Phase2EncryptionAlgorithms"], {"appender":Phase2EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase1IntegrityAlgorithm", params["Phase1IntegrityAlgorithms"], {"appender":Phase1IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase2IntegrityAlgorithm", params["Phase2IntegrityAlgorithms"], {"appender":Phase2IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase1DHGroupNumber", params["Phase1DHGroupNumbers"], {"appender":Phase1DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase2DHGroupNumber", params["Phase2DHGroupNumbers"], {"appender":Phase2DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["IKEVersions"]) qsP.appendList(body, prefix+".IKEVersion", params["IKEVersions"], {"appender":IKEVersionsRequestListValue_Serialize,"entryPrefix":"."})
    if ("StartupAction" in params) body.append(prefix+".StartupAction", (params["StartupAction"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase1EncryptionAlgorithmsRequestListValue {
  Value?: string | null;
}
function Phase1EncryptionAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase1EncryptionAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase2EncryptionAlgorithmsRequestListValue {
  Value?: string | null;
}
function Phase2EncryptionAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase2EncryptionAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase1IntegrityAlgorithmsRequestListValue {
  Value?: string | null;
}
function Phase1IntegrityAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase1IntegrityAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase2IntegrityAlgorithmsRequestListValue {
  Value?: string | null;
}
function Phase2IntegrityAlgorithmsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase2IntegrityAlgorithmsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase1DHGroupNumbersRequestListValue {
  Value?: number | null;
}
function Phase1DHGroupNumbersRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase1DHGroupNumbersRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface Phase2DHGroupNumbersRequestListValue {
  Value?: number | null;
}
function Phase2DHGroupNumbersRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: Phase2DHGroupNumbersRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface IKEVersionsRequestListValue {
  Value?: string | null;
}
function IKEVersionsRequestListValue_Serialize(body: URLSearchParams, prefix: string, params: IKEVersionsRequestListValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface DeregisterInstanceTagAttributeRequest {
  IncludeAllTagsOfInstance?: boolean | null;
  InstanceTagKeys?: string[] | null;
}
function DeregisterInstanceTagAttributeRequest_Serialize(body: URLSearchParams, prefix: string, params: DeregisterInstanceTagAttributeRequest) {
    if ("IncludeAllTagsOfInstance" in params) body.append(prefix+".IncludeAllTagsOfInstance", (params["IncludeAllTagsOfInstance"] ?? '').toString());
    if (params["InstanceTagKeys"]) qsP.appendList(body, prefix+".InstanceTagKey", params["InstanceTagKeys"], {"entryPrefix":"."})
}

// refs: 1 - tags: input, named, enum
export type AccountAttributeName =
| "supported-platforms"
| "default-vpc"
| cmnP.UnexpectedEnumValue;

// refs: 102 - tags: input, named, interface
export interface Filter {
  Name?: string | null;
  Values?: string[] | null;
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Value", params["Values"], {"entryPrefix":"."})
}

// refs: 2 - tags: input, named, enum, output
export type FleetEventType =
| "instance-change"
| "fleet-change"
| "service-error"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type FpgaImageAttributeName =
| "description"
| "name"
| "loadPermission"
| "productCodes"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ImageAttributeName =
| "description"
| "kernel"
| "ramdisk"
| "launchPermission"
| "productCodes"
| "blockDeviceMapping"
| "sriovNetSupport"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum
export type InstanceAttributeName =
| "instanceType"
| "kernel"
| "ramdisk"
| "userData"
| "disableApiTermination"
| "instanceInitiatedShutdownBehavior"
| "rootDeviceName"
| "blockDeviceMapping"
| "productCodes"
| "sourceDestCheck"
| "groupSet"
| "ebsOptimized"
| "sriovNetSupport"
| "enaSupport"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type LocationType =
| "region"
| "availability-zone"
| "availability-zone-id"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type NetworkInterfaceAttribute =
| "description"
| "groupSet"
| "sourceDestCheck"
| "attachment"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type OfferingClassType =
| "standard"
| "convertible"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type OfferingTypeValues =
| "Heavy Utilization"
| "Medium Utilization"
| "Light Utilization"
| "No Upfront"
| "Partial Upfront"
| "All Upfront"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type RIProductDescription =
| "Linux/UNIX"
| "Linux/UNIX (Amazon VPC)"
| "Windows"
| "Windows (Amazon VPC)"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SlotDateTimeRangeRequest {
  EarliestTime: Date | number;
  LatestTime: Date | number;
}
function SlotDateTimeRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: SlotDateTimeRangeRequest) {
    body.append(prefix+".EarliestTime", qsP.encodeDate_iso8601(params["EarliestTime"]));
    body.append(prefix+".LatestTime", qsP.encodeDate_iso8601(params["LatestTime"]));
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstanceRecurrenceRequest {
  Frequency?: string | null;
  Interval?: number | null;
  OccurrenceDays?: number[] | null;
  OccurrenceRelativeToEnd?: boolean | null;
  OccurrenceUnit?: string | null;
}
function ScheduledInstanceRecurrenceRequest_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstanceRecurrenceRequest) {
    if ("Frequency" in params) body.append(prefix+".Frequency", (params["Frequency"] ?? '').toString());
    if ("Interval" in params) body.append(prefix+".Interval", (params["Interval"] ?? '').toString());
    if (params["OccurrenceDays"]) qsP.appendList(body, prefix+".OccurrenceDay", params["OccurrenceDays"], {"entryPrefix":"."})
    if ("OccurrenceRelativeToEnd" in params) body.append(prefix+".OccurrenceRelativeToEnd", (params["OccurrenceRelativeToEnd"] ?? '').toString());
    if ("OccurrenceUnit" in params) body.append(prefix+".OccurrenceUnit", (params["OccurrenceUnit"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface SlotStartTimeRangeRequest {
  EarliestTime?: Date | number | null;
  LatestTime?: Date | number | null;
}
function SlotStartTimeRangeRequest_Serialize(body: URLSearchParams, prefix: string, params: SlotStartTimeRangeRequest) {
    if ("EarliestTime" in params) body.append(prefix+".EarliestTime", qsP.encodeDate_iso8601(params["EarliestTime"]));
    if ("LatestTime" in params) body.append(prefix+".LatestTime", qsP.encodeDate_iso8601(params["LatestTime"]));
}

// refs: 3 - tags: input, named, enum
export type SnapshotAttributeName =
| "productCodes"
| "createVolumePermission"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type EventType =
| "instanceChange"
| "fleetRequestChange"
| "error"
| "information"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type VolumeAttributeName =
| "autoEnableIO"
| "productCodes"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type VpcAttributeName =
| "enableDnsSupport"
| "enableDnsHostnames"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ExportTaskS3LocationRequest {
  S3Bucket: string;
  S3Prefix?: string | null;
}
function ExportTaskS3LocationRequest_Serialize(body: URLSearchParams, prefix: string, params: ExportTaskS3LocationRequest) {
    body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Prefix" in params) body.append(prefix+".S3Prefix", (params["S3Prefix"] ?? '').toString());
}

// refs: 4 - tags: input, named, enum, output
export type UnlimitedSupportedInstanceFamily =
| "t2"
| "t3"
| "t3a"
| "t4g"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ClientData {
  Comment?: string | null;
  UploadEnd?: Date | number | null;
  UploadSize?: number | null;
  UploadStart?: Date | number | null;
}
function ClientData_Serialize(body: URLSearchParams, prefix: string, params: ClientData) {
    if ("Comment" in params) body.append(prefix+".Comment", (params["Comment"] ?? '').toString());
    if ("UploadEnd" in params) body.append(prefix+".UploadEnd", qsP.encodeDate_iso8601(params["UploadEnd"]));
    if ("UploadSize" in params) body.append(prefix+".UploadSize", (params["UploadSize"] ?? '').toString());
    if ("UploadStart" in params) body.append(prefix+".UploadStart", qsP.encodeDate_iso8601(params["UploadStart"]));
}

// refs: 1 - tags: input, named, interface
export interface ImageDiskContainer {
  Description?: string | null;
  DeviceName?: string | null;
  Format?: string | null;
  SnapshotId?: string | null;
  Url?: string | null;
  UserBucket?: UserBucket | null;
}
function ImageDiskContainer_Serialize(body: URLSearchParams, prefix: string, params: ImageDiskContainer) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if ("Format" in params) body.append(prefix+".Format", (params["Format"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("Url" in params) body.append(prefix+".Url", (params["Url"] ?? '').toString());
    if (params["UserBucket"] != null) UserBucket_Serialize(body, prefix+".UserBucket", params["UserBucket"]);
}

// refs: 2 - tags: input, named, interface
export interface UserBucket {
  S3Bucket?: string | null;
  S3Key?: string | null;
}
function UserBucket_Serialize(body: URLSearchParams, prefix: string, params: UserBucket) {
    if ("S3Bucket" in params) body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Key" in params) body.append(prefix+".S3Key", (params["S3Key"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ImportImageLicenseConfigurationRequest {
  LicenseConfigurationArn?: string | null;
}
function ImportImageLicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: ImportImageLicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface DiskImage {
  Description?: string | null;
  Image?: DiskImageDetail | null;
  Volume?: VolumeDetail | null;
}
function DiskImage_Serialize(body: URLSearchParams, prefix: string, params: DiskImage) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if (params["Image"] != null) DiskImageDetail_Serialize(body, prefix+".Image", params["Image"]);
    if (params["Volume"] != null) VolumeDetail_Serialize(body, prefix+".Volume", params["Volume"]);
}

// refs: 2 - tags: input, named, interface
export interface DiskImageDetail {
  Bytes: number;
  Format: DiskImageFormat;
  ImportManifestUrl: string;
}
function DiskImageDetail_Serialize(body: URLSearchParams, prefix: string, params: DiskImageDetail) {
    body.append(prefix+".Bytes", (params["Bytes"] ?? '').toString());
    body.append(prefix+".Format", (params["Format"] ?? '').toString());
    body.append(prefix+".ImportManifestUrl", (params["ImportManifestUrl"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface VolumeDetail {
  Size: number;
}
function VolumeDetail_Serialize(body: URLSearchParams, prefix: string, params: VolumeDetail) {
    body.append(prefix+".Size", (params["Size"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ImportInstanceLaunchSpecification {
  AdditionalInfo?: string | null;
  Architecture?: ArchitectureValues | null;
  GroupIds?: string[] | null;
  GroupNames?: string[] | null;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior | null;
  InstanceType?: InstanceType | null;
  Monitoring?: boolean | null;
  Placement?: Placement | null;
  PrivateIpAddress?: string | null;
  SubnetId?: string | null;
  UserData?: UserData | null;
}
function ImportInstanceLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: ImportInstanceLaunchSpecification) {
    if ("AdditionalInfo" in params) body.append(prefix+".AdditionalInfo", (params["AdditionalInfo"] ?? '').toString());
    if ("Architecture" in params) body.append(prefix+".Architecture", (params["Architecture"] ?? '').toString());
    if (params["GroupIds"]) qsP.appendList(body, prefix+".GroupId", params["GroupIds"], {"entryPrefix":"."})
    if (params["GroupNames"]) qsP.appendList(body, prefix+".GroupName", params["GroupNames"], {"entryPrefix":"."})
    if ("InstanceInitiatedShutdownBehavior" in params) body.append(prefix+".InstanceInitiatedShutdownBehavior", (params["InstanceInitiatedShutdownBehavior"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Monitoring" in params) body.append(prefix+".Monitoring", (params["Monitoring"] ?? '').toString());
    if (params["Placement"] != null) Placement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if (params["UserData"] != null) UserData_Serialize(body, prefix+".UserData", params["UserData"]);
}

// refs: 5 - tags: input, named, enum, output
export type ArchitectureValues =
| "i386"
| "x86_64"
| "arm64"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface UserData {
  Data?: string | null;
}
function UserData_Serialize(body: URLSearchParams, prefix: string, params: UserData) {
    if ("Data" in params) body.append(prefix+".Data", (params["Data"] ?? '').toString());
}

// refs: 9 - tags: input, named, enum, output
export type PlatformValues =
| "Windows"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SnapshotDiskContainer {
  Description?: string | null;
  Format?: string | null;
  Url?: string | null;
  UserBucket?: UserBucket | null;
}
function SnapshotDiskContainer_Serialize(body: URLSearchParams, prefix: string, params: SnapshotDiskContainer) {
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Format" in params) body.append(prefix+".Format", (params["Format"] ?? '').toString());
    if ("Url" in params) body.append(prefix+".Url", (params["Url"] ?? '').toString());
    if (params["UserBucket"] != null) UserBucket_Serialize(body, prefix+".UserBucket", params["UserBucket"]);
}

// refs: 1 - tags: input, named, enum
export type ModifyAvailabilityZoneOptInStatus =
| "opted-in"
| "not-opted-in"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DnsServersOptionsModifyStructure {
  CustomDnsServers?: string[] | null;
  Enabled?: boolean | null;
}
function DnsServersOptionsModifyStructure_Serialize(body: URLSearchParams, prefix: string, params: DnsServersOptionsModifyStructure) {
    if (params["CustomDnsServers"]) qsP.appendList(body, prefix+".item", params["CustomDnsServers"], {"entryPrefix":"."})
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

// refs: 3 - tags: input, named, enum
export type OperationType =
| "add"
| "remove"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LoadPermissionModifications {
  Add?: LoadPermissionRequest[] | null;
  Remove?: LoadPermissionRequest[] | null;
}
function LoadPermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: LoadPermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":LoadPermissionRequest_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":LoadPermissionRequest_Serialize,"entryPrefix":"."})
}

// refs: 2 - tags: input, named, interface
export interface LoadPermissionRequest {
  Group?: PermissionGroup | null;
  UserId?: string | null;
}
function LoadPermissionRequest_Serialize(body: URLSearchParams, prefix: string, params: LoadPermissionRequest) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}

// refs: 10 - tags: input, named, enum, output
export type PermissionGroup =
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 21 - tags: input, named, interface, output
export interface AttributeValue {
  Value?: string | null;
}
function AttributeValue_Serialize(body: URLSearchParams, prefix: string, params: AttributeValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function AttributeValue_Parse(node: xmlP.XmlNode): AttributeValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: input, named, interface
export interface LaunchPermissionModifications {
  Add?: LaunchPermission[] | null;
  Remove?: LaunchPermission[] | null;
}
function LaunchPermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: LaunchPermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":LaunchPermission_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":LaunchPermission_Serialize,"entryPrefix":"."})
}

// refs: 3 - tags: input, named, interface, output
export interface LaunchPermission {
  Group?: PermissionGroup | null;
  UserId?: string | null;
}
function LaunchPermission_Serialize(body: URLSearchParams, prefix: string, params: LaunchPermission) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}
function LaunchPermission_Parse(node: xmlP.XmlNode): LaunchPermission {
  return {
    Group: node.first("group", false, x => (x.content ?? '') as PermissionGroup),
    UserId: node.first("userId", false, x => x.content ?? ''),
  };
}

// refs: 19 - tags: input, named, interface, output
export interface AttributeBooleanValue {
  Value?: boolean | null;
}
function AttributeBooleanValue_Serialize(body: URLSearchParams, prefix: string, params: AttributeBooleanValue) {
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function AttributeBooleanValue_Parse(node: xmlP.XmlNode): AttributeBooleanValue {
  return {
    Value: node.first("value", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, interface
export interface InstanceBlockDeviceMappingSpecification {
  DeviceName?: string | null;
  Ebs?: EbsInstanceBlockDeviceSpecification | null;
  NoDevice?: string | null;
  VirtualName?: string | null;
}
function InstanceBlockDeviceMappingSpecification_Serialize(body: URLSearchParams, prefix: string, params: InstanceBlockDeviceMappingSpecification) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) EbsInstanceBlockDeviceSpecification_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface EbsInstanceBlockDeviceSpecification {
  DeleteOnTermination?: boolean | null;
  VolumeId?: string | null;
}
function EbsInstanceBlockDeviceSpecification_Serialize(body: URLSearchParams, prefix: string, params: EbsInstanceBlockDeviceSpecification) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("VolumeId" in params) body.append(prefix+".VolumeId", (params["VolumeId"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface BlobAttributeValue {
  Value?: Uint8Array | string | null;
}
function BlobAttributeValue_Serialize(body: URLSearchParams, prefix: string, params: BlobAttributeValue) {
    if ("Value" in params) body.append(prefix+".Value", qsP.encodeBlob(params["Value"]));
}

// refs: 2 - tags: input, named, interface
export interface CapacityReservationSpecification {
  CapacityReservationPreference?: CapacityReservationPreference | null;
  CapacityReservationTarget?: CapacityReservationTarget | null;
}
function CapacityReservationSpecification_Serialize(body: URLSearchParams, prefix: string, params: CapacityReservationSpecification) {
    if ("CapacityReservationPreference" in params) body.append(prefix+".CapacityReservationPreference", (params["CapacityReservationPreference"] ?? '').toString());
    if (params["CapacityReservationTarget"] != null) CapacityReservationTarget_Serialize(body, prefix+".CapacityReservationTarget", params["CapacityReservationTarget"]);
}

// refs: 1 - tags: input, named, interface
export interface InstanceCreditSpecificationRequest {
  InstanceId?: string | null;
  CpuCredits?: string | null;
}
function InstanceCreditSpecificationRequest_Serialize(body: URLSearchParams, prefix: string, params: InstanceCreditSpecificationRequest) {
    if ("InstanceId" in params) body.append(prefix+".InstanceId", (params["InstanceId"] ?? '').toString());
    if ("CpuCredits" in params) body.append(prefix+".CpuCredits", (params["CpuCredits"] ?? '').toString());
}

// refs: 5 - tags: input, named, enum, output
export type HttpTokensState =
| "optional"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type InstanceMetadataEndpointState =
| "disabled"
| "enabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type Affinity =
| "default"
| "host"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type HostTenancy =
| "dedicated"
| "host"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RemovePrefixListEntry {
  Cidr: string;
}
function RemovePrefixListEntry_Serialize(body: URLSearchParams, prefix: string, params: RemovePrefixListEntry) {
    body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface NetworkInterfaceAttachmentChanges {
  AttachmentId?: string | null;
  DeleteOnTermination?: boolean | null;
}
function NetworkInterfaceAttachmentChanges_Serialize(body: URLSearchParams, prefix: string, params: NetworkInterfaceAttachmentChanges) {
    if ("AttachmentId" in params) body.append(prefix+".AttachmentId", (params["AttachmentId"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface, output
export interface ReservedInstancesConfiguration {
  AvailabilityZone?: string | null;
  InstanceCount?: number | null;
  InstanceType?: InstanceType | null;
  Platform?: string | null;
  Scope?: scope | null;
}
function ReservedInstancesConfiguration_Serialize(body: URLSearchParams, prefix: string, params: ReservedInstancesConfiguration) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("InstanceCount" in params) body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("Platform" in params) body.append(prefix+".Platform", (params["Platform"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
}
function ReservedInstancesConfiguration_Parse(node: xmlP.XmlNode): ReservedInstancesConfiguration {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    Platform: node.first("platform", false, x => x.content ?? ''),
    Scope: node.first("scope", false, x => (x.content ?? '') as scope),
  };
}

// refs: 4 - tags: input, named, enum, output
export type scope =
| "Availability Zone"
| "Region"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CreateVolumePermissionModifications {
  Add?: CreateVolumePermission[] | null;
  Remove?: CreateVolumePermission[] | null;
}
function CreateVolumePermissionModifications_Serialize(body: URLSearchParams, prefix: string, params: CreateVolumePermissionModifications) {
    if (params["Add"]) qsP.appendList(body, prefix+".item", params["Add"], {"appender":CreateVolumePermission_Serialize,"entryPrefix":"."})
    if (params["Remove"]) qsP.appendList(body, prefix+".item", params["Remove"], {"appender":CreateVolumePermission_Serialize,"entryPrefix":"."})
}

// refs: 3 - tags: input, named, interface, output
export interface CreateVolumePermission {
  Group?: PermissionGroup | null;
  UserId?: string | null;
}
function CreateVolumePermission_Serialize(body: URLSearchParams, prefix: string, params: CreateVolumePermission) {
    if ("Group" in params) body.append(prefix+".Group", (params["Group"] ?? '').toString());
    if ("UserId" in params) body.append(prefix+".UserId", (params["UserId"] ?? '').toString());
}
function CreateVolumePermission_Parse(node: xmlP.XmlNode): CreateVolumePermission {
  return {
    Group: node.first("group", false, x => (x.content ?? '') as PermissionGroup),
    UserId: node.first("userId", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, enum, output
export type ExcessCapacityTerminationPolicy =
| "noTermination"
| "default"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface LaunchTemplateConfig {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification | null;
  Overrides: LaunchTemplateOverrides[];
}
function LaunchTemplateConfig_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateConfig) {
    if (params["LaunchTemplateSpecification"] != null) FleetLaunchTemplateSpecification_Serialize(body, prefix+".LaunchTemplateSpecification", params["LaunchTemplateSpecification"]);
    if (params["Overrides"]) qsP.appendList(body, prefix+".overrides", params["Overrides"], {"appender":LaunchTemplateOverrides_Serialize,"entryPrefix":"."})
}
function LaunchTemplateConfig_Parse(node: xmlP.XmlNode): LaunchTemplateConfig {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.getList("overrides", "item").map(LaunchTemplateOverrides_Parse),
  };
}

// refs: 8 - tags: input, named, interface, output
export interface FleetLaunchTemplateSpecification {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Version?: string | null;
}
function FleetLaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: FleetLaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}
function FleetLaunchTemplateSpecification_Parse(node: xmlP.XmlNode): FleetLaunchTemplateSpecification {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    Version: node.first("version", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface LaunchTemplateOverrides {
  InstanceType?: InstanceType | null;
  SpotPrice?: string | null;
  SubnetId?: string | null;
  AvailabilityZone?: string | null;
  WeightedCapacity?: number | null;
  Priority?: number | null;
}
function LaunchTemplateOverrides_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateOverrides) {
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
}
function LaunchTemplateOverrides_Parse(node: xmlP.XmlNode): LaunchTemplateOverrides {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    Priority: node.first("priority", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 5 - tags: input, named, enum, output
export type TrafficMirrorNetworkService =
| "amazon-dns"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TrafficMirrorFilterRuleField =
| "destination-port-range"
| "source-port-range"
| "protocol"
| "description"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TrafficMirrorSessionField =
| "packet-length"
| "description"
| "virtual-network-id"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ModifyTransitGatewayOptions {
  VpnEcmpSupport?: VpnEcmpSupportValue | null;
  DnsSupport?: DnsSupportValue | null;
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue | null;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue | null;
  AssociationDefaultRouteTableId?: string | null;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue | null;
  PropagationDefaultRouteTableId?: string | null;
}
function ModifyTransitGatewayOptions_Serialize(body: URLSearchParams, prefix: string, params: ModifyTransitGatewayOptions) {
    if ("VpnEcmpSupport" in params) body.append(prefix+".VpnEcmpSupport", (params["VpnEcmpSupport"] ?? '').toString());
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("AutoAcceptSharedAttachments" in params) body.append(prefix+".AutoAcceptSharedAttachments", (params["AutoAcceptSharedAttachments"] ?? '').toString());
    if ("DefaultRouteTableAssociation" in params) body.append(prefix+".DefaultRouteTableAssociation", (params["DefaultRouteTableAssociation"] ?? '').toString());
    if ("AssociationDefaultRouteTableId" in params) body.append(prefix+".AssociationDefaultRouteTableId", (params["AssociationDefaultRouteTableId"] ?? '').toString());
    if ("DefaultRouteTablePropagation" in params) body.append(prefix+".DefaultRouteTablePropagation", (params["DefaultRouteTablePropagation"] ?? '').toString());
    if ("PropagationDefaultRouteTableId" in params) body.append(prefix+".PropagationDefaultRouteTableId", (params["PropagationDefaultRouteTableId"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ModifyTransitGatewayVpcAttachmentRequestOptions {
  DnsSupport?: DnsSupportValue | null;
  Ipv6Support?: Ipv6SupportValue | null;
}
function ModifyTransitGatewayVpcAttachmentRequestOptions_Serialize(body: URLSearchParams, prefix: string, params: ModifyTransitGatewayVpcAttachmentRequestOptions) {
    if ("DnsSupport" in params) body.append(prefix+".DnsSupport", (params["DnsSupport"] ?? '').toString());
    if ("Ipv6Support" in params) body.append(prefix+".Ipv6Support", (params["Ipv6Support"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface PeeringConnectionOptionsRequest {
  AllowDnsResolutionFromRemoteVpc?: boolean | null;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean | null;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean | null;
}
function PeeringConnectionOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: PeeringConnectionOptionsRequest) {
    if ("AllowDnsResolutionFromRemoteVpc" in params) body.append(prefix+".AllowDnsResolutionFromRemoteVpc", (params["AllowDnsResolutionFromRemoteVpc"] ?? '').toString());
    if ("AllowEgressFromLocalClassicLinkToRemoteVpc" in params) body.append(prefix+".AllowEgressFromLocalClassicLinkToRemoteVpc", (params["AllowEgressFromLocalClassicLinkToRemoteVpc"] ?? '').toString());
    if ("AllowEgressFromLocalVpcToRemoteClassicLink" in params) body.append(prefix+".AllowEgressFromLocalVpcToRemoteClassicLink", (params["AllowEgressFromLocalVpcToRemoteClassicLink"] ?? '').toString());
}

// refs: 1 - tags: input, named, enum
export type VpcTenancy =
| "default"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ModifyVpnTunnelOptionsSpecification {
  TunnelInsideCidr?: string | null;
  TunnelInsideIpv6Cidr?: string | null;
  PreSharedKey?: string | null;
  Phase1LifetimeSeconds?: number | null;
  Phase2LifetimeSeconds?: number | null;
  RekeyMarginTimeSeconds?: number | null;
  RekeyFuzzPercentage?: number | null;
  ReplayWindowSize?: number | null;
  DPDTimeoutSeconds?: number | null;
  DPDTimeoutAction?: string | null;
  Phase1EncryptionAlgorithms?: Phase1EncryptionAlgorithmsRequestListValue[] | null;
  Phase2EncryptionAlgorithms?: Phase2EncryptionAlgorithmsRequestListValue[] | null;
  Phase1IntegrityAlgorithms?: Phase1IntegrityAlgorithmsRequestListValue[] | null;
  Phase2IntegrityAlgorithms?: Phase2IntegrityAlgorithmsRequestListValue[] | null;
  Phase1DHGroupNumbers?: Phase1DHGroupNumbersRequestListValue[] | null;
  Phase2DHGroupNumbers?: Phase2DHGroupNumbersRequestListValue[] | null;
  IKEVersions?: IKEVersionsRequestListValue[] | null;
  StartupAction?: string | null;
}
function ModifyVpnTunnelOptionsSpecification_Serialize(body: URLSearchParams, prefix: string, params: ModifyVpnTunnelOptionsSpecification) {
    if ("TunnelInsideCidr" in params) body.append(prefix+".TunnelInsideCidr", (params["TunnelInsideCidr"] ?? '').toString());
    if ("TunnelInsideIpv6Cidr" in params) body.append(prefix+".TunnelInsideIpv6Cidr", (params["TunnelInsideIpv6Cidr"] ?? '').toString());
    if ("PreSharedKey" in params) body.append(prefix+".PreSharedKey", (params["PreSharedKey"] ?? '').toString());
    if ("Phase1LifetimeSeconds" in params) body.append(prefix+".Phase1LifetimeSeconds", (params["Phase1LifetimeSeconds"] ?? '').toString());
    if ("Phase2LifetimeSeconds" in params) body.append(prefix+".Phase2LifetimeSeconds", (params["Phase2LifetimeSeconds"] ?? '').toString());
    if ("RekeyMarginTimeSeconds" in params) body.append(prefix+".RekeyMarginTimeSeconds", (params["RekeyMarginTimeSeconds"] ?? '').toString());
    if ("RekeyFuzzPercentage" in params) body.append(prefix+".RekeyFuzzPercentage", (params["RekeyFuzzPercentage"] ?? '').toString());
    if ("ReplayWindowSize" in params) body.append(prefix+".ReplayWindowSize", (params["ReplayWindowSize"] ?? '').toString());
    if ("DPDTimeoutSeconds" in params) body.append(prefix+".DPDTimeoutSeconds", (params["DPDTimeoutSeconds"] ?? '').toString());
    if ("DPDTimeoutAction" in params) body.append(prefix+".DPDTimeoutAction", (params["DPDTimeoutAction"] ?? '').toString());
    if (params["Phase1EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase1EncryptionAlgorithm", params["Phase1EncryptionAlgorithms"], {"appender":Phase1EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2EncryptionAlgorithms"]) qsP.appendList(body, prefix+".Phase2EncryptionAlgorithm", params["Phase2EncryptionAlgorithms"], {"appender":Phase2EncryptionAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase1IntegrityAlgorithm", params["Phase1IntegrityAlgorithms"], {"appender":Phase1IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2IntegrityAlgorithms"]) qsP.appendList(body, prefix+".Phase2IntegrityAlgorithm", params["Phase2IntegrityAlgorithms"], {"appender":Phase2IntegrityAlgorithmsRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase1DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase1DHGroupNumber", params["Phase1DHGroupNumbers"], {"appender":Phase1DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["Phase2DHGroupNumbers"]) qsP.appendList(body, prefix+".Phase2DHGroupNumber", params["Phase2DHGroupNumbers"], {"appender":Phase2DHGroupNumbersRequestListValue_Serialize,"entryPrefix":"."})
    if (params["IKEVersions"]) qsP.appendList(body, prefix+".IKEVersion", params["IKEVersions"], {"appender":IKEVersionsRequestListValue_Serialize,"entryPrefix":"."})
    if ("StartupAction" in params) body.append(prefix+".StartupAction", (params["StartupAction"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface CidrAuthorizationContext {
  Message: string;
  Signature: string;
}
function CidrAuthorizationContext_Serialize(body: URLSearchParams, prefix: string, params: CidrAuthorizationContext) {
    body.append(prefix+".Message", (params["Message"] ?? '').toString());
    body.append(prefix+".Signature", (params["Signature"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ReservedInstanceLimitPrice {
  Amount?: number | null;
  CurrencyCode?: CurrencyCodeValues | null;
}
function ReservedInstanceLimitPrice_Serialize(body: URLSearchParams, prefix: string, params: ReservedInstanceLimitPrice) {
    if ("Amount" in params) body.append(prefix+".Amount", (params["Amount"] ?? '').toString());
    if ("CurrencyCode" in params) body.append(prefix+".CurrencyCode", (params["CurrencyCode"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface PurchaseRequest {
  InstanceCount: number;
  PurchaseToken: string;
}
function PurchaseRequest_Serialize(body: URLSearchParams, prefix: string, params: PurchaseRequest) {
    body.append(prefix+".InstanceCount", (params["InstanceCount"] ?? '').toString());
    body.append(prefix+".PurchaseToken", (params["PurchaseToken"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface RegisterInstanceTagAttributeRequest {
  IncludeAllTagsOfInstance?: boolean | null;
  InstanceTagKeys?: string[] | null;
}
function RegisterInstanceTagAttributeRequest_Serialize(body: URLSearchParams, prefix: string, params: RegisterInstanceTagAttributeRequest) {
    if ("IncludeAllTagsOfInstance" in params) body.append(prefix+".IncludeAllTagsOfInstance", (params["IncludeAllTagsOfInstance"] ?? '').toString());
    if (params["InstanceTagKeys"]) qsP.appendList(body, prefix+".InstanceTagKey", params["InstanceTagKeys"], {"entryPrefix":"."})
}

// refs: 1 - tags: input, named, enum
export type ReportInstanceReasonCodes =
| "instance-stuck-in-state"
| "unresponsive"
| "not-accepting-credentials"
| "password-not-available"
| "performance-network"
| "performance-instance-store"
| "performance-ebs-volume"
| "performance-other"
| "other"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ReportStatusType =
| "ok"
| "impaired"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface SpotFleetRequestConfigData {
  AllocationStrategy?: AllocationStrategy | null;
  OnDemandAllocationStrategy?: OnDemandAllocationStrategy | null;
  ClientToken?: string | null;
  ExcessCapacityTerminationPolicy?: ExcessCapacityTerminationPolicy | null;
  FulfilledCapacity?: number | null;
  OnDemandFulfilledCapacity?: number | null;
  IamFleetRole: string;
  LaunchSpecifications: SpotFleetLaunchSpecification[];
  LaunchTemplateConfigs: LaunchTemplateConfig[];
  SpotPrice?: string | null;
  TargetCapacity: number;
  OnDemandTargetCapacity?: number | null;
  OnDemandMaxTotalPrice?: string | null;
  SpotMaxTotalPrice?: string | null;
  TerminateInstancesWithExpiration?: boolean | null;
  Type?: FleetType | null;
  ValidFrom?: Date | number | null;
  ValidUntil?: Date | number | null;
  ReplaceUnhealthyInstances?: boolean | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
  LoadBalancersConfig?: LoadBalancersConfig | null;
  InstancePoolsToUseCount?: number | null;
  TagSpecifications: TagSpecification[];
}
function SpotFleetRequestConfigData_Serialize(body: URLSearchParams, prefix: string, params: SpotFleetRequestConfigData) {
    if ("AllocationStrategy" in params) body.append(prefix+".AllocationStrategy", (params["AllocationStrategy"] ?? '').toString());
    if ("OnDemandAllocationStrategy" in params) body.append(prefix+".OnDemandAllocationStrategy", (params["OnDemandAllocationStrategy"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+".ClientToken", (params["ClientToken"] ?? '').toString());
    if ("ExcessCapacityTerminationPolicy" in params) body.append(prefix+".ExcessCapacityTerminationPolicy", (params["ExcessCapacityTerminationPolicy"] ?? '').toString());
    if ("FulfilledCapacity" in params) body.append(prefix+".FulfilledCapacity", (params["FulfilledCapacity"] ?? '').toString());
    if ("OnDemandFulfilledCapacity" in params) body.append(prefix+".OnDemandFulfilledCapacity", (params["OnDemandFulfilledCapacity"] ?? '').toString());
    body.append(prefix+".IamFleetRole", (params["IamFleetRole"] ?? '').toString());
    if (params["LaunchSpecifications"]) qsP.appendList(body, prefix+".launchSpecifications", params["LaunchSpecifications"], {"appender":SpotFleetLaunchSpecification_Serialize,"entryPrefix":"."})
    if (params["LaunchTemplateConfigs"]) qsP.appendList(body, prefix+".launchTemplateConfigs", params["LaunchTemplateConfigs"], {"appender":LaunchTemplateConfig_Serialize,"entryPrefix":"."})
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    body.append(prefix+".TargetCapacity", (params["TargetCapacity"] ?? '').toString());
    if ("OnDemandTargetCapacity" in params) body.append(prefix+".OnDemandTargetCapacity", (params["OnDemandTargetCapacity"] ?? '').toString());
    if ("OnDemandMaxTotalPrice" in params) body.append(prefix+".OnDemandMaxTotalPrice", (params["OnDemandMaxTotalPrice"] ?? '').toString());
    if ("SpotMaxTotalPrice" in params) body.append(prefix+".SpotMaxTotalPrice", (params["SpotMaxTotalPrice"] ?? '').toString());
    if ("TerminateInstancesWithExpiration" in params) body.append(prefix+".TerminateInstancesWithExpiration", (params["TerminateInstancesWithExpiration"] ?? '').toString());
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("ValidFrom" in params) body.append(prefix+".ValidFrom", qsP.encodeDate_iso8601(params["ValidFrom"]));
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("ReplaceUnhealthyInstances" in params) body.append(prefix+".ReplaceUnhealthyInstances", (params["ReplaceUnhealthyInstances"] ?? '').toString());
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
    if (params["LoadBalancersConfig"] != null) LoadBalancersConfig_Serialize(body, prefix+".LoadBalancersConfig", params["LoadBalancersConfig"]);
    if ("InstancePoolsToUseCount" in params) body.append(prefix+".InstancePoolsToUseCount", (params["InstancePoolsToUseCount"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".TagSpecification", params["TagSpecifications"], {"appender":TagSpecification_Serialize,"entryPrefix":"."})
}
function SpotFleetRequestConfigData_Parse(node: xmlP.XmlNode): SpotFleetRequestConfigData {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as AllocationStrategy),
    OnDemandAllocationStrategy: node.first("onDemandAllocationStrategy", false, x => (x.content ?? '') as OnDemandAllocationStrategy),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    ExcessCapacityTerminationPolicy: node.first("excessCapacityTerminationPolicy", false, x => (x.content ?? '') as ExcessCapacityTerminationPolicy),
    FulfilledCapacity: node.first("fulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    OnDemandFulfilledCapacity: node.first("onDemandFulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    IamFleetRole: node.first("iamFleetRole", true, x => x.content ?? ''),
    LaunchSpecifications: node.getList("launchSpecifications", "item").map(SpotFleetLaunchSpecification_Parse),
    LaunchTemplateConfigs: node.getList("launchTemplateConfigs", "item").map(LaunchTemplateConfig_Parse),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    TargetCapacity: node.first("targetCapacity", true, x => parseInt(x.content ?? '0')),
    OnDemandTargetCapacity: node.first("onDemandTargetCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandMaxTotalPrice: node.first("onDemandMaxTotalPrice", false, x => x.content ?? ''),
    SpotMaxTotalPrice: node.first("spotMaxTotalPrice", false, x => x.content ?? ''),
    TerminateInstancesWithExpiration: node.first("terminateInstancesWithExpiration", false, x => x.content === 'true'),
    Type: node.first("type", false, x => (x.content ?? '') as FleetType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    ReplaceUnhealthyInstances: node.first("replaceUnhealthyInstances", false, x => x.content === 'true'),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as InstanceInterruptionBehavior),
    LoadBalancersConfig: node.first("loadBalancersConfig", false, LoadBalancersConfig_Parse),
    InstancePoolsToUseCount: node.first("instancePoolsToUseCount", false, x => parseInt(x.content ?? '0')),
    TagSpecifications: node.getList("TagSpecification", "item").map(TagSpecification_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type AllocationStrategy =
| "lowestPrice"
| "diversified"
| "capacityOptimized"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type OnDemandAllocationStrategy =
| "lowestPrice"
| "prioritized"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface SpotFleetLaunchSpecification {
  SecurityGroups: GroupIdentifier[];
  AddressingType?: string | null;
  BlockDeviceMappings: BlockDeviceMapping[];
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: IamInstanceProfileSpecification | null;
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  KernelId?: string | null;
  KeyName?: string | null;
  Monitoring?: SpotFleetMonitoring | null;
  NetworkInterfaces: InstanceNetworkInterfaceSpecification[];
  Placement?: SpotPlacement | null;
  RamdiskId?: string | null;
  SpotPrice?: string | null;
  SubnetId?: string | null;
  UserData?: string | null;
  WeightedCapacity?: number | null;
  TagSpecifications: SpotFleetTagSpecification[];
}
function SpotFleetLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: SpotFleetLaunchSpecification) {
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".groupSet", params["SecurityGroups"], {"appender":GroupIdentifier_Serialize,"entryPrefix":"."})
    if ("AddressingType" in params) body.append(prefix+".AddressingType", (params["AddressingType"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) SpotFleetMonitoring_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".networkInterfaceSet", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) SpotPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("SpotPrice" in params) body.append(prefix+".SpotPrice", (params["SpotPrice"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
    if ("WeightedCapacity" in params) body.append(prefix+".WeightedCapacity", (params["WeightedCapacity"] ?? '').toString());
    if (params["TagSpecifications"]) qsP.appendList(body, prefix+".tagSpecificationSet", params["TagSpecifications"], {"appender":SpotFleetTagSpecification_Serialize,"entryPrefix":"."})
}
function SpotFleetLaunchSpecification_Parse(node: xmlP.XmlNode): SpotFleetLaunchSpecification {
  return {
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    AddressingType: node.first("addressingType", false, x => x.content ?? ''),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfileSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, SpotFleetMonitoring_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterfaceSpecification_Parse),
    Placement: node.first("placement", false, SpotPlacement_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    UserData: node.first("userData", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    TagSpecifications: node.getList("tagSpecificationSet", "item").map(SpotFleetTagSpecification_Parse),
  };
}

// refs: 15 - tags: input, named, interface, output
export interface GroupIdentifier {
  GroupName?: string | null;
  GroupId?: string | null;
}
function GroupIdentifier_Serialize(body: URLSearchParams, prefix: string, params: GroupIdentifier) {
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("GroupId" in params) body.append(prefix+".GroupId", (params["GroupId"] ?? '').toString());
}
function GroupIdentifier_Parse(node: xmlP.XmlNode): GroupIdentifier {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface SpotFleetMonitoring {
  Enabled?: boolean | null;
}
function SpotFleetMonitoring_Serialize(body: URLSearchParams, prefix: string, params: SpotFleetMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function SpotFleetMonitoring_Parse(node: xmlP.XmlNode): SpotFleetMonitoring {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface InstanceNetworkInterfaceSpecification {
  AssociatePublicIpAddress?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Description?: string | null;
  DeviceIndex?: number | null;
  Groups: string[];
  Ipv6AddressCount?: number | null;
  Ipv6Addresses: InstanceIpv6Address[];
  NetworkInterfaceId?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number | null;
  SubnetId?: string | null;
  AssociateCarrierIpAddress?: boolean | null;
  InterfaceType?: string | null;
}
function InstanceNetworkInterfaceSpecification_Serialize(body: URLSearchParams, prefix: string, params: InstanceNetworkInterfaceSpecification) {
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".SecurityGroupId", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".Ipv6Addresses", params["Ipv6Addresses"], {"appender":InstanceIpv6Address_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddresses"]) qsP.appendList(body, prefix+".PrivateIpAddresses", params["PrivateIpAddresses"], {"appender":PrivateIpAddressSpecification_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AssociateCarrierIpAddress" in params) body.append(prefix+".AssociateCarrierIpAddress", (params["AssociateCarrierIpAddress"] ?? '').toString());
    if ("InterfaceType" in params) body.append(prefix+".InterfaceType", (params["InterfaceType"] ?? '').toString());
}
function InstanceNetworkInterfaceSpecification_Parse(node: xmlP.XmlNode): InstanceNetworkInterfaceSpecification {
  return {
    ...node.strings({
      optional: {"InterfaceType":true},
    }),
    AssociatePublicIpAddress: node.first("associatePublicIpAddress", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Groups: node.getList("SecurityGroupId", "SecurityGroupId").map(x => x.content ?? ''),
    Ipv6AddressCount: node.first("ipv6AddressCount", false, x => parseInt(x.content ?? '0')),
    Ipv6Addresses: node.getList("Ipv6Addresses", "item").map(InstanceIpv6Address_Parse),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("PrivateIpAddresses", "item").map(PrivateIpAddressSpecification_Parse),
    SecondaryPrivateIpAddressCount: node.first("secondaryPrivateIpAddressCount", false, x => parseInt(x.content ?? '0')),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AssociateCarrierIpAddress: node.first("AssociateCarrierIpAddress", false, x => x.content === 'true'),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface SpotPlacement {
  AvailabilityZone?: string | null;
  GroupName?: string | null;
  Tenancy?: Tenancy | null;
}
function SpotPlacement_Serialize(body: URLSearchParams, prefix: string, params: SpotPlacement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
    if ("Tenancy" in params) body.append(prefix+".Tenancy", (params["Tenancy"] ?? '').toString());
}
function SpotPlacement_Parse(node: xmlP.XmlNode): SpotPlacement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as Tenancy),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface SpotFleetTagSpecification {
  ResourceType?: ResourceType | null;
  Tags: Tag[];
}
function SpotFleetTagSpecification_Serialize(body: URLSearchParams, prefix: string, params: SpotFleetTagSpecification) {
    if ("ResourceType" in params) body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+".tag", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":"."})
}
function SpotFleetTagSpecification_Parse(node: xmlP.XmlNode): SpotFleetTagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as ResourceType),
    Tags: node.getList("tag", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LoadBalancersConfig {
  ClassicLoadBalancersConfig?: ClassicLoadBalancersConfig | null;
  TargetGroupsConfig?: TargetGroupsConfig | null;
}
function LoadBalancersConfig_Serialize(body: URLSearchParams, prefix: string, params: LoadBalancersConfig) {
    if (params["ClassicLoadBalancersConfig"] != null) ClassicLoadBalancersConfig_Serialize(body, prefix+".ClassicLoadBalancersConfig", params["ClassicLoadBalancersConfig"]);
    if (params["TargetGroupsConfig"] != null) TargetGroupsConfig_Serialize(body, prefix+".TargetGroupsConfig", params["TargetGroupsConfig"]);
}
function LoadBalancersConfig_Parse(node: xmlP.XmlNode): LoadBalancersConfig {
  return {
    ClassicLoadBalancersConfig: node.first("classicLoadBalancersConfig", false, ClassicLoadBalancersConfig_Parse),
    TargetGroupsConfig: node.first("targetGroupsConfig", false, TargetGroupsConfig_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ClassicLoadBalancersConfig {
  ClassicLoadBalancers: ClassicLoadBalancer[];
}
function ClassicLoadBalancersConfig_Serialize(body: URLSearchParams, prefix: string, params: ClassicLoadBalancersConfig) {
    if (params["ClassicLoadBalancers"]) qsP.appendList(body, prefix+".classicLoadBalancers", params["ClassicLoadBalancers"], {"appender":ClassicLoadBalancer_Serialize,"entryPrefix":"."})
}
function ClassicLoadBalancersConfig_Parse(node: xmlP.XmlNode): ClassicLoadBalancersConfig {
  return {
    ClassicLoadBalancers: node.getList("classicLoadBalancers", "item").map(ClassicLoadBalancer_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ClassicLoadBalancer {
  Name?: string | null;
}
function ClassicLoadBalancer_Serialize(body: URLSearchParams, prefix: string, params: ClassicLoadBalancer) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function ClassicLoadBalancer_Parse(node: xmlP.XmlNode): ClassicLoadBalancer {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TargetGroupsConfig {
  TargetGroups: TargetGroup[];
}
function TargetGroupsConfig_Serialize(body: URLSearchParams, prefix: string, params: TargetGroupsConfig) {
    if (params["TargetGroups"]) qsP.appendList(body, prefix+".targetGroups", params["TargetGroups"], {"appender":TargetGroup_Serialize,"entryPrefix":"."})
}
function TargetGroupsConfig_Parse(node: xmlP.XmlNode): TargetGroupsConfig {
  return {
    TargetGroups: node.getList("targetGroups", "item").map(TargetGroup_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface TargetGroup {
  Arn?: string | null;
}
function TargetGroup_Serialize(body: URLSearchParams, prefix: string, params: TargetGroup) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
}
function TargetGroup_Parse(node: xmlP.XmlNode): TargetGroup {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: input, named, interface
export interface RequestSpotLaunchSpecification {
  SecurityGroupIds?: string[] | null;
  SecurityGroups?: string[] | null;
  AddressingType?: string | null;
  BlockDeviceMappings?: BlockDeviceMapping[] | null;
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: IamInstanceProfileSpecification | null;
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  KernelId?: string | null;
  KeyName?: string | null;
  Monitoring?: RunInstancesMonitoringEnabled | null;
  NetworkInterfaces?: InstanceNetworkInterfaceSpecification[] | null;
  Placement?: SpotPlacement | null;
  RamdiskId?: string | null;
  SubnetId?: string | null;
  UserData?: string | null;
}
function RequestSpotLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: RequestSpotLaunchSpecification) {
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+".SecurityGroup", params["SecurityGroups"], {"entryPrefix":"."})
    if ("AddressingType" in params) body.append(prefix+".AddressingType", (params["AddressingType"] ?? '').toString());
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".blockDeviceMapping", params["BlockDeviceMappings"], {"appender":BlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) IamInstanceProfileSpecification_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    if ("ImageId" in params) body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) RunInstancesMonitoringEnabled_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":InstanceNetworkInterfaceSpecification_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) SpotPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
}

// refs: 4 - tags: input, named, interface, output
export interface RunInstancesMonitoringEnabled {
  Enabled: boolean;
}
function RunInstancesMonitoringEnabled_Serialize(body: URLSearchParams, prefix: string, params: RunInstancesMonitoringEnabled) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function RunInstancesMonitoringEnabled_Parse(node: xmlP.XmlNode): RunInstancesMonitoringEnabled {
  return {
    Enabled: node.first("enabled", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, enum
export type ResetFpgaImageAttributeName =
| "loadPermission"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ResetImageAttributeName =
| "launchPermission"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ElasticInferenceAccelerator {
  Type: string;
  Count?: number | null;
}
function ElasticInferenceAccelerator_Serialize(body: URLSearchParams, prefix: string, params: ElasticInferenceAccelerator) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Count" in params) body.append(prefix+".Count", (params["Count"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface LaunchTemplateSpecification {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  Version?: string | null;
}
function LaunchTemplateSpecification_Serialize(body: URLSearchParams, prefix: string, params: LaunchTemplateSpecification) {
    if ("LaunchTemplateId" in params) body.append(prefix+".LaunchTemplateId", (params["LaunchTemplateId"] ?? '').toString());
    if ("LaunchTemplateName" in params) body.append(prefix+".LaunchTemplateName", (params["LaunchTemplateName"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface InstanceMarketOptionsRequest {
  MarketType?: MarketType | null;
  SpotOptions?: SpotMarketOptions | null;
}
function InstanceMarketOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: InstanceMarketOptionsRequest) {
    if ("MarketType" in params) body.append(prefix+".MarketType", (params["MarketType"] ?? '').toString());
    if (params["SpotOptions"] != null) SpotMarketOptions_Serialize(body, prefix+".SpotOptions", params["SpotOptions"]);
}

// refs: 1 - tags: input, named, interface
export interface SpotMarketOptions {
  MaxPrice?: string | null;
  SpotInstanceType?: SpotInstanceType | null;
  BlockDurationMinutes?: number | null;
  ValidUntil?: Date | number | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
}
function SpotMarketOptions_Serialize(body: URLSearchParams, prefix: string, params: SpotMarketOptions) {
    if ("MaxPrice" in params) body.append(prefix+".MaxPrice", (params["MaxPrice"] ?? '').toString());
    if ("SpotInstanceType" in params) body.append(prefix+".SpotInstanceType", (params["SpotInstanceType"] ?? '').toString());
    if ("BlockDurationMinutes" in params) body.append(prefix+".BlockDurationMinutes", (params["BlockDurationMinutes"] ?? '').toString());
    if ("ValidUntil" in params) body.append(prefix+".ValidUntil", qsP.encodeDate_iso8601(params["ValidUntil"]));
    if ("InstanceInterruptionBehavior" in params) body.append(prefix+".InstanceInterruptionBehavior", (params["InstanceInterruptionBehavior"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface CpuOptionsRequest {
  CoreCount?: number | null;
  ThreadsPerCore?: number | null;
}
function CpuOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: CpuOptionsRequest) {
    if ("CoreCount" in params) body.append(prefix+".CoreCount", (params["CoreCount"] ?? '').toString());
    if ("ThreadsPerCore" in params) body.append(prefix+".ThreadsPerCore", (params["ThreadsPerCore"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface HibernationOptionsRequest {
  Configured?: boolean | null;
}
function HibernationOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: HibernationOptionsRequest) {
    if ("Configured" in params) body.append(prefix+".Configured", (params["Configured"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface LicenseConfigurationRequest {
  LicenseConfigurationArn?: string | null;
}
function LicenseConfigurationRequest_Serialize(body: URLSearchParams, prefix: string, params: LicenseConfigurationRequest) {
    if ("LicenseConfigurationArn" in params) body.append(prefix+".LicenseConfigurationArn", (params["LicenseConfigurationArn"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface InstanceMetadataOptionsRequest {
  HttpTokens?: HttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: InstanceMetadataEndpointState | null;
}
function InstanceMetadataOptionsRequest_Serialize(body: URLSearchParams, prefix: string, params: InstanceMetadataOptionsRequest) {
    if ("HttpTokens" in params) body.append(prefix+".HttpTokens", (params["HttpTokens"] ?? '').toString());
    if ("HttpPutResponseHopLimit" in params) body.append(prefix+".HttpPutResponseHopLimit", (params["HttpPutResponseHopLimit"] ?? '').toString());
    if ("HttpEndpoint" in params) body.append(prefix+".HttpEndpoint", (params["HttpEndpoint"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesLaunchSpecification {
  BlockDeviceMappings?: ScheduledInstancesBlockDeviceMapping[] | null;
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: ScheduledInstancesIamInstanceProfile | null;
  ImageId: string;
  InstanceType?: string | null;
  KernelId?: string | null;
  KeyName?: string | null;
  Monitoring?: ScheduledInstancesMonitoring | null;
  NetworkInterfaces?: ScheduledInstancesNetworkInterface[] | null;
  Placement?: ScheduledInstancesPlacement | null;
  RamdiskId?: string | null;
  SecurityGroupIds?: string[] | null;
  SubnetId?: string | null;
  UserData?: string | null;
}
function ScheduledInstancesLaunchSpecification_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesLaunchSpecification) {
    if (params["BlockDeviceMappings"]) qsP.appendList(body, prefix+".BlockDeviceMapping", params["BlockDeviceMappings"], {"appender":ScheduledInstancesBlockDeviceMapping_Serialize,"entryPrefix":"."})
    if ("EbsOptimized" in params) body.append(prefix+".EbsOptimized", (params["EbsOptimized"] ?? '').toString());
    if (params["IamInstanceProfile"] != null) ScheduledInstancesIamInstanceProfile_Serialize(body, prefix+".IamInstanceProfile", params["IamInstanceProfile"]);
    body.append(prefix+".ImageId", (params["ImageId"] ?? '').toString());
    if ("InstanceType" in params) body.append(prefix+".InstanceType", (params["InstanceType"] ?? '').toString());
    if ("KernelId" in params) body.append(prefix+".KernelId", (params["KernelId"] ?? '').toString());
    if ("KeyName" in params) body.append(prefix+".KeyName", (params["KeyName"] ?? '').toString());
    if (params["Monitoring"] != null) ScheduledInstancesMonitoring_Serialize(body, prefix+".Monitoring", params["Monitoring"]);
    if (params["NetworkInterfaces"]) qsP.appendList(body, prefix+".NetworkInterface", params["NetworkInterfaces"], {"appender":ScheduledInstancesNetworkInterface_Serialize,"entryPrefix":"."})
    if (params["Placement"] != null) ScheduledInstancesPlacement_Serialize(body, prefix+".Placement", params["Placement"]);
    if ("RamdiskId" in params) body.append(prefix+".RamdiskId", (params["RamdiskId"] ?? '').toString());
    if (params["SecurityGroupIds"]) qsP.appendList(body, prefix+".SecurityGroupId", params["SecurityGroupIds"], {"entryPrefix":"."})
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("UserData" in params) body.append(prefix+".UserData", (params["UserData"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesBlockDeviceMapping {
  DeviceName?: string | null;
  Ebs?: ScheduledInstancesEbs | null;
  NoDevice?: string | null;
  VirtualName?: string | null;
}
function ScheduledInstancesBlockDeviceMapping_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesBlockDeviceMapping) {
    if ("DeviceName" in params) body.append(prefix+".DeviceName", (params["DeviceName"] ?? '').toString());
    if (params["Ebs"] != null) ScheduledInstancesEbs_Serialize(body, prefix+".Ebs", params["Ebs"]);
    if ("NoDevice" in params) body.append(prefix+".NoDevice", (params["NoDevice"] ?? '').toString());
    if ("VirtualName" in params) body.append(prefix+".VirtualName", (params["VirtualName"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesEbs {
  DeleteOnTermination?: boolean | null;
  Encrypted?: boolean | null;
  Iops?: number | null;
  SnapshotId?: string | null;
  VolumeSize?: number | null;
  VolumeType?: string | null;
}
function ScheduledInstancesEbs_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesEbs) {
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Encrypted" in params) body.append(prefix+".Encrypted", (params["Encrypted"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+".Iops", (params["Iops"] ?? '').toString());
    if ("SnapshotId" in params) body.append(prefix+".SnapshotId", (params["SnapshotId"] ?? '').toString());
    if ("VolumeSize" in params) body.append(prefix+".VolumeSize", (params["VolumeSize"] ?? '').toString());
    if ("VolumeType" in params) body.append(prefix+".VolumeType", (params["VolumeType"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesIamInstanceProfile {
  Arn?: string | null;
  Name?: string | null;
}
function ScheduledInstancesIamInstanceProfile_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesIamInstanceProfile) {
    if ("Arn" in params) body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesMonitoring {
  Enabled?: boolean | null;
}
function ScheduledInstancesMonitoring_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesMonitoring) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesNetworkInterface {
  AssociatePublicIpAddress?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Description?: string | null;
  DeviceIndex?: number | null;
  Groups?: string[] | null;
  Ipv6AddressCount?: number | null;
  Ipv6Addresses?: ScheduledInstancesIpv6Address[] | null;
  NetworkInterfaceId?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddressConfigs?: ScheduledInstancesPrivateIpAddressConfig[] | null;
  SecondaryPrivateIpAddressCount?: number | null;
  SubnetId?: string | null;
}
function ScheduledInstancesNetworkInterface_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesNetworkInterface) {
    if ("AssociatePublicIpAddress" in params) body.append(prefix+".AssociatePublicIpAddress", (params["AssociatePublicIpAddress"] ?? '').toString());
    if ("DeleteOnTermination" in params) body.append(prefix+".DeleteOnTermination", (params["DeleteOnTermination"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("DeviceIndex" in params) body.append(prefix+".DeviceIndex", (params["DeviceIndex"] ?? '').toString());
    if (params["Groups"]) qsP.appendList(body, prefix+".Group", params["Groups"], {"entryPrefix":"."})
    if ("Ipv6AddressCount" in params) body.append(prefix+".Ipv6AddressCount", (params["Ipv6AddressCount"] ?? '').toString());
    if (params["Ipv6Addresses"]) qsP.appendList(body, prefix+".Ipv6Address", params["Ipv6Addresses"], {"appender":ScheduledInstancesIpv6Address_Serialize,"entryPrefix":"."})
    if ("NetworkInterfaceId" in params) body.append(prefix+".NetworkInterfaceId", (params["NetworkInterfaceId"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
    if (params["PrivateIpAddressConfigs"]) qsP.appendList(body, prefix+".PrivateIpAddressConfig", params["PrivateIpAddressConfigs"], {"appender":ScheduledInstancesPrivateIpAddressConfig_Serialize,"entryPrefix":"."})
    if ("SecondaryPrivateIpAddressCount" in params) body.append(prefix+".SecondaryPrivateIpAddressCount", (params["SecondaryPrivateIpAddressCount"] ?? '').toString());
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesIpv6Address {
  Ipv6Address?: string | null;
}
function ScheduledInstancesIpv6Address_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesIpv6Address) {
    if ("Ipv6Address" in params) body.append(prefix+".Ipv6Address", (params["Ipv6Address"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesPrivateIpAddressConfig {
  Primary?: boolean | null;
  PrivateIpAddress?: string | null;
}
function ScheduledInstancesPrivateIpAddressConfig_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesPrivateIpAddressConfig) {
    if ("Primary" in params) body.append(prefix+".Primary", (params["Primary"] ?? '').toString());
    if ("PrivateIpAddress" in params) body.append(prefix+".PrivateIpAddress", (params["PrivateIpAddress"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ScheduledInstancesPlacement {
  AvailabilityZone?: string | null;
  GroupName?: string | null;
}
function ScheduledInstancesPlacement_Serialize(body: URLSearchParams, prefix: string, params: ScheduledInstancesPlacement) {
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+".GroupName", (params["GroupName"] ?? '').toString());
}

// refs: 5 - tags: output, named, interface
export interface TransitGatewayPeeringAttachment {
  TransitGatewayAttachmentId?: string | null;
  RequesterTgwInfo?: PeeringTgwInfo | null;
  AccepterTgwInfo?: PeeringTgwInfo | null;
  Status?: PeeringAttachmentStatus | null;
  State?: TransitGatewayAttachmentState | null;
  CreationTime?: Date | number | null;
  Tags: Tag[];
}
function TransitGatewayPeeringAttachment_Parse(node: xmlP.XmlNode): TransitGatewayPeeringAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    RequesterTgwInfo: node.first("requesterTgwInfo", false, PeeringTgwInfo_Parse),
    AccepterTgwInfo: node.first("accepterTgwInfo", false, PeeringTgwInfo_Parse),
    Status: node.first("status", false, PeeringAttachmentStatus_Parse),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAttachmentState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 10 - tags: output, named, interface
export interface PeeringTgwInfo {
  TransitGatewayId?: string | null;
  OwnerId?: string | null;
  Region?: string | null;
}
function PeeringTgwInfo_Parse(node: xmlP.XmlNode): PeeringTgwInfo {
  return {
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Region: node.first("region", false, x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, interface
export interface PeeringAttachmentStatus {
  Code?: string | null;
  Message?: string | null;
}
function PeeringAttachmentStatus_Parse(node: xmlP.XmlNode): PeeringAttachmentStatus {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 12 - tags: output, named, enum
export type TransitGatewayAttachmentState =
| "initiating"
| "initiatingRequest"
| "pendingAcceptance"
| "rollingBack"
| "pending"
| "available"
| "modifying"
| "deleting"
| "deleted"
| "failed"
| "rejected"
| "rejecting"
| "failing"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface TransitGatewayVpcAttachment {
  TransitGatewayAttachmentId?: string | null;
  TransitGatewayId?: string | null;
  VpcId?: string | null;
  VpcOwnerId?: string | null;
  State?: TransitGatewayAttachmentState | null;
  SubnetIds: string[];
  CreationTime?: Date | number | null;
  Options?: TransitGatewayVpcAttachmentOptions | null;
  Tags: Tag[];
}
function TransitGatewayVpcAttachment_Parse(node: xmlP.XmlNode): TransitGatewayVpcAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    VpcOwnerId: node.first("vpcOwnerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAttachmentState),
    SubnetIds: node.getList("subnetIds", "item").map(x => x.content ?? ''),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Options: node.first("options", false, TransitGatewayVpcAttachmentOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 6 - tags: output, named, interface
export interface TransitGatewayVpcAttachmentOptions {
  DnsSupport?: DnsSupportValue | null;
  Ipv6Support?: Ipv6SupportValue | null;
}
function TransitGatewayVpcAttachmentOptions_Parse(node: xmlP.XmlNode): TransitGatewayVpcAttachmentOptions {
  return {
    DnsSupport: node.first("dnsSupport", false, x => (x.content ?? '') as DnsSupportValue),
    Ipv6Support: node.first("ipv6Support", false, x => (x.content ?? '') as Ipv6SupportValue),
  };
}

// refs: 9 - tags: output, named, interface
export interface UnsuccessfulItem {
  Error?: UnsuccessfulItemError | null;
  ResourceId?: string | null;
}
function UnsuccessfulItem_Parse(node: xmlP.XmlNode): UnsuccessfulItem {
  return {
    Error: node.first("error", false, UnsuccessfulItemError_Parse),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
  };
}

// refs: 9 - tags: output, named, interface
export interface UnsuccessfulItemError {
  Code?: string | null;
  Message?: string | null;
}
function UnsuccessfulItemError_Parse(node: xmlP.XmlNode): UnsuccessfulItemError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface VpcPeeringConnection {
  AccepterVpcInfo?: VpcPeeringConnectionVpcInfo | null;
  ExpirationTime?: Date | number | null;
  RequesterVpcInfo?: VpcPeeringConnectionVpcInfo | null;
  Status?: VpcPeeringConnectionStateReason | null;
  Tags: Tag[];
  VpcPeeringConnectionId?: string | null;
}
function VpcPeeringConnection_Parse(node: xmlP.XmlNode): VpcPeeringConnection {
  return {
    AccepterVpcInfo: node.first("accepterVpcInfo", false, VpcPeeringConnectionVpcInfo_Parse),
    ExpirationTime: node.first("expirationTime", false, x => xmlP.parseTimestamp(x.content)),
    RequesterVpcInfo: node.first("requesterVpcInfo", false, VpcPeeringConnectionVpcInfo_Parse),
    Status: node.first("status", false, VpcPeeringConnectionStateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface VpcPeeringConnectionVpcInfo {
  CidrBlock?: string | null;
  Ipv6CidrBlockSet: Ipv6CidrBlock[];
  CidrBlockSet: CidrBlock[];
  OwnerId?: string | null;
  PeeringOptions?: VpcPeeringConnectionOptionsDescription | null;
  VpcId?: string | null;
  Region?: string | null;
}
function VpcPeeringConnectionVpcInfo_Parse(node: xmlP.XmlNode): VpcPeeringConnectionVpcInfo {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockSet: node.getList("ipv6CidrBlockSet", "item").map(Ipv6CidrBlock_Parse),
    CidrBlockSet: node.getList("cidrBlockSet", "item").map(CidrBlock_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PeeringOptions: node.first("peeringOptions", false, VpcPeeringConnectionOptionsDescription_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Region: node.first("region", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Ipv6CidrBlock {
  Ipv6CidrBlock?: string | null;
}
function Ipv6CidrBlock_Parse(node: xmlP.XmlNode): Ipv6CidrBlock {
  return {
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface CidrBlock {
  CidrBlock?: string | null;
}
function CidrBlock_Parse(node: xmlP.XmlNode): CidrBlock {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface VpcPeeringConnectionOptionsDescription {
  AllowDnsResolutionFromRemoteVpc?: boolean | null;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean | null;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean | null;
}
function VpcPeeringConnectionOptionsDescription_Parse(node: xmlP.XmlNode): VpcPeeringConnectionOptionsDescription {
  return {
    AllowDnsResolutionFromRemoteVpc: node.first("allowDnsResolutionFromRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalClassicLinkToRemoteVpc: node.first("allowEgressFromLocalClassicLinkToRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalVpcToRemoteClassicLink: node.first("allowEgressFromLocalVpcToRemoteClassicLink", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface VpcPeeringConnectionStateReason {
  Code?: VpcPeeringConnectionStateReasonCode | null;
  Message?: string | null;
}
function VpcPeeringConnectionStateReason_Parse(node: xmlP.XmlNode): VpcPeeringConnectionStateReason {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as VpcPeeringConnectionStateReasonCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type VpcPeeringConnectionStateReasonCode =
| "initiating-request"
| "pending-acceptance"
| "active"
| "deleted"
| "rejected"
| "failed"
| "expired"
| "provisioning"
| "deleting"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface ByoipCidr {
  Cidr?: string | null;
  Description?: string | null;
  StatusMessage?: string | null;
  State?: ByoipCidrState | null;
}
function ByoipCidr_Parse(node: xmlP.XmlNode): ByoipCidr {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as ByoipCidrState),
  };
}

// refs: 5 - tags: output, named, enum
export type ByoipCidrState =
| "advertised"
| "deprovisioned"
| "failed-deprovision"
| "failed-provision"
| "pending-deprovision"
| "pending-provision"
| "provisioned"
| "provisioned-not-publicly-advertisable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AssignedPrivateIpAddress {
  PrivateIpAddress?: string | null;
}
function AssignedPrivateIpAddress_Parse(node: xmlP.XmlNode): AssignedPrivateIpAddress {
  return {
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface AssociationStatus {
  Code?: AssociationStatusCode | null;
  Message?: string | null;
}
function AssociationStatus_Parse(node: xmlP.XmlNode): AssociationStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as AssociationStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type AssociationStatusCode =
| "associating"
| "associated"
| "association-failed"
| "disassociating"
| "disassociated"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface IamInstanceProfileAssociation {
  AssociationId?: string | null;
  InstanceId?: string | null;
  IamInstanceProfile?: IamInstanceProfile | null;
  State?: IamInstanceProfileAssociationState | null;
  Timestamp?: Date | number | null;
}
function IamInstanceProfileAssociation_Parse(node: xmlP.XmlNode): IamInstanceProfileAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfile_Parse),
    State: node.first("state", false, x => (x.content ?? '') as IamInstanceProfileAssociationState),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 6 - tags: output, named, interface
export interface IamInstanceProfile {
  Arn?: string | null;
  Id?: string | null;
}
function IamInstanceProfile_Parse(node: xmlP.XmlNode): IamInstanceProfile {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Id: node.first("id", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type IamInstanceProfileAssociationState =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface RouteTableAssociationState {
  State?: RouteTableAssociationStateCode | null;
  StatusMessage?: string | null;
}
function RouteTableAssociationState_Parse(node: xmlP.XmlNode): RouteTableAssociationState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as RouteTableAssociationStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type RouteTableAssociationStateCode =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface SubnetIpv6CidrBlockAssociation {
  AssociationId?: string | null;
  Ipv6CidrBlock?: string | null;
  Ipv6CidrBlockState?: SubnetCidrBlockState | null;
}
function SubnetIpv6CidrBlockAssociation_Parse(node: xmlP.XmlNode): SubnetIpv6CidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockState: node.first("ipv6CidrBlockState", false, SubnetCidrBlockState_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface SubnetCidrBlockState {
  State?: SubnetCidrBlockStateCode | null;
  StatusMessage?: string | null;
}
function SubnetCidrBlockState_Parse(node: xmlP.XmlNode): SubnetCidrBlockState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as SubnetCidrBlockStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, enum
export type SubnetCidrBlockStateCode =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| "failing"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface TransitGatewayMulticastDomainAssociations {
  TransitGatewayMulticastDomainId?: string | null;
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  Subnets: SubnetAssociation[];
}
function TransitGatewayMulticastDomainAssociations_Parse(node: xmlP.XmlNode): TransitGatewayMulticastDomainAssociations {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    Subnets: node.getList("subnets", "item").map(SubnetAssociation_Parse),
  };
}

// refs: 19 - tags: output, named, enum
export type TransitGatewayAttachmentResourceType =
| "vpc"
| "vpn"
| "direct-connect-gateway"
| "peering"
| "tgw-peering"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface SubnetAssociation {
  SubnetId?: string | null;
  State?: TransitGatewayMulitcastDomainAssociationState | null;
}
function SubnetAssociation_Parse(node: xmlP.XmlNode): SubnetAssociation {
  return {
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayMulitcastDomainAssociationState),
  };
}

// refs: 3 - tags: output, named, enum
export type TransitGatewayMulitcastDomainAssociationState =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface TransitGatewayAssociation {
  TransitGatewayRouteTableId?: string | null;
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  State?: TransitGatewayAssociationState | null;
}
function TransitGatewayAssociation_Parse(node: xmlP.XmlNode): TransitGatewayAssociation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAssociationState),
  };
}

// refs: 4 - tags: output, named, enum
export type TransitGatewayAssociationState =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface VpcIpv6CidrBlockAssociation {
  AssociationId?: string | null;
  Ipv6CidrBlock?: string | null;
  Ipv6CidrBlockState?: VpcCidrBlockState | null;
  NetworkBorderGroup?: string | null;
  Ipv6Pool?: string | null;
}
function VpcIpv6CidrBlockAssociation_Parse(node: xmlP.XmlNode): VpcIpv6CidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    Ipv6CidrBlockState: node.first("ipv6CidrBlockState", false, VpcCidrBlockState_Parse),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    Ipv6Pool: node.first("ipv6Pool", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: output, named, interface
export interface VpcCidrBlockState {
  State?: VpcCidrBlockStateCode | null;
  StatusMessage?: string | null;
}
function VpcCidrBlockState_Parse(node: xmlP.XmlNode): VpcCidrBlockState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as VpcCidrBlockStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

// refs: 10 - tags: output, named, enum
export type VpcCidrBlockStateCode =
| "associating"
| "associated"
| "disassociating"
| "disassociated"
| "failing"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, interface
export interface VpcCidrBlockAssociation {
  AssociationId?: string | null;
  CidrBlock?: string | null;
  CidrBlockState?: VpcCidrBlockState | null;
}
function VpcCidrBlockAssociation_Parse(node: xmlP.XmlNode): VpcCidrBlockAssociation {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    CidrBlockState: node.first("cidrBlockState", false, VpcCidrBlockState_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type VolumeAttachmentState =
| "attaching"
| "attached"
| "detaching"
| "detached"
| "busy"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface VpcAttachment {
  State?: AttachmentStatus | null;
  VpcId?: string | null;
}
function VpcAttachment_Parse(node: xmlP.XmlNode): VpcAttachment {
  return {
    State: node.first("state", false, x => (x.content ?? '') as AttachmentStatus),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 15 - tags: output, named, enum
export type AttachmentStatus =
| "attaching"
| "attached"
| "detaching"
| "detached"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ClientVpnAuthorizationRuleStatus {
  Code?: ClientVpnAuthorizationRuleStatusCode | null;
  Message?: string | null;
}
function ClientVpnAuthorizationRuleStatus_Parse(node: xmlP.XmlNode): ClientVpnAuthorizationRuleStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as ClientVpnAuthorizationRuleStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type ClientVpnAuthorizationRuleStatusCode =
| "authorizing"
| "active"
| "failed"
| "revoking"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface BundleTask {
  BundleId?: string | null;
  BundleTaskError?: BundleTaskError | null;
  InstanceId?: string | null;
  Progress?: string | null;
  StartTime?: Date | number | null;
  State?: BundleTaskState | null;
  Storage?: Storage | null;
  UpdateTime?: Date | number | null;
}
function BundleTask_Parse(node: xmlP.XmlNode): BundleTask {
  return {
    BundleId: node.first("bundleId", false, x => x.content ?? ''),
    BundleTaskError: node.first("error", false, BundleTaskError_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as BundleTaskState),
    Storage: node.first("storage", false, Storage_Parse),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 3 - tags: output, named, interface
export interface BundleTaskError {
  Code?: string | null;
  Message?: string | null;
}
function BundleTaskError_Parse(node: xmlP.XmlNode): BundleTaskError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type BundleTaskState =
| "pending"
| "waiting-for-shutdown"
| "bundling"
| "storing"
| "cancelling"
| "complete"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ReservedInstancesListing {
  ClientToken?: string | null;
  CreateDate?: Date | number | null;
  InstanceCounts: InstanceCount[];
  PriceSchedules: PriceSchedule[];
  ReservedInstancesId?: string | null;
  ReservedInstancesListingId?: string | null;
  Status?: ListingStatus | null;
  StatusMessage?: string | null;
  Tags: Tag[];
  UpdateDate?: Date | number | null;
}
function ReservedInstancesListing_Parse(node: xmlP.XmlNode): ReservedInstancesListing {
  return {
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    InstanceCounts: node.getList("instanceCounts", "item").map(InstanceCount_Parse),
    PriceSchedules: node.getList("priceSchedules", "item").map(PriceSchedule_Parse),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    ReservedInstancesListingId: node.first("reservedInstancesListingId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as ListingStatus),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    UpdateDate: node.first("updateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 3 - tags: output, named, interface
export interface InstanceCount {
  InstanceCount?: number | null;
  State?: ListingState | null;
}
function InstanceCount_Parse(node: xmlP.XmlNode): InstanceCount {
  return {
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    State: node.first("state", false, x => (x.content ?? '') as ListingState),
  };
}

// refs: 3 - tags: output, named, enum
export type ListingState =
| "available"
| "sold"
| "cancelled"
| "pending"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface PriceSchedule {
  Active?: boolean | null;
  CurrencyCode?: CurrencyCodeValues | null;
  Price?: number | null;
  Term?: number | null;
}
function PriceSchedule_Parse(node: xmlP.XmlNode): PriceSchedule {
  return {
    Active: node.first("active", false, x => x.content === 'true'),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    Price: node.first("price", false, x => parseFloat(x.content ?? '0')),
    Term: node.first("term", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, enum
export type ListingStatus =
| "active"
| "pending"
| "cancelled"
| "closed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CancelSpotFleetRequestsSuccessItem {
  CurrentSpotFleetRequestState?: BatchState | null;
  PreviousSpotFleetRequestState?: BatchState | null;
  SpotFleetRequestId?: string | null;
}
function CancelSpotFleetRequestsSuccessItem_Parse(node: xmlP.XmlNode): CancelSpotFleetRequestsSuccessItem {
  return {
    CurrentSpotFleetRequestState: node.first("currentSpotFleetRequestState", false, x => (x.content ?? '') as BatchState),
    PreviousSpotFleetRequestState: node.first("previousSpotFleetRequestState", false, x => (x.content ?? '') as BatchState),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type BatchState =
| "submitted"
| "active"
| "cancelled"
| "failed"
| "cancelled_running"
| "cancelled_terminating"
| "modifying"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CancelSpotFleetRequestsErrorItem {
  Error?: CancelSpotFleetRequestsError | null;
  SpotFleetRequestId?: string | null;
}
function CancelSpotFleetRequestsErrorItem_Parse(node: xmlP.XmlNode): CancelSpotFleetRequestsErrorItem {
  return {
    Error: node.first("error", false, CancelSpotFleetRequestsError_Parse),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CancelSpotFleetRequestsError {
  Code?: CancelBatchErrorCode | null;
  Message?: string | null;
}
function CancelSpotFleetRequestsError_Parse(node: xmlP.XmlNode): CancelSpotFleetRequestsError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as CancelBatchErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type CancelBatchErrorCode =
| "fleetRequestIdDoesNotExist"
| "fleetRequestIdMalformed"
| "fleetRequestNotInCancellableState"
| "unexpectedError"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CancelledSpotInstanceRequest {
  SpotInstanceRequestId?: string | null;
  State?: CancelSpotInstanceRequestState | null;
}
function CancelledSpotInstanceRequest_Parse(node: xmlP.XmlNode): CancelledSpotInstanceRequest {
  return {
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as CancelSpotInstanceRequestState),
  };
}

// refs: 1 - tags: output, named, enum
export type CancelSpotInstanceRequestState =
| "active"
| "open"
| "closed"
| "cancelled"
| "completed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface CapacityReservation {
  CapacityReservationId?: string | null;
  OwnerId?: string | null;
  CapacityReservationArn?: string | null;
  AvailabilityZoneId?: string | null;
  InstanceType?: string | null;
  InstancePlatform?: CapacityReservationInstancePlatform | null;
  AvailabilityZone?: string | null;
  Tenancy?: CapacityReservationTenancy | null;
  TotalInstanceCount?: number | null;
  AvailableInstanceCount?: number | null;
  EbsOptimized?: boolean | null;
  EphemeralStorage?: boolean | null;
  State?: CapacityReservationState | null;
  EndDate?: Date | number | null;
  EndDateType?: EndDateType | null;
  InstanceMatchCriteria?: InstanceMatchCriteria | null;
  CreateDate?: Date | number | null;
  Tags: Tag[];
}
function CapacityReservation_Parse(node: xmlP.XmlNode): CapacityReservation {
  return {
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    CapacityReservationArn: node.first("capacityReservationArn", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    InstancePlatform: node.first("instancePlatform", false, x => (x.content ?? '') as CapacityReservationInstancePlatform),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as CapacityReservationTenancy),
    TotalInstanceCount: node.first("totalInstanceCount", false, x => parseInt(x.content ?? '0')),
    AvailableInstanceCount: node.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    EphemeralStorage: node.first("ephemeralStorage", false, x => x.content === 'true'),
    State: node.first("state", false, x => (x.content ?? '') as CapacityReservationState),
    EndDate: node.first("endDate", false, x => xmlP.parseTimestamp(x.content)),
    EndDateType: node.first("endDateType", false, x => (x.content ?? '') as EndDateType),
    InstanceMatchCriteria: node.first("instanceMatchCriteria", false, x => (x.content ?? '') as InstanceMatchCriteria),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type CapacityReservationState =
| "active"
| "expired"
| "cancelled"
| "pending"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface CarrierGateway {
  CarrierGatewayId?: string | null;
  VpcId?: string | null;
  State?: CarrierGatewayState | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function CarrierGateway_Parse(node: xmlP.XmlNode): CarrierGateway {
  return {
    CarrierGatewayId: node.first("carrierGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as CarrierGatewayState),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type CarrierGatewayState =
| "pending"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ClientVpnEndpointStatus {
  Code?: ClientVpnEndpointStatusCode | null;
  Message?: string | null;
}
function ClientVpnEndpointStatus_Parse(node: xmlP.XmlNode): ClientVpnEndpointStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as ClientVpnEndpointStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type ClientVpnEndpointStatusCode =
| "pending-associate"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ClientVpnRouteStatus {
  Code?: ClientVpnRouteStatusCode | null;
  Message?: string | null;
}
function ClientVpnRouteStatus_Parse(node: xmlP.XmlNode): ClientVpnRouteStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as ClientVpnRouteStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type ClientVpnRouteStatusCode =
| "creating"
| "active"
| "failed"
| "deleting"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface CustomerGateway {
  BgpAsn?: string | null;
  CustomerGatewayId?: string | null;
  IpAddress?: string | null;
  CertificateArn?: string | null;
  State?: string | null;
  Type?: string | null;
  DeviceName?: string | null;
  Tags: Tag[];
}
function CustomerGateway_Parse(node: xmlP.XmlNode): CustomerGateway {
  return {
    BgpAsn: node.first("bgpAsn", false, x => x.content ?? ''),
    CustomerGatewayId: node.first("customerGatewayId", false, x => x.content ?? ''),
    IpAddress: node.first("ipAddress", false, x => x.content ?? ''),
    CertificateArn: node.first("certificateArn", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Type: node.first("type", false, x => x.content ?? ''),
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface Subnet {
  AvailabilityZone?: string | null;
  AvailabilityZoneId?: string | null;
  AvailableIpAddressCount?: number | null;
  CidrBlock?: string | null;
  DefaultForAz?: boolean | null;
  MapPublicIpOnLaunch?: boolean | null;
  MapCustomerOwnedIpOnLaunch?: boolean | null;
  CustomerOwnedIpv4Pool?: string | null;
  State?: SubnetState | null;
  SubnetId?: string | null;
  VpcId?: string | null;
  OwnerId?: string | null;
  AssignIpv6AddressOnCreation?: boolean | null;
  Ipv6CidrBlockAssociationSet: SubnetIpv6CidrBlockAssociation[];
  Tags: Tag[];
  SubnetArn?: string | null;
  OutpostArn?: string | null;
}
function Subnet_Parse(node: xmlP.XmlNode): Subnet {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    AvailableIpAddressCount: node.first("availableIpAddressCount", false, x => parseInt(x.content ?? '0')),
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    DefaultForAz: node.first("defaultForAz", false, x => x.content === 'true'),
    MapPublicIpOnLaunch: node.first("mapPublicIpOnLaunch", false, x => x.content === 'true'),
    MapCustomerOwnedIpOnLaunch: node.first("mapCustomerOwnedIpOnLaunch", false, x => x.content === 'true'),
    CustomerOwnedIpv4Pool: node.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as SubnetState),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    AssignIpv6AddressOnCreation: node.first("assignIpv6AddressOnCreation", false, x => x.content === 'true'),
    Ipv6CidrBlockAssociationSet: node.getList("ipv6CidrBlockAssociationSet", "item").map(SubnetIpv6CidrBlockAssociation_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    SubnetArn: node.first("subnetArn", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type SubnetState =
| "pending"
| "available"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Vpc {
  CidrBlock?: string | null;
  DhcpOptionsId?: string | null;
  State?: VpcState | null;
  VpcId?: string | null;
  OwnerId?: string | null;
  InstanceTenancy?: Tenancy | null;
  Ipv6CidrBlockAssociationSet: VpcIpv6CidrBlockAssociation[];
  CidrBlockAssociationSet: VpcCidrBlockAssociation[];
  IsDefault?: boolean | null;
  Tags: Tag[];
}
function Vpc_Parse(node: xmlP.XmlNode): Vpc {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    DhcpOptionsId: node.first("dhcpOptionsId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as VpcState),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as Tenancy),
    Ipv6CidrBlockAssociationSet: node.getList("ipv6CidrBlockAssociationSet", "item").map(VpcIpv6CidrBlockAssociation_Parse),
    CidrBlockAssociationSet: node.getList("cidrBlockAssociationSet", "item").map(VpcCidrBlockAssociation_Parse),
    IsDefault: node.first("isDefault", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type VpcState =
| "pending"
| "available"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface DhcpOptions {
  DhcpConfigurations: DhcpConfiguration[];
  DhcpOptionsId?: string | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function DhcpOptions_Parse(node: xmlP.XmlNode): DhcpOptions {
  return {
    DhcpConfigurations: node.getList("dhcpConfigurationSet", "item").map(DhcpConfiguration_Parse),
    DhcpOptionsId: node.first("dhcpOptionsId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DhcpConfiguration {
  Key?: string | null;
  Values: AttributeValue[];
}
function DhcpConfiguration_Parse(node: xmlP.XmlNode): DhcpConfiguration {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    Values: node.getList("valueSet", "item").map(AttributeValue_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface EgressOnlyInternetGateway {
  Attachments: InternetGatewayAttachment[];
  EgressOnlyInternetGatewayId?: string | null;
  Tags: Tag[];
}
function EgressOnlyInternetGateway_Parse(node: xmlP.XmlNode): EgressOnlyInternetGateway {
  return {
    Attachments: node.getList("attachmentSet", "item").map(InternetGatewayAttachment_Parse),
    EgressOnlyInternetGatewayId: node.first("egressOnlyInternetGatewayId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface InternetGatewayAttachment {
  State?: AttachmentStatus | null;
  VpcId?: string | null;
}
function InternetGatewayAttachment_Parse(node: xmlP.XmlNode): InternetGatewayAttachment {
  return {
    State: node.first("state", false, x => (x.content ?? '') as AttachmentStatus),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CreateFleetError {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse | null;
  Lifecycle?: InstanceLifecycle | null;
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function CreateFleetError_Parse(node: xmlP.XmlNode): CreateFleetError {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as InstanceLifecycle),
    ErrorCode: node.first("errorCode", false, x => x.content ?? ''),
    ErrorMessage: node.first("errorMessage", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface LaunchTemplateAndOverridesResponse {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification | null;
  Overrides?: FleetLaunchTemplateOverrides | null;
}
function LaunchTemplateAndOverridesResponse_Parse(node: xmlP.XmlNode): LaunchTemplateAndOverridesResponse {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.first("overrides", false, FleetLaunchTemplateOverrides_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface FleetLaunchTemplateOverrides {
  InstanceType?: InstanceType | null;
  MaxPrice?: string | null;
  SubnetId?: string | null;
  AvailabilityZone?: string | null;
  WeightedCapacity?: number | null;
  Priority?: number | null;
  Placement?: PlacementResponse | null;
}
function FleetLaunchTemplateOverrides_Parse(node: xmlP.XmlNode): FleetLaunchTemplateOverrides {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    MaxPrice: node.first("maxPrice", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    WeightedCapacity: node.first("weightedCapacity", false, x => parseFloat(x.content ?? '0')),
    Priority: node.first("priority", false, x => parseFloat(x.content ?? '0')),
    Placement: node.first("placement", false, PlacementResponse_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface PlacementResponse {
  GroupName?: string | null;
}
function PlacementResponse_Parse(node: xmlP.XmlNode): PlacementResponse {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type InstanceLifecycle =
| "spot"
| "on-demand"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CreateFleetInstance {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse | null;
  Lifecycle?: InstanceLifecycle | null;
  InstanceIds: string[];
  InstanceType?: InstanceType | null;
  Platform?: PlatformValues | null;
}
function CreateFleetInstance_Parse(node: xmlP.XmlNode): CreateFleetInstance {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as InstanceLifecycle),
    InstanceIds: node.getList("instanceIds", "item").map(x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    Platform: node.first("platform", false, x => (x.content ?? '') as PlatformValues),
  };
}

// refs: 2 - tags: output, named, interface
export interface ExportTask {
  Description?: string | null;
  ExportTaskId?: string | null;
  ExportToS3Task?: ExportToS3Task | null;
  InstanceExportDetails?: InstanceExportDetails | null;
  State?: ExportTaskState | null;
  StatusMessage?: string | null;
  Tags: Tag[];
}
function ExportTask_Parse(node: xmlP.XmlNode): ExportTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ExportTaskId: node.first("exportTaskId", false, x => x.content ?? ''),
    ExportToS3Task: node.first("exportToS3", false, ExportToS3Task_Parse),
    InstanceExportDetails: node.first("instanceExport", false, InstanceExportDetails_Parse),
    State: node.first("state", false, x => (x.content ?? '') as ExportTaskState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ExportToS3Task {
  ContainerFormat?: ContainerFormat | null;
  DiskImageFormat?: DiskImageFormat | null;
  S3Bucket?: string | null;
  S3Key?: string | null;
}
function ExportToS3Task_Parse(node: xmlP.XmlNode): ExportToS3Task {
  return {
    ContainerFormat: node.first("containerFormat", false, x => (x.content ?? '') as ContainerFormat),
    DiskImageFormat: node.first("diskImageFormat", false, x => (x.content ?? '') as DiskImageFormat),
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Key: node.first("s3Key", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceExportDetails {
  InstanceId?: string | null;
  TargetEnvironment?: ExportEnvironment | null;
}
function InstanceExportDetails_Parse(node: xmlP.XmlNode): InstanceExportDetails {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    TargetEnvironment: node.first("targetEnvironment", false, x => (x.content ?? '') as ExportEnvironment),
  };
}

// refs: 2 - tags: output, named, enum
export type ExportTaskState =
| "active"
| "cancelling"
| "cancelled"
| "completed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface InternetGateway {
  Attachments: InternetGatewayAttachment[];
  InternetGatewayId?: string | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function InternetGateway_Parse(node: xmlP.XmlNode): InternetGateway {
  return {
    Attachments: node.getList("attachmentSet", "item").map(InternetGatewayAttachment_Parse),
    InternetGatewayId: node.first("internetGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface LaunchTemplate {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  CreateTime?: Date | number | null;
  CreatedBy?: string | null;
  DefaultVersionNumber?: number | null;
  LatestVersionNumber?: number | null;
  Tags: Tag[];
}
function LaunchTemplate_Parse(node: xmlP.XmlNode): LaunchTemplate {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    CreatedBy: node.first("createdBy", false, x => x.content ?? ''),
    DefaultVersionNumber: node.first("defaultVersionNumber", false, x => parseInt(x.content ?? '0')),
    LatestVersionNumber: node.first("latestVersionNumber", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ValidationWarning {
  Errors: ValidationError[];
}
function ValidationWarning_Parse(node: xmlP.XmlNode): ValidationWarning {
  return {
    Errors: node.getList("errorSet", "item").map(ValidationError_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ValidationError {
  Code?: string | null;
  Message?: string | null;
}
function ValidationError_Parse(node: xmlP.XmlNode): ValidationError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface LaunchTemplateVersion {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  VersionNumber?: number | null;
  VersionDescription?: string | null;
  CreateTime?: Date | number | null;
  CreatedBy?: string | null;
  DefaultVersion?: boolean | null;
  LaunchTemplateData?: ResponseLaunchTemplateData | null;
}
function LaunchTemplateVersion_Parse(node: xmlP.XmlNode): LaunchTemplateVersion {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
    VersionDescription: node.first("versionDescription", false, x => x.content ?? ''),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    CreatedBy: node.first("createdBy", false, x => x.content ?? ''),
    DefaultVersion: node.first("defaultVersion", false, x => x.content === 'true'),
    LaunchTemplateData: node.first("launchTemplateData", false, ResponseLaunchTemplateData_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ResponseLaunchTemplateData {
  KernelId?: string | null;
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: LaunchTemplateIamInstanceProfileSpecification | null;
  BlockDeviceMappings: LaunchTemplateBlockDeviceMapping[];
  NetworkInterfaces: LaunchTemplateInstanceNetworkInterfaceSpecification[];
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  KeyName?: string | null;
  Monitoring?: LaunchTemplatesMonitoring | null;
  Placement?: LaunchTemplatePlacement | null;
  RamDiskId?: string | null;
  DisableApiTermination?: boolean | null;
  InstanceInitiatedShutdownBehavior?: ShutdownBehavior | null;
  UserData?: string | null;
  TagSpecifications: LaunchTemplateTagSpecification[];
  ElasticGpuSpecifications: ElasticGpuSpecificationResponse[];
  ElasticInferenceAccelerators: LaunchTemplateElasticInferenceAcceleratorResponse[];
  SecurityGroupIds: string[];
  SecurityGroups: string[];
  InstanceMarketOptions?: LaunchTemplateInstanceMarketOptions | null;
  CreditSpecification?: CreditSpecification | null;
  CpuOptions?: LaunchTemplateCpuOptions | null;
  CapacityReservationSpecification?: LaunchTemplateCapacityReservationSpecificationResponse | null;
  LicenseSpecifications: LaunchTemplateLicenseConfiguration[];
  HibernationOptions?: LaunchTemplateHibernationOptions | null;
  MetadataOptions?: LaunchTemplateInstanceMetadataOptions | null;
}
function ResponseLaunchTemplateData_Parse(node: xmlP.XmlNode): ResponseLaunchTemplateData {
  return {
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, LaunchTemplateIamInstanceProfileSpecification_Parse),
    BlockDeviceMappings: node.getList("blockDeviceMappingSet", "item").map(LaunchTemplateBlockDeviceMapping_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(LaunchTemplateInstanceNetworkInterfaceSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, LaunchTemplatesMonitoring_Parse),
    Placement: node.first("placement", false, LaunchTemplatePlacement_Parse),
    RamDiskId: node.first("ramDiskId", false, x => x.content ?? ''),
    DisableApiTermination: node.first("disableApiTermination", false, x => x.content === 'true'),
    InstanceInitiatedShutdownBehavior: node.first("instanceInitiatedShutdownBehavior", false, x => (x.content ?? '') as ShutdownBehavior),
    UserData: node.first("userData", false, x => x.content ?? ''),
    TagSpecifications: node.getList("tagSpecificationSet", "item").map(LaunchTemplateTagSpecification_Parse),
    ElasticGpuSpecifications: node.getList("elasticGpuSpecificationSet", "item").map(ElasticGpuSpecificationResponse_Parse),
    ElasticInferenceAccelerators: node.getList("elasticInferenceAcceleratorSet", "item").map(LaunchTemplateElasticInferenceAcceleratorResponse_Parse),
    SecurityGroupIds: node.getList("securityGroupIdSet", "item").map(x => x.content ?? ''),
    SecurityGroups: node.getList("securityGroupSet", "item").map(x => x.content ?? ''),
    InstanceMarketOptions: node.first("instanceMarketOptions", false, LaunchTemplateInstanceMarketOptions_Parse),
    CreditSpecification: node.first("creditSpecification", false, CreditSpecification_Parse),
    CpuOptions: node.first("cpuOptions", false, LaunchTemplateCpuOptions_Parse),
    CapacityReservationSpecification: node.first("capacityReservationSpecification", false, LaunchTemplateCapacityReservationSpecificationResponse_Parse),
    LicenseSpecifications: node.getList("licenseSet", "item").map(LaunchTemplateLicenseConfiguration_Parse),
    HibernationOptions: node.first("hibernationOptions", false, LaunchTemplateHibernationOptions_Parse),
    MetadataOptions: node.first("metadataOptions", false, LaunchTemplateInstanceMetadataOptions_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateIamInstanceProfileSpecification {
  Arn?: string | null;
  Name?: string | null;
}
function LaunchTemplateIamInstanceProfileSpecification_Parse(node: xmlP.XmlNode): LaunchTemplateIamInstanceProfileSpecification {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateBlockDeviceMapping {
  DeviceName?: string | null;
  VirtualName?: string | null;
  Ebs?: LaunchTemplateEbsBlockDevice | null;
  NoDevice?: string | null;
}
function LaunchTemplateBlockDeviceMapping_Parse(node: xmlP.XmlNode): LaunchTemplateBlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    VirtualName: node.first("virtualName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, LaunchTemplateEbsBlockDevice_Parse),
    NoDevice: node.first("noDevice", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateEbsBlockDevice {
  Encrypted?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Iops?: number | null;
  KmsKeyId?: string | null;
  SnapshotId?: string | null;
  VolumeSize?: number | null;
  VolumeType?: VolumeType | null;
}
function LaunchTemplateEbsBlockDevice_Parse(node: xmlP.XmlNode): LaunchTemplateEbsBlockDevice {
  return {
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Iops: node.first("iops", false, x => parseInt(x.content ?? '0')),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    VolumeType: node.first("volumeType", false, x => (x.content ?? '') as VolumeType),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateInstanceNetworkInterfaceSpecification {
  AssociateCarrierIpAddress?: boolean | null;
  AssociatePublicIpAddress?: boolean | null;
  DeleteOnTermination?: boolean | null;
  Description?: string | null;
  DeviceIndex?: number | null;
  Groups: string[];
  InterfaceType?: string | null;
  Ipv6AddressCount?: number | null;
  Ipv6Addresses: InstanceIpv6Address[];
  NetworkInterfaceId?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses: PrivateIpAddressSpecification[];
  SecondaryPrivateIpAddressCount?: number | null;
  SubnetId?: string | null;
}
function LaunchTemplateInstanceNetworkInterfaceSpecification_Parse(node: xmlP.XmlNode): LaunchTemplateInstanceNetworkInterfaceSpecification {
  return {
    AssociateCarrierIpAddress: node.first("associateCarrierIpAddress", false, x => x.content === 'true'),
    AssociatePublicIpAddress: node.first("associatePublicIpAddress", false, x => x.content === 'true'),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Groups: node.getList("groupSet", "groupId").map(x => x.content ?? ''),
    InterfaceType: node.first("interfaceType", false, x => x.content ?? ''),
    Ipv6AddressCount: node.first("ipv6AddressCount", false, x => parseInt(x.content ?? '0')),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(InstanceIpv6Address_Parse),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(PrivateIpAddressSpecification_Parse),
    SecondaryPrivateIpAddressCount: node.first("secondaryPrivateIpAddressCount", false, x => parseInt(x.content ?? '0')),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplatesMonitoring {
  Enabled?: boolean | null;
}
function LaunchTemplatesMonitoring_Parse(node: xmlP.XmlNode): LaunchTemplatesMonitoring {
  return {
    Enabled: node.first("enabled", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplatePlacement {
  AvailabilityZone?: string | null;
  Affinity?: string | null;
  GroupName?: string | null;
  HostId?: string | null;
  Tenancy?: Tenancy | null;
  SpreadDomain?: string | null;
  HostResourceGroupArn?: string | null;
  PartitionNumber?: number | null;
}
function LaunchTemplatePlacement_Parse(node: xmlP.XmlNode): LaunchTemplatePlacement {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Affinity: node.first("affinity", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    Tenancy: node.first("tenancy", false, x => (x.content ?? '') as Tenancy),
    SpreadDomain: node.first("spreadDomain", false, x => x.content ?? ''),
    HostResourceGroupArn: node.first("hostResourceGroupArn", false, x => x.content ?? ''),
    PartitionNumber: node.first("partitionNumber", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateTagSpecification {
  ResourceType?: ResourceType | null;
  Tags: Tag[];
}
function LaunchTemplateTagSpecification_Parse(node: xmlP.XmlNode): LaunchTemplateTagSpecification {
  return {
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as ResourceType),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ElasticGpuSpecificationResponse {
  Type?: string | null;
}
function ElasticGpuSpecificationResponse_Parse(node: xmlP.XmlNode): ElasticGpuSpecificationResponse {
  return {
    Type: node.first("type", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateElasticInferenceAcceleratorResponse {
  Type?: string | null;
  Count?: number | null;
}
function LaunchTemplateElasticInferenceAcceleratorResponse_Parse(node: xmlP.XmlNode): LaunchTemplateElasticInferenceAcceleratorResponse {
  return {
    Type: node.first("type", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateInstanceMarketOptions {
  MarketType?: MarketType | null;
  SpotOptions?: LaunchTemplateSpotMarketOptions | null;
}
function LaunchTemplateInstanceMarketOptions_Parse(node: xmlP.XmlNode): LaunchTemplateInstanceMarketOptions {
  return {
    MarketType: node.first("marketType", false, x => (x.content ?? '') as MarketType),
    SpotOptions: node.first("spotOptions", false, LaunchTemplateSpotMarketOptions_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateSpotMarketOptions {
  MaxPrice?: string | null;
  SpotInstanceType?: SpotInstanceType | null;
  BlockDurationMinutes?: number | null;
  ValidUntil?: Date | number | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
}
function LaunchTemplateSpotMarketOptions_Parse(node: xmlP.XmlNode): LaunchTemplateSpotMarketOptions {
  return {
    MaxPrice: node.first("maxPrice", false, x => x.content ?? ''),
    SpotInstanceType: node.first("spotInstanceType", false, x => (x.content ?? '') as SpotInstanceType),
    BlockDurationMinutes: node.first("blockDurationMinutes", false, x => parseInt(x.content ?? '0')),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as InstanceInterruptionBehavior),
  };
}

// refs: 3 - tags: output, named, interface
export interface CreditSpecification {
  CpuCredits?: string | null;
}
function CreditSpecification_Parse(node: xmlP.XmlNode): CreditSpecification {
  return {
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateCpuOptions {
  CoreCount?: number | null;
  ThreadsPerCore?: number | null;
}
function LaunchTemplateCpuOptions_Parse(node: xmlP.XmlNode): LaunchTemplateCpuOptions {
  return {
    CoreCount: node.first("coreCount", false, x => parseInt(x.content ?? '0')),
    ThreadsPerCore: node.first("threadsPerCore", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateCapacityReservationSpecificationResponse {
  CapacityReservationPreference?: CapacityReservationPreference | null;
  CapacityReservationTarget?: CapacityReservationTargetResponse | null;
}
function LaunchTemplateCapacityReservationSpecificationResponse_Parse(node: xmlP.XmlNode): LaunchTemplateCapacityReservationSpecificationResponse {
  return {
    CapacityReservationPreference: node.first("capacityReservationPreference", false, x => (x.content ?? '') as CapacityReservationPreference),
    CapacityReservationTarget: node.first("capacityReservationTarget", false, CapacityReservationTargetResponse_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface CapacityReservationTargetResponse {
  CapacityReservationId?: string | null;
  CapacityReservationResourceGroupArn?: string | null;
}
function CapacityReservationTargetResponse_Parse(node: xmlP.XmlNode): CapacityReservationTargetResponse {
  return {
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    CapacityReservationResourceGroupArn: node.first("capacityReservationResourceGroupArn", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateLicenseConfiguration {
  LicenseConfigurationArn?: string | null;
}
function LaunchTemplateLicenseConfiguration_Parse(node: xmlP.XmlNode): LaunchTemplateLicenseConfiguration {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateHibernationOptions {
  Configured?: boolean | null;
}
function LaunchTemplateHibernationOptions_Parse(node: xmlP.XmlNode): LaunchTemplateHibernationOptions {
  return {
    Configured: node.first("configured", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface LaunchTemplateInstanceMetadataOptions {
  State?: LaunchTemplateInstanceMetadataOptionsState | null;
  HttpTokens?: LaunchTemplateHttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: LaunchTemplateInstanceMetadataEndpointState | null;
}
function LaunchTemplateInstanceMetadataOptions_Parse(node: xmlP.XmlNode): LaunchTemplateInstanceMetadataOptions {
  return {
    State: node.first("state", false, x => (x.content ?? '') as LaunchTemplateInstanceMetadataOptionsState),
    HttpTokens: node.first("httpTokens", false, x => (x.content ?? '') as LaunchTemplateHttpTokensState),
    HttpPutResponseHopLimit: node.first("httpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("httpEndpoint", false, x => (x.content ?? '') as LaunchTemplateInstanceMetadataEndpointState),
  };
}

// refs: 3 - tags: output, named, enum
export type LaunchTemplateInstanceMetadataOptionsState =
| "pending"
| "applied"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface LocalGatewayRoute {
  DestinationCidrBlock?: string | null;
  LocalGatewayVirtualInterfaceGroupId?: string | null;
  Type?: LocalGatewayRouteType | null;
  State?: LocalGatewayRouteState | null;
  LocalGatewayRouteTableId?: string | null;
  LocalGatewayRouteTableArn?: string | null;
  OwnerId?: string | null;
}
function LocalGatewayRoute_Parse(node: xmlP.XmlNode): LocalGatewayRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    Type: node.first("type", false, x => (x.content ?? '') as LocalGatewayRouteType),
    State: node.first("state", false, x => (x.content ?? '') as LocalGatewayRouteState),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type LocalGatewayRouteType =
| "static"
| "propagated"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type LocalGatewayRouteState =
| "pending"
| "active"
| "blackhole"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface LocalGatewayRouteTableVpcAssociation {
  LocalGatewayRouteTableVpcAssociationId?: string | null;
  LocalGatewayRouteTableId?: string | null;
  LocalGatewayRouteTableArn?: string | null;
  LocalGatewayId?: string | null;
  VpcId?: string | null;
  OwnerId?: string | null;
  State?: string | null;
  Tags: Tag[];
}
function LocalGatewayRouteTableVpcAssociation_Parse(node: xmlP.XmlNode): LocalGatewayRouteTableVpcAssociation {
  return {
    LocalGatewayRouteTableVpcAssociationId: node.first("localGatewayRouteTableVpcAssociationId", false, x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface ManagedPrefixList {
  PrefixListId?: string | null;
  AddressFamily?: string | null;
  State?: PrefixListState | null;
  StateMessage?: string | null;
  PrefixListArn?: string | null;
  PrefixListName?: string | null;
  MaxEntries?: number | null;
  Version?: number | null;
  Tags: Tag[];
  OwnerId?: string | null;
}
function ManagedPrefixList_Parse(node: xmlP.XmlNode): ManagedPrefixList {
  return {
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    AddressFamily: node.first("addressFamily", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as PrefixListState),
    StateMessage: node.first("stateMessage", false, x => x.content ?? ''),
    PrefixListArn: node.first("prefixListArn", false, x => x.content ?? ''),
    PrefixListName: node.first("prefixListName", false, x => x.content ?? ''),
    MaxEntries: node.first("maxEntries", false, x => parseInt(x.content ?? '0')),
    Version: node.first("version", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, enum
export type PrefixListState =
| "create-in-progress"
| "create-complete"
| "create-failed"
| "modify-in-progress"
| "modify-complete"
| "modify-failed"
| "restore-in-progress"
| "restore-complete"
| "restore-failed"
| "delete-in-progress"
| "delete-complete"
| "delete-failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface NatGateway {
  CreateTime?: Date | number | null;
  DeleteTime?: Date | number | null;
  FailureCode?: string | null;
  FailureMessage?: string | null;
  NatGatewayAddresses: NatGatewayAddress[];
  NatGatewayId?: string | null;
  ProvisionedBandwidth?: ProvisionedBandwidth | null;
  State?: NatGatewayState | null;
  SubnetId?: string | null;
  VpcId?: string | null;
  Tags: Tag[];
}
function NatGateway_Parse(node: xmlP.XmlNode): NatGateway {
  return {
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    DeleteTime: node.first("deleteTime", false, x => xmlP.parseTimestamp(x.content)),
    FailureCode: node.first("failureCode", false, x => x.content ?? ''),
    FailureMessage: node.first("failureMessage", false, x => x.content ?? ''),
    NatGatewayAddresses: node.getList("natGatewayAddressSet", "item").map(NatGatewayAddress_Parse),
    NatGatewayId: node.first("natGatewayId", false, x => x.content ?? ''),
    ProvisionedBandwidth: node.first("provisionedBandwidth", false, ProvisionedBandwidth_Parse),
    State: node.first("state", false, x => (x.content ?? '') as NatGatewayState),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface NatGatewayAddress {
  AllocationId?: string | null;
  NetworkInterfaceId?: string | null;
  PrivateIp?: string | null;
  PublicIp?: string | null;
}
function NatGatewayAddress_Parse(node: xmlP.XmlNode): NatGatewayAddress {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    PrivateIp: node.first("privateIp", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ProvisionedBandwidth {
  ProvisionTime?: Date | number | null;
  Provisioned?: string | null;
  RequestTime?: Date | number | null;
  Requested?: string | null;
  Status?: string | null;
}
function ProvisionedBandwidth_Parse(node: xmlP.XmlNode): ProvisionedBandwidth {
  return {
    ProvisionTime: node.first("provisionTime", false, x => xmlP.parseTimestamp(x.content)),
    Provisioned: node.first("provisioned", false, x => x.content ?? ''),
    RequestTime: node.first("requestTime", false, x => xmlP.parseTimestamp(x.content)),
    Requested: node.first("requested", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, enum
export type NatGatewayState =
| "pending"
| "failed"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface NetworkAcl {
  Associations: NetworkAclAssociation[];
  Entries: NetworkAclEntry[];
  IsDefault?: boolean | null;
  NetworkAclId?: string | null;
  Tags: Tag[];
  VpcId?: string | null;
  OwnerId?: string | null;
}
function NetworkAcl_Parse(node: xmlP.XmlNode): NetworkAcl {
  return {
    Associations: node.getList("associationSet", "item").map(NetworkAclAssociation_Parse),
    Entries: node.getList("entrySet", "item").map(NetworkAclEntry_Parse),
    IsDefault: node.first("default", false, x => x.content === 'true'),
    NetworkAclId: node.first("networkAclId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface NetworkAclAssociation {
  NetworkAclAssociationId?: string | null;
  NetworkAclId?: string | null;
  SubnetId?: string | null;
}
function NetworkAclAssociation_Parse(node: xmlP.XmlNode): NetworkAclAssociation {
  return {
    NetworkAclAssociationId: node.first("networkAclAssociationId", false, x => x.content ?? ''),
    NetworkAclId: node.first("networkAclId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface NetworkAclEntry {
  CidrBlock?: string | null;
  Egress?: boolean | null;
  IcmpTypeCode?: IcmpTypeCode | null;
  Ipv6CidrBlock?: string | null;
  PortRange?: PortRange | null;
  Protocol?: string | null;
  RuleAction?: RuleAction | null;
  RuleNumber?: number | null;
}
function NetworkAclEntry_Parse(node: xmlP.XmlNode): NetworkAclEntry {
  return {
    CidrBlock: node.first("cidrBlock", false, x => x.content ?? ''),
    Egress: node.first("egress", false, x => x.content === 'true'),
    IcmpTypeCode: node.first("icmpTypeCode", false, IcmpTypeCode_Parse),
    Ipv6CidrBlock: node.first("ipv6CidrBlock", false, x => x.content ?? ''),
    PortRange: node.first("portRange", false, PortRange_Parse),
    Protocol: node.first("protocol", false, x => x.content ?? ''),
    RuleAction: node.first("ruleAction", false, x => (x.content ?? '') as RuleAction),
    RuleNumber: node.first("ruleNumber", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, interface
export interface NetworkInterface {
  Association?: NetworkInterfaceAssociation | null;
  Attachment?: NetworkInterfaceAttachment | null;
  AvailabilityZone?: string | null;
  Description?: string | null;
  Groups: GroupIdentifier[];
  InterfaceType?: NetworkInterfaceType | null;
  Ipv6Addresses: NetworkInterfaceIpv6Address[];
  MacAddress?: string | null;
  NetworkInterfaceId?: string | null;
  OutpostArn?: string | null;
  OwnerId?: string | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses: NetworkInterfacePrivateIpAddress[];
  RequesterId?: string | null;
  RequesterManaged?: boolean | null;
  SourceDestCheck?: boolean | null;
  Status?: NetworkInterfaceStatus | null;
  SubnetId?: string | null;
  TagSet: Tag[];
  VpcId?: string | null;
}
function NetworkInterface_Parse(node: xmlP.XmlNode): NetworkInterface {
  return {
    Association: node.first("association", false, NetworkInterfaceAssociation_Parse),
    Attachment: node.first("attachment", false, NetworkInterfaceAttachment_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    InterfaceType: node.first("interfaceType", false, x => (x.content ?? '') as NetworkInterfaceType),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(NetworkInterfaceIpv6Address_Parse),
    MacAddress: node.first("macAddress", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(NetworkInterfacePrivateIpAddress_Parse),
    RequesterId: node.first("requesterId", false, x => x.content ?? ''),
    RequesterManaged: node.first("requesterManaged", false, x => x.content === 'true'),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as NetworkInterfaceStatus),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    TagSet: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface NetworkInterfaceAssociation {
  AllocationId?: string | null;
  AssociationId?: string | null;
  IpOwnerId?: string | null;
  PublicDnsName?: string | null;
  PublicIp?: string | null;
  CustomerOwnedIp?: string | null;
  CarrierIp?: string | null;
}
function NetworkInterfaceAssociation_Parse(node: xmlP.XmlNode): NetworkInterfaceAssociation {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    IpOwnerId: node.first("ipOwnerId", false, x => x.content ?? ''),
    PublicDnsName: node.first("publicDnsName", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
    CustomerOwnedIp: node.first("customerOwnedIp", false, x => x.content ?? ''),
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface NetworkInterfaceAttachment {
  AttachTime?: Date | number | null;
  AttachmentId?: string | null;
  DeleteOnTermination?: boolean | null;
  DeviceIndex?: number | null;
  InstanceId?: string | null;
  InstanceOwnerId?: string | null;
  Status?: AttachmentStatus | null;
}
function NetworkInterfaceAttachment_Parse(node: xmlP.XmlNode): NetworkInterfaceAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    AttachmentId: node.first("attachmentId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceOwnerId: node.first("instanceOwnerId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as AttachmentStatus),
  };
}

// refs: 2 - tags: output, named, enum
export type NetworkInterfaceType =
| "interface"
| "natGateway"
| "efa"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface NetworkInterfaceIpv6Address {
  Ipv6Address?: string | null;
}
function NetworkInterfaceIpv6Address_Parse(node: xmlP.XmlNode): NetworkInterfaceIpv6Address {
  return {
    Ipv6Address: node.first("ipv6Address", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface NetworkInterfacePrivateIpAddress {
  Association?: NetworkInterfaceAssociation | null;
  Primary?: boolean | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
}
function NetworkInterfacePrivateIpAddress_Parse(node: xmlP.XmlNode): NetworkInterfacePrivateIpAddress {
  return {
    Association: node.first("association", false, NetworkInterfaceAssociation_Parse),
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type NetworkInterfaceStatus =
| "available"
| "associated"
| "attaching"
| "in-use"
| "detaching"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface NetworkInterfacePermission {
  NetworkInterfacePermissionId?: string | null;
  NetworkInterfaceId?: string | null;
  AwsAccountId?: string | null;
  AwsService?: string | null;
  Permission?: InterfacePermissionType | null;
  PermissionState?: NetworkInterfacePermissionState | null;
}
function NetworkInterfacePermission_Parse(node: xmlP.XmlNode): NetworkInterfacePermission {
  return {
    NetworkInterfacePermissionId: node.first("networkInterfacePermissionId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    AwsAccountId: node.first("awsAccountId", false, x => x.content ?? ''),
    AwsService: node.first("awsService", false, x => x.content ?? ''),
    Permission: node.first("permission", false, x => (x.content ?? '') as InterfacePermissionType),
    PermissionState: node.first("permissionState", false, NetworkInterfacePermissionState_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface NetworkInterfacePermissionState {
  State?: NetworkInterfacePermissionStateCode | null;
  StatusMessage?: string | null;
}
function NetworkInterfacePermissionState_Parse(node: xmlP.XmlNode): NetworkInterfacePermissionState {
  return {
    State: node.first("state", false, x => (x.content ?? '') as NetworkInterfacePermissionStateCode),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, enum
export type NetworkInterfacePermissionStateCode =
| "pending"
| "granted"
| "revoking"
| "revoked"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface PlacementGroup {
  GroupName?: string | null;
  State?: PlacementGroupState | null;
  Strategy?: PlacementStrategy | null;
  PartitionCount?: number | null;
  GroupId?: string | null;
  Tags: Tag[];
}
function PlacementGroup_Parse(node: xmlP.XmlNode): PlacementGroup {
  return {
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as PlacementGroupState),
    Strategy: node.first("strategy", false, x => (x.content ?? '') as PlacementStrategy),
    PartitionCount: node.first("partitionCount", false, x => parseInt(x.content ?? '0')),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type PlacementGroupState =
| "pending"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface RouteTable {
  Associations: RouteTableAssociation[];
  PropagatingVgws: PropagatingVgw[];
  RouteTableId?: string | null;
  Routes: Route[];
  Tags: Tag[];
  VpcId?: string | null;
  OwnerId?: string | null;
}
function RouteTable_Parse(node: xmlP.XmlNode): RouteTable {
  return {
    Associations: node.getList("associationSet", "item").map(RouteTableAssociation_Parse),
    PropagatingVgws: node.getList("propagatingVgwSet", "item").map(PropagatingVgw_Parse),
    RouteTableId: node.first("routeTableId", false, x => x.content ?? ''),
    Routes: node.getList("routeSet", "item").map(Route_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface RouteTableAssociation {
  Main?: boolean | null;
  RouteTableAssociationId?: string | null;
  RouteTableId?: string | null;
  SubnetId?: string | null;
  GatewayId?: string | null;
  AssociationState?: RouteTableAssociationState | null;
}
function RouteTableAssociation_Parse(node: xmlP.XmlNode): RouteTableAssociation {
  return {
    Main: node.first("main", false, x => x.content === 'true'),
    RouteTableAssociationId: node.first("routeTableAssociationId", false, x => x.content ?? ''),
    RouteTableId: node.first("routeTableId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
    AssociationState: node.first("associationState", false, RouteTableAssociationState_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface PropagatingVgw {
  GatewayId?: string | null;
}
function PropagatingVgw_Parse(node: xmlP.XmlNode): PropagatingVgw {
  return {
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface Route {
  DestinationCidrBlock?: string | null;
  DestinationIpv6CidrBlock?: string | null;
  DestinationPrefixListId?: string | null;
  EgressOnlyInternetGatewayId?: string | null;
  GatewayId?: string | null;
  InstanceId?: string | null;
  InstanceOwnerId?: string | null;
  NatGatewayId?: string | null;
  TransitGatewayId?: string | null;
  LocalGatewayId?: string | null;
  CarrierGatewayId?: string | null;
  NetworkInterfaceId?: string | null;
  Origin?: RouteOrigin | null;
  State?: RouteState | null;
  VpcPeeringConnectionId?: string | null;
}
function Route_Parse(node: xmlP.XmlNode): Route {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    DestinationIpv6CidrBlock: node.first("destinationIpv6CidrBlock", false, x => x.content ?? ''),
    DestinationPrefixListId: node.first("destinationPrefixListId", false, x => x.content ?? ''),
    EgressOnlyInternetGatewayId: node.first("egressOnlyInternetGatewayId", false, x => x.content ?? ''),
    GatewayId: node.first("gatewayId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceOwnerId: node.first("instanceOwnerId", false, x => x.content ?? ''),
    NatGatewayId: node.first("natGatewayId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    CarrierGatewayId: node.first("carrierGatewayId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    Origin: node.first("origin", false, x => (x.content ?? '') as RouteOrigin),
    State: node.first("state", false, x => (x.content ?? '') as RouteState),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, enum
export type RouteOrigin =
| "CreateRouteTable"
| "CreateRoute"
| "EnableVgwRoutePropagation"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type RouteState =
| "active"
| "blackhole"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type SnapshotState =
| "pending"
| "completed"
| "error"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SnapshotInfo {
  Description?: string | null;
  Tags: Tag[];
  Encrypted?: boolean | null;
  VolumeId?: string | null;
  State?: SnapshotState | null;
  VolumeSize?: number | null;
  StartTime?: Date | number | null;
  Progress?: string | null;
  OwnerId?: string | null;
  SnapshotId?: string | null;
}
function SnapshotInfo_Parse(node: xmlP.XmlNode): SnapshotInfo {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as SnapshotState),
    VolumeSize: node.first("volumeSize", false, x => parseInt(x.content ?? '0')),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    Progress: node.first("progress", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface SpotDatafeedSubscription {
  Bucket?: string | null;
  Fault?: SpotInstanceStateFault | null;
  OwnerId?: string | null;
  Prefix?: string | null;
  State?: DatafeedSubscriptionState | null;
}
function SpotDatafeedSubscription_Parse(node: xmlP.XmlNode): SpotDatafeedSubscription {
  return {
    Bucket: node.first("bucket", false, x => x.content ?? ''),
    Fault: node.first("fault", false, SpotInstanceStateFault_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Prefix: node.first("prefix", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as DatafeedSubscriptionState),
  };
}

// refs: 4 - tags: output, named, interface
export interface SpotInstanceStateFault {
  Code?: string | null;
  Message?: string | null;
}
function SpotInstanceStateFault_Parse(node: xmlP.XmlNode): SpotInstanceStateFault {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, enum
export type DatafeedSubscriptionState =
| "Active"
| "Inactive"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface TrafficMirrorFilter {
  TrafficMirrorFilterId?: string | null;
  IngressFilterRules: TrafficMirrorFilterRule[];
  EgressFilterRules: TrafficMirrorFilterRule[];
  NetworkServices: TrafficMirrorNetworkService[];
  Description?: string | null;
  Tags: Tag[];
}
function TrafficMirrorFilter_Parse(node: xmlP.XmlNode): TrafficMirrorFilter {
  return {
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    IngressFilterRules: node.getList("ingressFilterRuleSet", "item").map(TrafficMirrorFilterRule_Parse),
    EgressFilterRules: node.getList("egressFilterRuleSet", "item").map(TrafficMirrorFilterRule_Parse),
    NetworkServices: node.getList("networkServiceSet", "item").map(x => (x.content ?? '') as TrafficMirrorNetworkService),
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface TrafficMirrorFilterRule {
  TrafficMirrorFilterRuleId?: string | null;
  TrafficMirrorFilterId?: string | null;
  TrafficDirection?: TrafficDirection | null;
  RuleNumber?: number | null;
  RuleAction?: TrafficMirrorRuleAction | null;
  Protocol?: number | null;
  DestinationPortRange?: TrafficMirrorPortRange | null;
  SourcePortRange?: TrafficMirrorPortRange | null;
  DestinationCidrBlock?: string | null;
  SourceCidrBlock?: string | null;
  Description?: string | null;
}
function TrafficMirrorFilterRule_Parse(node: xmlP.XmlNode): TrafficMirrorFilterRule {
  return {
    TrafficMirrorFilterRuleId: node.first("trafficMirrorFilterRuleId", false, x => x.content ?? ''),
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    TrafficDirection: node.first("trafficDirection", false, x => (x.content ?? '') as TrafficDirection),
    RuleNumber: node.first("ruleNumber", false, x => parseInt(x.content ?? '0')),
    RuleAction: node.first("ruleAction", false, x => (x.content ?? '') as TrafficMirrorRuleAction),
    Protocol: node.first("protocol", false, x => parseInt(x.content ?? '0')),
    DestinationPortRange: node.first("destinationPortRange", false, TrafficMirrorPortRange_Parse),
    SourcePortRange: node.first("sourcePortRange", false, TrafficMirrorPortRange_Parse),
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    SourceCidrBlock: node.first("sourceCidrBlock", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

// refs: 16 - tags: output, named, interface
export interface TrafficMirrorPortRange {
  FromPort?: number | null;
  ToPort?: number | null;
}
function TrafficMirrorPortRange_Parse(node: xmlP.XmlNode): TrafficMirrorPortRange {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface TrafficMirrorSession {
  TrafficMirrorSessionId?: string | null;
  TrafficMirrorTargetId?: string | null;
  TrafficMirrorFilterId?: string | null;
  NetworkInterfaceId?: string | null;
  OwnerId?: string | null;
  PacketLength?: number | null;
  SessionNumber?: number | null;
  VirtualNetworkId?: number | null;
  Description?: string | null;
  Tags: Tag[];
}
function TrafficMirrorSession_Parse(node: xmlP.XmlNode): TrafficMirrorSession {
  return {
    TrafficMirrorSessionId: node.first("trafficMirrorSessionId", false, x => x.content ?? ''),
    TrafficMirrorTargetId: node.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    TrafficMirrorFilterId: node.first("trafficMirrorFilterId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PacketLength: node.first("packetLength", false, x => parseInt(x.content ?? '0')),
    SessionNumber: node.first("sessionNumber", false, x => parseInt(x.content ?? '0')),
    VirtualNetworkId: node.first("virtualNetworkId", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface TrafficMirrorTarget {
  TrafficMirrorTargetId?: string | null;
  NetworkInterfaceId?: string | null;
  NetworkLoadBalancerArn?: string | null;
  Type?: TrafficMirrorTargetType | null;
  Description?: string | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function TrafficMirrorTarget_Parse(node: xmlP.XmlNode): TrafficMirrorTarget {
  return {
    TrafficMirrorTargetId: node.first("trafficMirrorTargetId", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    NetworkLoadBalancerArn: node.first("networkLoadBalancerArn", false, x => x.content ?? ''),
    Type: node.first("type", false, x => (x.content ?? '') as TrafficMirrorTargetType),
    Description: node.first("description", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type TrafficMirrorTargetType =
| "network-interface"
| "network-load-balancer"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface TransitGateway {
  TransitGatewayId?: string | null;
  TransitGatewayArn?: string | null;
  State?: TransitGatewayState | null;
  OwnerId?: string | null;
  Description?: string | null;
  CreationTime?: Date | number | null;
  Options?: TransitGatewayOptions | null;
  Tags: Tag[];
}
function TransitGateway_Parse(node: xmlP.XmlNode): TransitGateway {
  return {
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    TransitGatewayArn: node.first("transitGatewayArn", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayState),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Options: node.first("options", false, TransitGatewayOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 4 - tags: output, named, enum
export type TransitGatewayState =
| "pending"
| "available"
| "modifying"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface TransitGatewayOptions {
  AmazonSideAsn?: number | null;
  AutoAcceptSharedAttachments?: AutoAcceptSharedAttachmentsValue | null;
  DefaultRouteTableAssociation?: DefaultRouteTableAssociationValue | null;
  AssociationDefaultRouteTableId?: string | null;
  DefaultRouteTablePropagation?: DefaultRouteTablePropagationValue | null;
  PropagationDefaultRouteTableId?: string | null;
  VpnEcmpSupport?: VpnEcmpSupportValue | null;
  DnsSupport?: DnsSupportValue | null;
  MulticastSupport?: MulticastSupportValue | null;
}
function TransitGatewayOptions_Parse(node: xmlP.XmlNode): TransitGatewayOptions {
  return {
    AmazonSideAsn: node.first("amazonSideAsn", false, x => parseInt(x.content ?? '0')),
    AutoAcceptSharedAttachments: node.first("autoAcceptSharedAttachments", false, x => (x.content ?? '') as AutoAcceptSharedAttachmentsValue),
    DefaultRouteTableAssociation: node.first("defaultRouteTableAssociation", false, x => (x.content ?? '') as DefaultRouteTableAssociationValue),
    AssociationDefaultRouteTableId: node.first("associationDefaultRouteTableId", false, x => x.content ?? ''),
    DefaultRouteTablePropagation: node.first("defaultRouteTablePropagation", false, x => (x.content ?? '') as DefaultRouteTablePropagationValue),
    PropagationDefaultRouteTableId: node.first("propagationDefaultRouteTableId", false, x => x.content ?? ''),
    VpnEcmpSupport: node.first("vpnEcmpSupport", false, x => (x.content ?? '') as VpnEcmpSupportValue),
    DnsSupport: node.first("dnsSupport", false, x => (x.content ?? '') as DnsSupportValue),
    MulticastSupport: node.first("multicastSupport", false, x => (x.content ?? '') as MulticastSupportValue),
  };
}

// refs: 3 - tags: output, named, interface
export interface TransitGatewayMulticastDomain {
  TransitGatewayMulticastDomainId?: string | null;
  TransitGatewayId?: string | null;
  State?: TransitGatewayMulticastDomainState | null;
  CreationTime?: Date | number | null;
  Tags: Tag[];
}
function TransitGatewayMulticastDomain_Parse(node: xmlP.XmlNode): TransitGatewayMulticastDomain {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayMulticastDomainState),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type TransitGatewayMulticastDomainState =
| "pending"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface TransitGatewayPrefixListReference {
  TransitGatewayRouteTableId?: string | null;
  PrefixListId?: string | null;
  PrefixListOwnerId?: string | null;
  State?: TransitGatewayPrefixListReferenceState | null;
  Blackhole?: boolean | null;
  TransitGatewayAttachment?: TransitGatewayPrefixListAttachment | null;
}
function TransitGatewayPrefixListReference_Parse(node: xmlP.XmlNode): TransitGatewayPrefixListReference {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    PrefixListOwnerId: node.first("prefixListOwnerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayPrefixListReferenceState),
    Blackhole: node.first("blackhole", false, x => x.content === 'true'),
    TransitGatewayAttachment: node.first("transitGatewayAttachment", false, TransitGatewayPrefixListAttachment_Parse),
  };
}

// refs: 4 - tags: output, named, enum
export type TransitGatewayPrefixListReferenceState =
| "pending"
| "available"
| "modifying"
| "deleting"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface TransitGatewayPrefixListAttachment {
  TransitGatewayAttachmentId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  ResourceId?: string | null;
}
function TransitGatewayPrefixListAttachment_Parse(node: xmlP.XmlNode): TransitGatewayPrefixListAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface TransitGatewayRoute {
  DestinationCidrBlock?: string | null;
  PrefixListId?: string | null;
  TransitGatewayAttachments: TransitGatewayRouteAttachment[];
  Type?: TransitGatewayRouteType | null;
  State?: TransitGatewayRouteState | null;
}
function TransitGatewayRoute_Parse(node: xmlP.XmlNode): TransitGatewayRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    TransitGatewayAttachments: node.getList("transitGatewayAttachments", "item").map(TransitGatewayRouteAttachment_Parse),
    Type: node.first("type", false, x => (x.content ?? '') as TransitGatewayRouteType),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayRouteState),
  };
}

// refs: 4 - tags: output, named, interface
export interface TransitGatewayRouteAttachment {
  ResourceId?: string | null;
  TransitGatewayAttachmentId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
}
function TransitGatewayRouteAttachment_Parse(node: xmlP.XmlNode): TransitGatewayRouteAttachment {
  return {
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
  };
}

// refs: 4 - tags: output, named, enum
export type TransitGatewayRouteType =
| "static"
| "propagated"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type TransitGatewayRouteState =
| "pending"
| "active"
| "blackhole"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface TransitGatewayRouteTable {
  TransitGatewayRouteTableId?: string | null;
  TransitGatewayId?: string | null;
  State?: TransitGatewayRouteTableState | null;
  DefaultAssociationRouteTable?: boolean | null;
  DefaultPropagationRouteTable?: boolean | null;
  CreationTime?: Date | number | null;
  Tags: Tag[];
}
function TransitGatewayRouteTable_Parse(node: xmlP.XmlNode): TransitGatewayRouteTable {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayRouteTableState),
    DefaultAssociationRouteTable: node.first("defaultAssociationRouteTable", false, x => x.content === 'true'),
    DefaultPropagationRouteTable: node.first("defaultPropagationRouteTable", false, x => x.content === 'true'),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type TransitGatewayRouteTableState =
| "pending"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type VolumeState =
| "creating"
| "available"
| "in-use"
| "deleting"
| "deleted"
| "error"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface VpcEndpoint {
  VpcEndpointId?: string | null;
  VpcEndpointType?: VpcEndpointType | null;
  VpcId?: string | null;
  ServiceName?: string | null;
  State?: State | null;
  PolicyDocument?: string | null;
  RouteTableIds: string[];
  SubnetIds: string[];
  Groups: SecurityGroupIdentifier[];
  PrivateDnsEnabled?: boolean | null;
  RequesterManaged?: boolean | null;
  NetworkInterfaceIds: string[];
  DnsEntries: DnsEntry[];
  CreationTimestamp?: Date | number | null;
  Tags: Tag[];
  OwnerId?: string | null;
  LastError?: LastError | null;
}
function VpcEndpoint_Parse(node: xmlP.XmlNode): VpcEndpoint {
  return {
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    VpcEndpointType: node.first("vpcEndpointType", false, x => (x.content ?? '') as VpcEndpointType),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as State),
    PolicyDocument: node.first("policyDocument", false, x => x.content ?? ''),
    RouteTableIds: node.getList("routeTableIdSet", "item").map(x => x.content ?? ''),
    SubnetIds: node.getList("subnetIdSet", "item").map(x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(SecurityGroupIdentifier_Parse),
    PrivateDnsEnabled: node.first("privateDnsEnabled", false, x => x.content === 'true'),
    RequesterManaged: node.first("requesterManaged", false, x => x.content === 'true'),
    NetworkInterfaceIds: node.getList("networkInterfaceIdSet", "item").map(x => x.content ?? ''),
    DnsEntries: node.getList("dnsEntrySet", "item").map(DnsEntry_Parse),
    CreationTimestamp: node.first("creationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    LastError: node.first("lastError", false, LastError_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type State =
| "PendingAcceptance"
| "Pending"
| "Available"
| "Deleting"
| "Deleted"
| "Rejected"
| "Failed"
| "Expired"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SecurityGroupIdentifier {
  GroupId?: string | null;
  GroupName?: string | null;
}
function SecurityGroupIdentifier_Parse(node: xmlP.XmlNode): SecurityGroupIdentifier {
  return {
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface DnsEntry {
  DnsName?: string | null;
  HostedZoneId?: string | null;
}
function DnsEntry_Parse(node: xmlP.XmlNode): DnsEntry {
  return {
    DnsName: node.first("dnsName", false, x => x.content ?? ''),
    HostedZoneId: node.first("hostedZoneId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface LastError {
  Message?: string | null;
  Code?: string | null;
}
function LastError_Parse(node: xmlP.XmlNode): LastError {
  return {
    Message: node.first("message", false, x => x.content ?? ''),
    Code: node.first("code", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ConnectionNotification {
  ConnectionNotificationId?: string | null;
  ServiceId?: string | null;
  VpcEndpointId?: string | null;
  ConnectionNotificationType?: ConnectionNotificationType | null;
  ConnectionNotificationArn?: string | null;
  ConnectionEvents: string[];
  ConnectionNotificationState?: ConnectionNotificationState | null;
}
function ConnectionNotification_Parse(node: xmlP.XmlNode): ConnectionNotification {
  return {
    ConnectionNotificationId: node.first("connectionNotificationId", false, x => x.content ?? ''),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    ConnectionNotificationType: node.first("connectionNotificationType", false, x => (x.content ?? '') as ConnectionNotificationType),
    ConnectionNotificationArn: node.first("connectionNotificationArn", false, x => x.content ?? ''),
    ConnectionEvents: node.getList("connectionEvents", "item").map(x => x.content ?? ''),
    ConnectionNotificationState: node.first("connectionNotificationState", false, x => (x.content ?? '') as ConnectionNotificationState),
  };
}

// refs: 2 - tags: output, named, enum
export type ConnectionNotificationType =
| "Topic"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ConnectionNotificationState =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ServiceConfiguration {
  ServiceType: ServiceTypeDetail[];
  ServiceId?: string | null;
  ServiceName?: string | null;
  ServiceState?: ServiceState | null;
  AvailabilityZones: string[];
  AcceptanceRequired?: boolean | null;
  ManagesVpcEndpoints?: boolean | null;
  NetworkLoadBalancerArns: string[];
  BaseEndpointDnsNames: string[];
  PrivateDnsName?: string | null;
  PrivateDnsNameConfiguration?: PrivateDnsNameConfiguration | null;
  Tags: Tag[];
}
function ServiceConfiguration_Parse(node: xmlP.XmlNode): ServiceConfiguration {
  return {
    ServiceType: node.getList("serviceType", "item").map(ServiceTypeDetail_Parse),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    ServiceState: node.first("serviceState", false, x => (x.content ?? '') as ServiceState),
    AvailabilityZones: node.getList("availabilityZoneSet", "item").map(x => x.content ?? ''),
    AcceptanceRequired: node.first("acceptanceRequired", false, x => x.content === 'true'),
    ManagesVpcEndpoints: node.first("managesVpcEndpoints", false, x => x.content === 'true'),
    NetworkLoadBalancerArns: node.getList("networkLoadBalancerArnSet", "item").map(x => x.content ?? ''),
    BaseEndpointDnsNames: node.getList("baseEndpointDnsNameSet", "item").map(x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateDnsNameConfiguration: node.first("privateDnsNameConfiguration", false, PrivateDnsNameConfiguration_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ServiceTypeDetail {
  ServiceType?: ServiceType | null;
}
function ServiceTypeDetail_Parse(node: xmlP.XmlNode): ServiceTypeDetail {
  return {
    ServiceType: node.first("serviceType", false, x => (x.content ?? '') as ServiceType),
  };
}

// refs: 3 - tags: output, named, enum
export type ServiceType =
| "Interface"
| "Gateway"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ServiceState =
| "Pending"
| "Available"
| "Deleting"
| "Deleted"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface PrivateDnsNameConfiguration {
  State?: DnsNameState | null;
  Type?: string | null;
  Value?: string | null;
  Name?: string | null;
}
function PrivateDnsNameConfiguration_Parse(node: xmlP.XmlNode): PrivateDnsNameConfiguration {
  return {
    State: node.first("state", false, x => (x.content ?? '') as DnsNameState),
    Type: node.first("type", false, x => x.content ?? ''),
    Value: node.first("value", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type DnsNameState =
| "pendingVerification"
| "verified"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface VpnConnection {
  CustomerGatewayConfiguration?: string | null;
  CustomerGatewayId?: string | null;
  Category?: string | null;
  State?: VpnState | null;
  Type?: GatewayType | null;
  VpnConnectionId?: string | null;
  VpnGatewayId?: string | null;
  TransitGatewayId?: string | null;
  Options?: VpnConnectionOptions | null;
  Routes: VpnStaticRoute[];
  Tags: Tag[];
  VgwTelemetry: VgwTelemetry[];
}
function VpnConnection_Parse(node: xmlP.XmlNode): VpnConnection {
  return {
    CustomerGatewayConfiguration: node.first("customerGatewayConfiguration", false, x => x.content ?? ''),
    CustomerGatewayId: node.first("customerGatewayId", false, x => x.content ?? ''),
    Category: node.first("category", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as VpnState),
    Type: node.first("type", false, x => (x.content ?? '') as GatewayType),
    VpnConnectionId: node.first("vpnConnectionId", false, x => x.content ?? ''),
    VpnGatewayId: node.first("vpnGatewayId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    Options: node.first("options", false, VpnConnectionOptions_Parse),
    Routes: node.getList("routes", "item").map(VpnStaticRoute_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VgwTelemetry: node.getList("vgwTelemetry", "item").map(VgwTelemetry_Parse),
  };
}

// refs: 14 - tags: output, named, enum
export type VpnState =
| "pending"
| "available"
| "deleting"
| "deleted"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface VpnConnectionOptions {
  EnableAcceleration?: boolean | null;
  StaticRoutesOnly?: boolean | null;
  LocalIpv4NetworkCidr?: string | null;
  RemoteIpv4NetworkCidr?: string | null;
  LocalIpv6NetworkCidr?: string | null;
  RemoteIpv6NetworkCidr?: string | null;
  TunnelInsideIpVersion?: TunnelInsideIpVersion | null;
  TunnelOptions: TunnelOption[];
}
function VpnConnectionOptions_Parse(node: xmlP.XmlNode): VpnConnectionOptions {
  return {
    EnableAcceleration: node.first("enableAcceleration", false, x => x.content === 'true'),
    StaticRoutesOnly: node.first("staticRoutesOnly", false, x => x.content === 'true'),
    LocalIpv4NetworkCidr: node.first("localIpv4NetworkCidr", false, x => x.content ?? ''),
    RemoteIpv4NetworkCidr: node.first("remoteIpv4NetworkCidr", false, x => x.content ?? ''),
    LocalIpv6NetworkCidr: node.first("localIpv6NetworkCidr", false, x => x.content ?? ''),
    RemoteIpv6NetworkCidr: node.first("remoteIpv6NetworkCidr", false, x => x.content ?? ''),
    TunnelInsideIpVersion: node.first("tunnelInsideIpVersion", false, x => (x.content ?? '') as TunnelInsideIpVersion),
    TunnelOptions: node.getList("tunnelOptionSet", "item").map(TunnelOption_Parse),
  };
}

// refs: 6 - tags: output, named, interface
export interface TunnelOption {
  OutsideIpAddress?: string | null;
  TunnelInsideCidr?: string | null;
  TunnelInsideIpv6Cidr?: string | null;
  PreSharedKey?: string | null;
  Phase1LifetimeSeconds?: number | null;
  Phase2LifetimeSeconds?: number | null;
  RekeyMarginTimeSeconds?: number | null;
  RekeyFuzzPercentage?: number | null;
  ReplayWindowSize?: number | null;
  DpdTimeoutSeconds?: number | null;
  DpdTimeoutAction?: string | null;
  Phase1EncryptionAlgorithms: Phase1EncryptionAlgorithmsListValue[];
  Phase2EncryptionAlgorithms: Phase2EncryptionAlgorithmsListValue[];
  Phase1IntegrityAlgorithms: Phase1IntegrityAlgorithmsListValue[];
  Phase2IntegrityAlgorithms: Phase2IntegrityAlgorithmsListValue[];
  Phase1DHGroupNumbers: Phase1DHGroupNumbersListValue[];
  Phase2DHGroupNumbers: Phase2DHGroupNumbersListValue[];
  IkeVersions: IKEVersionsListValue[];
  StartupAction?: string | null;
}
function TunnelOption_Parse(node: xmlP.XmlNode): TunnelOption {
  return {
    OutsideIpAddress: node.first("outsideIpAddress", false, x => x.content ?? ''),
    TunnelInsideCidr: node.first("tunnelInsideCidr", false, x => x.content ?? ''),
    TunnelInsideIpv6Cidr: node.first("tunnelInsideIpv6Cidr", false, x => x.content ?? ''),
    PreSharedKey: node.first("preSharedKey", false, x => x.content ?? ''),
    Phase1LifetimeSeconds: node.first("phase1LifetimeSeconds", false, x => parseInt(x.content ?? '0')),
    Phase2LifetimeSeconds: node.first("phase2LifetimeSeconds", false, x => parseInt(x.content ?? '0')),
    RekeyMarginTimeSeconds: node.first("rekeyMarginTimeSeconds", false, x => parseInt(x.content ?? '0')),
    RekeyFuzzPercentage: node.first("rekeyFuzzPercentage", false, x => parseInt(x.content ?? '0')),
    ReplayWindowSize: node.first("replayWindowSize", false, x => parseInt(x.content ?? '0')),
    DpdTimeoutSeconds: node.first("dpdTimeoutSeconds", false, x => parseInt(x.content ?? '0')),
    DpdTimeoutAction: node.first("dpdTimeoutAction", false, x => x.content ?? ''),
    Phase1EncryptionAlgorithms: node.getList("phase1EncryptionAlgorithmSet", "item").map(Phase1EncryptionAlgorithmsListValue_Parse),
    Phase2EncryptionAlgorithms: node.getList("phase2EncryptionAlgorithmSet", "item").map(Phase2EncryptionAlgorithmsListValue_Parse),
    Phase1IntegrityAlgorithms: node.getList("phase1IntegrityAlgorithmSet", "item").map(Phase1IntegrityAlgorithmsListValue_Parse),
    Phase2IntegrityAlgorithms: node.getList("phase2IntegrityAlgorithmSet", "item").map(Phase2IntegrityAlgorithmsListValue_Parse),
    Phase1DHGroupNumbers: node.getList("phase1DHGroupNumberSet", "item").map(Phase1DHGroupNumbersListValue_Parse),
    Phase2DHGroupNumbers: node.getList("phase2DHGroupNumberSet", "item").map(Phase2DHGroupNumbersListValue_Parse),
    IkeVersions: node.getList("ikeVersionSet", "item").map(IKEVersionsListValue_Parse),
    StartupAction: node.first("startupAction", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase1EncryptionAlgorithmsListValue {
  Value?: string | null;
}
function Phase1EncryptionAlgorithmsListValue_Parse(node: xmlP.XmlNode): Phase1EncryptionAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase2EncryptionAlgorithmsListValue {
  Value?: string | null;
}
function Phase2EncryptionAlgorithmsListValue_Parse(node: xmlP.XmlNode): Phase2EncryptionAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase1IntegrityAlgorithmsListValue {
  Value?: string | null;
}
function Phase1IntegrityAlgorithmsListValue_Parse(node: xmlP.XmlNode): Phase1IntegrityAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase2IntegrityAlgorithmsListValue {
  Value?: string | null;
}
function Phase2IntegrityAlgorithmsListValue_Parse(node: xmlP.XmlNode): Phase2IntegrityAlgorithmsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase1DHGroupNumbersListValue {
  Value?: number | null;
}
function Phase1DHGroupNumbersListValue_Parse(node: xmlP.XmlNode): Phase1DHGroupNumbersListValue {
  return {
    Value: node.first("value", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 6 - tags: output, named, interface
export interface Phase2DHGroupNumbersListValue {
  Value?: number | null;
}
function Phase2DHGroupNumbersListValue_Parse(node: xmlP.XmlNode): Phase2DHGroupNumbersListValue {
  return {
    Value: node.first("value", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 6 - tags: output, named, interface
export interface IKEVersionsListValue {
  Value?: string | null;
}
function IKEVersionsListValue_Parse(node: xmlP.XmlNode): IKEVersionsListValue {
  return {
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, interface
export interface VpnStaticRoute {
  DestinationCidrBlock?: string | null;
  Source?: VpnStaticRouteSource | null;
  State?: VpnState | null;
}
function VpnStaticRoute_Parse(node: xmlP.XmlNode): VpnStaticRoute {
  return {
    DestinationCidrBlock: node.first("destinationCidrBlock", false, x => x.content ?? ''),
    Source: node.first("source", false, x => (x.content ?? '') as VpnStaticRouteSource),
    State: node.first("state", false, x => (x.content ?? '') as VpnState),
  };
}

// refs: 6 - tags: output, named, enum
export type VpnStaticRouteSource =
| "Static"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface VgwTelemetry {
  AcceptedRouteCount?: number | null;
  LastStatusChange?: Date | number | null;
  OutsideIpAddress?: string | null;
  Status?: TelemetryStatus | null;
  StatusMessage?: string | null;
  CertificateArn?: string | null;
}
function VgwTelemetry_Parse(node: xmlP.XmlNode): VgwTelemetry {
  return {
    AcceptedRouteCount: node.first("acceptedRouteCount", false, x => parseInt(x.content ?? '0')),
    LastStatusChange: node.first("lastStatusChange", false, x => xmlP.parseTimestamp(x.content)),
    OutsideIpAddress: node.first("outsideIpAddress", false, x => x.content ?? ''),
    Status: node.first("status", false, x => (x.content ?? '') as TelemetryStatus),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    CertificateArn: node.first("certificateArn", false, x => x.content ?? ''),
  };
}

// refs: 6 - tags: output, named, enum
export type TelemetryStatus =
| "UP"
| "DOWN"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface VpnGateway {
  AvailabilityZone?: string | null;
  State?: VpnState | null;
  Type?: GatewayType | null;
  VpcAttachments: VpcAttachment[];
  VpnGatewayId?: string | null;
  AmazonSideAsn?: number | null;
  Tags: Tag[];
}
function VpnGateway_Parse(node: xmlP.XmlNode): VpnGateway {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as VpnState),
    Type: node.first("type", false, x => (x.content ?? '') as GatewayType),
    VpcAttachments: node.getList("attachments", "item").map(VpcAttachment_Parse),
    VpnGatewayId: node.first("vpnGatewayId", false, x => x.content ?? ''),
    AmazonSideAsn: node.first("amazonSideAsn", false, x => parseInt(x.content ?? '0')),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface DeleteFleetSuccessItem {
  CurrentFleetState?: FleetStateCode | null;
  PreviousFleetState?: FleetStateCode | null;
  FleetId?: string | null;
}
function DeleteFleetSuccessItem_Parse(node: xmlP.XmlNode): DeleteFleetSuccessItem {
  return {
    CurrentFleetState: node.first("currentFleetState", false, x => (x.content ?? '') as FleetStateCode),
    PreviousFleetState: node.first("previousFleetState", false, x => (x.content ?? '') as FleetStateCode),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type FleetStateCode =
| "submitted"
| "active"
| "deleted"
| "failed"
| "deleted_running"
| "deleted_terminating"
| "modifying"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DeleteFleetErrorItem {
  Error?: DeleteFleetError | null;
  FleetId?: string | null;
}
function DeleteFleetErrorItem_Parse(node: xmlP.XmlNode): DeleteFleetErrorItem {
  return {
    Error: node.first("error", false, DeleteFleetError_Parse),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DeleteFleetError {
  Code?: DeleteFleetErrorCode | null;
  Message?: string | null;
}
function DeleteFleetError_Parse(node: xmlP.XmlNode): DeleteFleetError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as DeleteFleetErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type DeleteFleetErrorCode =
| "fleetIdDoesNotExist"
| "fleetIdMalformed"
| "fleetNotInDeletableState"
| "unexpectedError"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DeleteLaunchTemplateVersionsResponseSuccessItem {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  VersionNumber?: number | null;
}
function DeleteLaunchTemplateVersionsResponseSuccessItem_Parse(node: xmlP.XmlNode): DeleteLaunchTemplateVersionsResponseSuccessItem {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface DeleteLaunchTemplateVersionsResponseErrorItem {
  LaunchTemplateId?: string | null;
  LaunchTemplateName?: string | null;
  VersionNumber?: number | null;
  ResponseError?: ResponseError | null;
}
function DeleteLaunchTemplateVersionsResponseErrorItem_Parse(node: xmlP.XmlNode): DeleteLaunchTemplateVersionsResponseErrorItem {
  return {
    LaunchTemplateId: node.first("launchTemplateId", false, x => x.content ?? ''),
    LaunchTemplateName: node.first("launchTemplateName", false, x => x.content ?? ''),
    VersionNumber: node.first("versionNumber", false, x => parseInt(x.content ?? '0')),
    ResponseError: node.first("responseError", false, ResponseError_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ResponseError {
  Code?: LaunchTemplateErrorCode | null;
  Message?: string | null;
}
function ResponseError_Parse(node: xmlP.XmlNode): ResponseError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as LaunchTemplateErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type LaunchTemplateErrorCode =
| "launchTemplateIdDoesNotExist"
| "launchTemplateIdMalformed"
| "launchTemplateNameDoesNotExist"
| "launchTemplateNameMalformed"
| "launchTemplateVersionDoesNotExist"
| "unexpectedError"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SuccessfulQueuedPurchaseDeletion {
  ReservedInstancesId?: string | null;
}
function SuccessfulQueuedPurchaseDeletion_Parse(node: xmlP.XmlNode): SuccessfulQueuedPurchaseDeletion {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface FailedQueuedPurchaseDeletion {
  Error?: DeleteQueuedReservedInstancesError | null;
  ReservedInstancesId?: string | null;
}
function FailedQueuedPurchaseDeletion_Parse(node: xmlP.XmlNode): FailedQueuedPurchaseDeletion {
  return {
    Error: node.first("error", false, DeleteQueuedReservedInstancesError_Parse),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DeleteQueuedReservedInstancesError {
  Code?: DeleteQueuedReservedInstancesErrorCode | null;
  Message?: string | null;
}
function DeleteQueuedReservedInstancesError_Parse(node: xmlP.XmlNode): DeleteQueuedReservedInstancesError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as DeleteQueuedReservedInstancesErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type DeleteQueuedReservedInstancesErrorCode =
| "reserved-instances-id-invalid"
| "reserved-instances-not-in-queued-state"
| "unexpected-error"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InstanceTagNotificationAttribute {
  InstanceTagKeys: string[];
  IncludeAllTagsOfInstance?: boolean | null;
}
function InstanceTagNotificationAttribute_Parse(node: xmlP.XmlNode): InstanceTagNotificationAttribute {
  return {
    InstanceTagKeys: node.getList("instanceTagKeySet", "item").map(x => x.content ?? ''),
    IncludeAllTagsOfInstance: node.first("includeAllTagsOfInstance", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastDeregisteredGroupMembers {
  TransitGatewayMulticastDomainId?: string | null;
  DeregisteredNetworkInterfaceIds: string[];
  GroupIpAddress?: string | null;
}
function TransitGatewayMulticastDeregisteredGroupMembers_Parse(node: xmlP.XmlNode): TransitGatewayMulticastDeregisteredGroupMembers {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    DeregisteredNetworkInterfaceIds: node.getList("deregisteredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastDeregisteredGroupSources {
  TransitGatewayMulticastDomainId?: string | null;
  DeregisteredNetworkInterfaceIds: string[];
  GroupIpAddress?: string | null;
}
function TransitGatewayMulticastDeregisteredGroupSources_Parse(node: xmlP.XmlNode): TransitGatewayMulticastDeregisteredGroupSources {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    DeregisteredNetworkInterfaceIds: node.getList("deregisteredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccountAttribute {
  AttributeName?: string | null;
  AttributeValues: AccountAttributeValue[];
}
function AccountAttribute_Parse(node: xmlP.XmlNode): AccountAttribute {
  return {
    AttributeName: node.first("attributeName", false, x => x.content ?? ''),
    AttributeValues: node.getList("attributeValueSet", "item").map(AccountAttributeValue_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccountAttributeValue {
  AttributeValue?: string | null;
}
function AccountAttributeValue_Parse(node: xmlP.XmlNode): AccountAttributeValue {
  return {
    AttributeValue: node.first("attributeValue", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Address {
  InstanceId?: string | null;
  PublicIp?: string | null;
  AllocationId?: string | null;
  AssociationId?: string | null;
  Domain?: DomainType | null;
  NetworkInterfaceId?: string | null;
  NetworkInterfaceOwnerId?: string | null;
  PrivateIpAddress?: string | null;
  Tags: Tag[];
  PublicIpv4Pool?: string | null;
  NetworkBorderGroup?: string | null;
  CustomerOwnedIp?: string | null;
  CustomerOwnedIpv4Pool?: string | null;
  CarrierIp?: string | null;
}
function Address_Parse(node: xmlP.XmlNode): Address {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    Domain: node.first("domain", false, x => (x.content ?? '') as DomainType),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    NetworkInterfaceOwnerId: node.first("networkInterfaceOwnerId", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PublicIpv4Pool: node.first("publicIpv4Pool", false, x => x.content ?? ''),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    CustomerOwnedIp: node.first("customerOwnedIp", false, x => x.content ?? ''),
    CustomerOwnedIpv4Pool: node.first("customerOwnedIpv4Pool", false, x => x.content ?? ''),
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface IdFormat {
  Deadline?: Date | number | null;
  Resource?: string | null;
  UseLongIds?: boolean | null;
}
function IdFormat_Parse(node: xmlP.XmlNode): IdFormat {
  return {
    Deadline: node.first("deadline", false, x => xmlP.parseTimestamp(x.content)),
    Resource: node.first("resource", false, x => x.content ?? ''),
    UseLongIds: node.first("useLongIds", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface AvailabilityZone {
  State?: AvailabilityZoneState | null;
  OptInStatus?: AvailabilityZoneOptInStatus | null;
  Messages: AvailabilityZoneMessage[];
  RegionName?: string | null;
  ZoneName?: string | null;
  ZoneId?: string | null;
  GroupName?: string | null;
  NetworkBorderGroup?: string | null;
  ZoneType?: string | null;
  ParentZoneName?: string | null;
  ParentZoneId?: string | null;
}
function AvailabilityZone_Parse(node: xmlP.XmlNode): AvailabilityZone {
  return {
    State: node.first("zoneState", false, x => (x.content ?? '') as AvailabilityZoneState),
    OptInStatus: node.first("optInStatus", false, x => (x.content ?? '') as AvailabilityZoneOptInStatus),
    Messages: node.getList("messageSet", "item").map(AvailabilityZoneMessage_Parse),
    RegionName: node.first("regionName", false, x => x.content ?? ''),
    ZoneName: node.first("zoneName", false, x => x.content ?? ''),
    ZoneId: node.first("zoneId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    ZoneType: node.first("zoneType", false, x => x.content ?? ''),
    ParentZoneName: node.first("parentZoneName", false, x => x.content ?? ''),
    ParentZoneId: node.first("parentZoneId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type AvailabilityZoneState =
| "available"
| "information"
| "impaired"
| "unavailable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type AvailabilityZoneOptInStatus =
| "opt-in-not-required"
| "opted-in"
| "not-opted-in"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AvailabilityZoneMessage {
  Message?: string | null;
}
function AvailabilityZoneMessage_Parse(node: xmlP.XmlNode): AvailabilityZoneMessage {
  return {
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ClassicLinkInstance {
  Groups: GroupIdentifier[];
  InstanceId?: string | null;
  Tags: Tag[];
  VpcId?: string | null;
}
function ClassicLinkInstance_Parse(node: xmlP.XmlNode): ClassicLinkInstance {
  return {
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface AuthorizationRule {
  ClientVpnEndpointId?: string | null;
  Description?: string | null;
  GroupId?: string | null;
  AccessAll?: boolean | null;
  DestinationCidr?: string | null;
  Status?: ClientVpnAuthorizationRuleStatus | null;
}
function AuthorizationRule_Parse(node: xmlP.XmlNode): AuthorizationRule {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    AccessAll: node.first("accessAll", false, x => x.content === 'true'),
    DestinationCidr: node.first("destinationCidr", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnAuthorizationRuleStatus_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ClientVpnConnection {
  ClientVpnEndpointId?: string | null;
  Timestamp?: string | null;
  ConnectionId?: string | null;
  Username?: string | null;
  ConnectionEstablishedTime?: string | null;
  IngressBytes?: string | null;
  EgressBytes?: string | null;
  IngressPackets?: string | null;
  EgressPackets?: string | null;
  ClientIp?: string | null;
  CommonName?: string | null;
  Status?: ClientVpnConnectionStatus | null;
  ConnectionEndTime?: string | null;
}
function ClientVpnConnection_Parse(node: xmlP.XmlNode): ClientVpnConnection {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Timestamp: node.first("timestamp", false, x => x.content ?? ''),
    ConnectionId: node.first("connectionId", false, x => x.content ?? ''),
    Username: node.first("username", false, x => x.content ?? ''),
    ConnectionEstablishedTime: node.first("connectionEstablishedTime", false, x => x.content ?? ''),
    IngressBytes: node.first("ingressBytes", false, x => x.content ?? ''),
    EgressBytes: node.first("egressBytes", false, x => x.content ?? ''),
    IngressPackets: node.first("ingressPackets", false, x => x.content ?? ''),
    EgressPackets: node.first("egressPackets", false, x => x.content ?? ''),
    ClientIp: node.first("clientIp", false, x => x.content ?? ''),
    CommonName: node.first("commonName", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnConnectionStatus_Parse),
    ConnectionEndTime: node.first("connectionEndTime", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface ClientVpnConnectionStatus {
  Code?: ClientVpnConnectionStatusCode | null;
  Message?: string | null;
}
function ClientVpnConnectionStatus_Parse(node: xmlP.XmlNode): ClientVpnConnectionStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as ClientVpnConnectionStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, enum
export type ClientVpnConnectionStatusCode =
| "active"
| "failed-to-terminate"
| "terminating"
| "terminated"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ClientVpnEndpoint {
  ClientVpnEndpointId?: string | null;
  Description?: string | null;
  Status?: ClientVpnEndpointStatus | null;
  CreationTime?: string | null;
  DeletionTime?: string | null;
  DnsName?: string | null;
  ClientCidrBlock?: string | null;
  DnsServers: string[];
  SplitTunnel?: boolean | null;
  VpnProtocol?: VpnProtocol | null;
  TransportProtocol?: TransportProtocol | null;
  VpnPort?: number | null;
  AssociatedTargetNetworks: AssociatedTargetNetwork[];
  ServerCertificateArn?: string | null;
  AuthenticationOptions: ClientVpnAuthentication[];
  ConnectionLogOptions?: ConnectionLogResponseOptions | null;
  Tags: Tag[];
  SecurityGroupIds: string[];
  VpcId?: string | null;
}
function ClientVpnEndpoint_Parse(node: xmlP.XmlNode): ClientVpnEndpoint {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnEndpointStatus_Parse),
    CreationTime: node.first("creationTime", false, x => x.content ?? ''),
    DeletionTime: node.first("deletionTime", false, x => x.content ?? ''),
    DnsName: node.first("dnsName", false, x => x.content ?? ''),
    ClientCidrBlock: node.first("clientCidrBlock", false, x => x.content ?? ''),
    DnsServers: node.getList("dnsServer", "item").map(x => x.content ?? ''),
    SplitTunnel: node.first("splitTunnel", false, x => x.content === 'true'),
    VpnProtocol: node.first("vpnProtocol", false, x => (x.content ?? '') as VpnProtocol),
    TransportProtocol: node.first("transportProtocol", false, x => (x.content ?? '') as TransportProtocol),
    VpnPort: node.first("vpnPort", false, x => parseInt(x.content ?? '0')),
    AssociatedTargetNetworks: node.getList("associatedTargetNetwork", "item").map(AssociatedTargetNetwork_Parse),
    ServerCertificateArn: node.first("serverCertificateArn", false, x => x.content ?? ''),
    AuthenticationOptions: node.getList("authenticationOptions", "item").map(ClientVpnAuthentication_Parse),
    ConnectionLogOptions: node.first("connectionLogOptions", false, ConnectionLogResponseOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    SecurityGroupIds: node.getList("securityGroupIdSet", "item").map(x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type VpnProtocol =
| "openvpn"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AssociatedTargetNetwork {
  NetworkId?: string | null;
  NetworkType?: AssociatedNetworkType | null;
}
function AssociatedTargetNetwork_Parse(node: xmlP.XmlNode): AssociatedTargetNetwork {
  return {
    NetworkId: node.first("networkId", false, x => x.content ?? ''),
    NetworkType: node.first("networkType", false, x => (x.content ?? '') as AssociatedNetworkType),
  };
}

// refs: 1 - tags: output, named, enum
export type AssociatedNetworkType =
| "vpc"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ClientVpnAuthentication {
  Type?: ClientVpnAuthenticationType | null;
  ActiveDirectory?: DirectoryServiceAuthentication | null;
  MutualAuthentication?: CertificateAuthentication | null;
  FederatedAuthentication?: FederatedAuthentication | null;
}
function ClientVpnAuthentication_Parse(node: xmlP.XmlNode): ClientVpnAuthentication {
  return {
    Type: node.first("type", false, x => (x.content ?? '') as ClientVpnAuthenticationType),
    ActiveDirectory: node.first("activeDirectory", false, DirectoryServiceAuthentication_Parse),
    MutualAuthentication: node.first("mutualAuthentication", false, CertificateAuthentication_Parse),
    FederatedAuthentication: node.first("federatedAuthentication", false, FederatedAuthentication_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface DirectoryServiceAuthentication {
  DirectoryId?: string | null;
}
function DirectoryServiceAuthentication_Parse(node: xmlP.XmlNode): DirectoryServiceAuthentication {
  return {
    DirectoryId: node.first("directoryId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CertificateAuthentication {
  ClientRootCertificateChain?: string | null;
}
function CertificateAuthentication_Parse(node: xmlP.XmlNode): CertificateAuthentication {
  return {
    ClientRootCertificateChain: node.first("clientRootCertificateChain", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface FederatedAuthentication {
  SamlProviderArn?: string | null;
}
function FederatedAuthentication_Parse(node: xmlP.XmlNode): FederatedAuthentication {
  return {
    SamlProviderArn: node.first("samlProviderArn", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ConnectionLogResponseOptions {
  Enabled?: boolean | null;
  CloudwatchLogGroup?: string | null;
  CloudwatchLogStream?: string | null;
}
function ConnectionLogResponseOptions_Parse(node: xmlP.XmlNode): ConnectionLogResponseOptions {
  return {
    ...node.strings({
      optional: {"CloudwatchLogGroup":true,"CloudwatchLogStream":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface ClientVpnRoute {
  ClientVpnEndpointId?: string | null;
  DestinationCidr?: string | null;
  TargetSubnet?: string | null;
  Type?: string | null;
  Origin?: string | null;
  Status?: ClientVpnRouteStatus | null;
  Description?: string | null;
}
function ClientVpnRoute_Parse(node: xmlP.XmlNode): ClientVpnRoute {
  return {
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    DestinationCidr: node.first("destinationCidr", false, x => x.content ?? ''),
    TargetSubnet: node.first("targetSubnet", false, x => x.content ?? ''),
    Type: node.first("type", false, x => x.content ?? ''),
    Origin: node.first("origin", false, x => x.content ?? ''),
    Status: node.first("status", false, ClientVpnRouteStatus_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetNetwork {
  AssociationId?: string | null;
  VpcId?: string | null;
  TargetNetworkId?: string | null;
  ClientVpnEndpointId?: string | null;
  Status?: AssociationStatus | null;
  SecurityGroups: string[];
}
function TargetNetwork_Parse(node: xmlP.XmlNode): TargetNetwork {
  return {
    AssociationId: node.first("associationId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    TargetNetworkId: node.first("targetNetworkId", false, x => x.content ?? ''),
    ClientVpnEndpointId: node.first("clientVpnEndpointId", false, x => x.content ?? ''),
    Status: node.first("status", false, AssociationStatus_Parse),
    SecurityGroups: node.getList("securityGroups", "item").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CoipPool {
  PoolId?: string | null;
  PoolCidrs: string[];
  LocalGatewayRouteTableId?: string | null;
  Tags: Tag[];
  PoolArn?: string | null;
}
function CoipPool_Parse(node: xmlP.XmlNode): CoipPool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    PoolCidrs: node.getList("poolCidrSet", "item").map(x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PoolArn: node.first("poolArn", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface ConversionTask {
  ConversionTaskId?: string | null;
  ExpirationTime?: string | null;
  ImportInstance?: ImportInstanceTaskDetails | null;
  ImportVolume?: ImportVolumeTaskDetails | null;
  State?: ConversionTaskState | null;
  StatusMessage?: string | null;
  Tags: Tag[];
}
function ConversionTask_Parse(node: xmlP.XmlNode): ConversionTask {
  return {
    ConversionTaskId: node.first("conversionTaskId", false, x => x.content ?? ''),
    ExpirationTime: node.first("expirationTime", false, x => x.content ?? ''),
    ImportInstance: node.first("importInstance", false, ImportInstanceTaskDetails_Parse),
    ImportVolume: node.first("importVolume", false, ImportVolumeTaskDetails_Parse),
    State: node.first("state", false, x => (x.content ?? '') as ConversionTaskState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ImportInstanceTaskDetails {
  Description?: string | null;
  InstanceId?: string | null;
  Platform?: PlatformValues | null;
  Volumes: ImportInstanceVolumeDetailItem[];
}
function ImportInstanceTaskDetails_Parse(node: xmlP.XmlNode): ImportInstanceTaskDetails {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => (x.content ?? '') as PlatformValues),
    Volumes: node.getList("volumes", "item").map(ImportInstanceVolumeDetailItem_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface ImportInstanceVolumeDetailItem {
  AvailabilityZone?: string | null;
  BytesConverted?: number | null;
  Description?: string | null;
  Image?: DiskImageDescription | null;
  Status?: string | null;
  StatusMessage?: string | null;
  Volume?: DiskImageVolumeDescription | null;
}
function ImportInstanceVolumeDetailItem_Parse(node: xmlP.XmlNode): ImportInstanceVolumeDetailItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    BytesConverted: node.first("bytesConverted", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Image: node.first("image", false, DiskImageDescription_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Volume: node.first("volume", false, DiskImageVolumeDescription_Parse),
  };
}

// refs: 6 - tags: output, named, interface
export interface DiskImageDescription {
  Checksum?: string | null;
  Format?: DiskImageFormat | null;
  ImportManifestUrl?: string | null;
  Size?: number | null;
}
function DiskImageDescription_Parse(node: xmlP.XmlNode): DiskImageDescription {
  return {
    Checksum: node.first("checksum", false, x => x.content ?? ''),
    Format: node.first("format", false, x => (x.content ?? '') as DiskImageFormat),
    ImportManifestUrl: node.first("importManifestUrl", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 6 - tags: output, named, interface
export interface DiskImageVolumeDescription {
  Id?: string | null;
  Size?: number | null;
}
function DiskImageVolumeDescription_Parse(node: xmlP.XmlNode): DiskImageVolumeDescription {
  return {
    Id: node.first("id", false, x => x.content ?? ''),
    Size: node.first("size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface ImportVolumeTaskDetails {
  AvailabilityZone?: string | null;
  BytesConverted?: number | null;
  Description?: string | null;
  Image?: DiskImageDescription | null;
  Volume?: DiskImageVolumeDescription | null;
}
function ImportVolumeTaskDetails_Parse(node: xmlP.XmlNode): ImportVolumeTaskDetails {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    BytesConverted: node.first("bytesConverted", false, x => parseInt(x.content ?? '0')),
    Description: node.first("description", false, x => x.content ?? ''),
    Image: node.first("image", false, DiskImageDescription_Parse),
    Volume: node.first("volume", false, DiskImageVolumeDescription_Parse),
  };
}

// refs: 3 - tags: output, named, enum
export type ConversionTaskState =
| "active"
| "cancelling"
| "cancelled"
| "completed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ElasticGpus {
  ElasticGpuId?: string | null;
  AvailabilityZone?: string | null;
  ElasticGpuType?: string | null;
  ElasticGpuHealth?: ElasticGpuHealth | null;
  ElasticGpuState?: ElasticGpuState | null;
  InstanceId?: string | null;
  Tags: Tag[];
}
function ElasticGpus_Parse(node: xmlP.XmlNode): ElasticGpus {
  return {
    ElasticGpuId: node.first("elasticGpuId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    ElasticGpuType: node.first("elasticGpuType", false, x => x.content ?? ''),
    ElasticGpuHealth: node.first("elasticGpuHealth", false, ElasticGpuHealth_Parse),
    ElasticGpuState: node.first("elasticGpuState", false, x => (x.content ?? '') as ElasticGpuState),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ElasticGpuHealth {
  Status?: ElasticGpuStatus | null;
}
function ElasticGpuHealth_Parse(node: xmlP.XmlNode): ElasticGpuHealth {
  return {
    Status: node.first("status", false, x => (x.content ?? '') as ElasticGpuStatus),
  };
}

// refs: 1 - tags: output, named, enum
export type ElasticGpuStatus =
| "OK"
| "IMPAIRED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type ElasticGpuState =
| "ATTACHED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ExportImageTask {
  Description?: string | null;
  ExportImageTaskId?: string | null;
  ImageId?: string | null;
  Progress?: string | null;
  S3ExportLocation?: ExportTaskS3Location | null;
  Status?: string | null;
  StatusMessage?: string | null;
  Tags: Tag[];
}
function ExportImageTask_Parse(node: xmlP.XmlNode): ExportImageTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ExportImageTaskId: node.first("exportImageTaskId", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    S3ExportLocation: node.first("s3ExportLocation", false, ExportTaskS3Location_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ExportTaskS3Location {
  S3Bucket?: string | null;
  S3Prefix?: string | null;
}
function ExportTaskS3Location_Parse(node: xmlP.XmlNode): ExportTaskS3Location {
  return {
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Prefix: node.first("s3Prefix", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DescribeFastSnapshotRestoreSuccessItem {
  SnapshotId?: string | null;
  AvailabilityZone?: string | null;
  State?: FastSnapshotRestoreStateCode | null;
  StateTransitionReason?: string | null;
  OwnerId?: string | null;
  OwnerAlias?: string | null;
  EnablingTime?: Date | number | null;
  OptimizingTime?: Date | number | null;
  EnabledTime?: Date | number | null;
  DisablingTime?: Date | number | null;
  DisabledTime?: Date | number | null;
}
function DescribeFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): DescribeFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 3 - tags: output, named, enum
export type FastSnapshotRestoreStateCode =
| "enabling"
| "optimizing"
| "enabled"
| "disabling"
| "disabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface HistoryRecordEntry {
  EventInformation?: EventInformation | null;
  EventType?: FleetEventType | null;
  Timestamp?: Date | number | null;
}
function HistoryRecordEntry_Parse(node: xmlP.XmlNode): HistoryRecordEntry {
  return {
    EventInformation: node.first("eventInformation", false, EventInformation_Parse),
    EventType: node.first("eventType", false, x => (x.content ?? '') as FleetEventType),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface EventInformation {
  EventDescription?: string | null;
  EventSubType?: string | null;
  InstanceId?: string | null;
}
function EventInformation_Parse(node: xmlP.XmlNode): EventInformation {
  return {
    EventDescription: node.first("eventDescription", false, x => x.content ?? ''),
    EventSubType: node.first("eventSubType", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ActiveInstance {
  InstanceId?: string | null;
  InstanceType?: string | null;
  SpotInstanceRequestId?: string | null;
  InstanceHealth?: InstanceHealthStatus | null;
}
function ActiveInstance_Parse(node: xmlP.XmlNode): ActiveInstance {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    InstanceHealth: node.first("instanceHealth", false, x => (x.content ?? '') as InstanceHealthStatus),
  };
}

// refs: 2 - tags: output, named, enum
export type InstanceHealthStatus =
| "healthy"
| "unhealthy"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface FleetData {
  ActivityStatus?: FleetActivityStatus | null;
  CreateTime?: Date | number | null;
  FleetId?: string | null;
  FleetState?: FleetStateCode | null;
  ClientToken?: string | null;
  ExcessCapacityTerminationPolicy?: FleetExcessCapacityTerminationPolicy | null;
  FulfilledCapacity?: number | null;
  FulfilledOnDemandCapacity?: number | null;
  LaunchTemplateConfigs: FleetLaunchTemplateConfig[];
  TargetCapacitySpecification?: TargetCapacitySpecification | null;
  TerminateInstancesWithExpiration?: boolean | null;
  Type?: FleetType | null;
  ValidFrom?: Date | number | null;
  ValidUntil?: Date | number | null;
  ReplaceUnhealthyInstances?: boolean | null;
  SpotOptions?: SpotOptions | null;
  OnDemandOptions?: OnDemandOptions | null;
  Tags: Tag[];
  Errors: DescribeFleetError[];
  Instances: DescribeFleetsInstances[];
}
function FleetData_Parse(node: xmlP.XmlNode): FleetData {
  return {
    ActivityStatus: node.first("activityStatus", false, x => (x.content ?? '') as FleetActivityStatus),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    FleetId: node.first("fleetId", false, x => x.content ?? ''),
    FleetState: node.first("fleetState", false, x => (x.content ?? '') as FleetStateCode),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    ExcessCapacityTerminationPolicy: node.first("excessCapacityTerminationPolicy", false, x => (x.content ?? '') as FleetExcessCapacityTerminationPolicy),
    FulfilledCapacity: node.first("fulfilledCapacity", false, x => parseFloat(x.content ?? '0')),
    FulfilledOnDemandCapacity: node.first("fulfilledOnDemandCapacity", false, x => parseFloat(x.content ?? '0')),
    LaunchTemplateConfigs: node.getList("launchTemplateConfigs", "item").map(FleetLaunchTemplateConfig_Parse),
    TargetCapacitySpecification: node.first("targetCapacitySpecification", false, TargetCapacitySpecification_Parse),
    TerminateInstancesWithExpiration: node.first("terminateInstancesWithExpiration", false, x => x.content === 'true'),
    Type: node.first("type", false, x => (x.content ?? '') as FleetType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    ReplaceUnhealthyInstances: node.first("replaceUnhealthyInstances", false, x => x.content === 'true'),
    SpotOptions: node.first("spotOptions", false, SpotOptions_Parse),
    OnDemandOptions: node.first("onDemandOptions", false, OnDemandOptions_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Errors: node.getList("errorSet", "item").map(DescribeFleetError_Parse),
    Instances: node.getList("fleetInstanceSet", "item").map(DescribeFleetsInstances_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type FleetActivityStatus =
| "error"
| "pending_fulfillment"
| "pending_termination"
| "fulfilled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface FleetLaunchTemplateConfig {
  LaunchTemplateSpecification?: FleetLaunchTemplateSpecification | null;
  Overrides: FleetLaunchTemplateOverrides[];
}
function FleetLaunchTemplateConfig_Parse(node: xmlP.XmlNode): FleetLaunchTemplateConfig {
  return {
    LaunchTemplateSpecification: node.first("launchTemplateSpecification", false, FleetLaunchTemplateSpecification_Parse),
    Overrides: node.getList("overrides", "item").map(FleetLaunchTemplateOverrides_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetCapacitySpecification {
  TotalTargetCapacity?: number | null;
  OnDemandTargetCapacity?: number | null;
  SpotTargetCapacity?: number | null;
  DefaultTargetCapacityType?: DefaultTargetCapacityType | null;
}
function TargetCapacitySpecification_Parse(node: xmlP.XmlNode): TargetCapacitySpecification {
  return {
    TotalTargetCapacity: node.first("totalTargetCapacity", false, x => parseInt(x.content ?? '0')),
    OnDemandTargetCapacity: node.first("onDemandTargetCapacity", false, x => parseInt(x.content ?? '0')),
    SpotTargetCapacity: node.first("spotTargetCapacity", false, x => parseInt(x.content ?? '0')),
    DefaultTargetCapacityType: node.first("defaultTargetCapacityType", false, x => (x.content ?? '') as DefaultTargetCapacityType),
  };
}

// refs: 1 - tags: output, named, interface
export interface SpotOptions {
  AllocationStrategy?: SpotAllocationStrategy | null;
  InstanceInterruptionBehavior?: SpotInstanceInterruptionBehavior | null;
  InstancePoolsToUseCount?: number | null;
  SingleInstanceType?: boolean | null;
  SingleAvailabilityZone?: boolean | null;
  MinTargetCapacity?: number | null;
  MaxTotalPrice?: string | null;
}
function SpotOptions_Parse(node: xmlP.XmlNode): SpotOptions {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as SpotAllocationStrategy),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as SpotInstanceInterruptionBehavior),
    InstancePoolsToUseCount: node.first("instancePoolsToUseCount", false, x => parseInt(x.content ?? '0')),
    SingleInstanceType: node.first("singleInstanceType", false, x => x.content === 'true'),
    SingleAvailabilityZone: node.first("singleAvailabilityZone", false, x => x.content === 'true'),
    MinTargetCapacity: node.first("minTargetCapacity", false, x => parseInt(x.content ?? '0')),
    MaxTotalPrice: node.first("maxTotalPrice", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface OnDemandOptions {
  AllocationStrategy?: FleetOnDemandAllocationStrategy | null;
  CapacityReservationOptions?: CapacityReservationOptions | null;
  SingleInstanceType?: boolean | null;
  SingleAvailabilityZone?: boolean | null;
  MinTargetCapacity?: number | null;
  MaxTotalPrice?: string | null;
}
function OnDemandOptions_Parse(node: xmlP.XmlNode): OnDemandOptions {
  return {
    AllocationStrategy: node.first("allocationStrategy", false, x => (x.content ?? '') as FleetOnDemandAllocationStrategy),
    CapacityReservationOptions: node.first("capacityReservationOptions", false, CapacityReservationOptions_Parse),
    SingleInstanceType: node.first("singleInstanceType", false, x => x.content === 'true'),
    SingleAvailabilityZone: node.first("singleAvailabilityZone", false, x => x.content === 'true'),
    MinTargetCapacity: node.first("minTargetCapacity", false, x => parseInt(x.content ?? '0')),
    MaxTotalPrice: node.first("maxTotalPrice", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CapacityReservationOptions {
  UsageStrategy?: FleetCapacityReservationUsageStrategy | null;
}
function CapacityReservationOptions_Parse(node: xmlP.XmlNode): CapacityReservationOptions {
  return {
    UsageStrategy: node.first("usageStrategy", false, x => (x.content ?? '') as FleetCapacityReservationUsageStrategy),
  };
}

// refs: 1 - tags: output, named, interface
export interface DescribeFleetError {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse | null;
  Lifecycle?: InstanceLifecycle | null;
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function DescribeFleetError_Parse(node: xmlP.XmlNode): DescribeFleetError {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as InstanceLifecycle),
    ErrorCode: node.first("errorCode", false, x => x.content ?? ''),
    ErrorMessage: node.first("errorMessage", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DescribeFleetsInstances {
  LaunchTemplateAndOverrides?: LaunchTemplateAndOverridesResponse | null;
  Lifecycle?: InstanceLifecycle | null;
  InstanceIds: string[];
  InstanceType?: InstanceType | null;
  Platform?: PlatformValues | null;
}
function DescribeFleetsInstances_Parse(node: xmlP.XmlNode): DescribeFleetsInstances {
  return {
    LaunchTemplateAndOverrides: node.first("launchTemplateAndOverrides", false, LaunchTemplateAndOverridesResponse_Parse),
    Lifecycle: node.first("lifecycle", false, x => (x.content ?? '') as InstanceLifecycle),
    InstanceIds: node.getList("instanceIds", "item").map(x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    Platform: node.first("platform", false, x => (x.content ?? '') as PlatformValues),
  };
}

// refs: 1 - tags: output, named, interface
export interface FlowLog {
  CreationTime?: Date | number | null;
  DeliverLogsErrorMessage?: string | null;
  DeliverLogsPermissionArn?: string | null;
  DeliverLogsStatus?: string | null;
  FlowLogId?: string | null;
  FlowLogStatus?: string | null;
  LogGroupName?: string | null;
  ResourceId?: string | null;
  TrafficType?: TrafficType | null;
  LogDestinationType?: LogDestinationType | null;
  LogDestination?: string | null;
  LogFormat?: string | null;
  Tags: Tag[];
  MaxAggregationInterval?: number | null;
}
function FlowLog_Parse(node: xmlP.XmlNode): FlowLog {
  return {
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    DeliverLogsErrorMessage: node.first("deliverLogsErrorMessage", false, x => x.content ?? ''),
    DeliverLogsPermissionArn: node.first("deliverLogsPermissionArn", false, x => x.content ?? ''),
    DeliverLogsStatus: node.first("deliverLogsStatus", false, x => x.content ?? ''),
    FlowLogId: node.first("flowLogId", false, x => x.content ?? ''),
    FlowLogStatus: node.first("flowLogStatus", false, x => x.content ?? ''),
    LogGroupName: node.first("logGroupName", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    TrafficType: node.first("trafficType", false, x => (x.content ?? '') as TrafficType),
    LogDestinationType: node.first("logDestinationType", false, x => (x.content ?? '') as LogDestinationType),
    LogDestination: node.first("logDestination", false, x => x.content ?? ''),
    LogFormat: node.first("logFormat", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    MaxAggregationInterval: node.first("maxAggregationInterval", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, interface
export interface FpgaImageAttribute {
  FpgaImageId?: string | null;
  Name?: string | null;
  Description?: string | null;
  LoadPermissions: LoadPermission[];
  ProductCodes: ProductCode[];
}
function FpgaImageAttribute_Parse(node: xmlP.XmlNode): FpgaImageAttribute {
  return {
    FpgaImageId: node.first("fpgaImageId", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    LoadPermissions: node.getList("loadPermissions", "item").map(LoadPermission_Parse),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface LoadPermission {
  UserId?: string | null;
  Group?: PermissionGroup | null;
}
function LoadPermission_Parse(node: xmlP.XmlNode): LoadPermission {
  return {
    UserId: node.first("userId", false, x => x.content ?? ''),
    Group: node.first("group", false, x => (x.content ?? '') as PermissionGroup),
  };
}

// refs: 10 - tags: output, named, interface
export interface ProductCode {
  ProductCodeId?: string | null;
  ProductCodeType?: ProductCodeValues | null;
}
function ProductCode_Parse(node: xmlP.XmlNode): ProductCode {
  return {
    ProductCodeId: node.first("productCode", false, x => x.content ?? ''),
    ProductCodeType: node.first("type", false, x => (x.content ?? '') as ProductCodeValues),
  };
}

// refs: 10 - tags: output, named, enum
export type ProductCodeValues =
| "devpay"
| "marketplace"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface FpgaImage {
  FpgaImageId?: string | null;
  FpgaImageGlobalId?: string | null;
  Name?: string | null;
  Description?: string | null;
  ShellVersion?: string | null;
  PciId?: PciId | null;
  State?: FpgaImageState | null;
  CreateTime?: Date | number | null;
  UpdateTime?: Date | number | null;
  OwnerId?: string | null;
  OwnerAlias?: string | null;
  ProductCodes: ProductCode[];
  Tags: Tag[];
  Public?: boolean | null;
  DataRetentionSupport?: boolean | null;
}
function FpgaImage_Parse(node: xmlP.XmlNode): FpgaImage {
  return {
    FpgaImageId: node.first("fpgaImageId", false, x => x.content ?? ''),
    FpgaImageGlobalId: node.first("fpgaImageGlobalId", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    ShellVersion: node.first("shellVersion", false, x => x.content ?? ''),
    PciId: node.first("pciId", false, PciId_Parse),
    State: node.first("state", false, FpgaImageState_Parse),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    Tags: node.getList("tags", "item").map(Tag_Parse),
    Public: node.first("public", false, x => x.content === 'true'),
    DataRetentionSupport: node.first("dataRetentionSupport", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface PciId {
  DeviceId?: string | null;
  VendorId?: string | null;
  SubsystemId?: string | null;
  SubsystemVendorId?: string | null;
}
function PciId_Parse(node: xmlP.XmlNode): PciId {
  return node.strings({
    optional: {"DeviceId":true,"VendorId":true,"SubsystemId":true,"SubsystemVendorId":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface FpgaImageState {
  Code?: FpgaImageStateCode | null;
  Message?: string | null;
}
function FpgaImageState_Parse(node: xmlP.XmlNode): FpgaImageState {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as FpgaImageStateCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type FpgaImageStateCode =
| "pending"
| "failed"
| "available"
| "unavailable"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface HostOffering {
  CurrencyCode?: CurrencyCodeValues | null;
  Duration?: number | null;
  HourlyPrice?: string | null;
  InstanceFamily?: string | null;
  OfferingId?: string | null;
  PaymentOption?: PaymentOption | null;
  UpfrontPrice?: string | null;
}
function HostOffering_Parse(node: xmlP.XmlNode): HostOffering {
  return {
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as PaymentOption),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type PaymentOption =
| "AllUpfront"
| "PartialUpfront"
| "NoUpfront"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface HostReservation {
  Count?: number | null;
  CurrencyCode?: CurrencyCodeValues | null;
  Duration?: number | null;
  End?: Date | number | null;
  HostIdSet: string[];
  HostReservationId?: string | null;
  HourlyPrice?: string | null;
  InstanceFamily?: string | null;
  OfferingId?: string | null;
  PaymentOption?: PaymentOption | null;
  Start?: Date | number | null;
  State?: ReservationState | null;
  UpfrontPrice?: string | null;
  Tags: Tag[];
}
function HostReservation_Parse(node: xmlP.XmlNode): HostReservation {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    End: node.first("end", false, x => xmlP.parseTimestamp(x.content)),
    HostIdSet: node.getList("hostIdSet", "item").map(x => x.content ?? ''),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as PaymentOption),
    Start: node.first("start", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as ReservationState),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ReservationState =
| "payment-pending"
| "payment-failed"
| "active"
| "retired"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Host {
  AutoPlacement?: AutoPlacement | null;
  AvailabilityZone?: string | null;
  AvailableCapacity?: AvailableCapacity | null;
  ClientToken?: string | null;
  HostId?: string | null;
  HostProperties?: HostProperties | null;
  HostReservationId?: string | null;
  Instances: HostInstance[];
  State?: AllocationState | null;
  AllocationTime?: Date | number | null;
  ReleaseTime?: Date | number | null;
  Tags: Tag[];
  HostRecovery?: HostRecovery | null;
  AllowsMultipleInstanceTypes?: AllowsMultipleInstanceTypes | null;
  OwnerId?: string | null;
  AvailabilityZoneId?: string | null;
  MemberOfServiceLinkedResourceGroup?: boolean | null;
}
function Host_Parse(node: xmlP.XmlNode): Host {
  return {
    AutoPlacement: node.first("autoPlacement", false, x => (x.content ?? '') as AutoPlacement),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailableCapacity: node.first("availableCapacity", false, AvailableCapacity_Parse),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    HostId: node.first("hostId", false, x => x.content ?? ''),
    HostProperties: node.first("hostProperties", false, HostProperties_Parse),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    Instances: node.getList("instances", "item").map(HostInstance_Parse),
    State: node.first("state", false, x => (x.content ?? '') as AllocationState),
    AllocationTime: node.first("allocationTime", false, x => xmlP.parseTimestamp(x.content)),
    ReleaseTime: node.first("releaseTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    HostRecovery: node.first("hostRecovery", false, x => (x.content ?? '') as HostRecovery),
    AllowsMultipleInstanceTypes: node.first("allowsMultipleInstanceTypes", false, x => (x.content ?? '') as AllowsMultipleInstanceTypes),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    AvailabilityZoneId: node.first("availabilityZoneId", false, x => x.content ?? ''),
    MemberOfServiceLinkedResourceGroup: node.first("memberOfServiceLinkedResourceGroup", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface AvailableCapacity {
  AvailableInstanceCapacity: InstanceCapacity[];
  AvailableVCpus?: number | null;
}
function AvailableCapacity_Parse(node: xmlP.XmlNode): AvailableCapacity {
  return {
    AvailableInstanceCapacity: node.getList("availableInstanceCapacity", "item").map(InstanceCapacity_Parse),
    AvailableVCpus: node.first("availableVCpus", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceCapacity {
  AvailableCapacity?: number | null;
  InstanceType?: string | null;
  TotalCapacity?: number | null;
}
function InstanceCapacity_Parse(node: xmlP.XmlNode): InstanceCapacity {
  return {
    AvailableCapacity: node.first("availableCapacity", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    TotalCapacity: node.first("totalCapacity", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface HostProperties {
  Cores?: number | null;
  InstanceType?: string | null;
  InstanceFamily?: string | null;
  Sockets?: number | null;
  TotalVCpus?: number | null;
}
function HostProperties_Parse(node: xmlP.XmlNode): HostProperties {
  return {
    Cores: node.first("cores", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    Sockets: node.first("sockets", false, x => parseInt(x.content ?? '0')),
    TotalVCpus: node.first("totalVCpus", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface HostInstance {
  InstanceId?: string | null;
  InstanceType?: string | null;
  OwnerId?: string | null;
}
function HostInstance_Parse(node: xmlP.XmlNode): HostInstance {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type AllocationState =
| "available"
| "under-assessment"
| "permanent-failure"
| "released"
| "released-permanent-failure"
| "pending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type AllowsMultipleInstanceTypes =
| "on"
| "off"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Image {
  Architecture?: ArchitectureValues | null;
  CreationDate?: string | null;
  ImageId?: string | null;
  ImageLocation?: string | null;
  ImageType?: ImageTypeValues | null;
  Public?: boolean | null;
  KernelId?: string | null;
  OwnerId?: string | null;
  Platform?: PlatformValues | null;
  PlatformDetails?: string | null;
  UsageOperation?: string | null;
  ProductCodes: ProductCode[];
  RamdiskId?: string | null;
  State?: ImageState | null;
  BlockDeviceMappings: BlockDeviceMapping[];
  Description?: string | null;
  EnaSupport?: boolean | null;
  Hypervisor?: HypervisorType | null;
  ImageOwnerAlias?: string | null;
  Name?: string | null;
  RootDeviceName?: string | null;
  RootDeviceType?: DeviceType | null;
  SriovNetSupport?: string | null;
  StateReason?: StateReason | null;
  Tags: Tag[];
  VirtualizationType?: VirtualizationType | null;
}
function Image_Parse(node: xmlP.XmlNode): Image {
  return {
    Architecture: node.first("architecture", false, x => (x.content ?? '') as ArchitectureValues),
    CreationDate: node.first("creationDate", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    ImageLocation: node.first("imageLocation", false, x => x.content ?? ''),
    ImageType: node.first("imageType", false, x => (x.content ?? '') as ImageTypeValues),
    Public: node.first("isPublic", false, x => x.content === 'true'),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    OwnerId: node.first("imageOwnerId", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => (x.content ?? '') as PlatformValues),
    PlatformDetails: node.first("platformDetails", false, x => x.content ?? ''),
    UsageOperation: node.first("usageOperation", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    State: node.first("imageState", false, x => (x.content ?? '') as ImageState),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
    EnaSupport: node.first("enaSupport", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as HypervisorType),
    ImageOwnerAlias: node.first("imageOwnerAlias", false, x => x.content ?? ''),
    Name: node.first("name", false, x => x.content ?? ''),
    RootDeviceName: node.first("rootDeviceName", false, x => x.content ?? ''),
    RootDeviceType: node.first("rootDeviceType", false, x => (x.content ?? '') as DeviceType),
    SriovNetSupport: node.first("sriovNetSupport", false, x => x.content ?? ''),
    StateReason: node.first("stateReason", false, StateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VirtualizationType: node.first("virtualizationType", false, x => (x.content ?? '') as VirtualizationType),
  };
}

// refs: 1 - tags: output, named, enum
export type ImageTypeValues =
| "machine"
| "kernel"
| "ramdisk"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type ImageState =
| "pending"
| "available"
| "invalid"
| "deregistered"
| "transient"
| "failed"
| "error"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type HypervisorType =
| "ovm"
| "xen"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type DeviceType =
| "ebs"
| "instance-store"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface StateReason {
  Code?: string | null;
  Message?: string | null;
}
function StateReason_Parse(node: xmlP.XmlNode): StateReason {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, enum
export type VirtualizationType =
| "hvm"
| "paravirtual"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ImportImageTask {
  Architecture?: string | null;
  Description?: string | null;
  Encrypted?: boolean | null;
  Hypervisor?: string | null;
  ImageId?: string | null;
  ImportTaskId?: string | null;
  KmsKeyId?: string | null;
  LicenseType?: string | null;
  Platform?: string | null;
  Progress?: string | null;
  SnapshotDetails: SnapshotDetail[];
  Status?: string | null;
  StatusMessage?: string | null;
  Tags: Tag[];
  LicenseSpecifications: ImportImageLicenseConfigurationResponse[];
}
function ImportImageTask_Parse(node: xmlP.XmlNode): ImportImageTask {
  return {
    Architecture: node.first("architecture", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => x.content ?? ''),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    ImportTaskId: node.first("importTaskId", false, x => x.content ?? ''),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    LicenseType: node.first("licenseType", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotDetails: node.getList("snapshotDetailSet", "item").map(SnapshotDetail_Parse),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    LicenseSpecifications: node.getList("licenseSpecifications", "item").map(ImportImageLicenseConfigurationResponse_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface SnapshotDetail {
  Description?: string | null;
  DeviceName?: string | null;
  DiskImageSize?: number | null;
  Format?: string | null;
  Progress?: string | null;
  SnapshotId?: string | null;
  Status?: string | null;
  StatusMessage?: string | null;
  Url?: string | null;
  UserBucket?: UserBucketDetails | null;
}
function SnapshotDetail_Parse(node: xmlP.XmlNode): SnapshotDetail {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    DiskImageSize: node.first("diskImageSize", false, x => parseFloat(x.content ?? '0')),
    Format: node.first("format", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Url: node.first("url", false, x => x.content ?? ''),
    UserBucket: node.first("userBucket", false, UserBucketDetails_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface UserBucketDetails {
  S3Bucket?: string | null;
  S3Key?: string | null;
}
function UserBucketDetails_Parse(node: xmlP.XmlNode): UserBucketDetails {
  return {
    S3Bucket: node.first("s3Bucket", false, x => x.content ?? ''),
    S3Key: node.first("s3Key", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ImportImageLicenseConfigurationResponse {
  LicenseConfigurationArn?: string | null;
}
function ImportImageLicenseConfigurationResponse_Parse(node: xmlP.XmlNode): ImportImageLicenseConfigurationResponse {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ImportSnapshotTask {
  Description?: string | null;
  ImportTaskId?: string | null;
  SnapshotTaskDetail?: SnapshotTaskDetail | null;
  Tags: Tag[];
}
function ImportSnapshotTask_Parse(node: xmlP.XmlNode): ImportSnapshotTask {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    ImportTaskId: node.first("importTaskId", false, x => x.content ?? ''),
    SnapshotTaskDetail: node.first("snapshotTaskDetail", false, SnapshotTaskDetail_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface SnapshotTaskDetail {
  Description?: string | null;
  DiskImageSize?: number | null;
  Encrypted?: boolean | null;
  Format?: string | null;
  KmsKeyId?: string | null;
  Progress?: string | null;
  SnapshotId?: string | null;
  Status?: string | null;
  StatusMessage?: string | null;
  Url?: string | null;
  UserBucket?: UserBucketDetails | null;
}
function SnapshotTaskDetail_Parse(node: xmlP.XmlNode): SnapshotTaskDetail {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    DiskImageSize: node.first("diskImageSize", false, x => parseFloat(x.content ?? '0')),
    Encrypted: node.first("encrypted", false, x => x.content === 'true'),
    Format: node.first("format", false, x => x.content ?? ''),
    KmsKeyId: node.first("kmsKeyId", false, x => x.content ?? ''),
    Progress: node.first("progress", false, x => x.content ?? ''),
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    Url: node.first("url", false, x => x.content ?? ''),
    UserBucket: node.first("userBucket", false, UserBucketDetails_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface InstanceBlockDeviceMapping {
  DeviceName?: string | null;
  Ebs?: EbsInstanceBlockDevice | null;
}
function InstanceBlockDeviceMapping_Parse(node: xmlP.XmlNode): InstanceBlockDeviceMapping {
  return {
    DeviceName: node.first("deviceName", false, x => x.content ?? ''),
    Ebs: node.first("ebs", false, EbsInstanceBlockDevice_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface EbsInstanceBlockDevice {
  AttachTime?: Date | number | null;
  DeleteOnTermination?: boolean | null;
  Status?: AttachmentStatus | null;
  VolumeId?: string | null;
}
function EbsInstanceBlockDevice_Parse(node: xmlP.XmlNode): EbsInstanceBlockDevice {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as AttachmentStatus),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceCreditSpecification {
  InstanceId?: string | null;
  CpuCredits?: string | null;
}
function InstanceCreditSpecification_Parse(node: xmlP.XmlNode): InstanceCreditSpecification {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceStatus {
  AvailabilityZone?: string | null;
  OutpostArn?: string | null;
  Events: InstanceStatusEvent[];
  InstanceId?: string | null;
  InstanceState?: InstanceState | null;
  InstanceStatus?: InstanceStatusSummary | null;
  SystemStatus?: InstanceStatusSummary | null;
}
function InstanceStatus_Parse(node: xmlP.XmlNode): InstanceStatus {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Events: node.getList("eventsSet", "item").map(InstanceStatusEvent_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceState: node.first("instanceState", false, InstanceState_Parse),
    InstanceStatus: node.first("instanceStatus", false, InstanceStatusSummary_Parse),
    SystemStatus: node.first("systemStatus", false, InstanceStatusSummary_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceStatusEvent {
  InstanceEventId?: string | null;
  Code?: EventCode | null;
  Description?: string | null;
  NotAfter?: Date | number | null;
  NotBefore?: Date | number | null;
  NotBeforeDeadline?: Date | number | null;
}
function InstanceStatusEvent_Parse(node: xmlP.XmlNode): InstanceStatusEvent {
  return {
    InstanceEventId: node.first("instanceEventId", false, x => x.content ?? ''),
    Code: node.first("code", false, x => (x.content ?? '') as EventCode),
    Description: node.first("description", false, x => x.content ?? ''),
    NotAfter: node.first("notAfter", false, x => xmlP.parseTimestamp(x.content)),
    NotBefore: node.first("notBefore", false, x => xmlP.parseTimestamp(x.content)),
    NotBeforeDeadline: node.first("notBeforeDeadline", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, enum
export type EventCode =
| "instance-reboot"
| "system-reboot"
| "system-maintenance"
| "instance-retirement"
| "instance-stop"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: output, named, interface
export interface InstanceState {
  Code?: number | null;
  Name?: InstanceStateName | null;
}
function InstanceState_Parse(node: xmlP.XmlNode): InstanceState {
  return {
    Code: node.first("code", false, x => parseInt(x.content ?? '0')),
    Name: node.first("name", false, x => (x.content ?? '') as InstanceStateName),
  };
}

// refs: 9 - tags: output, named, enum
export type InstanceStateName =
| "pending"
| "running"
| "shutting-down"
| "terminated"
| "stopping"
| "stopped"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface InstanceStatusSummary {
  Details: InstanceStatusDetails[];
  Status?: SummaryStatus | null;
}
function InstanceStatusSummary_Parse(node: xmlP.XmlNode): InstanceStatusSummary {
  return {
    Details: node.getList("details", "item").map(InstanceStatusDetails_Parse),
    Status: node.first("status", false, x => (x.content ?? '') as SummaryStatus),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceStatusDetails {
  ImpairedSince?: Date | number | null;
  Name?: StatusName | null;
  Status?: StatusType | null;
}
function InstanceStatusDetails_Parse(node: xmlP.XmlNode): InstanceStatusDetails {
  return {
    ImpairedSince: node.first("impairedSince", false, x => xmlP.parseTimestamp(x.content)),
    Name: node.first("name", false, x => (x.content ?? '') as StatusName),
    Status: node.first("status", false, x => (x.content ?? '') as StatusType),
  };
}

// refs: 2 - tags: output, named, enum
export type StatusName =
| "reachability"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type StatusType =
| "passed"
| "failed"
| "insufficient-data"
| "initializing"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type SummaryStatus =
| "ok"
| "impaired"
| "insufficient-data"
| "not-applicable"
| "initializing"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InstanceTypeOffering {
  InstanceType?: InstanceType | null;
  LocationType?: LocationType | null;
  Location?: string | null;
}
function InstanceTypeOffering_Parse(node: xmlP.XmlNode): InstanceTypeOffering {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    LocationType: node.first("locationType", false, x => (x.content ?? '') as LocationType),
    Location: node.first("location", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceTypeInfo {
  InstanceType?: InstanceType | null;
  CurrentGeneration?: boolean | null;
  FreeTierEligible?: boolean | null;
  SupportedUsageClasses: UsageClassType[];
  SupportedRootDeviceTypes: RootDeviceType[];
  SupportedVirtualizationTypes: VirtualizationType[];
  BareMetal?: boolean | null;
  Hypervisor?: InstanceTypeHypervisor | null;
  ProcessorInfo?: ProcessorInfo | null;
  VCpuInfo?: VCpuInfo | null;
  MemoryInfo?: MemoryInfo | null;
  InstanceStorageSupported?: boolean | null;
  InstanceStorageInfo?: InstanceStorageInfo | null;
  EbsInfo?: EbsInfo | null;
  NetworkInfo?: NetworkInfo | null;
  GpuInfo?: GpuInfo | null;
  FpgaInfo?: FpgaInfo | null;
  PlacementGroupInfo?: PlacementGroupInfo | null;
  InferenceAcceleratorInfo?: InferenceAcceleratorInfo | null;
  HibernationSupported?: boolean | null;
  BurstablePerformanceSupported?: boolean | null;
  DedicatedHostsSupported?: boolean | null;
  AutoRecoverySupported?: boolean | null;
}
function InstanceTypeInfo_Parse(node: xmlP.XmlNode): InstanceTypeInfo {
  return {
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    CurrentGeneration: node.first("currentGeneration", false, x => x.content === 'true'),
    FreeTierEligible: node.first("freeTierEligible", false, x => x.content === 'true'),
    SupportedUsageClasses: node.getList("supportedUsageClasses", "item").map(x => (x.content ?? '') as UsageClassType),
    SupportedRootDeviceTypes: node.getList("supportedRootDeviceTypes", "item").map(x => (x.content ?? '') as RootDeviceType),
    SupportedVirtualizationTypes: node.getList("supportedVirtualizationTypes", "item").map(x => (x.content ?? '') as VirtualizationType),
    BareMetal: node.first("bareMetal", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as InstanceTypeHypervisor),
    ProcessorInfo: node.first("processorInfo", false, ProcessorInfo_Parse),
    VCpuInfo: node.first("vCpuInfo", false, VCpuInfo_Parse),
    MemoryInfo: node.first("memoryInfo", false, MemoryInfo_Parse),
    InstanceStorageSupported: node.first("instanceStorageSupported", false, x => x.content === 'true'),
    InstanceStorageInfo: node.first("instanceStorageInfo", false, InstanceStorageInfo_Parse),
    EbsInfo: node.first("ebsInfo", false, EbsInfo_Parse),
    NetworkInfo: node.first("networkInfo", false, NetworkInfo_Parse),
    GpuInfo: node.first("gpuInfo", false, GpuInfo_Parse),
    FpgaInfo: node.first("fpgaInfo", false, FpgaInfo_Parse),
    PlacementGroupInfo: node.first("placementGroupInfo", false, PlacementGroupInfo_Parse),
    InferenceAcceleratorInfo: node.first("inferenceAcceleratorInfo", false, InferenceAcceleratorInfo_Parse),
    HibernationSupported: node.first("hibernationSupported", false, x => x.content === 'true'),
    BurstablePerformanceSupported: node.first("burstablePerformanceSupported", false, x => x.content === 'true'),
    DedicatedHostsSupported: node.first("dedicatedHostsSupported", false, x => x.content === 'true'),
    AutoRecoverySupported: node.first("autoRecoverySupported", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, enum
export type UsageClassType =
| "spot"
| "on-demand"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type RootDeviceType =
| "ebs"
| "instance-store"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type InstanceTypeHypervisor =
| "nitro"
| "xen"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ProcessorInfo {
  SupportedArchitectures: ArchitectureType[];
  SustainedClockSpeedInGhz?: number | null;
}
function ProcessorInfo_Parse(node: xmlP.XmlNode): ProcessorInfo {
  return {
    SupportedArchitectures: node.getList("supportedArchitectures", "item").map(x => (x.content ?? '') as ArchitectureType),
    SustainedClockSpeedInGhz: node.first("sustainedClockSpeedInGhz", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, enum
export type ArchitectureType =
| "i386"
| "x86_64"
| "arm64"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface VCpuInfo {
  DefaultVCpus?: number | null;
  DefaultCores?: number | null;
  DefaultThreadsPerCore?: number | null;
  ValidCores: number[];
  ValidThreadsPerCore: number[];
}
function VCpuInfo_Parse(node: xmlP.XmlNode): VCpuInfo {
  return {
    DefaultVCpus: node.first("defaultVCpus", false, x => parseInt(x.content ?? '0')),
    DefaultCores: node.first("defaultCores", false, x => parseInt(x.content ?? '0')),
    DefaultThreadsPerCore: node.first("defaultThreadsPerCore", false, x => parseInt(x.content ?? '0')),
    ValidCores: node.getList("validCores", "item").map(x => parseInt(x.content ?? '0')),
    ValidThreadsPerCore: node.getList("validThreadsPerCore", "item").map(x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface MemoryInfo {
  SizeInMiB?: number | null;
}
function MemoryInfo_Parse(node: xmlP.XmlNode): MemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceStorageInfo {
  TotalSizeInGB?: number | null;
  Disks: DiskInfo[];
  NvmeSupport?: EphemeralNvmeSupport | null;
}
function InstanceStorageInfo_Parse(node: xmlP.XmlNode): InstanceStorageInfo {
  return {
    TotalSizeInGB: node.first("totalSizeInGB", false, x => parseInt(x.content ?? '0')),
    Disks: node.getList("disks", "item").map(DiskInfo_Parse),
    NvmeSupport: node.first("nvmeSupport", false, x => (x.content ?? '') as EphemeralNvmeSupport),
  };
}

// refs: 1 - tags: output, named, interface
export interface DiskInfo {
  SizeInGB?: number | null;
  Count?: number | null;
  Type?: DiskType | null;
}
function DiskInfo_Parse(node: xmlP.XmlNode): DiskInfo {
  return {
    SizeInGB: node.first("sizeInGB", false, x => parseInt(x.content ?? '0')),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Type: node.first("type", false, x => (x.content ?? '') as DiskType),
  };
}

// refs: 1 - tags: output, named, enum
export type DiskType =
| "hdd"
| "ssd"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type EphemeralNvmeSupport =
| "unsupported"
| "supported"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface EbsInfo {
  EbsOptimizedSupport?: EbsOptimizedSupport | null;
  EncryptionSupport?: EbsEncryptionSupport | null;
  EbsOptimizedInfo?: EbsOptimizedInfo | null;
  NvmeSupport?: EbsNvmeSupport | null;
}
function EbsInfo_Parse(node: xmlP.XmlNode): EbsInfo {
  return {
    EbsOptimizedSupport: node.first("ebsOptimizedSupport", false, x => (x.content ?? '') as EbsOptimizedSupport),
    EncryptionSupport: node.first("encryptionSupport", false, x => (x.content ?? '') as EbsEncryptionSupport),
    EbsOptimizedInfo: node.first("ebsOptimizedInfo", false, EbsOptimizedInfo_Parse),
    NvmeSupport: node.first("nvmeSupport", false, x => (x.content ?? '') as EbsNvmeSupport),
  };
}

// refs: 1 - tags: output, named, enum
export type EbsOptimizedSupport =
| "unsupported"
| "supported"
| "default"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type EbsEncryptionSupport =
| "unsupported"
| "supported"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface EbsOptimizedInfo {
  BaselineBandwidthInMbps?: number | null;
  BaselineThroughputInMBps?: number | null;
  BaselineIops?: number | null;
  MaximumBandwidthInMbps?: number | null;
  MaximumThroughputInMBps?: number | null;
  MaximumIops?: number | null;
}
function EbsOptimizedInfo_Parse(node: xmlP.XmlNode): EbsOptimizedInfo {
  return {
    BaselineBandwidthInMbps: node.first("baselineBandwidthInMbps", false, x => parseInt(x.content ?? '0')),
    BaselineThroughputInMBps: node.first("baselineThroughputInMBps", false, x => parseFloat(x.content ?? '0')),
    BaselineIops: node.first("baselineIops", false, x => parseInt(x.content ?? '0')),
    MaximumBandwidthInMbps: node.first("maximumBandwidthInMbps", false, x => parseInt(x.content ?? '0')),
    MaximumThroughputInMBps: node.first("maximumThroughputInMBps", false, x => parseFloat(x.content ?? '0')),
    MaximumIops: node.first("maximumIops", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, enum
export type EbsNvmeSupport =
| "unsupported"
| "supported"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface NetworkInfo {
  NetworkPerformance?: string | null;
  MaximumNetworkInterfaces?: number | null;
  Ipv4AddressesPerInterface?: number | null;
  Ipv6AddressesPerInterface?: number | null;
  Ipv6Supported?: boolean | null;
  EnaSupport?: EnaSupport | null;
  EfaSupported?: boolean | null;
}
function NetworkInfo_Parse(node: xmlP.XmlNode): NetworkInfo {
  return {
    NetworkPerformance: node.first("networkPerformance", false, x => x.content ?? ''),
    MaximumNetworkInterfaces: node.first("maximumNetworkInterfaces", false, x => parseInt(x.content ?? '0')),
    Ipv4AddressesPerInterface: node.first("ipv4AddressesPerInterface", false, x => parseInt(x.content ?? '0')),
    Ipv6AddressesPerInterface: node.first("ipv6AddressesPerInterface", false, x => parseInt(x.content ?? '0')),
    Ipv6Supported: node.first("ipv6Supported", false, x => x.content === 'true'),
    EnaSupport: node.first("enaSupport", false, x => (x.content ?? '') as EnaSupport),
    EfaSupported: node.first("efaSupported", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, enum
export type EnaSupport =
| "unsupported"
| "supported"
| "required"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GpuInfo {
  Gpus: GpuDeviceInfo[];
  TotalGpuMemoryInMiB?: number | null;
}
function GpuInfo_Parse(node: xmlP.XmlNode): GpuInfo {
  return {
    Gpus: node.getList("gpus", "item").map(GpuDeviceInfo_Parse),
    TotalGpuMemoryInMiB: node.first("totalGpuMemoryInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface GpuDeviceInfo {
  Name?: string | null;
  Manufacturer?: string | null;
  Count?: number | null;
  MemoryInfo?: GpuDeviceMemoryInfo | null;
}
function GpuDeviceInfo_Parse(node: xmlP.XmlNode): GpuDeviceInfo {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    MemoryInfo: node.first("memoryInfo", false, GpuDeviceMemoryInfo_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface GpuDeviceMemoryInfo {
  SizeInMiB?: number | null;
}
function GpuDeviceMemoryInfo_Parse(node: xmlP.XmlNode): GpuDeviceMemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface FpgaInfo {
  Fpgas: FpgaDeviceInfo[];
  TotalFpgaMemoryInMiB?: number | null;
}
function FpgaInfo_Parse(node: xmlP.XmlNode): FpgaInfo {
  return {
    Fpgas: node.getList("fpgas", "item").map(FpgaDeviceInfo_Parse),
    TotalFpgaMemoryInMiB: node.first("totalFpgaMemoryInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface FpgaDeviceInfo {
  Name?: string | null;
  Manufacturer?: string | null;
  Count?: number | null;
  MemoryInfo?: FpgaDeviceMemoryInfo | null;
}
function FpgaDeviceInfo_Parse(node: xmlP.XmlNode): FpgaDeviceInfo {
  return {
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    MemoryInfo: node.first("memoryInfo", false, FpgaDeviceMemoryInfo_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface FpgaDeviceMemoryInfo {
  SizeInMiB?: number | null;
}
function FpgaDeviceMemoryInfo_Parse(node: xmlP.XmlNode): FpgaDeviceMemoryInfo {
  return {
    SizeInMiB: node.first("sizeInMiB", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface PlacementGroupInfo {
  SupportedStrategies: PlacementGroupStrategy[];
}
function PlacementGroupInfo_Parse(node: xmlP.XmlNode): PlacementGroupInfo {
  return {
    SupportedStrategies: node.getList("supportedStrategies", "item").map(x => (x.content ?? '') as PlacementGroupStrategy),
  };
}

// refs: 1 - tags: output, named, enum
export type PlacementGroupStrategy =
| "cluster"
| "partition"
| "spread"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InferenceAcceleratorInfo {
  Accelerators: InferenceDeviceInfo[];
}
function InferenceAcceleratorInfo_Parse(node: xmlP.XmlNode): InferenceAcceleratorInfo {
  return {
    Accelerators: node.getList("accelerators", "item").map(InferenceDeviceInfo_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface InferenceDeviceInfo {
  Count?: number | null;
  Name?: string | null;
  Manufacturer?: string | null;
}
function InferenceDeviceInfo_Parse(node: xmlP.XmlNode): InferenceDeviceInfo {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Name: node.first("name", false, x => x.content ?? ''),
    Manufacturer: node.first("manufacturer", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface Instance {
  AmiLaunchIndex?: number | null;
  ImageId?: string | null;
  InstanceId?: string | null;
  InstanceType?: InstanceType | null;
  KernelId?: string | null;
  KeyName?: string | null;
  LaunchTime?: Date | number | null;
  Monitoring?: Monitoring | null;
  Placement?: Placement | null;
  Platform?: PlatformValues | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
  ProductCodes: ProductCode[];
  PublicDnsName?: string | null;
  PublicIpAddress?: string | null;
  RamdiskId?: string | null;
  State?: InstanceState | null;
  StateTransitionReason?: string | null;
  SubnetId?: string | null;
  VpcId?: string | null;
  Architecture?: ArchitectureValues | null;
  BlockDeviceMappings: InstanceBlockDeviceMapping[];
  ClientToken?: string | null;
  EbsOptimized?: boolean | null;
  EnaSupport?: boolean | null;
  Hypervisor?: HypervisorType | null;
  IamInstanceProfile?: IamInstanceProfile | null;
  InstanceLifecycle?: InstanceLifecycleType | null;
  ElasticGpuAssociations: ElasticGpuAssociation[];
  ElasticInferenceAcceleratorAssociations: ElasticInferenceAcceleratorAssociation[];
  NetworkInterfaces: InstanceNetworkInterface[];
  OutpostArn?: string | null;
  RootDeviceName?: string | null;
  RootDeviceType?: DeviceType | null;
  SecurityGroups: GroupIdentifier[];
  SourceDestCheck?: boolean | null;
  SpotInstanceRequestId?: string | null;
  SriovNetSupport?: string | null;
  StateReason?: StateReason | null;
  Tags: Tag[];
  VirtualizationType?: VirtualizationType | null;
  CpuOptions?: CpuOptions | null;
  CapacityReservationId?: string | null;
  CapacityReservationSpecification?: CapacityReservationSpecificationResponse | null;
  HibernationOptions?: HibernationOptions | null;
  Licenses: LicenseConfiguration[];
  MetadataOptions?: InstanceMetadataOptionsResponse | null;
}
function Instance_Parse(node: xmlP.XmlNode): Instance {
  return {
    AmiLaunchIndex: node.first("amiLaunchIndex", false, x => parseInt(x.content ?? '0')),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    LaunchTime: node.first("launchTime", false, x => xmlP.parseTimestamp(x.content)),
    Monitoring: node.first("monitoring", false, Monitoring_Parse),
    Placement: node.first("placement", false, Placement_Parse),
    Platform: node.first("platform", false, x => (x.content ?? '') as PlatformValues),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    ProductCodes: node.getList("productCodes", "item").map(ProductCode_Parse),
    PublicDnsName: node.first("dnsName", false, x => x.content ?? ''),
    PublicIpAddress: node.first("ipAddress", false, x => x.content ?? ''),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    State: node.first("instanceState", false, InstanceState_Parse),
    StateTransitionReason: node.first("reason", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    Architecture: node.first("architecture", false, x => (x.content ?? '') as ArchitectureValues),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(InstanceBlockDeviceMapping_Parse),
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    EnaSupport: node.first("enaSupport", false, x => x.content === 'true'),
    Hypervisor: node.first("hypervisor", false, x => (x.content ?? '') as HypervisorType),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfile_Parse),
    InstanceLifecycle: node.first("instanceLifecycle", false, x => (x.content ?? '') as InstanceLifecycleType),
    ElasticGpuAssociations: node.getList("elasticGpuAssociationSet", "item").map(ElasticGpuAssociation_Parse),
    ElasticInferenceAcceleratorAssociations: node.getList("elasticInferenceAcceleratorAssociationSet", "item").map(ElasticInferenceAcceleratorAssociation_Parse),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterface_Parse),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    RootDeviceName: node.first("rootDeviceName", false, x => x.content ?? ''),
    RootDeviceType: node.first("rootDeviceType", false, x => (x.content ?? '') as DeviceType),
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    SriovNetSupport: node.first("sriovNetSupport", false, x => x.content ?? ''),
    StateReason: node.first("stateReason", false, StateReason_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VirtualizationType: node.first("virtualizationType", false, x => (x.content ?? '') as VirtualizationType),
    CpuOptions: node.first("cpuOptions", false, CpuOptions_Parse),
    CapacityReservationId: node.first("capacityReservationId", false, x => x.content ?? ''),
    CapacityReservationSpecification: node.first("capacityReservationSpecification", false, CapacityReservationSpecificationResponse_Parse),
    HibernationOptions: node.first("hibernationOptions", false, HibernationOptions_Parse),
    Licenses: node.getList("licenseSet", "item").map(LicenseConfiguration_Parse),
    MetadataOptions: node.first("metadataOptions", false, InstanceMetadataOptionsResponse_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface Monitoring {
  State?: MonitoringState | null;
}
function Monitoring_Parse(node: xmlP.XmlNode): Monitoring {
  return {
    State: node.first("state", false, x => (x.content ?? '') as MonitoringState),
  };
}

// refs: 4 - tags: output, named, enum
export type MonitoringState =
| "disabled"
| "disabling"
| "enabled"
| "pending"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type InstanceLifecycleType =
| "spot"
| "scheduled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ElasticGpuAssociation {
  ElasticGpuId?: string | null;
  ElasticGpuAssociationId?: string | null;
  ElasticGpuAssociationState?: string | null;
  ElasticGpuAssociationTime?: string | null;
}
function ElasticGpuAssociation_Parse(node: xmlP.XmlNode): ElasticGpuAssociation {
  return {
    ElasticGpuId: node.first("elasticGpuId", false, x => x.content ?? ''),
    ElasticGpuAssociationId: node.first("elasticGpuAssociationId", false, x => x.content ?? ''),
    ElasticGpuAssociationState: node.first("elasticGpuAssociationState", false, x => x.content ?? ''),
    ElasticGpuAssociationTime: node.first("elasticGpuAssociationTime", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ElasticInferenceAcceleratorAssociation {
  ElasticInferenceAcceleratorArn?: string | null;
  ElasticInferenceAcceleratorAssociationId?: string | null;
  ElasticInferenceAcceleratorAssociationState?: string | null;
  ElasticInferenceAcceleratorAssociationTime?: Date | number | null;
}
function ElasticInferenceAcceleratorAssociation_Parse(node: xmlP.XmlNode): ElasticInferenceAcceleratorAssociation {
  return {
    ElasticInferenceAcceleratorArn: node.first("elasticInferenceAcceleratorArn", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationId: node.first("elasticInferenceAcceleratorAssociationId", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationState: node.first("elasticInferenceAcceleratorAssociationState", false, x => x.content ?? ''),
    ElasticInferenceAcceleratorAssociationTime: node.first("elasticInferenceAcceleratorAssociationTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceNetworkInterface {
  Association?: InstanceNetworkInterfaceAssociation | null;
  Attachment?: InstanceNetworkInterfaceAttachment | null;
  Description?: string | null;
  Groups: GroupIdentifier[];
  Ipv6Addresses: InstanceIpv6Address[];
  MacAddress?: string | null;
  NetworkInterfaceId?: string | null;
  OwnerId?: string | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
  PrivateIpAddresses: InstancePrivateIpAddress[];
  SourceDestCheck?: boolean | null;
  Status?: NetworkInterfaceStatus | null;
  SubnetId?: string | null;
  VpcId?: string | null;
  InterfaceType?: string | null;
}
function InstanceNetworkInterface_Parse(node: xmlP.XmlNode): InstanceNetworkInterface {
  return {
    Association: node.first("association", false, InstanceNetworkInterfaceAssociation_Parse),
    Attachment: node.first("attachment", false, InstanceNetworkInterfaceAttachment_Parse),
    Description: node.first("description", false, x => x.content ?? ''),
    Groups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    Ipv6Addresses: node.getList("ipv6AddressesSet", "item").map(InstanceIpv6Address_Parse),
    MacAddress: node.first("macAddress", false, x => x.content ?? ''),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
    PrivateIpAddresses: node.getList("privateIpAddressesSet", "item").map(InstancePrivateIpAddress_Parse),
    SourceDestCheck: node.first("sourceDestCheck", false, x => x.content === 'true'),
    Status: node.first("status", false, x => (x.content ?? '') as NetworkInterfaceStatus),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
    InterfaceType: node.first("interfaceType", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface InstanceNetworkInterfaceAssociation {
  CarrierIp?: string | null;
  IpOwnerId?: string | null;
  PublicDnsName?: string | null;
  PublicIp?: string | null;
}
function InstanceNetworkInterfaceAssociation_Parse(node: xmlP.XmlNode): InstanceNetworkInterfaceAssociation {
  return {
    CarrierIp: node.first("carrierIp", false, x => x.content ?? ''),
    IpOwnerId: node.first("ipOwnerId", false, x => x.content ?? ''),
    PublicDnsName: node.first("publicDnsName", false, x => x.content ?? ''),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceNetworkInterfaceAttachment {
  AttachTime?: Date | number | null;
  AttachmentId?: string | null;
  DeleteOnTermination?: boolean | null;
  DeviceIndex?: number | null;
  Status?: AttachmentStatus | null;
}
function InstanceNetworkInterfaceAttachment_Parse(node: xmlP.XmlNode): InstanceNetworkInterfaceAttachment {
  return {
    AttachTime: node.first("attachTime", false, x => xmlP.parseTimestamp(x.content)),
    AttachmentId: node.first("attachmentId", false, x => x.content ?? ''),
    DeleteOnTermination: node.first("deleteOnTermination", false, x => x.content === 'true'),
    DeviceIndex: node.first("deviceIndex", false, x => parseInt(x.content ?? '0')),
    Status: node.first("status", false, x => (x.content ?? '') as AttachmentStatus),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstancePrivateIpAddress {
  Association?: InstanceNetworkInterfaceAssociation | null;
  Primary?: boolean | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
}
function InstancePrivateIpAddress_Parse(node: xmlP.XmlNode): InstancePrivateIpAddress {
  return {
    Association: node.first("association", false, InstanceNetworkInterfaceAssociation_Parse),
    Primary: node.first("primary", false, x => x.content === 'true'),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    PrivateIpAddress: node.first("privateIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface CpuOptions {
  CoreCount?: number | null;
  ThreadsPerCore?: number | null;
}
function CpuOptions_Parse(node: xmlP.XmlNode): CpuOptions {
  return {
    CoreCount: node.first("coreCount", false, x => parseInt(x.content ?? '0')),
    ThreadsPerCore: node.first("threadsPerCore", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, interface
export interface CapacityReservationSpecificationResponse {
  CapacityReservationPreference?: CapacityReservationPreference | null;
  CapacityReservationTarget?: CapacityReservationTargetResponse | null;
}
function CapacityReservationSpecificationResponse_Parse(node: xmlP.XmlNode): CapacityReservationSpecificationResponse {
  return {
    CapacityReservationPreference: node.first("capacityReservationPreference", false, x => (x.content ?? '') as CapacityReservationPreference),
    CapacityReservationTarget: node.first("capacityReservationTarget", false, CapacityReservationTargetResponse_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface HibernationOptions {
  Configured?: boolean | null;
}
function HibernationOptions_Parse(node: xmlP.XmlNode): HibernationOptions {
  return {
    Configured: node.first("configured", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface LicenseConfiguration {
  LicenseConfigurationArn?: string | null;
}
function LicenseConfiguration_Parse(node: xmlP.XmlNode): LicenseConfiguration {
  return {
    LicenseConfigurationArn: node.first("licenseConfigurationArn", false, x => x.content ?? ''),
  };
}

// refs: 3 - tags: output, named, interface
export interface InstanceMetadataOptionsResponse {
  State?: InstanceMetadataOptionsState | null;
  HttpTokens?: HttpTokensState | null;
  HttpPutResponseHopLimit?: number | null;
  HttpEndpoint?: InstanceMetadataEndpointState | null;
}
function InstanceMetadataOptionsResponse_Parse(node: xmlP.XmlNode): InstanceMetadataOptionsResponse {
  return {
    State: node.first("state", false, x => (x.content ?? '') as InstanceMetadataOptionsState),
    HttpTokens: node.first("httpTokens", false, x => (x.content ?? '') as HttpTokensState),
    HttpPutResponseHopLimit: node.first("httpPutResponseHopLimit", false, x => parseInt(x.content ?? '0')),
    HttpEndpoint: node.first("httpEndpoint", false, x => (x.content ?? '') as InstanceMetadataEndpointState),
  };
}

// refs: 3 - tags: output, named, enum
export type InstanceMetadataOptionsState =
| "pending"
| "applied"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Ipv6Pool {
  PoolId?: string | null;
  Description?: string | null;
  PoolCidrBlocks: PoolCidrBlock[];
  Tags: Tag[];
}
function Ipv6Pool_Parse(node: xmlP.XmlNode): Ipv6Pool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    PoolCidrBlocks: node.getList("poolCidrBlockSet", "item").map(PoolCidrBlock_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PoolCidrBlock {
  Cidr?: string | null;
}
function PoolCidrBlock_Parse(node: xmlP.XmlNode): PoolCidrBlock {
  return {
    Cidr: node.first("poolCidrBlock", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface KeyPairInfo {
  KeyPairId?: string | null;
  KeyFingerprint?: string | null;
  KeyName?: string | null;
  Tags: Tag[];
}
function KeyPairInfo_Parse(node: xmlP.XmlNode): KeyPairInfo {
  return {
    KeyPairId: node.first("keyPairId", false, x => x.content ?? ''),
    KeyFingerprint: node.first("keyFingerprint", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
  LocalGatewayRouteTableVirtualInterfaceGroupAssociationId?: string | null;
  LocalGatewayVirtualInterfaceGroupId?: string | null;
  LocalGatewayId?: string | null;
  LocalGatewayRouteTableId?: string | null;
  LocalGatewayRouteTableArn?: string | null;
  OwnerId?: string | null;
  State?: string | null;
  Tags: Tag[];
}
function LocalGatewayRouteTableVirtualInterfaceGroupAssociation_Parse(node: xmlP.XmlNode): LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
  return {
    LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: node.first("localGatewayRouteTableVirtualInterfaceGroupAssociationId", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LocalGatewayRouteTable {
  LocalGatewayRouteTableId?: string | null;
  LocalGatewayRouteTableArn?: string | null;
  LocalGatewayId?: string | null;
  OutpostArn?: string | null;
  OwnerId?: string | null;
  State?: string | null;
  Tags: Tag[];
}
function LocalGatewayRouteTable_Parse(node: xmlP.XmlNode): LocalGatewayRouteTable {
  return {
    LocalGatewayRouteTableId: node.first("localGatewayRouteTableId", false, x => x.content ?? ''),
    LocalGatewayRouteTableArn: node.first("localGatewayRouteTableArn", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LocalGatewayVirtualInterfaceGroup {
  LocalGatewayVirtualInterfaceGroupId?: string | null;
  LocalGatewayVirtualInterfaceIds: string[];
  LocalGatewayId?: string | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function LocalGatewayVirtualInterfaceGroup_Parse(node: xmlP.XmlNode): LocalGatewayVirtualInterfaceGroup {
  return {
    LocalGatewayVirtualInterfaceGroupId: node.first("localGatewayVirtualInterfaceGroupId", false, x => x.content ?? ''),
    LocalGatewayVirtualInterfaceIds: node.getList("localGatewayVirtualInterfaceIdSet", "item").map(x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LocalGatewayVirtualInterface {
  LocalGatewayVirtualInterfaceId?: string | null;
  LocalGatewayId?: string | null;
  Vlan?: number | null;
  LocalAddress?: string | null;
  PeerAddress?: string | null;
  LocalBgpAsn?: number | null;
  PeerBgpAsn?: number | null;
  OwnerId?: string | null;
  Tags: Tag[];
}
function LocalGatewayVirtualInterface_Parse(node: xmlP.XmlNode): LocalGatewayVirtualInterface {
  return {
    LocalGatewayVirtualInterfaceId: node.first("localGatewayVirtualInterfaceId", false, x => x.content ?? ''),
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    Vlan: node.first("vlan", false, x => parseInt(x.content ?? '0')),
    LocalAddress: node.first("localAddress", false, x => x.content ?? ''),
    PeerAddress: node.first("peerAddress", false, x => x.content ?? ''),
    LocalBgpAsn: node.first("localBgpAsn", false, x => parseInt(x.content ?? '0')),
    PeerBgpAsn: node.first("peerBgpAsn", false, x => parseInt(x.content ?? '0')),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface LocalGateway {
  LocalGatewayId?: string | null;
  OutpostArn?: string | null;
  OwnerId?: string | null;
  State?: string | null;
  Tags: Tag[];
}
function LocalGateway_Parse(node: xmlP.XmlNode): LocalGateway {
  return {
    LocalGatewayId: node.first("localGatewayId", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    State: node.first("state", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface MovingAddressStatus {
  MoveStatus?: MoveStatus | null;
  PublicIp?: string | null;
}
function MovingAddressStatus_Parse(node: xmlP.XmlNode): MovingAddressStatus {
  return {
    MoveStatus: node.first("moveStatus", false, x => (x.content ?? '') as MoveStatus),
    PublicIp: node.first("publicIp", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type MoveStatus =
| "movingToVpc"
| "restoringToClassic"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface PrefixList {
  Cidrs: string[];
  PrefixListId?: string | null;
  PrefixListName?: string | null;
}
function PrefixList_Parse(node: xmlP.XmlNode): PrefixList {
  return {
    Cidrs: node.getList("cidrSet", "item").map(x => x.content ?? ''),
    PrefixListId: node.first("prefixListId", false, x => x.content ?? ''),
    PrefixListName: node.first("prefixListName", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface PrincipalIdFormat {
  Arn?: string | null;
  Statuses: IdFormat[];
}
function PrincipalIdFormat_Parse(node: xmlP.XmlNode): PrincipalIdFormat {
  return {
    Arn: node.first("arn", false, x => x.content ?? ''),
    Statuses: node.getList("statusSet", "item").map(IdFormat_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PublicIpv4Pool {
  PoolId?: string | null;
  Description?: string | null;
  PoolAddressRanges: PublicIpv4PoolRange[];
  TotalAddressCount?: number | null;
  TotalAvailableAddressCount?: number | null;
  NetworkBorderGroup?: string | null;
  Tags: Tag[];
}
function PublicIpv4Pool_Parse(node: xmlP.XmlNode): PublicIpv4Pool {
  return {
    PoolId: node.first("poolId", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    PoolAddressRanges: node.getList("poolAddressRangeSet", "item").map(PublicIpv4PoolRange_Parse),
    TotalAddressCount: node.first("totalAddressCount", false, x => parseInt(x.content ?? '0')),
    TotalAvailableAddressCount: node.first("totalAvailableAddressCount", false, x => parseInt(x.content ?? '0')),
    NetworkBorderGroup: node.first("networkBorderGroup", false, x => x.content ?? ''),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PublicIpv4PoolRange {
  FirstAddress?: string | null;
  LastAddress?: string | null;
  AddressCount?: number | null;
  AvailableAddressCount?: number | null;
}
function PublicIpv4PoolRange_Parse(node: xmlP.XmlNode): PublicIpv4PoolRange {
  return {
    FirstAddress: node.first("firstAddress", false, x => x.content ?? ''),
    LastAddress: node.first("lastAddress", false, x => x.content ?? ''),
    AddressCount: node.first("addressCount", false, x => parseInt(x.content ?? '0')),
    AvailableAddressCount: node.first("availableAddressCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface Region {
  Endpoint?: string | null;
  RegionName?: string | null;
  OptInStatus?: string | null;
}
function Region_Parse(node: xmlP.XmlNode): Region {
  return {
    Endpoint: node.first("regionEndpoint", false, x => x.content ?? ''),
    RegionName: node.first("regionName", false, x => x.content ?? ''),
    OptInStatus: node.first("optInStatus", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedInstances {
  AvailabilityZone?: string | null;
  Duration?: number | null;
  End?: Date | number | null;
  FixedPrice?: number | null;
  InstanceCount?: number | null;
  InstanceType?: InstanceType | null;
  ProductDescription?: RIProductDescription | null;
  ReservedInstancesId?: string | null;
  Start?: Date | number | null;
  State?: ReservedInstanceState | null;
  UsagePrice?: number | null;
  CurrencyCode?: CurrencyCodeValues | null;
  InstanceTenancy?: Tenancy | null;
  OfferingClass?: OfferingClassType | null;
  OfferingType?: OfferingTypeValues | null;
  RecurringCharges: RecurringCharge[];
  Scope?: scope | null;
  Tags: Tag[];
}
function ReservedInstances_Parse(node: xmlP.XmlNode): ReservedInstances {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    End: node.first("end", false, x => xmlP.parseTimestamp(x.content)),
    FixedPrice: node.first("fixedPrice", false, x => parseFloat(x.content ?? '0')),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as RIProductDescription),
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    Start: node.first("start", false, x => xmlP.parseTimestamp(x.content)),
    State: node.first("state", false, x => (x.content ?? '') as ReservedInstanceState),
    UsagePrice: node.first("usagePrice", false, x => parseFloat(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as Tenancy),
    OfferingClass: node.first("offeringClass", false, x => (x.content ?? '') as OfferingClassType),
    OfferingType: node.first("offeringType", false, x => (x.content ?? '') as OfferingTypeValues),
    RecurringCharges: node.getList("recurringCharges", "item").map(RecurringCharge_Parse),
    Scope: node.first("scope", false, x => (x.content ?? '') as scope),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ReservedInstanceState =
| "payment-pending"
| "active"
| "payment-failed"
| "retired"
| "queued"
| "queued-deleted"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface RecurringCharge {
  Amount?: number | null;
  Frequency?: RecurringChargeFrequency | null;
}
function RecurringCharge_Parse(node: xmlP.XmlNode): RecurringCharge {
  return {
    Amount: node.first("amount", false, x => parseFloat(x.content ?? '0')),
    Frequency: node.first("frequency", false, x => (x.content ?? '') as RecurringChargeFrequency),
  };
}

// refs: 2 - tags: output, named, enum
export type RecurringChargeFrequency =
| "Hourly"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ReservedInstancesModification {
  ClientToken?: string | null;
  CreateDate?: Date | number | null;
  EffectiveDate?: Date | number | null;
  ModificationResults: ReservedInstancesModificationResult[];
  ReservedInstancesIds: ReservedInstancesId[];
  ReservedInstancesModificationId?: string | null;
  Status?: string | null;
  StatusMessage?: string | null;
  UpdateDate?: Date | number | null;
}
function ReservedInstancesModification_Parse(node: xmlP.XmlNode): ReservedInstancesModification {
  return {
    ClientToken: node.first("clientToken", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    EffectiveDate: node.first("effectiveDate", false, x => xmlP.parseTimestamp(x.content)),
    ModificationResults: node.getList("modificationResultSet", "item").map(ReservedInstancesModificationResult_Parse),
    ReservedInstancesIds: node.getList("reservedInstancesSet", "item").map(ReservedInstancesId_Parse),
    ReservedInstancesModificationId: node.first("reservedInstancesModificationId", false, x => x.content ?? ''),
    Status: node.first("status", false, x => x.content ?? ''),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    UpdateDate: node.first("updateDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedInstancesModificationResult {
  ReservedInstancesId?: string | null;
  TargetConfiguration?: ReservedInstancesConfiguration | null;
}
function ReservedInstancesModificationResult_Parse(node: xmlP.XmlNode): ReservedInstancesModificationResult {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
    TargetConfiguration: node.first("targetConfiguration", false, ReservedInstancesConfiguration_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedInstancesId {
  ReservedInstancesId?: string | null;
}
function ReservedInstancesId_Parse(node: xmlP.XmlNode): ReservedInstancesId {
  return {
    ReservedInstancesId: node.first("reservedInstancesId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedInstancesOffering {
  AvailabilityZone?: string | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  InstanceType?: InstanceType | null;
  ProductDescription?: RIProductDescription | null;
  ReservedInstancesOfferingId?: string | null;
  UsagePrice?: number | null;
  CurrencyCode?: CurrencyCodeValues | null;
  InstanceTenancy?: Tenancy | null;
  Marketplace?: boolean | null;
  OfferingClass?: OfferingClassType | null;
  OfferingType?: OfferingTypeValues | null;
  PricingDetails: PricingDetail[];
  RecurringCharges: RecurringCharge[];
  Scope?: scope | null;
}
function ReservedInstancesOffering_Parse(node: xmlP.XmlNode): ReservedInstancesOffering {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("fixedPrice", false, x => parseFloat(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as RIProductDescription),
    ReservedInstancesOfferingId: node.first("reservedInstancesOfferingId", false, x => x.content ?? ''),
    UsagePrice: node.first("usagePrice", false, x => parseFloat(x.content ?? '0')),
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    InstanceTenancy: node.first("instanceTenancy", false, x => (x.content ?? '') as Tenancy),
    Marketplace: node.first("marketplace", false, x => x.content === 'true'),
    OfferingClass: node.first("offeringClass", false, x => (x.content ?? '') as OfferingClassType),
    OfferingType: node.first("offeringType", false, x => (x.content ?? '') as OfferingTypeValues),
    PricingDetails: node.getList("pricingDetailsSet", "item").map(PricingDetail_Parse),
    RecurringCharges: node.getList("recurringCharges", "item").map(RecurringCharge_Parse),
    Scope: node.first("scope", false, x => (x.content ?? '') as scope),
  };
}

// refs: 1 - tags: output, named, interface
export interface PricingDetail {
  Count?: number | null;
  Price?: number | null;
}
function PricingDetail_Parse(node: xmlP.XmlNode): PricingDetail {
  return {
    Count: node.first("count", false, x => parseInt(x.content ?? '0')),
    Price: node.first("price", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ScheduledInstanceAvailability {
  AvailabilityZone?: string | null;
  AvailableInstanceCount?: number | null;
  FirstSlotStartTime?: Date | number | null;
  HourlyPrice?: string | null;
  InstanceType?: string | null;
  MaxTermDurationInDays?: number | null;
  MinTermDurationInDays?: number | null;
  NetworkPlatform?: string | null;
  Platform?: string | null;
  PurchaseToken?: string | null;
  Recurrence?: ScheduledInstanceRecurrence | null;
  SlotDurationInHours?: number | null;
  TotalScheduledInstanceHours?: number | null;
}
function ScheduledInstanceAvailability_Parse(node: xmlP.XmlNode): ScheduledInstanceAvailability {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    AvailableInstanceCount: node.first("availableInstanceCount", false, x => parseInt(x.content ?? '0')),
    FirstSlotStartTime: node.first("firstSlotStartTime", false, x => xmlP.parseTimestamp(x.content)),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    MaxTermDurationInDays: node.first("maxTermDurationInDays", false, x => parseInt(x.content ?? '0')),
    MinTermDurationInDays: node.first("minTermDurationInDays", false, x => parseInt(x.content ?? '0')),
    NetworkPlatform: node.first("networkPlatform", false, x => x.content ?? ''),
    Platform: node.first("platform", false, x => x.content ?? ''),
    PurchaseToken: node.first("purchaseToken", false, x => x.content ?? ''),
    Recurrence: node.first("recurrence", false, ScheduledInstanceRecurrence_Parse),
    SlotDurationInHours: node.first("slotDurationInHours", false, x => parseInt(x.content ?? '0')),
    TotalScheduledInstanceHours: node.first("totalScheduledInstanceHours", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface ScheduledInstanceRecurrence {
  Frequency?: string | null;
  Interval?: number | null;
  OccurrenceDaySet: number[];
  OccurrenceRelativeToEnd?: boolean | null;
  OccurrenceUnit?: string | null;
}
function ScheduledInstanceRecurrence_Parse(node: xmlP.XmlNode): ScheduledInstanceRecurrence {
  return {
    Frequency: node.first("frequency", false, x => x.content ?? ''),
    Interval: node.first("interval", false, x => parseInt(x.content ?? '0')),
    OccurrenceDaySet: node.getList("occurrenceDaySet", "item").map(x => parseInt(x.content ?? '0')),
    OccurrenceRelativeToEnd: node.first("occurrenceRelativeToEnd", false, x => x.content === 'true'),
    OccurrenceUnit: node.first("occurrenceUnit", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface ScheduledInstance {
  AvailabilityZone?: string | null;
  CreateDate?: Date | number | null;
  HourlyPrice?: string | null;
  InstanceCount?: number | null;
  InstanceType?: string | null;
  NetworkPlatform?: string | null;
  NextSlotStartTime?: Date | number | null;
  Platform?: string | null;
  PreviousSlotEndTime?: Date | number | null;
  Recurrence?: ScheduledInstanceRecurrence | null;
  ScheduledInstanceId?: string | null;
  SlotDurationInHours?: number | null;
  TermEndDate?: Date | number | null;
  TermStartDate?: Date | number | null;
  TotalScheduledInstanceHours?: number | null;
}
function ScheduledInstance_Parse(node: xmlP.XmlNode): ScheduledInstance {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    CreateDate: node.first("createDate", false, x => xmlP.parseTimestamp(x.content)),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    InstanceType: node.first("instanceType", false, x => x.content ?? ''),
    NetworkPlatform: node.first("networkPlatform", false, x => x.content ?? ''),
    NextSlotStartTime: node.first("nextSlotStartTime", false, x => xmlP.parseTimestamp(x.content)),
    Platform: node.first("platform", false, x => x.content ?? ''),
    PreviousSlotEndTime: node.first("previousSlotEndTime", false, x => xmlP.parseTimestamp(x.content)),
    Recurrence: node.first("recurrence", false, ScheduledInstanceRecurrence_Parse),
    ScheduledInstanceId: node.first("scheduledInstanceId", false, x => x.content ?? ''),
    SlotDurationInHours: node.first("slotDurationInHours", false, x => parseInt(x.content ?? '0')),
    TermEndDate: node.first("termEndDate", false, x => xmlP.parseTimestamp(x.content)),
    TermStartDate: node.first("termStartDate", false, x => xmlP.parseTimestamp(x.content)),
    TotalScheduledInstanceHours: node.first("totalScheduledInstanceHours", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface SecurityGroupReference {
  GroupId?: string | null;
  ReferencingVpcId?: string | null;
  VpcPeeringConnectionId?: string | null;
}
function SecurityGroupReference_Parse(node: xmlP.XmlNode): SecurityGroupReference {
  return {
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    ReferencingVpcId: node.first("referencingVpcId", false, x => x.content ?? ''),
    VpcPeeringConnectionId: node.first("vpcPeeringConnectionId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface SecurityGroup {
  Description?: string | null;
  GroupName?: string | null;
  IpPermissions: IpPermission[];
  OwnerId?: string | null;
  GroupId?: string | null;
  IpPermissionsEgress: IpPermission[];
  Tags: Tag[];
  VpcId?: string | null;
}
function SecurityGroup_Parse(node: xmlP.XmlNode): SecurityGroup {
  return {
    Description: node.first("groupDescription", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    IpPermissions: node.getList("ipPermissions", "item").map(IpPermission_Parse),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    IpPermissionsEgress: node.getList("ipPermissionsEgress", "item").map(IpPermission_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface HistoryRecord {
  EventInformation?: EventInformation | null;
  EventType?: EventType | null;
  Timestamp?: Date | number | null;
}
function HistoryRecord_Parse(node: xmlP.XmlNode): HistoryRecord {
  return {
    EventInformation: node.first("eventInformation", false, EventInformation_Parse),
    EventType: node.first("eventType", false, x => (x.content ?? '') as EventType),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface SpotFleetRequestConfig {
  ActivityStatus?: ActivityStatus | null;
  CreateTime?: Date | number | null;
  SpotFleetRequestConfig?: SpotFleetRequestConfigData | null;
  SpotFleetRequestId?: string | null;
  SpotFleetRequestState?: BatchState | null;
  Tags: Tag[];
}
function SpotFleetRequestConfig_Parse(node: xmlP.XmlNode): SpotFleetRequestConfig {
  return {
    ActivityStatus: node.first("activityStatus", false, x => (x.content ?? '') as ActivityStatus),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    SpotFleetRequestConfig: node.first("spotFleetRequestConfig", false, SpotFleetRequestConfigData_Parse),
    SpotFleetRequestId: node.first("spotFleetRequestId", false, x => x.content ?? ''),
    SpotFleetRequestState: node.first("spotFleetRequestState", false, x => (x.content ?? '') as BatchState),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ActivityStatus =
| "error"
| "pending_fulfillment"
| "pending_termination"
| "fulfilled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SpotInstanceRequest {
  ActualBlockHourlyPrice?: string | null;
  AvailabilityZoneGroup?: string | null;
  BlockDurationMinutes?: number | null;
  CreateTime?: Date | number | null;
  Fault?: SpotInstanceStateFault | null;
  InstanceId?: string | null;
  LaunchGroup?: string | null;
  LaunchSpecification?: LaunchSpecification | null;
  LaunchedAvailabilityZone?: string | null;
  ProductDescription?: RIProductDescription | null;
  SpotInstanceRequestId?: string | null;
  SpotPrice?: string | null;
  State?: SpotInstanceState | null;
  Status?: SpotInstanceStatus | null;
  Tags: Tag[];
  Type?: SpotInstanceType | null;
  ValidFrom?: Date | number | null;
  ValidUntil?: Date | number | null;
  InstanceInterruptionBehavior?: InstanceInterruptionBehavior | null;
}
function SpotInstanceRequest_Parse(node: xmlP.XmlNode): SpotInstanceRequest {
  return {
    ActualBlockHourlyPrice: node.first("actualBlockHourlyPrice", false, x => x.content ?? ''),
    AvailabilityZoneGroup: node.first("availabilityZoneGroup", false, x => x.content ?? ''),
    BlockDurationMinutes: node.first("blockDurationMinutes", false, x => parseInt(x.content ?? '0')),
    CreateTime: node.first("createTime", false, x => xmlP.parseTimestamp(x.content)),
    Fault: node.first("fault", false, SpotInstanceStateFault_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    LaunchGroup: node.first("launchGroup", false, x => x.content ?? ''),
    LaunchSpecification: node.first("launchSpecification", false, LaunchSpecification_Parse),
    LaunchedAvailabilityZone: node.first("launchedAvailabilityZone", false, x => x.content ?? ''),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as RIProductDescription),
    SpotInstanceRequestId: node.first("spotInstanceRequestId", false, x => x.content ?? ''),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as SpotInstanceState),
    Status: node.first("status", false, SpotInstanceStatus_Parse),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    Type: node.first("type", false, x => (x.content ?? '') as SpotInstanceType),
    ValidFrom: node.first("validFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidUntil: node.first("validUntil", false, x => xmlP.parseTimestamp(x.content)),
    InstanceInterruptionBehavior: node.first("instanceInterruptionBehavior", false, x => (x.content ?? '') as InstanceInterruptionBehavior),
  };
}

// refs: 2 - tags: output, named, interface
export interface LaunchSpecification {
  UserData?: string | null;
  SecurityGroups: GroupIdentifier[];
  AddressingType?: string | null;
  BlockDeviceMappings: BlockDeviceMapping[];
  EbsOptimized?: boolean | null;
  IamInstanceProfile?: IamInstanceProfileSpecification | null;
  ImageId?: string | null;
  InstanceType?: InstanceType | null;
  KernelId?: string | null;
  KeyName?: string | null;
  NetworkInterfaces: InstanceNetworkInterfaceSpecification[];
  Placement?: SpotPlacement | null;
  RamdiskId?: string | null;
  SubnetId?: string | null;
  Monitoring?: RunInstancesMonitoringEnabled | null;
}
function LaunchSpecification_Parse(node: xmlP.XmlNode): LaunchSpecification {
  return {
    UserData: node.first("userData", false, x => x.content ?? ''),
    SecurityGroups: node.getList("groupSet", "item").map(GroupIdentifier_Parse),
    AddressingType: node.first("addressingType", false, x => x.content ?? ''),
    BlockDeviceMappings: node.getList("blockDeviceMapping", "item").map(BlockDeviceMapping_Parse),
    EbsOptimized: node.first("ebsOptimized", false, x => x.content === 'true'),
    IamInstanceProfile: node.first("iamInstanceProfile", false, IamInstanceProfileSpecification_Parse),
    ImageId: node.first("imageId", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    KernelId: node.first("kernelId", false, x => x.content ?? ''),
    KeyName: node.first("keyName", false, x => x.content ?? ''),
    NetworkInterfaces: node.getList("networkInterfaceSet", "item").map(InstanceNetworkInterfaceSpecification_Parse),
    Placement: node.first("placement", false, SpotPlacement_Parse),
    RamdiskId: node.first("ramdiskId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, RunInstancesMonitoringEnabled_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type SpotInstanceState =
| "open"
| "active"
| "closed"
| "cancelled"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SpotInstanceStatus {
  Code?: string | null;
  Message?: string | null;
  UpdateTime?: Date | number | null;
}
function SpotInstanceStatus_Parse(node: xmlP.XmlNode): SpotInstanceStatus {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
    UpdateTime: node.first("updateTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface SpotPrice {
  AvailabilityZone?: string | null;
  InstanceType?: InstanceType | null;
  ProductDescription?: RIProductDescription | null;
  SpotPrice?: string | null;
  Timestamp?: Date | number | null;
}
function SpotPrice_Parse(node: xmlP.XmlNode): SpotPrice {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    InstanceType: node.first("instanceType", false, x => (x.content ?? '') as InstanceType),
    ProductDescription: node.first("productDescription", false, x => (x.content ?? '') as RIProductDescription),
    SpotPrice: node.first("spotPrice", false, x => x.content ?? ''),
    Timestamp: node.first("timestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StaleSecurityGroup {
  Description?: string | null;
  GroupId?: string | null;
  GroupName?: string | null;
  StaleIpPermissions: StaleIpPermission[];
  StaleIpPermissionsEgress: StaleIpPermission[];
  VpcId?: string | null;
}
function StaleSecurityGroup_Parse(node: xmlP.XmlNode): StaleSecurityGroup {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    GroupId: node.first("groupId", false, x => x.content ?? ''),
    GroupName: node.first("groupName", false, x => x.content ?? ''),
    StaleIpPermissions: node.getList("staleIpPermissions", "item").map(StaleIpPermission_Parse),
    StaleIpPermissionsEgress: node.getList("staleIpPermissionsEgress", "item").map(StaleIpPermission_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface StaleIpPermission {
  FromPort?: number | null;
  IpProtocol?: string | null;
  IpRanges: string[];
  PrefixListIds: string[];
  ToPort?: number | null;
  UserIdGroupPairs: UserIdGroupPair[];
}
function StaleIpPermission_Parse(node: xmlP.XmlNode): StaleIpPermission {
  return {
    FromPort: node.first("fromPort", false, x => parseInt(x.content ?? '0')),
    IpProtocol: node.first("ipProtocol", false, x => x.content ?? ''),
    IpRanges: node.getList("ipRanges", "item").map(x => x.content ?? ''),
    PrefixListIds: node.getList("prefixListIds", "item").map(x => x.content ?? ''),
    ToPort: node.first("toPort", false, x => parseInt(x.content ?? '0')),
    UserIdGroupPairs: node.getList("groups", "item").map(UserIdGroupPair_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TagDescription {
  Key?: string | null;
  ResourceId?: string | null;
  ResourceType?: ResourceType | null;
  Value?: string | null;
}
function TagDescription_Parse(node: xmlP.XmlNode): TagDescription {
  return {
    Key: node.first("key", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as ResourceType),
    Value: node.first("value", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayAttachment {
  TransitGatewayAttachmentId?: string | null;
  TransitGatewayId?: string | null;
  TransitGatewayOwnerId?: string | null;
  ResourceOwnerId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  ResourceId?: string | null;
  State?: TransitGatewayAttachmentState | null;
  Association?: TransitGatewayAttachmentAssociation | null;
  CreationTime?: Date | number | null;
  Tags: Tag[];
}
function TransitGatewayAttachment_Parse(node: xmlP.XmlNode): TransitGatewayAttachment {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    TransitGatewayId: node.first("transitGatewayId", false, x => x.content ?? ''),
    TransitGatewayOwnerId: node.first("transitGatewayOwnerId", false, x => x.content ?? ''),
    ResourceOwnerId: node.first("resourceOwnerId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAttachmentState),
    Association: node.first("association", false, TransitGatewayAttachmentAssociation_Parse),
    CreationTime: node.first("creationTime", false, x => xmlP.parseTimestamp(x.content)),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayAttachmentAssociation {
  TransitGatewayRouteTableId?: string | null;
  State?: TransitGatewayAssociationState | null;
}
function TransitGatewayAttachmentAssociation_Parse(node: xmlP.XmlNode): TransitGatewayAttachmentAssociation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAssociationState),
  };
}

// refs: 1 - tags: output, named, interface
export interface VolumeStatusItem {
  Actions: VolumeStatusAction[];
  AvailabilityZone?: string | null;
  OutpostArn?: string | null;
  Events: VolumeStatusEvent[];
  VolumeId?: string | null;
  VolumeStatus?: VolumeStatusInfo | null;
  AttachmentStatuses: VolumeStatusAttachmentStatus[];
}
function VolumeStatusItem_Parse(node: xmlP.XmlNode): VolumeStatusItem {
  return {
    Actions: node.getList("actionsSet", "item").map(VolumeStatusAction_Parse),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    OutpostArn: node.first("outpostArn", false, x => x.content ?? ''),
    Events: node.getList("eventsSet", "item").map(VolumeStatusEvent_Parse),
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    VolumeStatus: node.first("volumeStatus", false, VolumeStatusInfo_Parse),
    AttachmentStatuses: node.getList("attachmentStatuses", "item").map(VolumeStatusAttachmentStatus_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface VolumeStatusAction {
  Code?: string | null;
  Description?: string | null;
  EventId?: string | null;
  EventType?: string | null;
}
function VolumeStatusAction_Parse(node: xmlP.XmlNode): VolumeStatusAction {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
    EventId: node.first("eventId", false, x => x.content ?? ''),
    EventType: node.first("eventType", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface VolumeStatusEvent {
  Description?: string | null;
  EventId?: string | null;
  EventType?: string | null;
  NotAfter?: Date | number | null;
  NotBefore?: Date | number | null;
  InstanceId?: string | null;
}
function VolumeStatusEvent_Parse(node: xmlP.XmlNode): VolumeStatusEvent {
  return {
    Description: node.first("description", false, x => x.content ?? ''),
    EventId: node.first("eventId", false, x => x.content ?? ''),
    EventType: node.first("eventType", false, x => x.content ?? ''),
    NotAfter: node.first("notAfter", false, x => xmlP.parseTimestamp(x.content)),
    NotBefore: node.first("notBefore", false, x => xmlP.parseTimestamp(x.content)),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface VolumeStatusInfo {
  Details: VolumeStatusDetails[];
  Status?: VolumeStatusInfoStatus | null;
}
function VolumeStatusInfo_Parse(node: xmlP.XmlNode): VolumeStatusInfo {
  return {
    Details: node.getList("details", "item").map(VolumeStatusDetails_Parse),
    Status: node.first("status", false, x => (x.content ?? '') as VolumeStatusInfoStatus),
  };
}

// refs: 1 - tags: output, named, interface
export interface VolumeStatusDetails {
  Name?: VolumeStatusName | null;
  Status?: string | null;
}
function VolumeStatusDetails_Parse(node: xmlP.XmlNode): VolumeStatusDetails {
  return {
    Name: node.first("name", false, x => (x.content ?? '') as VolumeStatusName),
    Status: node.first("status", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type VolumeStatusName =
| "io-enabled"
| "io-performance"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type VolumeStatusInfoStatus =
| "ok"
| "impaired"
| "insufficient-data"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface VolumeStatusAttachmentStatus {
  IoPerformance?: string | null;
  InstanceId?: string | null;
}
function VolumeStatusAttachmentStatus_Parse(node: xmlP.XmlNode): VolumeStatusAttachmentStatus {
  return {
    IoPerformance: node.first("ioPerformance", false, x => x.content ?? ''),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface VolumeModification {
  VolumeId?: string | null;
  ModificationState?: VolumeModificationState | null;
  StatusMessage?: string | null;
  TargetSize?: number | null;
  TargetIops?: number | null;
  TargetVolumeType?: VolumeType | null;
  OriginalSize?: number | null;
  OriginalIops?: number | null;
  OriginalVolumeType?: VolumeType | null;
  Progress?: number | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
}
function VolumeModification_Parse(node: xmlP.XmlNode): VolumeModification {
  return {
    VolumeId: node.first("volumeId", false, x => x.content ?? ''),
    ModificationState: node.first("modificationState", false, x => (x.content ?? '') as VolumeModificationState),
    StatusMessage: node.first("statusMessage", false, x => x.content ?? ''),
    TargetSize: node.first("targetSize", false, x => parseInt(x.content ?? '0')),
    TargetIops: node.first("targetIops", false, x => parseInt(x.content ?? '0')),
    TargetVolumeType: node.first("targetVolumeType", false, x => (x.content ?? '') as VolumeType),
    OriginalSize: node.first("originalSize", false, x => parseInt(x.content ?? '0')),
    OriginalIops: node.first("originalIops", false, x => parseInt(x.content ?? '0')),
    OriginalVolumeType: node.first("originalVolumeType", false, x => (x.content ?? '') as VolumeType),
    Progress: node.first("progress", false, x => parseInt(x.content ?? '0')),
    StartTime: node.first("startTime", false, x => xmlP.parseTimestamp(x.content)),
    EndTime: node.first("endTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, enum
export type VolumeModificationState =
| "modifying"
| "optimizing"
| "completed"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface VpcClassicLink {
  ClassicLinkEnabled?: boolean | null;
  Tags: Tag[];
  VpcId?: string | null;
}
function VpcClassicLink_Parse(node: xmlP.XmlNode): VpcClassicLink {
  return {
    ClassicLinkEnabled: node.first("classicLinkEnabled", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ClassicLinkDnsSupport {
  ClassicLinkDnsSupported?: boolean | null;
  VpcId?: string | null;
}
function ClassicLinkDnsSupport_Parse(node: xmlP.XmlNode): ClassicLinkDnsSupport {
  return {
    ClassicLinkDnsSupported: node.first("classicLinkDnsSupported", false, x => x.content === 'true'),
    VpcId: node.first("vpcId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface VpcEndpointConnection {
  ServiceId?: string | null;
  VpcEndpointId?: string | null;
  VpcEndpointOwner?: string | null;
  VpcEndpointState?: State | null;
  CreationTimestamp?: Date | number | null;
  DnsEntries: DnsEntry[];
  NetworkLoadBalancerArns: string[];
}
function VpcEndpointConnection_Parse(node: xmlP.XmlNode): VpcEndpointConnection {
  return {
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    VpcEndpointId: node.first("vpcEndpointId", false, x => x.content ?? ''),
    VpcEndpointOwner: node.first("vpcEndpointOwner", false, x => x.content ?? ''),
    VpcEndpointState: node.first("vpcEndpointState", false, x => (x.content ?? '') as State),
    CreationTimestamp: node.first("creationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    DnsEntries: node.getList("dnsEntrySet", "item").map(DnsEntry_Parse),
    NetworkLoadBalancerArns: node.getList("networkLoadBalancerArnSet", "item").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface AllowedPrincipal {
  PrincipalType?: PrincipalType | null;
  Principal?: string | null;
}
function AllowedPrincipal_Parse(node: xmlP.XmlNode): AllowedPrincipal {
  return {
    PrincipalType: node.first("principalType", false, x => (x.content ?? '') as PrincipalType),
    Principal: node.first("principal", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type PrincipalType =
| "All"
| "Service"
| "OrganizationUnit"
| "Account"
| "User"
| "Role"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ServiceDetail {
  ServiceName?: string | null;
  ServiceId?: string | null;
  ServiceType: ServiceTypeDetail[];
  AvailabilityZones: string[];
  Owner?: string | null;
  BaseEndpointDnsNames: string[];
  PrivateDnsName?: string | null;
  VpcEndpointPolicySupported?: boolean | null;
  AcceptanceRequired?: boolean | null;
  ManagesVpcEndpoints?: boolean | null;
  Tags: Tag[];
  PrivateDnsNameVerificationState?: DnsNameState | null;
}
function ServiceDetail_Parse(node: xmlP.XmlNode): ServiceDetail {
  return {
    ServiceName: node.first("serviceName", false, x => x.content ?? ''),
    ServiceId: node.first("serviceId", false, x => x.content ?? ''),
    ServiceType: node.getList("serviceType", "item").map(ServiceTypeDetail_Parse),
    AvailabilityZones: node.getList("availabilityZoneSet", "item").map(x => x.content ?? ''),
    Owner: node.first("owner", false, x => x.content ?? ''),
    BaseEndpointDnsNames: node.getList("baseEndpointDnsNameSet", "item").map(x => x.content ?? ''),
    PrivateDnsName: node.first("privateDnsName", false, x => x.content ?? ''),
    VpcEndpointPolicySupported: node.first("vpcEndpointPolicySupported", false, x => x.content === 'true'),
    AcceptanceRequired: node.first("acceptanceRequired", false, x => x.content === 'true'),
    ManagesVpcEndpoints: node.first("managesVpcEndpoints", false, x => x.content === 'true'),
    Tags: node.getList("tagSet", "item").map(Tag_Parse),
    PrivateDnsNameVerificationState: node.first("privateDnsNameVerificationState", false, x => (x.content ?? '') as DnsNameState),
  };
}

// refs: 1 - tags: output, named, interface
export interface DisableFastSnapshotRestoreSuccessItem {
  SnapshotId?: string | null;
  AvailabilityZone?: string | null;
  State?: FastSnapshotRestoreStateCode | null;
  StateTransitionReason?: string | null;
  OwnerId?: string | null;
  OwnerAlias?: string | null;
  EnablingTime?: Date | number | null;
  OptimizingTime?: Date | number | null;
  EnabledTime?: Date | number | null;
  DisablingTime?: Date | number | null;
  DisabledTime?: Date | number | null;
}
function DisableFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): DisableFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface DisableFastSnapshotRestoreErrorItem {
  SnapshotId?: string | null;
  FastSnapshotRestoreStateErrors: DisableFastSnapshotRestoreStateErrorItem[];
}
function DisableFastSnapshotRestoreErrorItem_Parse(node: xmlP.XmlNode): DisableFastSnapshotRestoreErrorItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    FastSnapshotRestoreStateErrors: node.getList("fastSnapshotRestoreStateErrorSet", "item").map(DisableFastSnapshotRestoreStateErrorItem_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface DisableFastSnapshotRestoreStateErrorItem {
  AvailabilityZone?: string | null;
  Error?: DisableFastSnapshotRestoreStateError | null;
}
function DisableFastSnapshotRestoreStateErrorItem_Parse(node: xmlP.XmlNode): DisableFastSnapshotRestoreStateErrorItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Error: node.first("error", false, DisableFastSnapshotRestoreStateError_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface DisableFastSnapshotRestoreStateError {
  Code?: string | null;
  Message?: string | null;
}
function DisableFastSnapshotRestoreStateError_Parse(node: xmlP.XmlNode): DisableFastSnapshotRestoreStateError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface TransitGatewayPropagation {
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  TransitGatewayRouteTableId?: string | null;
  State?: TransitGatewayPropagationState | null;
}
function TransitGatewayPropagation_Parse(node: xmlP.XmlNode): TransitGatewayPropagation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayPropagationState),
  };
}

// refs: 4 - tags: output, named, enum
export type TransitGatewayPropagationState =
| "enabling"
| "enabled"
| "disabling"
| "disabled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface EnableFastSnapshotRestoreSuccessItem {
  SnapshotId?: string | null;
  AvailabilityZone?: string | null;
  State?: FastSnapshotRestoreStateCode | null;
  StateTransitionReason?: string | null;
  OwnerId?: string | null;
  OwnerAlias?: string | null;
  EnablingTime?: Date | number | null;
  OptimizingTime?: Date | number | null;
  EnabledTime?: Date | number | null;
  DisablingTime?: Date | number | null;
  DisabledTime?: Date | number | null;
}
function EnableFastSnapshotRestoreSuccessItem_Parse(node: xmlP.XmlNode): EnableFastSnapshotRestoreSuccessItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as FastSnapshotRestoreStateCode),
    StateTransitionReason: node.first("stateTransitionReason", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
    OwnerAlias: node.first("ownerAlias", false, x => x.content ?? ''),
    EnablingTime: node.first("enablingTime", false, x => xmlP.parseTimestamp(x.content)),
    OptimizingTime: node.first("optimizingTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledTime: node.first("enabledTime", false, x => xmlP.parseTimestamp(x.content)),
    DisablingTime: node.first("disablingTime", false, x => xmlP.parseTimestamp(x.content)),
    DisabledTime: node.first("disabledTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface EnableFastSnapshotRestoreErrorItem {
  SnapshotId?: string | null;
  FastSnapshotRestoreStateErrors: EnableFastSnapshotRestoreStateErrorItem[];
}
function EnableFastSnapshotRestoreErrorItem_Parse(node: xmlP.XmlNode): EnableFastSnapshotRestoreErrorItem {
  return {
    SnapshotId: node.first("snapshotId", false, x => x.content ?? ''),
    FastSnapshotRestoreStateErrors: node.getList("fastSnapshotRestoreStateErrorSet", "item").map(EnableFastSnapshotRestoreStateErrorItem_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EnableFastSnapshotRestoreStateErrorItem {
  AvailabilityZone?: string | null;
  Error?: EnableFastSnapshotRestoreStateError | null;
}
function EnableFastSnapshotRestoreStateErrorItem_Parse(node: xmlP.XmlNode): EnableFastSnapshotRestoreStateErrorItem {
  return {
    AvailabilityZone: node.first("availabilityZone", false, x => x.content ?? ''),
    Error: node.first("error", false, EnableFastSnapshotRestoreStateError_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EnableFastSnapshotRestoreStateError {
  Code?: string | null;
  Message?: string | null;
}
function EnableFastSnapshotRestoreStateError_Parse(node: xmlP.XmlNode): EnableFastSnapshotRestoreStateError {
  return {
    Code: node.first("code", false, x => x.content ?? ''),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ClientCertificateRevocationListStatus {
  Code?: ClientCertificateRevocationListStatusCode | null;
  Message?: string | null;
}
function ClientCertificateRevocationListStatus_Parse(node: xmlP.XmlNode): ClientCertificateRevocationListStatus {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as ClientCertificateRevocationListStatusCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type ClientCertificateRevocationListStatusCode =
| "pending"
| "active"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Ipv6CidrAssociation {
  Ipv6Cidr?: string | null;
  AssociatedResource?: string | null;
}
function Ipv6CidrAssociation_Parse(node: xmlP.XmlNode): Ipv6CidrAssociation {
  return {
    Ipv6Cidr: node.first("ipv6Cidr", false, x => x.content ?? ''),
    AssociatedResource: node.first("associatedResource", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface InstanceUsage {
  AccountId?: string | null;
  UsedInstanceCount?: number | null;
}
function InstanceUsage_Parse(node: xmlP.XmlNode): InstanceUsage {
  return {
    AccountId: node.first("accountId", false, x => x.content ?? ''),
    UsedInstanceCount: node.first("usedInstanceCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface CoipAddressUsage {
  AllocationId?: string | null;
  AwsAccountId?: string | null;
  AwsService?: string | null;
  CoIp?: string | null;
}
function CoipAddressUsage_Parse(node: xmlP.XmlNode): CoipAddressUsage {
  return {
    AllocationId: node.first("allocationId", false, x => x.content ?? ''),
    AwsAccountId: node.first("awsAccountId", false, x => x.content ?? ''),
    AwsService: node.first("awsService", false, x => x.content ?? ''),
    CoIp: node.first("coIp", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceFamilyCreditSpecification {
  InstanceFamily?: UnlimitedSupportedInstanceFamily | null;
  CpuCredits?: string | null;
}
function InstanceFamilyCreditSpecification_Parse(node: xmlP.XmlNode): InstanceFamilyCreditSpecification {
  return {
    InstanceFamily: node.first("instanceFamily", false, x => (x.content ?? '') as UnlimitedSupportedInstanceFamily),
    CpuCredits: node.first("cpuCredits", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface CapacityReservationGroup {
  GroupArn?: string | null;
  OwnerId?: string | null;
}
function CapacityReservationGroup_Parse(node: xmlP.XmlNode): CapacityReservationGroup {
  return {
    GroupArn: node.first("groupArn", false, x => x.content ?? ''),
    OwnerId: node.first("ownerId", false, x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface Purchase {
  CurrencyCode?: CurrencyCodeValues | null;
  Duration?: number | null;
  HostIdSet: string[];
  HostReservationId?: string | null;
  HourlyPrice?: string | null;
  InstanceFamily?: string | null;
  PaymentOption?: PaymentOption | null;
  UpfrontPrice?: string | null;
}
function Purchase_Parse(node: xmlP.XmlNode): Purchase {
  return {
    CurrencyCode: node.first("currencyCode", false, x => (x.content ?? '') as CurrencyCodeValues),
    Duration: node.first("duration", false, x => parseInt(x.content ?? '0')),
    HostIdSet: node.getList("hostIdSet", "item").map(x => x.content ?? ''),
    HostReservationId: node.first("hostReservationId", false, x => x.content ?? ''),
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    InstanceFamily: node.first("instanceFamily", false, x => x.content ?? ''),
    PaymentOption: node.first("paymentOption", false, x => (x.content ?? '') as PaymentOption),
    UpfrontPrice: node.first("upfrontPrice", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface PrefixListAssociation {
  ResourceId?: string | null;
  ResourceOwner?: string | null;
}
function PrefixListAssociation_Parse(node: xmlP.XmlNode): PrefixListAssociation {
  return {
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceOwner: node.first("resourceOwner", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface PrefixListEntry {
  Cidr?: string | null;
  Description?: string | null;
}
function PrefixListEntry_Parse(node: xmlP.XmlNode): PrefixListEntry {
  return {
    Cidr: node.first("cidr", false, x => x.content ?? ''),
    Description: node.first("description", false, x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface ReservationValue {
  HourlyPrice?: string | null;
  RemainingTotalValue?: string | null;
  RemainingUpfrontValue?: string | null;
}
function ReservationValue_Parse(node: xmlP.XmlNode): ReservationValue {
  return {
    HourlyPrice: node.first("hourlyPrice", false, x => x.content ?? ''),
    RemainingTotalValue: node.first("remainingTotalValue", false, x => x.content ?? ''),
    RemainingUpfrontValue: node.first("remainingUpfrontValue", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedInstanceReservationValue {
  ReservationValue?: ReservationValue | null;
  ReservedInstanceId?: string | null;
}
function ReservedInstanceReservationValue_Parse(node: xmlP.XmlNode): ReservedInstanceReservationValue {
  return {
    ReservationValue: node.first("reservationValue", false, ReservationValue_Parse),
    ReservedInstanceId: node.first("reservedInstanceId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetReservationValue {
  ReservationValue?: ReservationValue | null;
  TargetConfiguration?: TargetConfiguration | null;
}
function TargetReservationValue_Parse(node: xmlP.XmlNode): TargetReservationValue {
  return {
    ReservationValue: node.first("reservationValue", false, ReservationValue_Parse),
    TargetConfiguration: node.first("targetConfiguration", false, TargetConfiguration_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetConfiguration {
  InstanceCount?: number | null;
  OfferingId?: string | null;
}
function TargetConfiguration_Parse(node: xmlP.XmlNode): TargetConfiguration {
  return {
    InstanceCount: node.first("instanceCount", false, x => parseInt(x.content ?? '0')),
    OfferingId: node.first("offeringId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayAttachmentPropagation {
  TransitGatewayRouteTableId?: string | null;
  State?: TransitGatewayPropagationState | null;
}
function TransitGatewayAttachmentPropagation_Parse(node: xmlP.XmlNode): TransitGatewayAttachmentPropagation {
  return {
    TransitGatewayRouteTableId: node.first("transitGatewayRouteTableId", false, x => x.content ?? ''),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayPropagationState),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastDomainAssociation {
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  Subnet?: SubnetAssociation | null;
}
function TransitGatewayMulticastDomainAssociation_Parse(node: xmlP.XmlNode): TransitGatewayMulticastDomainAssociation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    Subnet: node.first("subnet", false, SubnetAssociation_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayRouteTableAssociation {
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  State?: TransitGatewayAssociationState | null;
}
function TransitGatewayRouteTableAssociation_Parse(node: xmlP.XmlNode): TransitGatewayRouteTableAssociation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayAssociationState),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayRouteTablePropagation {
  TransitGatewayAttachmentId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  State?: TransitGatewayPropagationState | null;
}
function TransitGatewayRouteTablePropagation_Parse(node: xmlP.XmlNode): TransitGatewayRouteTablePropagation {
  return {
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    State: node.first("state", false, x => (x.content ?? '') as TransitGatewayPropagationState),
  };
}

// refs: 1 - tags: output, named, interface
export interface SuccessfulInstanceCreditSpecificationItem {
  InstanceId?: string | null;
}
function SuccessfulInstanceCreditSpecificationItem_Parse(node: xmlP.XmlNode): SuccessfulInstanceCreditSpecificationItem {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface UnsuccessfulInstanceCreditSpecificationItem {
  InstanceId?: string | null;
  Error?: UnsuccessfulInstanceCreditSpecificationItemError | null;
}
function UnsuccessfulInstanceCreditSpecificationItem_Parse(node: xmlP.XmlNode): UnsuccessfulInstanceCreditSpecificationItem {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Error: node.first("error", false, UnsuccessfulInstanceCreditSpecificationItemError_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface UnsuccessfulInstanceCreditSpecificationItemError {
  Code?: UnsuccessfulInstanceCreditSpecificationErrorCode | null;
  Message?: string | null;
}
function UnsuccessfulInstanceCreditSpecificationItemError_Parse(node: xmlP.XmlNode): UnsuccessfulInstanceCreditSpecificationItemError {
  return {
    Code: node.first("code", false, x => (x.content ?? '') as UnsuccessfulInstanceCreditSpecificationErrorCode),
    Message: node.first("message", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, enum
export type UnsuccessfulInstanceCreditSpecificationErrorCode =
| "InvalidInstanceID.Malformed"
| "InvalidInstanceID.NotFound"
| "IncorrectInstanceState"
| "InstanceCreditSpecification.NotSupported"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface PeeringConnectionOptions {
  AllowDnsResolutionFromRemoteVpc?: boolean | null;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean | null;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean | null;
}
function PeeringConnectionOptions_Parse(node: xmlP.XmlNode): PeeringConnectionOptions {
  return {
    AllowDnsResolutionFromRemoteVpc: node.first("allowDnsResolutionFromRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalClassicLinkToRemoteVpc: node.first("allowEgressFromLocalClassicLinkToRemoteVpc", false, x => x.content === 'true'),
    AllowEgressFromLocalVpcToRemoteClassicLink: node.first("allowEgressFromLocalVpcToRemoteClassicLink", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface InstanceMonitoring {
  InstanceId?: string | null;
  Monitoring?: Monitoring | null;
}
function InstanceMonitoring_Parse(node: xmlP.XmlNode): InstanceMonitoring {
  return {
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    Monitoring: node.first("monitoring", false, Monitoring_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type Status =
| "MoveInProgress"
| "InVpc"
| "InClassic"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastRegisteredGroupMembers {
  TransitGatewayMulticastDomainId?: string | null;
  RegisteredNetworkInterfaceIds: string[];
  GroupIpAddress?: string | null;
}
function TransitGatewayMulticastRegisteredGroupMembers_Parse(node: xmlP.XmlNode): TransitGatewayMulticastRegisteredGroupMembers {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    RegisteredNetworkInterfaceIds: node.getList("registeredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastRegisteredGroupSources {
  TransitGatewayMulticastDomainId?: string | null;
  RegisteredNetworkInterfaceIds: string[];
  GroupIpAddress?: string | null;
}
function TransitGatewayMulticastRegisteredGroupSources_Parse(node: xmlP.XmlNode): TransitGatewayMulticastRegisteredGroupSources {
  return {
    TransitGatewayMulticastDomainId: node.first("transitGatewayMulticastDomainId", false, x => x.content ?? ''),
    RegisteredNetworkInterfaceIds: node.getList("registeredNetworkInterfaceIds", "item").map(x => x.content ?? ''),
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface TransitGatewayMulticastGroup {
  GroupIpAddress?: string | null;
  TransitGatewayAttachmentId?: string | null;
  SubnetId?: string | null;
  ResourceId?: string | null;
  ResourceType?: TransitGatewayAttachmentResourceType | null;
  NetworkInterfaceId?: string | null;
  GroupMember?: boolean | null;
  GroupSource?: boolean | null;
  MemberType?: MembershipType | null;
  SourceType?: MembershipType | null;
}
function TransitGatewayMulticastGroup_Parse(node: xmlP.XmlNode): TransitGatewayMulticastGroup {
  return {
    GroupIpAddress: node.first("groupIpAddress", false, x => x.content ?? ''),
    TransitGatewayAttachmentId: node.first("transitGatewayAttachmentId", false, x => x.content ?? ''),
    SubnetId: node.first("subnetId", false, x => x.content ?? ''),
    ResourceId: node.first("resourceId", false, x => x.content ?? ''),
    ResourceType: node.first("resourceType", false, x => (x.content ?? '') as TransitGatewayAttachmentResourceType),
    NetworkInterfaceId: node.first("networkInterfaceId", false, x => x.content ?? ''),
    GroupMember: node.first("groupMember", false, x => x.content === 'true'),
    GroupSource: node.first("groupSource", false, x => x.content === 'true'),
    MemberType: node.first("memberType", false, x => (x.content ?? '') as MembershipType),
    SourceType: node.first("sourceType", false, x => (x.content ?? '') as MembershipType),
  };
}

// refs: 2 - tags: output, named, enum
export type MembershipType =
| "static"
| "igmp"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InstanceStateChange {
  CurrentState?: InstanceState | null;
  InstanceId?: string | null;
  PreviousState?: InstanceState | null;
}
function InstanceStateChange_Parse(node: xmlP.XmlNode): InstanceStateChange {
  return {
    CurrentState: node.first("currentState", false, InstanceState_Parse),
    InstanceId: node.first("instanceId", false, x => x.content ?? ''),
    PreviousState: node.first("previousState", false, InstanceState_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TerminateConnectionStatus {
  ConnectionId?: string | null;
  PreviousStatus?: ClientVpnConnectionStatus | null;
  CurrentStatus?: ClientVpnConnectionStatus | null;
}
function TerminateConnectionStatus_Parse(node: xmlP.XmlNode): TerminateConnectionStatus {
  return {
    ConnectionId: node.first("connectionId", false, x => x.content ?? ''),
    PreviousStatus: node.first("previousStatus", false, ClientVpnConnectionStatus_Parse),
    CurrentStatus: node.first("currentStatus", false, ClientVpnConnectionStatus_Parse),
  };
}
