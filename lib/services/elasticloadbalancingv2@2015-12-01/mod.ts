// Autogenerated API client for: Elastic Load Balancing

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class ELBv2 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ELBv2.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-12-01",
    "endpointPrefix": "elasticloadbalancing",
    "protocol": "query",
    "serviceAbbreviation": "Elastic Load Balancing v2",
    "serviceFullName": "Elastic Load Balancing",
    "serviceId": "Elastic Load Balancing v2",
    "signatureVersion": "v4",
    "uid": "elasticloadbalancingv2-2015-12-01",
    "xmlNamespace": "http://elasticloadbalancing.amazonaws.com/doc/2015-12-01/"
  };

  async addListenerCertificates(
    {abortSignal, ...params}: RequestConfig & AddListenerCertificatesInput,
  ): Promise<AddListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Certificates"]) prt.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddListenerCertificates",
    });
    const xml = readXmlResult(await resp.text(), "AddListenerCertificatesResult");
    return {
      Certificates: xml.getList("Certificates", "member").map(Certificate_Parse),
    };
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) prt.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    const xml = readXmlResult(await resp.text(), "AddTagsResult");
    return {};
  }

  async createListener(
    {abortSignal, ...params}: RequestConfig & CreateListenerInput,
  ): Promise<CreateListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("SslPolicy" in params) body.append(prefix+"SslPolicy", (params["SslPolicy"] ?? '').toString());
    if (params["Certificates"]) prt.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    if (params["DefaultActions"]) prt.appendList(body, prefix+"DefaultActions", params["DefaultActions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["AlpnPolicy"]) prt.appendList(body, prefix+"AlpnPolicy", params["AlpnPolicy"], {"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateListener",
    });
    const xml = readXmlResult(await resp.text(), "CreateListenerResult");
    return {
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async createLoadBalancer(
    {abortSignal, ...params}: RequestConfig & CreateLoadBalancerInput,
  ): Promise<CreateLoadBalancerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if (params["Subnets"]) prt.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    if (params["SubnetMappings"]) prt.appendList(body, prefix+"SubnetMappings", params["SubnetMappings"], {"appender":SubnetMapping_Serialize,"entryPrefix":".member."})
    if (params["SecurityGroups"]) prt.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    if ("Scheme" in params) body.append(prefix+"Scheme", (params["Scheme"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("IpAddressType" in params) body.append(prefix+"IpAddressType", (params["IpAddressType"] ?? '').toString());
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "CreateLoadBalancerResult");
    return {
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancer_Parse),
    };
  }

  async createRule(
    {abortSignal, ...params}: RequestConfig & CreateRuleInput,
  ): Promise<CreateRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Conditions"]) prt.appendList(body, prefix+"Conditions", params["Conditions"], {"appender":RuleCondition_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Priority", (params["Priority"] ?? '').toString());
    if (params["Actions"]) prt.appendList(body, prefix+"Actions", params["Actions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRule",
    });
    const xml = readXmlResult(await resp.text(), "CreateRuleResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async createTargetGroup(
    {abortSignal, ...params}: RequestConfig & CreateTargetGroupInput,
  ): Promise<CreateTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("HealthCheckProtocol" in params) body.append(prefix+"HealthCheckProtocol", (params["HealthCheckProtocol"] ?? '').toString());
    if ("HealthCheckPort" in params) body.append(prefix+"HealthCheckPort", (params["HealthCheckPort"] ?? '').toString());
    if ("HealthCheckEnabled" in params) body.append(prefix+"HealthCheckEnabled", (params["HealthCheckEnabled"] ?? '').toString());
    if ("HealthCheckPath" in params) body.append(prefix+"HealthCheckPath", (params["HealthCheckPath"] ?? '').toString());
    if ("HealthCheckIntervalSeconds" in params) body.append(prefix+"HealthCheckIntervalSeconds", (params["HealthCheckIntervalSeconds"] ?? '').toString());
    if ("HealthCheckTimeoutSeconds" in params) body.append(prefix+"HealthCheckTimeoutSeconds", (params["HealthCheckTimeoutSeconds"] ?? '').toString());
    if ("HealthyThresholdCount" in params) body.append(prefix+"HealthyThresholdCount", (params["HealthyThresholdCount"] ?? '').toString());
    if ("UnhealthyThresholdCount" in params) body.append(prefix+"UnhealthyThresholdCount", (params["UnhealthyThresholdCount"] ?? '').toString());
    if (params["Matcher"] != null) Matcher_Serialize(body, prefix+"Matcher", params["Matcher"]);
    if ("TargetType" in params) body.append(prefix+"TargetType", (params["TargetType"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTargetGroup",
    });
    const xml = readXmlResult(await resp.text(), "CreateTargetGroupResult");
    return {
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async deleteListener(
    {abortSignal, ...params}: RequestConfig & DeleteListenerInput,
  ): Promise<DeleteListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteListener",
    });
    const xml = readXmlResult(await resp.text(), "DeleteListenerResult");
    return {};
  }

  async deleteLoadBalancer(
    {abortSignal, ...params}: RequestConfig & DeleteLoadBalancerInput,
  ): Promise<DeleteLoadBalancerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "DeleteLoadBalancerResult");
    return {};
  }

  async deleteRule(
    {abortSignal, ...params}: RequestConfig & DeleteRuleInput,
  ): Promise<DeleteRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleArn", (params["RuleArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRule",
    });
    const xml = readXmlResult(await resp.text(), "DeleteRuleResult");
    return {};
  }

  async deleteTargetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteTargetGroupInput,
  ): Promise<DeleteTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTargetGroup",
    });
    const xml = readXmlResult(await resp.text(), "DeleteTargetGroupResult");
    return {};
  }

  async deregisterTargets(
    {abortSignal, ...params}: RequestConfig & DeregisterTargetsInput,
  ): Promise<DeregisterTargetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) prt.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTargets",
    });
    const xml = readXmlResult(await resp.text(), "DeregisterTargetsResult");
    return {};
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig & DescribeAccountLimitsInput = {},
  ): Promise<DescribeAccountLimitsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountLimits",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Limits: xml.getList("Limits", "member").map(Limit_Parse),
    };
  }

  async describeListenerCertificates(
    {abortSignal, ...params}: RequestConfig & DescribeListenerCertificatesInput,
  ): Promise<DescribeListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeListenerCertificates",
    });
    const xml = readXmlResult(await resp.text(), "DescribeListenerCertificatesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Certificates: xml.getList("Certificates", "member").map(Certificate_Parse),
    };
  }

  async describeListeners(
    {abortSignal, ...params}: RequestConfig & DescribeListenersInput = {},
  ): Promise<DescribeListenersOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("LoadBalancerArn" in params) body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["ListenerArns"]) prt.appendList(body, prefix+"ListenerArns", params["ListenerArns"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeListeners",
    });
    const xml = readXmlResult(await resp.text(), "DescribeListenersResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async describeLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancerAttributesInput,
  ): Promise<DescribeLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancerAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(LoadBalancerAttribute_Parse),
    };
  }

  async describeLoadBalancers(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancersInput = {},
  ): Promise<DescribeLoadBalancersOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerArns"]) prt.appendList(body, prefix+"LoadBalancerArns", params["LoadBalancerArns"], {"entryPrefix":".member."})
    if (params["Names"]) prt.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancers",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancersResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancer_Parse),
    };
  }

  async describeRules(
    {abortSignal, ...params}: RequestConfig & DescribeRulesInput = {},
  ): Promise<DescribeRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ListenerArn" in params) body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["RuleArns"]) prt.appendList(body, prefix+"RuleArns", params["RuleArns"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRules",
    });
    const xml = readXmlResult(await resp.text(), "DescribeRulesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async describeSSLPolicies(
    {abortSignal, ...params}: RequestConfig & DescribeSSLPoliciesInput = {},
  ): Promise<DescribeSSLPoliciesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Names"]) prt.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSSLPolicies",
    });
    const xml = readXmlResult(await resp.text(), "DescribeSSLPoliciesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      SslPolicies: xml.getList("SslPolicies", "member").map(SslPolicy_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsInput,
  ): Promise<DescribeTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) prt.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      TagDescriptions: xml.getList("TagDescriptions", "member").map(TagDescription_Parse),
    };
  }

  async describeTargetGroupAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeTargetGroupAttributesInput,
  ): Promise<DescribeTargetGroupAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetGroupAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeTargetGroupAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(TargetGroupAttribute_Parse),
    };
  }

  async describeTargetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeTargetGroupsInput = {},
  ): Promise<DescribeTargetGroupsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("LoadBalancerArn" in params) body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["TargetGroupArns"]) prt.appendList(body, prefix+"TargetGroupArns", params["TargetGroupArns"], {"entryPrefix":".member."})
    if (params["Names"]) prt.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetGroups",
    });
    const xml = readXmlResult(await resp.text(), "DescribeTargetGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async describeTargetHealth(
    {abortSignal, ...params}: RequestConfig & DescribeTargetHealthInput,
  ): Promise<DescribeTargetHealthOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) prt.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetHealth",
    });
    const xml = readXmlResult(await resp.text(), "DescribeTargetHealthResult");
    return {
      TargetHealthDescriptions: xml.getList("TargetHealthDescriptions", "member").map(TargetHealthDescription_Parse),
    };
  }

  async modifyListener(
    {abortSignal, ...params}: RequestConfig & ModifyListenerInput,
  ): Promise<ModifyListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("SslPolicy" in params) body.append(prefix+"SslPolicy", (params["SslPolicy"] ?? '').toString());
    if (params["Certificates"]) prt.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    if (params["DefaultActions"]) prt.appendList(body, prefix+"DefaultActions", params["DefaultActions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["AlpnPolicy"]) prt.appendList(body, prefix+"AlpnPolicy", params["AlpnPolicy"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyListener",
    });
    const xml = readXmlResult(await resp.text(), "ModifyListenerResult");
    return {
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async modifyLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & ModifyLoadBalancerAttributesInput,
  ): Promise<ModifyLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["Attributes"]) prt.appendList(body, prefix+"Attributes", params["Attributes"], {"appender":LoadBalancerAttribute_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyLoadBalancerAttributes",
    });
    const xml = readXmlResult(await resp.text(), "ModifyLoadBalancerAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(LoadBalancerAttribute_Parse),
    };
  }

  async modifyRule(
    {abortSignal, ...params}: RequestConfig & ModifyRuleInput,
  ): Promise<ModifyRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleArn", (params["RuleArn"] ?? '').toString());
    if (params["Conditions"]) prt.appendList(body, prefix+"Conditions", params["Conditions"], {"appender":RuleCondition_Serialize,"entryPrefix":".member."})
    if (params["Actions"]) prt.appendList(body, prefix+"Actions", params["Actions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyRule",
    });
    const xml = readXmlResult(await resp.text(), "ModifyRuleResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async modifyTargetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyTargetGroupInput,
  ): Promise<ModifyTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if ("HealthCheckProtocol" in params) body.append(prefix+"HealthCheckProtocol", (params["HealthCheckProtocol"] ?? '').toString());
    if ("HealthCheckPort" in params) body.append(prefix+"HealthCheckPort", (params["HealthCheckPort"] ?? '').toString());
    if ("HealthCheckPath" in params) body.append(prefix+"HealthCheckPath", (params["HealthCheckPath"] ?? '').toString());
    if ("HealthCheckEnabled" in params) body.append(prefix+"HealthCheckEnabled", (params["HealthCheckEnabled"] ?? '').toString());
    if ("HealthCheckIntervalSeconds" in params) body.append(prefix+"HealthCheckIntervalSeconds", (params["HealthCheckIntervalSeconds"] ?? '').toString());
    if ("HealthCheckTimeoutSeconds" in params) body.append(prefix+"HealthCheckTimeoutSeconds", (params["HealthCheckTimeoutSeconds"] ?? '').toString());
    if ("HealthyThresholdCount" in params) body.append(prefix+"HealthyThresholdCount", (params["HealthyThresholdCount"] ?? '').toString());
    if ("UnhealthyThresholdCount" in params) body.append(prefix+"UnhealthyThresholdCount", (params["UnhealthyThresholdCount"] ?? '').toString());
    if (params["Matcher"] != null) Matcher_Serialize(body, prefix+"Matcher", params["Matcher"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTargetGroup",
    });
    const xml = readXmlResult(await resp.text(), "ModifyTargetGroupResult");
    return {
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async modifyTargetGroupAttributes(
    {abortSignal, ...params}: RequestConfig & ModifyTargetGroupAttributesInput,
  ): Promise<ModifyTargetGroupAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Attributes"]) prt.appendList(body, prefix+"Attributes", params["Attributes"], {"appender":TargetGroupAttribute_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTargetGroupAttributes",
    });
    const xml = readXmlResult(await resp.text(), "ModifyTargetGroupAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(TargetGroupAttribute_Parse),
    };
  }

  async registerTargets(
    {abortSignal, ...params}: RequestConfig & RegisterTargetsInput,
  ): Promise<RegisterTargetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) prt.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTargets",
    });
    const xml = readXmlResult(await resp.text(), "RegisterTargetsResult");
    return {};
  }

  async removeListenerCertificates(
    {abortSignal, ...params}: RequestConfig & RemoveListenerCertificatesInput,
  ): Promise<RemoveListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Certificates"]) prt.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveListenerCertificates",
    });
    const xml = readXmlResult(await resp.text(), "RemoveListenerCertificatesResult");
    return {};
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & RemoveTagsInput,
  ): Promise<RemoveTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) prt.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if (params["TagKeys"]) prt.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    const xml = readXmlResult(await resp.text(), "RemoveTagsResult");
    return {};
  }

  async setIpAddressType(
    {abortSignal, ...params}: RequestConfig & SetIpAddressTypeInput,
  ): Promise<SetIpAddressTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    body.append(prefix+"IpAddressType", (params["IpAddressType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIpAddressType",
    });
    const xml = readXmlResult(await resp.text(), "SetIpAddressTypeResult");
    return {
      IpAddressType: xml.first("IpAddressType", false, x => (x.content ?? '') as IpAddressType),
    };
  }

  async setRulePriorities(
    {abortSignal, ...params}: RequestConfig & SetRulePrioritiesInput,
  ): Promise<SetRulePrioritiesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RulePriorities"]) prt.appendList(body, prefix+"RulePriorities", params["RulePriorities"], {"appender":RulePriorityPair_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetRulePriorities",
    });
    const xml = readXmlResult(await resp.text(), "SetRulePrioritiesResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async setSecurityGroups(
    {abortSignal, ...params}: RequestConfig & SetSecurityGroupsInput,
  ): Promise<SetSecurityGroupsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["SecurityGroups"]) prt.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSecurityGroups",
    });
    const xml = readXmlResult(await resp.text(), "SetSecurityGroupsResult");
    return {
      SecurityGroupIds: xml.getList("SecurityGroupIds", "member").map(x => x.content ?? ''),
    };
  }

  async setSubnets(
    {abortSignal, ...params}: RequestConfig & SetSubnetsInput,
  ): Promise<SetSubnetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["Subnets"]) prt.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    if (params["SubnetMappings"]) prt.appendList(body, prefix+"SubnetMappings", params["SubnetMappings"], {"appender":SubnetMapping_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSubnets",
    });
    const xml = readXmlResult(await resp.text(), "SetSubnetsResult");
    return {
      AvailabilityZones: xml.getList("AvailabilityZones", "member").map(AvailabilityZone_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancerExists(
    params: RequestConfig & DescribeLoadBalancersInput,
  ): Promise<DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancerExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        return resp; // for status 200
      } catch (err) {
        if (!["LoadBalancerNotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancerAvailable(
    params: RequestConfig & DescribeLoadBalancersInput,
  ): Promise<DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancerAvailable';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        const field = resp["LoadBalancers"].flatMap(x => x["State"]?.["Code"]);
        if (field.every(x => x === "active")) return resp;
        if (field.some(x => x === "provisioning")) continue;
      } catch (err) {
        if (!["LoadBalancerNotFound"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancersDeleted(
    params: RequestConfig & DescribeLoadBalancersInput,
  ): Promise<Error | DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancersDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        if (resp["LoadBalancers"].flatMap(x => x["State"]?.["Code"]).every(x => x === "active")) continue;
      } catch (err) {
        if (["LoadBalancerNotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForTargetInService(
    params: RequestConfig & DescribeTargetHealthInput,
  ): Promise<DescribeTargetHealthOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TargetInService';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeTargetHealth(params);
        if (resp["TargetHealthDescriptions"].flatMap(x => x["TargetHealth"]?.["State"]).every(x => x === "healthy")) return resp;
      } catch (err) {
        if (!["InvalidInstance"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForTargetDeregistered(
    params: RequestConfig & DescribeTargetHealthInput,
  ): Promise<Error | DescribeTargetHealthOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TargetDeregistered';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeTargetHealth(params);
        if (resp["TargetHealthDescriptions"].flatMap(x => x["TargetHealth"]?.["State"]).every(x => x === "unused")) return resp;
      } catch (err) {
        if (["InvalidTarget"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddListenerCertificatesInput {
  ListenerArn: string;
  Certificates: Certificate[];
}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  ResourceArns: string[];
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface CreateListenerInput {
  LoadBalancerArn: string;
  Protocol: ProtocolEnum;
  Port: number;
  SslPolicy?: string | null;
  Certificates?: Certificate[] | null;
  DefaultActions: Action[];
  AlpnPolicy?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateLoadBalancerInput {
  Name: string;
  Subnets?: string[] | null;
  SubnetMappings?: SubnetMapping[] | null;
  SecurityGroups?: string[] | null;
  Scheme?: LoadBalancerSchemeEnum | null;
  Tags?: Tag[] | null;
  Type?: LoadBalancerTypeEnum | null;
  IpAddressType?: IpAddressType | null;
  CustomerOwnedIpv4Pool?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateRuleInput {
  ListenerArn: string;
  Conditions: RuleCondition[];
  Priority: number;
  Actions: Action[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTargetGroupInput {
  Name: string;
  Protocol?: ProtocolEnum | null;
  Port?: number | null;
  VpcId?: string | null;
  HealthCheckProtocol?: ProtocolEnum | null;
  HealthCheckPort?: string | null;
  HealthCheckEnabled?: boolean | null;
  HealthCheckPath?: string | null;
  HealthCheckIntervalSeconds?: number | null;
  HealthCheckTimeoutSeconds?: number | null;
  HealthyThresholdCount?: number | null;
  UnhealthyThresholdCount?: number | null;
  Matcher?: Matcher | null;
  TargetType?: TargetTypeEnum | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteListenerInput {
  ListenerArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteLoadBalancerInput {
  LoadBalancerArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteRuleInput {
  RuleArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteTargetGroupInput {
  TargetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DeregisterTargetsInput {
  TargetGroupArn: string;
  Targets: TargetDescription[];
}

// refs: 1 - tags: named, input
export interface DescribeAccountLimitsInput {
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeListenerCertificatesInput {
  ListenerArn: string;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeListenersInput {
  LoadBalancerArn?: string | null;
  ListenerArns?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancerAttributesInput {
  LoadBalancerArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancersInput {
  LoadBalancerArns?: string[] | null;
  Names?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeRulesInput {
  ListenerArn?: string | null;
  RuleArns?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeSSLPoliciesInput {
  Names?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsInput {
  ResourceArns: string[];
}

// refs: 1 - tags: named, input
export interface DescribeTargetGroupAttributesInput {
  TargetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeTargetGroupsInput {
  LoadBalancerArn?: string | null;
  TargetGroupArns?: string[] | null;
  Names?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTargetHealthInput {
  TargetGroupArn: string;
  Targets?: TargetDescription[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyListenerInput {
  ListenerArn: string;
  Port?: number | null;
  Protocol?: ProtocolEnum | null;
  SslPolicy?: string | null;
  Certificates?: Certificate[] | null;
  DefaultActions?: Action[] | null;
  AlpnPolicy?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyLoadBalancerAttributesInput {
  LoadBalancerArn: string;
  Attributes: LoadBalancerAttribute[];
}

// refs: 1 - tags: named, input
export interface ModifyRuleInput {
  RuleArn: string;
  Conditions?: RuleCondition[] | null;
  Actions?: Action[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyTargetGroupInput {
  TargetGroupArn: string;
  HealthCheckProtocol?: ProtocolEnum | null;
  HealthCheckPort?: string | null;
  HealthCheckPath?: string | null;
  HealthCheckEnabled?: boolean | null;
  HealthCheckIntervalSeconds?: number | null;
  HealthCheckTimeoutSeconds?: number | null;
  HealthyThresholdCount?: number | null;
  UnhealthyThresholdCount?: number | null;
  Matcher?: Matcher | null;
}

// refs: 1 - tags: named, input
export interface ModifyTargetGroupAttributesInput {
  TargetGroupArn: string;
  Attributes: TargetGroupAttribute[];
}

// refs: 1 - tags: named, input
export interface RegisterTargetsInput {
  TargetGroupArn: string;
  Targets: TargetDescription[];
}

// refs: 1 - tags: named, input
export interface RemoveListenerCertificatesInput {
  ListenerArn: string;
  Certificates: Certificate[];
}

// refs: 1 - tags: named, input
export interface RemoveTagsInput {
  ResourceArns: string[];
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface SetIpAddressTypeInput {
  LoadBalancerArn: string;
  IpAddressType: IpAddressType;
}

// refs: 1 - tags: named, input
export interface SetRulePrioritiesInput {
  RulePriorities: RulePriorityPair[];
}

// refs: 1 - tags: named, input
export interface SetSecurityGroupsInput {
  LoadBalancerArn: string;
  SecurityGroups: string[];
}

// refs: 1 - tags: named, input
export interface SetSubnetsInput {
  LoadBalancerArn: string;
  Subnets?: string[] | null;
  SubnetMappings?: SubnetMapping[] | null;
}

// refs: 1 - tags: named, output
export interface AddListenerCertificatesOutput {
  Certificates: Certificate[];
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
}

// refs: 1 - tags: named, output
export interface CreateListenerOutput {
  Listeners: Listener[];
}

// refs: 1 - tags: named, output
export interface CreateLoadBalancerOutput {
  LoadBalancers: LoadBalancer[];
}

// refs: 1 - tags: named, output
export interface CreateRuleOutput {
  Rules: Rule[];
}

// refs: 1 - tags: named, output
export interface CreateTargetGroupOutput {
  TargetGroups: TargetGroup[];
}

// refs: 1 - tags: named, output
export interface DeleteListenerOutput {
}

// refs: 1 - tags: named, output
export interface DeleteLoadBalancerOutput {
}

// refs: 1 - tags: named, output
export interface DeleteRuleOutput {
}

// refs: 1 - tags: named, output
export interface DeleteTargetGroupOutput {
}

// refs: 1 - tags: named, output
export interface DeregisterTargetsOutput {
}

// refs: 1 - tags: named, output
export interface DescribeAccountLimitsOutput {
  Limits: Limit[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeListenerCertificatesOutput {
  Certificates: Certificate[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeListenersOutput {
  Listeners: Listener[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancerAttributesOutput {
  Attributes: LoadBalancerAttribute[];
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancersOutput {
  LoadBalancers: LoadBalancer[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRulesOutput {
  Rules: Rule[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSSLPoliciesOutput {
  SslPolicies: SslPolicy[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTagsOutput {
  TagDescriptions: TagDescription[];
}

// refs: 1 - tags: named, output
export interface DescribeTargetGroupAttributesOutput {
  Attributes: TargetGroupAttribute[];
}

// refs: 1 - tags: named, output
export interface DescribeTargetGroupsOutput {
  TargetGroups: TargetGroup[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTargetHealthOutput {
  TargetHealthDescriptions: TargetHealthDescription[];
}

// refs: 1 - tags: named, output
export interface ModifyListenerOutput {
  Listeners: Listener[];
}

// refs: 1 - tags: named, output
export interface ModifyLoadBalancerAttributesOutput {
  Attributes: LoadBalancerAttribute[];
}

// refs: 1 - tags: named, output
export interface ModifyRuleOutput {
  Rules: Rule[];
}

// refs: 1 - tags: named, output
export interface ModifyTargetGroupOutput {
  TargetGroups: TargetGroup[];
}

// refs: 1 - tags: named, output
export interface ModifyTargetGroupAttributesOutput {
  Attributes: TargetGroupAttribute[];
}

// refs: 1 - tags: named, output
export interface RegisterTargetsOutput {
}

// refs: 1 - tags: named, output
export interface RemoveListenerCertificatesOutput {
}

// refs: 1 - tags: named, output
export interface RemoveTagsOutput {
}

// refs: 1 - tags: named, output
export interface SetIpAddressTypeOutput {
  IpAddressType?: IpAddressType | null;
}

// refs: 1 - tags: named, output
export interface SetRulePrioritiesOutput {
  Rules: Rule[];
}

// refs: 1 - tags: named, output
export interface SetSecurityGroupsOutput {
  SecurityGroupIds: string[];
}

// refs: 1 - tags: named, output
export interface SetSubnetsOutput {
  AvailabilityZones: AvailabilityZone[];
}

// refs: 9 - tags: input, named, interface, output
export interface Certificate {
  CertificateArn?: string | null;
  IsDefault?: boolean | null;
}
function Certificate_Serialize(body: URLSearchParams, prefix: string, params: Certificate) {
    if ("CertificateArn" in params) body.append(prefix+".CertificateArn", (params["CertificateArn"] ?? '').toString());
    if ("IsDefault" in params) body.append(prefix+".IsDefault", (params["IsDefault"] ?? '').toString());
}
function Certificate_Parse(node: XmlNode): Certificate {
  return {
    ...node.strings({
      optional: {"CertificateArn":true},
    }),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: XmlNode): Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

// refs: 14 - tags: input, named, enum, output
export type ProtocolEnum =
| "HTTP"
| "HTTPS"
| "TCP"
| "TLS"
| "UDP"
| "TCP_UDP"
;



// refs: 11 - tags: input, named, interface, output
export interface Action {
  Type: ActionTypeEnum;
  TargetGroupArn?: string | null;
  AuthenticateOidcConfig?: AuthenticateOidcActionConfig | null;
  AuthenticateCognitoConfig?: AuthenticateCognitoActionConfig | null;
  Order?: number | null;
  RedirectConfig?: RedirectActionConfig | null;
  FixedResponseConfig?: FixedResponseActionConfig | null;
  ForwardConfig?: ForwardActionConfig | null;
}
function Action_Serialize(body: URLSearchParams, prefix: string, params: Action) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("TargetGroupArn" in params) body.append(prefix+".TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["AuthenticateOidcConfig"] != null) AuthenticateOidcActionConfig_Serialize(body, prefix+".AuthenticateOidcConfig", params["AuthenticateOidcConfig"]);
    if (params["AuthenticateCognitoConfig"] != null) AuthenticateCognitoActionConfig_Serialize(body, prefix+".AuthenticateCognitoConfig", params["AuthenticateCognitoConfig"]);
    if ("Order" in params) body.append(prefix+".Order", (params["Order"] ?? '').toString());
    if (params["RedirectConfig"] != null) RedirectActionConfig_Serialize(body, prefix+".RedirectConfig", params["RedirectConfig"]);
    if (params["FixedResponseConfig"] != null) FixedResponseActionConfig_Serialize(body, prefix+".FixedResponseConfig", params["FixedResponseConfig"]);
    if (params["ForwardConfig"] != null) ForwardActionConfig_Serialize(body, prefix+".ForwardConfig", params["ForwardConfig"]);
}
function Action_Parse(node: XmlNode): Action {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as ActionTypeEnum),
    AuthenticateOidcConfig: node.first("AuthenticateOidcConfig", false, AuthenticateOidcActionConfig_Parse),
    AuthenticateCognitoConfig: node.first("AuthenticateCognitoConfig", false, AuthenticateCognitoActionConfig_Parse),
    Order: node.first("Order", false, x => parseInt(x.content ?? '0')),
    RedirectConfig: node.first("RedirectConfig", false, RedirectActionConfig_Parse),
    FixedResponseConfig: node.first("FixedResponseConfig", false, FixedResponseActionConfig_Parse),
    ForwardConfig: node.first("ForwardConfig", false, ForwardActionConfig_Parse),
  };
}

// refs: 11 - tags: input, named, enum, output
export type ActionTypeEnum =
| "forward"
| "authenticate-oidc"
| "authenticate-cognito"
| "redirect"
| "fixed-response"
;



// refs: 11 - tags: input, named, interface, output
export interface AuthenticateOidcActionConfig {
  Issuer: string;
  AuthorizationEndpoint: string;
  TokenEndpoint: string;
  UserInfoEndpoint: string;
  ClientId: string;
  ClientSecret?: string | null;
  SessionCookieName?: string | null;
  Scope?: string | null;
  SessionTimeout?: number | null;
  AuthenticationRequestExtraParams: { [key: string]: string };
  OnUnauthenticatedRequest?: AuthenticateOidcActionConditionalBehaviorEnum | null;
  UseExistingClientSecret?: boolean | null;
}
function AuthenticateOidcActionConfig_Serialize(body: URLSearchParams, prefix: string, params: AuthenticateOidcActionConfig) {
    body.append(prefix+".Issuer", (params["Issuer"] ?? '').toString());
    body.append(prefix+".AuthorizationEndpoint", (params["AuthorizationEndpoint"] ?? '').toString());
    body.append(prefix+".TokenEndpoint", (params["TokenEndpoint"] ?? '').toString());
    body.append(prefix+".UserInfoEndpoint", (params["UserInfoEndpoint"] ?? '').toString());
    body.append(prefix+".ClientId", (params["ClientId"] ?? '').toString());
    if ("ClientSecret" in params) body.append(prefix+".ClientSecret", (params["ClientSecret"] ?? '').toString());
    if ("SessionCookieName" in params) body.append(prefix+".SessionCookieName", (params["SessionCookieName"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
    if ("SessionTimeout" in params) body.append(prefix+".SessionTimeout", (params["SessionTimeout"] ?? '').toString());
    if (params["AuthenticationRequestExtraParams"]) prt.appendMap(body, prefix+".AuthenticationRequestExtraParams", params["AuthenticationRequestExtraParams"], {"entryPrefix":".entry."})
    if ("OnUnauthenticatedRequest" in params) body.append(prefix+".OnUnauthenticatedRequest", (params["OnUnauthenticatedRequest"] ?? '').toString());
    if ("UseExistingClientSecret" in params) body.append(prefix+".UseExistingClientSecret", (params["UseExistingClientSecret"] ?? '').toString());
}
function AuthenticateOidcActionConfig_Parse(node: XmlNode): AuthenticateOidcActionConfig {
  return {
    ...node.strings({
      required: {"Issuer":true,"AuthorizationEndpoint":true,"TokenEndpoint":true,"UserInfoEndpoint":true,"ClientId":true},
      optional: {"ClientSecret":true,"SessionCookieName":true,"Scope":true},
    }),
    SessionTimeout: node.first("SessionTimeout", false, x => parseInt(x.content ?? '0')),
    AuthenticationRequestExtraParams: readXmlMap(node.getList("AuthenticationRequestExtraParams", "entry"), x => x.content ?? '', {}),
    OnUnauthenticatedRequest: node.first("OnUnauthenticatedRequest", false, x => (x.content ?? '') as AuthenticateOidcActionConditionalBehaviorEnum),
    UseExistingClientSecret: node.first("UseExistingClientSecret", false, x => x.content === 'true'),
  };
}

// refs: 11 - tags: input, named, enum, output
export type AuthenticateOidcActionConditionalBehaviorEnum =
| "deny"
| "allow"
| "authenticate"
;



// refs: 11 - tags: input, named, interface, output
export interface AuthenticateCognitoActionConfig {
  UserPoolArn: string;
  UserPoolClientId: string;
  UserPoolDomain: string;
  SessionCookieName?: string | null;
  Scope?: string | null;
  SessionTimeout?: number | null;
  AuthenticationRequestExtraParams: { [key: string]: string };
  OnUnauthenticatedRequest?: AuthenticateCognitoActionConditionalBehaviorEnum | null;
}
function AuthenticateCognitoActionConfig_Serialize(body: URLSearchParams, prefix: string, params: AuthenticateCognitoActionConfig) {
    body.append(prefix+".UserPoolArn", (params["UserPoolArn"] ?? '').toString());
    body.append(prefix+".UserPoolClientId", (params["UserPoolClientId"] ?? '').toString());
    body.append(prefix+".UserPoolDomain", (params["UserPoolDomain"] ?? '').toString());
    if ("SessionCookieName" in params) body.append(prefix+".SessionCookieName", (params["SessionCookieName"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
    if ("SessionTimeout" in params) body.append(prefix+".SessionTimeout", (params["SessionTimeout"] ?? '').toString());
    if (params["AuthenticationRequestExtraParams"]) prt.appendMap(body, prefix+".AuthenticationRequestExtraParams", params["AuthenticationRequestExtraParams"], {"entryPrefix":".entry."})
    if ("OnUnauthenticatedRequest" in params) body.append(prefix+".OnUnauthenticatedRequest", (params["OnUnauthenticatedRequest"] ?? '').toString());
}
function AuthenticateCognitoActionConfig_Parse(node: XmlNode): AuthenticateCognitoActionConfig {
  return {
    ...node.strings({
      required: {"UserPoolArn":true,"UserPoolClientId":true,"UserPoolDomain":true},
      optional: {"SessionCookieName":true,"Scope":true},
    }),
    SessionTimeout: node.first("SessionTimeout", false, x => parseInt(x.content ?? '0')),
    AuthenticationRequestExtraParams: readXmlMap(node.getList("AuthenticationRequestExtraParams", "entry"), x => x.content ?? '', {}),
    OnUnauthenticatedRequest: node.first("OnUnauthenticatedRequest", false, x => (x.content ?? '') as AuthenticateCognitoActionConditionalBehaviorEnum),
  };
}

// refs: 11 - tags: input, named, enum, output
export type AuthenticateCognitoActionConditionalBehaviorEnum =
| "deny"
| "allow"
| "authenticate"
;



// refs: 11 - tags: input, named, interface, output
export interface RedirectActionConfig {
  Protocol?: string | null;
  Port?: string | null;
  Host?: string | null;
  Path?: string | null;
  Query?: string | null;
  StatusCode: RedirectActionStatusCodeEnum;
}
function RedirectActionConfig_Serialize(body: URLSearchParams, prefix: string, params: RedirectActionConfig) {
    if ("Protocol" in params) body.append(prefix+".Protocol", (params["Protocol"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if ("Host" in params) body.append(prefix+".Host", (params["Host"] ?? '').toString());
    if ("Path" in params) body.append(prefix+".Path", (params["Path"] ?? '').toString());
    if ("Query" in params) body.append(prefix+".Query", (params["Query"] ?? '').toString());
    body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
}
function RedirectActionConfig_Parse(node: XmlNode): RedirectActionConfig {
  return {
    ...node.strings({
      optional: {"Protocol":true,"Port":true,"Host":true,"Path":true,"Query":true},
    }),
    StatusCode: node.first("StatusCode", true, x => (x.content ?? '') as RedirectActionStatusCodeEnum),
  };
}

// refs: 11 - tags: input, named, enum, output
export type RedirectActionStatusCodeEnum =
| "HTTP_301"
| "HTTP_302"
;



// refs: 11 - tags: input, named, interface, output
export interface FixedResponseActionConfig {
  MessageBody?: string | null;
  StatusCode: string;
  ContentType?: string | null;
}
function FixedResponseActionConfig_Serialize(body: URLSearchParams, prefix: string, params: FixedResponseActionConfig) {
    if ("MessageBody" in params) body.append(prefix+".MessageBody", (params["MessageBody"] ?? '').toString());
    body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
    if ("ContentType" in params) body.append(prefix+".ContentType", (params["ContentType"] ?? '').toString());
}
function FixedResponseActionConfig_Parse(node: XmlNode): FixedResponseActionConfig {
  return node.strings({
    required: {"StatusCode":true},
    optional: {"MessageBody":true,"ContentType":true},
  });
}

// refs: 11 - tags: input, named, interface, output
export interface ForwardActionConfig {
  TargetGroups: TargetGroupTuple[];
  TargetGroupStickinessConfig?: TargetGroupStickinessConfig | null;
}
function ForwardActionConfig_Serialize(body: URLSearchParams, prefix: string, params: ForwardActionConfig) {
    if (params["TargetGroups"]) prt.appendList(body, prefix+".TargetGroups", params["TargetGroups"], {"appender":TargetGroupTuple_Serialize,"entryPrefix":".member."})
    if (params["TargetGroupStickinessConfig"] != null) TargetGroupStickinessConfig_Serialize(body, prefix+".TargetGroupStickinessConfig", params["TargetGroupStickinessConfig"]);
}
function ForwardActionConfig_Parse(node: XmlNode): ForwardActionConfig {
  return {
    TargetGroups: node.getList("TargetGroups", "member").map(TargetGroupTuple_Parse),
    TargetGroupStickinessConfig: node.first("TargetGroupStickinessConfig", false, TargetGroupStickinessConfig_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface TargetGroupTuple {
  TargetGroupArn?: string | null;
  Weight?: number | null;
}
function TargetGroupTuple_Serialize(body: URLSearchParams, prefix: string, params: TargetGroupTuple) {
    if ("TargetGroupArn" in params) body.append(prefix+".TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if ("Weight" in params) body.append(prefix+".Weight", (params["Weight"] ?? '').toString());
}
function TargetGroupTuple_Parse(node: XmlNode): TargetGroupTuple {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true},
    }),
    Weight: node.first("Weight", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface TargetGroupStickinessConfig {
  Enabled?: boolean | null;
  DurationSeconds?: number | null;
}
function TargetGroupStickinessConfig_Serialize(body: URLSearchParams, prefix: string, params: TargetGroupStickinessConfig) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("DurationSeconds" in params) body.append(prefix+".DurationSeconds", (params["DurationSeconds"] ?? '').toString());
}
function TargetGroupStickinessConfig_Parse(node: XmlNode): TargetGroupStickinessConfig {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    DurationSeconds: node.first("DurationSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface
export interface SubnetMapping {
  SubnetId?: string | null;
  AllocationId?: string | null;
  PrivateIPv4Address?: string | null;
}
function SubnetMapping_Serialize(body: URLSearchParams, prefix: string, params: SubnetMapping) {
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AllocationId" in params) body.append(prefix+".AllocationId", (params["AllocationId"] ?? '').toString());
    if ("PrivateIPv4Address" in params) body.append(prefix+".PrivateIPv4Address", (params["PrivateIPv4Address"] ?? '').toString());
}

// refs: 3 - tags: input, named, enum, output
export type LoadBalancerSchemeEnum =
| "internet-facing"
| "internal"
;



// refs: 3 - tags: input, named, enum, output
export type LoadBalancerTypeEnum =
| "application"
| "network"
;



// refs: 5 - tags: input, named, enum, output
export type IpAddressType =
| "ipv4"
| "dualstack"
;



// refs: 6 - tags: input, named, interface, output
export interface RuleCondition {
  Field?: string | null;
  Values: string[];
  HostHeaderConfig?: HostHeaderConditionConfig | null;
  PathPatternConfig?: PathPatternConditionConfig | null;
  HttpHeaderConfig?: HttpHeaderConditionConfig | null;
  QueryStringConfig?: QueryStringConditionConfig | null;
  HttpRequestMethodConfig?: HttpRequestMethodConditionConfig | null;
  SourceIpConfig?: SourceIpConditionConfig | null;
}
function RuleCondition_Serialize(body: URLSearchParams, prefix: string, params: RuleCondition) {
    if ("Field" in params) body.append(prefix+".Field", (params["Field"] ?? '').toString());
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
    if (params["HostHeaderConfig"] != null) HostHeaderConditionConfig_Serialize(body, prefix+".HostHeaderConfig", params["HostHeaderConfig"]);
    if (params["PathPatternConfig"] != null) PathPatternConditionConfig_Serialize(body, prefix+".PathPatternConfig", params["PathPatternConfig"]);
    if (params["HttpHeaderConfig"] != null) HttpHeaderConditionConfig_Serialize(body, prefix+".HttpHeaderConfig", params["HttpHeaderConfig"]);
    if (params["QueryStringConfig"] != null) QueryStringConditionConfig_Serialize(body, prefix+".QueryStringConfig", params["QueryStringConfig"]);
    if (params["HttpRequestMethodConfig"] != null) HttpRequestMethodConditionConfig_Serialize(body, prefix+".HttpRequestMethodConfig", params["HttpRequestMethodConfig"]);
    if (params["SourceIpConfig"] != null) SourceIpConditionConfig_Serialize(body, prefix+".SourceIpConfig", params["SourceIpConfig"]);
}
function RuleCondition_Parse(node: XmlNode): RuleCondition {
  return {
    ...node.strings({
      optional: {"Field":true},
    }),
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
    HostHeaderConfig: node.first("HostHeaderConfig", false, HostHeaderConditionConfig_Parse),
    PathPatternConfig: node.first("PathPatternConfig", false, PathPatternConditionConfig_Parse),
    HttpHeaderConfig: node.first("HttpHeaderConfig", false, HttpHeaderConditionConfig_Parse),
    QueryStringConfig: node.first("QueryStringConfig", false, QueryStringConditionConfig_Parse),
    HttpRequestMethodConfig: node.first("HttpRequestMethodConfig", false, HttpRequestMethodConditionConfig_Parse),
    SourceIpConfig: node.first("SourceIpConfig", false, SourceIpConditionConfig_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface HostHeaderConditionConfig {
  Values: string[];
}
function HostHeaderConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: HostHeaderConditionConfig) {
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HostHeaderConditionConfig_Parse(node: XmlNode): HostHeaderConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface PathPatternConditionConfig {
  Values: string[];
}
function PathPatternConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: PathPatternConditionConfig) {
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function PathPatternConditionConfig_Parse(node: XmlNode): PathPatternConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface HttpHeaderConditionConfig {
  HttpHeaderName?: string | null;
  Values: string[];
}
function HttpHeaderConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: HttpHeaderConditionConfig) {
    if ("HttpHeaderName" in params) body.append(prefix+".HttpHeaderName", (params["HttpHeaderName"] ?? '').toString());
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HttpHeaderConditionConfig_Parse(node: XmlNode): HttpHeaderConditionConfig {
  return {
    ...node.strings({
      optional: {"HttpHeaderName":true},
    }),
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface QueryStringConditionConfig {
  Values: QueryStringKeyValuePair[];
}
function QueryStringConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: QueryStringConditionConfig) {
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"appender":QueryStringKeyValuePair_Serialize,"entryPrefix":".member."})
}
function QueryStringConditionConfig_Parse(node: XmlNode): QueryStringConditionConfig {
  return {
    Values: node.getList("Values", "member").map(QueryStringKeyValuePair_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface QueryStringKeyValuePair {
  Key?: string | null;
  Value?: string | null;
}
function QueryStringKeyValuePair_Serialize(body: URLSearchParams, prefix: string, params: QueryStringKeyValuePair) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function QueryStringKeyValuePair_Parse(node: XmlNode): QueryStringKeyValuePair {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 6 - tags: input, named, interface, output
export interface HttpRequestMethodConditionConfig {
  Values: string[];
}
function HttpRequestMethodConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: HttpRequestMethodConditionConfig) {
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HttpRequestMethodConditionConfig_Parse(node: XmlNode): HttpRequestMethodConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface SourceIpConditionConfig {
  Values: string[];
}
function SourceIpConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: SourceIpConditionConfig) {
    if (params["Values"]) prt.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function SourceIpConditionConfig_Parse(node: XmlNode): SourceIpConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface Matcher {
  HttpCode: string;
}
function Matcher_Serialize(body: URLSearchParams, prefix: string, params: Matcher) {
    body.append(prefix+".HttpCode", (params["HttpCode"] ?? '').toString());
}
function Matcher_Parse(node: XmlNode): Matcher {
  return node.strings({
    required: {"HttpCode":true},
  });
}

// refs: 4 - tags: input, named, enum, output
export type TargetTypeEnum =
| "instance"
| "ip"
| "lambda"
;



// refs: 4 - tags: input, named, interface, output
export interface TargetDescription {
  Id: string;
  Port?: number | null;
  AvailabilityZone?: string | null;
}
function TargetDescription_Serialize(body: URLSearchParams, prefix: string, params: TargetDescription) {
    body.append(prefix+".Id", (params["Id"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
}
function TargetDescription_Parse(node: XmlNode): TargetDescription {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"AvailabilityZone":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface LoadBalancerAttribute {
  Key?: string | null;
  Value?: string | null;
}
function LoadBalancerAttribute_Serialize(body: URLSearchParams, prefix: string, params: LoadBalancerAttribute) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function LoadBalancerAttribute_Parse(node: XmlNode): LoadBalancerAttribute {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface TargetGroupAttribute {
  Key?: string | null;
  Value?: string | null;
}
function TargetGroupAttribute_Serialize(body: URLSearchParams, prefix: string, params: TargetGroupAttribute) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function TargetGroupAttribute_Parse(node: XmlNode): TargetGroupAttribute {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 1 - tags: input, named, interface
export interface RulePriorityPair {
  RuleArn?: string | null;
  Priority?: number | null;
}
function RulePriorityPair_Serialize(body: URLSearchParams, prefix: string, params: RulePriorityPair) {
    if ("RuleArn" in params) body.append(prefix+".RuleArn", (params["RuleArn"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
}

// refs: 3 - tags: output, named, interface
export interface Listener {
  ListenerArn?: string | null;
  LoadBalancerArn?: string | null;
  Port?: number | null;
  Protocol?: ProtocolEnum | null;
  Certificates: Certificate[];
  SslPolicy?: string | null;
  DefaultActions: Action[];
  AlpnPolicy: string[];
}
function Listener_Parse(node: XmlNode): Listener {
  return {
    ...node.strings({
      optional: {"ListenerArn":true,"LoadBalancerArn":true,"SslPolicy":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as ProtocolEnum),
    Certificates: node.getList("Certificates", "member").map(Certificate_Parse),
    DefaultActions: node.getList("DefaultActions", "member").map(Action_Parse),
    AlpnPolicy: node.getList("AlpnPolicy", "member").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface LoadBalancer {
  LoadBalancerArn?: string | null;
  DNSName?: string | null;
  CanonicalHostedZoneId?: string | null;
  CreatedTime?: Date | number | null;
  LoadBalancerName?: string | null;
  Scheme?: LoadBalancerSchemeEnum | null;
  VpcId?: string | null;
  State?: LoadBalancerState | null;
  Type?: LoadBalancerTypeEnum | null;
  AvailabilityZones: AvailabilityZone[];
  SecurityGroups: string[];
  IpAddressType?: IpAddressType | null;
  CustomerOwnedIpv4Pool?: string | null;
}
function LoadBalancer_Parse(node: XmlNode): LoadBalancer {
  return {
    ...node.strings({
      optional: {"LoadBalancerArn":true,"DNSName":true,"CanonicalHostedZoneId":true,"LoadBalancerName":true,"VpcId":true,"CustomerOwnedIpv4Pool":true},
    }),
    CreatedTime: node.first("CreatedTime", false, x => parseTimestamp(x.content)),
    Scheme: node.first("Scheme", false, x => (x.content ?? '') as LoadBalancerSchemeEnum),
    State: node.first("State", false, LoadBalancerState_Parse),
    Type: node.first("Type", false, x => (x.content ?? '') as LoadBalancerTypeEnum),
    AvailabilityZones: node.getList("AvailabilityZones", "member").map(AvailabilityZone_Parse),
    SecurityGroups: node.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    IpAddressType: node.first("IpAddressType", false, x => (x.content ?? '') as IpAddressType),
  };
}

// refs: 2 - tags: output, named, interface
export interface LoadBalancerState {
  Code?: LoadBalancerStateEnum | null;
  Reason?: string | null;
}
function LoadBalancerState_Parse(node: XmlNode): LoadBalancerState {
  return {
    ...node.strings({
      optional: {"Reason":true},
    }),
    Code: node.first("Code", false, x => (x.content ?? '') as LoadBalancerStateEnum),
  };
}

// refs: 2 - tags: output, named, enum
export type LoadBalancerStateEnum =
| "active"
| "provisioning"
| "active_impaired"
| "failed"
;


// refs: 3 - tags: output, named, interface
export interface AvailabilityZone {
  ZoneName?: string | null;
  SubnetId?: string | null;
  OutpostId?: string | null;
  LoadBalancerAddresses: LoadBalancerAddress[];
}
function AvailabilityZone_Parse(node: XmlNode): AvailabilityZone {
  return {
    ...node.strings({
      optional: {"ZoneName":true,"SubnetId":true,"OutpostId":true},
    }),
    LoadBalancerAddresses: node.getList("LoadBalancerAddresses", "member").map(LoadBalancerAddress_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface LoadBalancerAddress {
  IpAddress?: string | null;
  AllocationId?: string | null;
  PrivateIPv4Address?: string | null;
}
function LoadBalancerAddress_Parse(node: XmlNode): LoadBalancerAddress {
  return node.strings({
    optional: {"IpAddress":true,"AllocationId":true,"PrivateIPv4Address":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface Rule {
  RuleArn?: string | null;
  Priority?: string | null;
  Conditions: RuleCondition[];
  Actions: Action[];
  IsDefault?: boolean | null;
}
function Rule_Parse(node: XmlNode): Rule {
  return {
    ...node.strings({
      optional: {"RuleArn":true,"Priority":true},
    }),
    Conditions: node.getList("Conditions", "member").map(RuleCondition_Parse),
    Actions: node.getList("Actions", "member").map(Action_Parse),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface TargetGroup {
  TargetGroupArn?: string | null;
  TargetGroupName?: string | null;
  Protocol?: ProtocolEnum | null;
  Port?: number | null;
  VpcId?: string | null;
  HealthCheckProtocol?: ProtocolEnum | null;
  HealthCheckPort?: string | null;
  HealthCheckEnabled?: boolean | null;
  HealthCheckIntervalSeconds?: number | null;
  HealthCheckTimeoutSeconds?: number | null;
  HealthyThresholdCount?: number | null;
  UnhealthyThresholdCount?: number | null;
  HealthCheckPath?: string | null;
  Matcher?: Matcher | null;
  LoadBalancerArns: string[];
  TargetType?: TargetTypeEnum | null;
}
function TargetGroup_Parse(node: XmlNode): TargetGroup {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true,"TargetGroupName":true,"VpcId":true,"HealthCheckPort":true,"HealthCheckPath":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as ProtocolEnum),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    HealthCheckProtocol: node.first("HealthCheckProtocol", false, x => (x.content ?? '') as ProtocolEnum),
    HealthCheckEnabled: node.first("HealthCheckEnabled", false, x => x.content === 'true'),
    HealthCheckIntervalSeconds: node.first("HealthCheckIntervalSeconds", false, x => parseInt(x.content ?? '0')),
    HealthCheckTimeoutSeconds: node.first("HealthCheckTimeoutSeconds", false, x => parseInt(x.content ?? '0')),
    HealthyThresholdCount: node.first("HealthyThresholdCount", false, x => parseInt(x.content ?? '0')),
    UnhealthyThresholdCount: node.first("UnhealthyThresholdCount", false, x => parseInt(x.content ?? '0')),
    Matcher: node.first("Matcher", false, Matcher_Parse),
    LoadBalancerArns: node.getList("LoadBalancerArns", "member").map(x => x.content ?? ''),
    TargetType: node.first("TargetType", false, x => (x.content ?? '') as TargetTypeEnum),
  };
}

// refs: 1 - tags: output, named, interface
export interface Limit {
  Name?: string | null;
  Max?: string | null;
}
function Limit_Parse(node: XmlNode): Limit {
  return node.strings({
    optional: {"Name":true,"Max":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface SslPolicy {
  SslProtocols: string[];
  Ciphers: Cipher[];
  Name?: string | null;
}
function SslPolicy_Parse(node: XmlNode): SslPolicy {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    SslProtocols: node.getList("SslProtocols", "member").map(x => x.content ?? ''),
    Ciphers: node.getList("Ciphers", "member").map(Cipher_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface Cipher {
  Name?: string | null;
  Priority?: number | null;
}
function Cipher_Parse(node: XmlNode): Cipher {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface TagDescription {
  ResourceArn?: string | null;
  Tags: Tag[];
}
function TagDescription_Parse(node: XmlNode): TagDescription {
  return {
    ...node.strings({
      optional: {"ResourceArn":true},
    }),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetHealthDescription {
  Target?: TargetDescription | null;
  HealthCheckPort?: string | null;
  TargetHealth?: TargetHealth | null;
}
function TargetHealthDescription_Parse(node: XmlNode): TargetHealthDescription {
  return {
    ...node.strings({
      optional: {"HealthCheckPort":true},
    }),
    Target: node.first("Target", false, TargetDescription_Parse),
    TargetHealth: node.first("TargetHealth", false, TargetHealth_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TargetHealth {
  State?: TargetHealthStateEnum | null;
  Reason?: TargetHealthReasonEnum | null;
  Description?: string | null;
}
function TargetHealth_Parse(node: XmlNode): TargetHealth {
  return {
    ...node.strings({
      optional: {"Description":true},
    }),
    State: node.first("State", false, x => (x.content ?? '') as TargetHealthStateEnum),
    Reason: node.first("Reason", false, x => (x.content ?? '') as TargetHealthReasonEnum),
  };
}

// refs: 1 - tags: output, named, enum
export type TargetHealthStateEnum =
| "initial"
| "healthy"
| "unhealthy"
| "unused"
| "draining"
| "unavailable"
;


// refs: 1 - tags: output, named, enum
export type TargetHealthReasonEnum =
| "Elb.RegistrationInProgress"
| "Elb.InitialHealthChecking"
| "Target.ResponseCodeMismatch"
| "Target.Timeout"
| "Target.FailedHealthChecks"
| "Target.NotRegistered"
| "Target.NotInUse"
| "Target.DeregistrationInProgress"
| "Target.InvalidState"
| "Target.IpUnusable"
| "Target.HealthCheckDisabled"
| "Elb.InternalError"
;

