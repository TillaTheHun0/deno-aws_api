// Autogenerated API client for: AWS Elemental MediaPackage

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MediaPackage {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaPackage.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-10-12",
    "endpointPrefix": "mediapackage",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "MediaPackage",
    "serviceFullName": "AWS Elemental MediaPackage",
    "serviceId": "MediaPackage",
    "signatureVersion": "v4",
    "signingName": "mediapackage",
    "uid": "mediapackage-2017-10-12"
  };

  async configureLogs(
    {abortSignal, ...params}: RequestConfig & ConfigureLogsRequest,
  ): Promise<ConfigureLogsResponse> {
    const body: jsonP.JSONObject = {
      egressAccessLogs: fromEgressAccessLogs(params["EgressAccessLogs"]),
      ingressAccessLogs: fromIngressAccessLogs(params["IngressAccessLogs"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfigureLogs",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/configure_logs`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & CreateChannelRequest,
  ): Promise<CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      id: params["Id"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createHarvestJob(
    {abortSignal, ...params}: RequestConfig & CreateHarvestJobRequest,
  ): Promise<CreateHarvestJobResponse> {
    const body: jsonP.JSONObject = {
      endTime: params["EndTime"],
      id: params["Id"],
      originEndpointId: params["OriginEndpointId"],
      s3Destination: fromS3Destination(params["S3Destination"]),
      startTime: params["StartTime"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHarvestJob",
      requestUri: "/harvest_jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ChannelId": "s",
        "CreatedAt": "s",
        "EndTime": "s",
        "Id": "s",
        "OriginEndpointId": "s",
        "S3Destination": toS3Destination,
        "StartTime": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      },
    }, await resp.json());
  }

  async createOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateOriginEndpointRequest,
  ): Promise<CreateOriginEndpointResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
      channelId: params["ChannelId"],
      cmafPackage: fromCmafPackageCreateOrUpdateParameters(params["CmafPackage"]),
      dashPackage: fromDashPackage(params["DashPackage"]),
      description: params["Description"],
      hlsPackage: fromHlsPackage(params["HlsPackage"]),
      id: params["Id"],
      manifestName: params["ManifestName"],
      mssPackage: fromMssPackage(params["MssPackage"]),
      origination: params["Origination"],
      startoverWindowSeconds: params["StartoverWindowSeconds"],
      tags: params["Tags"],
      timeDelaySeconds: params["TimeDelaySeconds"],
      whitelist: params["Whitelist"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOriginEndpoint",
      requestUri: "/origin_endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & DeleteChannelRequest,
  ): Promise<DeleteChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteOriginEndpointRequest,
  ): Promise<DeleteOriginEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteOriginEndpoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeHarvestJob(
    {abortSignal, ...params}: RequestConfig & DescribeHarvestJobRequest,
  ): Promise<DescribeHarvestJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeHarvestJob",
      method: "GET",
      requestUri: cmnP.encodePath`/harvest_jobs/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ChannelId": "s",
        "CreatedAt": "s",
        "EndTime": "s",
        "Id": "s",
        "OriginEndpointId": "s",
        "S3Destination": toS3Destination,
        "StartTime": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      },
    }, await resp.json());
  }

  async describeOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & DescribeOriginEndpointRequest,
  ): Promise<DescribeOriginEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOriginEndpoint",
      method: "GET",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & ListChannelsRequest = {},
  ): Promise<ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channels": [toChannel],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHarvestJobs(
    {abortSignal, ...params}: RequestConfig & ListHarvestJobsRequest = {},
  ): Promise<ListHarvestJobsResponse> {
    const query = new URLSearchParams;
    if (params["IncludeChannelId"] != null) query.set("includeChannelId", params["IncludeChannelId"]?.toString() ?? "");
    if (params["IncludeStatus"] != null) query.set("includeStatus", params["IncludeStatus"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHarvestJobs",
      method: "GET",
      requestUri: "/harvest_jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HarvestJobs": [toHarvestJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOriginEndpoints(
    {abortSignal, ...params}: RequestConfig & ListOriginEndpointsRequest = {},
  ): Promise<ListOriginEndpointsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelId"] != null) query.set("channelId", params["ChannelId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOriginEndpoints",
      method: "GET",
      requestUri: "/origin_endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "OriginEndpoints": [toOriginEndpoint],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rotateChannelCredentials(
    {abortSignal, ...params}: RequestConfig & RotateChannelCredentialsRequest,
  ): Promise<RotateChannelCredentialsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RotateChannelCredentials",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/credentials`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rotateIngestEndpointCredentials(
    {abortSignal, ...params}: RequestConfig & RotateIngestEndpointCredentialsRequest,
  ): Promise<RotateIngestEndpointCredentialsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RotateIngestEndpointCredentials",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/ingest_endpoints/${params["IngestEndpointId"]}/credentials`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & UpdateChannelRequest,
  ): Promise<UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & UpdateOriginEndpointRequest,
  ): Promise<UpdateOriginEndpointResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
      cmafPackage: fromCmafPackageCreateOrUpdateParameters(params["CmafPackage"]),
      dashPackage: fromDashPackage(params["DashPackage"]),
      description: params["Description"],
      hlsPackage: fromHlsPackage(params["HlsPackage"]),
      manifestName: params["ManifestName"],
      mssPackage: fromMssPackage(params["MssPackage"]),
      origination: params["Origination"],
      startoverWindowSeconds: params["StartoverWindowSeconds"],
      timeDelaySeconds: params["TimeDelaySeconds"],
      whitelist: params["Whitelist"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOriginEndpoint",
      method: "PUT",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface ConfigureLogsRequest {
  EgressAccessLogs?: EgressAccessLogs | null;
  Id: string;
  IngressAccessLogs?: IngressAccessLogs | null;
}

// refs: 1 - tags: named, input
export interface CreateChannelRequest {
  Description?: string | null;
  Id: string;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateHarvestJobRequest {
  EndTime: string;
  Id: string;
  OriginEndpointId: string;
  S3Destination: S3Destination;
  StartTime: string;
}

// refs: 1 - tags: named, input
export interface CreateOriginEndpointRequest {
  Authorization?: Authorization | null;
  ChannelId: string;
  CmafPackage?: CmafPackageCreateOrUpdateParameters | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id: string;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TimeDelaySeconds?: number | null;
  Whitelist?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteChannelRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteOriginEndpointRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DescribeChannelRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DescribeHarvestJobRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DescribeOriginEndpointRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ListChannelsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListHarvestJobsRequest {
  IncludeChannelId?: string | null;
  IncludeStatus?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListOriginEndpointsRequest {
  ChannelId?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface RotateChannelCredentialsRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface RotateIngestEndpointCredentialsRequest {
  Id: string;
  IngestEndpointId: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateChannelRequest {
  Description?: string | null;
  Id: string;
}

// refs: 1 - tags: named, input
export interface UpdateOriginEndpointRequest {
  Authorization?: Authorization | null;
  CmafPackage?: CmafPackageCreateOrUpdateParameters | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id: string;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  TimeDelaySeconds?: number | null;
  Whitelist?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ConfigureLogsResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateChannelResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateHarvestJobResponse {
  Arn?: string | null;
  ChannelId?: string | null;
  CreatedAt?: string | null;
  EndTime?: string | null;
  Id?: string | null;
  OriginEndpointId?: string | null;
  S3Destination?: S3Destination | null;
  StartTime?: string | null;
  Status?: Status | null;
}

// refs: 1 - tags: named, output
export interface CreateOriginEndpointResponse {
  Arn?: string | null;
  Authorization?: Authorization | null;
  ChannelId?: string | null;
  CmafPackage?: CmafPackage | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id?: string | null;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TimeDelaySeconds?: number | null;
  Url?: string | null;
  Whitelist?: string[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteChannelResponse {
}

// refs: 1 - tags: named, output
export interface DeleteOriginEndpointResponse {
}

// refs: 1 - tags: named, output
export interface DescribeChannelResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DescribeHarvestJobResponse {
  Arn?: string | null;
  ChannelId?: string | null;
  CreatedAt?: string | null;
  EndTime?: string | null;
  Id?: string | null;
  OriginEndpointId?: string | null;
  S3Destination?: S3Destination | null;
  StartTime?: string | null;
  Status?: Status | null;
}

// refs: 1 - tags: named, output
export interface DescribeOriginEndpointResponse {
  Arn?: string | null;
  Authorization?: Authorization | null;
  ChannelId?: string | null;
  CmafPackage?: CmafPackage | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id?: string | null;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TimeDelaySeconds?: number | null;
  Url?: string | null;
  Whitelist?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListChannelsResponse {
  Channels?: Channel[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListHarvestJobsResponse {
  HarvestJobs?: HarvestJob[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListOriginEndpointsResponse {
  NextToken?: string | null;
  OriginEndpoints?: OriginEndpoint[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface RotateChannelCredentialsResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface RotateIngestEndpointCredentialsResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface UpdateChannelResponse {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface UpdateOriginEndpointResponse {
  Arn?: string | null;
  Authorization?: Authorization | null;
  ChannelId?: string | null;
  CmafPackage?: CmafPackage | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id?: string | null;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TimeDelaySeconds?: number | null;
  Url?: string | null;
  Whitelist?: string[] | null;
}

// refs: 8 - tags: input, named, interface, output
export interface EgressAccessLogs {
  LogGroupName?: string | null;
}
function fromEgressAccessLogs(input?: EgressAccessLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["LogGroupName"],
  }
}
function toEgressAccessLogs(root: jsonP.JSONValue): EgressAccessLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface IngressAccessLogs {
  LogGroupName?: string | null;
}
function fromIngressAccessLogs(input?: IngressAccessLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["LogGroupName"],
  }
}
function toIngressAccessLogs(root: jsonP.JSONValue): IngressAccessLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface S3Destination {
  BucketName: string;
  ManifestKey: string;
  RoleArn: string;
}
function fromS3Destination(input?: S3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketName: input["BucketName"],
    manifestKey: input["ManifestKey"],
    roleArn: input["RoleArn"],
  }
}
function toS3Destination(root: jsonP.JSONValue): S3Destination {
  return jsonP.readObj({
    required: {
      "BucketName": "s",
      "ManifestKey": "s",
      "RoleArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Authorization {
  CdnIdentifierSecret: string;
  SecretsRoleArn: string;
}
function fromAuthorization(input?: Authorization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cdnIdentifierSecret: input["CdnIdentifierSecret"],
    secretsRoleArn: input["SecretsRoleArn"],
  }
}
function toAuthorization(root: jsonP.JSONValue): Authorization {
  return jsonP.readObj({
    required: {
      "CdnIdentifierSecret": "s",
      "SecretsRoleArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface CmafPackageCreateOrUpdateParameters {
  Encryption?: CmafEncryption | null;
  HlsManifests?: HlsManifestCreateOrUpdateParameters[] | null;
  SegmentDurationSeconds?: number | null;
  SegmentPrefix?: string | null;
  StreamSelection?: StreamSelection | null;
}
function fromCmafPackageCreateOrUpdateParameters(input?: CmafPackageCreateOrUpdateParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromCmafEncryption(input["Encryption"]),
    hlsManifests: input["HlsManifests"]?.map(x => fromHlsManifestCreateOrUpdateParameters(x)),
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    segmentPrefix: input["SegmentPrefix"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}

// refs: 6 - tags: input, named, interface, output
export interface CmafEncryption {
  KeyRotationIntervalSeconds?: number | null;
  SpekeKeyProvider: SpekeKeyProvider;
}
function fromCmafEncryption(input?: CmafEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toCmafEncryption(root: jsonP.JSONValue): CmafEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "KeyRotationIntervalSeconds": "n",
    },
  }, root);
}

// refs: 24 - tags: input, named, interface, output
export interface SpekeKeyProvider {
  CertificateArn?: string | null;
  ResourceId: string;
  RoleArn: string;
  SystemIds: string[];
  Url: string;
}
function fromSpekeKeyProvider(input?: SpekeKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    resourceId: input["ResourceId"],
    roleArn: input["RoleArn"],
    systemIds: input["SystemIds"],
    url: input["Url"],
  }
}
function toSpekeKeyProvider(root: jsonP.JSONValue): SpekeKeyProvider {
  return jsonP.readObj({
    required: {
      "ResourceId": "s",
      "RoleArn": "s",
      "SystemIds": ["s"],
      "Url": "s",
    },
    optional: {
      "CertificateArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface HlsManifestCreateOrUpdateParameters {
  AdMarkers?: AdMarkers | null;
  AdTriggers?: __AdTriggersElement[] | null;
  AdsOnDeliveryRestrictions?: AdsOnDeliveryRestrictions | null;
  Id: string;
  IncludeIframeOnlyStream?: boolean | null;
  ManifestName?: string | null;
  PlaylistType?: PlaylistType | null;
  PlaylistWindowSeconds?: number | null;
  ProgramDateTimeIntervalSeconds?: number | null;
}
function fromHlsManifestCreateOrUpdateParameters(input?: HlsManifestCreateOrUpdateParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    id: input["Id"],
    includeIframeOnlyStream: input["IncludeIframeOnlyStream"],
    manifestName: input["ManifestName"],
    playlistType: input["PlaylistType"],
    playlistWindowSeconds: input["PlaylistWindowSeconds"],
    programDateTimeIntervalSeconds: input["ProgramDateTimeIntervalSeconds"],
  }
}

// refs: 12 - tags: input, named, enum, output
export type AdMarkers =
| "NONE"
| "SCTE35_ENHANCED"
| "PASSTHROUGH"
| "DATERANGE"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type __AdTriggersElement =
| "SPLICE_INSERT"
| "BREAK"
| "PROVIDER_ADVERTISEMENT"
| "DISTRIBUTOR_ADVERTISEMENT"
| "PROVIDER_PLACEMENT_OPPORTUNITY"
| "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
| "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
| "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type AdsOnDeliveryRestrictions =
| "NONE"
| "RESTRICTED"
| "UNRESTRICTED"
| "BOTH"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, enum, output
export type PlaylistType =
| "NONE"
| "EVENT"
| "VOD"
| cmnP.UnexpectedEnumValue;

// refs: 24 - tags: input, named, interface, output
export interface StreamSelection {
  MaxVideoBitsPerSecond?: number | null;
  MinVideoBitsPerSecond?: number | null;
  StreamOrder?: StreamOrder | null;
}
function fromStreamSelection(input?: StreamSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxVideoBitsPerSecond: input["MaxVideoBitsPerSecond"],
    minVideoBitsPerSecond: input["MinVideoBitsPerSecond"],
    streamOrder: input["StreamOrder"],
  }
}
function toStreamSelection(root: jsonP.JSONValue): StreamSelection {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxVideoBitsPerSecond": "n",
      "MinVideoBitsPerSecond": "n",
      "StreamOrder": (x: jsonP.JSONValue) => cmnP.readEnum<StreamOrder>(x),
    },
  }, root);
}

// refs: 24 - tags: input, named, enum, output
export type StreamOrder =
| "ORIGINAL"
| "VIDEO_BITRATE_ASCENDING"
| "VIDEO_BITRATE_DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface DashPackage {
  AdTriggers?: __AdTriggersElement[] | null;
  AdsOnDeliveryRestrictions?: AdsOnDeliveryRestrictions | null;
  Encryption?: DashEncryption | null;
  ManifestLayout?: ManifestLayout | null;
  ManifestWindowSeconds?: number | null;
  MinBufferTimeSeconds?: number | null;
  MinUpdatePeriodSeconds?: number | null;
  PeriodTriggers?: __PeriodTriggersElement[] | null;
  Profile?: Profile | null;
  SegmentDurationSeconds?: number | null;
  SegmentTemplateFormat?: SegmentTemplateFormat | null;
  StreamSelection?: StreamSelection | null;
  SuggestedPresentationDelaySeconds?: number | null;
  UtcTiming?: UtcTiming | null;
  UtcTimingUri?: string | null;
}
function fromDashPackage(input?: DashPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    encryption: fromDashEncryption(input["Encryption"]),
    manifestLayout: input["ManifestLayout"],
    manifestWindowSeconds: input["ManifestWindowSeconds"],
    minBufferTimeSeconds: input["MinBufferTimeSeconds"],
    minUpdatePeriodSeconds: input["MinUpdatePeriodSeconds"],
    periodTriggers: input["PeriodTriggers"],
    profile: input["Profile"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    segmentTemplateFormat: input["SegmentTemplateFormat"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
    suggestedPresentationDelaySeconds: input["SuggestedPresentationDelaySeconds"],
    utcTiming: input["UtcTiming"],
    utcTimingUri: input["UtcTimingUri"],
  }
}
function toDashPackage(root: jsonP.JSONValue): DashPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<__AdTriggersElement>(x)],
      "AdsOnDeliveryRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<AdsOnDeliveryRestrictions>(x),
      "Encryption": toDashEncryption,
      "ManifestLayout": (x: jsonP.JSONValue) => cmnP.readEnum<ManifestLayout>(x),
      "ManifestWindowSeconds": "n",
      "MinBufferTimeSeconds": "n",
      "MinUpdatePeriodSeconds": "n",
      "PeriodTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<__PeriodTriggersElement>(x)],
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<Profile>(x),
      "SegmentDurationSeconds": "n",
      "SegmentTemplateFormat": (x: jsonP.JSONValue) => cmnP.readEnum<SegmentTemplateFormat>(x),
      "StreamSelection": toStreamSelection,
      "SuggestedPresentationDelaySeconds": "n",
      "UtcTiming": (x: jsonP.JSONValue) => cmnP.readEnum<UtcTiming>(x),
      "UtcTimingUri": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DashEncryption {
  KeyRotationIntervalSeconds?: number | null;
  SpekeKeyProvider: SpekeKeyProvider;
}
function fromDashEncryption(input?: DashEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toDashEncryption(root: jsonP.JSONValue): DashEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "KeyRotationIntervalSeconds": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ManifestLayout =
| "FULL"
| "COMPACT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type __PeriodTriggersElement =
| "ADS"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type Profile =
| "NONE"
| "HBBTV_1_5"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type SegmentTemplateFormat =
| "NUMBER_WITH_TIMELINE"
| "TIME_WITH_TIMELINE"
| "NUMBER_WITH_DURATION"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type UtcTiming =
| "NONE"
| "HTTP-HEAD"
| "HTTP-ISO"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface HlsPackage {
  AdMarkers?: AdMarkers | null;
  AdTriggers?: __AdTriggersElement[] | null;
  AdsOnDeliveryRestrictions?: AdsOnDeliveryRestrictions | null;
  Encryption?: HlsEncryption | null;
  IncludeIframeOnlyStream?: boolean | null;
  PlaylistType?: PlaylistType | null;
  PlaylistWindowSeconds?: number | null;
  ProgramDateTimeIntervalSeconds?: number | null;
  SegmentDurationSeconds?: number | null;
  StreamSelection?: StreamSelection | null;
  UseAudioRenditionGroup?: boolean | null;
}
function fromHlsPackage(input?: HlsPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    encryption: fromHlsEncryption(input["Encryption"]),
    includeIframeOnlyStream: input["IncludeIframeOnlyStream"],
    playlistType: input["PlaylistType"],
    playlistWindowSeconds: input["PlaylistWindowSeconds"],
    programDateTimeIntervalSeconds: input["ProgramDateTimeIntervalSeconds"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
    useAudioRenditionGroup: input["UseAudioRenditionGroup"],
  }
}
function toHlsPackage(root: jsonP.JSONValue): HlsPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<AdMarkers>(x),
      "AdTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<__AdTriggersElement>(x)],
      "AdsOnDeliveryRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<AdsOnDeliveryRestrictions>(x),
      "Encryption": toHlsEncryption,
      "IncludeIframeOnlyStream": "b",
      "PlaylistType": (x: jsonP.JSONValue) => cmnP.readEnum<PlaylistType>(x),
      "PlaylistWindowSeconds": "n",
      "ProgramDateTimeIntervalSeconds": "n",
      "SegmentDurationSeconds": "n",
      "StreamSelection": toStreamSelection,
      "UseAudioRenditionGroup": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface HlsEncryption {
  ConstantInitializationVector?: string | null;
  EncryptionMethod?: EncryptionMethod | null;
  KeyRotationIntervalSeconds?: number | null;
  RepeatExtXKey?: boolean | null;
  SpekeKeyProvider: SpekeKeyProvider;
}
function fromHlsEncryption(input?: HlsEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    repeatExtXKey: input["RepeatExtXKey"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toHlsEncryption(root: jsonP.JSONValue): HlsEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionMethod>(x),
      "KeyRotationIntervalSeconds": "n",
      "RepeatExtXKey": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type EncryptionMethod =
| "AES_128"
| "SAMPLE_AES"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface MssPackage {
  Encryption?: MssEncryption | null;
  ManifestWindowSeconds?: number | null;
  SegmentDurationSeconds?: number | null;
  StreamSelection?: StreamSelection | null;
}
function fromMssPackage(input?: MssPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromMssEncryption(input["Encryption"]),
    manifestWindowSeconds: input["ManifestWindowSeconds"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}
function toMssPackage(root: jsonP.JSONValue): MssPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Encryption": toMssEncryption,
      "ManifestWindowSeconds": "n",
      "SegmentDurationSeconds": "n",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MssEncryption {
  SpekeKeyProvider: SpekeKeyProvider;
}
function fromMssEncryption(input?: MssEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toMssEncryption(root: jsonP.JSONValue): MssEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type Origination =
| "ALLOW"
| "DENY"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, interface
export interface HlsIngest {
  IngestEndpoints?: IngestEndpoint[] | null;
}
function toHlsIngest(root: jsonP.JSONValue): HlsIngest {
  return jsonP.readObj({
    required: {},
    optional: {
      "IngestEndpoints": [toIngestEndpoint],
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface IngestEndpoint {
  Id?: string | null;
  Password?: string | null;
  Url?: string | null;
  Username?: string | null;
}
function toIngestEndpoint(root: jsonP.JSONValue): IngestEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Password": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type Status =
| "IN_PROGRESS"
| "SUCCEEDED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface CmafPackage {
  Encryption?: CmafEncryption | null;
  HlsManifests?: HlsManifest[] | null;
  SegmentDurationSeconds?: number | null;
  SegmentPrefix?: string | null;
  StreamSelection?: StreamSelection | null;
}
function toCmafPackage(root: jsonP.JSONValue): CmafPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Encryption": toCmafEncryption,
      "HlsManifests": [toHlsManifest],
      "SegmentDurationSeconds": "n",
      "SegmentPrefix": "s",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface HlsManifest {
  AdMarkers?: AdMarkers | null;
  Id: string;
  IncludeIframeOnlyStream?: boolean | null;
  ManifestName?: string | null;
  PlaylistType?: PlaylistType | null;
  PlaylistWindowSeconds?: number | null;
  ProgramDateTimeIntervalSeconds?: number | null;
  Url?: string | null;
}
function toHlsManifest(root: jsonP.JSONValue): HlsManifest {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "AdMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<AdMarkers>(x),
      "IncludeIframeOnlyStream": "b",
      "ManifestName": "s",
      "PlaylistType": (x: jsonP.JSONValue) => cmnP.readEnum<PlaylistType>(x),
      "PlaylistWindowSeconds": "n",
      "ProgramDateTimeIntervalSeconds": "n",
      "Url": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Channel {
  Arn?: string | null;
  Description?: string | null;
  EgressAccessLogs?: EgressAccessLogs | null;
  HlsIngest?: HlsIngest | null;
  Id?: string | null;
  IngressAccessLogs?: IngressAccessLogs | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toChannel(root: jsonP.JSONValue): Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Description": "s",
      "EgressAccessLogs": toEgressAccessLogs,
      "HlsIngest": toHlsIngest,
      "Id": "s",
      "IngressAccessLogs": toIngressAccessLogs,
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HarvestJob {
  Arn?: string | null;
  ChannelId?: string | null;
  CreatedAt?: string | null;
  EndTime?: string | null;
  Id?: string | null;
  OriginEndpointId?: string | null;
  S3Destination?: S3Destination | null;
  StartTime?: string | null;
  Status?: Status | null;
}
function toHarvestJob(root: jsonP.JSONValue): HarvestJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "ChannelId": "s",
      "CreatedAt": "s",
      "EndTime": "s",
      "Id": "s",
      "OriginEndpointId": "s",
      "S3Destination": toS3Destination,
      "StartTime": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface OriginEndpoint {
  Arn?: string | null;
  Authorization?: Authorization | null;
  ChannelId?: string | null;
  CmafPackage?: CmafPackage | null;
  DashPackage?: DashPackage | null;
  Description?: string | null;
  HlsPackage?: HlsPackage | null;
  Id?: string | null;
  ManifestName?: string | null;
  MssPackage?: MssPackage | null;
  Origination?: Origination | null;
  StartoverWindowSeconds?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TimeDelaySeconds?: number | null;
  Url?: string | null;
  Whitelist?: string[] | null;
}
function toOriginEndpoint(root: jsonP.JSONValue): OriginEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Authorization": toAuthorization,
      "ChannelId": "s",
      "CmafPackage": toCmafPackage,
      "DashPackage": toDashPackage,
      "Description": "s",
      "HlsPackage": toHlsPackage,
      "Id": "s",
      "ManifestName": "s",
      "MssPackage": toMssPackage,
      "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<Origination>(x),
      "StartoverWindowSeconds": "n",
      "Tags": x => jsonP.readMap(String, String, x),
      "TimeDelaySeconds": "n",
      "Url": "s",
      "Whitelist": ["s"],
    },
  }, root);
}
