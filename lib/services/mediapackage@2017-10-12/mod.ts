// Autogenerated API client for: AWS Elemental MediaPackage

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class MediaPackage {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaPackage.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-10-12",
    "endpointPrefix": "mediapackage",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "MediaPackage",
    "serviceFullName": "AWS Elemental MediaPackage",
    "serviceId": "MediaPackage",
    "signatureVersion": "v4",
    "signingName": "mediapackage",
    "uid": "mediapackage-2017-10-12"
  };

  async configureLogs(
    {abortSignal, ...params}: RequestConfig & s.ConfigureLogsRequest,
  ): Promise<s.ConfigureLogsResponse> {
    const body: jsonP.JSONObject = {
      egressAccessLogs: fromEgressAccessLogs(params["EgressAccessLogs"]),
      ingressAccessLogs: fromIngressAccessLogs(params["IngressAccessLogs"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfigureLogs",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/configure_logs`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & s.CreateChannelRequest,
  ): Promise<s.CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      id: params["Id"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createHarvestJob(
    {abortSignal, ...params}: RequestConfig & s.CreateHarvestJobRequest,
  ): Promise<s.CreateHarvestJobResponse> {
    const body: jsonP.JSONObject = {
      endTime: params["EndTime"],
      id: params["Id"],
      originEndpointId: params["OriginEndpointId"],
      s3Destination: fromS3Destination(params["S3Destination"]),
      startTime: params["StartTime"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHarvestJob",
      requestUri: "/harvest_jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ChannelId": "s",
        "CreatedAt": "s",
        "EndTime": "s",
        "Id": "s",
        "OriginEndpointId": "s",
        "S3Destination": toS3Destination,
        "StartTime": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      },
    }, await resp.json());
  }

  async createOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateOriginEndpointRequest,
  ): Promise<s.CreateOriginEndpointResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
      channelId: params["ChannelId"],
      cmafPackage: fromCmafPackageCreateOrUpdateParameters(params["CmafPackage"]),
      dashPackage: fromDashPackage(params["DashPackage"]),
      description: params["Description"],
      hlsPackage: fromHlsPackage(params["HlsPackage"]),
      id: params["Id"],
      manifestName: params["ManifestName"],
      mssPackage: fromMssPackage(params["MssPackage"]),
      origination: params["Origination"],
      startoverWindowSeconds: params["StartoverWindowSeconds"],
      tags: params["Tags"],
      timeDelaySeconds: params["TimeDelaySeconds"],
      whitelist: params["Whitelist"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOriginEndpoint",
      requestUri: "/origin_endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<s.Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteChannelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async deleteOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteOriginEndpointRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteOriginEndpoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 202,
    });
    await resp.text();
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeHarvestJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeHarvestJobRequest,
  ): Promise<s.DescribeHarvestJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeHarvestJob",
      method: "GET",
      requestUri: cmnP.encodePath`/harvest_jobs/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ChannelId": "s",
        "CreatedAt": "s",
        "EndTime": "s",
        "Id": "s",
        "OriginEndpointId": "s",
        "S3Destination": toS3Destination,
        "StartTime": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      },
    }, await resp.json());
  }

  async describeOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DescribeOriginEndpointRequest,
  ): Promise<s.DescribeOriginEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOriginEndpoint",
      method: "GET",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<s.Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & s.ListChannelsRequest = {},
  ): Promise<s.ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channels": [toChannel],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHarvestJobs(
    {abortSignal, ...params}: RequestConfig & s.ListHarvestJobsRequest = {},
  ): Promise<s.ListHarvestJobsResponse> {
    const query = new URLSearchParams;
    if (params["IncludeChannelId"] != null) query.set("includeChannelId", params["IncludeChannelId"]?.toString() ?? "");
    if (params["IncludeStatus"] != null) query.set("includeStatus", params["IncludeStatus"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHarvestJobs",
      method: "GET",
      requestUri: "/harvest_jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HarvestJobs": [toHarvestJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOriginEndpoints(
    {abortSignal, ...params}: RequestConfig & s.ListOriginEndpointsRequest = {},
  ): Promise<s.ListOriginEndpointsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelId"] != null) query.set("channelId", params["ChannelId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOriginEndpoints",
      method: "GET",
      requestUri: "/origin_endpoints",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "OriginEndpoints": [toOriginEndpoint],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rotateChannelCredentials(
    {abortSignal, ...params}: RequestConfig & s.RotateChannelCredentialsRequest,
  ): Promise<s.RotateChannelCredentialsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RotateChannelCredentials",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/credentials`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async rotateIngestEndpointCredentials(
    {abortSignal, ...params}: RequestConfig & s.RotateIngestEndpointCredentialsRequest,
  ): Promise<s.RotateIngestEndpointCredentialsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RotateIngestEndpointCredentials",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}/ingest_endpoints/${params["IngestEndpointId"]}/credentials`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateChannelRequest,
  ): Promise<s.UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/channels/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Description": "s",
        "EgressAccessLogs": toEgressAccessLogs,
        "HlsIngest": toHlsIngest,
        "Id": "s",
        "IngressAccessLogs": toIngressAccessLogs,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateOriginEndpoint(
    {abortSignal, ...params}: RequestConfig & s.UpdateOriginEndpointRequest,
  ): Promise<s.UpdateOriginEndpointResponse> {
    const body: jsonP.JSONObject = {
      authorization: fromAuthorization(params["Authorization"]),
      cmafPackage: fromCmafPackageCreateOrUpdateParameters(params["CmafPackage"]),
      dashPackage: fromDashPackage(params["DashPackage"]),
      description: params["Description"],
      hlsPackage: fromHlsPackage(params["HlsPackage"]),
      manifestName: params["ManifestName"],
      mssPackage: fromMssPackage(params["MssPackage"]),
      origination: params["Origination"],
      startoverWindowSeconds: params["StartoverWindowSeconds"],
      timeDelaySeconds: params["TimeDelaySeconds"],
      whitelist: params["Whitelist"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOriginEndpoint",
      method: "PUT",
      requestUri: cmnP.encodePath`/origin_endpoints/${params["Id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Authorization": toAuthorization,
        "ChannelId": "s",
        "CmafPackage": toCmafPackage,
        "DashPackage": toDashPackage,
        "Description": "s",
        "HlsPackage": toHlsPackage,
        "Id": "s",
        "ManifestName": "s",
        "MssPackage": toMssPackage,
        "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<s.Origination>(x),
        "StartoverWindowSeconds": "n",
        "Tags": x => jsonP.readMap(String, String, x),
        "TimeDelaySeconds": "n",
        "Url": "s",
        "Whitelist": ["s"],
      },
    }, await resp.json());
  }

}

function fromEgressAccessLogs(input?: s.EgressAccessLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["LogGroupName"],
  }
}
function toEgressAccessLogs(root: jsonP.JSONValue): s.EgressAccessLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
    },
  }, root);
}

function fromIngressAccessLogs(input?: s.IngressAccessLogs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["LogGroupName"],
  }
}
function toIngressAccessLogs(root: jsonP.JSONValue): s.IngressAccessLogs {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogGroupName": "s",
    },
  }, root);
}

function fromS3Destination(input?: s.S3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketName: input["BucketName"],
    manifestKey: input["ManifestKey"],
    roleArn: input["RoleArn"],
  }
}
function toS3Destination(root: jsonP.JSONValue): s.S3Destination {
  return jsonP.readObj({
    required: {
      "BucketName": "s",
      "ManifestKey": "s",
      "RoleArn": "s",
    },
    optional: {},
  }, root);
}

function fromAuthorization(input?: s.Authorization | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cdnIdentifierSecret: input["CdnIdentifierSecret"],
    secretsRoleArn: input["SecretsRoleArn"],
  }
}
function toAuthorization(root: jsonP.JSONValue): s.Authorization {
  return jsonP.readObj({
    required: {
      "CdnIdentifierSecret": "s",
      "SecretsRoleArn": "s",
    },
    optional: {},
  }, root);
}

function fromCmafPackageCreateOrUpdateParameters(input?: s.CmafPackageCreateOrUpdateParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromCmafEncryption(input["Encryption"]),
    hlsManifests: input["HlsManifests"]?.map(x => fromHlsManifestCreateOrUpdateParameters(x)),
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    segmentPrefix: input["SegmentPrefix"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}

function fromCmafEncryption(input?: s.CmafEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toCmafEncryption(root: jsonP.JSONValue): s.CmafEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "KeyRotationIntervalSeconds": "n",
    },
  }, root);
}

function fromSpekeKeyProvider(input?: s.SpekeKeyProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["CertificateArn"],
    resourceId: input["ResourceId"],
    roleArn: input["RoleArn"],
    systemIds: input["SystemIds"],
    url: input["Url"],
  }
}
function toSpekeKeyProvider(root: jsonP.JSONValue): s.SpekeKeyProvider {
  return jsonP.readObj({
    required: {
      "ResourceId": "s",
      "RoleArn": "s",
      "SystemIds": ["s"],
      "Url": "s",
    },
    optional: {
      "CertificateArn": "s",
    },
  }, root);
}

function fromHlsManifestCreateOrUpdateParameters(input?: s.HlsManifestCreateOrUpdateParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    id: input["Id"],
    includeIframeOnlyStream: input["IncludeIframeOnlyStream"],
    manifestName: input["ManifestName"],
    playlistType: input["PlaylistType"],
    playlistWindowSeconds: input["PlaylistWindowSeconds"],
    programDateTimeIntervalSeconds: input["ProgramDateTimeIntervalSeconds"],
  }
}

function fromStreamSelection(input?: s.StreamSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxVideoBitsPerSecond: input["MaxVideoBitsPerSecond"],
    minVideoBitsPerSecond: input["MinVideoBitsPerSecond"],
    streamOrder: input["StreamOrder"],
  }
}
function toStreamSelection(root: jsonP.JSONValue): s.StreamSelection {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxVideoBitsPerSecond": "n",
      "MinVideoBitsPerSecond": "n",
      "StreamOrder": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamOrder>(x),
    },
  }, root);
}

function fromDashPackage(input?: s.DashPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    encryption: fromDashEncryption(input["Encryption"]),
    manifestLayout: input["ManifestLayout"],
    manifestWindowSeconds: input["ManifestWindowSeconds"],
    minBufferTimeSeconds: input["MinBufferTimeSeconds"],
    minUpdatePeriodSeconds: input["MinUpdatePeriodSeconds"],
    periodTriggers: input["PeriodTriggers"],
    profile: input["Profile"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    segmentTemplateFormat: input["SegmentTemplateFormat"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
    suggestedPresentationDelaySeconds: input["SuggestedPresentationDelaySeconds"],
    utcTiming: input["UtcTiming"],
    utcTimingUri: input["UtcTimingUri"],
  }
}
function toDashPackage(root: jsonP.JSONValue): s.DashPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__AdTriggersElement>(x)],
      "AdsOnDeliveryRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdsOnDeliveryRestrictions>(x),
      "Encryption": toDashEncryption,
      "ManifestLayout": (x: jsonP.JSONValue) => cmnP.readEnum<s.ManifestLayout>(x),
      "ManifestWindowSeconds": "n",
      "MinBufferTimeSeconds": "n",
      "MinUpdatePeriodSeconds": "n",
      "PeriodTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__PeriodTriggersElement>(x)],
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.Profile>(x),
      "SegmentDurationSeconds": "n",
      "SegmentTemplateFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.SegmentTemplateFormat>(x),
      "StreamSelection": toStreamSelection,
      "SuggestedPresentationDelaySeconds": "n",
      "UtcTiming": (x: jsonP.JSONValue) => cmnP.readEnum<s.UtcTiming>(x),
      "UtcTimingUri": "s",
    },
  }, root);
}

function fromDashEncryption(input?: s.DashEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toDashEncryption(root: jsonP.JSONValue): s.DashEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "KeyRotationIntervalSeconds": "n",
    },
  }, root);
}

function fromHlsPackage(input?: s.HlsPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    adTriggers: input["AdTriggers"],
    adsOnDeliveryRestrictions: input["AdsOnDeliveryRestrictions"],
    encryption: fromHlsEncryption(input["Encryption"]),
    includeIframeOnlyStream: input["IncludeIframeOnlyStream"],
    playlistType: input["PlaylistType"],
    playlistWindowSeconds: input["PlaylistWindowSeconds"],
    programDateTimeIntervalSeconds: input["ProgramDateTimeIntervalSeconds"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
    useAudioRenditionGroup: input["UseAudioRenditionGroup"],
  }
}
function toHlsPackage(root: jsonP.JSONValue): s.HlsPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdMarkers>(x),
      "AdTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__AdTriggersElement>(x)],
      "AdsOnDeliveryRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdsOnDeliveryRestrictions>(x),
      "Encryption": toHlsEncryption,
      "IncludeIframeOnlyStream": "b",
      "PlaylistType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlaylistType>(x),
      "PlaylistWindowSeconds": "n",
      "ProgramDateTimeIntervalSeconds": "n",
      "SegmentDurationSeconds": "n",
      "StreamSelection": toStreamSelection,
      "UseAudioRenditionGroup": "b",
    },
  }, root);
}

function fromHlsEncryption(input?: s.HlsEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantInitializationVector: input["ConstantInitializationVector"],
    encryptionMethod: input["EncryptionMethod"],
    keyRotationIntervalSeconds: input["KeyRotationIntervalSeconds"],
    repeatExtXKey: input["RepeatExtXKey"],
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toHlsEncryption(root: jsonP.JSONValue): s.HlsEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {
      "ConstantInitializationVector": "s",
      "EncryptionMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionMethod>(x),
      "KeyRotationIntervalSeconds": "n",
      "RepeatExtXKey": "b",
    },
  }, root);
}

function fromMssPackage(input?: s.MssPackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryption: fromMssEncryption(input["Encryption"]),
    manifestWindowSeconds: input["ManifestWindowSeconds"],
    segmentDurationSeconds: input["SegmentDurationSeconds"],
    streamSelection: fromStreamSelection(input["StreamSelection"]),
  }
}
function toMssPackage(root: jsonP.JSONValue): s.MssPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Encryption": toMssEncryption,
      "ManifestWindowSeconds": "n",
      "SegmentDurationSeconds": "n",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

function fromMssEncryption(input?: s.MssEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spekeKeyProvider: fromSpekeKeyProvider(input["SpekeKeyProvider"]),
  }
}
function toMssEncryption(root: jsonP.JSONValue): s.MssEncryption {
  return jsonP.readObj({
    required: {
      "SpekeKeyProvider": toSpekeKeyProvider,
    },
    optional: {},
  }, root);
}

function toHlsIngest(root: jsonP.JSONValue): s.HlsIngest {
  return jsonP.readObj({
    required: {},
    optional: {
      "IngestEndpoints": [toIngestEndpoint],
    },
  }, root);
}

function toIngestEndpoint(root: jsonP.JSONValue): s.IngestEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Password": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

function toCmafPackage(root: jsonP.JSONValue): s.CmafPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Encryption": toCmafEncryption,
      "HlsManifests": [toHlsManifest],
      "SegmentDurationSeconds": "n",
      "SegmentPrefix": "s",
      "StreamSelection": toStreamSelection,
    },
  }, root);
}

function toHlsManifest(root: jsonP.JSONValue): s.HlsManifest {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "AdMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdMarkers>(x),
      "IncludeIframeOnlyStream": "b",
      "ManifestName": "s",
      "PlaylistType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlaylistType>(x),
      "PlaylistWindowSeconds": "n",
      "ProgramDateTimeIntervalSeconds": "n",
      "Url": "s",
    },
  }, root);
}

function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Description": "s",
      "EgressAccessLogs": toEgressAccessLogs,
      "HlsIngest": toHlsIngest,
      "Id": "s",
      "IngressAccessLogs": toIngressAccessLogs,
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toHarvestJob(root: jsonP.JSONValue): s.HarvestJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "ChannelId": "s",
      "CreatedAt": "s",
      "EndTime": "s",
      "Id": "s",
      "OriginEndpointId": "s",
      "S3Destination": toS3Destination,
      "StartTime": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
    },
  }, root);
}

function toOriginEndpoint(root: jsonP.JSONValue): s.OriginEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Authorization": toAuthorization,
      "ChannelId": "s",
      "CmafPackage": toCmafPackage,
      "DashPackage": toDashPackage,
      "Description": "s",
      "HlsPackage": toHlsPackage,
      "Id": "s",
      "ManifestName": "s",
      "MssPackage": toMssPackage,
      "Origination": (x: jsonP.JSONValue) => cmnP.readEnum<s.Origination>(x),
      "StartoverWindowSeconds": "n",
      "Tags": x => jsonP.readMap(String, String, x),
      "TimeDelaySeconds": "n",
      "Url": "s",
      "Whitelist": ["s"],
    },
  }, root);
}
