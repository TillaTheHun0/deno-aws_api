// Autogenerated API client for: Amazon WorkDocs

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class WorkDocs {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(WorkDocs.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-05-01",
    "endpointPrefix": "workdocs",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon WorkDocs",
    "serviceId": "WorkDocs",
    "signatureVersion": "v4",
    "uid": "workdocs-2016-05-01"
  };

  async abortDocumentVersionUpload(
    {abortSignal, ...params}: RequestConfig & s.AbortDocumentVersionUploadRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "AbortDocumentVersionUpload",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}`,
      responseCode: 204,
    });
  }

  async activateUser(
    {abortSignal, ...params}: RequestConfig & s.ActivateUserRequest,
  ): Promise<s.ActivateUserResponse> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "ActivateUser",
      requestUri: cmnP.encodePath`/api/v1/users/${params["UserId"]}/activation`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "User": toUser,
      },
    }, await resp.json());
  }

  async addResourcePermissions(
    {abortSignal, ...params}: RequestConfig & s.AddResourcePermissionsRequest,
  ): Promise<s.AddResourcePermissionsResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Principals: params["Principals"]?.map(x => fromSharePrincipal(x)),
      NotificationOptions: fromNotificationOptions(params["NotificationOptions"]),
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "AddResourcePermissions",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/permissions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ShareResults": [toShareResult],
      },
    }, await resp.json());
  }

  async createComment(
    {abortSignal, ...params}: RequestConfig & s.CreateCommentRequest,
  ): Promise<s.CreateCommentResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      ParentId: params["ParentId"],
      ThreadId: params["ThreadId"],
      Text: params["Text"],
      Visibility: params["Visibility"],
      NotifyCollaborators: params["NotifyCollaborators"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateComment",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}/comment`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Comment": toComment,
      },
    }, await resp.json());
  }

  async createCustomMetadata(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomMetadataRequest,
  ): Promise<s.CreateCustomMetadataResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      CustomMetadata: params["CustomMetadata"],
    };
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["VersionId"] != null) query.set("versionid", params["VersionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "CreateCustomMetadata",
      method: "PUT",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/customMetadata`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createFolder(
    {abortSignal, ...params}: RequestConfig & s.CreateFolderRequest,
  ): Promise<s.CreateFolderResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ParentFolderId: params["ParentFolderId"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateFolder",
      requestUri: "/api/v1/folders",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toFolderMetadata,
      },
    }, await resp.json());
  }

  async createLabels(
    {abortSignal, ...params}: RequestConfig & s.CreateLabelsRequest,
  ): Promise<s.CreateLabelsResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Labels: params["Labels"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateLabels",
      method: "PUT",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/labels`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createNotificationSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateNotificationSubscriptionRequest,
  ): Promise<s.CreateNotificationSubscriptionResponse> {
    const body: jsonP.JSONObject = {
      Endpoint: params["Endpoint"],
      Protocol: params["Protocol"],
      SubscriptionType: params["SubscriptionType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotificationSubscription",
      requestUri: cmnP.encodePath`/api/v1/organizations/${params["OrganizationId"]}/subscriptions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Subscription": toSubscription,
      },
    }, await resp.json());
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & s.CreateUserRequest,
  ): Promise<s.CreateUserResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      OrganizationId: params["OrganizationId"],
      Username: params["Username"],
      EmailAddress: params["EmailAddress"],
      GivenName: params["GivenName"],
      Surname: params["Surname"],
      Password: params["Password"],
      TimeZoneId: params["TimeZoneId"],
      StorageRule: fromStorageRuleType(params["StorageRule"]),
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateUser",
      requestUri: "/api/v1/users",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "User": toUser,
      },
    }, await resp.json());
  }

  async deactivateUser(
    {abortSignal, ...params}: RequestConfig & s.DeactivateUserRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeactivateUser",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/users/${params["UserId"]}/activation`,
      responseCode: 204,
    });
  }

  async deleteComment(
    {abortSignal, ...params}: RequestConfig & s.DeleteCommentRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteComment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}/comment/${params["CommentId"]}`,
      responseCode: 204,
    });
  }

  async deleteCustomMetadata(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomMetadataRequest,
  ): Promise<s.DeleteCustomMetadataResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    for (const item of params["Keys"] ?? []) {
      query.append("keys", item?.toString() ?? "");
    }
    if (params["DeleteAll"] != null) query.set("deleteAll", params["DeleteAll"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteCustomMetadata",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/customMetadata`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDocument(
    {abortSignal, ...params}: RequestConfig & s.DeleteDocumentRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDocument",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}`,
      responseCode: 204,
    });
  }

  async deleteFolder(
    {abortSignal, ...params}: RequestConfig & s.DeleteFolderRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFolder",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}`,
      responseCode: 204,
    });
  }

  async deleteFolderContents(
    {abortSignal, ...params}: RequestConfig & s.DeleteFolderContentsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFolderContents",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}/contents`,
      responseCode: 204,
    });
  }

  async deleteLabels(
    {abortSignal, ...params}: RequestConfig & s.DeleteLabelsRequest,
  ): Promise<s.DeleteLabelsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    for (const item of params["Labels"] ?? []) {
      query.append("labels", item?.toString() ?? "");
    }
    if (params["DeleteAll"] != null) query.set("deleteAll", params["DeleteAll"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DeleteLabels",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/labels`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteNotificationSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteNotificationSubscriptionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteNotificationSubscription",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/organizations/${params["OrganizationId"]}/subscriptions/${params["SubscriptionId"]}`,
      responseCode: 200,
    });
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteUser",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/users/${params["UserId"]}`,
      responseCode: 204,
    });
  }

  async describeActivities(
    {abortSignal, ...params}: RequestConfig & s.DescribeActivitiesRequest = {},
  ): Promise<s.DescribeActivitiesResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["StartTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["StartTime"]) ?? "");
    if (params["EndTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["EndTime"]) ?? "");
    if (params["OrganizationId"] != null) query.set("organizationId", params["OrganizationId"]?.toString() ?? "");
    if (params["ActivityTypes"] != null) query.set("activityTypes", params["ActivityTypes"]?.toString() ?? "");
    if (params["ResourceId"] != null) query.set("resourceId", params["ResourceId"]?.toString() ?? "");
    if (params["UserId"] != null) query.set("userId", params["UserId"]?.toString() ?? "");
    if (params["IncludeIndirectActivities"] != null) query.set("includeIndirectActivities", params["IncludeIndirectActivities"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeActivities",
      method: "GET",
      requestUri: "/api/v1/activities",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserActivities": [toActivity],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeComments(
    {abortSignal, ...params}: RequestConfig & s.DescribeCommentsRequest,
  ): Promise<s.DescribeCommentsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeComments",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}/comments`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Comments": [toComment],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeDocumentVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDocumentVersionsRequest,
  ): Promise<s.DescribeDocumentVersionsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Include"] != null) query.set("include", params["Include"]?.toString() ?? "");
    if (params["Fields"] != null) query.set("fields", params["Fields"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeDocumentVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentVersions": [toDocumentVersionMetadata],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeFolderContents(
    {abortSignal, ...params}: RequestConfig & s.DescribeFolderContentsRequest,
  ): Promise<s.DescribeFolderContentsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Sort"] != null) query.set("sort", params["Sort"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["Type"] != null) query.set("type", params["Type"]?.toString() ?? "");
    if (params["Include"] != null) query.set("include", params["Include"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeFolderContents",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}/contents`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Folders": [toFolderMetadata],
        "Documents": [toDocumentMetadata],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeGroupsRequest,
  ): Promise<s.DescribeGroupsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    query.set("searchQuery", params["SearchQuery"]?.toString() ?? "");
    if (params["OrganizationId"] != null) query.set("organizationId", params["OrganizationId"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeGroups",
      method: "GET",
      requestUri: "/api/v1/groups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Groups": [toGroupMetadata],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeNotificationSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotificationSubscriptionsRequest,
  ): Promise<s.DescribeNotificationSubscriptionsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeNotificationSubscriptions",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/organizations/${params["OrganizationId"]}/subscriptions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Subscriptions": [toSubscription],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeResourcePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeResourcePermissionsRequest,
  ): Promise<s.DescribeResourcePermissionsResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["PrincipalId"] != null) query.set("principalId", params["PrincipalId"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeResourcePermissions",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/permissions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Principals": [toPrincipal],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeRootFolders(
    {abortSignal, ...params}: RequestConfig & s.DescribeRootFoldersRequest,
  ): Promise<s.DescribeRootFoldersResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeRootFolders",
      method: "GET",
      requestUri: "/api/v1/me/root",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Folders": [toFolderMetadata],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeUsers(
    {abortSignal, ...params}: RequestConfig & s.DescribeUsersRequest = {},
  ): Promise<s.DescribeUsersResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["OrganizationId"] != null) query.set("organizationId", params["OrganizationId"]?.toString() ?? "");
    if (params["UserIds"] != null) query.set("userIds", params["UserIds"]?.toString() ?? "");
    if (params["Query"] != null) query.set("query", params["Query"]?.toString() ?? "");
    if (params["Include"] != null) query.set("include", params["Include"]?.toString() ?? "");
    if (params["Order"] != null) query.set("order", params["Order"]?.toString() ?? "");
    if (params["Sort"] != null) query.set("sort", params["Sort"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Fields"] != null) query.set("fields", params["Fields"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "DescribeUsers",
      method: "GET",
      requestUri: "/api/v1/users",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Users": [toUser],
        "TotalNumberOfUsers": "n",
        "Marker": "s",
      },
    }, await resp.json());
  }

  async getCurrentUser(
    {abortSignal, ...params}: RequestConfig & s.GetCurrentUserRequest,
  ): Promise<s.GetCurrentUserResponse> {
    const headers = new Headers;
    headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetCurrentUser",
      method: "GET",
      requestUri: "/api/v1/me",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "User": toUser,
      },
    }, await resp.json());
  }

  async getDocument(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentRequest,
  ): Promise<s.GetDocumentResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["IncludeCustomMetadata"] != null) query.set("includeCustomMetadata", params["IncludeCustomMetadata"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetDocument",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toDocumentMetadata,
        "CustomMetadata": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getDocumentPath(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentPathRequest,
  ): Promise<s.GetDocumentPathResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Fields"] != null) query.set("fields", params["Fields"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetDocumentPath",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/path`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Path": toResourcePath,
      },
    }, await resp.json());
  }

  async getDocumentVersion(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentVersionRequest,
  ): Promise<s.GetDocumentVersionResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Fields"] != null) query.set("fields", params["Fields"]?.toString() ?? "");
    if (params["IncludeCustomMetadata"] != null) query.set("includeCustomMetadata", params["IncludeCustomMetadata"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetDocumentVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toDocumentVersionMetadata,
        "CustomMetadata": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getFolder(
    {abortSignal, ...params}: RequestConfig & s.GetFolderRequest,
  ): Promise<s.GetFolderResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["IncludeCustomMetadata"] != null) query.set("includeCustomMetadata", params["IncludeCustomMetadata"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetFolder",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toFolderMetadata,
        "CustomMetadata": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getFolderPath(
    {abortSignal, ...params}: RequestConfig & s.GetFolderPathRequest,
  ): Promise<s.GetFolderPathResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Fields"] != null) query.set("fields", params["Fields"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetFolderPath",
      method: "GET",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}/path`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Path": toResourcePath,
      },
    }, await resp.json());
  }

  async getResources(
    {abortSignal, ...params}: RequestConfig & s.GetResourcesRequest = {},
  ): Promise<s.GetResourcesResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["UserId"] != null) query.set("userId", params["UserId"]?.toString() ?? "");
    if (params["CollectionType"] != null) query.set("collectionType", params["CollectionType"]?.toString() ?? "");
    if (params["Limit"] != null) query.set("limit", params["Limit"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetResources",
      method: "GET",
      requestUri: "/api/v1/resources",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Folders": [toFolderMetadata],
        "Documents": [toDocumentMetadata],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async initiateDocumentVersionUpload(
    {abortSignal, ...params}: RequestConfig & s.InitiateDocumentVersionUploadRequest,
  ): Promise<s.InitiateDocumentVersionUploadResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Id: params["Id"],
      Name: params["Name"],
      ContentCreatedTimestamp: jsonP.serializeDate_unixTimestamp(params["ContentCreatedTimestamp"]),
      ContentModifiedTimestamp: jsonP.serializeDate_unixTimestamp(params["ContentModifiedTimestamp"]),
      ContentType: params["ContentType"],
      DocumentSizeInBytes: params["DocumentSizeInBytes"],
      ParentFolderId: params["ParentFolderId"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "InitiateDocumentVersionUpload",
      requestUri: "/api/v1/documents",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Metadata": toDocumentMetadata,
        "UploadMetadata": toUploadMetadata,
      },
    }, await resp.json());
  }

  async removeAllResourcePermissions(
    {abortSignal, ...params}: RequestConfig & s.RemoveAllResourcePermissionsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "RemoveAllResourcePermissions",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/permissions`,
      responseCode: 204,
    });
  }

  async removeResourcePermission(
    {abortSignal, ...params}: RequestConfig & s.RemoveResourcePermissionRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    if (params["PrincipalType"] != null) query.set("type", params["PrincipalType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "RemoveResourcePermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/api/v1/resources/${params["ResourceId"]}/permissions/${params["PrincipalId"]}`,
      responseCode: 204,
    });
  }

  async updateDocument(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ParentFolderId: params["ParentFolderId"],
      ResourceState: params["ResourceState"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDocument",
      method: "PATCH",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}`,
      responseCode: 200,
    });
  }

  async updateDocumentVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentVersionRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      VersionStatus: params["VersionStatus"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDocumentVersion",
      method: "PATCH",
      requestUri: cmnP.encodePath`/api/v1/documents/${params["DocumentId"]}/versions/${params["VersionId"]}`,
      responseCode: 200,
    });
  }

  async updateFolder(
    {abortSignal, ...params}: RequestConfig & s.UpdateFolderRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ParentFolderId: params["ParentFolderId"],
      ResourceState: params["ResourceState"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFolder",
      method: "PATCH",
      requestUri: cmnP.encodePath`/api/v1/folders/${params["FolderId"]}`,
      responseCode: 200,
    });
  }

  async updateUser(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserRequest,
  ): Promise<s.UpdateUserResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      GivenName: params["GivenName"],
      Surname: params["Surname"],
      Type: params["Type"],
      StorageRule: fromStorageRuleType(params["StorageRule"]),
      TimeZoneId: params["TimeZoneId"],
      Locale: params["Locale"],
      GrantPoweruserPrivileges: params["GrantPoweruserPrivileges"],
    };
    if (params["AuthenticationToken"] != null) headers.append("Authentication", params["AuthenticationToken"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateUser",
      method: "PATCH",
      requestUri: cmnP.encodePath`/api/v1/users/${params["UserId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "User": toUser,
      },
    }, await resp.json());
  }

}

function fromSharePrincipal(input?: s.SharePrincipal | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Type: input["Type"],
    Role: input["Role"],
  }
}

function fromNotificationOptions(input?: s.NotificationOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SendEmail: input["SendEmail"],
    EmailMessage: input["EmailMessage"],
  }
}

function fromStorageRuleType(input?: s.StorageRuleType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StorageAllocatedInBytes: input["StorageAllocatedInBytes"],
    StorageType: input["StorageType"],
  }
}
function toStorageRuleType(root: jsonP.JSONValue): s.StorageRuleType {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageAllocatedInBytes": "n",
      "StorageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.StorageType>(x),
    },
  }, root);
}

function toUser(root: jsonP.JSONValue): s.User {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Username": "s",
      "EmailAddress": "s",
      "GivenName": "s",
      "Surname": "s",
      "OrganizationId": "s",
      "RootFolderId": "s",
      "RecycleBinFolderId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserStatusType>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserType>(x),
      "CreatedTimestamp": "d",
      "ModifiedTimestamp": "d",
      "TimeZoneId": "s",
      "Locale": (x: jsonP.JSONValue) => cmnP.readEnum<s.LocaleType>(x),
      "Storage": toUserStorageMetadata,
    },
  }, root);
}

function toUserStorageMetadata(root: jsonP.JSONValue): s.UserStorageMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageUtilizedInBytes": "n",
      "StorageRule": toStorageRuleType,
    },
  }, root);
}

function toShareResult(root: jsonP.JSONValue): s.ShareResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrincipalId": "s",
      "InviteePrincipalId": "s",
      "Role": (x: jsonP.JSONValue) => cmnP.readEnum<s.RoleType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ShareStatusType>(x),
      "ShareId": "s",
      "StatusMessage": "s",
    },
  }, root);
}

function toComment(root: jsonP.JSONValue): s.Comment {
  return jsonP.readObj({
    required: {
      "CommentId": "s",
    },
    optional: {
      "ParentId": "s",
      "ThreadId": "s",
      "Text": "s",
      "Contributor": toUser,
      "CreatedTimestamp": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommentStatusType>(x),
      "Visibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommentVisibilityType>(x),
      "RecipientId": "s",
    },
  }, root);
}

function toFolderMetadata(root: jsonP.JSONValue): s.FolderMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "CreatorId": "s",
      "ParentFolderId": "s",
      "CreatedTimestamp": "d",
      "ModifiedTimestamp": "d",
      "ResourceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStateType>(x),
      "Signature": "s",
      "Labels": ["s"],
      "Size": "n",
      "LatestVersionSize": "n",
    },
  }, root);
}

function toSubscription(root: jsonP.JSONValue): s.Subscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubscriptionId": "s",
      "EndPoint": "s",
      "Protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.SubscriptionProtocolType>(x),
    },
  }, root);
}

function toActivity(root: jsonP.JSONValue): s.Activity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActivityType>(x),
      "TimeStamp": "d",
      "IsIndirectActivity": "b",
      "OrganizationId": "s",
      "Initiator": toUserMetadata,
      "Participants": toParticipants,
      "ResourceMetadata": toResourceMetadata,
      "OriginalParent": toResourceMetadata,
      "CommentMetadata": toCommentMetadata,
    },
  }, root);
}

function toUserMetadata(root: jsonP.JSONValue): s.UserMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Username": "s",
      "GivenName": "s",
      "Surname": "s",
      "EmailAddress": "s",
    },
  }, root);
}

function toParticipants(root: jsonP.JSONValue): s.Participants {
  return jsonP.readObj({
    required: {},
    optional: {
      "Users": [toUserMetadata],
      "Groups": [toGroupMetadata],
    },
  }, root);
}

function toGroupMetadata(root: jsonP.JSONValue): s.GroupMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
    },
  }, root);
}

function toResourceMetadata(root: jsonP.JSONValue): s.ResourceMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "Name": "s",
      "OriginalName": "s",
      "Id": "s",
      "VersionId": "s",
      "Owner": toUserMetadata,
      "ParentId": "s",
    },
  }, root);
}

function toCommentMetadata(root: jsonP.JSONValue): s.CommentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommentId": "s",
      "Contributor": toUser,
      "CreatedTimestamp": "d",
      "CommentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommentStatusType>(x),
      "RecipientId": "s",
    },
  }, root);
}

function toDocumentVersionMetadata(root: jsonP.JSONValue): s.DocumentVersionMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "ContentType": "s",
      "Size": "n",
      "Signature": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentStatusType>(x),
      "CreatedTimestamp": "d",
      "ModifiedTimestamp": "d",
      "ContentCreatedTimestamp": "d",
      "ContentModifiedTimestamp": "d",
      "CreatorId": "s",
      "Thumbnail": x => jsonP.readMap(x => cmnP.readEnumReq<s.DocumentThumbnailType>(x), String, x),
      "Source": x => jsonP.readMap(x => cmnP.readEnumReq<s.DocumentSourceType>(x), String, x),
    },
  }, root);
}

function toDocumentMetadata(root: jsonP.JSONValue): s.DocumentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "CreatorId": "s",
      "ParentFolderId": "s",
      "CreatedTimestamp": "d",
      "ModifiedTimestamp": "d",
      "LatestVersionMetadata": toDocumentVersionMetadata,
      "ResourceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceStateType>(x),
      "Labels": ["s"],
    },
  }, root);
}

function toPrincipal(root: jsonP.JSONValue): s.Principal {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.PrincipalType>(x),
      "Roles": [toPermissionInfo],
    },
  }, root);
}

function toPermissionInfo(root: jsonP.JSONValue): s.PermissionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Role": (x: jsonP.JSONValue) => cmnP.readEnum<s.RoleType>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.RolePermissionType>(x),
    },
  }, root);
}

function toResourcePath(root: jsonP.JSONValue): s.ResourcePath {
  return jsonP.readObj({
    required: {},
    optional: {
      "Components": [toResourcePathComponent],
    },
  }, root);
}

function toResourcePathComponent(root: jsonP.JSONValue): s.ResourcePathComponent {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
    },
  }, root);
}

function toUploadMetadata(root: jsonP.JSONValue): s.UploadMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "UploadUrl": "s",
      "SignedHeaders": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
