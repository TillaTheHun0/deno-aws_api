// Autogenerated API client for: Amazon SimpleDB

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class SimpleDB {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SimpleDB.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2009-04-15",
    "endpointPrefix": "sdb",
    "serviceFullName": "Amazon SimpleDB",
    "serviceId": "SimpleDB",
    "signatureVersion": "v2",
    "xmlNamespace": "http://sdb.amazonaws.com/doc/2009-04-15/",
    "protocol": "query",
    "uid": "sdb-2009-04-15"
  };

  async batchDeleteAttributes(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["Items"]) qsP.appendList(body, prefix+"Item", params["Items"], {"appender":DeletableItem_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteAttributes",
    });
  }

  async batchPutAttributes(
    {abortSignal, ...params}: RequestConfig & s.BatchPutAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["Items"]) qsP.appendList(body, prefix+"Item", params["Items"], {"appender":ReplaceableItem_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutAttributes",
    });
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
  }

  async deleteAttributes(
    {abortSignal, ...params}: RequestConfig & s.DeleteAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attribute", params["Attributes"], {"appender":DeletableAttribute_Serialize,"entryPrefix":"."})
    if (params["Expected"] != null) UpdateCondition_Serialize(body, prefix+"Expected", params["Expected"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAttributes",
    });
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
  }

  async domainMetadata(
    {abortSignal, ...params}: RequestConfig & s.DomainMetadataRequest,
  ): Promise<s.DomainMetadataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DomainMetadata",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DomainMetadataResult");
    return {
      ItemCount: xml.first("ItemCount", false, x => parseInt(x.content ?? '0')),
      ItemNamesSizeBytes: xml.first("ItemNamesSizeBytes", false, x => parseInt(x.content ?? '0')),
      AttributeNameCount: xml.first("AttributeNameCount", false, x => parseInt(x.content ?? '0')),
      AttributeNamesSizeBytes: xml.first("AttributeNamesSizeBytes", false, x => parseInt(x.content ?? '0')),
      AttributeValueCount: xml.first("AttributeValueCount", false, x => parseInt(x.content ?? '0')),
      AttributeValuesSizeBytes: xml.first("AttributeValuesSizeBytes", false, x => parseInt(x.content ?? '0')),
      Timestamp: xml.first("Timestamp", false, x => parseInt(x.content ?? '0')),
    };
  }

  async getAttributes(
    {abortSignal, ...params}: RequestConfig & s.GetAttributesRequest,
  ): Promise<s.GetAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeName", params["AttributeNames"], {"entryPrefix":"."})
    if ("ConsistentRead" in params) body.append(prefix+"ConsistentRead", (params["ConsistentRead"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAttributesResult");
    return {
      Attributes: xml.getList("Attribute").map(Attribute_Parse),
    };
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & s.ListDomainsRequest = {},
  ): Promise<s.ListDomainsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaxNumberOfDomains" in params) body.append(prefix+"MaxNumberOfDomains", (params["MaxNumberOfDomains"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListDomainsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      DomainNames: xml.getList("DomainName").map(x => x.content ?? ''),
    };
  }

  async putAttributes(
    {abortSignal, ...params}: RequestConfig & s.PutAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attribute", params["Attributes"], {"appender":ReplaceableAttribute_Serialize,"entryPrefix":"."})
    if (params["Expected"] != null) UpdateCondition_Serialize(body, prefix+"Expected", params["Expected"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAttributes",
    });
  }

  async select(
    {abortSignal, ...params}: RequestConfig & s.SelectRequest,
  ): Promise<s.SelectResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SelectExpression", (params["SelectExpression"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ConsistentRead" in params) body.append(prefix+"ConsistentRead", (params["ConsistentRead"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Select",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SelectResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Items: xml.getList("Item").map(Item_Parse),
    };
  }

}

function DeletableItem_Serialize(body: URLSearchParams, prefix: string, params: s.DeletableItem) {
    body.append(prefix+".ItemName", (params["Name"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+".Attribute", params["Attributes"], {"appender":DeletableAttribute_Serialize,"entryPrefix":"."})
}

function DeletableAttribute_Serialize(body: URLSearchParams, prefix: string, params: s.DeletableAttribute) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

function ReplaceableItem_Serialize(body: URLSearchParams, prefix: string, params: s.ReplaceableItem) {
    body.append(prefix+".ItemName", (params["Name"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+".Attribute", params["Attributes"], {"appender":ReplaceableAttribute_Serialize,"entryPrefix":"."})
}

function ReplaceableAttribute_Serialize(body: URLSearchParams, prefix: string, params: s.ReplaceableAttribute) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("Replace" in params) body.append(prefix+".Replace", (params["Replace"] ?? '').toString());
}

function UpdateCondition_Serialize(body: URLSearchParams, prefix: string, params: s.UpdateCondition) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("Exists" in params) body.append(prefix+".Exists", (params["Exists"] ?? '').toString());
}

function Attribute_Parse(node: xmlP.XmlNode): s.Attribute {
  return node.strings({
    required: {"Name":true,"Value":true},
    optional: {"AlternateNameEncoding":true,"AlternateValueEncoding":true},
  });
}

function Item_Parse(node: xmlP.XmlNode): s.Item {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"AlternateNameEncoding":true},
    }),
    Attributes: node.getList("Attribute").map(Attribute_Parse),
  };
}
