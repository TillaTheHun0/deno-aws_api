// Autogenerated API client for: Amazon DynamoDB

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class DynamoDB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DynamoDB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2012-08-10",
    "endpointPrefix": "dynamodb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "DynamoDB",
    "serviceFullName": "Amazon DynamoDB",
    "serviceId": "DynamoDB",
    "signatureVersion": "v4",
    "targetPrefix": "DynamoDB_20120810",
    "uid": "dynamodb-2012-08-10"
  };

  async batchGetItem(
    {abortSignal, ...params}: RequestConfig & BatchGetItemInput,
  ): Promise<BatchGetItemOutput> {
    const body: jsonP.JSONObject = params ? {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => fromKeysAndAttributes(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(y => jsonP.readMap(String, toAttributeValue, y)!) : [], x),
        "UnprocessedKeys": x => jsonP.readMap(String, toKeysAndAttributes, x),
        "ConsumedCapacity": [toConsumedCapacity],
      },
    }, await resp.json());
  }

  async batchWriteItem(
    {abortSignal, ...params}: RequestConfig & BatchWriteItemInput,
  ): Promise<BatchWriteItemOutput> {
    const body: jsonP.JSONObject = params ? {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => x?.map(fromWriteRequest)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchWriteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedItems": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toWriteRequest) : [], x),
        "ItemCollectionMetrics": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toItemCollectionMetrics) : [], x),
        "ConsumedCapacity": [toConsumedCapacity],
      },
    }, await resp.json());
  }

  async createBackup(
    {abortSignal, ...params}: RequestConfig & CreateBackupInput,
  ): Promise<CreateBackupOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      BackupName: params["BackupName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDetails": toBackupDetails,
      },
    }, await resp.json());
  }

  async createGlobalTable(
    {abortSignal, ...params}: RequestConfig & CreateGlobalTableInput,
  ): Promise<CreateGlobalTableOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalTableName: params["GlobalTableName"],
      ReplicationGroup: params["ReplicationGroup"]?.map(x => fromReplica(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & CreateTableInput,
  ): Promise<CreateTableOutput> {
    const body: jsonP.JSONObject = params ? {
      AttributeDefinitions: params["AttributeDefinitions"]?.map(x => fromAttributeDefinition(x)),
      TableName: params["TableName"],
      KeySchema: params["KeySchema"]?.map(x => fromKeySchemaElement(x)),
      LocalSecondaryIndexes: params["LocalSecondaryIndexes"]?.map(x => fromLocalSecondaryIndex(x)),
      GlobalSecondaryIndexes: params["GlobalSecondaryIndexes"]?.map(x => fromGlobalSecondaryIndex(x)),
      BillingMode: params["BillingMode"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
      StreamSpecification: fromStreamSpecification(params["StreamSpecification"]),
      SSESpecification: fromSSESpecification(params["SSESpecification"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async deleteBackup(
    {abortSignal, ...params}: RequestConfig & DeleteBackupInput,
  ): Promise<DeleteBackupOutput> {
    const body: jsonP.JSONObject = params ? {
      BackupArn: params["BackupArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDescription": toBackupDescription,
      },
    }, await resp.json());
  }

  async deleteItem(
    {abortSignal, ...params}: RequestConfig & DeleteItemInput,
  ): Promise<DeleteItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & DeleteTableInput,
  ): Promise<DeleteTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async describeBackup(
    {abortSignal, ...params}: RequestConfig & DescribeBackupInput,
  ): Promise<DescribeBackupOutput> {
    const body: jsonP.JSONObject = params ? {
      BackupArn: params["BackupArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupDescription": toBackupDescription,
      },
    }, await resp.json());
  }

  async describeContinuousBackups(
    {abortSignal, ...params}: RequestConfig & DescribeContinuousBackupsInput,
  ): Promise<DescribeContinuousBackupsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContinuousBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContinuousBackupsDescription": toContinuousBackupsDescription,
      },
    }, await resp.json());
  }

  async describeContributorInsights(
    {abortSignal, ...params}: RequestConfig & DescribeContributorInsightsInput,
  ): Promise<DescribeContributorInsightsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "IndexName": "s",
        "ContributorInsightsRuleList": ["s"],
        "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ContributorInsightsStatus>(x),
        "LastUpdateDateTime": "d",
        "FailureException": toFailureException,
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointsRequest = {},
  ): Promise<DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = params ? {
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpoint],
      },
      optional: {},
    }, await resp.json());
  }

  async describeGlobalTable(
    {abortSignal, ...params}: RequestConfig & DescribeGlobalTableInput,
  ): Promise<DescribeGlobalTableOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalTableName: params["GlobalTableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async describeGlobalTableSettings(
    {abortSignal, ...params}: RequestConfig & DescribeGlobalTableSettingsInput,
  ): Promise<DescribeGlobalTableSettingsOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalTableName: params["GlobalTableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeGlobalTableSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableName": "s",
        "ReplicaSettings": [toReplicaSettingsDescription],
      },
    }, await resp.json());
  }

  async describeLimits(
    {abortSignal, ...params}: RequestConfig & DescribeLimitsInput = {},
  ): Promise<DescribeLimitsOutput> {
    const body: jsonP.JSONObject = params ? {
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountMaxReadCapacityUnits": "n",
        "AccountMaxWriteCapacityUnits": "n",
        "TableMaxReadCapacityUnits": "n",
        "TableMaxWriteCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async describeTable(
    {abortSignal, ...params}: RequestConfig & DescribeTableInput,
  ): Promise<DescribeTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTableDescription,
      },
    }, await resp.json());
  }

  async describeTableReplicaAutoScaling(
    {abortSignal, ...params}: RequestConfig & DescribeTableReplicaAutoScalingInput,
  ): Promise<DescribeTableReplicaAutoScalingOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableReplicaAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableAutoScalingDescription": toTableAutoScalingDescription,
      },
    }, await resp.json());
  }

  async describeTimeToLive(
    {abortSignal, ...params}: RequestConfig & DescribeTimeToLiveInput,
  ): Promise<DescribeTimeToLiveOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTimeToLive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeToLiveDescription": toTimeToLiveDescription,
      },
    }, await resp.json());
  }

  async getItem(
    {abortSignal, ...params}: RequestConfig & GetItemInput,
  ): Promise<GetItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      AttributesToGet: params["AttributesToGet"],
      ConsistentRead: params["ConsistentRead"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ProjectionExpression: params["ProjectionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Item": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async listBackups(
    {abortSignal, ...params}: RequestConfig & ListBackupsInput = {},
  ): Promise<ListBackupsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Limit: params["Limit"],
      TimeRangeLowerBound: jsonP.serializeDate_unixTimestamp(params["TimeRangeLowerBound"]),
      TimeRangeUpperBound: jsonP.serializeDate_unixTimestamp(params["TimeRangeUpperBound"]),
      ExclusiveStartBackupArn: params["ExclusiveStartBackupArn"],
      BackupType: params["BackupType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BackupSummaries": [toBackupSummary],
        "LastEvaluatedBackupArn": "s",
      },
    }, await resp.json());
  }

  async listContributorInsights(
    {abortSignal, ...params}: RequestConfig & ListContributorInsightsInput = {},
  ): Promise<ListContributorInsightsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContributorInsightsSummaries": [toContributorInsightsSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listGlobalTables(
    {abortSignal, ...params}: RequestConfig & ListGlobalTablesInput = {},
  ): Promise<ListGlobalTablesOutput> {
    const body: jsonP.JSONObject = params ? {
      ExclusiveStartGlobalTableName: params["ExclusiveStartGlobalTableName"],
      Limit: params["Limit"],
      RegionName: params["RegionName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGlobalTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTables": [toGlobalTable],
        "LastEvaluatedGlobalTableName": "s",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & ListTablesInput = {},
  ): Promise<ListTablesOutput> {
    const body: jsonP.JSONObject = params ? {
      ExclusiveStartTableName: params["ExclusiveStartTableName"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableNames": ["s"],
        "LastEvaluatedTableName": "s",
      },
    }, await resp.json());
  }

  async listTagsOfResource(
    {abortSignal, ...params}: RequestConfig & ListTagsOfResourceInput,
  ): Promise<ListTagsOfResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsOfResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putItem(
    {abortSignal, ...params}: RequestConfig & PutItemInput,
  ): Promise<PutItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Item: jsonP.serializeMap(params["Item"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ConditionalOperator: params["ConditionalOperator"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & QueryInput,
  ): Promise<QueryOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      Select: params["Select"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      ConsistentRead: params["ConsistentRead"],
      KeyConditions: jsonP.serializeMap(params["KeyConditions"], x => fromCondition(x)),
      QueryFilter: jsonP.serializeMap(params["QueryFilter"], x => fromCondition(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ScanIndexForward: params["ScanIndexForward"],
      ExclusiveStartKey: jsonP.serializeMap(params["ExclusiveStartKey"], x => fromAttributeValue(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ProjectionExpression: params["ProjectionExpression"],
      FilterExpression: params["FilterExpression"],
      KeyConditionExpression: params["KeyConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async restoreTableFromBackup(
    {abortSignal, ...params}: RequestConfig & RestoreTableFromBackupInput,
  ): Promise<RestoreTableFromBackupOutput> {
    const body: jsonP.JSONObject = params ? {
      TargetTableName: params["TargetTableName"],
      BackupArn: params["BackupArn"],
      BillingModeOverride: params["BillingModeOverride"],
      GlobalSecondaryIndexOverride: params["GlobalSecondaryIndexOverride"]?.map(x => fromGlobalSecondaryIndex(x)),
      LocalSecondaryIndexOverride: params["LocalSecondaryIndexOverride"]?.map(x => fromLocalSecondaryIndex(x)),
      ProvisionedThroughputOverride: fromProvisionedThroughput(params["ProvisionedThroughputOverride"]),
      SSESpecificationOverride: fromSSESpecification(params["SSESpecificationOverride"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableFromBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async restoreTableToPointInTime(
    {abortSignal, ...params}: RequestConfig & RestoreTableToPointInTimeInput,
  ): Promise<RestoreTableToPointInTimeOutput> {
    const body: jsonP.JSONObject = params ? {
      SourceTableArn: params["SourceTableArn"],
      SourceTableName: params["SourceTableName"],
      TargetTableName: params["TargetTableName"],
      UseLatestRestorableTime: params["UseLatestRestorableTime"],
      RestoreDateTime: jsonP.serializeDate_unixTimestamp(params["RestoreDateTime"]),
      BillingModeOverride: params["BillingModeOverride"],
      GlobalSecondaryIndexOverride: params["GlobalSecondaryIndexOverride"]?.map(x => fromGlobalSecondaryIndex(x)),
      LocalSecondaryIndexOverride: params["LocalSecondaryIndexOverride"]?.map(x => fromLocalSecondaryIndex(x)),
      ProvisionedThroughputOverride: fromProvisionedThroughput(params["ProvisionedThroughputOverride"]),
      SSESpecificationOverride: fromSSESpecification(params["SSESpecificationOverride"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreTableToPointInTime",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async scan(
    {abortSignal, ...params}: RequestConfig & ScanInput,
  ): Promise<ScanOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      Select: params["Select"],
      ScanFilter: jsonP.serializeMap(params["ScanFilter"], x => fromCondition(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ExclusiveStartKey: jsonP.serializeMap(params["ExclusiveStartKey"], x => fromAttributeValue(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      TotalSegments: params["TotalSegments"],
      Segment: params["Segment"],
      ProjectionExpression: params["ProjectionExpression"],
      FilterExpression: params["FilterExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
      ConsistentRead: params["ConsistentRead"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Scan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async transactGetItems(
    {abortSignal, ...params}: RequestConfig & TransactGetItemsInput,
  ): Promise<TransactGetItemsOutput> {
    const body: jsonP.JSONObject = params ? {
      TransactItems: params["TransactItems"]?.map(x => fromTransactGetItem(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransactGetItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConsumedCapacity": [toConsumedCapacity],
        "Responses": [toItemResponse],
      },
    }, await resp.json());
  }

  async transactWriteItems(
    {abortSignal, ...params}: RequestConfig & TransactWriteItemsInput,
  ): Promise<TransactWriteItemsOutput> {
    const body: jsonP.JSONObject = params ? {
      TransactItems: params["TransactItems"]?.map(x => fromTransactWriteItem(x)),
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransactWriteItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConsumedCapacity": [toConsumedCapacity],
        "ItemCollectionMetrics": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toItemCollectionMetrics) : [], x),
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateContinuousBackups(
    {abortSignal, ...params}: RequestConfig & UpdateContinuousBackupsInput,
  ): Promise<UpdateContinuousBackupsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      PointInTimeRecoverySpecification: fromPointInTimeRecoverySpecification(params["PointInTimeRecoverySpecification"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContinuousBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContinuousBackupsDescription": toContinuousBackupsDescription,
      },
    }, await resp.json());
  }

  async updateContributorInsights(
    {abortSignal, ...params}: RequestConfig & UpdateContributorInsightsInput,
  ): Promise<UpdateContributorInsightsOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      IndexName: params["IndexName"],
      ContributorInsightsAction: params["ContributorInsightsAction"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContributorInsights",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableName": "s",
        "IndexName": "s",
        "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ContributorInsightsStatus>(x),
      },
    }, await resp.json());
  }

  async updateGlobalTable(
    {abortSignal, ...params}: RequestConfig & UpdateGlobalTableInput,
  ): Promise<UpdateGlobalTableOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalTableName: params["GlobalTableName"],
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicaUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGlobalTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableDescription": toGlobalTableDescription,
      },
    }, await resp.json());
  }

  async updateGlobalTableSettings(
    {abortSignal, ...params}: RequestConfig & UpdateGlobalTableSettingsInput,
  ): Promise<UpdateGlobalTableSettingsOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalTableName: params["GlobalTableName"],
      GlobalTableBillingMode: params["GlobalTableBillingMode"],
      GlobalTableProvisionedWriteCapacityUnits: params["GlobalTableProvisionedWriteCapacityUnits"],
      GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(params["GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate"]),
      GlobalTableGlobalSecondaryIndexSettingsUpdate: params["GlobalTableGlobalSecondaryIndexSettingsUpdate"]?.map(x => fromGlobalTableGlobalSecondaryIndexSettingsUpdate(x)),
      ReplicaSettingsUpdate: params["ReplicaSettingsUpdate"]?.map(x => fromReplicaSettingsUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGlobalTableSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GlobalTableName": "s",
        "ReplicaSettings": [toReplicaSettingsDescription],
      },
    }, await resp.json());
  }

  async updateItem(
    {abortSignal, ...params}: RequestConfig & UpdateItemInput,
  ): Promise<UpdateItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: jsonP.serializeMap(params["Key"], x => fromAttributeValue(x)),
      AttributeUpdates: jsonP.serializeMap(params["AttributeUpdates"], x => fromAttributeValueUpdate(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ConditionalOperator: params["ConditionalOperator"],
      ReturnValues: params["ReturnValues"],
      ReturnConsumedCapacity: params["ReturnConsumedCapacity"],
      ReturnItemCollectionMetrics: params["ReturnItemCollectionMetrics"],
      UpdateExpression: params["UpdateExpression"],
      ConditionExpression: params["ConditionExpression"],
      ExpressionAttributeNames: params["ExpressionAttributeNames"],
      ExpressionAttributeValues: jsonP.serializeMap(params["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacity": toConsumedCapacity,
        "ItemCollectionMetrics": toItemCollectionMetrics,
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & UpdateTableInput,
  ): Promise<UpdateTableOutput> {
    const body: jsonP.JSONObject = params ? {
      AttributeDefinitions: params["AttributeDefinitions"]?.map(x => fromAttributeDefinition(x)),
      TableName: params["TableName"],
      BillingMode: params["BillingMode"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
      GlobalSecondaryIndexUpdates: params["GlobalSecondaryIndexUpdates"]?.map(x => fromGlobalSecondaryIndexUpdate(x)),
      StreamSpecification: fromStreamSpecification(params["StreamSpecification"]),
      SSESpecification: fromSSESpecification(params["SSESpecification"]),
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicationGroupUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async updateTableReplicaAutoScaling(
    {abortSignal, ...params}: RequestConfig & UpdateTableReplicaAutoScalingInput,
  ): Promise<UpdateTableReplicaAutoScalingOutput> {
    const body: jsonP.JSONObject = params ? {
      GlobalSecondaryIndexUpdates: params["GlobalSecondaryIndexUpdates"]?.map(x => fromGlobalSecondaryIndexAutoScalingUpdate(x)),
      TableName: params["TableName"],
      ProvisionedWriteCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(params["ProvisionedWriteCapacityAutoScalingUpdate"]),
      ReplicaUpdates: params["ReplicaUpdates"]?.map(x => fromReplicaAutoScalingUpdate(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTableReplicaAutoScaling",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableAutoScalingDescription": toTableAutoScalingDescription,
      },
    }, await resp.json());
  }

  async updateTimeToLive(
    {abortSignal, ...params}: RequestConfig & UpdateTimeToLiveInput,
  ): Promise<UpdateTimeToLiveOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      TimeToLiveSpecification: fromTimeToLiveSpecification(params["TimeToLiveSpecification"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTimeToLive",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TimeToLiveSpecification": toTimeToLiveSpecification,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableExists(
    params: RequestConfig & DescribeTableInput,
  ): Promise<DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
        if (resp?.Table?.TableStatus === "ACTIVE") return resp;
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableNotExists(
    params: RequestConfig & DescribeTableInput,
  ): Promise<Error | DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableNotExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface BatchGetItemInput {
  RequestItems: { [key: string]: KeysAndAttributes | null | undefined };
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
}

// refs: 1 - tags: named, input
export interface BatchWriteItemInput {
  RequestItems: { [key: string]: WriteRequest[] | null | undefined };
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | null;
}

// refs: 1 - tags: named, input
export interface CreateBackupInput {
  TableName: string;
  BackupName: string;
}

// refs: 1 - tags: named, input
export interface CreateGlobalTableInput {
  GlobalTableName: string;
  ReplicationGroup: Replica[];
}

// refs: 1 - tags: named, input
export interface CreateTableInput {
  AttributeDefinitions: AttributeDefinition[];
  TableName: string;
  KeySchema: KeySchemaElement[];
  LocalSecondaryIndexes?: LocalSecondaryIndex[] | null;
  GlobalSecondaryIndexes?: GlobalSecondaryIndex[] | null;
  BillingMode?: BillingMode | null;
  ProvisionedThroughput?: ProvisionedThroughput | null;
  StreamSpecification?: StreamSpecification | null;
  SSESpecification?: SSESpecification | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteBackupInput {
  BackupArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteItemInput {
  TableName: string;
  Key: { [key: string]: AttributeValue | null | undefined };
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ConditionalOperator?: ConditionalOperator | null;
  ReturnValues?: ReturnValue | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | null;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteTableInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeBackupInput {
  BackupArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeContinuousBackupsInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeContributorInsightsInput {
  TableName: string;
  IndexName?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointsRequest {
}

// refs: 1 - tags: named, input
export interface DescribeGlobalTableInput {
  GlobalTableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeGlobalTableSettingsInput {
  GlobalTableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeLimitsInput {
}

// refs: 1 - tags: named, input
export interface DescribeTableInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTableReplicaAutoScalingInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTimeToLiveInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface GetItemInput {
  TableName: string;
  Key: { [key: string]: AttributeValue | null | undefined };
  AttributesToGet?: string[] | null;
  ConsistentRead?: boolean | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ProjectionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListBackupsInput {
  TableName?: string | null;
  Limit?: number | null;
  TimeRangeLowerBound?: Date | number | null;
  TimeRangeUpperBound?: Date | number | null;
  ExclusiveStartBackupArn?: string | null;
  BackupType?: BackupTypeFilter | null;
}

// refs: 1 - tags: named, input
export interface ListContributorInsightsInput {
  TableName?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListGlobalTablesInput {
  ExclusiveStartGlobalTableName?: string | null;
  Limit?: number | null;
  RegionName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTablesInput {
  ExclusiveStartTableName?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsOfResourceInput {
  ResourceArn: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutItemInput {
  TableName: string;
  Item: { [key: string]: AttributeValue | null | undefined };
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ReturnValues?: ReturnValue | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | null;
  ConditionalOperator?: ConditionalOperator | null;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface QueryInput {
  TableName: string;
  IndexName?: string | null;
  Select?: Select | null;
  AttributesToGet?: string[] | null;
  Limit?: number | null;
  ConsistentRead?: boolean | null;
  KeyConditions?: { [key: string]: Condition | null | undefined } | null;
  QueryFilter?: { [key: string]: Condition | null | undefined } | null;
  ConditionalOperator?: ConditionalOperator | null;
  ScanIndexForward?: boolean | null;
  ExclusiveStartKey?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ProjectionExpression?: string | null;
  FilterExpression?: string | null;
  KeyConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface RestoreTableFromBackupInput {
  TargetTableName: string;
  BackupArn: string;
  BillingModeOverride?: BillingMode | null;
  GlobalSecondaryIndexOverride?: GlobalSecondaryIndex[] | null;
  LocalSecondaryIndexOverride?: LocalSecondaryIndex[] | null;
  ProvisionedThroughputOverride?: ProvisionedThroughput | null;
  SSESpecificationOverride?: SSESpecification | null;
}

// refs: 1 - tags: named, input
export interface RestoreTableToPointInTimeInput {
  SourceTableArn?: string | null;
  SourceTableName?: string | null;
  TargetTableName: string;
  UseLatestRestorableTime?: boolean | null;
  RestoreDateTime?: Date | number | null;
  BillingModeOverride?: BillingMode | null;
  GlobalSecondaryIndexOverride?: GlobalSecondaryIndex[] | null;
  LocalSecondaryIndexOverride?: LocalSecondaryIndex[] | null;
  ProvisionedThroughputOverride?: ProvisionedThroughput | null;
  SSESpecificationOverride?: SSESpecification | null;
}

// refs: 1 - tags: named, input
export interface ScanInput {
  TableName: string;
  IndexName?: string | null;
  AttributesToGet?: string[] | null;
  Limit?: number | null;
  Select?: Select | null;
  ScanFilter?: { [key: string]: Condition | null | undefined } | null;
  ConditionalOperator?: ConditionalOperator | null;
  ExclusiveStartKey?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  TotalSegments?: number | null;
  Segment?: number | null;
  ProjectionExpression?: string | null;
  FilterExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsistentRead?: boolean | null;
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface TransactGetItemsInput {
  TransactItems: TransactGetItem[];
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
}

// refs: 1 - tags: named, input
export interface TransactWriteItemsInput {
  TransactItems: TransactWriteItem[];
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateContinuousBackupsInput {
  TableName: string;
  PointInTimeRecoverySpecification: PointInTimeRecoverySpecification;
}

// refs: 1 - tags: named, input
export interface UpdateContributorInsightsInput {
  TableName: string;
  IndexName?: string | null;
  ContributorInsightsAction: ContributorInsightsAction;
}

// refs: 1 - tags: named, input
export interface UpdateGlobalTableInput {
  GlobalTableName: string;
  ReplicaUpdates: ReplicaUpdate[];
}

// refs: 1 - tags: named, input
export interface UpdateGlobalTableSettingsInput {
  GlobalTableName: string;
  GlobalTableBillingMode?: BillingMode | null;
  GlobalTableProvisionedWriteCapacityUnits?: number | null;
  GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate | null;
  GlobalTableGlobalSecondaryIndexSettingsUpdate?: GlobalTableGlobalSecondaryIndexSettingsUpdate[] | null;
  ReplicaSettingsUpdate?: ReplicaSettingsUpdate[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateItemInput {
  TableName: string;
  Key: { [key: string]: AttributeValue | null | undefined };
  AttributeUpdates?: { [key: string]: AttributeValueUpdate | null | undefined } | null;
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ConditionalOperator?: ConditionalOperator | null;
  ReturnValues?: ReturnValue | null;
  ReturnConsumedCapacity?: ReturnConsumedCapacity | null;
  ReturnItemCollectionMetrics?: ReturnItemCollectionMetrics | null;
  UpdateExpression?: string | null;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface UpdateTableInput {
  AttributeDefinitions?: AttributeDefinition[] | null;
  TableName: string;
  BillingMode?: BillingMode | null;
  ProvisionedThroughput?: ProvisionedThroughput | null;
  GlobalSecondaryIndexUpdates?: GlobalSecondaryIndexUpdate[] | null;
  StreamSpecification?: StreamSpecification | null;
  SSESpecification?: SSESpecification | null;
  ReplicaUpdates?: ReplicationGroupUpdate[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateTableReplicaAutoScalingInput {
  GlobalSecondaryIndexUpdates?: GlobalSecondaryIndexAutoScalingUpdate[] | null;
  TableName: string;
  ProvisionedWriteCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate | null;
  ReplicaUpdates?: ReplicaAutoScalingUpdate[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateTimeToLiveInput {
  TableName: string;
  TimeToLiveSpecification: TimeToLiveSpecification;
}

// refs: 1 - tags: named, output
export interface BatchGetItemOutput {
  Responses?: { [key: string]: ({ [key: string]: AttributeValue | null | undefined })[] | null | undefined } | null;
  UnprocessedKeys?: { [key: string]: KeysAndAttributes | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity[] | null;
}

// refs: 1 - tags: named, output
export interface BatchWriteItemOutput {
  UnprocessedItems?: { [key: string]: WriteRequest[] | null | undefined } | null;
  ItemCollectionMetrics?: { [key: string]: ItemCollectionMetrics[] | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity[] | null;
}

// refs: 1 - tags: named, output
export interface CreateBackupOutput {
  BackupDetails?: BackupDetails | null;
}

// refs: 1 - tags: named, output
export interface CreateGlobalTableOutput {
  GlobalTableDescription?: GlobalTableDescription | null;
}

// refs: 1 - tags: named, output
export interface CreateTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteBackupOutput {
  BackupDescription?: BackupDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
  ItemCollectionMetrics?: ItemCollectionMetrics | null;
}

// refs: 1 - tags: named, output
export interface DeleteTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeBackupOutput {
  BackupDescription?: BackupDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeContinuousBackupsOutput {
  ContinuousBackupsDescription?: ContinuousBackupsDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeContributorInsightsOutput {
  TableName?: string | null;
  IndexName?: string | null;
  ContributorInsightsRuleList?: string[] | null;
  ContributorInsightsStatus?: ContributorInsightsStatus | null;
  LastUpdateDateTime?: Date | number | null;
  FailureException?: FailureException | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointsResponse {
  Endpoints: Endpoint[];
}

// refs: 1 - tags: named, output
export interface DescribeGlobalTableOutput {
  GlobalTableDescription?: GlobalTableDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeGlobalTableSettingsOutput {
  GlobalTableName?: string | null;
  ReplicaSettings?: ReplicaSettingsDescription[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeLimitsOutput {
  AccountMaxReadCapacityUnits?: number | null;
  AccountMaxWriteCapacityUnits?: number | null;
  TableMaxReadCapacityUnits?: number | null;
  TableMaxWriteCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeTableOutput {
  Table?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeTableReplicaAutoScalingOutput {
  TableAutoScalingDescription?: TableAutoScalingDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeTimeToLiveOutput {
  TimeToLiveDescription?: TimeToLiveDescription | null;
}

// refs: 1 - tags: named, output
export interface GetItemOutput {
  Item?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
}

// refs: 1 - tags: named, output
export interface ListBackupsOutput {
  BackupSummaries?: BackupSummary[] | null;
  LastEvaluatedBackupArn?: string | null;
}

// refs: 1 - tags: named, output
export interface ListContributorInsightsOutput {
  ContributorInsightsSummaries?: ContributorInsightsSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListGlobalTablesOutput {
  GlobalTables?: GlobalTable[] | null;
  LastEvaluatedGlobalTableName?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTablesOutput {
  TableNames?: string[] | null;
  LastEvaluatedTableName?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsOfResourceOutput {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
  ItemCollectionMetrics?: ItemCollectionMetrics | null;
}

// refs: 1 - tags: named, output
export interface QueryOutput {
  Items?: ({ [key: string]: AttributeValue | null | undefined })[] | null;
  Count?: number | null;
  ScannedCount?: number | null;
  LastEvaluatedKey?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
}

// refs: 1 - tags: named, output
export interface RestoreTableFromBackupOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface RestoreTableToPointInTimeOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface ScanOutput {
  Items?: ({ [key: string]: AttributeValue | null | undefined })[] | null;
  Count?: number | null;
  ScannedCount?: number | null;
  LastEvaluatedKey?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
}

// refs: 1 - tags: named, output
export interface TransactGetItemsOutput {
  ConsumedCapacity?: ConsumedCapacity[] | null;
  Responses?: ItemResponse[] | null;
}

// refs: 1 - tags: named, output
export interface TransactWriteItemsOutput {
  ConsumedCapacity?: ConsumedCapacity[] | null;
  ItemCollectionMetrics?: { [key: string]: ItemCollectionMetrics[] | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface UpdateContinuousBackupsOutput {
  ContinuousBackupsDescription?: ContinuousBackupsDescription | null;
}

// refs: 1 - tags: named, output
export interface UpdateContributorInsightsOutput {
  TableName?: string | null;
  IndexName?: string | null;
  ContributorInsightsStatus?: ContributorInsightsStatus | null;
}

// refs: 1 - tags: named, output
export interface UpdateGlobalTableOutput {
  GlobalTableDescription?: GlobalTableDescription | null;
}

// refs: 1 - tags: named, output
export interface UpdateGlobalTableSettingsOutput {
  GlobalTableName?: string | null;
  ReplicaSettings?: ReplicaSettingsDescription[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacity?: ConsumedCapacity | null;
  ItemCollectionMetrics?: ItemCollectionMetrics | null;
}

// refs: 1 - tags: named, output
export interface UpdateTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface UpdateTableReplicaAutoScalingOutput {
  TableAutoScalingDescription?: TableAutoScalingDescription | null;
}

// refs: 1 - tags: named, output
export interface UpdateTimeToLiveOutput {
  TimeToLiveSpecification?: TimeToLiveSpecification | null;
}

// refs: 2 - tags: input, named, interface, output
export interface KeysAndAttributes {
  Keys: ({ [key: string]: AttributeValue | null | undefined })[];
  AttributesToGet?: string[] | null;
  ConsistentRead?: boolean | null;
  ProjectionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
}
function fromKeysAndAttributes(input?: KeysAndAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"]?.map(x => jsonP.serializeMap(x, fromAttributeValue)),
    AttributesToGet: input["AttributesToGet"],
    ConsistentRead: input["ConsistentRead"],
    ProjectionExpression: input["ProjectionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
  }
}
function toKeysAndAttributes(root: jsonP.JSONValue): KeysAndAttributes {
  return jsonP.readObj({
    required: {
      "Keys": [x => jsonP.readMap(String, toAttributeValue, x)],
    },
    optional: {
      "AttributesToGet": ["s"],
      "ConsistentRead": "b",
      "ProjectionExpression": "s",
      "ExpressionAttributeNames": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 153 - tags: input, named, interface, recursed, output
export interface AttributeValue {
  S?: string | null;
  N?: string | null;
  B?: Uint8Array | string | null;
  SS?: string[] | null;
  NS?: string[] | null;
  BS?: (Uint8Array | string)[] | null;
  M?: { [key: string]: AttributeValue | null | undefined } | null;
  L?: AttributeValue[] | null;
  NULL?: boolean | null;
  BOOL?: boolean | null;
}
function fromAttributeValue(input?: AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    B: jsonP.serializeBlob(input["B"]),
    SS: input["SS"],
    NS: input["NS"],
    BS: input["BS"]?.map(x => jsonP.serializeBlob(x)),
    M: jsonP.serializeMap(input["M"], x => fromAttributeValue(x)),
    L: input["L"]?.map(x => fromAttributeValue(x)),
    NULL: input["NULL"],
    BOOL: input["BOOL"],
  }
}
function toAttributeValue(root: jsonP.JSONValue): AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "s",
      "B": "a",
      "SS": ["s"],
      "NS": ["s"],
      "BS": ["a"],
      "M": x => jsonP.readMap(String, toAttributeValue, x),
      "L": [toAttributeValue],
      "NULL": "b",
      "BOOL": "b",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum
export type ReturnConsumedCapacity =
| "INDEXES"
| "TOTAL"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface WriteRequest {
  PutRequest?: PutRequest | null;
  DeleteRequest?: DeleteRequest | null;
}
function fromWriteRequest(input?: WriteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PutRequest: fromPutRequest(input["PutRequest"]),
    DeleteRequest: fromDeleteRequest(input["DeleteRequest"]),
  }
}
function toWriteRequest(root: jsonP.JSONValue): WriteRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "PutRequest": toPutRequest,
      "DeleteRequest": toDeleteRequest,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PutRequest {
  Item: { [key: string]: AttributeValue | null | undefined };
}
function fromPutRequest(input?: PutRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
  }
}
function toPutRequest(root: jsonP.JSONValue): PutRequest {
  return jsonP.readObj({
    required: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DeleteRequest {
  Key: { [key: string]: AttributeValue | null | undefined };
}
function fromDeleteRequest(input?: DeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
  }
}
function toDeleteRequest(root: jsonP.JSONValue): DeleteRequest {
  return jsonP.readObj({
    required: {
      "Key": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, enum
export type ReturnItemCollectionMetrics =
| "SIZE"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Replica {
  RegionName?: string | null;
}
function fromReplica(input?: Replica | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}
function toReplica(root: jsonP.JSONValue): Replica {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface AttributeDefinition {
  AttributeName: string;
  AttributeType: ScalarAttributeType;
}
function fromAttributeDefinition(input?: AttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toAttributeDefinition(root: jsonP.JSONValue): AttributeDefinition {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<ScalarAttributeType>(x),
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type ScalarAttributeType =
| "S"
| "N"
| "B"
| cmnP.UnexpectedEnumValue;

// refs: 32 - tags: input, named, interface, output
export interface KeySchemaElement {
  AttributeName: string;
  KeyType: KeyType;
}
function fromKeySchemaElement(input?: KeySchemaElement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    KeyType: input["KeyType"],
  }
}
function toKeySchemaElement(root: jsonP.JSONValue): KeySchemaElement {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<KeyType>(x),
    },
    optional: {},
  }, root);
}

// refs: 32 - tags: input, named, enum, output
export type KeyType =
| "HASH"
| "RANGE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface LocalSecondaryIndex {
  IndexName: string;
  KeySchema: KeySchemaElement[];
  Projection: Projection;
}
function fromLocalSecondaryIndex(input?: LocalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
  }
}

// refs: 23 - tags: input, named, interface, output
export interface Projection {
  ProjectionType?: ProjectionType | null;
  NonKeyAttributes?: string[] | null;
}
function fromProjection(input?: Projection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProjectionType: input["ProjectionType"],
    NonKeyAttributes: input["NonKeyAttributes"],
  }
}
function toProjection(root: jsonP.JSONValue): Projection {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ProjectionType>(x),
      "NonKeyAttributes": ["s"],
    },
  }, root);
}

// refs: 23 - tags: input, named, enum, output
export type ProjectionType =
| "ALL"
| "KEYS_ONLY"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface GlobalSecondaryIndex {
  IndexName: string;
  KeySchema: KeySchemaElement[];
  Projection: Projection;
  ProvisionedThroughput?: ProvisionedThroughput | null;
}
function fromGlobalSecondaryIndex(input?: GlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

// refs: 13 - tags: input, named, interface, output
export interface ProvisionedThroughput {
  ReadCapacityUnits: number;
  WriteCapacityUnits: number;
}
function fromProvisionedThroughput(input?: ProvisionedThroughput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
    WriteCapacityUnits: input["WriteCapacityUnits"],
  }
}
function toProvisionedThroughput(root: jsonP.JSONValue): ProvisionedThroughput {
  return jsonP.readObj({
    required: {
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
    optional: {},
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type BillingMode =
| "PROVISIONED"
| "PAY_PER_REQUEST"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface StreamSpecification {
  StreamEnabled: boolean;
  StreamViewType?: StreamViewType | null;
}
function fromStreamSpecification(input?: StreamSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamEnabled: input["StreamEnabled"],
    StreamViewType: input["StreamViewType"],
  }
}
function toStreamSpecification(root: jsonP.JSONValue): StreamSpecification {
  return jsonP.readObj({
    required: {
      "StreamEnabled": "b",
    },
    optional: {
      "StreamViewType": (x: jsonP.JSONValue) => cmnP.readEnum<StreamViewType>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type StreamViewType =
| "NEW_IMAGE"
| "OLD_IMAGE"
| "NEW_AND_OLD_IMAGES"
| "KEYS_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface
export interface SSESpecification {
  Enabled?: boolean | null;
  SSEType?: SSEType | null;
  KMSMasterKeyId?: string | null;
}
function fromSSESpecification(input?: SSESpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    SSEType: input["SSEType"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
  }
}

// refs: 12 - tags: input, named, enum, output
export type SSEType =
| "AES256"
| "KMS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface
export interface ExpectedAttributeValue {
  Value?: AttributeValue | null;
  Exists?: boolean | null;
  ComparisonOperator?: ComparisonOperator | null;
  AttributeValueList?: AttributeValue[] | null;
}
function fromExpectedAttributeValue(input?: ExpectedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Exists: input["Exists"],
    ComparisonOperator: input["ComparisonOperator"],
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
  }
}

// refs: 6 - tags: input, named, enum
export type ComparisonOperator =
| "EQ"
| "NE"
| "IN"
| "LE"
| "LT"
| "GE"
| "GT"
| "BETWEEN"
| "NOT_NULL"
| "NULL"
| "CONTAINS"
| "NOT_CONTAINS"
| "BEGINS_WITH"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum
export type ConditionalOperator =
| "AND"
| "OR"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum
export type ReturnValue =
| "NONE"
| "ALL_OLD"
| "UPDATED_OLD"
| "ALL_NEW"
| "UPDATED_NEW"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type BackupTypeFilter =
| "USER"
| "SYSTEM"
| "AWS_BACKUP"
| "ALL"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type Select =
| "ALL_ATTRIBUTES"
| "ALL_PROJECTED_ATTRIBUTES"
| "SPECIFIC_ATTRIBUTES"
| "COUNT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface Condition {
  AttributeValueList?: AttributeValue[] | null;
  ComparisonOperator: ComparisonOperator;
}
function fromCondition(input?: Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
    ComparisonOperator: input["ComparisonOperator"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TransactGetItem {
  Get: Get;
}
function fromTransactGetItem(input?: TransactGetItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Get: fromGet(input["Get"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface Get {
  Key: { [key: string]: AttributeValue | null | undefined };
  TableName: string;
  ProjectionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
}
function fromGet(input?: Get | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ProjectionExpression: input["ProjectionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TransactWriteItem {
  ConditionCheck?: ConditionCheck | null;
  Put?: Put | null;
  Delete?: Delete | null;
  Update?: Update | null;
}
function fromTransactWriteItem(input?: TransactWriteItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConditionCheck: fromConditionCheck(input["ConditionCheck"]),
    Put: fromPut(input["Put"]),
    Delete: fromDelete(input["Delete"]),
    Update: fromUpdate(input["Update"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ConditionCheck {
  Key: { [key: string]: AttributeValue | null | undefined };
  TableName: string;
  ConditionExpression: string;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | null;
}
function fromConditionCheck(input?: ConditionCheck | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

// refs: 4 - tags: input, named, enum
export type ReturnValuesOnConditionCheckFailure =
| "ALL_OLD"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Put {
  Item: { [key: string]: AttributeValue | null | undefined };
  TableName: string;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | null;
}
function fromPut(input?: Put | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

// refs: 1 - tags: input, named, interface
export interface Delete {
  Key: { [key: string]: AttributeValue | null | undefined };
  TableName: string;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | null;
}
function fromDelete(input?: Delete | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

// refs: 1 - tags: input, named, interface
export interface Update {
  Key: { [key: string]: AttributeValue | null | undefined };
  UpdateExpression: string;
  TableName: string;
  ConditionExpression?: string | null;
  ExpressionAttributeNames?: { [key: string]: string | null | undefined } | null;
  ExpressionAttributeValues?: { [key: string]: AttributeValue | null | undefined } | null;
  ReturnValuesOnConditionCheckFailure?: ReturnValuesOnConditionCheckFailure | null;
}
function fromUpdate(input?: Update | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: jsonP.serializeMap(input["Key"], x => fromAttributeValue(x)),
    UpdateExpression: input["UpdateExpression"],
    TableName: input["TableName"],
    ConditionExpression: input["ConditionExpression"],
    ExpressionAttributeNames: input["ExpressionAttributeNames"],
    ExpressionAttributeValues: jsonP.serializeMap(input["ExpressionAttributeValues"], x => fromAttributeValue(x)),
    ReturnValuesOnConditionCheckFailure: input["ReturnValuesOnConditionCheckFailure"],
  }
}

// refs: 1 - tags: input, named, interface
export interface PointInTimeRecoverySpecification {
  PointInTimeRecoveryEnabled: boolean;
}
function fromPointInTimeRecoverySpecification(input?: PointInTimeRecoverySpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PointInTimeRecoveryEnabled: input["PointInTimeRecoveryEnabled"],
  }
}

// refs: 1 - tags: input, named, enum
export type ContributorInsightsAction =
| "ENABLE"
| "DISABLE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ReplicaUpdate {
  Create?: CreateReplicaAction | null;
  Delete?: DeleteReplicaAction | null;
}
function fromReplicaUpdate(input?: ReplicaUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Create: fromCreateReplicaAction(input["Create"]),
    Delete: fromDeleteReplicaAction(input["Delete"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateReplicaAction {
  RegionName: string;
}
function fromCreateReplicaAction(input?: CreateReplicaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface DeleteReplicaAction {
  RegionName: string;
}
function fromDeleteReplicaAction(input?: DeleteReplicaAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

// refs: 8 - tags: input, named, interface
export interface AutoScalingSettingsUpdate {
  MinimumUnits?: number | null;
  MaximumUnits?: number | null;
  AutoScalingDisabled?: boolean | null;
  AutoScalingRoleArn?: string | null;
  ScalingPolicyUpdate?: AutoScalingPolicyUpdate | null;
}
function fromAutoScalingSettingsUpdate(input?: AutoScalingSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumUnits: input["MinimumUnits"],
    MaximumUnits: input["MaximumUnits"],
    AutoScalingDisabled: input["AutoScalingDisabled"],
    AutoScalingRoleArn: input["AutoScalingRoleArn"],
    ScalingPolicyUpdate: fromAutoScalingPolicyUpdate(input["ScalingPolicyUpdate"]),
  }
}

// refs: 8 - tags: input, named, interface
export interface AutoScalingPolicyUpdate {
  PolicyName?: string | null;
  TargetTrackingScalingPolicyConfiguration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate;
}
function fromAutoScalingPolicyUpdate(input?: AutoScalingPolicyUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
    TargetTrackingScalingPolicyConfiguration: fromAutoScalingTargetTrackingScalingPolicyConfigurationUpdate(input["TargetTrackingScalingPolicyConfiguration"]),
  }
}

// refs: 8 - tags: input, named, interface
export interface AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
  DisableScaleIn?: boolean | null;
  ScaleInCooldown?: number | null;
  ScaleOutCooldown?: number | null;
  TargetValue: number;
}
function fromAutoScalingTargetTrackingScalingPolicyConfigurationUpdate(input?: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DisableScaleIn: input["DisableScaleIn"],
    ScaleInCooldown: input["ScaleInCooldown"],
    ScaleOutCooldown: input["ScaleOutCooldown"],
    TargetValue: input["TargetValue"],
  }
}

// refs: 1 - tags: input, named, interface
export interface GlobalTableGlobalSecondaryIndexSettingsUpdate {
  IndexName: string;
  ProvisionedWriteCapacityUnits?: number | null;
  ProvisionedWriteCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate | null;
}
function fromGlobalTableGlobalSecondaryIndexSettingsUpdate(input?: GlobalTableGlobalSecondaryIndexSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedWriteCapacityUnits: input["ProvisionedWriteCapacityUnits"],
    ProvisionedWriteCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedWriteCapacityAutoScalingSettingsUpdate"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ReplicaSettingsUpdate {
  RegionName: string;
  ReplicaProvisionedReadCapacityUnits?: number | null;
  ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate | null;
  ReplicaGlobalSecondaryIndexSettingsUpdate?: ReplicaGlobalSecondaryIndexSettingsUpdate[] | null;
}
function fromReplicaSettingsUpdate(input?: ReplicaSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    ReplicaProvisionedReadCapacityUnits: input["ReplicaProvisionedReadCapacityUnits"],
    ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate"]),
    ReplicaGlobalSecondaryIndexSettingsUpdate: input["ReplicaGlobalSecondaryIndexSettingsUpdate"]?.map(x => fromReplicaGlobalSecondaryIndexSettingsUpdate(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface ReplicaGlobalSecondaryIndexSettingsUpdate {
  IndexName: string;
  ProvisionedReadCapacityUnits?: number | null;
  ProvisionedReadCapacityAutoScalingSettingsUpdate?: AutoScalingSettingsUpdate | null;
}
function fromReplicaGlobalSecondaryIndexSettingsUpdate(input?: ReplicaGlobalSecondaryIndexSettingsUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedReadCapacityUnits: input["ProvisionedReadCapacityUnits"],
    ProvisionedReadCapacityAutoScalingSettingsUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedReadCapacityAutoScalingSettingsUpdate"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface AttributeValueUpdate {
  Value?: AttributeValue | null;
  Action?: AttributeAction | null;
}
function fromAttributeValueUpdate(input?: AttributeValueUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Action: input["Action"],
  }
}

// refs: 1 - tags: input, named, enum
export type AttributeAction =
| "ADD"
| "PUT"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface GlobalSecondaryIndexUpdate {
  Update?: UpdateGlobalSecondaryIndexAction | null;
  Create?: CreateGlobalSecondaryIndexAction | null;
  Delete?: DeleteGlobalSecondaryIndexAction | null;
}
function fromGlobalSecondaryIndexUpdate(input?: GlobalSecondaryIndexUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Update: fromUpdateGlobalSecondaryIndexAction(input["Update"]),
    Create: fromCreateGlobalSecondaryIndexAction(input["Create"]),
    Delete: fromDeleteGlobalSecondaryIndexAction(input["Delete"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateGlobalSecondaryIndexAction {
  IndexName: string;
  ProvisionedThroughput: ProvisionedThroughput;
}
function fromUpdateGlobalSecondaryIndexAction(input?: UpdateGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateGlobalSecondaryIndexAction {
  IndexName: string;
  KeySchema: KeySchemaElement[];
  Projection: Projection;
  ProvisionedThroughput?: ProvisionedThroughput | null;
}
function fromCreateGlobalSecondaryIndexAction(input?: CreateGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromKeySchemaElement(x)),
    Projection: fromProjection(input["Projection"]),
    ProvisionedThroughput: fromProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface DeleteGlobalSecondaryIndexAction {
  IndexName: string;
}
function fromDeleteGlobalSecondaryIndexAction(input?: DeleteGlobalSecondaryIndexAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface ReplicationGroupUpdate {
  Create?: CreateReplicationGroupMemberAction | null;
  Update?: UpdateReplicationGroupMemberAction | null;
  Delete?: DeleteReplicationGroupMemberAction | null;
}
function fromReplicationGroupUpdate(input?: ReplicationGroupUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Create: fromCreateReplicationGroupMemberAction(input["Create"]),
    Update: fromUpdateReplicationGroupMemberAction(input["Update"]),
    Delete: fromDeleteReplicationGroupMemberAction(input["Delete"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateReplicationGroupMemberAction {
  RegionName: string;
  KMSMasterKeyId?: string | null;
  ProvisionedThroughputOverride?: ProvisionedThroughputOverride | null;
  GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndex[] | null;
}
function fromCreateReplicationGroupMemberAction(input?: CreateReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromReplicaGlobalSecondaryIndex(x)),
  }
}

// refs: 22 - tags: input, named, interface, output
export interface ProvisionedThroughputOverride {
  ReadCapacityUnits?: number | null;
}
function fromProvisionedThroughputOverride(input?: ProvisionedThroughputOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
  }
}
function toProvisionedThroughputOverride(root: jsonP.JSONValue): ProvisionedThroughputOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadCapacityUnits": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface ReplicaGlobalSecondaryIndex {
  IndexName: string;
  ProvisionedThroughputOverride?: ProvisionedThroughputOverride | null;
}
function fromReplicaGlobalSecondaryIndex(input?: ReplicaGlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateReplicationGroupMemberAction {
  RegionName: string;
  KMSMasterKeyId?: string | null;
  ProvisionedThroughputOverride?: ProvisionedThroughputOverride | null;
  GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndex[] | null;
}
function fromUpdateReplicationGroupMemberAction(input?: UpdateReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    KMSMasterKeyId: input["KMSMasterKeyId"],
    ProvisionedThroughputOverride: fromProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromReplicaGlobalSecondaryIndex(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface DeleteReplicationGroupMemberAction {
  RegionName: string;
}
function fromDeleteReplicationGroupMemberAction(input?: DeleteReplicationGroupMemberAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
  }
}

// refs: 1 - tags: input, named, interface
export interface GlobalSecondaryIndexAutoScalingUpdate {
  IndexName?: string | null;
  ProvisionedWriteCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate | null;
}
function fromGlobalSecondaryIndexAutoScalingUpdate(input?: GlobalSecondaryIndexAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedWriteCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedWriteCapacityAutoScalingUpdate"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ReplicaAutoScalingUpdate {
  RegionName: string;
  ReplicaGlobalSecondaryIndexUpdates?: ReplicaGlobalSecondaryIndexAutoScalingUpdate[] | null;
  ReplicaProvisionedReadCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate | null;
}
function fromReplicaAutoScalingUpdate(input?: ReplicaAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegionName: input["RegionName"],
    ReplicaGlobalSecondaryIndexUpdates: input["ReplicaGlobalSecondaryIndexUpdates"]?.map(x => fromReplicaGlobalSecondaryIndexAutoScalingUpdate(x)),
    ReplicaProvisionedReadCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ReplicaProvisionedReadCapacityAutoScalingUpdate"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ReplicaGlobalSecondaryIndexAutoScalingUpdate {
  IndexName?: string | null;
  ProvisionedReadCapacityAutoScalingUpdate?: AutoScalingSettingsUpdate | null;
}
function fromReplicaGlobalSecondaryIndexAutoScalingUpdate(input?: ReplicaGlobalSecondaryIndexAutoScalingUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedReadCapacityAutoScalingUpdate: fromAutoScalingSettingsUpdate(input["ProvisionedReadCapacityAutoScalingUpdate"]),
  }
}

// refs: 2 - tags: input, named, interface, output
export interface TimeToLiveSpecification {
  Enabled: boolean;
  AttributeName: string;
}
function fromTimeToLiveSpecification(input?: TimeToLiveSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    AttributeName: input["AttributeName"],
  }
}
function toTimeToLiveSpecification(root: jsonP.JSONValue): TimeToLiveSpecification {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
      "AttributeName": "s",
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface ConsumedCapacity {
  TableName?: string | null;
  CapacityUnits?: number | null;
  ReadCapacityUnits?: number | null;
  WriteCapacityUnits?: number | null;
  Table?: Capacity | null;
  LocalSecondaryIndexes?: { [key: string]: Capacity | null | undefined } | null;
  GlobalSecondaryIndexes?: { [key: string]: Capacity | null | undefined } | null;
}
function toConsumedCapacity(root: jsonP.JSONValue): ConsumedCapacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "CapacityUnits": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
      "Table": toCapacity,
      "LocalSecondaryIndexes": x => jsonP.readMap(String, toCapacity, x),
      "GlobalSecondaryIndexes": x => jsonP.readMap(String, toCapacity, x),
    },
  }, root);
}

// refs: 30 - tags: output, named, interface
export interface Capacity {
  ReadCapacityUnits?: number | null;
  WriteCapacityUnits?: number | null;
  CapacityUnits?: number | null;
}
function toCapacity(root: jsonP.JSONValue): Capacity {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
      "CapacityUnits": "n",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface ItemCollectionMetrics {
  ItemCollectionKey?: { [key: string]: AttributeValue | null | undefined } | null;
  SizeEstimateRangeGB?: number[] | null;
}
function toItemCollectionMetrics(root: jsonP.JSONValue): ItemCollectionMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "ItemCollectionKey": x => jsonP.readMap(String, toAttributeValue, x),
      "SizeEstimateRangeGB": ["n"],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface BackupDetails {
  BackupArn: string;
  BackupName: string;
  BackupSizeBytes?: number | null;
  BackupStatus: BackupStatus;
  BackupType: BackupType;
  BackupCreationDateTime: Date | number;
  BackupExpiryDateTime?: Date | number | null;
}
function toBackupDetails(root: jsonP.JSONValue): BackupDetails {
  return jsonP.readObj({
    required: {
      "BackupArn": "s",
      "BackupName": "s",
      "BackupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<BackupStatus>(x),
      "BackupType": (x: jsonP.JSONValue) => cmnP.readEnum<BackupType>(x),
      "BackupCreationDateTime": "d",
    },
    optional: {
      "BackupSizeBytes": "n",
      "BackupExpiryDateTime": "d",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type BackupStatus =
| "CREATING"
| "DELETED"
| "AVAILABLE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type BackupType =
| "USER"
| "SYSTEM"
| "AWS_BACKUP"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface GlobalTableDescription {
  ReplicationGroup?: ReplicaDescription[] | null;
  GlobalTableArn?: string | null;
  CreationDateTime?: Date | number | null;
  GlobalTableStatus?: GlobalTableStatus | null;
  GlobalTableName?: string | null;
}
function toGlobalTableDescription(root: jsonP.JSONValue): GlobalTableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationGroup": [toReplicaDescription],
      "GlobalTableArn": "s",
      "CreationDateTime": "d",
      "GlobalTableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<GlobalTableStatus>(x),
      "GlobalTableName": "s",
    },
  }, root);
}

// refs: 9 - tags: output, named, interface
export interface ReplicaDescription {
  RegionName?: string | null;
  ReplicaStatus?: ReplicaStatus | null;
  ReplicaStatusDescription?: string | null;
  ReplicaStatusPercentProgress?: string | null;
  KMSMasterKeyId?: string | null;
  ProvisionedThroughputOverride?: ProvisionedThroughputOverride | null;
  GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndexDescription[] | null;
  ReplicaInaccessibleDateTime?: Date | number | null;
}
function toReplicaDescription(root: jsonP.JSONValue): ReplicaDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ReplicaStatus>(x),
      "ReplicaStatusDescription": "s",
      "ReplicaStatusPercentProgress": "s",
      "KMSMasterKeyId": "s",
      "ProvisionedThroughputOverride": toProvisionedThroughputOverride,
      "GlobalSecondaryIndexes": [toReplicaGlobalSecondaryIndexDescription],
      "ReplicaInaccessibleDateTime": "d",
    },
  }, root);
}

// refs: 13 - tags: output, named, enum
export type ReplicaStatus =
| "CREATING"
| "CREATION_FAILED"
| "UPDATING"
| "DELETING"
| "ACTIVE"
| "REGION_DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: output, named, interface
export interface ReplicaGlobalSecondaryIndexDescription {
  IndexName?: string | null;
  ProvisionedThroughputOverride?: ProvisionedThroughputOverride | null;
}
function toReplicaGlobalSecondaryIndexDescription(root: jsonP.JSONValue): ReplicaGlobalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "ProvisionedThroughputOverride": toProvisionedThroughputOverride,
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type GlobalTableStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface TableDescription {
  AttributeDefinitions?: AttributeDefinition[] | null;
  TableName?: string | null;
  KeySchema?: KeySchemaElement[] | null;
  TableStatus?: TableStatus | null;
  CreationDateTime?: Date | number | null;
  ProvisionedThroughput?: ProvisionedThroughputDescription | null;
  TableSizeBytes?: number | null;
  ItemCount?: number | null;
  TableArn?: string | null;
  TableId?: string | null;
  BillingModeSummary?: BillingModeSummary | null;
  LocalSecondaryIndexes?: LocalSecondaryIndexDescription[] | null;
  GlobalSecondaryIndexes?: GlobalSecondaryIndexDescription[] | null;
  StreamSpecification?: StreamSpecification | null;
  LatestStreamLabel?: string | null;
  LatestStreamArn?: string | null;
  GlobalTableVersion?: string | null;
  Replicas?: ReplicaDescription[] | null;
  RestoreSummary?: RestoreSummary | null;
  SSEDescription?: SSEDescription | null;
  ArchivalSummary?: ArchivalSummary | null;
}
function toTableDescription(root: jsonP.JSONValue): TableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeDefinitions": [toAttributeDefinition],
      "TableName": "s",
      "KeySchema": [toKeySchemaElement],
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TableStatus>(x),
      "CreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "TableSizeBytes": "n",
      "ItemCount": "n",
      "TableArn": "s",
      "TableId": "s",
      "BillingModeSummary": toBillingModeSummary,
      "LocalSecondaryIndexes": [toLocalSecondaryIndexDescription],
      "GlobalSecondaryIndexes": [toGlobalSecondaryIndexDescription],
      "StreamSpecification": toStreamSpecification,
      "LatestStreamLabel": "s",
      "LatestStreamArn": "s",
      "GlobalTableVersion": "s",
      "Replicas": [toReplicaDescription],
      "RestoreSummary": toRestoreSummary,
      "SSEDescription": toSSEDescription,
      "ArchivalSummary": toArchivalSummary,
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type TableStatus =
| "CREATING"
| "UPDATING"
| "DELETING"
| "ACTIVE"
| "INACCESSIBLE_ENCRYPTION_CREDENTIALS"
| "ARCHIVING"
| "ARCHIVED"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: output, named, interface
export interface ProvisionedThroughputDescription {
  LastIncreaseDateTime?: Date | number | null;
  LastDecreaseDateTime?: Date | number | null;
  NumberOfDecreasesToday?: number | null;
  ReadCapacityUnits?: number | null;
  WriteCapacityUnits?: number | null;
}
function toProvisionedThroughputDescription(root: jsonP.JSONValue): ProvisionedThroughputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastIncreaseDateTime": "d",
      "LastDecreaseDateTime": "d",
      "NumberOfDecreasesToday": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface BillingModeSummary {
  BillingMode?: BillingMode | null;
  LastUpdateToPayPerRequestDateTime?: Date | number | null;
}
function toBillingModeSummary(root: jsonP.JSONValue): BillingModeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "BillingMode": (x: jsonP.JSONValue) => cmnP.readEnum<BillingMode>(x),
      "LastUpdateToPayPerRequestDateTime": "d",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface LocalSecondaryIndexDescription {
  IndexName?: string | null;
  KeySchema?: KeySchemaElement[] | null;
  Projection?: Projection | null;
  IndexSizeBytes?: number | null;
  ItemCount?: number | null;
  IndexArn?: string | null;
}
function toLocalSecondaryIndexDescription(root: jsonP.JSONValue): LocalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "IndexSizeBytes": "n",
      "ItemCount": "n",
      "IndexArn": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface GlobalSecondaryIndexDescription {
  IndexName?: string | null;
  KeySchema?: KeySchemaElement[] | null;
  Projection?: Projection | null;
  IndexStatus?: IndexStatus | null;
  Backfilling?: boolean | null;
  ProvisionedThroughput?: ProvisionedThroughputDescription | null;
  IndexSizeBytes?: number | null;
  ItemCount?: number | null;
  IndexArn?: string | null;
}
function toGlobalSecondaryIndexDescription(root: jsonP.JSONValue): GlobalSecondaryIndexDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<IndexStatus>(x),
      "Backfilling": "b",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "IndexSizeBytes": "n",
      "ItemCount": "n",
      "IndexArn": "s",
    },
  }, root);
}

// refs: 10 - tags: output, named, enum
export type IndexStatus =
| "CREATING"
| "UPDATING"
| "DELETING"
| "ACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface RestoreSummary {
  SourceBackupArn?: string | null;
  SourceTableArn?: string | null;
  RestoreDateTime: Date | number;
  RestoreInProgress: boolean;
}
function toRestoreSummary(root: jsonP.JSONValue): RestoreSummary {
  return jsonP.readObj({
    required: {
      "RestoreDateTime": "d",
      "RestoreInProgress": "b",
    },
    optional: {
      "SourceBackupArn": "s",
      "SourceTableArn": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface SSEDescription {
  Status?: SSEStatus | null;
  SSEType?: SSEType | null;
  KMSMasterKeyArn?: string | null;
  InaccessibleEncryptionDateTime?: Date | number | null;
}
function toSSEDescription(root: jsonP.JSONValue): SSEDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SSEStatus>(x),
      "SSEType": (x: jsonP.JSONValue) => cmnP.readEnum<SSEType>(x),
      "KMSMasterKeyArn": "s",
      "InaccessibleEncryptionDateTime": "d",
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type SSEStatus =
| "ENABLING"
| "ENABLED"
| "DISABLING"
| "DISABLED"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface ArchivalSummary {
  ArchivalDateTime?: Date | number | null;
  ArchivalReason?: string | null;
  ArchivalBackupArn?: string | null;
}
function toArchivalSummary(root: jsonP.JSONValue): ArchivalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchivalDateTime": "d",
      "ArchivalReason": "s",
      "ArchivalBackupArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface BackupDescription {
  BackupDetails?: BackupDetails | null;
  SourceTableDetails?: SourceTableDetails | null;
  SourceTableFeatureDetails?: SourceTableFeatureDetails | null;
}
function toBackupDescription(root: jsonP.JSONValue): BackupDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "BackupDetails": toBackupDetails,
      "SourceTableDetails": toSourceTableDetails,
      "SourceTableFeatureDetails": toSourceTableFeatureDetails,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SourceTableDetails {
  TableName: string;
  TableId: string;
  TableArn?: string | null;
  TableSizeBytes?: number | null;
  KeySchema: KeySchemaElement[];
  TableCreationDateTime: Date | number;
  ProvisionedThroughput: ProvisionedThroughput;
  ItemCount?: number | null;
  BillingMode?: BillingMode | null;
}
function toSourceTableDetails(root: jsonP.JSONValue): SourceTableDetails {
  return jsonP.readObj({
    required: {
      "TableName": "s",
      "TableId": "s",
      "KeySchema": [toKeySchemaElement],
      "TableCreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughput,
    },
    optional: {
      "TableArn": "s",
      "TableSizeBytes": "n",
      "ItemCount": "n",
      "BillingMode": (x: jsonP.JSONValue) => cmnP.readEnum<BillingMode>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SourceTableFeatureDetails {
  LocalSecondaryIndexes?: LocalSecondaryIndexInfo[] | null;
  GlobalSecondaryIndexes?: GlobalSecondaryIndexInfo[] | null;
  StreamDescription?: StreamSpecification | null;
  TimeToLiveDescription?: TimeToLiveDescription | null;
  SSEDescription?: SSEDescription | null;
}
function toSourceTableFeatureDetails(root: jsonP.JSONValue): SourceTableFeatureDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "LocalSecondaryIndexes": [toLocalSecondaryIndexInfo],
      "GlobalSecondaryIndexes": [toGlobalSecondaryIndexInfo],
      "StreamDescription": toStreamSpecification,
      "TimeToLiveDescription": toTimeToLiveDescription,
      "SSEDescription": toSSEDescription,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LocalSecondaryIndexInfo {
  IndexName?: string | null;
  KeySchema?: KeySchemaElement[] | null;
  Projection?: Projection | null;
}
function toLocalSecondaryIndexInfo(root: jsonP.JSONValue): LocalSecondaryIndexInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface GlobalSecondaryIndexInfo {
  IndexName?: string | null;
  KeySchema?: KeySchemaElement[] | null;
  Projection?: Projection | null;
  ProvisionedThroughput?: ProvisionedThroughput | null;
}
function toGlobalSecondaryIndexInfo(root: jsonP.JSONValue): GlobalSecondaryIndexInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "KeySchema": [toKeySchemaElement],
      "Projection": toProjection,
      "ProvisionedThroughput": toProvisionedThroughput,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface TimeToLiveDescription {
  TimeToLiveStatus?: TimeToLiveStatus | null;
  AttributeName?: string | null;
}
function toTimeToLiveDescription(root: jsonP.JSONValue): TimeToLiveDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimeToLiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TimeToLiveStatus>(x),
      "AttributeName": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type TimeToLiveStatus =
| "ENABLING"
| "DISABLING"
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ContinuousBackupsDescription {
  ContinuousBackupsStatus: ContinuousBackupsStatus;
  PointInTimeRecoveryDescription?: PointInTimeRecoveryDescription | null;
}
function toContinuousBackupsDescription(root: jsonP.JSONValue): ContinuousBackupsDescription {
  return jsonP.readObj({
    required: {
      "ContinuousBackupsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ContinuousBackupsStatus>(x),
    },
    optional: {
      "PointInTimeRecoveryDescription": toPointInTimeRecoveryDescription,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ContinuousBackupsStatus =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface PointInTimeRecoveryDescription {
  PointInTimeRecoveryStatus?: PointInTimeRecoveryStatus | null;
  EarliestRestorableDateTime?: Date | number | null;
  LatestRestorableDateTime?: Date | number | null;
}
function toPointInTimeRecoveryDescription(root: jsonP.JSONValue): PointInTimeRecoveryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "PointInTimeRecoveryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PointInTimeRecoveryStatus>(x),
      "EarliestRestorableDateTime": "d",
      "LatestRestorableDateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type PointInTimeRecoveryStatus =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type ContributorInsightsStatus =
| "ENABLING"
| "ENABLED"
| "DISABLING"
| "DISABLED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface FailureException {
  ExceptionName?: string | null;
  ExceptionDescription?: string | null;
}
function toFailureException(root: jsonP.JSONValue): FailureException {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExceptionName": "s",
      "ExceptionDescription": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Endpoint {
  Address: string;
  CachePeriodInMinutes: number;
}
function toEndpoint(root: jsonP.JSONValue): Endpoint {
  return jsonP.readObj({
    required: {
      "Address": "s",
      "CachePeriodInMinutes": "n",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReplicaSettingsDescription {
  RegionName: string;
  ReplicaStatus?: ReplicaStatus | null;
  ReplicaBillingModeSummary?: BillingModeSummary | null;
  ReplicaProvisionedReadCapacityUnits?: number | null;
  ReplicaProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ReplicaProvisionedWriteCapacityUnits?: number | null;
  ReplicaProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ReplicaGlobalSecondaryIndexSettings?: ReplicaGlobalSecondaryIndexSettingsDescription[] | null;
}
function toReplicaSettingsDescription(root: jsonP.JSONValue): ReplicaSettingsDescription {
  return jsonP.readObj({
    required: {
      "RegionName": "s",
    },
    optional: {
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ReplicaStatus>(x),
      "ReplicaBillingModeSummary": toBillingModeSummary,
      "ReplicaProvisionedReadCapacityUnits": "n",
      "ReplicaProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaProvisionedWriteCapacityUnits": "n",
      "ReplicaProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaGlobalSecondaryIndexSettings": [toReplicaGlobalSecondaryIndexSettingsDescription],
    },
  }, root);
}

// refs: 16 - tags: output, named, interface
export interface AutoScalingSettingsDescription {
  MinimumUnits?: number | null;
  MaximumUnits?: number | null;
  AutoScalingDisabled?: boolean | null;
  AutoScalingRoleArn?: string | null;
  ScalingPolicies?: AutoScalingPolicyDescription[] | null;
}
function toAutoScalingSettingsDescription(root: jsonP.JSONValue): AutoScalingSettingsDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinimumUnits": "n",
      "MaximumUnits": "n",
      "AutoScalingDisabled": "b",
      "AutoScalingRoleArn": "s",
      "ScalingPolicies": [toAutoScalingPolicyDescription],
    },
  }, root);
}

// refs: 16 - tags: output, named, interface
export interface AutoScalingPolicyDescription {
  PolicyName?: string | null;
  TargetTrackingScalingPolicyConfiguration?: AutoScalingTargetTrackingScalingPolicyConfigurationDescription | null;
}
function toAutoScalingPolicyDescription(root: jsonP.JSONValue): AutoScalingPolicyDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
      "TargetTrackingScalingPolicyConfiguration": toAutoScalingTargetTrackingScalingPolicyConfigurationDescription,
    },
  }, root);
}

// refs: 16 - tags: output, named, interface
export interface AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
  DisableScaleIn?: boolean | null;
  ScaleInCooldown?: number | null;
  ScaleOutCooldown?: number | null;
  TargetValue: number;
}
function toAutoScalingTargetTrackingScalingPolicyConfigurationDescription(root: jsonP.JSONValue): AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
  return jsonP.readObj({
    required: {
      "TargetValue": "n",
    },
    optional: {
      "DisableScaleIn": "b",
      "ScaleInCooldown": "n",
      "ScaleOutCooldown": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReplicaGlobalSecondaryIndexSettingsDescription {
  IndexName: string;
  IndexStatus?: IndexStatus | null;
  ProvisionedReadCapacityUnits?: number | null;
  ProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ProvisionedWriteCapacityUnits?: number | null;
  ProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
}
function toReplicaGlobalSecondaryIndexSettingsDescription(root: jsonP.JSONValue): ReplicaGlobalSecondaryIndexSettingsDescription {
  return jsonP.readObj({
    required: {
      "IndexName": "s",
    },
    optional: {
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<IndexStatus>(x),
      "ProvisionedReadCapacityUnits": "n",
      "ProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ProvisionedWriteCapacityUnits": "n",
      "ProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TableAutoScalingDescription {
  TableName?: string | null;
  TableStatus?: TableStatus | null;
  Replicas?: ReplicaAutoScalingDescription[] | null;
}
function toTableAutoScalingDescription(root: jsonP.JSONValue): TableAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TableStatus>(x),
      "Replicas": [toReplicaAutoScalingDescription],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReplicaAutoScalingDescription {
  RegionName?: string | null;
  GlobalSecondaryIndexes?: ReplicaGlobalSecondaryIndexAutoScalingDescription[] | null;
  ReplicaProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ReplicaProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ReplicaStatus?: ReplicaStatus | null;
}
function toReplicaAutoScalingDescription(root: jsonP.JSONValue): ReplicaAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegionName": "s",
      "GlobalSecondaryIndexes": [toReplicaGlobalSecondaryIndexAutoScalingDescription],
      "ReplicaProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ReplicaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ReplicaStatus>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ReplicaGlobalSecondaryIndexAutoScalingDescription {
  IndexName?: string | null;
  IndexStatus?: IndexStatus | null;
  ProvisionedReadCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
  ProvisionedWriteCapacityAutoScalingSettings?: AutoScalingSettingsDescription | null;
}
function toReplicaGlobalSecondaryIndexAutoScalingDescription(root: jsonP.JSONValue): ReplicaGlobalSecondaryIndexAutoScalingDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<IndexStatus>(x),
      "ProvisionedReadCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
      "ProvisionedWriteCapacityAutoScalingSettings": toAutoScalingSettingsDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BackupSummary {
  TableName?: string | null;
  TableId?: string | null;
  TableArn?: string | null;
  BackupArn?: string | null;
  BackupName?: string | null;
  BackupCreationDateTime?: Date | number | null;
  BackupExpiryDateTime?: Date | number | null;
  BackupStatus?: BackupStatus | null;
  BackupType?: BackupType | null;
  BackupSizeBytes?: number | null;
}
function toBackupSummary(root: jsonP.JSONValue): BackupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "TableId": "s",
      "TableArn": "s",
      "BackupArn": "s",
      "BackupName": "s",
      "BackupCreationDateTime": "d",
      "BackupExpiryDateTime": "d",
      "BackupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<BackupStatus>(x),
      "BackupType": (x: jsonP.JSONValue) => cmnP.readEnum<BackupType>(x),
      "BackupSizeBytes": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ContributorInsightsSummary {
  TableName?: string | null;
  IndexName?: string | null;
  ContributorInsightsStatus?: ContributorInsightsStatus | null;
}
function toContributorInsightsSummary(root: jsonP.JSONValue): ContributorInsightsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "IndexName": "s",
      "ContributorInsightsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ContributorInsightsStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface GlobalTable {
  GlobalTableName?: string | null;
  ReplicationGroup?: Replica[] | null;
}
function toGlobalTable(root: jsonP.JSONValue): GlobalTable {
  return jsonP.readObj({
    required: {},
    optional: {
      "GlobalTableName": "s",
      "ReplicationGroup": [toReplica],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ItemResponse {
  Item?: { [key: string]: AttributeValue | null | undefined } | null;
}
function toItemResponse(root: jsonP.JSONValue): ItemResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
  }, root);
}
