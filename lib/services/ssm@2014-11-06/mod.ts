// Autogenerated API client for: Amazon Simple Systems Manager (SSM)

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class SSM {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SSM.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-11-06",
    "endpointPrefix": "ssm",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon SSM",
    "serviceFullName": "Amazon Simple Systems Manager (SSM)",
    "serviceId": "SSM",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonSSM",
    "uid": "ssm-2014-11-06"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceRequest,
  ): Promise<s.AddTagsToResourceResult> {
    const body: jsonP.JSONObject = {
      ResourceType: params["ResourceType"],
      ResourceId: params["ResourceId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelCommand(
    {abortSignal, ...params}: RequestConfig & s.CancelCommandRequest,
  ): Promise<s.CancelCommandResult> {
    const body: jsonP.JSONObject = {
      CommandId: params["CommandId"],
      InstanceIds: params["InstanceIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelCommand",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelMaintenanceWindowExecution(
    {abortSignal, ...params}: RequestConfig & s.CancelMaintenanceWindowExecutionRequest,
  ): Promise<s.CancelMaintenanceWindowExecutionResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelMaintenanceWindowExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionId": "s",
      },
    }, await resp.json());
  }

  async createActivation(
    {abortSignal, ...params}: RequestConfig & s.CreateActivationRequest,
  ): Promise<s.CreateActivationResult> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      DefaultInstanceName: params["DefaultInstanceName"],
      IamRole: params["IamRole"],
      RegistrationLimit: params["RegistrationLimit"],
      ExpirationDate: jsonP.serializeDate_unixTimestamp(params["ExpirationDate"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateActivation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActivationId": "s",
        "ActivationCode": "s",
      },
    }, await resp.json());
  }

  async createAssociation(
    {abortSignal, ...params}: RequestConfig & s.CreateAssociationRequest,
  ): Promise<s.CreateAssociationResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
      InstanceId: params["InstanceId"],
      Parameters: params["Parameters"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      ScheduleExpression: params["ScheduleExpression"],
      OutputLocation: fromInstanceAssociationOutputLocation(params["OutputLocation"]),
      AssociationName: params["AssociationName"],
      AutomationTargetParameterName: params["AutomationTargetParameterName"],
      MaxErrors: params["MaxErrors"],
      MaxConcurrency: params["MaxConcurrency"],
      ComplianceSeverity: params["ComplianceSeverity"],
      SyncCompliance: params["SyncCompliance"],
      ApplyOnlyAtCronInterval: params["ApplyOnlyAtCronInterval"],
      TargetLocations: params["TargetLocations"]?.map(x => fromTargetLocation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationDescription": toAssociationDescription,
      },
    }, await resp.json());
  }

  async createAssociationBatch(
    {abortSignal, ...params}: RequestConfig & s.CreateAssociationBatchRequest,
  ): Promise<s.CreateAssociationBatchResult> {
    const body: jsonP.JSONObject = {
      Entries: params["Entries"]?.map(x => fromCreateAssociationBatchRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAssociationBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Successful": [toAssociationDescription],
        "Failed": [toFailedCreateAssociation],
      },
    }, await resp.json());
  }

  async createDocument(
    {abortSignal, ...params}: RequestConfig & s.CreateDocumentRequest,
  ): Promise<s.CreateDocumentResult> {
    const body: jsonP.JSONObject = {
      Content: params["Content"],
      Requires: params["Requires"]?.map(x => fromDocumentRequires(x)),
      Attachments: params["Attachments"]?.map(x => fromAttachmentsSource(x)),
      Name: params["Name"],
      VersionName: params["VersionName"],
      DocumentType: params["DocumentType"],
      DocumentFormat: params["DocumentFormat"],
      TargetType: params["TargetType"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentDescription": toDocumentDescription,
      },
    }, await resp.json());
  }

  async createMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.CreateMaintenanceWindowRequest,
  ): Promise<s.CreateMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      StartDate: params["StartDate"],
      EndDate: params["EndDate"],
      Schedule: params["Schedule"],
      ScheduleTimezone: params["ScheduleTimezone"],
      ScheduleOffset: params["ScheduleOffset"],
      Duration: params["Duration"],
      Cutoff: params["Cutoff"],
      AllowUnassociatedTargets: params["AllowUnassociatedTargets"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
      },
    }, await resp.json());
  }

  async createOpsItem(
    {abortSignal, ...params}: RequestConfig & s.CreateOpsItemRequest,
  ): Promise<s.CreateOpsItemResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      OpsItemType: params["OpsItemType"],
      OperationalData: jsonP.serializeMap(params["OperationalData"], x => fromOpsItemDataValue(x)),
      Notifications: params["Notifications"]?.map(x => fromOpsItemNotification(x)),
      Priority: params["Priority"],
      RelatedOpsItems: params["RelatedOpsItems"]?.map(x => fromRelatedOpsItem(x)),
      Source: params["Source"],
      Title: params["Title"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      Category: params["Category"],
      Severity: params["Severity"],
      ActualStartTime: jsonP.serializeDate_unixTimestamp(params["ActualStartTime"]),
      ActualEndTime: jsonP.serializeDate_unixTimestamp(params["ActualEndTime"]),
      PlannedStartTime: jsonP.serializeDate_unixTimestamp(params["PlannedStartTime"]),
      PlannedEndTime: jsonP.serializeDate_unixTimestamp(params["PlannedEndTime"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOpsItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OpsItemId": "s",
      },
    }, await resp.json());
  }

  async createOpsMetadata(
    {abortSignal, ...params}: RequestConfig & s.CreateOpsMetadataRequest,
  ): Promise<s.CreateOpsMetadataResult> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      Metadata: jsonP.serializeMap(params["Metadata"], x => fromMetadataValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOpsMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OpsMetadataArn": "s",
      },
    }, await resp.json());
  }

  async createPatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.CreatePatchBaselineRequest,
  ): Promise<s.CreatePatchBaselineResult> {
    const body: jsonP.JSONObject = {
      OperatingSystem: params["OperatingSystem"],
      Name: params["Name"],
      GlobalFilters: fromPatchFilterGroup(params["GlobalFilters"]),
      ApprovalRules: fromPatchRuleGroup(params["ApprovalRules"]),
      ApprovedPatches: params["ApprovedPatches"],
      ApprovedPatchesComplianceLevel: params["ApprovedPatchesComplianceLevel"],
      ApprovedPatchesEnableNonSecurity: params["ApprovedPatchesEnableNonSecurity"],
      RejectedPatches: params["RejectedPatches"],
      RejectedPatchesAction: params["RejectedPatchesAction"],
      Description: params["Description"],
      Sources: params["Sources"]?.map(x => fromPatchSource(x)),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
      },
    }, await resp.json());
  }

  async createResourceDataSync(
    {abortSignal, ...params}: RequestConfig & s.CreateResourceDataSyncRequest,
  ): Promise<s.CreateResourceDataSyncResult> {
    const body: jsonP.JSONObject = {
      SyncName: params["SyncName"],
      S3Destination: fromResourceDataSyncS3Destination(params["S3Destination"]),
      SyncType: params["SyncType"],
      SyncSource: fromResourceDataSyncSource(params["SyncSource"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateResourceDataSync",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteActivation(
    {abortSignal, ...params}: RequestConfig & s.DeleteActivationRequest,
  ): Promise<s.DeleteActivationResult> {
    const body: jsonP.JSONObject = {
      ActivationId: params["ActivationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteActivation",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteAssociation(
    {abortSignal, ...params}: RequestConfig & s.DeleteAssociationRequest = {},
  ): Promise<s.DeleteAssociationResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      InstanceId: params["InstanceId"],
      AssociationId: params["AssociationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDocument(
    {abortSignal, ...params}: RequestConfig & s.DeleteDocumentRequest,
  ): Promise<s.DeleteDocumentResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
      VersionName: params["VersionName"],
      Force: params["Force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteInventory(
    {abortSignal, ...params}: RequestConfig & s.DeleteInventoryRequest,
  ): Promise<s.DeleteInventoryResult> {
    const body: jsonP.JSONObject = {
      TypeName: params["TypeName"],
      SchemaDeleteOption: params["SchemaDeleteOption"],
      DryRun: params["DryRun"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInventory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeletionId": "s",
        "TypeName": "s",
        "DeletionSummary": toInventoryDeletionSummary,
      },
    }, await resp.json());
  }

  async deleteMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.DeleteMaintenanceWindowRequest,
  ): Promise<s.DeleteMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
      },
    }, await resp.json());
  }

  async deleteOpsMetadata(
    {abortSignal, ...params}: RequestConfig & s.DeleteOpsMetadataRequest,
  ): Promise<s.DeleteOpsMetadataResult> {
    const body: jsonP.JSONObject = {
      OpsMetadataArn: params["OpsMetadataArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOpsMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteParameter(
    {abortSignal, ...params}: RequestConfig & s.DeleteParameterRequest,
  ): Promise<s.DeleteParameterResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteParameter",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteParameters(
    {abortSignal, ...params}: RequestConfig & s.DeleteParametersRequest,
  ): Promise<s.DeleteParametersResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeletedParameters": ["s"],
        "InvalidParameters": ["s"],
      },
    }, await resp.json());
  }

  async deletePatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.DeletePatchBaselineRequest,
  ): Promise<s.DeletePatchBaselineResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
      },
    }, await resp.json());
  }

  async deleteResourceDataSync(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourceDataSyncRequest,
  ): Promise<s.DeleteResourceDataSyncResult> {
    const body: jsonP.JSONObject = {
      SyncName: params["SyncName"],
      SyncType: params["SyncType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourceDataSync",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterManagedInstance(
    {abortSignal, ...params}: RequestConfig & s.DeregisterManagedInstanceRequest,
  ): Promise<s.DeregisterManagedInstanceResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterManagedInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterPatchBaselineForPatchGroup(
    {abortSignal, ...params}: RequestConfig & s.DeregisterPatchBaselineForPatchGroupRequest,
  ): Promise<s.DeregisterPatchBaselineForPatchGroupResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
      PatchGroup: params["PatchGroup"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterPatchBaselineForPatchGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "PatchGroup": "s",
      },
    }, await resp.json());
  }

  async deregisterTargetFromMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTargetFromMaintenanceWindowRequest,
  ): Promise<s.DeregisterTargetFromMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      WindowTargetId: params["WindowTargetId"],
      Safe: params["Safe"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTargetFromMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "WindowTargetId": "s",
      },
    }, await resp.json());
  }

  async deregisterTaskFromMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTaskFromMaintenanceWindowRequest,
  ): Promise<s.DeregisterTaskFromMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      WindowTaskId: params["WindowTaskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTaskFromMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "WindowTaskId": "s",
      },
    }, await resp.json());
  }

  async describeActivations(
    {abortSignal, ...params}: RequestConfig & s.DescribeActivationsRequest = {},
  ): Promise<s.DescribeActivationsResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromDescribeActivationsFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeActivations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActivationList": [toActivation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeAssociation(
    {abortSignal, ...params}: RequestConfig & s.DescribeAssociationRequest = {},
  ): Promise<s.DescribeAssociationResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      InstanceId: params["InstanceId"],
      AssociationId: params["AssociationId"],
      AssociationVersion: params["AssociationVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationDescription": toAssociationDescription,
      },
    }, await resp.json());
  }

  async describeAssociationExecutionTargets(
    {abortSignal, ...params}: RequestConfig & s.DescribeAssociationExecutionTargetsRequest,
  ): Promise<s.DescribeAssociationExecutionTargetsResult> {
    const body: jsonP.JSONObject = {
      AssociationId: params["AssociationId"],
      ExecutionId: params["ExecutionId"],
      Filters: params["Filters"]?.map(x => fromAssociationExecutionTargetsFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAssociationExecutionTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationExecutionTargets": [toAssociationExecutionTarget],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeAssociationExecutions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAssociationExecutionsRequest,
  ): Promise<s.DescribeAssociationExecutionsResult> {
    const body: jsonP.JSONObject = {
      AssociationId: params["AssociationId"],
      Filters: params["Filters"]?.map(x => fromAssociationExecutionFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAssociationExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationExecutions": [toAssociationExecution],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeAutomationExecutions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAutomationExecutionsRequest = {},
  ): Promise<s.DescribeAutomationExecutionsResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromAutomationExecutionFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutomationExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomationExecutionMetadataList": [toAutomationExecutionMetadata],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeAutomationStepExecutions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAutomationStepExecutionsRequest,
  ): Promise<s.DescribeAutomationStepExecutionsResult> {
    const body: jsonP.JSONObject = {
      AutomationExecutionId: params["AutomationExecutionId"],
      Filters: params["Filters"]?.map(x => fromStepExecutionFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ReverseOrder: params["ReverseOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutomationStepExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StepExecutions": [toStepExecution],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeAvailablePatches(
    {abortSignal, ...params}: RequestConfig & s.DescribeAvailablePatchesRequest = {},
  ): Promise<s.DescribeAvailablePatchesResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromPatchOrchestratorFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailablePatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Patches": [toPatch],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeDocument(
    {abortSignal, ...params}: RequestConfig & s.DescribeDocumentRequest,
  ): Promise<s.DescribeDocumentResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
      VersionName: params["VersionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Document": toDocumentDescription,
      },
    }, await resp.json());
  }

  async describeDocumentPermission(
    {abortSignal, ...params}: RequestConfig & s.DescribeDocumentPermissionRequest,
  ): Promise<s.DescribeDocumentPermissionResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      PermissionType: params["PermissionType"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDocumentPermission",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountIds": ["s"],
        "AccountSharingInfoList": [toAccountSharingInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEffectiveInstanceAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeEffectiveInstanceAssociationsRequest,
  ): Promise<s.DescribeEffectiveInstanceAssociationsResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEffectiveInstanceAssociations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Associations": [toInstanceAssociation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEffectivePatchesForPatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.DescribeEffectivePatchesForPatchBaselineRequest,
  ): Promise<s.DescribeEffectivePatchesForPatchBaselineResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEffectivePatchesForPatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EffectivePatches": [toEffectivePatch],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstanceAssociationsStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceAssociationsStatusRequest,
  ): Promise<s.DescribeInstanceAssociationsStatusResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceAssociationsStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceAssociationStatusInfos": [toInstanceAssociationStatusInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstanceInformation(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstanceInformationRequest = {},
  ): Promise<s.DescribeInstanceInformationResult> {
    const body: jsonP.JSONObject = {
      InstanceInformationFilterList: params["InstanceInformationFilterList"]?.map(x => fromInstanceInformationFilter(x)),
      Filters: params["Filters"]?.map(x => fromInstanceInformationStringFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceInformation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceInformationList": [toInstanceInformation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstancePatchStates(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancePatchStatesRequest,
  ): Promise<s.DescribeInstancePatchStatesResult> {
    const body: jsonP.JSONObject = {
      InstanceIds: params["InstanceIds"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstancePatchStates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstancePatchStates": [toInstancePatchState],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstancePatchStatesForPatchGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancePatchStatesForPatchGroupRequest,
  ): Promise<s.DescribeInstancePatchStatesForPatchGroupResult> {
    const body: jsonP.JSONObject = {
      PatchGroup: params["PatchGroup"],
      Filters: params["Filters"]?.map(x => fromInstancePatchStateFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstancePatchStatesForPatchGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstancePatchStates": [toInstancePatchState],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInstancePatches(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancePatchesRequest,
  ): Promise<s.DescribeInstancePatchesResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      Filters: params["Filters"]?.map(x => fromPatchOrchestratorFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstancePatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Patches": [toPatchComplianceData],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeInventoryDeletions(
    {abortSignal, ...params}: RequestConfig & s.DescribeInventoryDeletionsRequest = {},
  ): Promise<s.DescribeInventoryDeletionsResult> {
    const body: jsonP.JSONObject = {
      DeletionId: params["DeletionId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInventoryDeletions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InventoryDeletions": [toInventoryDeletionStatusItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowExecutionTaskInvocations(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowExecutionTaskInvocationsRequest,
  ): Promise<s.DescribeMaintenanceWindowExecutionTaskInvocationsResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
      TaskId: params["TaskId"],
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowExecutionTaskInvocations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionTaskInvocationIdentities": [toMaintenanceWindowExecutionTaskInvocationIdentity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowExecutionTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowExecutionTasksRequest,
  ): Promise<s.DescribeMaintenanceWindowExecutionTasksResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowExecutionTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionTaskIdentities": [toMaintenanceWindowExecutionTaskIdentity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowExecutions(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowExecutionsRequest,
  ): Promise<s.DescribeMaintenanceWindowExecutionsResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutions": [toMaintenanceWindowExecution],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowScheduleRequest = {},
  ): Promise<s.DescribeMaintenanceWindowScheduleResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      ResourceType: params["ResourceType"],
      Filters: params["Filters"]?.map(x => fromPatchOrchestratorFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ScheduledWindowExecutions": [toScheduledWindowExecution],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowTargets(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowTargetsRequest,
  ): Promise<s.DescribeMaintenanceWindowTargetsResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowTargets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Targets": [toMaintenanceWindowTarget],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowTasksRequest,
  ): Promise<s.DescribeMaintenanceWindowTasksResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tasks": [toMaintenanceWindowTask],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindows(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowsRequest = {},
  ): Promise<s.DescribeMaintenanceWindowsResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromMaintenanceWindowFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowIdentities": [toMaintenanceWindowIdentity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeMaintenanceWindowsForTarget(
    {abortSignal, ...params}: RequestConfig & s.DescribeMaintenanceWindowsForTargetRequest,
  ): Promise<s.DescribeMaintenanceWindowsForTargetResult> {
    const body: jsonP.JSONObject = {
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      ResourceType: params["ResourceType"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMaintenanceWindowsForTarget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowIdentities": [toMaintenanceWindowIdentityForTarget],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeOpsItems(
    {abortSignal, ...params}: RequestConfig & s.DescribeOpsItemsRequest = {},
  ): Promise<s.DescribeOpsItemsResponse> {
    const body: jsonP.JSONObject = {
      OpsItemFilters: params["OpsItemFilters"]?.map(x => fromOpsItemFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOpsItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "OpsItemSummaries": [toOpsItemSummary],
      },
    }, await resp.json());
  }

  async describeParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeParametersRequest = {},
  ): Promise<s.DescribeParametersResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromParametersFilter(x)),
      ParameterFilters: params["ParameterFilters"]?.map(x => fromParameterStringFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parameters": [toParameterMetadata],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePatchBaselines(
    {abortSignal, ...params}: RequestConfig & s.DescribePatchBaselinesRequest = {},
  ): Promise<s.DescribePatchBaselinesResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromPatchOrchestratorFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePatchBaselines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineIdentities": [toPatchBaselineIdentity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePatchGroupState(
    {abortSignal, ...params}: RequestConfig & s.DescribePatchGroupStateRequest,
  ): Promise<s.DescribePatchGroupStateResult> {
    const body: jsonP.JSONObject = {
      PatchGroup: params["PatchGroup"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePatchGroupState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": "n",
        "InstancesWithInstalledPatches": "n",
        "InstancesWithInstalledOtherPatches": "n",
        "InstancesWithInstalledPendingRebootPatches": "n",
        "InstancesWithInstalledRejectedPatches": "n",
        "InstancesWithMissingPatches": "n",
        "InstancesWithFailedPatches": "n",
        "InstancesWithNotApplicablePatches": "n",
        "InstancesWithUnreportedNotApplicablePatches": "n",
      },
    }, await resp.json());
  }

  async describePatchGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribePatchGroupsRequest = {},
  ): Promise<s.DescribePatchGroupsResult> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      Filters: params["Filters"]?.map(x => fromPatchOrchestratorFilter(x)),
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePatchGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Mappings": [toPatchGroupPatchBaselineMapping],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePatchProperties(
    {abortSignal, ...params}: RequestConfig & s.DescribePatchPropertiesRequest,
  ): Promise<s.DescribePatchPropertiesResult> {
    const body: jsonP.JSONObject = {
      OperatingSystem: params["OperatingSystem"],
      Property: params["Property"],
      PatchSet: params["PatchSet"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePatchProperties",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Properties": [x => jsonP.readMap(String, String, x)],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeSessions(
    {abortSignal, ...params}: RequestConfig & s.DescribeSessionsRequest,
  ): Promise<s.DescribeSessionsResponse> {
    const body: jsonP.JSONObject = {
      State: params["State"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromSessionFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Sessions": [toSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getAutomationExecution(
    {abortSignal, ...params}: RequestConfig & s.GetAutomationExecutionRequest,
  ): Promise<s.GetAutomationExecutionResult> {
    const body: jsonP.JSONObject = {
      AutomationExecutionId: params["AutomationExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAutomationExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomationExecution": toAutomationExecution,
      },
    }, await resp.json());
  }

  async getCalendarState(
    {abortSignal, ...params}: RequestConfig & s.GetCalendarStateRequest,
  ): Promise<s.GetCalendarStateResponse> {
    const body: jsonP.JSONObject = {
      CalendarNames: params["CalendarNames"],
      AtTime: params["AtTime"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCalendarState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.CalendarState>(x),
        "AtTime": "s",
        "NextTransitionTime": "s",
      },
    }, await resp.json());
  }

  async getCommandInvocation(
    {abortSignal, ...params}: RequestConfig & s.GetCommandInvocationRequest,
  ): Promise<s.GetCommandInvocationResult> {
    const body: jsonP.JSONObject = {
      CommandId: params["CommandId"],
      InstanceId: params["InstanceId"],
      PluginName: params["PluginName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCommandInvocation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CommandId": "s",
        "InstanceId": "s",
        "Comment": "s",
        "DocumentName": "s",
        "DocumentVersion": "s",
        "PluginName": "s",
        "ResponseCode": "n",
        "ExecutionStartDateTime": "s",
        "ExecutionElapsedTime": "s",
        "ExecutionEndDateTime": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommandInvocationStatus>(x),
        "StatusDetails": "s",
        "StandardOutputContent": "s",
        "StandardOutputUrl": "s",
        "StandardErrorContent": "s",
        "StandardErrorUrl": "s",
        "CloudWatchOutputConfig": toCloudWatchOutputConfig,
      },
    }, await resp.json());
  }

  async getConnectionStatus(
    {abortSignal, ...params}: RequestConfig & s.GetConnectionStatusRequest,
  ): Promise<s.GetConnectionStatusResponse> {
    const body: jsonP.JSONObject = {
      Target: params["Target"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConnectionStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Target": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionStatus>(x),
      },
    }, await resp.json());
  }

  async getDefaultPatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.GetDefaultPatchBaselineRequest = {},
  ): Promise<s.GetDefaultPatchBaselineResult> {
    const body: jsonP.JSONObject = {
      OperatingSystem: params["OperatingSystem"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDefaultPatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      },
    }, await resp.json());
  }

  async getDeployablePatchSnapshotForInstance(
    {abortSignal, ...params}: RequestConfig & s.GetDeployablePatchSnapshotForInstanceRequest,
  ): Promise<s.GetDeployablePatchSnapshotForInstanceResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      SnapshotId: params["SnapshotId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeployablePatchSnapshotForInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceId": "s",
        "SnapshotId": "s",
        "SnapshotDownloadUrl": "s",
        "Product": "s",
      },
    }, await resp.json());
  }

  async getDocument(
    {abortSignal, ...params}: RequestConfig & s.GetDocumentRequest,
  ): Promise<s.GetDocumentResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      VersionName: params["VersionName"],
      DocumentVersion: params["DocumentVersion"],
      DocumentFormat: params["DocumentFormat"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "VersionName": "s",
        "DocumentVersion": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentStatus>(x),
        "StatusInformation": "s",
        "Content": "s",
        "DocumentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentType>(x),
        "DocumentFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentFormat>(x),
        "Requires": [toDocumentRequires],
        "AttachmentsContent": [toAttachmentContent],
        "ReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
      },
    }, await resp.json());
  }

  async getInventory(
    {abortSignal, ...params}: RequestConfig & s.GetInventoryRequest = {},
  ): Promise<s.GetInventoryResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromInventoryFilter(x)),
      Aggregators: params["Aggregators"]?.map(x => fromInventoryAggregator(x)),
      ResultAttributes: params["ResultAttributes"]?.map(x => fromResultAttribute(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInventory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entities": [toInventoryResultEntity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInventorySchema(
    {abortSignal, ...params}: RequestConfig & s.GetInventorySchemaRequest = {},
  ): Promise<s.GetInventorySchemaResult> {
    const body: jsonP.JSONObject = {
      TypeName: params["TypeName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Aggregator: params["Aggregator"],
      SubType: params["SubType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInventorySchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Schemas": [toInventoryItemSchema],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.GetMaintenanceWindowRequest,
  ): Promise<s.GetMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "Name": "s",
        "Description": "s",
        "StartDate": "s",
        "EndDate": "s",
        "Schedule": "s",
        "ScheduleTimezone": "s",
        "ScheduleOffset": "n",
        "NextExecutionTime": "s",
        "Duration": "n",
        "Cutoff": "n",
        "AllowUnassociatedTargets": "b",
        "Enabled": "b",
        "CreatedDate": "d",
        "ModifiedDate": "d",
      },
    }, await resp.json());
  }

  async getMaintenanceWindowExecution(
    {abortSignal, ...params}: RequestConfig & s.GetMaintenanceWindowExecutionRequest,
  ): Promise<s.GetMaintenanceWindowExecutionResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMaintenanceWindowExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionId": "s",
        "TaskIds": ["s"],
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
        "StatusDetails": "s",
        "StartTime": "d",
        "EndTime": "d",
      },
    }, await resp.json());
  }

  async getMaintenanceWindowExecutionTask(
    {abortSignal, ...params}: RequestConfig & s.GetMaintenanceWindowExecutionTaskRequest,
  ): Promise<s.GetMaintenanceWindowExecutionTaskResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
      TaskId: params["TaskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMaintenanceWindowExecutionTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionId": "s",
        "TaskExecutionId": "s",
        "TaskArn": "s",
        "ServiceRole": "s",
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
        "TaskParameters": [x => jsonP.readMap(String, toMaintenanceWindowTaskParameterValueExpression, x)],
        "Priority": "n",
        "MaxConcurrency": "s",
        "MaxErrors": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
        "StatusDetails": "s",
        "StartTime": "d",
        "EndTime": "d",
      },
    }, await resp.json());
  }

  async getMaintenanceWindowExecutionTaskInvocation(
    {abortSignal, ...params}: RequestConfig & s.GetMaintenanceWindowExecutionTaskInvocationRequest,
  ): Promise<s.GetMaintenanceWindowExecutionTaskInvocationResult> {
    const body: jsonP.JSONObject = {
      WindowExecutionId: params["WindowExecutionId"],
      TaskId: params["TaskId"],
      InvocationId: params["InvocationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMaintenanceWindowExecutionTaskInvocation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowExecutionId": "s",
        "TaskExecutionId": "s",
        "InvocationId": "s",
        "ExecutionId": "s",
        "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
        "Parameters": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
        "StatusDetails": "s",
        "StartTime": "d",
        "EndTime": "d",
        "OwnerInformation": "s",
        "WindowTargetId": "s",
      },
    }, await resp.json());
  }

  async getMaintenanceWindowTask(
    {abortSignal, ...params}: RequestConfig & s.GetMaintenanceWindowTaskRequest,
  ): Promise<s.GetMaintenanceWindowTaskResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      WindowTaskId: params["WindowTaskId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMaintenanceWindowTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "WindowTaskId": "s",
        "Targets": [toTarget],
        "TaskArn": "s",
        "ServiceRoleArn": "s",
        "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
        "TaskParameters": x => jsonP.readMap(String, toMaintenanceWindowTaskParameterValueExpression, x),
        "TaskInvocationParameters": toMaintenanceWindowTaskInvocationParameters,
        "Priority": "n",
        "MaxConcurrency": "s",
        "MaxErrors": "s",
        "LoggingInfo": toLoggingInfo,
        "Name": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async getOpsItem(
    {abortSignal, ...params}: RequestConfig & s.GetOpsItemRequest,
  ): Promise<s.GetOpsItemResponse> {
    const body: jsonP.JSONObject = {
      OpsItemId: params["OpsItemId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOpsItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OpsItem": toOpsItem,
      },
    }, await resp.json());
  }

  async getOpsMetadata(
    {abortSignal, ...params}: RequestConfig & s.GetOpsMetadataRequest,
  ): Promise<s.GetOpsMetadataResult> {
    const body: jsonP.JSONObject = {
      OpsMetadataArn: params["OpsMetadataArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOpsMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceId": "s",
        "Metadata": x => jsonP.readMap(String, toMetadataValue, x),
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getOpsSummary(
    {abortSignal, ...params}: RequestConfig & s.GetOpsSummaryRequest = {},
  ): Promise<s.GetOpsSummaryResult> {
    const body: jsonP.JSONObject = {
      SyncName: params["SyncName"],
      Filters: params["Filters"]?.map(x => fromOpsFilter(x)),
      Aggregators: params["Aggregators"]?.map(x => fromOpsAggregator(x)),
      ResultAttributes: params["ResultAttributes"]?.map(x => fromOpsResultAttribute(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOpsSummary",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Entities": [toOpsEntity],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getParameter(
    {abortSignal, ...params}: RequestConfig & s.GetParameterRequest,
  ): Promise<s.GetParameterResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      WithDecryption: params["WithDecryption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParameter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parameter": toParameter,
      },
    }, await resp.json());
  }

  async getParameterHistory(
    {abortSignal, ...params}: RequestConfig & s.GetParameterHistoryRequest,
  ): Promise<s.GetParameterHistoryResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      WithDecryption: params["WithDecryption"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParameterHistory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parameters": [toParameterHistory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getParameters(
    {abortSignal, ...params}: RequestConfig & s.GetParametersRequest,
  ): Promise<s.GetParametersResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      WithDecryption: params["WithDecryption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parameters": [toParameter],
        "InvalidParameters": ["s"],
      },
    }, await resp.json());
  }

  async getParametersByPath(
    {abortSignal, ...params}: RequestConfig & s.GetParametersByPathRequest,
  ): Promise<s.GetParametersByPathResult> {
    const body: jsonP.JSONObject = {
      Path: params["Path"],
      Recursive: params["Recursive"],
      ParameterFilters: params["ParameterFilters"]?.map(x => fromParameterStringFilter(x)),
      WithDecryption: params["WithDecryption"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParametersByPath",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Parameters": [toParameter],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getPatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.GetPatchBaselineRequest,
  ): Promise<s.GetPatchBaselineResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "Name": "s",
        "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
        "GlobalFilters": toPatchFilterGroup,
        "ApprovalRules": toPatchRuleGroup,
        "ApprovedPatches": ["s"],
        "ApprovedPatchesComplianceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchComplianceLevel>(x),
        "ApprovedPatchesEnableNonSecurity": "b",
        "RejectedPatches": ["s"],
        "RejectedPatchesAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchAction>(x),
        "PatchGroups": ["s"],
        "CreatedDate": "d",
        "ModifiedDate": "d",
        "Description": "s",
        "Sources": [toPatchSource],
      },
    }, await resp.json());
  }

  async getPatchBaselineForPatchGroup(
    {abortSignal, ...params}: RequestConfig & s.GetPatchBaselineForPatchGroupRequest,
  ): Promise<s.GetPatchBaselineForPatchGroupResult> {
    const body: jsonP.JSONObject = {
      PatchGroup: params["PatchGroup"],
      OperatingSystem: params["OperatingSystem"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPatchBaselineForPatchGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "PatchGroup": "s",
        "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      },
    }, await resp.json());
  }

  async getServiceSetting(
    {abortSignal, ...params}: RequestConfig & s.GetServiceSettingRequest,
  ): Promise<s.GetServiceSettingResult> {
    const body: jsonP.JSONObject = {
      SettingId: params["SettingId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetServiceSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSetting": toServiceSetting,
      },
    }, await resp.json());
  }

  async labelParameterVersion(
    {abortSignal, ...params}: RequestConfig & s.LabelParameterVersionRequest,
  ): Promise<s.LabelParameterVersionResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ParameterVersion: params["ParameterVersion"],
      Labels: params["Labels"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "LabelParameterVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InvalidLabels": ["s"],
        "ParameterVersion": "n",
      },
    }, await resp.json());
  }

  async listAssociationVersions(
    {abortSignal, ...params}: RequestConfig & s.ListAssociationVersionsRequest,
  ): Promise<s.ListAssociationVersionsResult> {
    const body: jsonP.JSONObject = {
      AssociationId: params["AssociationId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociationVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationVersions": [toAssociationVersionInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAssociations(
    {abortSignal, ...params}: RequestConfig & s.ListAssociationsRequest = {},
  ): Promise<s.ListAssociationsResult> {
    const body: jsonP.JSONObject = {
      AssociationFilterList: params["AssociationFilterList"]?.map(x => fromAssociationFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Associations": [toAssociation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCommandInvocations(
    {abortSignal, ...params}: RequestConfig & s.ListCommandInvocationsRequest = {},
  ): Promise<s.ListCommandInvocationsResult> {
    const body: jsonP.JSONObject = {
      CommandId: params["CommandId"],
      InstanceId: params["InstanceId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromCommandFilter(x)),
      Details: params["Details"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCommandInvocations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CommandInvocations": [toCommandInvocation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCommands(
    {abortSignal, ...params}: RequestConfig & s.ListCommandsRequest = {},
  ): Promise<s.ListCommandsResult> {
    const body: jsonP.JSONObject = {
      CommandId: params["CommandId"],
      InstanceId: params["InstanceId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromCommandFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCommands",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Commands": [toCommand],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listComplianceItems(
    {abortSignal, ...params}: RequestConfig & s.ListComplianceItemsRequest = {},
  ): Promise<s.ListComplianceItemsResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromComplianceStringFilter(x)),
      ResourceIds: params["ResourceIds"],
      ResourceTypes: params["ResourceTypes"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListComplianceItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ComplianceItems": [toComplianceItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listComplianceSummaries(
    {abortSignal, ...params}: RequestConfig & s.ListComplianceSummariesRequest = {},
  ): Promise<s.ListComplianceSummariesResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromComplianceStringFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListComplianceSummaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ComplianceSummaryItems": [toComplianceSummaryItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDocumentMetadataHistory(
    {abortSignal, ...params}: RequestConfig & s.ListDocumentMetadataHistoryRequest,
  ): Promise<s.ListDocumentMetadataHistoryResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
      Metadata: params["Metadata"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDocumentMetadataHistory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "DocumentVersion": "s",
        "Author": "s",
        "Metadata": toDocumentMetadataResponseInfo,
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDocumentVersions(
    {abortSignal, ...params}: RequestConfig & s.ListDocumentVersionsRequest,
  ): Promise<s.ListDocumentVersionsResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDocumentVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentVersions": [toDocumentVersionInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDocuments(
    {abortSignal, ...params}: RequestConfig & s.ListDocumentsRequest = {},
  ): Promise<s.ListDocumentsResult> {
    const body: jsonP.JSONObject = {
      DocumentFilterList: params["DocumentFilterList"]?.map(x => fromDocumentFilter(x)),
      Filters: params["Filters"]?.map(x => fromDocumentKeyValuesFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDocuments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentIdentifiers": [toDocumentIdentifier],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInventoryEntries(
    {abortSignal, ...params}: RequestConfig & s.ListInventoryEntriesRequest,
  ): Promise<s.ListInventoryEntriesResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      TypeName: params["TypeName"],
      Filters: params["Filters"]?.map(x => fromInventoryFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInventoryEntries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TypeName": "s",
        "InstanceId": "s",
        "SchemaVersion": "s",
        "CaptureTime": "s",
        "Entries": [x => jsonP.readMap(String, String, x)],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOpsItemEvents(
    {abortSignal, ...params}: RequestConfig & s.ListOpsItemEventsRequest = {},
  ): Promise<s.ListOpsItemEventsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromOpsItemEventFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOpsItemEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Summaries": [toOpsItemEventSummary],
      },
    }, await resp.json());
  }

  async listOpsMetadata(
    {abortSignal, ...params}: RequestConfig & s.ListOpsMetadataRequest = {},
  ): Promise<s.ListOpsMetadataResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromOpsMetadataFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListOpsMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OpsMetadataList": [toOpsMetadata],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listResourceComplianceSummaries(
    {abortSignal, ...params}: RequestConfig & s.ListResourceComplianceSummariesRequest = {},
  ): Promise<s.ListResourceComplianceSummariesResult> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromComplianceStringFilter(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourceComplianceSummaries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceComplianceSummaryItems": [toResourceComplianceSummaryItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listResourceDataSync(
    {abortSignal, ...params}: RequestConfig & s.ListResourceDataSyncRequest = {},
  ): Promise<s.ListResourceDataSyncResult> {
    const body: jsonP.JSONObject = {
      SyncType: params["SyncType"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourceDataSync",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceDataSyncItems": [toResourceDataSyncItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const body: jsonP.JSONObject = {
      ResourceType: params["ResourceType"],
      ResourceId: params["ResourceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TagList": [toTag],
      },
    }, await resp.json());
  }

  async modifyDocumentPermission(
    {abortSignal, ...params}: RequestConfig & s.ModifyDocumentPermissionRequest,
  ): Promise<s.ModifyDocumentPermissionResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      PermissionType: params["PermissionType"],
      AccountIdsToAdd: params["AccountIdsToAdd"],
      AccountIdsToRemove: params["AccountIdsToRemove"],
      SharedDocumentVersion: params["SharedDocumentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDocumentPermission",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putComplianceItems(
    {abortSignal, ...params}: RequestConfig & s.PutComplianceItemsRequest,
  ): Promise<s.PutComplianceItemsResult> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      ResourceType: params["ResourceType"],
      ComplianceType: params["ComplianceType"],
      ExecutionSummary: fromComplianceExecutionSummary(params["ExecutionSummary"]),
      Items: params["Items"]?.map(x => fromComplianceItemEntry(x)),
      ItemContentHash: params["ItemContentHash"],
      UploadType: params["UploadType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutComplianceItems",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putInventory(
    {abortSignal, ...params}: RequestConfig & s.PutInventoryRequest,
  ): Promise<s.PutInventoryResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      Items: params["Items"]?.map(x => fromInventoryItem(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutInventory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Message": "s",
      },
    }, await resp.json());
  }

  async putParameter(
    {abortSignal, ...params}: RequestConfig & s.PutParameterRequest,
  ): Promise<s.PutParameterResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      Value: params["Value"],
      Type: params["Type"],
      KeyId: params["KeyId"],
      Overwrite: params["Overwrite"],
      AllowedPattern: params["AllowedPattern"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      Tier: params["Tier"],
      Policies: params["Policies"],
      DataType: params["DataType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutParameter",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Version": "n",
        "Tier": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterTier>(x),
      },
    }, await resp.json());
  }

  async registerDefaultPatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.RegisterDefaultPatchBaselineRequest,
  ): Promise<s.RegisterDefaultPatchBaselineResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterDefaultPatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
      },
    }, await resp.json());
  }

  async registerPatchBaselineForPatchGroup(
    {abortSignal, ...params}: RequestConfig & s.RegisterPatchBaselineForPatchGroupRequest,
  ): Promise<s.RegisterPatchBaselineForPatchGroupResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
      PatchGroup: params["PatchGroup"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterPatchBaselineForPatchGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "PatchGroup": "s",
      },
    }, await resp.json());
  }

  async registerTargetWithMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.RegisterTargetWithMaintenanceWindowRequest,
  ): Promise<s.RegisterTargetWithMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      ResourceType: params["ResourceType"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      OwnerInformation: params["OwnerInformation"],
      Name: params["Name"],
      Description: params["Description"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTargetWithMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowTargetId": "s",
      },
    }, await resp.json());
  }

  async registerTaskWithMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.RegisterTaskWithMaintenanceWindowRequest,
  ): Promise<s.RegisterTaskWithMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      TaskArn: params["TaskArn"],
      ServiceRoleArn: params["ServiceRoleArn"],
      TaskType: params["TaskType"],
      TaskParameters: jsonP.serializeMap(params["TaskParameters"], x => fromMaintenanceWindowTaskParameterValueExpression(x)),
      TaskInvocationParameters: fromMaintenanceWindowTaskInvocationParameters(params["TaskInvocationParameters"]),
      Priority: params["Priority"],
      MaxConcurrency: params["MaxConcurrency"],
      MaxErrors: params["MaxErrors"],
      LoggingInfo: fromLoggingInfo(params["LoggingInfo"]),
      Name: params["Name"],
      Description: params["Description"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTaskWithMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowTaskId": "s",
      },
    }, await resp.json());
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceRequest,
  ): Promise<s.RemoveTagsFromResourceResult> {
    const body: jsonP.JSONObject = {
      ResourceType: params["ResourceType"],
      ResourceId: params["ResourceId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async resetServiceSetting(
    {abortSignal, ...params}: RequestConfig & s.ResetServiceSettingRequest,
  ): Promise<s.ResetServiceSettingResult> {
    const body: jsonP.JSONObject = {
      SettingId: params["SettingId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetServiceSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSetting": toServiceSetting,
      },
    }, await resp.json());
  }

  async resumeSession(
    {abortSignal, ...params}: RequestConfig & s.ResumeSessionRequest,
  ): Promise<s.ResumeSessionResponse> {
    const body: jsonP.JSONObject = {
      SessionId: params["SessionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionId": "s",
        "TokenValue": "s",
        "StreamUrl": "s",
      },
    }, await resp.json());
  }

  async sendAutomationSignal(
    {abortSignal, ...params}: RequestConfig & s.SendAutomationSignalRequest,
  ): Promise<s.SendAutomationSignalResult> {
    const body: jsonP.JSONObject = {
      AutomationExecutionId: params["AutomationExecutionId"],
      SignalType: params["SignalType"],
      Payload: params["Payload"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendAutomationSignal",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async sendCommand(
    {abortSignal, ...params}: RequestConfig & s.SendCommandRequest,
  ): Promise<s.SendCommandResult> {
    const body: jsonP.JSONObject = {
      InstanceIds: params["InstanceIds"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      DocumentName: params["DocumentName"],
      DocumentVersion: params["DocumentVersion"],
      DocumentHash: params["DocumentHash"],
      DocumentHashType: params["DocumentHashType"],
      TimeoutSeconds: params["TimeoutSeconds"],
      Comment: params["Comment"],
      Parameters: params["Parameters"],
      OutputS3Region: params["OutputS3Region"],
      OutputS3BucketName: params["OutputS3BucketName"],
      OutputS3KeyPrefix: params["OutputS3KeyPrefix"],
      MaxConcurrency: params["MaxConcurrency"],
      MaxErrors: params["MaxErrors"],
      ServiceRoleArn: params["ServiceRoleArn"],
      NotificationConfig: fromNotificationConfig(params["NotificationConfig"]),
      CloudWatchOutputConfig: fromCloudWatchOutputConfig(params["CloudWatchOutputConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendCommand",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Command": toCommand,
      },
    }, await resp.json());
  }

  async startAssociationsOnce(
    {abortSignal, ...params}: RequestConfig & s.StartAssociationsOnceRequest,
  ): Promise<s.StartAssociationsOnceResult> {
    const body: jsonP.JSONObject = {
      AssociationIds: params["AssociationIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartAssociationsOnce",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startAutomationExecution(
    {abortSignal, ...params}: RequestConfig & s.StartAutomationExecutionRequest,
  ): Promise<s.StartAutomationExecutionResult> {
    const body: jsonP.JSONObject = {
      DocumentName: params["DocumentName"],
      DocumentVersion: params["DocumentVersion"],
      Parameters: params["Parameters"],
      ClientToken: params["ClientToken"],
      Mode: params["Mode"],
      TargetParameterName: params["TargetParameterName"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      TargetMaps: params["TargetMaps"],
      MaxConcurrency: params["MaxConcurrency"],
      MaxErrors: params["MaxErrors"],
      TargetLocations: params["TargetLocations"]?.map(x => fromTargetLocation(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartAutomationExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomationExecutionId": "s",
      },
    }, await resp.json());
  }

  async startChangeRequestExecution(
    {abortSignal, ...params}: RequestConfig & s.StartChangeRequestExecutionRequest,
  ): Promise<s.StartChangeRequestExecutionResult> {
    const body: jsonP.JSONObject = {
      ScheduledTime: jsonP.serializeDate_unixTimestamp(params["ScheduledTime"]),
      DocumentName: params["DocumentName"],
      DocumentVersion: params["DocumentVersion"],
      Parameters: params["Parameters"],
      ChangeRequestName: params["ChangeRequestName"],
      ClientToken: params["ClientToken"],
      Runbooks: params["Runbooks"]?.map(x => fromRunbook(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartChangeRequestExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutomationExecutionId": "s",
      },
    }, await resp.json());
  }

  async startSession(
    {abortSignal, ...params}: RequestConfig & s.StartSessionRequest,
  ): Promise<s.StartSessionResponse> {
    const body: jsonP.JSONObject = {
      Target: params["Target"],
      DocumentName: params["DocumentName"],
      Parameters: params["Parameters"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionId": "s",
        "TokenValue": "s",
        "StreamUrl": "s",
      },
    }, await resp.json());
  }

  async stopAutomationExecution(
    {abortSignal, ...params}: RequestConfig & s.StopAutomationExecutionRequest,
  ): Promise<s.StopAutomationExecutionResult> {
    const body: jsonP.JSONObject = {
      AutomationExecutionId: params["AutomationExecutionId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopAutomationExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async terminateSession(
    {abortSignal, ...params}: RequestConfig & s.TerminateSessionRequest,
  ): Promise<s.TerminateSessionResponse> {
    const body: jsonP.JSONObject = {
      SessionId: params["SessionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionId": "s",
      },
    }, await resp.json());
  }

  async updateAssociation(
    {abortSignal, ...params}: RequestConfig & s.UpdateAssociationRequest,
  ): Promise<s.UpdateAssociationResult> {
    const body: jsonP.JSONObject = {
      AssociationId: params["AssociationId"],
      Parameters: params["Parameters"],
      DocumentVersion: params["DocumentVersion"],
      ScheduleExpression: params["ScheduleExpression"],
      OutputLocation: fromInstanceAssociationOutputLocation(params["OutputLocation"]),
      Name: params["Name"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      AssociationName: params["AssociationName"],
      AssociationVersion: params["AssociationVersion"],
      AutomationTargetParameterName: params["AutomationTargetParameterName"],
      MaxErrors: params["MaxErrors"],
      MaxConcurrency: params["MaxConcurrency"],
      ComplianceSeverity: params["ComplianceSeverity"],
      SyncCompliance: params["SyncCompliance"],
      ApplyOnlyAtCronInterval: params["ApplyOnlyAtCronInterval"],
      TargetLocations: params["TargetLocations"]?.map(x => fromTargetLocation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationDescription": toAssociationDescription,
      },
    }, await resp.json());
  }

  async updateAssociationStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdateAssociationStatusRequest,
  ): Promise<s.UpdateAssociationStatusResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      InstanceId: params["InstanceId"],
      AssociationStatus: fromAssociationStatus(params["AssociationStatus"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAssociationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationDescription": toAssociationDescription,
      },
    }, await resp.json());
  }

  async updateDocument(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentRequest,
  ): Promise<s.UpdateDocumentResult> {
    const body: jsonP.JSONObject = {
      Content: params["Content"],
      Attachments: params["Attachments"]?.map(x => fromAttachmentsSource(x)),
      Name: params["Name"],
      VersionName: params["VersionName"],
      DocumentVersion: params["DocumentVersion"],
      DocumentFormat: params["DocumentFormat"],
      TargetType: params["TargetType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentDescription": toDocumentDescription,
      },
    }, await resp.json());
  }

  async updateDocumentDefaultVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentDefaultVersionRequest,
  ): Promise<s.UpdateDocumentDefaultVersionResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentDefaultVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Description": toDocumentDefaultVersionDescription,
      },
    }, await resp.json());
  }

  async updateDocumentMetadata(
    {abortSignal, ...params}: RequestConfig & s.UpdateDocumentMetadataRequest,
  ): Promise<s.UpdateDocumentMetadataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      DocumentVersion: params["DocumentVersion"],
      DocumentReviews: fromDocumentReviews(params["DocumentReviews"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDocumentMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateMaintenanceWindow(
    {abortSignal, ...params}: RequestConfig & s.UpdateMaintenanceWindowRequest,
  ): Promise<s.UpdateMaintenanceWindowResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      Name: params["Name"],
      Description: params["Description"],
      StartDate: params["StartDate"],
      EndDate: params["EndDate"],
      Schedule: params["Schedule"],
      ScheduleTimezone: params["ScheduleTimezone"],
      ScheduleOffset: params["ScheduleOffset"],
      Duration: params["Duration"],
      Cutoff: params["Cutoff"],
      AllowUnassociatedTargets: params["AllowUnassociatedTargets"],
      Enabled: params["Enabled"],
      Replace: params["Replace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMaintenanceWindow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "Name": "s",
        "Description": "s",
        "StartDate": "s",
        "EndDate": "s",
        "Schedule": "s",
        "ScheduleTimezone": "s",
        "ScheduleOffset": "n",
        "Duration": "n",
        "Cutoff": "n",
        "AllowUnassociatedTargets": "b",
        "Enabled": "b",
      },
    }, await resp.json());
  }

  async updateMaintenanceWindowTarget(
    {abortSignal, ...params}: RequestConfig & s.UpdateMaintenanceWindowTargetRequest,
  ): Promise<s.UpdateMaintenanceWindowTargetResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      WindowTargetId: params["WindowTargetId"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      OwnerInformation: params["OwnerInformation"],
      Name: params["Name"],
      Description: params["Description"],
      Replace: params["Replace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMaintenanceWindowTarget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "WindowTargetId": "s",
        "Targets": [toTarget],
        "OwnerInformation": "s",
        "Name": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async updateMaintenanceWindowTask(
    {abortSignal, ...params}: RequestConfig & s.UpdateMaintenanceWindowTaskRequest,
  ): Promise<s.UpdateMaintenanceWindowTaskResult> {
    const body: jsonP.JSONObject = {
      WindowId: params["WindowId"],
      WindowTaskId: params["WindowTaskId"],
      Targets: params["Targets"]?.map(x => fromTarget(x)),
      TaskArn: params["TaskArn"],
      ServiceRoleArn: params["ServiceRoleArn"],
      TaskParameters: jsonP.serializeMap(params["TaskParameters"], x => fromMaintenanceWindowTaskParameterValueExpression(x)),
      TaskInvocationParameters: fromMaintenanceWindowTaskInvocationParameters(params["TaskInvocationParameters"]),
      Priority: params["Priority"],
      MaxConcurrency: params["MaxConcurrency"],
      MaxErrors: params["MaxErrors"],
      LoggingInfo: fromLoggingInfo(params["LoggingInfo"]),
      Name: params["Name"],
      Description: params["Description"],
      Replace: params["Replace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMaintenanceWindowTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WindowId": "s",
        "WindowTaskId": "s",
        "Targets": [toTarget],
        "TaskArn": "s",
        "ServiceRoleArn": "s",
        "TaskParameters": x => jsonP.readMap(String, toMaintenanceWindowTaskParameterValueExpression, x),
        "TaskInvocationParameters": toMaintenanceWindowTaskInvocationParameters,
        "Priority": "n",
        "MaxConcurrency": "s",
        "MaxErrors": "s",
        "LoggingInfo": toLoggingInfo,
        "Name": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async updateManagedInstanceRole(
    {abortSignal, ...params}: RequestConfig & s.UpdateManagedInstanceRoleRequest,
  ): Promise<s.UpdateManagedInstanceRoleResult> {
    const body: jsonP.JSONObject = {
      InstanceId: params["InstanceId"],
      IamRole: params["IamRole"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateManagedInstanceRole",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateOpsItem(
    {abortSignal, ...params}: RequestConfig & s.UpdateOpsItemRequest,
  ): Promise<s.UpdateOpsItemResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      OperationalData: jsonP.serializeMap(params["OperationalData"], x => fromOpsItemDataValue(x)),
      OperationalDataToDelete: params["OperationalDataToDelete"],
      Notifications: params["Notifications"]?.map(x => fromOpsItemNotification(x)),
      Priority: params["Priority"],
      RelatedOpsItems: params["RelatedOpsItems"]?.map(x => fromRelatedOpsItem(x)),
      Status: params["Status"],
      OpsItemId: params["OpsItemId"],
      Title: params["Title"],
      Category: params["Category"],
      Severity: params["Severity"],
      ActualStartTime: jsonP.serializeDate_unixTimestamp(params["ActualStartTime"]),
      ActualEndTime: jsonP.serializeDate_unixTimestamp(params["ActualEndTime"]),
      PlannedStartTime: jsonP.serializeDate_unixTimestamp(params["PlannedStartTime"]),
      PlannedEndTime: jsonP.serializeDate_unixTimestamp(params["PlannedEndTime"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOpsItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateOpsMetadata(
    {abortSignal, ...params}: RequestConfig & s.UpdateOpsMetadataRequest,
  ): Promise<s.UpdateOpsMetadataResult> {
    const body: jsonP.JSONObject = {
      OpsMetadataArn: params["OpsMetadataArn"],
      MetadataToUpdate: jsonP.serializeMap(params["MetadataToUpdate"], x => fromMetadataValue(x)),
      KeysToDelete: params["KeysToDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOpsMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OpsMetadataArn": "s",
      },
    }, await resp.json());
  }

  async updatePatchBaseline(
    {abortSignal, ...params}: RequestConfig & s.UpdatePatchBaselineRequest,
  ): Promise<s.UpdatePatchBaselineResult> {
    const body: jsonP.JSONObject = {
      BaselineId: params["BaselineId"],
      Name: params["Name"],
      GlobalFilters: fromPatchFilterGroup(params["GlobalFilters"]),
      ApprovalRules: fromPatchRuleGroup(params["ApprovalRules"]),
      ApprovedPatches: params["ApprovedPatches"],
      ApprovedPatchesComplianceLevel: params["ApprovedPatchesComplianceLevel"],
      ApprovedPatchesEnableNonSecurity: params["ApprovedPatchesEnableNonSecurity"],
      RejectedPatches: params["RejectedPatches"],
      RejectedPatchesAction: params["RejectedPatchesAction"],
      Description: params["Description"],
      Sources: params["Sources"]?.map(x => fromPatchSource(x)),
      Replace: params["Replace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePatchBaseline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaselineId": "s",
        "Name": "s",
        "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
        "GlobalFilters": toPatchFilterGroup,
        "ApprovalRules": toPatchRuleGroup,
        "ApprovedPatches": ["s"],
        "ApprovedPatchesComplianceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchComplianceLevel>(x),
        "ApprovedPatchesEnableNonSecurity": "b",
        "RejectedPatches": ["s"],
        "RejectedPatchesAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchAction>(x),
        "CreatedDate": "d",
        "ModifiedDate": "d",
        "Description": "s",
        "Sources": [toPatchSource],
      },
    }, await resp.json());
  }

  async updateResourceDataSync(
    {abortSignal, ...params}: RequestConfig & s.UpdateResourceDataSyncRequest,
  ): Promise<s.UpdateResourceDataSyncResult> {
    const body: jsonP.JSONObject = {
      SyncName: params["SyncName"],
      SyncType: params["SyncType"],
      SyncSource: fromResourceDataSyncSource(params["SyncSource"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateResourceDataSync",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateServiceSetting(
    {abortSignal, ...params}: RequestConfig & s.UpdateServiceSettingRequest,
  ): Promise<s.UpdateServiceSettingResult> {
    const body: jsonP.JSONObject = {
      SettingId: params["SettingId"],
      SettingValue: params["SettingValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceSetting",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForCommandExecuted(
    params: RequestConfig & s.GetCommandInvocationRequest,
  ): Promise<s.GetCommandInvocationResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CommandExecuted';
    for (let i = 0; i < 20; i++) {
      const resp = await this.getCommandInvocation(params);
      const field = resp?.Status;
      if (field === "Pending") continue;
      if (field === "InProgress") continue;
      if (field === "Delayed") continue;
      if (field === "Success") return resp;
      if (field === "Cancelled") throw new Error(errMessage);
      if (field === "TimedOut") throw new Error(errMessage);
      if (field === "Failed") throw new Error(errMessage);
      if (field === "Cancelling") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromTarget(input?: s.Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}
function toTarget(root: jsonP.JSONValue): s.Target {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Values": ["s"],
    },
  }, root);
}

function fromInstanceAssociationOutputLocation(input?: s.InstanceAssociationOutputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Location: fromS3OutputLocation(input["S3Location"]),
  }
}
function toInstanceAssociationOutputLocation(root: jsonP.JSONValue): s.InstanceAssociationOutputLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Location": toS3OutputLocation,
    },
  }, root);
}

function fromS3OutputLocation(input?: s.S3OutputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OutputS3Region: input["OutputS3Region"],
    OutputS3BucketName: input["OutputS3BucketName"],
    OutputS3KeyPrefix: input["OutputS3KeyPrefix"],
  }
}
function toS3OutputLocation(root: jsonP.JSONValue): s.S3OutputLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputS3Region": "s",
      "OutputS3BucketName": "s",
      "OutputS3KeyPrefix": "s",
    },
  }, root);
}

function fromTargetLocation(input?: s.TargetLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Accounts: input["Accounts"],
    Regions: input["Regions"],
    TargetLocationMaxConcurrency: input["TargetLocationMaxConcurrency"],
    TargetLocationMaxErrors: input["TargetLocationMaxErrors"],
    ExecutionRoleName: input["ExecutionRoleName"],
  }
}
function toTargetLocation(root: jsonP.JSONValue): s.TargetLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Accounts": ["s"],
      "Regions": ["s"],
      "TargetLocationMaxConcurrency": "s",
      "TargetLocationMaxErrors": "s",
      "ExecutionRoleName": "s",
    },
  }, root);
}

function fromCreateAssociationBatchRequestEntry(input?: s.CreateAssociationBatchRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    InstanceId: input["InstanceId"],
    Parameters: input["Parameters"],
    AutomationTargetParameterName: input["AutomationTargetParameterName"],
    DocumentVersion: input["DocumentVersion"],
    Targets: input["Targets"]?.map(x => fromTarget(x)),
    ScheduleExpression: input["ScheduleExpression"],
    OutputLocation: fromInstanceAssociationOutputLocation(input["OutputLocation"]),
    AssociationName: input["AssociationName"],
    MaxErrors: input["MaxErrors"],
    MaxConcurrency: input["MaxConcurrency"],
    ComplianceSeverity: input["ComplianceSeverity"],
    SyncCompliance: input["SyncCompliance"],
    ApplyOnlyAtCronInterval: input["ApplyOnlyAtCronInterval"],
    TargetLocations: input["TargetLocations"]?.map(x => fromTargetLocation(x)),
  }
}
function toCreateAssociationBatchRequestEntry(root: jsonP.JSONValue): s.CreateAssociationBatchRequestEntry {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "InstanceId": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "AutomationTargetParameterName": "s",
      "DocumentVersion": "s",
      "Targets": [toTarget],
      "ScheduleExpression": "s",
      "OutputLocation": toInstanceAssociationOutputLocation,
      "AssociationName": "s",
      "MaxErrors": "s",
      "MaxConcurrency": "s",
      "ComplianceSeverity": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationComplianceSeverity>(x),
      "SyncCompliance": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationSyncCompliance>(x),
      "ApplyOnlyAtCronInterval": "b",
      "TargetLocations": [toTargetLocation],
    },
  }, root);
}

function fromDocumentRequires(input?: s.DocumentRequires | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
  }
}
function toDocumentRequires(root: jsonP.JSONValue): s.DocumentRequires {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Version": "s",
    },
  }, root);
}

function fromAttachmentsSource(input?: s.AttachmentsSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Name: input["Name"],
  }
}

function fromOpsItemDataValue(input?: s.OpsItemDataValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Type: input["Type"],
  }
}
function toOpsItemDataValue(root: jsonP.JSONValue): s.OpsItemDataValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.OpsItemDataType>(x),
    },
  }, root);
}

function fromOpsItemNotification(input?: s.OpsItemNotification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
  }
}
function toOpsItemNotification(root: jsonP.JSONValue): s.OpsItemNotification {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function fromRelatedOpsItem(input?: s.RelatedOpsItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OpsItemId: input["OpsItemId"],
  }
}
function toRelatedOpsItem(root: jsonP.JSONValue): s.RelatedOpsItem {
  return jsonP.readObj({
    required: {
      "OpsItemId": "s",
    },
    optional: {},
  }, root);
}

function fromMetadataValue(input?: s.MetadataValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
  }
}
function toMetadataValue(root: jsonP.JSONValue): s.MetadataValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromPatchFilterGroup(input?: s.PatchFilterGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PatchFilters: input["PatchFilters"]?.map(x => fromPatchFilter(x)),
  }
}
function toPatchFilterGroup(root: jsonP.JSONValue): s.PatchFilterGroup {
  return jsonP.readObj({
    required: {
      "PatchFilters": [toPatchFilter],
    },
    optional: {},
  }, root);
}

function fromPatchFilter(input?: s.PatchFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}
function toPatchFilter(root: jsonP.JSONValue): s.PatchFilter {
  return jsonP.readObj({
    required: {
      "Key": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchFilterKey>(x),
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

function fromPatchRuleGroup(input?: s.PatchRuleGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PatchRules: input["PatchRules"]?.map(x => fromPatchRule(x)),
  }
}
function toPatchRuleGroup(root: jsonP.JSONValue): s.PatchRuleGroup {
  return jsonP.readObj({
    required: {
      "PatchRules": [toPatchRule],
    },
    optional: {},
  }, root);
}

function fromPatchRule(input?: s.PatchRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PatchFilterGroup: fromPatchFilterGroup(input["PatchFilterGroup"]),
    ComplianceLevel: input["ComplianceLevel"],
    ApproveAfterDays: input["ApproveAfterDays"],
    ApproveUntilDate: input["ApproveUntilDate"],
    EnableNonSecurity: input["EnableNonSecurity"],
  }
}
function toPatchRule(root: jsonP.JSONValue): s.PatchRule {
  return jsonP.readObj({
    required: {
      "PatchFilterGroup": toPatchFilterGroup,
    },
    optional: {
      "ComplianceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchComplianceLevel>(x),
      "ApproveAfterDays": "n",
      "ApproveUntilDate": "s",
      "EnableNonSecurity": "b",
    },
  }, root);
}

function fromPatchSource(input?: s.PatchSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Products: input["Products"],
    Configuration: input["Configuration"],
  }
}
function toPatchSource(root: jsonP.JSONValue): s.PatchSource {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Products": ["s"],
      "Configuration": "s",
    },
    optional: {},
  }, root);
}

function fromResourceDataSyncS3Destination(input?: s.ResourceDataSyncS3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BucketName: input["BucketName"],
    Prefix: input["Prefix"],
    SyncFormat: input["SyncFormat"],
    Region: input["Region"],
    AWSKMSKeyARN: input["AWSKMSKeyARN"],
    DestinationDataSharing: fromResourceDataSyncDestinationDataSharing(input["DestinationDataSharing"]),
  }
}
function toResourceDataSyncS3Destination(root: jsonP.JSONValue): s.ResourceDataSyncS3Destination {
  return jsonP.readObj({
    required: {
      "BucketName": "s",
      "SyncFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceDataSyncS3Format>(x),
      "Region": "s",
    },
    optional: {
      "Prefix": "s",
      "AWSKMSKeyARN": "s",
      "DestinationDataSharing": toResourceDataSyncDestinationDataSharing,
    },
  }, root);
}

function fromResourceDataSyncDestinationDataSharing(input?: s.ResourceDataSyncDestinationDataSharing | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DestinationDataSharingType: input["DestinationDataSharingType"],
  }
}
function toResourceDataSyncDestinationDataSharing(root: jsonP.JSONValue): s.ResourceDataSyncDestinationDataSharing {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationDataSharingType": "s",
    },
  }, root);
}

function fromResourceDataSyncSource(input?: s.ResourceDataSyncSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceType: input["SourceType"],
    AwsOrganizationsSource: fromResourceDataSyncAwsOrganizationsSource(input["AwsOrganizationsSource"]),
    SourceRegions: input["SourceRegions"],
    IncludeFutureRegions: input["IncludeFutureRegions"],
  }
}

function fromResourceDataSyncAwsOrganizationsSource(input?: s.ResourceDataSyncAwsOrganizationsSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OrganizationSourceType: input["OrganizationSourceType"],
    OrganizationalUnits: input["OrganizationalUnits"]?.map(x => fromResourceDataSyncOrganizationalUnit(x)),
  }
}
function toResourceDataSyncAwsOrganizationsSource(root: jsonP.JSONValue): s.ResourceDataSyncAwsOrganizationsSource {
  return jsonP.readObj({
    required: {
      "OrganizationSourceType": "s",
    },
    optional: {
      "OrganizationalUnits": [toResourceDataSyncOrganizationalUnit],
    },
  }, root);
}

function fromResourceDataSyncOrganizationalUnit(input?: s.ResourceDataSyncOrganizationalUnit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OrganizationalUnitId: input["OrganizationalUnitId"],
  }
}
function toResourceDataSyncOrganizationalUnit(root: jsonP.JSONValue): s.ResourceDataSyncOrganizationalUnit {
  return jsonP.readObj({
    required: {},
    optional: {
      "OrganizationalUnitId": "s",
    },
  }, root);
}

function fromDescribeActivationsFilter(input?: s.DescribeActivationsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FilterKey: input["FilterKey"],
    FilterValues: input["FilterValues"],
  }
}

function fromAssociationExecutionTargetsFilter(input?: s.AssociationExecutionTargetsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}

function fromAssociationExecutionFilter(input?: s.AssociationExecutionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Type: input["Type"],
  }
}

function fromAutomationExecutionFilter(input?: s.AutomationExecutionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromStepExecutionFilter(input?: s.StepExecutionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromPatchOrchestratorFilter(input?: s.PatchOrchestratorFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromInstanceInformationFilter(input?: s.InstanceInformationFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    valueSet: input["valueSet"],
  }
}

function fromInstanceInformationStringFilter(input?: s.InstanceInformationStringFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromInstancePatchStateFilter(input?: s.InstancePatchStateFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Type: input["Type"],
  }
}

function fromMaintenanceWindowFilter(input?: s.MaintenanceWindowFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromOpsItemFilter(input?: s.OpsItemFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Operator: input["Operator"],
  }
}

function fromParametersFilter(input?: s.ParametersFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromParameterStringFilter(input?: s.ParameterStringFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Option: input["Option"],
    Values: input["Values"],
  }
}

function fromSessionFilter(input?: s.SessionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}

function fromInventoryFilter(input?: s.InventoryFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Type: input["Type"],
  }
}

function fromInventoryAggregator(input?: s.InventoryAggregator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Expression: input["Expression"],
    Aggregators: input["Aggregators"]?.map(x => fromInventoryAggregator(x)),
    Groups: input["Groups"]?.map(x => fromInventoryGroup(x)),
  }
}

function fromInventoryGroup(input?: s.InventoryGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Filters: input["Filters"]?.map(x => fromInventoryFilter(x)),
  }
}

function fromResultAttribute(input?: s.ResultAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypeName: input["TypeName"],
  }
}

function fromOpsFilter(input?: s.OpsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Type: input["Type"],
  }
}

function fromOpsAggregator(input?: s.OpsAggregator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AggregatorType: input["AggregatorType"],
    TypeName: input["TypeName"],
    AttributeName: input["AttributeName"],
    Values: input["Values"],
    Filters: input["Filters"]?.map(x => fromOpsFilter(x)),
    Aggregators: input["Aggregators"]?.map(x => fromOpsAggregator(x)),
  }
}

function fromOpsResultAttribute(input?: s.OpsResultAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypeName: input["TypeName"],
  }
}

function fromAssociationFilter(input?: s.AssociationFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}

function fromCommandFilter(input?: s.CommandFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}

function fromComplianceStringFilter(input?: s.ComplianceStringFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Type: input["Type"],
  }
}

function fromDocumentFilter(input?: s.DocumentFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}

function fromDocumentKeyValuesFilter(input?: s.DocumentKeyValuesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromOpsItemEventFilter(input?: s.OpsItemEventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
    Operator: input["Operator"],
  }
}

function fromOpsMetadataFilter(input?: s.OpsMetadataFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Values: input["Values"],
  }
}

function fromComplianceExecutionSummary(input?: s.ComplianceExecutionSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExecutionTime: jsonP.serializeDate_unixTimestamp(input["ExecutionTime"]),
    ExecutionId: input["ExecutionId"],
    ExecutionType: input["ExecutionType"],
  }
}
function toComplianceExecutionSummary(root: jsonP.JSONValue): s.ComplianceExecutionSummary {
  return jsonP.readObj({
    required: {
      "ExecutionTime": "d",
    },
    optional: {
      "ExecutionId": "s",
      "ExecutionType": "s",
    },
  }, root);
}

function fromComplianceItemEntry(input?: s.ComplianceItemEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Title: input["Title"],
    Severity: input["Severity"],
    Status: input["Status"],
    Details: input["Details"],
  }
}

function fromInventoryItem(input?: s.InventoryItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypeName: input["TypeName"],
    SchemaVersion: input["SchemaVersion"],
    CaptureTime: input["CaptureTime"],
    ContentHash: input["ContentHash"],
    Content: input["Content"],
    Context: input["Context"],
  }
}

function fromMaintenanceWindowTaskParameterValueExpression(input?: s.MaintenanceWindowTaskParameterValueExpression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
  }
}
function toMaintenanceWindowTaskParameterValueExpression(root: jsonP.JSONValue): s.MaintenanceWindowTaskParameterValueExpression {
  return jsonP.readObj({
    required: {},
    optional: {
      "Values": ["s"],
    },
  }, root);
}

function fromMaintenanceWindowTaskInvocationParameters(input?: s.MaintenanceWindowTaskInvocationParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RunCommand: fromMaintenanceWindowRunCommandParameters(input["RunCommand"]),
    Automation: fromMaintenanceWindowAutomationParameters(input["Automation"]),
    StepFunctions: fromMaintenanceWindowStepFunctionsParameters(input["StepFunctions"]),
    Lambda: fromMaintenanceWindowLambdaParameters(input["Lambda"]),
  }
}
function toMaintenanceWindowTaskInvocationParameters(root: jsonP.JSONValue): s.MaintenanceWindowTaskInvocationParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "RunCommand": toMaintenanceWindowRunCommandParameters,
      "Automation": toMaintenanceWindowAutomationParameters,
      "StepFunctions": toMaintenanceWindowStepFunctionsParameters,
      "Lambda": toMaintenanceWindowLambdaParameters,
    },
  }, root);
}

function fromMaintenanceWindowRunCommandParameters(input?: s.MaintenanceWindowRunCommandParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Comment: input["Comment"],
    CloudWatchOutputConfig: fromCloudWatchOutputConfig(input["CloudWatchOutputConfig"]),
    DocumentHash: input["DocumentHash"],
    DocumentHashType: input["DocumentHashType"],
    DocumentVersion: input["DocumentVersion"],
    NotificationConfig: fromNotificationConfig(input["NotificationConfig"]),
    OutputS3BucketName: input["OutputS3BucketName"],
    OutputS3KeyPrefix: input["OutputS3KeyPrefix"],
    Parameters: input["Parameters"],
    ServiceRoleArn: input["ServiceRoleArn"],
    TimeoutSeconds: input["TimeoutSeconds"],
  }
}
function toMaintenanceWindowRunCommandParameters(root: jsonP.JSONValue): s.MaintenanceWindowRunCommandParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Comment": "s",
      "CloudWatchOutputConfig": toCloudWatchOutputConfig,
      "DocumentHash": "s",
      "DocumentHashType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentHashType>(x),
      "DocumentVersion": "s",
      "NotificationConfig": toNotificationConfig,
      "OutputS3BucketName": "s",
      "OutputS3KeyPrefix": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "ServiceRoleArn": "s",
      "TimeoutSeconds": "n",
    },
  }, root);
}

function fromCloudWatchOutputConfig(input?: s.CloudWatchOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchLogGroupName: input["CloudWatchLogGroupName"],
    CloudWatchOutputEnabled: input["CloudWatchOutputEnabled"],
  }
}
function toCloudWatchOutputConfig(root: jsonP.JSONValue): s.CloudWatchOutputConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogGroupName": "s",
      "CloudWatchOutputEnabled": "b",
    },
  }, root);
}

function fromNotificationConfig(input?: s.NotificationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotificationArn: input["NotificationArn"],
    NotificationEvents: input["NotificationEvents"],
    NotificationType: input["NotificationType"],
  }
}
function toNotificationConfig(root: jsonP.JSONValue): s.NotificationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotificationArn": "s",
      "NotificationEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<s.NotificationEvent>(x)],
      "NotificationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotificationType>(x),
    },
  }, root);
}

function fromMaintenanceWindowAutomationParameters(input?: s.MaintenanceWindowAutomationParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DocumentVersion: input["DocumentVersion"],
    Parameters: input["Parameters"],
  }
}
function toMaintenanceWindowAutomationParameters(root: jsonP.JSONValue): s.MaintenanceWindowAutomationParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "DocumentVersion": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

function fromMaintenanceWindowStepFunctionsParameters(input?: s.MaintenanceWindowStepFunctionsParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Input: input["Input"],
    Name: input["Name"],
  }
}
function toMaintenanceWindowStepFunctionsParameters(root: jsonP.JSONValue): s.MaintenanceWindowStepFunctionsParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Input": "s",
      "Name": "s",
    },
  }, root);
}

function fromMaintenanceWindowLambdaParameters(input?: s.MaintenanceWindowLambdaParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClientContext: input["ClientContext"],
    Qualifier: input["Qualifier"],
    Payload: serializeBlob(input["Payload"]),
  }
}
function toMaintenanceWindowLambdaParameters(root: jsonP.JSONValue): s.MaintenanceWindowLambdaParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientContext": "s",
      "Qualifier": "s",
      "Payload": "a",
    },
  }, root);
}

function fromLoggingInfo(input?: s.LoggingInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3BucketName: input["S3BucketName"],
    S3KeyPrefix: input["S3KeyPrefix"],
    S3Region: input["S3Region"],
  }
}
function toLoggingInfo(root: jsonP.JSONValue): s.LoggingInfo {
  return jsonP.readObj({
    required: {
      "S3BucketName": "s",
      "S3Region": "s",
    },
    optional: {
      "S3KeyPrefix": "s",
    },
  }, root);
}

function fromRunbook(input?: s.Runbook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DocumentName: input["DocumentName"],
    DocumentVersion: input["DocumentVersion"],
    Parameters: input["Parameters"],
    TargetParameterName: input["TargetParameterName"],
    Targets: input["Targets"]?.map(x => fromTarget(x)),
    MaxConcurrency: input["MaxConcurrency"],
    MaxErrors: input["MaxErrors"],
    TargetLocations: input["TargetLocations"]?.map(x => fromTargetLocation(x)),
  }
}
function toRunbook(root: jsonP.JSONValue): s.Runbook {
  return jsonP.readObj({
    required: {
      "DocumentName": "s",
    },
    optional: {
      "DocumentVersion": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "TargetParameterName": "s",
      "Targets": [toTarget],
      "MaxConcurrency": "s",
      "MaxErrors": "s",
      "TargetLocations": [toTargetLocation],
    },
  }, root);
}

function fromAssociationStatus(input?: s.AssociationStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Date: jsonP.serializeDate_unixTimestamp(input["Date"]),
    Name: input["Name"],
    Message: input["Message"],
    AdditionalInfo: input["AdditionalInfo"],
  }
}
function toAssociationStatus(root: jsonP.JSONValue): s.AssociationStatus {
  return jsonP.readObj({
    required: {
      "Date": "d",
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationStatusName>(x),
      "Message": "s",
    },
    optional: {
      "AdditionalInfo": "s",
    },
  }, root);
}

function fromDocumentReviews(input?: s.DocumentReviews | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Comment: input["Comment"]?.map(x => fromDocumentReviewCommentSource(x)),
  }
}

function fromDocumentReviewCommentSource(input?: s.DocumentReviewCommentSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Content: input["Content"],
  }
}
function toDocumentReviewCommentSource(root: jsonP.JSONValue): s.DocumentReviewCommentSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentReviewCommentType>(x),
      "Content": "s",
    },
  }, root);
}

function toAssociationDescription(root: jsonP.JSONValue): s.AssociationDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "InstanceId": "s",
      "AssociationVersion": "s",
      "Date": "d",
      "LastUpdateAssociationDate": "d",
      "Status": toAssociationStatus,
      "Overview": toAssociationOverview,
      "DocumentVersion": "s",
      "AutomationTargetParameterName": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "AssociationId": "s",
      "Targets": [toTarget],
      "ScheduleExpression": "s",
      "OutputLocation": toInstanceAssociationOutputLocation,
      "LastExecutionDate": "d",
      "LastSuccessfulExecutionDate": "d",
      "AssociationName": "s",
      "MaxErrors": "s",
      "MaxConcurrency": "s",
      "ComplianceSeverity": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationComplianceSeverity>(x),
      "SyncCompliance": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationSyncCompliance>(x),
      "ApplyOnlyAtCronInterval": "b",
      "TargetLocations": [toTargetLocation],
    },
  }, root);
}

function toAssociationOverview(root: jsonP.JSONValue): s.AssociationOverview {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": "s",
      "DetailedStatus": "s",
      "AssociationStatusAggregatedCount": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toFailedCreateAssociation(root: jsonP.JSONValue): s.FailedCreateAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Entry": toCreateAssociationBatchRequestEntry,
      "Message": "s",
      "Fault": (x: jsonP.JSONValue) => cmnP.readEnum<s.Fault>(x),
    },
  }, root);
}

function toDocumentDescription(root: jsonP.JSONValue): s.DocumentDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Sha1": "s",
      "Hash": "s",
      "HashType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentHashType>(x),
      "Name": "s",
      "VersionName": "s",
      "Owner": "s",
      "CreatedDate": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentStatus>(x),
      "StatusInformation": "s",
      "DocumentVersion": "s",
      "Description": "s",
      "Parameters": [toDocumentParameter],
      "PlatformTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x)],
      "DocumentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentType>(x),
      "SchemaVersion": "s",
      "LatestVersion": "s",
      "DefaultVersion": "s",
      "DocumentFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentFormat>(x),
      "TargetType": "s",
      "Tags": [toTag],
      "AttachmentsInformation": [toAttachmentInformation],
      "Requires": [toDocumentRequires],
      "Author": "s",
      "ReviewInformation": [toReviewInformation],
      "ApprovedVersion": "s",
      "PendingReviewVersion": "s",
      "ReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
    },
  }, root);
}

function toDocumentParameter(root: jsonP.JSONValue): s.DocumentParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentParameterType>(x),
      "Description": "s",
      "DefaultValue": "s",
    },
  }, root);
}

function toAttachmentInformation(root: jsonP.JSONValue): s.AttachmentInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function toReviewInformation(root: jsonP.JSONValue): s.ReviewInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReviewedTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
      "Reviewer": "s",
    },
  }, root);
}

function toInventoryDeletionSummary(root: jsonP.JSONValue): s.InventoryDeletionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCount": "n",
      "RemainingCount": "n",
      "SummaryItems": [toInventoryDeletionSummaryItem],
    },
  }, root);
}

function toInventoryDeletionSummaryItem(root: jsonP.JSONValue): s.InventoryDeletionSummaryItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "Count": "n",
      "RemainingCount": "n",
    },
  }, root);
}

function toActivation(root: jsonP.JSONValue): s.Activation {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActivationId": "s",
      "Description": "s",
      "DefaultInstanceName": "s",
      "IamRole": "s",
      "RegistrationLimit": "n",
      "RegistrationsCount": "n",
      "ExpirationDate": "d",
      "Expired": "b",
      "CreatedDate": "d",
      "Tags": [toTag],
    },
  }, root);
}

function toAssociationExecutionTarget(root: jsonP.JSONValue): s.AssociationExecutionTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "AssociationVersion": "s",
      "ExecutionId": "s",
      "ResourceId": "s",
      "ResourceType": "s",
      "Status": "s",
      "DetailedStatus": "s",
      "LastExecutionDate": "d",
      "OutputSource": toOutputSource,
    },
  }, root);
}

function toOutputSource(root: jsonP.JSONValue): s.OutputSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputSourceId": "s",
      "OutputSourceType": "s",
    },
  }, root);
}

function toAssociationExecution(root: jsonP.JSONValue): s.AssociationExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "AssociationVersion": "s",
      "ExecutionId": "s",
      "Status": "s",
      "DetailedStatus": "s",
      "CreatedTime": "d",
      "LastExecutionDate": "d",
      "ResourceCountByStatus": "s",
    },
  }, root);
}

function toAutomationExecutionMetadata(root: jsonP.JSONValue): s.AutomationExecutionMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomationExecutionId": "s",
      "DocumentName": "s",
      "DocumentVersion": "s",
      "AutomationExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationExecutionStatus>(x),
      "ExecutionStartTime": "d",
      "ExecutionEndTime": "d",
      "ExecutedBy": "s",
      "LogFile": "s",
      "Outputs": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionMode>(x),
      "ParentAutomationExecutionId": "s",
      "CurrentStepName": "s",
      "CurrentAction": "s",
      "FailureMessage": "s",
      "TargetParameterName": "s",
      "Targets": [toTarget],
      "TargetMaps": [x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x)],
      "ResolvedTargets": toResolvedTargets,
      "MaxConcurrency": "s",
      "MaxErrors": "s",
      "Target": "s",
      "AutomationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationType>(x),
      "AutomationSubtype": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationSubtype>(x),
      "ScheduledTime": "d",
      "Runbooks": [toRunbook],
      "OpsItemId": "s",
      "AssociationId": "s",
      "ChangeRequestName": "s",
    },
  }, root);
}

function toResolvedTargets(root: jsonP.JSONValue): s.ResolvedTargets {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterValues": ["s"],
      "Truncated": "b",
    },
  }, root);
}

function toStepExecution(root: jsonP.JSONValue): s.StepExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepName": "s",
      "Action": "s",
      "TimeoutSeconds": "n",
      "OnFailure": "s",
      "MaxAttempts": "n",
      "ExecutionStartTime": "d",
      "ExecutionEndTime": "d",
      "StepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationExecutionStatus>(x),
      "ResponseCode": "s",
      "Inputs": x => jsonP.readMap(String, String, x),
      "Outputs": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "Response": "s",
      "FailureMessage": "s",
      "FailureDetails": toFailureDetails,
      "StepExecutionId": "s",
      "OverriddenParameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "IsEnd": "b",
      "NextStep": "s",
      "IsCritical": "b",
      "ValidNextSteps": ["s"],
      "Targets": [toTarget],
      "TargetLocation": toTargetLocation,
    },
  }, root);
}

function toFailureDetails(root: jsonP.JSONValue): s.FailureDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "FailureStage": "s",
      "FailureType": "s",
      "Details": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

function toPatch(root: jsonP.JSONValue): s.Patch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "ReleaseDate": "d",
      "Title": "s",
      "Description": "s",
      "ContentUrl": "s",
      "Vendor": "s",
      "ProductFamily": "s",
      "Product": "s",
      "Classification": "s",
      "MsrcSeverity": "s",
      "KbNumber": "s",
      "MsrcNumber": "s",
      "Language": "s",
      "AdvisoryIds": ["s"],
      "BugzillaIds": ["s"],
      "CVEIds": ["s"],
      "Name": "s",
      "Epoch": "n",
      "Version": "s",
      "Release": "s",
      "Arch": "s",
      "Severity": "s",
      "Repository": "s",
    },
  }, root);
}

function toAccountSharingInfo(root: jsonP.JSONValue): s.AccountSharingInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "SharedDocumentVersion": "s",
    },
  }, root);
}

function toInstanceAssociation(root: jsonP.JSONValue): s.InstanceAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "InstanceId": "s",
      "Content": "s",
      "AssociationVersion": "s",
    },
  }, root);
}

function toEffectivePatch(root: jsonP.JSONValue): s.EffectivePatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Patch": toPatch,
      "PatchStatus": toPatchStatus,
    },
  }, root);
}

function toPatchStatus(root: jsonP.JSONValue): s.PatchStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchDeploymentStatus>(x),
      "ComplianceLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchComplianceLevel>(x),
      "ApprovalDate": "d",
    },
  }, root);
}

function toInstanceAssociationStatusInfo(root: jsonP.JSONValue): s.InstanceAssociationStatusInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "Name": "s",
      "DocumentVersion": "s",
      "AssociationVersion": "s",
      "InstanceId": "s",
      "ExecutionDate": "d",
      "Status": "s",
      "DetailedStatus": "s",
      "ExecutionSummary": "s",
      "ErrorCode": "s",
      "OutputUrl": toInstanceAssociationOutputUrl,
      "AssociationName": "s",
    },
  }, root);
}

function toInstanceAssociationOutputUrl(root: jsonP.JSONValue): s.InstanceAssociationOutputUrl {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3OutputUrl": toS3OutputUrl,
    },
  }, root);
}

function toS3OutputUrl(root: jsonP.JSONValue): s.S3OutputUrl {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputUrl": "s",
    },
  }, root);
}

function toInstanceInformation(root: jsonP.JSONValue): s.InstanceInformation {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceId": "s",
      "PingStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PingStatus>(x),
      "LastPingDateTime": "d",
      "AgentVersion": "s",
      "IsLatestVersion": "b",
      "PlatformType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x),
      "PlatformName": "s",
      "PlatformVersion": "s",
      "ActivationId": "s",
      "IamRole": "s",
      "RegistrationDate": "d",
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "Name": "s",
      "IPAddress": "s",
      "ComputerName": "s",
      "AssociationStatus": "s",
      "LastAssociationExecutionDate": "d",
      "LastSuccessfulAssociationExecutionDate": "d",
      "AssociationOverview": toInstanceAggregatedAssociationOverview,
    },
  }, root);
}

function toInstanceAggregatedAssociationOverview(root: jsonP.JSONValue): s.InstanceAggregatedAssociationOverview {
  return jsonP.readObj({
    required: {},
    optional: {
      "DetailedStatus": "s",
      "InstanceAssociationStatusAggregatedCount": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toInstancePatchState(root: jsonP.JSONValue): s.InstancePatchState {
  return jsonP.readObj({
    required: {
      "InstanceId": "s",
      "PatchGroup": "s",
      "BaselineId": "s",
      "OperationStartTime": "d",
      "OperationEndTime": "d",
      "Operation": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchOperationType>(x),
    },
    optional: {
      "SnapshotId": "s",
      "InstallOverrideList": "s",
      "OwnerInformation": "s",
      "InstalledCount": "n",
      "InstalledOtherCount": "n",
      "InstalledPendingRebootCount": "n",
      "InstalledRejectedCount": "n",
      "MissingCount": "n",
      "FailedCount": "n",
      "UnreportedNotApplicableCount": "n",
      "NotApplicableCount": "n",
      "LastNoRebootInstallOperationTime": "d",
      "RebootOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.RebootOption>(x),
    },
  }, root);
}

function toPatchComplianceData(root: jsonP.JSONValue): s.PatchComplianceData {
  return jsonP.readObj({
    required: {
      "Title": "s",
      "KBId": "s",
      "Classification": "s",
      "Severity": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.PatchComplianceDataState>(x),
      "InstalledTime": "d",
    },
    optional: {
      "CVEIds": "s",
    },
  }, root);
}

function toInventoryDeletionStatusItem(root: jsonP.JSONValue): s.InventoryDeletionStatusItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeletionId": "s",
      "TypeName": "s",
      "DeletionStartTime": "d",
      "LastStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.InventoryDeletionStatus>(x),
      "LastStatusMessage": "s",
      "DeletionSummary": toInventoryDeletionSummary,
      "LastStatusUpdateTime": "d",
    },
  }, root);
}

function toMaintenanceWindowExecutionTaskInvocationIdentity(root: jsonP.JSONValue): s.MaintenanceWindowExecutionTaskInvocationIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowExecutionId": "s",
      "TaskExecutionId": "s",
      "InvocationId": "s",
      "ExecutionId": "s",
      "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
      "Parameters": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
      "StatusDetails": "s",
      "StartTime": "d",
      "EndTime": "d",
      "OwnerInformation": "s",
      "WindowTargetId": "s",
    },
  }, root);
}

function toMaintenanceWindowExecutionTaskIdentity(root: jsonP.JSONValue): s.MaintenanceWindowExecutionTaskIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowExecutionId": "s",
      "TaskExecutionId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
      "StatusDetails": "s",
      "StartTime": "d",
      "EndTime": "d",
      "TaskArn": "s",
      "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
    },
  }, root);
}

function toMaintenanceWindowExecution(root: jsonP.JSONValue): s.MaintenanceWindowExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "WindowExecutionId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowExecutionStatus>(x),
      "StatusDetails": "s",
      "StartTime": "d",
      "EndTime": "d",
    },
  }, root);
}

function toScheduledWindowExecution(root: jsonP.JSONValue): s.ScheduledWindowExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "Name": "s",
      "ExecutionTime": "s",
    },
  }, root);
}

function toMaintenanceWindowTarget(root: jsonP.JSONValue): s.MaintenanceWindowTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "WindowTargetId": "s",
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowResourceType>(x),
      "Targets": [toTarget],
      "OwnerInformation": "s",
      "Name": "s",
      "Description": "s",
    },
  }, root);
}

function toMaintenanceWindowTask(root: jsonP.JSONValue): s.MaintenanceWindowTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "WindowTaskId": "s",
      "TaskArn": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MaintenanceWindowTaskType>(x),
      "Targets": [toTarget],
      "TaskParameters": x => jsonP.readMap(String, toMaintenanceWindowTaskParameterValueExpression, x),
      "Priority": "n",
      "LoggingInfo": toLoggingInfo,
      "ServiceRoleArn": "s",
      "MaxConcurrency": "s",
      "MaxErrors": "s",
      "Name": "s",
      "Description": "s",
    },
  }, root);
}

function toMaintenanceWindowIdentity(root: jsonP.JSONValue): s.MaintenanceWindowIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "Name": "s",
      "Description": "s",
      "Enabled": "b",
      "Duration": "n",
      "Cutoff": "n",
      "Schedule": "s",
      "ScheduleTimezone": "s",
      "ScheduleOffset": "n",
      "EndDate": "s",
      "StartDate": "s",
      "NextExecutionTime": "s",
    },
  }, root);
}

function toMaintenanceWindowIdentityForTarget(root: jsonP.JSONValue): s.MaintenanceWindowIdentityForTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "WindowId": "s",
      "Name": "s",
    },
  }, root);
}

function toOpsItemSummary(root: jsonP.JSONValue): s.OpsItemSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedBy": "s",
      "CreatedTime": "d",
      "LastModifiedBy": "s",
      "LastModifiedTime": "d",
      "Priority": "n",
      "Source": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.OpsItemStatus>(x),
      "OpsItemId": "s",
      "Title": "s",
      "OperationalData": x => jsonP.readMap(String, toOpsItemDataValue, x),
      "Category": "s",
      "Severity": "s",
      "OpsItemType": "s",
      "ActualStartTime": "d",
      "ActualEndTime": "d",
      "PlannedStartTime": "d",
      "PlannedEndTime": "d",
    },
  }, root);
}

function toParameterMetadata(root: jsonP.JSONValue): s.ParameterMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterType>(x),
      "KeyId": "s",
      "LastModifiedDate": "d",
      "LastModifiedUser": "s",
      "Description": "s",
      "AllowedPattern": "s",
      "Version": "n",
      "Tier": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterTier>(x),
      "Policies": [toParameterInlinePolicy],
      "DataType": "s",
    },
  }, root);
}

function toParameterInlinePolicy(root: jsonP.JSONValue): s.ParameterInlinePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyText": "s",
      "PolicyType": "s",
      "PolicyStatus": "s",
    },
  }, root);
}

function toPatchBaselineIdentity(root: jsonP.JSONValue): s.PatchBaselineIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaselineId": "s",
      "BaselineName": "s",
      "OperatingSystem": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperatingSystem>(x),
      "BaselineDescription": "s",
      "DefaultBaseline": "b",
    },
  }, root);
}

function toPatchGroupPatchBaselineMapping(root: jsonP.JSONValue): s.PatchGroupPatchBaselineMapping {
  return jsonP.readObj({
    required: {},
    optional: {
      "PatchGroup": "s",
      "BaselineIdentity": toPatchBaselineIdentity,
    },
  }, root);
}

function toSession(root: jsonP.JSONValue): s.Session {
  return jsonP.readObj({
    required: {},
    optional: {
      "SessionId": "s",
      "Target": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SessionStatus>(x),
      "StartDate": "d",
      "EndDate": "d",
      "DocumentName": "s",
      "Owner": "s",
      "Details": "s",
      "OutputUrl": toSessionManagerOutputUrl,
    },
  }, root);
}

function toSessionManagerOutputUrl(root: jsonP.JSONValue): s.SessionManagerOutputUrl {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3OutputUrl": "s",
      "CloudWatchOutputUrl": "s",
    },
  }, root);
}

function toAutomationExecution(root: jsonP.JSONValue): s.AutomationExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomationExecutionId": "s",
      "DocumentName": "s",
      "DocumentVersion": "s",
      "ExecutionStartTime": "d",
      "ExecutionEndTime": "d",
      "AutomationExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationExecutionStatus>(x),
      "StepExecutions": [toStepExecution],
      "StepExecutionsTruncated": "b",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "Outputs": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "FailureMessage": "s",
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionMode>(x),
      "ParentAutomationExecutionId": "s",
      "ExecutedBy": "s",
      "CurrentStepName": "s",
      "CurrentAction": "s",
      "TargetParameterName": "s",
      "Targets": [toTarget],
      "TargetMaps": [x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x)],
      "ResolvedTargets": toResolvedTargets,
      "MaxConcurrency": "s",
      "MaxErrors": "s",
      "Target": "s",
      "TargetLocations": [toTargetLocation],
      "ProgressCounters": toProgressCounters,
      "AutomationSubtype": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutomationSubtype>(x),
      "ScheduledTime": "d",
      "Runbooks": [toRunbook],
      "OpsItemId": "s",
      "AssociationId": "s",
      "ChangeRequestName": "s",
    },
  }, root);
}

function toProgressCounters(root: jsonP.JSONValue): s.ProgressCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalSteps": "n",
      "SuccessSteps": "n",
      "FailedSteps": "n",
      "CancelledSteps": "n",
      "TimedOutSteps": "n",
    },
  }, root);
}

function toAttachmentContent(root: jsonP.JSONValue): s.AttachmentContent {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Size": "n",
      "Hash": "s",
      "HashType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AttachmentHashType>(x),
      "Url": "s",
    },
  }, root);
}

function toInventoryResultEntity(root: jsonP.JSONValue): s.InventoryResultEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Data": x => jsonP.readMap(String, toInventoryResultItem, x),
    },
  }, root);
}

function toInventoryResultItem(root: jsonP.JSONValue): s.InventoryResultItem {
  return jsonP.readObj({
    required: {
      "TypeName": "s",
      "SchemaVersion": "s",
      "Content": [x => jsonP.readMap(String, String, x)],
    },
    optional: {
      "CaptureTime": "s",
      "ContentHash": "s",
    },
  }, root);
}

function toInventoryItemSchema(root: jsonP.JSONValue): s.InventoryItemSchema {
  return jsonP.readObj({
    required: {
      "TypeName": "s",
      "Attributes": [toInventoryItemAttribute],
    },
    optional: {
      "Version": "s",
      "DisplayName": "s",
    },
  }, root);
}

function toInventoryItemAttribute(root: jsonP.JSONValue): s.InventoryItemAttribute {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "DataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InventoryAttributeDataType>(x),
    },
    optional: {},
  }, root);
}

function toOpsItem(root: jsonP.JSONValue): s.OpsItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedBy": "s",
      "OpsItemType": "s",
      "CreatedTime": "d",
      "Description": "s",
      "LastModifiedBy": "s",
      "LastModifiedTime": "d",
      "Notifications": [toOpsItemNotification],
      "Priority": "n",
      "RelatedOpsItems": [toRelatedOpsItem],
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.OpsItemStatus>(x),
      "OpsItemId": "s",
      "Version": "s",
      "Title": "s",
      "Source": "s",
      "OperationalData": x => jsonP.readMap(String, toOpsItemDataValue, x),
      "Category": "s",
      "Severity": "s",
      "ActualStartTime": "d",
      "ActualEndTime": "d",
      "PlannedStartTime": "d",
      "PlannedEndTime": "d",
    },
  }, root);
}

function toOpsEntity(root: jsonP.JSONValue): s.OpsEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Data": x => jsonP.readMap(String, toOpsEntityItem, x),
    },
  }, root);
}

function toOpsEntityItem(root: jsonP.JSONValue): s.OpsEntityItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptureTime": "s",
      "Content": [x => jsonP.readMap(String, String, x)],
    },
  }, root);
}

function toParameter(root: jsonP.JSONValue): s.Parameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterType>(x),
      "Value": "s",
      "Version": "n",
      "Selector": "s",
      "SourceResult": "s",
      "LastModifiedDate": "d",
      "ARN": "s",
      "DataType": "s",
    },
  }, root);
}

function toParameterHistory(root: jsonP.JSONValue): s.ParameterHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterType>(x),
      "KeyId": "s",
      "LastModifiedDate": "d",
      "LastModifiedUser": "s",
      "Description": "s",
      "Value": "s",
      "AllowedPattern": "s",
      "Version": "n",
      "Labels": ["s"],
      "Tier": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterTier>(x),
      "Policies": [toParameterInlinePolicy],
      "DataType": "s",
    },
  }, root);
}

function toServiceSetting(root: jsonP.JSONValue): s.ServiceSetting {
  return jsonP.readObj({
    required: {},
    optional: {
      "SettingId": "s",
      "SettingValue": "s",
      "LastModifiedDate": "d",
      "LastModifiedUser": "s",
      "ARN": "s",
      "Status": "s",
    },
  }, root);
}

function toAssociationVersionInfo(root: jsonP.JSONValue): s.AssociationVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "AssociationVersion": "s",
      "CreatedDate": "d",
      "Name": "s",
      "DocumentVersion": "s",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "Targets": [toTarget],
      "ScheduleExpression": "s",
      "OutputLocation": toInstanceAssociationOutputLocation,
      "AssociationName": "s",
      "MaxErrors": "s",
      "MaxConcurrency": "s",
      "ComplianceSeverity": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationComplianceSeverity>(x),
      "SyncCompliance": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationSyncCompliance>(x),
      "ApplyOnlyAtCronInterval": "b",
      "TargetLocations": [toTargetLocation],
    },
  }, root);
}

function toAssociation(root: jsonP.JSONValue): s.Association {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "InstanceId": "s",
      "AssociationId": "s",
      "AssociationVersion": "s",
      "DocumentVersion": "s",
      "Targets": [toTarget],
      "LastExecutionDate": "d",
      "Overview": toAssociationOverview,
      "ScheduleExpression": "s",
      "AssociationName": "s",
    },
  }, root);
}

function toCommandInvocation(root: jsonP.JSONValue): s.CommandInvocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommandId": "s",
      "InstanceId": "s",
      "InstanceName": "s",
      "Comment": "s",
      "DocumentName": "s",
      "DocumentVersion": "s",
      "RequestedDateTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommandInvocationStatus>(x),
      "StatusDetails": "s",
      "TraceOutput": "s",
      "StandardOutputUrl": "s",
      "StandardErrorUrl": "s",
      "CommandPlugins": [toCommandPlugin],
      "ServiceRole": "s",
      "NotificationConfig": toNotificationConfig,
      "CloudWatchOutputConfig": toCloudWatchOutputConfig,
    },
  }, root);
}

function toCommandPlugin(root: jsonP.JSONValue): s.CommandPlugin {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommandPluginStatus>(x),
      "StatusDetails": "s",
      "ResponseCode": "n",
      "ResponseStartDateTime": "d",
      "ResponseFinishDateTime": "d",
      "Output": "s",
      "StandardOutputUrl": "s",
      "StandardErrorUrl": "s",
      "OutputS3Region": "s",
      "OutputS3BucketName": "s",
      "OutputS3KeyPrefix": "s",
    },
  }, root);
}

function toCommand(root: jsonP.JSONValue): s.Command {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommandId": "s",
      "DocumentName": "s",
      "DocumentVersion": "s",
      "Comment": "s",
      "ExpiresAfter": "d",
      "Parameters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "InstanceIds": ["s"],
      "Targets": [toTarget],
      "RequestedDateTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CommandStatus>(x),
      "StatusDetails": "s",
      "OutputS3Region": "s",
      "OutputS3BucketName": "s",
      "OutputS3KeyPrefix": "s",
      "MaxConcurrency": "s",
      "MaxErrors": "s",
      "TargetCount": "n",
      "CompletedCount": "n",
      "ErrorCount": "n",
      "DeliveryTimedOutCount": "n",
      "ServiceRole": "s",
      "NotificationConfig": toNotificationConfig,
      "CloudWatchOutputConfig": toCloudWatchOutputConfig,
      "TimeoutSeconds": "n",
    },
  }, root);
}

function toComplianceItem(root: jsonP.JSONValue): s.ComplianceItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComplianceType": "s",
      "ResourceType": "s",
      "ResourceId": "s",
      "Id": "s",
      "Title": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComplianceStatus>(x),
      "Severity": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComplianceSeverity>(x),
      "ExecutionSummary": toComplianceExecutionSummary,
      "Details": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toComplianceSummaryItem(root: jsonP.JSONValue): s.ComplianceSummaryItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComplianceType": "s",
      "CompliantSummary": toCompliantSummary,
      "NonCompliantSummary": toNonCompliantSummary,
    },
  }, root);
}

function toCompliantSummary(root: jsonP.JSONValue): s.CompliantSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "CompliantCount": "n",
      "SeveritySummary": toSeveritySummary,
    },
  }, root);
}

function toSeveritySummary(root: jsonP.JSONValue): s.SeveritySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "CriticalCount": "n",
      "HighCount": "n",
      "MediumCount": "n",
      "LowCount": "n",
      "InformationalCount": "n",
      "UnspecifiedCount": "n",
    },
  }, root);
}

function toNonCompliantSummary(root: jsonP.JSONValue): s.NonCompliantSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "NonCompliantCount": "n",
      "SeveritySummary": toSeveritySummary,
    },
  }, root);
}

function toDocumentMetadataResponseInfo(root: jsonP.JSONValue): s.DocumentMetadataResponseInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReviewerResponse": [toDocumentReviewerResponseSource],
    },
  }, root);
}

function toDocumentReviewerResponseSource(root: jsonP.JSONValue): s.DocumentReviewerResponseSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreateTime": "d",
      "UpdatedTime": "d",
      "ReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
      "Comment": [toDocumentReviewCommentSource],
      "Reviewer": "s",
    },
  }, root);
}

function toDocumentVersionInfo(root: jsonP.JSONValue): s.DocumentVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DocumentVersion": "s",
      "VersionName": "s",
      "CreatedDate": "d",
      "IsDefaultVersion": "b",
      "DocumentFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentFormat>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentStatus>(x),
      "StatusInformation": "s",
      "ReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
    },
  }, root);
}

function toDocumentIdentifier(root: jsonP.JSONValue): s.DocumentIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Owner": "s",
      "VersionName": "s",
      "PlatformTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x)],
      "DocumentVersion": "s",
      "DocumentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentType>(x),
      "SchemaVersion": "s",
      "DocumentFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DocumentFormat>(x),
      "TargetType": "s",
      "Tags": [toTag],
      "Requires": [toDocumentRequires],
      "ReviewStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReviewStatus>(x),
      "Author": "s",
    },
  }, root);
}

function toOpsItemEventSummary(root: jsonP.JSONValue): s.OpsItemEventSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "OpsItemId": "s",
      "EventId": "s",
      "Source": "s",
      "DetailType": "s",
      "Detail": "s",
      "CreatedBy": toOpsItemIdentity,
      "CreatedTime": "d",
    },
  }, root);
}

function toOpsItemIdentity(root: jsonP.JSONValue): s.OpsItemIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toOpsMetadata(root: jsonP.JSONValue): s.OpsMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceId": "s",
      "OpsMetadataArn": "s",
      "LastModifiedDate": "d",
      "LastModifiedUser": "s",
      "CreationDate": "d",
    },
  }, root);
}

function toResourceComplianceSummaryItem(root: jsonP.JSONValue): s.ResourceComplianceSummaryItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComplianceType": "s",
      "ResourceType": "s",
      "ResourceId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComplianceStatus>(x),
      "OverallSeverity": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComplianceSeverity>(x),
      "ExecutionSummary": toComplianceExecutionSummary,
      "CompliantSummary": toCompliantSummary,
      "NonCompliantSummary": toNonCompliantSummary,
    },
  }, root);
}

function toResourceDataSyncItem(root: jsonP.JSONValue): s.ResourceDataSyncItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "SyncName": "s",
      "SyncType": "s",
      "SyncSource": toResourceDataSyncSourceWithState,
      "S3Destination": toResourceDataSyncS3Destination,
      "LastSyncTime": "d",
      "LastSuccessfulSyncTime": "d",
      "SyncLastModifiedTime": "d",
      "LastStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastResourceDataSyncStatus>(x),
      "SyncCreatedTime": "d",
      "LastSyncStatusMessage": "s",
    },
  }, root);
}

function toResourceDataSyncSourceWithState(root: jsonP.JSONValue): s.ResourceDataSyncSourceWithState {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceType": "s",
      "AwsOrganizationsSource": toResourceDataSyncAwsOrganizationsSource,
      "SourceRegions": ["s"],
      "IncludeFutureRegions": "b",
      "State": "s",
    },
  }, root);
}

function toDocumentDefaultVersionDescription(root: jsonP.JSONValue): s.DocumentDefaultVersionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DefaultVersion": "s",
      "DefaultVersionName": "s",
    },
  }, root);
}
