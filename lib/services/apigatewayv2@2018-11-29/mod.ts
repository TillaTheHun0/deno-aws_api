// Autogenerated API client for: AmazonApiGatewayV2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ApiGatewayV2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ApiGatewayV2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-11-29",
    "endpointPrefix": "apigateway",
    "signingName": "apigateway",
    "serviceFullName": "AmazonApiGatewayV2",
    "serviceId": "ApiGatewayV2",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "apigatewayv2-2018-11-29",
    "signatureVersion": "v4"
  };

  async createApi(
    {abortSignal, ...params}: RequestConfig & s.CreateApiRequest,
  ): Promise<s.CreateApiResponse> {
    const body: jsonP.JSONObject = {
      apiKeySelectionExpression: params["ApiKeySelectionExpression"],
      corsConfiguration: fromCors(params["CorsConfiguration"]),
      credentialsArn: params["CredentialsArn"],
      description: params["Description"],
      disableSchemaValidation: params["DisableSchemaValidation"],
      disableExecuteApiEndpoint: params["DisableExecuteApiEndpoint"],
      name: params["Name"],
      protocolType: params["ProtocolType"],
      routeKey: params["RouteKey"],
      routeSelectionExpression: params["RouteSelectionExpression"],
      tags: params["Tags"],
      target: params["Target"],
      version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApi",
      requestUri: "/v2/apis",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiEndpoint": "s",
        "ApiGatewayManaged": "b",
        "ApiId": "s",
        "ApiKeySelectionExpression": "s",
        "CorsConfiguration": toCors,
        "CreatedDate": "d",
        "Description": "s",
        "DisableSchemaValidation": "b",
        "DisableExecuteApiEndpoint": "b",
        "ImportInfo": ["s"],
        "Name": "s",
        "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
        "RouteSelectionExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Version": "s",
        "Warnings": ["s"],
      },
    }, await resp.json());
  }

  async createApiMapping(
    {abortSignal, ...params}: RequestConfig & s.CreateApiMappingRequest,
  ): Promise<s.CreateApiMappingResponse> {
    const body: jsonP.JSONObject = {
      apiId: params["ApiId"],
      apiMappingKey: params["ApiMappingKey"],
      stage: params["Stage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApiMapping",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}/apimappings`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiId": "s",
        "ApiMappingId": "s",
        "ApiMappingKey": "s",
        "Stage": "s",
      },
    }, await resp.json());
  }

  async createAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.CreateAuthorizerRequest,
  ): Promise<s.CreateAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      authorizerCredentialsArn: params["AuthorizerCredentialsArn"],
      authorizerPayloadFormatVersion: params["AuthorizerPayloadFormatVersion"],
      authorizerResultTtlInSeconds: params["AuthorizerResultTtlInSeconds"],
      authorizerType: params["AuthorizerType"],
      authorizerUri: params["AuthorizerUri"],
      enableSimpleResponses: params["EnableSimpleResponses"],
      identitySource: params["IdentitySource"],
      identityValidationExpression: params["IdentityValidationExpression"],
      jwtConfiguration: fromJWTConfiguration(params["JwtConfiguration"]),
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAuthorizer",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/authorizers`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizerCredentialsArn": "s",
        "AuthorizerId": "s",
        "AuthorizerPayloadFormatVersion": "s",
        "AuthorizerResultTtlInSeconds": "n",
        "AuthorizerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "AuthorizerUri": "s",
        "EnableSimpleResponses": "b",
        "IdentitySource": ["s"],
        "IdentityValidationExpression": "s",
        "JwtConfiguration": toJWTConfiguration,
        "Name": "s",
      },
    }, await resp.json());
  }

  async createDeployment(
    {abortSignal, ...params}: RequestConfig & s.CreateDeploymentRequest,
  ): Promise<s.CreateDeploymentResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
      stageName: params["StageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeployment",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/deployments`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutoDeployed": "b",
        "CreatedDate": "d",
        "DeploymentId": "s",
        "DeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "DeploymentStatusMessage": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async createDomainName(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainNameRequest,
  ): Promise<s.CreateDomainNameResponse> {
    const body: jsonP.JSONObject = {
      domainName: params["DomainName"],
      domainNameConfigurations: params["DomainNameConfigurations"]?.map(x => fromDomainNameConfiguration(x)),
      mutualTlsAuthentication: fromMutualTlsAuthenticationInput(params["MutualTlsAuthentication"]),
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomainName",
      requestUri: "/v2/domainnames",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiMappingSelectionExpression": "s",
        "DomainName": "s",
        "DomainNameConfigurations": [toDomainNameConfiguration],
        "MutualTlsAuthentication": toMutualTlsAuthentication,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createIntegration(
    {abortSignal, ...params}: RequestConfig & s.CreateIntegrationRequest,
  ): Promise<s.CreateIntegrationResult> {
    const body: jsonP.JSONObject = {
      connectionId: params["ConnectionId"],
      connectionType: params["ConnectionType"],
      contentHandlingStrategy: params["ContentHandlingStrategy"],
      credentialsArn: params["CredentialsArn"],
      description: params["Description"],
      integrationMethod: params["IntegrationMethod"],
      integrationSubtype: params["IntegrationSubtype"],
      integrationType: params["IntegrationType"],
      integrationUri: params["IntegrationUri"],
      passthroughBehavior: params["PassthroughBehavior"],
      payloadFormatVersion: params["PayloadFormatVersion"],
      requestParameters: params["RequestParameters"],
      requestTemplates: params["RequestTemplates"],
      responseParameters: params["ResponseParameters"],
      templateSelectionExpression: params["TemplateSelectionExpression"],
      timeoutInMillis: params["TimeoutInMillis"],
      tlsConfig: fromTlsConfigInput(params["TlsConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIntegration",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ConnectionId": "s",
        "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "CredentialsArn": "s",
        "Description": "s",
        "IntegrationId": "s",
        "IntegrationMethod": "s",
        "IntegrationResponseSelectionExpression": "s",
        "IntegrationSubtype": "s",
        "IntegrationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "IntegrationUri": "s",
        "PassthroughBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.PassthroughBehavior>(x),
        "PayloadFormatVersion": "s",
        "RequestParameters": x => jsonP.readMap(String, String, x),
        "RequestTemplates": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, y => jsonP.readMap(String, String, y)!, x),
        "TemplateSelectionExpression": "s",
        "TimeoutInMillis": "n",
        "TlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async createIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.CreateIntegrationResponseRequest,
  ): Promise<s.CreateIntegrationResponseResponse> {
    const body: jsonP.JSONObject = {
      contentHandlingStrategy: params["ContentHandlingStrategy"],
      integrationResponseKey: params["IntegrationResponseKey"],
      responseParameters: params["ResponseParameters"],
      responseTemplates: params["ResponseTemplates"],
      templateSelectionExpression: params["TemplateSelectionExpression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIntegrationResponse",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}/integrationresponses`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "IntegrationResponseId": "s",
        "IntegrationResponseKey": "s",
        "ResponseParameters": x => jsonP.readMap(String, String, x),
        "ResponseTemplates": x => jsonP.readMap(String, String, x),
        "TemplateSelectionExpression": "s",
      },
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & s.CreateModelRequest,
  ): Promise<s.CreateModelResponse> {
    const body: jsonP.JSONObject = {
      contentType: params["ContentType"],
      description: params["Description"],
      name: params["Name"],
      schema: params["Schema"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentType": "s",
        "Description": "s",
        "ModelId": "s",
        "Name": "s",
        "Schema": "s",
      },
    }, await resp.json());
  }

  async createRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateRouteRequest,
  ): Promise<s.CreateRouteResult> {
    const body: jsonP.JSONObject = {
      apiKeyRequired: params["ApiKeyRequired"],
      authorizationScopes: params["AuthorizationScopes"],
      authorizationType: params["AuthorizationType"],
      authorizerId: params["AuthorizerId"],
      modelSelectionExpression: params["ModelSelectionExpression"],
      operationName: params["OperationName"],
      requestModels: params["RequestModels"],
      requestParameters: jsonP.serializeMap(params["RequestParameters"], x => fromParameterConstraints(x)),
      routeKey: params["RouteKey"],
      routeResponseSelectionExpression: params["RouteResponseSelectionExpression"],
      target: params["Target"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRoute",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ApiKeyRequired": "b",
        "AuthorizationScopes": ["s"],
        "AuthorizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizationType>(x),
        "AuthorizerId": "s",
        "ModelSelectionExpression": "s",
        "OperationName": "s",
        "RequestModels": x => jsonP.readMap(String, String, x),
        "RequestParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteId": "s",
        "RouteKey": "s",
        "RouteResponseSelectionExpression": "s",
        "Target": "s",
      },
    }, await resp.json());
  }

  async createRouteResponse(
    {abortSignal, ...params}: RequestConfig & s.CreateRouteResponseRequest,
  ): Promise<s.CreateRouteResponseResponse> {
    const body: jsonP.JSONObject = {
      modelSelectionExpression: params["ModelSelectionExpression"],
      responseModels: params["ResponseModels"],
      responseParameters: jsonP.serializeMap(params["ResponseParameters"], x => fromParameterConstraints(x)),
      routeResponseKey: params["RouteResponseKey"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRouteResponse",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/routeresponses`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelSelectionExpression": "s",
        "ResponseModels": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteResponseId": "s",
        "RouteResponseKey": "s",
      },
    }, await resp.json());
  }

  async createStage(
    {abortSignal, ...params}: RequestConfig & s.CreateStageRequest,
  ): Promise<s.CreateStageResponse> {
    const body: jsonP.JSONObject = {
      accessLogSettings: fromAccessLogSettings(params["AccessLogSettings"]),
      autoDeploy: params["AutoDeploy"],
      clientCertificateId: params["ClientCertificateId"],
      defaultRouteSettings: fromRouteSettings(params["DefaultRouteSettings"]),
      deploymentId: params["DeploymentId"],
      description: params["Description"],
      routeSettings: jsonP.serializeMap(params["RouteSettings"], x => fromRouteSettings(x)),
      stageName: params["StageName"],
      stageVariables: params["StageVariables"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStage",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccessLogSettings": toAccessLogSettings,
        "ApiGatewayManaged": "b",
        "AutoDeploy": "b",
        "ClientCertificateId": "s",
        "CreatedDate": "d",
        "DefaultRouteSettings": toRouteSettings,
        "DeploymentId": "s",
        "Description": "s",
        "LastDeploymentStatusMessage": "s",
        "LastUpdatedDate": "d",
        "RouteSettings": x => jsonP.readMap(String, toRouteSettings, x),
        "StageName": "s",
        "StageVariables": x => jsonP.readMap(String, String, x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createVpcLink(
    {abortSignal, ...params}: RequestConfig & s.CreateVpcLinkRequest,
  ): Promise<s.CreateVpcLinkResponse> {
    const body: jsonP.JSONObject = {
      name: params["Name"],
      securityGroupIds: params["SecurityGroupIds"],
      subnetIds: params["SubnetIds"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVpcLink",
      requestUri: "/v2/vpclinks",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CreatedDate": "d",
        "Name": "s",
        "SecurityGroupIds": ["s"],
        "SubnetIds": ["s"],
        "Tags": x => jsonP.readMap(String, String, x),
        "VpcLinkId": "s",
        "VpcLinkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "VpcLinkStatusMessage": "s",
        "VpcLinkVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkVersion>(x),
      },
    }, await resp.json());
  }

  async deleteAccessLogSettings(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccessLogSettingsRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAccessLogSettings",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}/accesslogsettings`,
      responseCode: 204,
    });
  }

  async deleteApi(
    {abortSignal, ...params}: RequestConfig & s.DeleteApiRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApi",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}`,
      responseCode: 204,
    });
  }

  async deleteApiMapping(
    {abortSignal, ...params}: RequestConfig & s.DeleteApiMappingRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApiMapping",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}/apimappings/${params["ApiMappingId"]}`,
      responseCode: 204,
    });
  }

  async deleteAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.DeleteAuthorizerRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAuthorizer",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/authorizers/${params["AuthorizerId"]}`,
      responseCode: 204,
    });
  }

  async deleteCorsConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteCorsConfigurationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCorsConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/cors`,
      responseCode: 204,
    });
  }

  async deleteDeployment(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeploymentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDeployment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/deployments/${params["DeploymentId"]}`,
      responseCode: 204,
    });
  }

  async deleteDomainName(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainNameRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDomainName",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}`,
      responseCode: 204,
    });
  }

  async deleteIntegration(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntegrationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}`,
      responseCode: 204,
    });
  }

  async deleteIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntegrationResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntegrationResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}/integrationresponses/${params["IntegrationResponseId"]}`,
      responseCode: 204,
    });
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteModel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models/${params["ModelId"]}`,
      responseCode: 204,
    });
  }

  async deleteRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRoute",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}`,
      responseCode: 204,
    });
  }

  async deleteRouteRequestParameter(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteRequestParameterRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRouteRequestParameter",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/requestparameters/${params["RequestParameterKey"]}`,
      responseCode: 204,
    });
  }

  async deleteRouteResponse(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteResponseRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRouteResponse",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/routeresponses/${params["RouteResponseId"]}`,
      responseCode: 204,
    });
  }

  async deleteRouteSettings(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteSettingsRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRouteSettings",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}/routesettings/${params["RouteKey"]}`,
      responseCode: 204,
    });
  }

  async deleteStage(
    {abortSignal, ...params}: RequestConfig & s.DeleteStageRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteStage",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}`,
      responseCode: 204,
    });
  }

  async deleteVpcLink(
    {abortSignal, ...params}: RequestConfig & s.DeleteVpcLinkRequest,
  ): Promise<s.DeleteVpcLinkResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVpcLink",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/vpclinks/${params["VpcLinkId"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async exportApi(
    {abortSignal, ...params}: RequestConfig & s.ExportApiRequest,
  ): Promise<s.ExportApiResponse> {
    const query = new URLSearchParams;
    if (params["ExportVersion"] != null) query.set("exportVersion", params["ExportVersion"]?.toString() ?? "");
    if (params["IncludeExtensions"] != null) query.set("includeExtensions", params["IncludeExtensions"]?.toString() ?? "");
    query.set("outputType", params["OutputType"]?.toString() ?? "");
    if (params["StageName"] != null) query.set("stageName", params["StageName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ExportApi",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/exports/${params["Specification"]}`,
      responseCode: 200,
    });
  return {
    body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async resetAuthorizersCache(
    {abortSignal, ...params}: RequestConfig & s.ResetAuthorizersCacheRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ResetAuthorizersCache",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}/cache/authorizers`,
      responseCode: 204,
    });
  }

  async getApi(
    {abortSignal, ...params}: RequestConfig & s.GetApiRequest,
  ): Promise<s.GetApiResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApi",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiEndpoint": "s",
        "ApiGatewayManaged": "b",
        "ApiId": "s",
        "ApiKeySelectionExpression": "s",
        "CorsConfiguration": toCors,
        "CreatedDate": "d",
        "Description": "s",
        "DisableSchemaValidation": "b",
        "DisableExecuteApiEndpoint": "b",
        "ImportInfo": ["s"],
        "Name": "s",
        "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
        "RouteSelectionExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Version": "s",
        "Warnings": ["s"],
      },
    }, await resp.json());
  }

  async getApiMapping(
    {abortSignal, ...params}: RequestConfig & s.GetApiMappingRequest,
  ): Promise<s.GetApiMappingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApiMapping",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}/apimappings/${params["ApiMappingId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiId": "s",
        "ApiMappingId": "s",
        "ApiMappingKey": "s",
        "Stage": "s",
      },
    }, await resp.json());
  }

  async getApiMappings(
    {abortSignal, ...params}: RequestConfig & s.GetApiMappingsRequest,
  ): Promise<s.GetApiMappingsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApiMappings",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}/apimappings`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toApiMapping],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getApis(
    {abortSignal, ...params}: RequestConfig & s.GetApisRequest = {},
  ): Promise<s.GetApisResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApis",
      method: "GET",
      requestUri: "/v2/apis",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toApi],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.GetAuthorizerRequest,
  ): Promise<s.GetAuthorizerResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAuthorizer",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/authorizers/${params["AuthorizerId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizerCredentialsArn": "s",
        "AuthorizerId": "s",
        "AuthorizerPayloadFormatVersion": "s",
        "AuthorizerResultTtlInSeconds": "n",
        "AuthorizerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "AuthorizerUri": "s",
        "EnableSimpleResponses": "b",
        "IdentitySource": ["s"],
        "IdentityValidationExpression": "s",
        "JwtConfiguration": toJWTConfiguration,
        "Name": "s",
      },
    }, await resp.json());
  }

  async getAuthorizers(
    {abortSignal, ...params}: RequestConfig & s.GetAuthorizersRequest,
  ): Promise<s.GetAuthorizersResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAuthorizers",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/authorizers`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toAuthorizer],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDeployment(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentRequest,
  ): Promise<s.GetDeploymentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDeployment",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/deployments/${params["DeploymentId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutoDeployed": "b",
        "CreatedDate": "d",
        "DeploymentId": "s",
        "DeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "DeploymentStatusMessage": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async getDeployments(
    {abortSignal, ...params}: RequestConfig & s.GetDeploymentsRequest,
  ): Promise<s.GetDeploymentsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDeployments",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/deployments`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toDeployment],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDomainName(
    {abortSignal, ...params}: RequestConfig & s.GetDomainNameRequest,
  ): Promise<s.GetDomainNameResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDomainName",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiMappingSelectionExpression": "s",
        "DomainName": "s",
        "DomainNameConfigurations": [toDomainNameConfiguration],
        "MutualTlsAuthentication": toMutualTlsAuthentication,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getDomainNames(
    {abortSignal, ...params}: RequestConfig & s.GetDomainNamesRequest = {},
  ): Promise<s.GetDomainNamesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDomainNames",
      method: "GET",
      requestUri: "/v2/domainnames",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toDomainName],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getIntegration(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationRequest,
  ): Promise<s.GetIntegrationResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegration",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ConnectionId": "s",
        "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "CredentialsArn": "s",
        "Description": "s",
        "IntegrationId": "s",
        "IntegrationMethod": "s",
        "IntegrationResponseSelectionExpression": "s",
        "IntegrationSubtype": "s",
        "IntegrationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "IntegrationUri": "s",
        "PassthroughBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.PassthroughBehavior>(x),
        "PayloadFormatVersion": "s",
        "RequestParameters": x => jsonP.readMap(String, String, x),
        "RequestTemplates": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, y => jsonP.readMap(String, String, y)!, x),
        "TemplateSelectionExpression": "s",
        "TimeoutInMillis": "n",
        "TlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async getIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationResponseRequest,
  ): Promise<s.GetIntegrationResponseResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntegrationResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}/integrationresponses/${params["IntegrationResponseId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "IntegrationResponseId": "s",
        "IntegrationResponseKey": "s",
        "ResponseParameters": x => jsonP.readMap(String, String, x),
        "ResponseTemplates": x => jsonP.readMap(String, String, x),
        "TemplateSelectionExpression": "s",
      },
    }, await resp.json());
  }

  async getIntegrationResponses(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationResponsesRequest,
  ): Promise<s.GetIntegrationResponsesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntegrationResponses",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}/integrationresponses`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toIntegrationResponse],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getIntegrations(
    {abortSignal, ...params}: RequestConfig & s.GetIntegrationsRequest,
  ): Promise<s.GetIntegrationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntegrations",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toIntegration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getModel(
    {abortSignal, ...params}: RequestConfig & s.GetModelRequest,
  ): Promise<s.GetModelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetModel",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models/${params["ModelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentType": "s",
        "Description": "s",
        "ModelId": "s",
        "Name": "s",
        "Schema": "s",
      },
    }, await resp.json());
  }

  async getModelTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetModelTemplateRequest,
  ): Promise<s.GetModelTemplateResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetModelTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models/${params["ModelId"]}/template`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Value": "s",
      },
    }, await resp.json());
  }

  async getModels(
    {abortSignal, ...params}: RequestConfig & s.GetModelsRequest,
  ): Promise<s.GetModelsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetModels",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toModel],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getRoute(
    {abortSignal, ...params}: RequestConfig & s.GetRouteRequest,
  ): Promise<s.GetRouteResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRoute",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ApiKeyRequired": "b",
        "AuthorizationScopes": ["s"],
        "AuthorizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizationType>(x),
        "AuthorizerId": "s",
        "ModelSelectionExpression": "s",
        "OperationName": "s",
        "RequestModels": x => jsonP.readMap(String, String, x),
        "RequestParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteId": "s",
        "RouteKey": "s",
        "RouteResponseSelectionExpression": "s",
        "Target": "s",
      },
    }, await resp.json());
  }

  async getRouteResponse(
    {abortSignal, ...params}: RequestConfig & s.GetRouteResponseRequest,
  ): Promise<s.GetRouteResponseResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRouteResponse",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/routeresponses/${params["RouteResponseId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelSelectionExpression": "s",
        "ResponseModels": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteResponseId": "s",
        "RouteResponseKey": "s",
      },
    }, await resp.json());
  }

  async getRouteResponses(
    {abortSignal, ...params}: RequestConfig & s.GetRouteResponsesRequest,
  ): Promise<s.GetRouteResponsesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRouteResponses",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/routeresponses`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toRouteResponse],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getRoutes(
    {abortSignal, ...params}: RequestConfig & s.GetRoutesRequest,
  ): Promise<s.GetRoutesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRoutes",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toRoute],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getStage(
    {abortSignal, ...params}: RequestConfig & s.GetStageRequest,
  ): Promise<s.GetStageResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStage",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccessLogSettings": toAccessLogSettings,
        "ApiGatewayManaged": "b",
        "AutoDeploy": "b",
        "ClientCertificateId": "s",
        "CreatedDate": "d",
        "DefaultRouteSettings": toRouteSettings,
        "DeploymentId": "s",
        "Description": "s",
        "LastDeploymentStatusMessage": "s",
        "LastUpdatedDate": "d",
        "RouteSettings": x => jsonP.readMap(String, toRouteSettings, x),
        "StageName": "s",
        "StageVariables": x => jsonP.readMap(String, String, x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getStages(
    {abortSignal, ...params}: RequestConfig & s.GetStagesRequest,
  ): Promise<s.GetStagesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetStages",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toStage],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & s.GetTagsRequest,
  ): Promise<s.GetTagsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTags",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getVpcLink(
    {abortSignal, ...params}: RequestConfig & s.GetVpcLinkRequest,
  ): Promise<s.GetVpcLinkResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVpcLink",
      method: "GET",
      requestUri: cmnP.encodePath`/v2/vpclinks/${params["VpcLinkId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CreatedDate": "d",
        "Name": "s",
        "SecurityGroupIds": ["s"],
        "SubnetIds": ["s"],
        "Tags": x => jsonP.readMap(String, String, x),
        "VpcLinkId": "s",
        "VpcLinkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "VpcLinkStatusMessage": "s",
        "VpcLinkVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkVersion>(x),
      },
    }, await resp.json());
  }

  async getVpcLinks(
    {abortSignal, ...params}: RequestConfig & s.GetVpcLinksRequest = {},
  ): Promise<s.GetVpcLinksResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetVpcLinks",
      method: "GET",
      requestUri: "/v2/vpclinks",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [toVpcLink],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async importApi(
    {abortSignal, ...params}: RequestConfig & s.ImportApiRequest,
  ): Promise<s.ImportApiResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      body: params["Body"],
    };
    if (params["Basepath"] != null) query.set("basepath", params["Basepath"]?.toString() ?? "");
    if (params["FailOnWarnings"] != null) query.set("failOnWarnings", params["FailOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ImportApi",
      method: "PUT",
      requestUri: "/v2/apis",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiEndpoint": "s",
        "ApiGatewayManaged": "b",
        "ApiId": "s",
        "ApiKeySelectionExpression": "s",
        "CorsConfiguration": toCors,
        "CreatedDate": "d",
        "Description": "s",
        "DisableSchemaValidation": "b",
        "DisableExecuteApiEndpoint": "b",
        "ImportInfo": ["s"],
        "Name": "s",
        "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
        "RouteSelectionExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Version": "s",
        "Warnings": ["s"],
      },
    }, await resp.json());
  }

  async reimportApi(
    {abortSignal, ...params}: RequestConfig & s.ReimportApiRequest,
  ): Promise<s.ReimportApiResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      body: params["Body"],
    };
    if (params["Basepath"] != null) query.set("basepath", params["Basepath"]?.toString() ?? "");
    if (params["FailOnWarnings"] != null) query.set("failOnWarnings", params["FailOnWarnings"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "ReimportApi",
      method: "PUT",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiEndpoint": "s",
        "ApiGatewayManaged": "b",
        "ApiId": "s",
        "ApiKeySelectionExpression": "s",
        "CorsConfiguration": toCors,
        "CreatedDate": "d",
        "Description": "s",
        "DisableSchemaValidation": "b",
        "DisableExecuteApiEndpoint": "b",
        "ImportInfo": ["s"],
        "Name": "s",
        "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
        "RouteSelectionExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Version": "s",
        "Warnings": ["s"],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v2/tags/${params["ResourceArn"]}`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v2/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateApi(
    {abortSignal, ...params}: RequestConfig & s.UpdateApiRequest,
  ): Promise<s.UpdateApiResponse> {
    const body: jsonP.JSONObject = {
      apiKeySelectionExpression: params["ApiKeySelectionExpression"],
      corsConfiguration: fromCors(params["CorsConfiguration"]),
      credentialsArn: params["CredentialsArn"],
      description: params["Description"],
      disableSchemaValidation: params["DisableSchemaValidation"],
      disableExecuteApiEndpoint: params["DisableExecuteApiEndpoint"],
      name: params["Name"],
      routeKey: params["RouteKey"],
      routeSelectionExpression: params["RouteSelectionExpression"],
      target: params["Target"],
      version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApi",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiEndpoint": "s",
        "ApiGatewayManaged": "b",
        "ApiId": "s",
        "ApiKeySelectionExpression": "s",
        "CorsConfiguration": toCors,
        "CreatedDate": "d",
        "Description": "s",
        "DisableSchemaValidation": "b",
        "DisableExecuteApiEndpoint": "b",
        "ImportInfo": ["s"],
        "Name": "s",
        "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
        "RouteSelectionExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Version": "s",
        "Warnings": ["s"],
      },
    }, await resp.json());
  }

  async updateApiMapping(
    {abortSignal, ...params}: RequestConfig & s.UpdateApiMappingRequest,
  ): Promise<s.UpdateApiMappingResponse> {
    const body: jsonP.JSONObject = {
      apiId: params["ApiId"],
      apiMappingKey: params["ApiMappingKey"],
      stage: params["Stage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApiMapping",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}/apimappings/${params["ApiMappingId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiId": "s",
        "ApiMappingId": "s",
        "ApiMappingKey": "s",
        "Stage": "s",
      },
    }, await resp.json());
  }

  async updateAuthorizer(
    {abortSignal, ...params}: RequestConfig & s.UpdateAuthorizerRequest,
  ): Promise<s.UpdateAuthorizerResponse> {
    const body: jsonP.JSONObject = {
      authorizerCredentialsArn: params["AuthorizerCredentialsArn"],
      authorizerPayloadFormatVersion: params["AuthorizerPayloadFormatVersion"],
      authorizerResultTtlInSeconds: params["AuthorizerResultTtlInSeconds"],
      authorizerType: params["AuthorizerType"],
      authorizerUri: params["AuthorizerUri"],
      enableSimpleResponses: params["EnableSimpleResponses"],
      identitySource: params["IdentitySource"],
      identityValidationExpression: params["IdentityValidationExpression"],
      jwtConfiguration: fromJWTConfiguration(params["JwtConfiguration"]),
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAuthorizer",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/authorizers/${params["AuthorizerId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizerCredentialsArn": "s",
        "AuthorizerId": "s",
        "AuthorizerPayloadFormatVersion": "s",
        "AuthorizerResultTtlInSeconds": "n",
        "AuthorizerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
        "AuthorizerUri": "s",
        "EnableSimpleResponses": "b",
        "IdentitySource": ["s"],
        "IdentityValidationExpression": "s",
        "JwtConfiguration": toJWTConfiguration,
        "Name": "s",
      },
    }, await resp.json());
  }

  async updateDeployment(
    {abortSignal, ...params}: RequestConfig & s.UpdateDeploymentRequest,
  ): Promise<s.UpdateDeploymentResponse> {
    const body: jsonP.JSONObject = {
      description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeployment",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/deployments/${params["DeploymentId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutoDeployed": "b",
        "CreatedDate": "d",
        "DeploymentId": "s",
        "DeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
        "DeploymentStatusMessage": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async updateDomainName(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainNameRequest,
  ): Promise<s.UpdateDomainNameResponse> {
    const body: jsonP.JSONObject = {
      domainNameConfigurations: params["DomainNameConfigurations"]?.map(x => fromDomainNameConfiguration(x)),
      mutualTlsAuthentication: fromMutualTlsAuthenticationInput(params["MutualTlsAuthentication"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainName",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/domainnames/${params["DomainName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiMappingSelectionExpression": "s",
        "DomainName": "s",
        "DomainNameConfigurations": [toDomainNameConfiguration],
        "MutualTlsAuthentication": toMutualTlsAuthentication,
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateIntegration(
    {abortSignal, ...params}: RequestConfig & s.UpdateIntegrationRequest,
  ): Promise<s.UpdateIntegrationResult> {
    const body: jsonP.JSONObject = {
      connectionId: params["ConnectionId"],
      connectionType: params["ConnectionType"],
      contentHandlingStrategy: params["ContentHandlingStrategy"],
      credentialsArn: params["CredentialsArn"],
      description: params["Description"],
      integrationMethod: params["IntegrationMethod"],
      integrationSubtype: params["IntegrationSubtype"],
      integrationType: params["IntegrationType"],
      integrationUri: params["IntegrationUri"],
      passthroughBehavior: params["PassthroughBehavior"],
      payloadFormatVersion: params["PayloadFormatVersion"],
      requestParameters: params["RequestParameters"],
      requestTemplates: params["RequestTemplates"],
      responseParameters: params["ResponseParameters"],
      templateSelectionExpression: params["TemplateSelectionExpression"],
      timeoutInMillis: params["TimeoutInMillis"],
      tlsConfig: fromTlsConfigInput(params["TlsConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegration",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ConnectionId": "s",
        "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "CredentialsArn": "s",
        "Description": "s",
        "IntegrationId": "s",
        "IntegrationMethod": "s",
        "IntegrationResponseSelectionExpression": "s",
        "IntegrationSubtype": "s",
        "IntegrationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
        "IntegrationUri": "s",
        "PassthroughBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.PassthroughBehavior>(x),
        "PayloadFormatVersion": "s",
        "RequestParameters": x => jsonP.readMap(String, String, x),
        "RequestTemplates": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, y => jsonP.readMap(String, String, y)!, x),
        "TemplateSelectionExpression": "s",
        "TimeoutInMillis": "n",
        "TlsConfig": toTlsConfig,
      },
    }, await resp.json());
  }

  async updateIntegrationResponse(
    {abortSignal, ...params}: RequestConfig & s.UpdateIntegrationResponseRequest,
  ): Promise<s.UpdateIntegrationResponseResponse> {
    const body: jsonP.JSONObject = {
      contentHandlingStrategy: params["ContentHandlingStrategy"],
      integrationResponseKey: params["IntegrationResponseKey"],
      responseParameters: params["ResponseParameters"],
      responseTemplates: params["ResponseTemplates"],
      templateSelectionExpression: params["TemplateSelectionExpression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntegrationResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/integrations/${params["IntegrationId"]}/integrationresponses/${params["IntegrationResponseId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
        "IntegrationResponseId": "s",
        "IntegrationResponseKey": "s",
        "ResponseParameters": x => jsonP.readMap(String, String, x),
        "ResponseTemplates": x => jsonP.readMap(String, String, x),
        "TemplateSelectionExpression": "s",
      },
    }, await resp.json());
  }

  async updateModel(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelRequest,
  ): Promise<s.UpdateModelResponse> {
    const body: jsonP.JSONObject = {
      contentType: params["ContentType"],
      description: params["Description"],
      name: params["Name"],
      schema: params["Schema"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModel",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/models/${params["ModelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContentType": "s",
        "Description": "s",
        "ModelId": "s",
        "Name": "s",
        "Schema": "s",
      },
    }, await resp.json());
  }

  async updateRoute(
    {abortSignal, ...params}: RequestConfig & s.UpdateRouteRequest,
  ): Promise<s.UpdateRouteResult> {
    const body: jsonP.JSONObject = {
      apiKeyRequired: params["ApiKeyRequired"],
      authorizationScopes: params["AuthorizationScopes"],
      authorizationType: params["AuthorizationType"],
      authorizerId: params["AuthorizerId"],
      modelSelectionExpression: params["ModelSelectionExpression"],
      operationName: params["OperationName"],
      requestModels: params["RequestModels"],
      requestParameters: jsonP.serializeMap(params["RequestParameters"], x => fromParameterConstraints(x)),
      routeKey: params["RouteKey"],
      routeResponseSelectionExpression: params["RouteResponseSelectionExpression"],
      target: params["Target"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRoute",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApiGatewayManaged": "b",
        "ApiKeyRequired": "b",
        "AuthorizationScopes": ["s"],
        "AuthorizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizationType>(x),
        "AuthorizerId": "s",
        "ModelSelectionExpression": "s",
        "OperationName": "s",
        "RequestModels": x => jsonP.readMap(String, String, x),
        "RequestParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteId": "s",
        "RouteKey": "s",
        "RouteResponseSelectionExpression": "s",
        "Target": "s",
      },
    }, await resp.json());
  }

  async updateRouteResponse(
    {abortSignal, ...params}: RequestConfig & s.UpdateRouteResponseRequest,
  ): Promise<s.UpdateRouteResponseResponse> {
    const body: jsonP.JSONObject = {
      modelSelectionExpression: params["ModelSelectionExpression"],
      responseModels: params["ResponseModels"],
      responseParameters: jsonP.serializeMap(params["ResponseParameters"], x => fromParameterConstraints(x)),
      routeResponseKey: params["RouteResponseKey"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRouteResponse",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/routes/${params["RouteId"]}/routeresponses/${params["RouteResponseId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModelSelectionExpression": "s",
        "ResponseModels": x => jsonP.readMap(String, String, x),
        "ResponseParameters": x => jsonP.readMap(String, toParameterConstraints, x),
        "RouteResponseId": "s",
        "RouteResponseKey": "s",
      },
    }, await resp.json());
  }

  async updateStage(
    {abortSignal, ...params}: RequestConfig & s.UpdateStageRequest,
  ): Promise<s.UpdateStageResponse> {
    const body: jsonP.JSONObject = {
      accessLogSettings: fromAccessLogSettings(params["AccessLogSettings"]),
      autoDeploy: params["AutoDeploy"],
      clientCertificateId: params["ClientCertificateId"],
      defaultRouteSettings: fromRouteSettings(params["DefaultRouteSettings"]),
      deploymentId: params["DeploymentId"],
      description: params["Description"],
      routeSettings: jsonP.serializeMap(params["RouteSettings"], x => fromRouteSettings(x)),
      stageVariables: params["StageVariables"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStage",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/apis/${params["ApiId"]}/stages/${params["StageName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccessLogSettings": toAccessLogSettings,
        "ApiGatewayManaged": "b",
        "AutoDeploy": "b",
        "ClientCertificateId": "s",
        "CreatedDate": "d",
        "DefaultRouteSettings": toRouteSettings,
        "DeploymentId": "s",
        "Description": "s",
        "LastDeploymentStatusMessage": "s",
        "LastUpdatedDate": "d",
        "RouteSettings": x => jsonP.readMap(String, toRouteSettings, x),
        "StageName": "s",
        "StageVariables": x => jsonP.readMap(String, String, x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async updateVpcLink(
    {abortSignal, ...params}: RequestConfig & s.UpdateVpcLinkRequest,
  ): Promise<s.UpdateVpcLinkResponse> {
    const body: jsonP.JSONObject = {
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVpcLink",
      method: "PATCH",
      requestUri: cmnP.encodePath`/v2/vpclinks/${params["VpcLinkId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CreatedDate": "d",
        "Name": "s",
        "SecurityGroupIds": ["s"],
        "SubnetIds": ["s"],
        "Tags": x => jsonP.readMap(String, String, x),
        "VpcLinkId": "s",
        "VpcLinkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
        "VpcLinkStatusMessage": "s",
        "VpcLinkVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkVersion>(x),
      },
    }, await resp.json());
  }

}

function fromCors(input?: s.Cors | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    allowCredentials: input["AllowCredentials"],
    allowHeaders: input["AllowHeaders"],
    allowMethods: input["AllowMethods"],
    allowOrigins: input["AllowOrigins"],
    exposeHeaders: input["ExposeHeaders"],
    maxAge: input["MaxAge"],
  }
}
function toCors(root: jsonP.JSONValue): s.Cors {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowCredentials": "b",
      "AllowHeaders": ["s"],
      "AllowMethods": ["s"],
      "AllowOrigins": ["s"],
      "ExposeHeaders": ["s"],
      "MaxAge": "n",
    },
  }, root);
}

function fromJWTConfiguration(input?: s.JWTConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audience: input["Audience"],
    issuer: input["Issuer"],
  }
}
function toJWTConfiguration(root: jsonP.JSONValue): s.JWTConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Audience": ["s"],
      "Issuer": "s",
    },
  }, root);
}

function fromDomainNameConfiguration(input?: s.DomainNameConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    apiGatewayDomainName: input["ApiGatewayDomainName"],
    certificateArn: input["CertificateArn"],
    certificateName: input["CertificateName"],
    certificateUploadDate: jsonP.serializeDate_iso8601(input["CertificateUploadDate"]),
    domainNameStatus: input["DomainNameStatus"],
    domainNameStatusMessage: input["DomainNameStatusMessage"],
    endpointType: input["EndpointType"],
    hostedZoneId: input["HostedZoneId"],
    securityPolicy: input["SecurityPolicy"],
  }
}
function toDomainNameConfiguration(root: jsonP.JSONValue): s.DomainNameConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApiGatewayDomainName": "s",
      "CertificateArn": "s",
      "CertificateName": "s",
      "CertificateUploadDate": "d",
      "DomainNameStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainNameStatus>(x),
      "DomainNameStatusMessage": "s",
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointType>(x),
      "HostedZoneId": "s",
      "SecurityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecurityPolicy>(x),
    },
  }, root);
}

function fromMutualTlsAuthenticationInput(input?: s.MutualTlsAuthenticationInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    truststoreUri: input["TruststoreUri"],
    truststoreVersion: input["TruststoreVersion"],
  }
}

function fromTlsConfigInput(input?: s.TlsConfigInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serverNameToVerify: input["ServerNameToVerify"],
  }
}

function fromParameterConstraints(input?: s.ParameterConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    required: input["Required"],
  }
}
function toParameterConstraints(root: jsonP.JSONValue): s.ParameterConstraints {
  return jsonP.readObj({
    required: {},
    optional: {
      "Required": "b",
    },
  }, root);
}

function fromAccessLogSettings(input?: s.AccessLogSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinationArn: input["DestinationArn"],
    format: input["Format"],
  }
}
function toAccessLogSettings(root: jsonP.JSONValue): s.AccessLogSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationArn": "s",
      "Format": "s",
    },
  }, root);
}

function fromRouteSettings(input?: s.RouteSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataTraceEnabled: input["DataTraceEnabled"],
    detailedMetricsEnabled: input["DetailedMetricsEnabled"],
    loggingLevel: input["LoggingLevel"],
    throttlingBurstLimit: input["ThrottlingBurstLimit"],
    throttlingRateLimit: input["ThrottlingRateLimit"],
  }
}
function toRouteSettings(root: jsonP.JSONValue): s.RouteSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataTraceEnabled": "b",
      "DetailedMetricsEnabled": "b",
      "LoggingLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoggingLevel>(x),
      "ThrottlingBurstLimit": "n",
      "ThrottlingRateLimit": "n",
    },
  }, root);
}

function toMutualTlsAuthentication(root: jsonP.JSONValue): s.MutualTlsAuthentication {
  return jsonP.readObj({
    required: {},
    optional: {
      "TruststoreUri": "s",
      "TruststoreVersion": "s",
      "TruststoreWarnings": ["s"],
    },
  }, root);
}

function toTlsConfig(root: jsonP.JSONValue): s.TlsConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServerNameToVerify": "s",
    },
  }, root);
}

function toApiMapping(root: jsonP.JSONValue): s.ApiMapping {
  return jsonP.readObj({
    required: {
      "ApiId": "s",
      "Stage": "s",
    },
    optional: {
      "ApiMappingId": "s",
      "ApiMappingKey": "s",
    },
  }, root);
}

function toApi(root: jsonP.JSONValue): s.Api {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "ProtocolType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtocolType>(x),
      "RouteSelectionExpression": "s",
    },
    optional: {
      "ApiEndpoint": "s",
      "ApiGatewayManaged": "b",
      "ApiId": "s",
      "ApiKeySelectionExpression": "s",
      "CorsConfiguration": toCors,
      "CreatedDate": "d",
      "Description": "s",
      "DisableSchemaValidation": "b",
      "DisableExecuteApiEndpoint": "b",
      "ImportInfo": ["s"],
      "Tags": x => jsonP.readMap(String, String, x),
      "Version": "s",
      "Warnings": ["s"],
    },
  }, root);
}

function toAuthorizer(root: jsonP.JSONValue): s.Authorizer {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AuthorizerCredentialsArn": "s",
      "AuthorizerId": "s",
      "AuthorizerPayloadFormatVersion": "s",
      "AuthorizerResultTtlInSeconds": "n",
      "AuthorizerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizerType>(x),
      "AuthorizerUri": "s",
      "EnableSimpleResponses": "b",
      "IdentitySource": ["s"],
      "IdentityValidationExpression": "s",
      "JwtConfiguration": toJWTConfiguration,
    },
  }, root);
}

function toDeployment(root: jsonP.JSONValue): s.Deployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutoDeployed": "b",
      "CreatedDate": "d",
      "DeploymentId": "s",
      "DeploymentStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "DeploymentStatusMessage": "s",
      "Description": "s",
    },
  }, root);
}

function toDomainName(root: jsonP.JSONValue): s.DomainName {
  return jsonP.readObj({
    required: {
      "DomainName": "s",
    },
    optional: {
      "ApiMappingSelectionExpression": "s",
      "DomainNameConfigurations": [toDomainNameConfiguration],
      "MutualTlsAuthentication": toMutualTlsAuthentication,
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toIntegrationResponse(root: jsonP.JSONValue): s.IntegrationResponse {
  return jsonP.readObj({
    required: {
      "IntegrationResponseKey": "s",
    },
    optional: {
      "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      "IntegrationResponseId": "s",
      "ResponseParameters": x => jsonP.readMap(String, String, x),
      "ResponseTemplates": x => jsonP.readMap(String, String, x),
      "TemplateSelectionExpression": "s",
    },
  }, root);
}

function toIntegration(root: jsonP.JSONValue): s.Integration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApiGatewayManaged": "b",
      "ConnectionId": "s",
      "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
      "ContentHandlingStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentHandlingStrategy>(x),
      "CredentialsArn": "s",
      "Description": "s",
      "IntegrationId": "s",
      "IntegrationMethod": "s",
      "IntegrationResponseSelectionExpression": "s",
      "IntegrationSubtype": "s",
      "IntegrationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x),
      "IntegrationUri": "s",
      "PassthroughBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.PassthroughBehavior>(x),
      "PayloadFormatVersion": "s",
      "RequestParameters": x => jsonP.readMap(String, String, x),
      "RequestTemplates": x => jsonP.readMap(String, String, x),
      "ResponseParameters": x => jsonP.readMap(String, y => jsonP.readMap(String, String, y)!, x),
      "TemplateSelectionExpression": "s",
      "TimeoutInMillis": "n",
      "TlsConfig": toTlsConfig,
    },
  }, root);
}

function toModel(root: jsonP.JSONValue): s.Model {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "ContentType": "s",
      "Description": "s",
      "ModelId": "s",
      "Schema": "s",
    },
  }, root);
}

function toRouteResponse(root: jsonP.JSONValue): s.RouteResponse {
  return jsonP.readObj({
    required: {
      "RouteResponseKey": "s",
    },
    optional: {
      "ModelSelectionExpression": "s",
      "ResponseModels": x => jsonP.readMap(String, String, x),
      "ResponseParameters": x => jsonP.readMap(String, toParameterConstraints, x),
      "RouteResponseId": "s",
    },
  }, root);
}

function toRoute(root: jsonP.JSONValue): s.Route {
  return jsonP.readObj({
    required: {
      "RouteKey": "s",
    },
    optional: {
      "ApiGatewayManaged": "b",
      "ApiKeyRequired": "b",
      "AuthorizationScopes": ["s"],
      "AuthorizationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthorizationType>(x),
      "AuthorizerId": "s",
      "ModelSelectionExpression": "s",
      "OperationName": "s",
      "RequestModels": x => jsonP.readMap(String, String, x),
      "RequestParameters": x => jsonP.readMap(String, toParameterConstraints, x),
      "RouteId": "s",
      "RouteResponseSelectionExpression": "s",
      "Target": "s",
    },
  }, root);
}

function toStage(root: jsonP.JSONValue): s.Stage {
  return jsonP.readObj({
    required: {
      "StageName": "s",
    },
    optional: {
      "AccessLogSettings": toAccessLogSettings,
      "ApiGatewayManaged": "b",
      "AutoDeploy": "b",
      "ClientCertificateId": "s",
      "CreatedDate": "d",
      "DefaultRouteSettings": toRouteSettings,
      "DeploymentId": "s",
      "Description": "s",
      "LastDeploymentStatusMessage": "s",
      "LastUpdatedDate": "d",
      "RouteSettings": x => jsonP.readMap(String, toRouteSettings, x),
      "StageVariables": x => jsonP.readMap(String, String, x),
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toVpcLink(root: jsonP.JSONValue): s.VpcLink {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "SecurityGroupIds": ["s"],
      "SubnetIds": ["s"],
      "VpcLinkId": "s",
    },
    optional: {
      "CreatedDate": "d",
      "Tags": x => jsonP.readMap(String, String, x),
      "VpcLinkStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkStatus>(x),
      "VpcLinkStatusMessage": "s",
      "VpcLinkVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.VpcLinkVersion>(x),
    },
  }, root);
}
