// Autogenerated API client for: Amazon Simple Email Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class SES {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SES.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2010-12-01",
    "endpointPrefix": "email",
    "protocol": "query",
    "serviceAbbreviation": "Amazon SES",
    "serviceFullName": "Amazon Simple Email Service",
    "serviceId": "SES",
    "signatureVersion": "v4",
    "signingName": "ses",
    "uid": "email-2010-12-01",
    "xmlNamespace": "http://ses.amazonaws.com/doc/2010-12-01/"
  };

  async cloneReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & CloneReceiptRuleSetRequest,
  ): Promise<CloneReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"OriginalRuleSetName", (params["OriginalRuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloneReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "CloneReceiptRuleSetResult");
    return {};
  }

  async createConfigurationSet(
    {abortSignal, ...params}: RequestConfig & CreateConfigurationSetRequest,
  ): Promise<CreateConfigurationSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    ConfigurationSet_Serialize(body, prefix+"ConfigurationSet", params["ConfigurationSet"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSet",
    });
    const xml = readXmlResult(await resp.text(), "CreateConfigurationSetResult");
    return {};
  }

  async createConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & CreateConfigurationSetEventDestinationRequest,
  ): Promise<CreateConfigurationSetEventDestinationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    EventDestination_Serialize(body, prefix+"EventDestination", params["EventDestination"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSetEventDestination",
    });
    const xml = readXmlResult(await resp.text(), "CreateConfigurationSetEventDestinationResult");
    return {};
  }

  async createConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & CreateConfigurationSetTrackingOptionsRequest,
  ): Promise<CreateConfigurationSetTrackingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    TrackingOptions_Serialize(body, prefix+"TrackingOptions", params["TrackingOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationSetTrackingOptions",
    });
    const xml = readXmlResult(await resp.text(), "CreateConfigurationSetTrackingOptionsResult");
    return {};
  }

  async createCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & CreateCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    body.append(prefix+"FromEmailAddress", (params["FromEmailAddress"] ?? '').toString());
    body.append(prefix+"TemplateSubject", (params["TemplateSubject"] ?? '').toString());
    body.append(prefix+"TemplateContent", (params["TemplateContent"] ?? '').toString());
    body.append(prefix+"SuccessRedirectionURL", (params["SuccessRedirectionURL"] ?? '').toString());
    body.append(prefix+"FailureRedirectionURL", (params["FailureRedirectionURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomVerificationEmailTemplate",
    });
  }

  async createReceiptFilter(
    {abortSignal, ...params}: RequestConfig & CreateReceiptFilterRequest,
  ): Promise<CreateReceiptFilterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    ReceiptFilter_Serialize(body, prefix+"Filter", params["Filter"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptFilter",
    });
    const xml = readXmlResult(await resp.text(), "CreateReceiptFilterResult");
    return {};
  }

  async createReceiptRule(
    {abortSignal, ...params}: RequestConfig & CreateReceiptRuleRequest,
  ): Promise<CreateReceiptRuleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    if ("After" in params) body.append(prefix+"After", (params["After"] ?? '').toString());
    ReceiptRule_Serialize(body, prefix+"Rule", params["Rule"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptRule",
    });
    const xml = readXmlResult(await resp.text(), "CreateReceiptRuleResult");
    return {};
  }

  async createReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & CreateReceiptRuleSetRequest,
  ): Promise<CreateReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "CreateReceiptRuleSetResult");
    return {};
  }

  async createTemplate(
    {abortSignal, ...params}: RequestConfig & CreateTemplateRequest,
  ): Promise<CreateTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    Template_Serialize(body, prefix+"Template", params["Template"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTemplate",
    });
    const xml = readXmlResult(await resp.text(), "CreateTemplateResult");
    return {};
  }

  async deleteConfigurationSet(
    {abortSignal, ...params}: RequestConfig & DeleteConfigurationSetRequest,
  ): Promise<DeleteConfigurationSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSet",
    });
    const xml = readXmlResult(await resp.text(), "DeleteConfigurationSetResult");
    return {};
  }

  async deleteConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & DeleteConfigurationSetEventDestinationRequest,
  ): Promise<DeleteConfigurationSetEventDestinationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"EventDestinationName", (params["EventDestinationName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSetEventDestination",
    });
    const xml = readXmlResult(await resp.text(), "DeleteConfigurationSetEventDestinationResult");
    return {};
  }

  async deleteConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & DeleteConfigurationSetTrackingOptionsRequest,
  ): Promise<DeleteConfigurationSetTrackingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationSetTrackingOptions",
    });
    const xml = readXmlResult(await resp.text(), "DeleteConfigurationSetTrackingOptionsResult");
    return {};
  }

  async deleteCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & DeleteCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomVerificationEmailTemplate",
    });
  }

  async deleteIdentity(
    {abortSignal, ...params}: RequestConfig & DeleteIdentityRequest,
  ): Promise<DeleteIdentityResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIdentity",
    });
    const xml = readXmlResult(await resp.text(), "DeleteIdentityResult");
    return {};
  }

  async deleteIdentityPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteIdentityPolicyRequest,
  ): Promise<DeleteIdentityPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIdentityPolicy",
    });
    const xml = readXmlResult(await resp.text(), "DeleteIdentityPolicyResult");
    return {};
  }

  async deleteReceiptFilter(
    {abortSignal, ...params}: RequestConfig & DeleteReceiptFilterRequest,
  ): Promise<DeleteReceiptFilterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"FilterName", (params["FilterName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptFilter",
    });
    const xml = readXmlResult(await resp.text(), "DeleteReceiptFilterResult");
    return {};
  }

  async deleteReceiptRule(
    {abortSignal, ...params}: RequestConfig & DeleteReceiptRuleRequest,
  ): Promise<DeleteReceiptRuleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptRule",
    });
    const xml = readXmlResult(await resp.text(), "DeleteReceiptRuleResult");
    return {};
  }

  async deleteReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & DeleteReceiptRuleSetRequest,
  ): Promise<DeleteReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "DeleteReceiptRuleSetResult");
    return {};
  }

  async deleteTemplate(
    {abortSignal, ...params}: RequestConfig & DeleteTemplateRequest,
  ): Promise<DeleteTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTemplate",
    });
    const xml = readXmlResult(await resp.text(), "DeleteTemplateResult");
    return {};
  }

  async deleteVerifiedEmailAddress(
    {abortSignal, ...params}: RequestConfig & DeleteVerifiedEmailAddressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVerifiedEmailAddress",
    });
  }

  async describeActiveReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & DescribeActiveReceiptRuleSetRequest = {},
  ): Promise<DescribeActiveReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeActiveReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "DescribeActiveReceiptRuleSetResult");
    return {
      Metadata: xml.first("Metadata", false, ReceiptRuleSetMetadata_Parse),
      Rules: xml.getList("Rules", "member").map(ReceiptRule_Parse),
    };
  }

  async describeConfigurationSet(
    {abortSignal, ...params}: RequestConfig & DescribeConfigurationSetRequest,
  ): Promise<DescribeConfigurationSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["ConfigurationSetAttributeNames"]) prt.appendList(body, prefix+"ConfigurationSetAttributeNames", params["ConfigurationSetAttributeNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConfigurationSet",
    });
    const xml = readXmlResult(await resp.text(), "DescribeConfigurationSetResult");
    return {
      ConfigurationSet: xml.first("ConfigurationSet", false, ConfigurationSet_Parse),
      EventDestinations: xml.getList("EventDestinations", "member").map(EventDestination_Parse),
      TrackingOptions: xml.first("TrackingOptions", false, TrackingOptions_Parse),
      DeliveryOptions: xml.first("DeliveryOptions", false, DeliveryOptions_Parse),
      ReputationOptions: xml.first("ReputationOptions", false, ReputationOptions_Parse),
    };
  }

  async describeReceiptRule(
    {abortSignal, ...params}: RequestConfig & DescribeReceiptRuleRequest,
  ): Promise<DescribeReceiptRuleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReceiptRule",
    });
    const xml = readXmlResult(await resp.text(), "DescribeReceiptRuleResult");
    return {
      Rule: xml.first("Rule", false, ReceiptRule_Parse),
    };
  }

  async describeReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & DescribeReceiptRuleSetRequest,
  ): Promise<DescribeReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "DescribeReceiptRuleSetResult");
    return {
      Metadata: xml.first("Metadata", false, ReceiptRuleSetMetadata_Parse),
      Rules: xml.getList("Rules", "member").map(ReceiptRule_Parse),
    };
  }

  async getAccountSendingEnabled(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetAccountSendingEnabledResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountSendingEnabled",
    });
    const xml = readXmlResult(await resp.text(), "GetAccountSendingEnabledResult");
    return {
      Enabled: xml.first("Enabled", false, x => x.content === 'true'),
    };
  }

  async getCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & GetCustomVerificationEmailTemplateRequest,
  ): Promise<GetCustomVerificationEmailTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCustomVerificationEmailTemplate",
    });
    const xml = readXmlResult(await resp.text(), "GetCustomVerificationEmailTemplateResult");
    return xml.strings({
      optional: {"TemplateName":true,"FromEmailAddress":true,"TemplateSubject":true,"TemplateContent":true,"SuccessRedirectionURL":true,"FailureRedirectionURL":true},
    });
  }

  async getIdentityDkimAttributes(
    {abortSignal, ...params}: RequestConfig & GetIdentityDkimAttributesRequest,
  ): Promise<GetIdentityDkimAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) prt.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityDkimAttributes",
    });
    const xml = readXmlResult(await resp.text(), "GetIdentityDkimAttributesResult");
    return {
      DkimAttributes: readXmlMap(xml.getList("DkimAttributes", "entry"), IdentityDkimAttributes_Parse, {}),
    };
  }

  async getIdentityMailFromDomainAttributes(
    {abortSignal, ...params}: RequestConfig & GetIdentityMailFromDomainAttributesRequest,
  ): Promise<GetIdentityMailFromDomainAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) prt.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityMailFromDomainAttributes",
    });
    const xml = readXmlResult(await resp.text(), "GetIdentityMailFromDomainAttributesResult");
    return {
      MailFromDomainAttributes: readXmlMap(xml.getList("MailFromDomainAttributes", "entry"), IdentityMailFromDomainAttributes_Parse, {}),
    };
  }

  async getIdentityNotificationAttributes(
    {abortSignal, ...params}: RequestConfig & GetIdentityNotificationAttributesRequest,
  ): Promise<GetIdentityNotificationAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) prt.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityNotificationAttributes",
    });
    const xml = readXmlResult(await resp.text(), "GetIdentityNotificationAttributesResult");
    return {
      NotificationAttributes: readXmlMap(xml.getList("NotificationAttributes", "entry"), IdentityNotificationAttributes_Parse, {}),
    };
  }

  async getIdentityPolicies(
    {abortSignal, ...params}: RequestConfig & GetIdentityPoliciesRequest,
  ): Promise<GetIdentityPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    if (params["PolicyNames"]) prt.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityPolicies",
    });
    const xml = readXmlResult(await resp.text(), "GetIdentityPoliciesResult");
    return {
      Policies: readXmlMap(xml.getList("Policies", "entry"), x => x.content ?? '', {}),
    };
  }

  async getIdentityVerificationAttributes(
    {abortSignal, ...params}: RequestConfig & GetIdentityVerificationAttributesRequest,
  ): Promise<GetIdentityVerificationAttributesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Identities"]) prt.appendList(body, prefix+"Identities", params["Identities"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIdentityVerificationAttributes",
    });
    const xml = readXmlResult(await resp.text(), "GetIdentityVerificationAttributesResult");
    return {
      VerificationAttributes: readXmlMap(xml.getList("VerificationAttributes", "entry"), IdentityVerificationAttributes_Parse, {}),
    };
  }

  async getSendQuota(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetSendQuotaResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSendQuota",
    });
    const xml = readXmlResult(await resp.text(), "GetSendQuotaResult");
    return {
      Max24HourSend: xml.first("Max24HourSend", false, x => parseFloat(x.content ?? '0')),
      MaxSendRate: xml.first("MaxSendRate", false, x => parseFloat(x.content ?? '0')),
      SentLast24Hours: xml.first("SentLast24Hours", false, x => parseFloat(x.content ?? '0')),
    };
  }

  async getSendStatistics(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<GetSendStatisticsResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSendStatistics",
    });
    const xml = readXmlResult(await resp.text(), "GetSendStatisticsResult");
    return {
      SendDataPoints: xml.getList("SendDataPoints", "member").map(SendDataPoint_Parse),
    };
  }

  async getTemplate(
    {abortSignal, ...params}: RequestConfig & GetTemplateRequest,
  ): Promise<GetTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplate",
    });
    const xml = readXmlResult(await resp.text(), "GetTemplateResult");
    return {
      Template: xml.first("Template", false, Template_Parse),
    };
  }

  async listConfigurationSets(
    {abortSignal, ...params}: RequestConfig & ListConfigurationSetsRequest = {},
  ): Promise<ListConfigurationSetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListConfigurationSets",
    });
    const xml = readXmlResult(await resp.text(), "ListConfigurationSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ConfigurationSets: xml.getList("ConfigurationSets", "member").map(ConfigurationSet_Parse),
    };
  }

  async listCustomVerificationEmailTemplates(
    {abortSignal, ...params}: RequestConfig & ListCustomVerificationEmailTemplatesRequest = {},
  ): Promise<ListCustomVerificationEmailTemplatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCustomVerificationEmailTemplates",
    });
    const xml = readXmlResult(await resp.text(), "ListCustomVerificationEmailTemplatesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      CustomVerificationEmailTemplates: xml.getList("CustomVerificationEmailTemplates", "member").map(CustomVerificationEmailTemplate_Parse),
    };
  }

  async listIdentities(
    {abortSignal, ...params}: RequestConfig & ListIdentitiesRequest = {},
  ): Promise<ListIdentitiesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("IdentityType" in params) body.append(prefix+"IdentityType", (params["IdentityType"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIdentities",
    });
    const xml = readXmlResult(await resp.text(), "ListIdentitiesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Identities: xml.getList("Identities", "member").map(x => x.content ?? ''),
    };
  }

  async listIdentityPolicies(
    {abortSignal, ...params}: RequestConfig & ListIdentityPoliciesRequest,
  ): Promise<ListIdentityPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIdentityPolicies",
    });
    const xml = readXmlResult(await resp.text(), "ListIdentityPoliciesResult");
    return {
      PolicyNames: xml.getList("PolicyNames", "member").map(x => x.content ?? ''),
    };
  }

  async listReceiptFilters(
    {abortSignal, ...params}: RequestConfig & ListReceiptFiltersRequest = {},
  ): Promise<ListReceiptFiltersResponse> {
    const body = new URLSearchParams;
    const prefix = '';

    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReceiptFilters",
    });
    const xml = readXmlResult(await resp.text(), "ListReceiptFiltersResult");
    return {
      Filters: xml.getList("Filters", "member").map(ReceiptFilter_Parse),
    };
  }

  async listReceiptRuleSets(
    {abortSignal, ...params}: RequestConfig & ListReceiptRuleSetsRequest = {},
  ): Promise<ListReceiptRuleSetsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReceiptRuleSets",
    });
    const xml = readXmlResult(await resp.text(), "ListReceiptRuleSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RuleSets: xml.getList("RuleSets", "member").map(ReceiptRuleSetMetadata_Parse),
    };
  }

  async listTemplates(
    {abortSignal, ...params}: RequestConfig & ListTemplatesRequest = {},
  ): Promise<ListTemplatesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTemplates",
    });
    const xml = readXmlResult(await resp.text(), "ListTemplatesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TemplatesMetadata: xml.getList("TemplatesMetadata", "member").map(TemplateMetadata_Parse),
    };
  }

  async listVerifiedEmailAddresses(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<ListVerifiedEmailAddressesResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListVerifiedEmailAddresses",
    });
    const xml = readXmlResult(await resp.text(), "ListVerifiedEmailAddressesResult");
    return {
      VerifiedEmailAddresses: xml.getList("VerifiedEmailAddresses", "member").map(x => x.content ?? ''),
    };
  }

  async putConfigurationSetDeliveryOptions(
    {abortSignal, ...params}: RequestConfig & PutConfigurationSetDeliveryOptionsRequest,
  ): Promise<PutConfigurationSetDeliveryOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["DeliveryOptions"] != null) DeliveryOptions_Serialize(body, prefix+"DeliveryOptions", params["DeliveryOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutConfigurationSetDeliveryOptions",
    });
    const xml = readXmlResult(await resp.text(), "PutConfigurationSetDeliveryOptionsResult");
    return {};
  }

  async putIdentityPolicy(
    {abortSignal, ...params}: RequestConfig & PutIdentityPolicyRequest,
  ): Promise<PutIdentityPolicyResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"Policy", (params["Policy"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIdentityPolicy",
    });
    const xml = readXmlResult(await resp.text(), "PutIdentityPolicyResult");
    return {};
  }

  async reorderReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & ReorderReceiptRuleSetRequest,
  ): Promise<ReorderReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    if (params["RuleNames"]) prt.appendList(body, prefix+"RuleNames", params["RuleNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReorderReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "ReorderReceiptRuleSetResult");
    return {};
  }

  async sendBounce(
    {abortSignal, ...params}: RequestConfig & SendBounceRequest,
  ): Promise<SendBounceResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OriginalMessageId", (params["OriginalMessageId"] ?? '').toString());
    body.append(prefix+"BounceSender", (params["BounceSender"] ?? '').toString());
    if ("Explanation" in params) body.append(prefix+"Explanation", (params["Explanation"] ?? '').toString());
    if (params["MessageDsn"] != null) MessageDsn_Serialize(body, prefix+"MessageDsn", params["MessageDsn"]);
    if (params["BouncedRecipientInfoList"]) prt.appendList(body, prefix+"BouncedRecipientInfoList", params["BouncedRecipientInfoList"], {"appender":BouncedRecipientInfo_Serialize,"entryPrefix":".member."})
    if ("BounceSenderArn" in params) body.append(prefix+"BounceSenderArn", (params["BounceSenderArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendBounce",
    });
    const xml = readXmlResult(await resp.text(), "SendBounceResult");
    return xml.strings({
      optional: {"MessageId":true},
    });
  }

  async sendBulkTemplatedEmail(
    {abortSignal, ...params}: RequestConfig & SendBulkTemplatedEmailRequest,
  ): Promise<SendBulkTemplatedEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if (params["ReplyToAddresses"]) prt.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    if (params["DefaultTags"]) prt.appendList(body, prefix+"DefaultTags", params["DefaultTags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Template", (params["Template"] ?? '').toString());
    if ("TemplateArn" in params) body.append(prefix+"TemplateArn", (params["TemplateArn"] ?? '').toString());
    if ("DefaultTemplateData" in params) body.append(prefix+"DefaultTemplateData", (params["DefaultTemplateData"] ?? '').toString());
    if (params["Destinations"]) prt.appendList(body, prefix+"Destinations", params["Destinations"], {"appender":BulkEmailDestination_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendBulkTemplatedEmail",
    });
    const xml = readXmlResult(await resp.text(), "SendBulkTemplatedEmailResult");
    return {
      Status: xml.getList("Status", "member").map(BulkEmailDestinationStatus_Parse),
    };
  }

  async sendCustomVerificationEmail(
    {abortSignal, ...params}: RequestConfig & SendCustomVerificationEmailRequest,
  ): Promise<SendCustomVerificationEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendCustomVerificationEmail",
    });
    const xml = readXmlResult(await resp.text(), "SendCustomVerificationEmailResult");
    return xml.strings({
      optional: {"MessageId":true},
    });
  }

  async sendEmail(
    {abortSignal, ...params}: RequestConfig & SendEmailRequest,
  ): Promise<SendEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    Destination_Serialize(body, prefix+"Destination", params["Destination"]);
    Message_Serialize(body, prefix+"Message", params["Message"]);
    if (params["ReplyToAddresses"]) prt.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendEmail",
    });
    const xml = readXmlResult(await resp.text(), "SendEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async sendRawEmail(
    {abortSignal, ...params}: RequestConfig & SendRawEmailRequest,
  ): Promise<SendRawEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Destinations"]) prt.appendList(body, prefix+"Destinations", params["Destinations"], {"entryPrefix":".member."})
    RawMessage_Serialize(body, prefix+"RawMessage", params["RawMessage"]);
    if ("FromArn" in params) body.append(prefix+"FromArn", (params["FromArn"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendRawEmail",
    });
    const xml = readXmlResult(await resp.text(), "SendRawEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async sendTemplatedEmail(
    {abortSignal, ...params}: RequestConfig & SendTemplatedEmailRequest,
  ): Promise<SendTemplatedEmailResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Source", (params["Source"] ?? '').toString());
    Destination_Serialize(body, prefix+"Destination", params["Destination"]);
    if (params["ReplyToAddresses"]) prt.appendList(body, prefix+"ReplyToAddresses", params["ReplyToAddresses"], {"entryPrefix":".member."})
    if ("ReturnPath" in params) body.append(prefix+"ReturnPath", (params["ReturnPath"] ?? '').toString());
    if ("SourceArn" in params) body.append(prefix+"SourceArn", (params["SourceArn"] ?? '').toString());
    if ("ReturnPathArn" in params) body.append(prefix+"ReturnPathArn", (params["ReturnPathArn"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ConfigurationSetName" in params) body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Template", (params["Template"] ?? '').toString());
    if ("TemplateArn" in params) body.append(prefix+"TemplateArn", (params["TemplateArn"] ?? '').toString());
    body.append(prefix+"TemplateData", (params["TemplateData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendTemplatedEmail",
    });
    const xml = readXmlResult(await resp.text(), "SendTemplatedEmailResult");
    return xml.strings({
      required: {"MessageId":true},
    });
  }

  async setActiveReceiptRuleSet(
    {abortSignal, ...params}: RequestConfig & SetActiveReceiptRuleSetRequest = {},
  ): Promise<SetActiveReceiptRuleSetResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("RuleSetName" in params) body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetActiveReceiptRuleSet",
    });
    const xml = readXmlResult(await resp.text(), "SetActiveReceiptRuleSetResult");
    return {};
  }

  async setIdentityDkimEnabled(
    {abortSignal, ...params}: RequestConfig & SetIdentityDkimEnabledRequest,
  ): Promise<SetIdentityDkimEnabledResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"DkimEnabled", (params["DkimEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityDkimEnabled",
    });
    const xml = readXmlResult(await resp.text(), "SetIdentityDkimEnabledResult");
    return {};
  }

  async setIdentityFeedbackForwardingEnabled(
    {abortSignal, ...params}: RequestConfig & SetIdentityFeedbackForwardingEnabledRequest,
  ): Promise<SetIdentityFeedbackForwardingEnabledResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"ForwardingEnabled", (params["ForwardingEnabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityFeedbackForwardingEnabled",
    });
    const xml = readXmlResult(await resp.text(), "SetIdentityFeedbackForwardingEnabledResult");
    return {};
  }

  async setIdentityHeadersInNotificationsEnabled(
    {abortSignal, ...params}: RequestConfig & SetIdentityHeadersInNotificationsEnabledRequest,
  ): Promise<SetIdentityHeadersInNotificationsEnabledResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"NotificationType", (params["NotificationType"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityHeadersInNotificationsEnabled",
    });
    const xml = readXmlResult(await resp.text(), "SetIdentityHeadersInNotificationsEnabledResult");
    return {};
  }

  async setIdentityMailFromDomain(
    {abortSignal, ...params}: RequestConfig & SetIdentityMailFromDomainRequest,
  ): Promise<SetIdentityMailFromDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    if ("MailFromDomain" in params) body.append(prefix+"MailFromDomain", (params["MailFromDomain"] ?? '').toString());
    if ("BehaviorOnMXFailure" in params) body.append(prefix+"BehaviorOnMXFailure", (params["BehaviorOnMXFailure"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityMailFromDomain",
    });
    const xml = readXmlResult(await resp.text(), "SetIdentityMailFromDomainResult");
    return {};
  }

  async setIdentityNotificationTopic(
    {abortSignal, ...params}: RequestConfig & SetIdentityNotificationTopicRequest,
  ): Promise<SetIdentityNotificationTopicResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Identity", (params["Identity"] ?? '').toString());
    body.append(prefix+"NotificationType", (params["NotificationType"] ?? '').toString());
    if ("SnsTopic" in params) body.append(prefix+"SnsTopic", (params["SnsTopic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIdentityNotificationTopic",
    });
    const xml = readXmlResult(await resp.text(), "SetIdentityNotificationTopicResult");
    return {};
  }

  async setReceiptRulePosition(
    {abortSignal, ...params}: RequestConfig & SetReceiptRulePositionRequest,
  ): Promise<SetReceiptRulePositionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    body.append(prefix+"RuleName", (params["RuleName"] ?? '').toString());
    if ("After" in params) body.append(prefix+"After", (params["After"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetReceiptRulePosition",
    });
    const xml = readXmlResult(await resp.text(), "SetReceiptRulePositionResult");
    return {};
  }

  async testRenderTemplate(
    {abortSignal, ...params}: RequestConfig & TestRenderTemplateRequest,
  ): Promise<TestRenderTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    body.append(prefix+"TemplateData", (params["TemplateData"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestRenderTemplate",
    });
    const xml = readXmlResult(await resp.text(), "TestRenderTemplateResult");
    return xml.strings({
      optional: {"RenderedTemplate":true},
    });
  }

  async updateAccountSendingEnabled(
    {abortSignal, ...params}: RequestConfig & UpdateAccountSendingEnabledRequest = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAccountSendingEnabled",
    });
  }

  async updateConfigurationSetEventDestination(
    {abortSignal, ...params}: RequestConfig & UpdateConfigurationSetEventDestinationRequest,
  ): Promise<UpdateConfigurationSetEventDestinationResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    EventDestination_Serialize(body, prefix+"EventDestination", params["EventDestination"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetEventDestination",
    });
    const xml = readXmlResult(await resp.text(), "UpdateConfigurationSetEventDestinationResult");
    return {};
  }

  async updateConfigurationSetReputationMetricsEnabled(
    {abortSignal, ...params}: RequestConfig & UpdateConfigurationSetReputationMetricsEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetReputationMetricsEnabled",
    });
  }

  async updateConfigurationSetSendingEnabled(
    {abortSignal, ...params}: RequestConfig & UpdateConfigurationSetSendingEnabledRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetSendingEnabled",
    });
  }

  async updateConfigurationSetTrackingOptions(
    {abortSignal, ...params}: RequestConfig & UpdateConfigurationSetTrackingOptionsRequest,
  ): Promise<UpdateConfigurationSetTrackingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ConfigurationSetName", (params["ConfigurationSetName"] ?? '').toString());
    TrackingOptions_Serialize(body, prefix+"TrackingOptions", params["TrackingOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationSetTrackingOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateConfigurationSetTrackingOptionsResult");
    return {};
  }

  async updateCustomVerificationEmailTemplate(
    {abortSignal, ...params}: RequestConfig & UpdateCustomVerificationEmailTemplateRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("FromEmailAddress" in params) body.append(prefix+"FromEmailAddress", (params["FromEmailAddress"] ?? '').toString());
    if ("TemplateSubject" in params) body.append(prefix+"TemplateSubject", (params["TemplateSubject"] ?? '').toString());
    if ("TemplateContent" in params) body.append(prefix+"TemplateContent", (params["TemplateContent"] ?? '').toString());
    if ("SuccessRedirectionURL" in params) body.append(prefix+"SuccessRedirectionURL", (params["SuccessRedirectionURL"] ?? '').toString());
    if ("FailureRedirectionURL" in params) body.append(prefix+"FailureRedirectionURL", (params["FailureRedirectionURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCustomVerificationEmailTemplate",
    });
  }

  async updateReceiptRule(
    {abortSignal, ...params}: RequestConfig & UpdateReceiptRuleRequest,
  ): Promise<UpdateReceiptRuleResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleSetName", (params["RuleSetName"] ?? '').toString());
    ReceiptRule_Serialize(body, prefix+"Rule", params["Rule"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReceiptRule",
    });
    const xml = readXmlResult(await resp.text(), "UpdateReceiptRuleResult");
    return {};
  }

  async updateTemplate(
    {abortSignal, ...params}: RequestConfig & UpdateTemplateRequest,
  ): Promise<UpdateTemplateResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    Template_Serialize(body, prefix+"Template", params["Template"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplate",
    });
    const xml = readXmlResult(await resp.text(), "UpdateTemplateResult");
    return {};
  }

  async verifyDomainDkim(
    {abortSignal, ...params}: RequestConfig & VerifyDomainDkimRequest,
  ): Promise<VerifyDomainDkimResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyDomainDkim",
    });
    const xml = readXmlResult(await resp.text(), "VerifyDomainDkimResult");
    return {
      DkimTokens: xml.getList("DkimTokens", "member").map(x => x.content ?? ''),
    };
  }

  async verifyDomainIdentity(
    {abortSignal, ...params}: RequestConfig & VerifyDomainIdentityRequest,
  ): Promise<VerifyDomainIdentityResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Domain", (params["Domain"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyDomainIdentity",
    });
    const xml = readXmlResult(await resp.text(), "VerifyDomainIdentityResult");
    return xml.strings({
      required: {"VerificationToken":true},
    });
  }

  async verifyEmailAddress(
    {abortSignal, ...params}: RequestConfig & VerifyEmailAddressRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyEmailAddress",
    });
  }

  async verifyEmailIdentity(
    {abortSignal, ...params}: RequestConfig & VerifyEmailIdentityRequest,
  ): Promise<VerifyEmailIdentityResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EmailAddress", (params["EmailAddress"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyEmailIdentity",
    });
    const xml = readXmlResult(await resp.text(), "VerifyEmailIdentityResult");
    return {};
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 3 seconds apart (about 1 minutes max wait time). */
  async waitForIdentityExists(
    params: RequestConfig & GetIdentityVerificationAttributesRequest,
  ): Promise<GetIdentityVerificationAttributesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state IdentityExists';
    for (let i = 0; i < 20; i++) {
      const resp = await this.getIdentityVerificationAttributes(params);
      if (Object.values(resp["VerificationAttributes"]).map(x => x["VerificationStatus"]).every(x => x === "Success")) return resp;
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CloneReceiptRuleSetRequest {
  RuleSetName: string;
  OriginalRuleSetName: string;
}

// refs: 1 - tags: named, input
export interface CreateConfigurationSetRequest {
  ConfigurationSet: ConfigurationSet;
}

// refs: 1 - tags: named, input
export interface CreateConfigurationSetEventDestinationRequest {
  ConfigurationSetName: string;
  EventDestination: EventDestination;
}

// refs: 1 - tags: named, input
export interface CreateConfigurationSetTrackingOptionsRequest {
  ConfigurationSetName: string;
  TrackingOptions: TrackingOptions;
}

// refs: 1 - tags: named, input
export interface CreateCustomVerificationEmailTemplateRequest {
  TemplateName: string;
  FromEmailAddress: string;
  TemplateSubject: string;
  TemplateContent: string;
  SuccessRedirectionURL: string;
  FailureRedirectionURL: string;
}

// refs: 1 - tags: named, input
export interface CreateReceiptFilterRequest {
  Filter: ReceiptFilter;
}

// refs: 1 - tags: named, input
export interface CreateReceiptRuleRequest {
  RuleSetName: string;
  After?: string | null;
  Rule: ReceiptRule;
}

// refs: 1 - tags: named, input
export interface CreateReceiptRuleSetRequest {
  RuleSetName: string;
}

// refs: 1 - tags: named, input
export interface CreateTemplateRequest {
  Template: Template;
}

// refs: 1 - tags: named, input
export interface DeleteConfigurationSetRequest {
  ConfigurationSetName: string;
}

// refs: 1 - tags: named, input
export interface DeleteConfigurationSetEventDestinationRequest {
  ConfigurationSetName: string;
  EventDestinationName: string;
}

// refs: 1 - tags: named, input
export interface DeleteConfigurationSetTrackingOptionsRequest {
  ConfigurationSetName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCustomVerificationEmailTemplateRequest {
  TemplateName: string;
}

// refs: 1 - tags: named, input
export interface DeleteIdentityRequest {
  Identity: string;
}

// refs: 1 - tags: named, input
export interface DeleteIdentityPolicyRequest {
  Identity: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeleteReceiptFilterRequest {
  FilterName: string;
}

// refs: 1 - tags: named, input
export interface DeleteReceiptRuleRequest {
  RuleSetName: string;
  RuleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteReceiptRuleSetRequest {
  RuleSetName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTemplateRequest {
  TemplateName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVerifiedEmailAddressRequest {
  EmailAddress: string;
}

// refs: 1 - tags: named, input
export interface DescribeActiveReceiptRuleSetRequest {
}

// refs: 1 - tags: named, input
export interface DescribeConfigurationSetRequest {
  ConfigurationSetName: string;
  ConfigurationSetAttributeNames?: ConfigurationSetAttribute[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeReceiptRuleRequest {
  RuleSetName: string;
  RuleName: string;
}

// refs: 1 - tags: named, input
export interface DescribeReceiptRuleSetRequest {
  RuleSetName: string;
}

// refs: 1 - tags: named, input
export interface GetCustomVerificationEmailTemplateRequest {
  TemplateName: string;
}

// refs: 1 - tags: named, input
export interface GetIdentityDkimAttributesRequest {
  Identities: string[];
}

// refs: 1 - tags: named, input
export interface GetIdentityMailFromDomainAttributesRequest {
  Identities: string[];
}

// refs: 1 - tags: named, input
export interface GetIdentityNotificationAttributesRequest {
  Identities: string[];
}

// refs: 1 - tags: named, input
export interface GetIdentityPoliciesRequest {
  Identity: string;
  PolicyNames: string[];
}

// refs: 1 - tags: named, input
export interface GetIdentityVerificationAttributesRequest {
  Identities: string[];
}

// refs: 1 - tags: named, input
export interface GetTemplateRequest {
  TemplateName: string;
}

// refs: 1 - tags: named, input
export interface ListConfigurationSetsRequest {
  NextToken?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListCustomVerificationEmailTemplatesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListIdentitiesRequest {
  IdentityType?: IdentityType | null;
  NextToken?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListIdentityPoliciesRequest {
  Identity: string;
}

// refs: 1 - tags: named, input
export interface ListReceiptFiltersRequest {
}

// refs: 1 - tags: named, input
export interface ListReceiptRuleSetsRequest {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTemplatesRequest {
  NextToken?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface PutConfigurationSetDeliveryOptionsRequest {
  ConfigurationSetName: string;
  DeliveryOptions?: DeliveryOptions | null;
}

// refs: 1 - tags: named, input
export interface PutIdentityPolicyRequest {
  Identity: string;
  PolicyName: string;
  Policy: string;
}

// refs: 1 - tags: named, input
export interface ReorderReceiptRuleSetRequest {
  RuleSetName: string;
  RuleNames: string[];
}

// refs: 1 - tags: named, input
export interface SendBounceRequest {
  OriginalMessageId: string;
  BounceSender: string;
  Explanation?: string | null;
  MessageDsn?: MessageDsn | null;
  BouncedRecipientInfoList: BouncedRecipientInfo[];
  BounceSenderArn?: string | null;
}

// refs: 1 - tags: named, input
export interface SendBulkTemplatedEmailRequest {
  Source: string;
  SourceArn?: string | null;
  ReplyToAddresses?: string[] | null;
  ReturnPath?: string | null;
  ReturnPathArn?: string | null;
  ConfigurationSetName?: string | null;
  DefaultTags?: MessageTag[] | null;
  Template: string;
  TemplateArn?: string | null;
  DefaultTemplateData?: string | null;
  Destinations: BulkEmailDestination[];
}

// refs: 1 - tags: named, input
export interface SendCustomVerificationEmailRequest {
  EmailAddress: string;
  TemplateName: string;
  ConfigurationSetName?: string | null;
}

// refs: 1 - tags: named, input
export interface SendEmailRequest {
  Source: string;
  Destination: Destination;
  Message: Message;
  ReplyToAddresses?: string[] | null;
  ReturnPath?: string | null;
  SourceArn?: string | null;
  ReturnPathArn?: string | null;
  Tags?: MessageTag[] | null;
  ConfigurationSetName?: string | null;
}

// refs: 1 - tags: named, input
export interface SendRawEmailRequest {
  Source?: string | null;
  Destinations?: string[] | null;
  RawMessage: RawMessage;
  FromArn?: string | null;
  SourceArn?: string | null;
  ReturnPathArn?: string | null;
  Tags?: MessageTag[] | null;
  ConfigurationSetName?: string | null;
}

// refs: 1 - tags: named, input
export interface SendTemplatedEmailRequest {
  Source: string;
  Destination: Destination;
  ReplyToAddresses?: string[] | null;
  ReturnPath?: string | null;
  SourceArn?: string | null;
  ReturnPathArn?: string | null;
  Tags?: MessageTag[] | null;
  ConfigurationSetName?: string | null;
  Template: string;
  TemplateArn?: string | null;
  TemplateData: string;
}

// refs: 1 - tags: named, input
export interface SetActiveReceiptRuleSetRequest {
  RuleSetName?: string | null;
}

// refs: 1 - tags: named, input
export interface SetIdentityDkimEnabledRequest {
  Identity: string;
  DkimEnabled: boolean;
}

// refs: 1 - tags: named, input
export interface SetIdentityFeedbackForwardingEnabledRequest {
  Identity: string;
  ForwardingEnabled: boolean;
}

// refs: 1 - tags: named, input
export interface SetIdentityHeadersInNotificationsEnabledRequest {
  Identity: string;
  NotificationType: NotificationType;
  Enabled: boolean;
}

// refs: 1 - tags: named, input
export interface SetIdentityMailFromDomainRequest {
  Identity: string;
  MailFromDomain?: string | null;
  BehaviorOnMXFailure?: BehaviorOnMXFailure | null;
}

// refs: 1 - tags: named, input
export interface SetIdentityNotificationTopicRequest {
  Identity: string;
  NotificationType: NotificationType;
  SnsTopic?: string | null;
}

// refs: 1 - tags: named, input
export interface SetReceiptRulePositionRequest {
  RuleSetName: string;
  RuleName: string;
  After?: string | null;
}

// refs: 1 - tags: named, input
export interface TestRenderTemplateRequest {
  TemplateName: string;
  TemplateData: string;
}

// refs: 1 - tags: named, input
export interface UpdateAccountSendingEnabledRequest {
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateConfigurationSetEventDestinationRequest {
  ConfigurationSetName: string;
  EventDestination: EventDestination;
}

// refs: 1 - tags: named, input
export interface UpdateConfigurationSetReputationMetricsEnabledRequest {
  ConfigurationSetName: string;
  Enabled: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateConfigurationSetSendingEnabledRequest {
  ConfigurationSetName: string;
  Enabled: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateConfigurationSetTrackingOptionsRequest {
  ConfigurationSetName: string;
  TrackingOptions: TrackingOptions;
}

// refs: 1 - tags: named, input
export interface UpdateCustomVerificationEmailTemplateRequest {
  TemplateName: string;
  FromEmailAddress?: string | null;
  TemplateSubject?: string | null;
  TemplateContent?: string | null;
  SuccessRedirectionURL?: string | null;
  FailureRedirectionURL?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateReceiptRuleRequest {
  RuleSetName: string;
  Rule: ReceiptRule;
}

// refs: 1 - tags: named, input
export interface UpdateTemplateRequest {
  Template: Template;
}

// refs: 1 - tags: named, input
export interface VerifyDomainDkimRequest {
  Domain: string;
}

// refs: 1 - tags: named, input
export interface VerifyDomainIdentityRequest {
  Domain: string;
}

// refs: 1 - tags: named, input
export interface VerifyEmailAddressRequest {
  EmailAddress: string;
}

// refs: 1 - tags: named, input
export interface VerifyEmailIdentityRequest {
  EmailAddress: string;
}

// refs: 1 - tags: named, output
export interface CloneReceiptRuleSetResponse {
}

// refs: 1 - tags: named, output
export interface CreateConfigurationSetResponse {
}

// refs: 1 - tags: named, output
export interface CreateConfigurationSetEventDestinationResponse {
}

// refs: 1 - tags: named, output
export interface CreateConfigurationSetTrackingOptionsResponse {
}

// refs: 1 - tags: named, output
export interface CreateReceiptFilterResponse {
}

// refs: 1 - tags: named, output
export interface CreateReceiptRuleResponse {
}

// refs: 1 - tags: named, output
export interface CreateReceiptRuleSetResponse {
}

// refs: 1 - tags: named, output
export interface CreateTemplateResponse {
}

// refs: 1 - tags: named, output
export interface DeleteConfigurationSetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteConfigurationSetEventDestinationResponse {
}

// refs: 1 - tags: named, output
export interface DeleteConfigurationSetTrackingOptionsResponse {
}

// refs: 1 - tags: named, output
export interface DeleteIdentityResponse {
}

// refs: 1 - tags: named, output
export interface DeleteIdentityPolicyResponse {
}

// refs: 1 - tags: named, output
export interface DeleteReceiptFilterResponse {
}

// refs: 1 - tags: named, output
export interface DeleteReceiptRuleResponse {
}

// refs: 1 - tags: named, output
export interface DeleteReceiptRuleSetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTemplateResponse {
}

// refs: 1 - tags: named, output
export interface DescribeActiveReceiptRuleSetResponse {
  Metadata?: ReceiptRuleSetMetadata | null;
  Rules: ReceiptRule[];
}

// refs: 1 - tags: named, output
export interface DescribeConfigurationSetResponse {
  ConfigurationSet?: ConfigurationSet | null;
  EventDestinations: EventDestination[];
  TrackingOptions?: TrackingOptions | null;
  DeliveryOptions?: DeliveryOptions | null;
  ReputationOptions?: ReputationOptions | null;
}

// refs: 1 - tags: named, output
export interface DescribeReceiptRuleResponse {
  Rule?: ReceiptRule | null;
}

// refs: 1 - tags: named, output
export interface DescribeReceiptRuleSetResponse {
  Metadata?: ReceiptRuleSetMetadata | null;
  Rules: ReceiptRule[];
}

// refs: 1 - tags: named, output
export interface GetAccountSendingEnabledResponse {
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, output
export interface GetCustomVerificationEmailTemplateResponse {
  TemplateName?: string | null;
  FromEmailAddress?: string | null;
  TemplateSubject?: string | null;
  TemplateContent?: string | null;
  SuccessRedirectionURL?: string | null;
  FailureRedirectionURL?: string | null;
}

// refs: 1 - tags: named, output
export interface GetIdentityDkimAttributesResponse {
  DkimAttributes: { [key: string]: IdentityDkimAttributes };
}

// refs: 1 - tags: named, output
export interface GetIdentityMailFromDomainAttributesResponse {
  MailFromDomainAttributes: { [key: string]: IdentityMailFromDomainAttributes };
}

// refs: 1 - tags: named, output
export interface GetIdentityNotificationAttributesResponse {
  NotificationAttributes: { [key: string]: IdentityNotificationAttributes };
}

// refs: 1 - tags: named, output
export interface GetIdentityPoliciesResponse {
  Policies: { [key: string]: string };
}

// refs: 1 - tags: named, output
export interface GetIdentityVerificationAttributesResponse {
  VerificationAttributes: { [key: string]: IdentityVerificationAttributes };
}

// refs: 1 - tags: named, output
export interface GetSendQuotaResponse {
  Max24HourSend?: number | null;
  MaxSendRate?: number | null;
  SentLast24Hours?: number | null;
}

// refs: 1 - tags: named, output
export interface GetSendStatisticsResponse {
  SendDataPoints: SendDataPoint[];
}

// refs: 1 - tags: named, output
export interface GetTemplateResponse {
  Template?: Template | null;
}

// refs: 1 - tags: named, output
export interface ListConfigurationSetsResponse {
  ConfigurationSets: ConfigurationSet[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCustomVerificationEmailTemplatesResponse {
  CustomVerificationEmailTemplates: CustomVerificationEmailTemplate[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListIdentitiesResponse {
  Identities: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListIdentityPoliciesResponse {
  PolicyNames: string[];
}

// refs: 1 - tags: named, output
export interface ListReceiptFiltersResponse {
  Filters: ReceiptFilter[];
}

// refs: 1 - tags: named, output
export interface ListReceiptRuleSetsResponse {
  RuleSets: ReceiptRuleSetMetadata[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTemplatesResponse {
  TemplatesMetadata: TemplateMetadata[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListVerifiedEmailAddressesResponse {
  VerifiedEmailAddresses: string[];
}

// refs: 1 - tags: named, output
export interface PutConfigurationSetDeliveryOptionsResponse {
}

// refs: 1 - tags: named, output
export interface PutIdentityPolicyResponse {
}

// refs: 1 - tags: named, output
export interface ReorderReceiptRuleSetResponse {
}

// refs: 1 - tags: named, output
export interface SendBounceResponse {
  MessageId?: string | null;
}

// refs: 1 - tags: named, output
export interface SendBulkTemplatedEmailResponse {
  Status: BulkEmailDestinationStatus[];
}

// refs: 1 - tags: named, output
export interface SendCustomVerificationEmailResponse {
  MessageId?: string | null;
}

// refs: 1 - tags: named, output
export interface SendEmailResponse {
  MessageId: string;
}

// refs: 1 - tags: named, output
export interface SendRawEmailResponse {
  MessageId: string;
}

// refs: 1 - tags: named, output
export interface SendTemplatedEmailResponse {
  MessageId: string;
}

// refs: 1 - tags: named, output
export interface SetActiveReceiptRuleSetResponse {
}

// refs: 1 - tags: named, output
export interface SetIdentityDkimEnabledResponse {
}

// refs: 1 - tags: named, output
export interface SetIdentityFeedbackForwardingEnabledResponse {
}

// refs: 1 - tags: named, output
export interface SetIdentityHeadersInNotificationsEnabledResponse {
}

// refs: 1 - tags: named, output
export interface SetIdentityMailFromDomainResponse {
}

// refs: 1 - tags: named, output
export interface SetIdentityNotificationTopicResponse {
}

// refs: 1 - tags: named, output
export interface SetReceiptRulePositionResponse {
}

// refs: 1 - tags: named, output
export interface TestRenderTemplateResponse {
  RenderedTemplate?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateConfigurationSetEventDestinationResponse {
}

// refs: 1 - tags: named, output
export interface UpdateConfigurationSetTrackingOptionsResponse {
}

// refs: 1 - tags: named, output
export interface UpdateReceiptRuleResponse {
}

// refs: 1 - tags: named, output
export interface UpdateTemplateResponse {
}

// refs: 1 - tags: named, output
export interface VerifyDomainDkimResponse {
  DkimTokens: string[];
}

// refs: 1 - tags: named, output
export interface VerifyDomainIdentityResponse {
  VerificationToken: string;
}

// refs: 1 - tags: named, output
export interface VerifyEmailIdentityResponse {
}

// refs: 3 - tags: input, named, interface, output
export interface ConfigurationSet {
  Name: string;
}
function ConfigurationSet_Serialize(body: URLSearchParams, prefix: string, params: ConfigurationSet) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
}
function ConfigurationSet_Parse(node: XmlNode): ConfigurationSet {
  return node.strings({
    required: {"Name":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface EventDestination {
  Name: string;
  Enabled?: boolean | null;
  MatchingEventTypes: EventType[];
  KinesisFirehoseDestination?: KinesisFirehoseDestination | null;
  CloudWatchDestination?: CloudWatchDestination | null;
  SNSDestination?: SNSDestination | null;
}
function EventDestination_Serialize(body: URLSearchParams, prefix: string, params: EventDestination) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if (params["MatchingEventTypes"]) prt.appendList(body, prefix+".MatchingEventTypes", params["MatchingEventTypes"], {"entryPrefix":".member."})
    if (params["KinesisFirehoseDestination"] != null) KinesisFirehoseDestination_Serialize(body, prefix+".KinesisFirehoseDestination", params["KinesisFirehoseDestination"]);
    if (params["CloudWatchDestination"] != null) CloudWatchDestination_Serialize(body, prefix+".CloudWatchDestination", params["CloudWatchDestination"]);
    if (params["SNSDestination"] != null) SNSDestination_Serialize(body, prefix+".SNSDestination", params["SNSDestination"]);
}
function EventDestination_Parse(node: XmlNode): EventDestination {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    MatchingEventTypes: node.getList("MatchingEventTypes", "member").map(x => (x.content ?? '') as EventType),
    KinesisFirehoseDestination: node.first("KinesisFirehoseDestination", false, KinesisFirehoseDestination_Parse),
    CloudWatchDestination: node.first("CloudWatchDestination", false, CloudWatchDestination_Parse),
    SNSDestination: node.first("SNSDestination", false, SNSDestination_Parse),
  };
}

// refs: 3 - tags: input, named, enum, output
export type EventType =
| "send"
| "reject"
| "bounce"
| "complaint"
| "delivery"
| "open"
| "click"
| "renderingFailure"
;



// refs: 3 - tags: input, named, interface, output
export interface KinesisFirehoseDestination {
  IAMRoleARN: string;
  DeliveryStreamARN: string;
}
function KinesisFirehoseDestination_Serialize(body: URLSearchParams, prefix: string, params: KinesisFirehoseDestination) {
    body.append(prefix+".IAMRoleARN", (params["IAMRoleARN"] ?? '').toString());
    body.append(prefix+".DeliveryStreamARN", (params["DeliveryStreamARN"] ?? '').toString());
}
function KinesisFirehoseDestination_Parse(node: XmlNode): KinesisFirehoseDestination {
  return node.strings({
    required: {"IAMRoleARN":true,"DeliveryStreamARN":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface CloudWatchDestination {
  DimensionConfigurations: CloudWatchDimensionConfiguration[];
}
function CloudWatchDestination_Serialize(body: URLSearchParams, prefix: string, params: CloudWatchDestination) {
    if (params["DimensionConfigurations"]) prt.appendList(body, prefix+".DimensionConfigurations", params["DimensionConfigurations"], {"appender":CloudWatchDimensionConfiguration_Serialize,"entryPrefix":".member."})
}
function CloudWatchDestination_Parse(node: XmlNode): CloudWatchDestination {
  return {
    DimensionConfigurations: node.getList("DimensionConfigurations", "member").map(CloudWatchDimensionConfiguration_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface CloudWatchDimensionConfiguration {
  DimensionName: string;
  DimensionValueSource: DimensionValueSource;
  DefaultDimensionValue: string;
}
function CloudWatchDimensionConfiguration_Serialize(body: URLSearchParams, prefix: string, params: CloudWatchDimensionConfiguration) {
    body.append(prefix+".DimensionName", (params["DimensionName"] ?? '').toString());
    body.append(prefix+".DimensionValueSource", (params["DimensionValueSource"] ?? '').toString());
    body.append(prefix+".DefaultDimensionValue", (params["DefaultDimensionValue"] ?? '').toString());
}
function CloudWatchDimensionConfiguration_Parse(node: XmlNode): CloudWatchDimensionConfiguration {
  return {
    ...node.strings({
      required: {"DimensionName":true,"DefaultDimensionValue":true},
    }),
    DimensionValueSource: node.first("DimensionValueSource", true, x => (x.content ?? '') as DimensionValueSource),
  };
}

// refs: 3 - tags: input, named, enum, output
export type DimensionValueSource =
| "messageTag"
| "emailHeader"
| "linkTag"
;



// refs: 3 - tags: input, named, interface, output
export interface SNSDestination {
  TopicARN: string;
}
function SNSDestination_Serialize(body: URLSearchParams, prefix: string, params: SNSDestination) {
    body.append(prefix+".TopicARN", (params["TopicARN"] ?? '').toString());
}
function SNSDestination_Parse(node: XmlNode): SNSDestination {
  return node.strings({
    required: {"TopicARN":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface TrackingOptions {
  CustomRedirectDomain?: string | null;
}
function TrackingOptions_Serialize(body: URLSearchParams, prefix: string, params: TrackingOptions) {
    if ("CustomRedirectDomain" in params) body.append(prefix+".CustomRedirectDomain", (params["CustomRedirectDomain"] ?? '').toString());
}
function TrackingOptions_Parse(node: XmlNode): TrackingOptions {
  return node.strings({
    optional: {"CustomRedirectDomain":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface ReceiptFilter {
  Name: string;
  IpFilter: ReceiptIpFilter;
}
function ReceiptFilter_Serialize(body: URLSearchParams, prefix: string, params: ReceiptFilter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    ReceiptIpFilter_Serialize(body, prefix+".IpFilter", params["IpFilter"]);
}
function ReceiptFilter_Parse(node: XmlNode): ReceiptFilter {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    IpFilter: node.first("IpFilter", true, ReceiptIpFilter_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface ReceiptIpFilter {
  Policy: ReceiptFilterPolicy;
  Cidr: string;
}
function ReceiptIpFilter_Serialize(body: URLSearchParams, prefix: string, params: ReceiptIpFilter) {
    body.append(prefix+".Policy", (params["Policy"] ?? '').toString());
    body.append(prefix+".Cidr", (params["Cidr"] ?? '').toString());
}
function ReceiptIpFilter_Parse(node: XmlNode): ReceiptIpFilter {
  return {
    ...node.strings({
      required: {"Cidr":true},
    }),
    Policy: node.first("Policy", true, x => (x.content ?? '') as ReceiptFilterPolicy),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ReceiptFilterPolicy =
| "Block"
| "Allow"
;



// refs: 5 - tags: input, named, interface, output
export interface ReceiptRule {
  Name: string;
  Enabled?: boolean | null;
  TlsPolicy?: TlsPolicy | null;
  Recipients: string[];
  Actions: ReceiptAction[];
  ScanEnabled?: boolean | null;
}
function ReceiptRule_Serialize(body: URLSearchParams, prefix: string, params: ReceiptRule) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("TlsPolicy" in params) body.append(prefix+".TlsPolicy", (params["TlsPolicy"] ?? '').toString());
    if (params["Recipients"]) prt.appendList(body, prefix+".Recipients", params["Recipients"], {"entryPrefix":".member."})
    if (params["Actions"]) prt.appendList(body, prefix+".Actions", params["Actions"], {"appender":ReceiptAction_Serialize,"entryPrefix":".member."})
    if ("ScanEnabled" in params) body.append(prefix+".ScanEnabled", (params["ScanEnabled"] ?? '').toString());
}
function ReceiptRule_Parse(node: XmlNode): ReceiptRule {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    TlsPolicy: node.first("TlsPolicy", false, x => (x.content ?? '') as TlsPolicy),
    Recipients: node.getList("Recipients", "member").map(x => x.content ?? ''),
    Actions: node.getList("Actions", "member").map(ReceiptAction_Parse),
    ScanEnabled: node.first("ScanEnabled", false, x => x.content === 'true'),
  };
}

// refs: 7 - tags: input, named, enum, output
export type TlsPolicy =
| "Require"
| "Optional"
;



// refs: 5 - tags: input, named, interface, output
export interface ReceiptAction {
  S3Action?: S3Action | null;
  BounceAction?: BounceAction | null;
  WorkmailAction?: WorkmailAction | null;
  LambdaAction?: LambdaAction | null;
  StopAction?: StopAction | null;
  AddHeaderAction?: AddHeaderAction | null;
  SNSAction?: SNSAction | null;
}
function ReceiptAction_Serialize(body: URLSearchParams, prefix: string, params: ReceiptAction) {
    if (params["S3Action"] != null) S3Action_Serialize(body, prefix+".S3Action", params["S3Action"]);
    if (params["BounceAction"] != null) BounceAction_Serialize(body, prefix+".BounceAction", params["BounceAction"]);
    if (params["WorkmailAction"] != null) WorkmailAction_Serialize(body, prefix+".WorkmailAction", params["WorkmailAction"]);
    if (params["LambdaAction"] != null) LambdaAction_Serialize(body, prefix+".LambdaAction", params["LambdaAction"]);
    if (params["StopAction"] != null) StopAction_Serialize(body, prefix+".StopAction", params["StopAction"]);
    if (params["AddHeaderAction"] != null) AddHeaderAction_Serialize(body, prefix+".AddHeaderAction", params["AddHeaderAction"]);
    if (params["SNSAction"] != null) SNSAction_Serialize(body, prefix+".SNSAction", params["SNSAction"]);
}
function ReceiptAction_Parse(node: XmlNode): ReceiptAction {
  return {
    S3Action: node.first("S3Action", false, S3Action_Parse),
    BounceAction: node.first("BounceAction", false, BounceAction_Parse),
    WorkmailAction: node.first("WorkmailAction", false, WorkmailAction_Parse),
    LambdaAction: node.first("LambdaAction", false, LambdaAction_Parse),
    StopAction: node.first("StopAction", false, StopAction_Parse),
    AddHeaderAction: node.first("AddHeaderAction", false, AddHeaderAction_Parse),
    SNSAction: node.first("SNSAction", false, SNSAction_Parse),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface S3Action {
  TopicArn?: string | null;
  BucketName: string;
  ObjectKeyPrefix?: string | null;
  KmsKeyArn?: string | null;
}
function S3Action_Serialize(body: URLSearchParams, prefix: string, params: S3Action) {
    if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
    body.append(prefix+".BucketName", (params["BucketName"] ?? '').toString());
    if ("ObjectKeyPrefix" in params) body.append(prefix+".ObjectKeyPrefix", (params["ObjectKeyPrefix"] ?? '').toString());
    if ("KmsKeyArn" in params) body.append(prefix+".KmsKeyArn", (params["KmsKeyArn"] ?? '').toString());
}
function S3Action_Parse(node: XmlNode): S3Action {
  return node.strings({
    required: {"BucketName":true},
    optional: {"TopicArn":true,"ObjectKeyPrefix":true,"KmsKeyArn":true},
  });
}

// refs: 5 - tags: input, named, interface, output
export interface BounceAction {
  TopicArn?: string | null;
  SmtpReplyCode: string;
  StatusCode?: string | null;
  Message: string;
  Sender: string;
}
function BounceAction_Serialize(body: URLSearchParams, prefix: string, params: BounceAction) {
    if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
    body.append(prefix+".SmtpReplyCode", (params["SmtpReplyCode"] ?? '').toString());
    if ("StatusCode" in params) body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
    body.append(prefix+".Message", (params["Message"] ?? '').toString());
    body.append(prefix+".Sender", (params["Sender"] ?? '').toString());
}
function BounceAction_Parse(node: XmlNode): BounceAction {
  return node.strings({
    required: {"SmtpReplyCode":true,"Message":true,"Sender":true},
    optional: {"TopicArn":true,"StatusCode":true},
  });
}

// refs: 5 - tags: input, named, interface, output
export interface WorkmailAction {
  TopicArn?: string | null;
  OrganizationArn: string;
}
function WorkmailAction_Serialize(body: URLSearchParams, prefix: string, params: WorkmailAction) {
    if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
    body.append(prefix+".OrganizationArn", (params["OrganizationArn"] ?? '').toString());
}
function WorkmailAction_Parse(node: XmlNode): WorkmailAction {
  return node.strings({
    required: {"OrganizationArn":true},
    optional: {"TopicArn":true},
  });
}

// refs: 5 - tags: input, named, interface, output
export interface LambdaAction {
  TopicArn?: string | null;
  FunctionArn: string;
  InvocationType?: InvocationType | null;
}
function LambdaAction_Serialize(body: URLSearchParams, prefix: string, params: LambdaAction) {
    if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
    body.append(prefix+".FunctionArn", (params["FunctionArn"] ?? '').toString());
    if ("InvocationType" in params) body.append(prefix+".InvocationType", (params["InvocationType"] ?? '').toString());
}
function LambdaAction_Parse(node: XmlNode): LambdaAction {
  return {
    ...node.strings({
      required: {"FunctionArn":true},
      optional: {"TopicArn":true},
    }),
    InvocationType: node.first("InvocationType", false, x => (x.content ?? '') as InvocationType),
  };
}

// refs: 5 - tags: input, named, enum, output
export type InvocationType =
| "Event"
| "RequestResponse"
;



// refs: 5 - tags: input, named, interface, output
export interface StopAction {
  Scope: StopScope;
  TopicArn?: string | null;
}
function StopAction_Serialize(body: URLSearchParams, prefix: string, params: StopAction) {
    body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
    if ("TopicArn" in params) body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
}
function StopAction_Parse(node: XmlNode): StopAction {
  return {
    ...node.strings({
      optional: {"TopicArn":true},
    }),
    Scope: node.first("Scope", true, x => (x.content ?? '') as StopScope),
  };
}

// refs: 5 - tags: input, named, enum, output
export type StopScope =
| "RuleSet"
;



// refs: 5 - tags: input, named, interface, output
export interface AddHeaderAction {
  HeaderName: string;
  HeaderValue: string;
}
function AddHeaderAction_Serialize(body: URLSearchParams, prefix: string, params: AddHeaderAction) {
    body.append(prefix+".HeaderName", (params["HeaderName"] ?? '').toString());
    body.append(prefix+".HeaderValue", (params["HeaderValue"] ?? '').toString());
}
function AddHeaderAction_Parse(node: XmlNode): AddHeaderAction {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

// refs: 5 - tags: input, named, interface, output
export interface SNSAction {
  TopicArn: string;
  Encoding?: SNSActionEncoding | null;
}
function SNSAction_Serialize(body: URLSearchParams, prefix: string, params: SNSAction) {
    body.append(prefix+".TopicArn", (params["TopicArn"] ?? '').toString());
    if ("Encoding" in params) body.append(prefix+".Encoding", (params["Encoding"] ?? '').toString());
}
function SNSAction_Parse(node: XmlNode): SNSAction {
  return {
    ...node.strings({
      required: {"TopicArn":true},
    }),
    Encoding: node.first("Encoding", false, x => (x.content ?? '') as SNSActionEncoding),
  };
}

// refs: 5 - tags: input, named, enum, output
export type SNSActionEncoding =
| "UTF-8"
| "Base64"
;



// refs: 3 - tags: input, named, interface, output
export interface Template {
  TemplateName: string;
  SubjectPart?: string | null;
  TextPart?: string | null;
  HtmlPart?: string | null;
}
function Template_Serialize(body: URLSearchParams, prefix: string, params: Template) {
    body.append(prefix+".TemplateName", (params["TemplateName"] ?? '').toString());
    if ("SubjectPart" in params) body.append(prefix+".SubjectPart", (params["SubjectPart"] ?? '').toString());
    if ("TextPart" in params) body.append(prefix+".TextPart", (params["TextPart"] ?? '').toString());
    if ("HtmlPart" in params) body.append(prefix+".HtmlPart", (params["HtmlPart"] ?? '').toString());
}
function Template_Parse(node: XmlNode): Template {
  return node.strings({
    required: {"TemplateName":true},
    optional: {"SubjectPart":true,"TextPart":true,"HtmlPart":true},
  });
}

// refs: 1 - tags: input, named, enum
export type ConfigurationSetAttribute =
| "eventDestinations"
| "trackingOptions"
| "deliveryOptions"
| "reputationOptions"
;


// refs: 1 - tags: input, named, enum
export type IdentityType =
| "EmailAddress"
| "Domain"
;


// refs: 2 - tags: input, named, interface, output
export interface DeliveryOptions {
  TlsPolicy?: TlsPolicy | null;
}
function DeliveryOptions_Serialize(body: URLSearchParams, prefix: string, params: DeliveryOptions) {
    if ("TlsPolicy" in params) body.append(prefix+".TlsPolicy", (params["TlsPolicy"] ?? '').toString());
}
function DeliveryOptions_Parse(node: XmlNode): DeliveryOptions {
  return {
    TlsPolicy: node.first("TlsPolicy", false, x => (x.content ?? '') as TlsPolicy),
  };
}

// refs: 1 - tags: input, named, interface
export interface MessageDsn {
  ReportingMta: string;
  ArrivalDate?: Date | number | null;
  ExtensionFields?: ExtensionField[] | null;
}
function MessageDsn_Serialize(body: URLSearchParams, prefix: string, params: MessageDsn) {
    body.append(prefix+".ReportingMta", (params["ReportingMta"] ?? '').toString());
    if ("ArrivalDate" in params) body.append(prefix+".ArrivalDate", prt.encodeDate_iso8601(params["ArrivalDate"]));
    if (params["ExtensionFields"]) prt.appendList(body, prefix+".ExtensionFields", params["ExtensionFields"], {"appender":ExtensionField_Serialize,"entryPrefix":".member."})
}

// refs: 2 - tags: input, named, interface
export interface ExtensionField {
  Name: string;
  Value: string;
}
function ExtensionField_Serialize(body: URLSearchParams, prefix: string, params: ExtensionField) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface BouncedRecipientInfo {
  Recipient: string;
  RecipientArn?: string | null;
  BounceType?: BounceType | null;
  RecipientDsnFields?: RecipientDsnFields | null;
}
function BouncedRecipientInfo_Serialize(body: URLSearchParams, prefix: string, params: BouncedRecipientInfo) {
    body.append(prefix+".Recipient", (params["Recipient"] ?? '').toString());
    if ("RecipientArn" in params) body.append(prefix+".RecipientArn", (params["RecipientArn"] ?? '').toString());
    if ("BounceType" in params) body.append(prefix+".BounceType", (params["BounceType"] ?? '').toString());
    if (params["RecipientDsnFields"] != null) RecipientDsnFields_Serialize(body, prefix+".RecipientDsnFields", params["RecipientDsnFields"]);
}

// refs: 1 - tags: input, named, enum
export type BounceType =
| "DoesNotExist"
| "MessageTooLarge"
| "ExceededQuota"
| "ContentRejected"
| "Undefined"
| "TemporaryFailure"
;


// refs: 1 - tags: input, named, interface
export interface RecipientDsnFields {
  FinalRecipient?: string | null;
  Action: DsnAction;
  RemoteMta?: string | null;
  Status: string;
  DiagnosticCode?: string | null;
  LastAttemptDate?: Date | number | null;
  ExtensionFields?: ExtensionField[] | null;
}
function RecipientDsnFields_Serialize(body: URLSearchParams, prefix: string, params: RecipientDsnFields) {
    if ("FinalRecipient" in params) body.append(prefix+".FinalRecipient", (params["FinalRecipient"] ?? '').toString());
    body.append(prefix+".Action", (params["Action"] ?? '').toString());
    if ("RemoteMta" in params) body.append(prefix+".RemoteMta", (params["RemoteMta"] ?? '').toString());
    body.append(prefix+".Status", (params["Status"] ?? '').toString());
    if ("DiagnosticCode" in params) body.append(prefix+".DiagnosticCode", (params["DiagnosticCode"] ?? '').toString());
    if ("LastAttemptDate" in params) body.append(prefix+".LastAttemptDate", prt.encodeDate_iso8601(params["LastAttemptDate"]));
    if (params["ExtensionFields"]) prt.appendList(body, prefix+".ExtensionFields", params["ExtensionFields"], {"appender":ExtensionField_Serialize,"entryPrefix":".member."})
}

// refs: 1 - tags: input, named, enum
export type DsnAction =
| "failed"
| "delayed"
| "delivered"
| "relayed"
| "expanded"
;


// refs: 5 - tags: input, named, interface
export interface MessageTag {
  Name: string;
  Value: string;
}
function MessageTag_Serialize(body: URLSearchParams, prefix: string, params: MessageTag) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface BulkEmailDestination {
  Destination: Destination;
  ReplacementTags?: MessageTag[] | null;
  ReplacementTemplateData?: string | null;
}
function BulkEmailDestination_Serialize(body: URLSearchParams, prefix: string, params: BulkEmailDestination) {
    Destination_Serialize(body, prefix+".Destination", params["Destination"]);
    if (params["ReplacementTags"]) prt.appendList(body, prefix+".ReplacementTags", params["ReplacementTags"], {"appender":MessageTag_Serialize,"entryPrefix":".member."})
    if ("ReplacementTemplateData" in params) body.append(prefix+".ReplacementTemplateData", (params["ReplacementTemplateData"] ?? '').toString());
}

// refs: 3 - tags: input, named, interface
export interface Destination {
  ToAddresses?: string[] | null;
  CcAddresses?: string[] | null;
  BccAddresses?: string[] | null;
}
function Destination_Serialize(body: URLSearchParams, prefix: string, params: Destination) {
    if (params["ToAddresses"]) prt.appendList(body, prefix+".ToAddresses", params["ToAddresses"], {"entryPrefix":".member."})
    if (params["CcAddresses"]) prt.appendList(body, prefix+".CcAddresses", params["CcAddresses"], {"entryPrefix":".member."})
    if (params["BccAddresses"]) prt.appendList(body, prefix+".BccAddresses", params["BccAddresses"], {"entryPrefix":".member."})
}

// refs: 1 - tags: input, named, interface
export interface Message {
  Subject: Content;
  Body: Body;
}
function Message_Serialize(body: URLSearchParams, prefix: string, params: Message) {
    Content_Serialize(body, prefix+".Subject", params["Subject"]);
    Body_Serialize(body, prefix+".Body", params["Body"]);
}

// refs: 3 - tags: input, named, interface
export interface Content {
  Data: string;
  Charset?: string | null;
}
function Content_Serialize(body: URLSearchParams, prefix: string, params: Content) {
    body.append(prefix+".Data", (params["Data"] ?? '').toString());
    if ("Charset" in params) body.append(prefix+".Charset", (params["Charset"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface Body {
  Text?: Content | null;
  Html?: Content | null;
}
function Body_Serialize(body: URLSearchParams, prefix: string, params: Body) {
    if (params["Text"] != null) Content_Serialize(body, prefix+".Text", params["Text"]);
    if (params["Html"] != null) Content_Serialize(body, prefix+".Html", params["Html"]);
}

// refs: 1 - tags: input, named, interface
export interface RawMessage {
  Data: Uint8Array | string;
}
function RawMessage_Serialize(body: URLSearchParams, prefix: string, params: RawMessage) {
    body.append(prefix+".Data", prt.encodeBlob(params["Data"]));
}

// refs: 2 - tags: input, named, enum
export type NotificationType =
| "Bounce"
| "Complaint"
| "Delivery"
;


// refs: 2 - tags: input, named, enum, output
export type BehaviorOnMXFailure =
| "UseDefaultValue"
| "RejectMessage"
;



// refs: 3 - tags: output, named, interface
export interface ReceiptRuleSetMetadata {
  Name?: string | null;
  CreatedTimestamp?: Date | number | null;
}
function ReceiptRuleSetMetadata_Parse(node: XmlNode): ReceiptRuleSetMetadata {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreatedTimestamp: node.first("CreatedTimestamp", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReputationOptions {
  SendingEnabled?: boolean | null;
  ReputationMetricsEnabled?: boolean | null;
  LastFreshStart?: Date | number | null;
}
function ReputationOptions_Parse(node: XmlNode): ReputationOptions {
  return {
    SendingEnabled: node.first("SendingEnabled", false, x => x.content === 'true'),
    ReputationMetricsEnabled: node.first("ReputationMetricsEnabled", false, x => x.content === 'true'),
    LastFreshStart: node.first("LastFreshStart", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface IdentityDkimAttributes {
  DkimEnabled: boolean;
  DkimVerificationStatus: VerificationStatus;
  DkimTokens: string[];
}
function IdentityDkimAttributes_Parse(node: XmlNode): IdentityDkimAttributes {
  return {
    DkimEnabled: node.first("DkimEnabled", true, x => x.content === 'true'),
    DkimVerificationStatus: node.first("DkimVerificationStatus", true, x => (x.content ?? '') as VerificationStatus),
    DkimTokens: node.getList("DkimTokens", "member").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, enum
export type VerificationStatus =
| "Pending"
| "Success"
| "Failed"
| "TemporaryFailure"
| "NotStarted"
;


// refs: 1 - tags: output, named, interface
export interface IdentityMailFromDomainAttributes {
  MailFromDomain: string;
  MailFromDomainStatus: CustomMailFromStatus;
  BehaviorOnMXFailure: BehaviorOnMXFailure;
}
function IdentityMailFromDomainAttributes_Parse(node: XmlNode): IdentityMailFromDomainAttributes {
  return {
    ...node.strings({
      required: {"MailFromDomain":true},
    }),
    MailFromDomainStatus: node.first("MailFromDomainStatus", true, x => (x.content ?? '') as CustomMailFromStatus),
    BehaviorOnMXFailure: node.first("BehaviorOnMXFailure", true, x => (x.content ?? '') as BehaviorOnMXFailure),
  };
}

// refs: 1 - tags: output, named, enum
export type CustomMailFromStatus =
| "Pending"
| "Success"
| "Failed"
| "TemporaryFailure"
;


// refs: 1 - tags: output, named, interface
export interface IdentityNotificationAttributes {
  BounceTopic: string;
  ComplaintTopic: string;
  DeliveryTopic: string;
  ForwardingEnabled: boolean;
  HeadersInBounceNotificationsEnabled?: boolean | null;
  HeadersInComplaintNotificationsEnabled?: boolean | null;
  HeadersInDeliveryNotificationsEnabled?: boolean | null;
}
function IdentityNotificationAttributes_Parse(node: XmlNode): IdentityNotificationAttributes {
  return {
    ...node.strings({
      required: {"BounceTopic":true,"ComplaintTopic":true,"DeliveryTopic":true},
    }),
    ForwardingEnabled: node.first("ForwardingEnabled", true, x => x.content === 'true'),
    HeadersInBounceNotificationsEnabled: node.first("HeadersInBounceNotificationsEnabled", false, x => x.content === 'true'),
    HeadersInComplaintNotificationsEnabled: node.first("HeadersInComplaintNotificationsEnabled", false, x => x.content === 'true'),
    HeadersInDeliveryNotificationsEnabled: node.first("HeadersInDeliveryNotificationsEnabled", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface IdentityVerificationAttributes {
  VerificationStatus: VerificationStatus;
  VerificationToken?: string | null;
}
function IdentityVerificationAttributes_Parse(node: XmlNode): IdentityVerificationAttributes {
  return {
    ...node.strings({
      optional: {"VerificationToken":true},
    }),
    VerificationStatus: node.first("VerificationStatus", true, x => (x.content ?? '') as VerificationStatus),
  };
}

// refs: 1 - tags: output, named, interface
export interface SendDataPoint {
  Timestamp?: Date | number | null;
  DeliveryAttempts?: number | null;
  Bounces?: number | null;
  Complaints?: number | null;
  Rejects?: number | null;
}
function SendDataPoint_Parse(node: XmlNode): SendDataPoint {
  return {
    Timestamp: node.first("Timestamp", false, x => parseTimestamp(x.content)),
    DeliveryAttempts: node.first("DeliveryAttempts", false, x => parseInt(x.content ?? '0')),
    Bounces: node.first("Bounces", false, x => parseInt(x.content ?? '0')),
    Complaints: node.first("Complaints", false, x => parseInt(x.content ?? '0')),
    Rejects: node.first("Rejects", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface CustomVerificationEmailTemplate {
  TemplateName?: string | null;
  FromEmailAddress?: string | null;
  TemplateSubject?: string | null;
  SuccessRedirectionURL?: string | null;
  FailureRedirectionURL?: string | null;
}
function CustomVerificationEmailTemplate_Parse(node: XmlNode): CustomVerificationEmailTemplate {
  return node.strings({
    optional: {"TemplateName":true,"FromEmailAddress":true,"TemplateSubject":true,"SuccessRedirectionURL":true,"FailureRedirectionURL":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface TemplateMetadata {
  Name?: string | null;
  CreatedTimestamp?: Date | number | null;
}
function TemplateMetadata_Parse(node: XmlNode): TemplateMetadata {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreatedTimestamp: node.first("CreatedTimestamp", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface BulkEmailDestinationStatus {
  Status?: BulkEmailStatus | null;
  Error?: string | null;
  MessageId?: string | null;
}
function BulkEmailDestinationStatus_Parse(node: XmlNode): BulkEmailDestinationStatus {
  return {
    ...node.strings({
      optional: {"Error":true,"MessageId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as BulkEmailStatus),
  };
}

// refs: 1 - tags: output, named, enum
export type BulkEmailStatus =
| "Success"
| "MessageRejected"
| "MailFromDomainNotVerified"
| "ConfigurationSetDoesNotExist"
| "TemplateDoesNotExist"
| "AccountSuspended"
| "AccountThrottled"
| "AccountDailyQuotaExceeded"
| "InvalidSendingPoolName"
| "AccountSendingPaused"
| "ConfigurationSetSendingPaused"
| "InvalidParameterValue"
| "TransientFailure"
| "Failed"
;

