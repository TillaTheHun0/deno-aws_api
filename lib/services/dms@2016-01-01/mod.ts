// Autogenerated API client for: AWS Database Migration Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class DMS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DMS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-01-01",
    "endpointPrefix": "dms",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Database Migration Service",
    "serviceId": "Database Migration Service",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonDMSv20160101",
    "uid": "dms-2016-01-01"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceMessage,
  ): Promise<AddTagsToResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async applyPendingMaintenanceAction(
    {abortSignal, ...params}: RequestConfig & ApplyPendingMaintenanceActionMessage,
  ): Promise<ApplyPendingMaintenanceActionResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      ApplyAction: params["ApplyAction"],
      OptInType: params["OptInType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyPendingMaintenanceAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourcePendingMaintenanceActions": toResourcePendingMaintenanceActions,
      },
    }, await resp.json());
  }

  async cancelReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & CancelReplicationTaskAssessmentRunMessage,
  ): Promise<CancelReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskAssessmentRunArn: params["ReplicationTaskAssessmentRunArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async createEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateEndpointMessage,
  ): Promise<CreateEndpointResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointIdentifier: params["EndpointIdentifier"],
      EndpointType: params["EndpointType"],
      EngineName: params["EngineName"],
      Username: params["Username"],
      Password: params["Password"],
      ServerName: params["ServerName"],
      Port: params["Port"],
      DatabaseName: params["DatabaseName"],
      ExtraConnectionAttributes: params["ExtraConnectionAttributes"],
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      CertificateArn: params["CertificateArn"],
      SslMode: params["SslMode"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ExternalTableDefinition: params["ExternalTableDefinition"],
      DynamoDbSettings: fromDynamoDbSettings(params["DynamoDbSettings"]),
      S3Settings: fromS3Settings(params["S3Settings"]),
      DmsTransferSettings: fromDmsTransferSettings(params["DmsTransferSettings"]),
      MongoDbSettings: fromMongoDbSettings(params["MongoDbSettings"]),
      KinesisSettings: fromKinesisSettings(params["KinesisSettings"]),
      KafkaSettings: fromKafkaSettings(params["KafkaSettings"]),
      ElasticsearchSettings: fromElasticsearchSettings(params["ElasticsearchSettings"]),
      NeptuneSettings: fromNeptuneSettings(params["NeptuneSettings"]),
      RedshiftSettings: fromRedshiftSettings(params["RedshiftSettings"]),
      PostgreSQLSettings: fromPostgreSQLSettings(params["PostgreSQLSettings"]),
      MySQLSettings: fromMySQLSettings(params["MySQLSettings"]),
      OracleSettings: fromOracleSettings(params["OracleSettings"]),
      SybaseSettings: fromSybaseSettings(params["SybaseSettings"]),
      MicrosoftSQLServerSettings: fromMicrosoftSQLServerSettings(params["MicrosoftSQLServerSettings"]),
      IBMDb2Settings: fromIBMDb2Settings(params["IBMDb2Settings"]),
      ResourceIdentifier: params["ResourceIdentifier"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & CreateEventSubscriptionMessage,
  ): Promise<CreateEventSubscriptionResponse> {
    const body: jsonP.JSONObject = params ? {
      SubscriptionName: params["SubscriptionName"],
      SnsTopicArn: params["SnsTopicArn"],
      SourceType: params["SourceType"],
      EventCategories: params["EventCategories"],
      SourceIds: params["SourceIds"],
      Enabled: params["Enabled"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async createReplicationInstance(
    {abortSignal, ...params}: RequestConfig & CreateReplicationInstanceMessage,
  ): Promise<CreateReplicationInstanceResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceIdentifier: params["ReplicationInstanceIdentifier"],
      AllocatedStorage: params["AllocatedStorage"],
      ReplicationInstanceClass: params["ReplicationInstanceClass"],
      VpcSecurityGroupIds: params["VpcSecurityGroupIds"],
      AvailabilityZone: params["AvailabilityZone"],
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      MultiAZ: params["MultiAZ"],
      EngineVersion: params["EngineVersion"],
      AutoMinorVersionUpgrade: params["AutoMinorVersionUpgrade"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KmsKeyId: params["KmsKeyId"],
      PubliclyAccessible: params["PubliclyAccessible"],
      DnsNameServers: params["DnsNameServers"],
      ResourceIdentifier: params["ResourceIdentifier"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async createReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateReplicationSubnetGroupMessage,
  ): Promise<CreateReplicationSubnetGroupResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      ReplicationSubnetGroupDescription: params["ReplicationSubnetGroupDescription"],
      SubnetIds: params["SubnetIds"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationSubnetGroup": toReplicationSubnetGroup,
      },
    }, await resp.json());
  }

  async createReplicationTask(
    {abortSignal, ...params}: RequestConfig & CreateReplicationTaskMessage,
  ): Promise<CreateReplicationTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskIdentifier: params["ReplicationTaskIdentifier"],
      SourceEndpointArn: params["SourceEndpointArn"],
      TargetEndpointArn: params["TargetEndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      MigrationType: params["MigrationType"],
      TableMappings: params["TableMappings"],
      ReplicationTaskSettings: params["ReplicationTaskSettings"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      TaskData: params["TaskData"],
      ResourceIdentifier: params["ResourceIdentifier"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async deleteCertificate(
    {abortSignal, ...params}: RequestConfig & DeleteCertificateMessage,
  ): Promise<DeleteCertificateResponse> {
    const body: jsonP.JSONObject = params ? {
      CertificateArn: params["CertificateArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificate,
      },
    }, await resp.json());
  }

  async deleteConnection(
    {abortSignal, ...params}: RequestConfig & DeleteConnectionMessage,
  ): Promise<DeleteConnectionResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteEndpointMessage,
  ): Promise<DeleteEndpointResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & DeleteEventSubscriptionMessage,
  ): Promise<DeleteEventSubscriptionResponse> {
    const body: jsonP.JSONObject = params ? {
      SubscriptionName: params["SubscriptionName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async deleteReplicationInstance(
    {abortSignal, ...params}: RequestConfig & DeleteReplicationInstanceMessage,
  ): Promise<DeleteReplicationInstanceResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async deleteReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteReplicationSubnetGroupMessage,
  ): Promise<DeleteReplicationSubnetGroupResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteReplicationTask(
    {abortSignal, ...params}: RequestConfig & DeleteReplicationTaskMessage,
  ): Promise<DeleteReplicationTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async deleteReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & DeleteReplicationTaskAssessmentRunMessage,
  ): Promise<DeleteReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskAssessmentRunArn: params["ReplicationTaskAssessmentRunArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeAccountAttributesMessage = {},
  ): Promise<DescribeAccountAttributesResponse> {
    const body: jsonP.JSONObject = params ? {
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountQuotas": [toAccountQuota],
        "UniqueAccountIdentifier": "s",
      },
    }, await resp.json());
  }

  async describeApplicableIndividualAssessments(
    {abortSignal, ...params}: RequestConfig & DescribeApplicableIndividualAssessmentsMessage = {},
  ): Promise<DescribeApplicableIndividualAssessmentsResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      SourceEngineName: params["SourceEngineName"],
      TargetEngineName: params["TargetEngineName"],
      MigrationType: params["MigrationType"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApplicableIndividualAssessments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IndividualAssessmentNames": ["s"],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeCertificates(
    {abortSignal, ...params}: RequestConfig & DescribeCertificatesMessage = {},
  ): Promise<DescribeCertificatesResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Certificates": [toCertificate],
      },
    }, await resp.json());
  }

  async describeConnections(
    {abortSignal, ...params}: RequestConfig & DescribeConnectionsMessage = {},
  ): Promise<DescribeConnectionsResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Connections": [toConnection],
      },
    }, await resp.json());
  }

  async describeEndpointTypes(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointTypesMessage = {},
  ): Promise<DescribeEndpointTypesResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpointTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "SupportedEndpointTypes": [toSupportedEndpointType],
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointsMessage = {},
  ): Promise<DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Endpoints": [toEndpoint],
      },
    }, await resp.json());
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & DescribeEventCategoriesMessage = {},
  ): Promise<DescribeEventCategoriesResponse> {
    const body: jsonP.JSONObject = params ? {
      SourceType: params["SourceType"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventCategoryGroupList": [toEventCategoryGroup],
      },
    }, await resp.json());
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & DescribeEventSubscriptionsMessage = {},
  ): Promise<DescribeEventSubscriptionsResponse> {
    const body: jsonP.JSONObject = params ? {
      SubscriptionName: params["SubscriptionName"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "EventSubscriptionsList": [toEventSubscription],
      },
    }, await resp.json());
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<DescribeEventsResponse> {
    const body: jsonP.JSONObject = params ? {
      SourceIdentifier: params["SourceIdentifier"],
      SourceType: params["SourceType"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Duration: params["Duration"],
      EventCategories: params["EventCategories"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Events": [toEvent],
      },
    }, await resp.json());
  }

  async describeOrderableReplicationInstances(
    {abortSignal, ...params}: RequestConfig & DescribeOrderableReplicationInstancesMessage = {},
  ): Promise<DescribeOrderableReplicationInstancesResponse> {
    const body: jsonP.JSONObject = params ? {
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableReplicationInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OrderableReplicationInstances": [toOrderableReplicationInstance],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describePendingMaintenanceActions(
    {abortSignal, ...params}: RequestConfig & DescribePendingMaintenanceActionsMessage = {},
  ): Promise<DescribePendingMaintenanceActionsResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      Marker: params["Marker"],
      MaxRecords: params["MaxRecords"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePendingMaintenanceActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PendingMaintenanceActions": [toResourcePendingMaintenanceActions],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeRefreshSchemasStatus(
    {abortSignal, ...params}: RequestConfig & DescribeRefreshSchemasStatusMessage,
  ): Promise<DescribeRefreshSchemasStatusResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRefreshSchemasStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RefreshSchemasStatus": toRefreshSchemasStatus,
      },
    }, await resp.json());
  }

  async describeReplicationInstanceTaskLogs(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationInstanceTaskLogsMessage,
  ): Promise<DescribeReplicationInstanceTaskLogsResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationInstanceTaskLogs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstanceArn": "s",
        "ReplicationInstanceTaskLogs": [toReplicationInstanceTaskLog],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeReplicationInstances(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationInstancesMessage = {},
  ): Promise<DescribeReplicationInstancesResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationInstances": [toReplicationInstance],
      },
    }, await resp.json());
  }

  async describeReplicationSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationSubnetGroupsMessage = {},
  ): Promise<DescribeReplicationSubnetGroupsResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationSubnetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationSubnetGroups": [toReplicationSubnetGroup],
      },
    }, await resp.json());
  }

  async describeReplicationTaskAssessmentResults(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationTaskAssessmentResultsMessage = {},
  ): Promise<DescribeReplicationTaskAssessmentResultsResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskAssessmentResults",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "BucketName": "s",
        "ReplicationTaskAssessmentResults": [toReplicationTaskAssessmentResult],
      },
    }, await resp.json());
  }

  async describeReplicationTaskAssessmentRuns(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationTaskAssessmentRunsMessage = {},
  ): Promise<DescribeReplicationTaskAssessmentRunsResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskAssessmentRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTaskAssessmentRuns": [toReplicationTaskAssessmentRun],
      },
    }, await resp.json());
  }

  async describeReplicationTaskIndividualAssessments(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationTaskIndividualAssessmentsMessage = {},
  ): Promise<DescribeReplicationTaskIndividualAssessmentsResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskIndividualAssessments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTaskIndividualAssessments": [toReplicationTaskIndividualAssessment],
      },
    }, await resp.json());
  }

  async describeReplicationTasks(
    {abortSignal, ...params}: RequestConfig & DescribeReplicationTasksMessage = {},
  ): Promise<DescribeReplicationTasksResponse> {
    const body: jsonP.JSONObject = params ? {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
      WithoutSettings: params["WithoutSettings"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTasks": [toReplicationTask],
      },
    }, await resp.json());
  }

  async describeSchemas(
    {abortSignal, ...params}: RequestConfig & DescribeSchemasMessage,
  ): Promise<DescribeSchemasResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Schemas": ["s"],
      },
    }, await resp.json());
  }

  async describeTableStatistics(
    {abortSignal, ...params}: RequestConfig & DescribeTableStatisticsMessage,
  ): Promise<DescribeTableStatisticsResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableStatistics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskArn": "s",
        "TableStatistics": [toTableStatistics],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async importCertificate(
    {abortSignal, ...params}: RequestConfig & ImportCertificateMessage,
  ): Promise<ImportCertificateResponse> {
    const body: jsonP.JSONObject = params ? {
      CertificateIdentifier: params["CertificateIdentifier"],
      CertificatePem: params["CertificatePem"],
      CertificateWallet: jsonP.serializeBlob(params["CertificateWallet"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificate,
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceMessage,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TagList": [toTag],
      },
    }, await resp.json());
  }

  async modifyEndpoint(
    {abortSignal, ...params}: RequestConfig & ModifyEndpointMessage,
  ): Promise<ModifyEndpointResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
      EndpointIdentifier: params["EndpointIdentifier"],
      EndpointType: params["EndpointType"],
      EngineName: params["EngineName"],
      Username: params["Username"],
      Password: params["Password"],
      ServerName: params["ServerName"],
      Port: params["Port"],
      DatabaseName: params["DatabaseName"],
      ExtraConnectionAttributes: params["ExtraConnectionAttributes"],
      CertificateArn: params["CertificateArn"],
      SslMode: params["SslMode"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ExternalTableDefinition: params["ExternalTableDefinition"],
      DynamoDbSettings: fromDynamoDbSettings(params["DynamoDbSettings"]),
      S3Settings: fromS3Settings(params["S3Settings"]),
      DmsTransferSettings: fromDmsTransferSettings(params["DmsTransferSettings"]),
      MongoDbSettings: fromMongoDbSettings(params["MongoDbSettings"]),
      KinesisSettings: fromKinesisSettings(params["KinesisSettings"]),
      KafkaSettings: fromKafkaSettings(params["KafkaSettings"]),
      ElasticsearchSettings: fromElasticsearchSettings(params["ElasticsearchSettings"]),
      NeptuneSettings: fromNeptuneSettings(params["NeptuneSettings"]),
      RedshiftSettings: fromRedshiftSettings(params["RedshiftSettings"]),
      PostgreSQLSettings: fromPostgreSQLSettings(params["PostgreSQLSettings"]),
      MySQLSettings: fromMySQLSettings(params["MySQLSettings"]),
      OracleSettings: fromOracleSettings(params["OracleSettings"]),
      SybaseSettings: fromSybaseSettings(params["SybaseSettings"]),
      MicrosoftSQLServerSettings: fromMicrosoftSQLServerSettings(params["MicrosoftSQLServerSettings"]),
      IBMDb2Settings: fromIBMDb2Settings(params["IBMDb2Settings"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & ModifyEventSubscriptionMessage,
  ): Promise<ModifyEventSubscriptionResponse> {
    const body: jsonP.JSONObject = params ? {
      SubscriptionName: params["SubscriptionName"],
      SnsTopicArn: params["SnsTopicArn"],
      SourceType: params["SourceType"],
      EventCategories: params["EventCategories"],
      Enabled: params["Enabled"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async modifyReplicationInstance(
    {abortSignal, ...params}: RequestConfig & ModifyReplicationInstanceMessage,
  ): Promise<ModifyReplicationInstanceResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      AllocatedStorage: params["AllocatedStorage"],
      ApplyImmediately: params["ApplyImmediately"],
      ReplicationInstanceClass: params["ReplicationInstanceClass"],
      VpcSecurityGroupIds: params["VpcSecurityGroupIds"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      MultiAZ: params["MultiAZ"],
      EngineVersion: params["EngineVersion"],
      AllowMajorVersionUpgrade: params["AllowMajorVersionUpgrade"],
      AutoMinorVersionUpgrade: params["AutoMinorVersionUpgrade"],
      ReplicationInstanceIdentifier: params["ReplicationInstanceIdentifier"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async modifyReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyReplicationSubnetGroupMessage,
  ): Promise<ModifyReplicationSubnetGroupResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      ReplicationSubnetGroupDescription: params["ReplicationSubnetGroupDescription"],
      SubnetIds: params["SubnetIds"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationSubnetGroup": toReplicationSubnetGroup,
      },
    }, await resp.json());
  }

  async modifyReplicationTask(
    {abortSignal, ...params}: RequestConfig & ModifyReplicationTaskMessage,
  ): Promise<ModifyReplicationTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ReplicationTaskIdentifier: params["ReplicationTaskIdentifier"],
      MigrationType: params["MigrationType"],
      TableMappings: params["TableMappings"],
      ReplicationTaskSettings: params["ReplicationTaskSettings"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
      TaskData: params["TaskData"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async rebootReplicationInstance(
    {abortSignal, ...params}: RequestConfig & RebootReplicationInstanceMessage,
  ): Promise<RebootReplicationInstanceResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      ForceFailover: params["ForceFailover"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async refreshSchemas(
    {abortSignal, ...params}: RequestConfig & RefreshSchemasMessage,
  ): Promise<RefreshSchemasResponse> {
    const body: jsonP.JSONObject = params ? {
      EndpointArn: params["EndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RefreshSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RefreshSchemasStatus": toRefreshSchemasStatus,
      },
    }, await resp.json());
  }

  async reloadTables(
    {abortSignal, ...params}: RequestConfig & ReloadTablesMessage,
  ): Promise<ReloadTablesResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      TablesToReload: params["TablesToReload"]?.map(x => fromTableToReload(x)),
      ReloadOption: params["ReloadOption"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReloadTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskArn": "s",
      },
    }, await resp.json());
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceMessage,
  ): Promise<RemoveTagsFromResourceResponse> {
    const body: jsonP.JSONObject = params ? {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startReplicationTask(
    {abortSignal, ...params}: RequestConfig & StartReplicationTaskMessage,
  ): Promise<StartReplicationTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      StartReplicationTaskType: params["StartReplicationTaskType"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async startReplicationTaskAssessment(
    {abortSignal, ...params}: RequestConfig & StartReplicationTaskAssessmentMessage,
  ): Promise<StartReplicationTaskAssessmentResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTaskAssessment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async startReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & StartReplicationTaskAssessmentRunMessage,
  ): Promise<StartReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ResultLocationBucket: params["ResultLocationBucket"],
      ResultLocationFolder: params["ResultLocationFolder"],
      ResultEncryptionMode: params["ResultEncryptionMode"],
      ResultKmsKeyArn: params["ResultKmsKeyArn"],
      AssessmentRunName: params["AssessmentRunName"],
      IncludeOnly: params["IncludeOnly"],
      Exclude: params["Exclude"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async stopReplicationTask(
    {abortSignal, ...params}: RequestConfig & StopReplicationTaskMessage,
  ): Promise<StopReplicationTaskResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async testConnection(
    {abortSignal, ...params}: RequestConfig & TestConnectionMessage,
  ): Promise<TestConnectionResponse> {
    const body: jsonP.JSONObject = params ? {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      EndpointArn: params["EndpointArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until testing connection succeeds.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForTestConnectionSucceeds(
    params: RequestConfig & DescribeConnectionsMessage,
  ): Promise<DescribeConnectionsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TestConnectionSucceeds';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeConnections(params);
      const field = resp?.Connections?.flatMap(x => x?.Status);
      if (field?.every(x => x === "successful")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until testing endpoint is deleted.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForEndpointDeleted(
    params: RequestConfig & DescribeEndpointsMessage,
  ): Promise<Error | DescribeEndpointsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeEndpoints(params);
        const field = resp?.Endpoints?.flatMap(x => x?.Status);
        if (field?.some(x => x === "active")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication instance is available.
   * Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time).
   */
  async waitForReplicationInstanceAvailable(
    params: RequestConfig & DescribeReplicationInstancesMessage,
  ): Promise<DescribeReplicationInstancesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationInstances(params);
      const field = resp?.ReplicationInstances?.flatMap(x => x?.ReplicationInstanceStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-credentials")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
      if (field?.some(x => x === "inaccessible-encryption-credentials")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication instance is deleted.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationInstanceDeleted(
    params: RequestConfig & DescribeReplicationInstancesMessage,
  ): Promise<Error | DescribeReplicationInstancesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeReplicationInstances(params);
        if (resp?.ReplicationInstances?.flatMap(x => x?.ReplicationInstanceStatus)?.some(x => x === "available")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is ready.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskReady(
    params: RequestConfig & DescribeReplicationTasksMessage,
  ): Promise<DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskReady';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "ready")) return resp;
      if (field?.some(x => x === "starting")) throw new Error(errMessage);
      if (field?.some(x => x === "running")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is stopped.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskStopped(
    params: RequestConfig & DescribeReplicationTasksMessage,
  ): Promise<DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskStopped';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "stopped")) return resp;
      if (field?.some(x => x === "ready")) throw new Error(errMessage);
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "starting")) throw new Error(errMessage);
      if (field?.some(x => x === "running")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is running.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskRunning(
    params: RequestConfig & DescribeReplicationTasksMessage,
  ): Promise<DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskRunning';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "running")) return resp;
      if (field?.some(x => x === "ready")) throw new Error(errMessage);
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is deleted.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskDeleted(
    params: RequestConfig & DescribeReplicationTasksMessage,
  ): Promise<Error | DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeReplicationTasks(params);
        const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
        if (field?.some(x => x === "ready")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "stopped")) throw new Error(errMessage);
        if (field?.some(x => x === "running")) throw new Error(errMessage);
        if (field?.some(x => x === "failed")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsToResourceMessage {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface ApplyPendingMaintenanceActionMessage {
  ReplicationInstanceArn: string;
  ApplyAction: string;
  OptInType: string;
}

// refs: 1 - tags: named, input
export interface CancelReplicationTaskAssessmentRunMessage {
  ReplicationTaskAssessmentRunArn: string;
}

// refs: 1 - tags: named, input
export interface CreateEndpointMessage {
  EndpointIdentifier: string;
  EndpointType: ReplicationEndpointTypeValue;
  EngineName: string;
  Username?: string | null;
  Password?: string | null;
  ServerName?: string | null;
  Port?: number | null;
  DatabaseName?: string | null;
  ExtraConnectionAttributes?: string | null;
  KmsKeyId?: string | null;
  Tags?: Tag[] | null;
  CertificateArn?: string | null;
  SslMode?: DmsSslModeValue | null;
  ServiceAccessRoleArn?: string | null;
  ExternalTableDefinition?: string | null;
  DynamoDbSettings?: DynamoDbSettings | null;
  S3Settings?: S3Settings | null;
  DmsTransferSettings?: DmsTransferSettings | null;
  MongoDbSettings?: MongoDbSettings | null;
  KinesisSettings?: KinesisSettings | null;
  KafkaSettings?: KafkaSettings | null;
  ElasticsearchSettings?: ElasticsearchSettings | null;
  NeptuneSettings?: NeptuneSettings | null;
  RedshiftSettings?: RedshiftSettings | null;
  PostgreSQLSettings?: PostgreSQLSettings | null;
  MySQLSettings?: MySQLSettings | null;
  OracleSettings?: OracleSettings | null;
  SybaseSettings?: SybaseSettings | null;
  MicrosoftSQLServerSettings?: MicrosoftSQLServerSettings | null;
  IBMDb2Settings?: IBMDb2Settings | null;
  ResourceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn: string;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  SourceIds?: string[] | null;
  Enabled?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateReplicationInstanceMessage {
  ReplicationInstanceIdentifier: string;
  AllocatedStorage?: number | null;
  ReplicationInstanceClass: string;
  VpcSecurityGroupIds?: string[] | null;
  AvailabilityZone?: string | null;
  ReplicationSubnetGroupIdentifier?: string | null;
  PreferredMaintenanceWindow?: string | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  PubliclyAccessible?: boolean | null;
  DnsNameServers?: string | null;
  ResourceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateReplicationSubnetGroupMessage {
  ReplicationSubnetGroupIdentifier: string;
  ReplicationSubnetGroupDescription: string;
  SubnetIds: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateReplicationTaskMessage {
  ReplicationTaskIdentifier: string;
  SourceEndpointArn: string;
  TargetEndpointArn: string;
  ReplicationInstanceArn: string;
  MigrationType: MigrationTypeValue;
  TableMappings: string;
  ReplicationTaskSettings?: string | null;
  CdcStartTime?: Date | number | null;
  CdcStartPosition?: string | null;
  CdcStopPosition?: string | null;
  Tags?: Tag[] | null;
  TaskData?: string | null;
  ResourceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteCertificateMessage {
  CertificateArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteConnectionMessage {
  EndpointArn: string;
  ReplicationInstanceArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteEndpointMessage {
  EndpointArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventSubscriptionMessage {
  SubscriptionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteReplicationInstanceMessage {
  ReplicationInstanceArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteReplicationSubnetGroupMessage {
  ReplicationSubnetGroupIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteReplicationTaskMessage {
  ReplicationTaskArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteReplicationTaskAssessmentRunMessage {
  ReplicationTaskAssessmentRunArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeAccountAttributesMessage {
}

// refs: 1 - tags: named, input
export interface DescribeApplicableIndividualAssessmentsMessage {
  ReplicationTaskArn?: string | null;
  ReplicationInstanceArn?: string | null;
  SourceEngineName?: string | null;
  TargetEngineName?: string | null;
  MigrationType?: MigrationTypeValue | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeCertificatesMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeConnectionsMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointTypesMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointsMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventCategoriesMessage {
  SourceType?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventSubscriptionsMessage {
  SubscriptionName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  EventCategories?: string[] | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOrderableReplicationInstancesMessage {
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePendingMaintenanceActionsMessage {
  ReplicationInstanceArn?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeRefreshSchemasStatusMessage {
  EndpointArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationInstanceTaskLogsMessage {
  ReplicationInstanceArn: string;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationInstancesMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationSubnetGroupsMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationTaskAssessmentResultsMessage {
  ReplicationTaskArn?: string | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationTaskAssessmentRunsMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationTaskIndividualAssessmentsMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReplicationTasksMessage {
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  WithoutSettings?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSchemasMessage {
  EndpointArn: string;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTableStatisticsMessage {
  ReplicationTaskArn: string;
  MaxRecords?: number | null;
  Marker?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ImportCertificateMessage {
  CertificateIdentifier: string;
  CertificatePem?: string | null;
  CertificateWallet?: Uint8Array | string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceMessage {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface ModifyEndpointMessage {
  EndpointArn: string;
  EndpointIdentifier?: string | null;
  EndpointType?: ReplicationEndpointTypeValue | null;
  EngineName?: string | null;
  Username?: string | null;
  Password?: string | null;
  ServerName?: string | null;
  Port?: number | null;
  DatabaseName?: string | null;
  ExtraConnectionAttributes?: string | null;
  CertificateArn?: string | null;
  SslMode?: DmsSslModeValue | null;
  ServiceAccessRoleArn?: string | null;
  ExternalTableDefinition?: string | null;
  DynamoDbSettings?: DynamoDbSettings | null;
  S3Settings?: S3Settings | null;
  DmsTransferSettings?: DmsTransferSettings | null;
  MongoDbSettings?: MongoDbSettings | null;
  KinesisSettings?: KinesisSettings | null;
  KafkaSettings?: KafkaSettings | null;
  ElasticsearchSettings?: ElasticsearchSettings | null;
  NeptuneSettings?: NeptuneSettings | null;
  RedshiftSettings?: RedshiftSettings | null;
  PostgreSQLSettings?: PostgreSQLSettings | null;
  MySQLSettings?: MySQLSettings | null;
  OracleSettings?: OracleSettings | null;
  SybaseSettings?: SybaseSettings | null;
  MicrosoftSQLServerSettings?: MicrosoftSQLServerSettings | null;
  IBMDb2Settings?: IBMDb2Settings | null;
}

// refs: 1 - tags: named, input
export interface ModifyEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn?: string | null;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyReplicationInstanceMessage {
  ReplicationInstanceArn: string;
  AllocatedStorage?: number | null;
  ApplyImmediately?: boolean | null;
  ReplicationInstanceClass?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  PreferredMaintenanceWindow?: string | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AllowMajorVersionUpgrade?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  ReplicationInstanceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyReplicationSubnetGroupMessage {
  ReplicationSubnetGroupIdentifier: string;
  ReplicationSubnetGroupDescription?: string | null;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface ModifyReplicationTaskMessage {
  ReplicationTaskArn: string;
  ReplicationTaskIdentifier?: string | null;
  MigrationType?: MigrationTypeValue | null;
  TableMappings?: string | null;
  ReplicationTaskSettings?: string | null;
  CdcStartTime?: Date | number | null;
  CdcStartPosition?: string | null;
  CdcStopPosition?: string | null;
  TaskData?: string | null;
}

// refs: 1 - tags: named, input
export interface RebootReplicationInstanceMessage {
  ReplicationInstanceArn: string;
  ForceFailover?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RefreshSchemasMessage {
  EndpointArn: string;
  ReplicationInstanceArn: string;
}

// refs: 1 - tags: named, input
export interface ReloadTablesMessage {
  ReplicationTaskArn: string;
  TablesToReload: TableToReload[];
  ReloadOption?: ReloadOptionValue | null;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceMessage {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface StartReplicationTaskMessage {
  ReplicationTaskArn: string;
  StartReplicationTaskType: StartReplicationTaskTypeValue;
  CdcStartTime?: Date | number | null;
  CdcStartPosition?: string | null;
  CdcStopPosition?: string | null;
}

// refs: 1 - tags: named, input
export interface StartReplicationTaskAssessmentMessage {
  ReplicationTaskArn: string;
}

// refs: 1 - tags: named, input
export interface StartReplicationTaskAssessmentRunMessage {
  ReplicationTaskArn: string;
  ServiceAccessRoleArn: string;
  ResultLocationBucket: string;
  ResultLocationFolder?: string | null;
  ResultEncryptionMode?: string | null;
  ResultKmsKeyArn?: string | null;
  AssessmentRunName: string;
  IncludeOnly?: string[] | null;
  Exclude?: string[] | null;
}

// refs: 1 - tags: named, input
export interface StopReplicationTaskMessage {
  ReplicationTaskArn: string;
}

// refs: 1 - tags: named, input
export interface TestConnectionMessage {
  ReplicationInstanceArn: string;
  EndpointArn: string;
}

// refs: 1 - tags: named, output
export interface AddTagsToResourceResponse {
}

// refs: 1 - tags: named, output
export interface ApplyPendingMaintenanceActionResponse {
  ResourcePendingMaintenanceActions?: ResourcePendingMaintenanceActions | null;
}

// refs: 1 - tags: named, output
export interface CancelReplicationTaskAssessmentRunResponse {
  ReplicationTaskAssessmentRun?: ReplicationTaskAssessmentRun | null;
}

// refs: 1 - tags: named, output
export interface CreateEndpointResponse {
  Endpoint?: Endpoint | null;
}

// refs: 1 - tags: named, output
export interface CreateEventSubscriptionResponse {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateReplicationInstanceResponse {
  ReplicationInstance?: ReplicationInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateReplicationSubnetGroupResponse {
  ReplicationSubnetGroup?: ReplicationSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateReplicationTaskResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface DeleteCertificateResponse {
  Certificate?: Certificate | null;
}

// refs: 1 - tags: named, output
export interface DeleteConnectionResponse {
  Connection?: Connection | null;
}

// refs: 1 - tags: named, output
export interface DeleteEndpointResponse {
  Endpoint?: Endpoint | null;
}

// refs: 1 - tags: named, output
export interface DeleteEventSubscriptionResponse {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface DeleteReplicationInstanceResponse {
  ReplicationInstance?: ReplicationInstance | null;
}

// refs: 1 - tags: named, output
export interface DeleteReplicationSubnetGroupResponse {
}

// refs: 1 - tags: named, output
export interface DeleteReplicationTaskResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface DeleteReplicationTaskAssessmentRunResponse {
  ReplicationTaskAssessmentRun?: ReplicationTaskAssessmentRun | null;
}

// refs: 1 - tags: named, output
export interface DescribeAccountAttributesResponse {
  AccountQuotas?: AccountQuota[] | null;
  UniqueAccountIdentifier?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeApplicableIndividualAssessmentsResponse {
  IndividualAssessmentNames?: string[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeCertificatesResponse {
  Marker?: string | null;
  Certificates?: Certificate[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeConnectionsResponse {
  Marker?: string | null;
  Connections?: Connection[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointTypesResponse {
  Marker?: string | null;
  SupportedEndpointTypes?: SupportedEndpointType[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointsResponse {
  Marker?: string | null;
  Endpoints?: Endpoint[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEventCategoriesResponse {
  EventCategoryGroupList?: EventCategoryGroup[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEventSubscriptionsResponse {
  Marker?: string | null;
  EventSubscriptionsList?: EventSubscription[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeEventsResponse {
  Marker?: string | null;
  Events?: Event[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeOrderableReplicationInstancesResponse {
  OrderableReplicationInstances?: OrderableReplicationInstance[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePendingMaintenanceActionsResponse {
  PendingMaintenanceActions?: ResourcePendingMaintenanceActions[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeRefreshSchemasStatusResponse {
  RefreshSchemasStatus?: RefreshSchemasStatus | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationInstanceTaskLogsResponse {
  ReplicationInstanceArn?: string | null;
  ReplicationInstanceTaskLogs?: ReplicationInstanceTaskLog[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationInstancesResponse {
  Marker?: string | null;
  ReplicationInstances?: ReplicationInstance[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationSubnetGroupsResponse {
  Marker?: string | null;
  ReplicationSubnetGroups?: ReplicationSubnetGroup[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationTaskAssessmentResultsResponse {
  Marker?: string | null;
  BucketName?: string | null;
  ReplicationTaskAssessmentResults?: ReplicationTaskAssessmentResult[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationTaskAssessmentRunsResponse {
  Marker?: string | null;
  ReplicationTaskAssessmentRuns?: ReplicationTaskAssessmentRun[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationTaskIndividualAssessmentsResponse {
  Marker?: string | null;
  ReplicationTaskIndividualAssessments?: ReplicationTaskIndividualAssessment[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReplicationTasksResponse {
  Marker?: string | null;
  ReplicationTasks?: ReplicationTask[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeSchemasResponse {
  Marker?: string | null;
  Schemas?: string[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTableStatisticsResponse {
  ReplicationTaskArn?: string | null;
  TableStatistics?: TableStatistics[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ImportCertificateResponse {
  Certificate?: Certificate | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  TagList?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface ModifyEndpointResponse {
  Endpoint?: Endpoint | null;
}

// refs: 1 - tags: named, output
export interface ModifyEventSubscriptionResponse {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface ModifyReplicationInstanceResponse {
  ReplicationInstance?: ReplicationInstance | null;
}

// refs: 1 - tags: named, output
export interface ModifyReplicationSubnetGroupResponse {
  ReplicationSubnetGroup?: ReplicationSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyReplicationTaskResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface RebootReplicationInstanceResponse {
  ReplicationInstance?: ReplicationInstance | null;
}

// refs: 1 - tags: named, output
export interface RefreshSchemasResponse {
  RefreshSchemasStatus?: RefreshSchemasStatus | null;
}

// refs: 1 - tags: named, output
export interface ReloadTablesResponse {
  ReplicationTaskArn?: string | null;
}

// refs: 1 - tags: named, output
export interface RemoveTagsFromResourceResponse {
}

// refs: 1 - tags: named, output
export interface StartReplicationTaskResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface StartReplicationTaskAssessmentResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface StartReplicationTaskAssessmentRunResponse {
  ReplicationTaskAssessmentRun?: ReplicationTaskAssessmentRun | null;
}

// refs: 1 - tags: named, output
export interface StopReplicationTaskResponse {
  ReplicationTask?: ReplicationTask | null;
}

// refs: 1 - tags: named, output
export interface TestConnectionResponse {
  Connection?: Connection | null;
}

// refs: 8 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type ReplicationEndpointTypeValue =
| "source"
| "target"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DmsSslModeValue =
| "none"
| "require"
| "verify-ca"
| "verify-full"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface DynamoDbSettings {
  ServiceAccessRoleArn: string;
}
function fromDynamoDbSettings(input?: DynamoDbSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
  }
}
function toDynamoDbSettings(root: jsonP.JSONValue): DynamoDbSettings {
  return jsonP.readObj({
    required: {
      "ServiceAccessRoleArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface S3Settings {
  ServiceAccessRoleArn?: string | null;
  ExternalTableDefinition?: string | null;
  CsvRowDelimiter?: string | null;
  CsvDelimiter?: string | null;
  BucketFolder?: string | null;
  BucketName?: string | null;
  CompressionType?: CompressionTypeValue | null;
  EncryptionMode?: EncryptionModeValue | null;
  ServerSideEncryptionKmsKeyId?: string | null;
  DataFormat?: DataFormatValue | null;
  EncodingType?: EncodingTypeValue | null;
  DictPageSizeLimit?: number | null;
  RowGroupLength?: number | null;
  DataPageSize?: number | null;
  ParquetVersion?: ParquetVersionValue | null;
  EnableStatistics?: boolean | null;
  IncludeOpForFullLoad?: boolean | null;
  CdcInsertsOnly?: boolean | null;
  TimestampColumnName?: string | null;
  ParquetTimestampInMillisecond?: boolean | null;
  CdcInsertsAndUpdates?: boolean | null;
  DatePartitionEnabled?: boolean | null;
  DatePartitionSequence?: DatePartitionSequenceValue | null;
  DatePartitionDelimiter?: DatePartitionDelimiterValue | null;
}
function fromS3Settings(input?: S3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    ExternalTableDefinition: input["ExternalTableDefinition"],
    CsvRowDelimiter: input["CsvRowDelimiter"],
    CsvDelimiter: input["CsvDelimiter"],
    BucketFolder: input["BucketFolder"],
    BucketName: input["BucketName"],
    CompressionType: input["CompressionType"],
    EncryptionMode: input["EncryptionMode"],
    ServerSideEncryptionKmsKeyId: input["ServerSideEncryptionKmsKeyId"],
    DataFormat: input["DataFormat"],
    EncodingType: input["EncodingType"],
    DictPageSizeLimit: input["DictPageSizeLimit"],
    RowGroupLength: input["RowGroupLength"],
    DataPageSize: input["DataPageSize"],
    ParquetVersion: input["ParquetVersion"],
    EnableStatistics: input["EnableStatistics"],
    IncludeOpForFullLoad: input["IncludeOpForFullLoad"],
    CdcInsertsOnly: input["CdcInsertsOnly"],
    TimestampColumnName: input["TimestampColumnName"],
    ParquetTimestampInMillisecond: input["ParquetTimestampInMillisecond"],
    CdcInsertsAndUpdates: input["CdcInsertsAndUpdates"],
    DatePartitionEnabled: input["DatePartitionEnabled"],
    DatePartitionSequence: input["DatePartitionSequence"],
    DatePartitionDelimiter: input["DatePartitionDelimiter"],
  }
}
function toS3Settings(root: jsonP.JSONValue): S3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceAccessRoleArn": "s",
      "ExternalTableDefinition": "s",
      "CsvRowDelimiter": "s",
      "CsvDelimiter": "s",
      "BucketFolder": "s",
      "BucketName": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionTypeValue>(x),
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionModeValue>(x),
      "ServerSideEncryptionKmsKeyId": "s",
      "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<DataFormatValue>(x),
      "EncodingType": (x: jsonP.JSONValue) => cmnP.readEnum<EncodingTypeValue>(x),
      "DictPageSizeLimit": "n",
      "RowGroupLength": "n",
      "DataPageSize": "n",
      "ParquetVersion": (x: jsonP.JSONValue) => cmnP.readEnum<ParquetVersionValue>(x),
      "EnableStatistics": "b",
      "IncludeOpForFullLoad": "b",
      "CdcInsertsOnly": "b",
      "TimestampColumnName": "s",
      "ParquetTimestampInMillisecond": "b",
      "CdcInsertsAndUpdates": "b",
      "DatePartitionEnabled": "b",
      "DatePartitionSequence": (x: jsonP.JSONValue) => cmnP.readEnum<DatePartitionSequenceValue>(x),
      "DatePartitionDelimiter": (x: jsonP.JSONValue) => cmnP.readEnum<DatePartitionDelimiterValue>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type CompressionTypeValue =
| "none"
| "gzip"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, enum, output
export type EncryptionModeValue =
| "sse-s3"
| "sse-kms"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DataFormatValue =
| "csv"
| "parquet"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type EncodingTypeValue =
| "plain"
| "plain-dictionary"
| "rle-dictionary"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ParquetVersionValue =
| "parquet-1-0"
| "parquet-2-0"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DatePartitionSequenceValue =
| "YYYYMMDD"
| "YYYYMMDDHH"
| "YYYYMM"
| "MMYYYYDD"
| "DDMMYYYY"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type DatePartitionDelimiterValue =
| "SLASH"
| "UNDERSCORE"
| "DASH"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface DmsTransferSettings {
  ServiceAccessRoleArn?: string | null;
  BucketName?: string | null;
}
function fromDmsTransferSettings(input?: DmsTransferSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    BucketName: input["BucketName"],
  }
}
function toDmsTransferSettings(root: jsonP.JSONValue): DmsTransferSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceAccessRoleArn": "s",
      "BucketName": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MongoDbSettings {
  Username?: string | null;
  Password?: string | null;
  ServerName?: string | null;
  Port?: number | null;
  DatabaseName?: string | null;
  AuthType?: AuthTypeValue | null;
  AuthMechanism?: AuthMechanismValue | null;
  NestingLevel?: NestingLevelValue | null;
  ExtractDocId?: string | null;
  DocsToInvestigate?: string | null;
  AuthSource?: string | null;
  KmsKeyId?: string | null;
}
function fromMongoDbSettings(input?: MongoDbSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
    ServerName: input["ServerName"],
    Port: input["Port"],
    DatabaseName: input["DatabaseName"],
    AuthType: input["AuthType"],
    AuthMechanism: input["AuthMechanism"],
    NestingLevel: input["NestingLevel"],
    ExtractDocId: input["ExtractDocId"],
    DocsToInvestigate: input["DocsToInvestigate"],
    AuthSource: input["AuthSource"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toMongoDbSettings(root: jsonP.JSONValue): MongoDbSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Password": "s",
      "ServerName": "s",
      "Port": "n",
      "DatabaseName": "s",
      "AuthType": (x: jsonP.JSONValue) => cmnP.readEnum<AuthTypeValue>(x),
      "AuthMechanism": (x: jsonP.JSONValue) => cmnP.readEnum<AuthMechanismValue>(x),
      "NestingLevel": (x: jsonP.JSONValue) => cmnP.readEnum<NestingLevelValue>(x),
      "ExtractDocId": "s",
      "DocsToInvestigate": "s",
      "AuthSource": "s",
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type AuthTypeValue =
| "no"
| "password"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type AuthMechanismValue =
| "default"
| "mongodb_cr"
| "scram_sha_1"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type NestingLevelValue =
| "none"
| "one"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface KinesisSettings {
  StreamArn?: string | null;
  MessageFormat?: MessageFormatValue | null;
  ServiceAccessRoleArn?: string | null;
  IncludeTransactionDetails?: boolean | null;
  IncludePartitionValue?: boolean | null;
  PartitionIncludeSchemaTable?: boolean | null;
  IncludeTableAlterOperations?: boolean | null;
  IncludeControlDetails?: boolean | null;
  IncludeNullAndEmpty?: boolean | null;
}
function fromKinesisSettings(input?: KinesisSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamArn: input["StreamArn"],
    MessageFormat: input["MessageFormat"],
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    IncludeTransactionDetails: input["IncludeTransactionDetails"],
    IncludePartitionValue: input["IncludePartitionValue"],
    PartitionIncludeSchemaTable: input["PartitionIncludeSchemaTable"],
    IncludeTableAlterOperations: input["IncludeTableAlterOperations"],
    IncludeControlDetails: input["IncludeControlDetails"],
    IncludeNullAndEmpty: input["IncludeNullAndEmpty"],
  }
}
function toKinesisSettings(root: jsonP.JSONValue): KinesisSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamArn": "s",
      "MessageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<MessageFormatValue>(x),
      "ServiceAccessRoleArn": "s",
      "IncludeTransactionDetails": "b",
      "IncludePartitionValue": "b",
      "PartitionIncludeSchemaTable": "b",
      "IncludeTableAlterOperations": "b",
      "IncludeControlDetails": "b",
      "IncludeNullAndEmpty": "b",
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type MessageFormatValue =
| "json"
| "json-unformatted"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface KafkaSettings {
  Broker?: string | null;
  Topic?: string | null;
  MessageFormat?: MessageFormatValue | null;
  IncludeTransactionDetails?: boolean | null;
  IncludePartitionValue?: boolean | null;
  PartitionIncludeSchemaTable?: boolean | null;
  IncludeTableAlterOperations?: boolean | null;
  IncludeControlDetails?: boolean | null;
  MessageMaxBytes?: number | null;
  IncludeNullAndEmpty?: boolean | null;
}
function fromKafkaSettings(input?: KafkaSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Broker: input["Broker"],
    Topic: input["Topic"],
    MessageFormat: input["MessageFormat"],
    IncludeTransactionDetails: input["IncludeTransactionDetails"],
    IncludePartitionValue: input["IncludePartitionValue"],
    PartitionIncludeSchemaTable: input["PartitionIncludeSchemaTable"],
    IncludeTableAlterOperations: input["IncludeTableAlterOperations"],
    IncludeControlDetails: input["IncludeControlDetails"],
    MessageMaxBytes: input["MessageMaxBytes"],
    IncludeNullAndEmpty: input["IncludeNullAndEmpty"],
  }
}
function toKafkaSettings(root: jsonP.JSONValue): KafkaSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Broker": "s",
      "Topic": "s",
      "MessageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<MessageFormatValue>(x),
      "IncludeTransactionDetails": "b",
      "IncludePartitionValue": "b",
      "PartitionIncludeSchemaTable": "b",
      "IncludeTableAlterOperations": "b",
      "IncludeControlDetails": "b",
      "MessageMaxBytes": "n",
      "IncludeNullAndEmpty": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ElasticsearchSettings {
  ServiceAccessRoleArn: string;
  EndpointUri: string;
  FullLoadErrorPercentage?: number | null;
  ErrorRetryDuration?: number | null;
}
function fromElasticsearchSettings(input?: ElasticsearchSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    EndpointUri: input["EndpointUri"],
    FullLoadErrorPercentage: input["FullLoadErrorPercentage"],
    ErrorRetryDuration: input["ErrorRetryDuration"],
  }
}
function toElasticsearchSettings(root: jsonP.JSONValue): ElasticsearchSettings {
  return jsonP.readObj({
    required: {
      "ServiceAccessRoleArn": "s",
      "EndpointUri": "s",
    },
    optional: {
      "FullLoadErrorPercentage": "n",
      "ErrorRetryDuration": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface NeptuneSettings {
  ServiceAccessRoleArn?: string | null;
  S3BucketName: string;
  S3BucketFolder: string;
  ErrorRetryDuration?: number | null;
  MaxFileSize?: number | null;
  MaxRetryCount?: number | null;
  IamAuthEnabled?: boolean | null;
}
function fromNeptuneSettings(input?: NeptuneSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    S3BucketName: input["S3BucketName"],
    S3BucketFolder: input["S3BucketFolder"],
    ErrorRetryDuration: input["ErrorRetryDuration"],
    MaxFileSize: input["MaxFileSize"],
    MaxRetryCount: input["MaxRetryCount"],
    IamAuthEnabled: input["IamAuthEnabled"],
  }
}
function toNeptuneSettings(root: jsonP.JSONValue): NeptuneSettings {
  return jsonP.readObj({
    required: {
      "S3BucketName": "s",
      "S3BucketFolder": "s",
    },
    optional: {
      "ServiceAccessRoleArn": "s",
      "ErrorRetryDuration": "n",
      "MaxFileSize": "n",
      "MaxRetryCount": "n",
      "IamAuthEnabled": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface RedshiftSettings {
  AcceptAnyDate?: boolean | null;
  AfterConnectScript?: string | null;
  BucketFolder?: string | null;
  BucketName?: string | null;
  CaseSensitiveNames?: boolean | null;
  CompUpdate?: boolean | null;
  ConnectionTimeout?: number | null;
  DatabaseName?: string | null;
  DateFormat?: string | null;
  EmptyAsNull?: boolean | null;
  EncryptionMode?: EncryptionModeValue | null;
  ExplicitIds?: boolean | null;
  FileTransferUploadStreams?: number | null;
  LoadTimeout?: number | null;
  MaxFileSize?: number | null;
  Password?: string | null;
  Port?: number | null;
  RemoveQuotes?: boolean | null;
  ReplaceInvalidChars?: string | null;
  ReplaceChars?: string | null;
  ServerName?: string | null;
  ServiceAccessRoleArn?: string | null;
  ServerSideEncryptionKmsKeyId?: string | null;
  TimeFormat?: string | null;
  TrimBlanks?: boolean | null;
  TruncateColumns?: boolean | null;
  Username?: string | null;
  WriteBufferSize?: number | null;
}
function fromRedshiftSettings(input?: RedshiftSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AcceptAnyDate: input["AcceptAnyDate"],
    AfterConnectScript: input["AfterConnectScript"],
    BucketFolder: input["BucketFolder"],
    BucketName: input["BucketName"],
    CaseSensitiveNames: input["CaseSensitiveNames"],
    CompUpdate: input["CompUpdate"],
    ConnectionTimeout: input["ConnectionTimeout"],
    DatabaseName: input["DatabaseName"],
    DateFormat: input["DateFormat"],
    EmptyAsNull: input["EmptyAsNull"],
    EncryptionMode: input["EncryptionMode"],
    ExplicitIds: input["ExplicitIds"],
    FileTransferUploadStreams: input["FileTransferUploadStreams"],
    LoadTimeout: input["LoadTimeout"],
    MaxFileSize: input["MaxFileSize"],
    Password: input["Password"],
    Port: input["Port"],
    RemoveQuotes: input["RemoveQuotes"],
    ReplaceInvalidChars: input["ReplaceInvalidChars"],
    ReplaceChars: input["ReplaceChars"],
    ServerName: input["ServerName"],
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    ServerSideEncryptionKmsKeyId: input["ServerSideEncryptionKmsKeyId"],
    TimeFormat: input["TimeFormat"],
    TrimBlanks: input["TrimBlanks"],
    TruncateColumns: input["TruncateColumns"],
    Username: input["Username"],
    WriteBufferSize: input["WriteBufferSize"],
  }
}
function toRedshiftSettings(root: jsonP.JSONValue): RedshiftSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AcceptAnyDate": "b",
      "AfterConnectScript": "s",
      "BucketFolder": "s",
      "BucketName": "s",
      "CaseSensitiveNames": "b",
      "CompUpdate": "b",
      "ConnectionTimeout": "n",
      "DatabaseName": "s",
      "DateFormat": "s",
      "EmptyAsNull": "b",
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionModeValue>(x),
      "ExplicitIds": "b",
      "FileTransferUploadStreams": "n",
      "LoadTimeout": "n",
      "MaxFileSize": "n",
      "Password": "s",
      "Port": "n",
      "RemoveQuotes": "b",
      "ReplaceInvalidChars": "s",
      "ReplaceChars": "s",
      "ServerName": "s",
      "ServiceAccessRoleArn": "s",
      "ServerSideEncryptionKmsKeyId": "s",
      "TimeFormat": "s",
      "TrimBlanks": "b",
      "TruncateColumns": "b",
      "Username": "s",
      "WriteBufferSize": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface PostgreSQLSettings {
  AfterConnectScript?: string | null;
  CaptureDdls?: boolean | null;
  MaxFileSize?: number | null;
  DatabaseName?: string | null;
  DdlArtifactsSchema?: string | null;
  ExecuteTimeout?: number | null;
  FailTasksOnLobTruncation?: boolean | null;
  Password?: string | null;
  Port?: number | null;
  ServerName?: string | null;
  Username?: string | null;
  SlotName?: string | null;
}
function fromPostgreSQLSettings(input?: PostgreSQLSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AfterConnectScript: input["AfterConnectScript"],
    CaptureDdls: input["CaptureDdls"],
    MaxFileSize: input["MaxFileSize"],
    DatabaseName: input["DatabaseName"],
    DdlArtifactsSchema: input["DdlArtifactsSchema"],
    ExecuteTimeout: input["ExecuteTimeout"],
    FailTasksOnLobTruncation: input["FailTasksOnLobTruncation"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    SlotName: input["SlotName"],
  }
}
function toPostgreSQLSettings(root: jsonP.JSONValue): PostgreSQLSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfterConnectScript": "s",
      "CaptureDdls": "b",
      "MaxFileSize": "n",
      "DatabaseName": "s",
      "DdlArtifactsSchema": "s",
      "ExecuteTimeout": "n",
      "FailTasksOnLobTruncation": "b",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "Username": "s",
      "SlotName": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MySQLSettings {
  AfterConnectScript?: string | null;
  DatabaseName?: string | null;
  EventsPollInterval?: number | null;
  TargetDbType?: TargetDbType | null;
  MaxFileSize?: number | null;
  ParallelLoadThreads?: number | null;
  Password?: string | null;
  Port?: number | null;
  ServerName?: string | null;
  ServerTimezone?: string | null;
  Username?: string | null;
}
function fromMySQLSettings(input?: MySQLSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AfterConnectScript: input["AfterConnectScript"],
    DatabaseName: input["DatabaseName"],
    EventsPollInterval: input["EventsPollInterval"],
    TargetDbType: input["TargetDbType"],
    MaxFileSize: input["MaxFileSize"],
    ParallelLoadThreads: input["ParallelLoadThreads"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    ServerTimezone: input["ServerTimezone"],
    Username: input["Username"],
  }
}
function toMySQLSettings(root: jsonP.JSONValue): MySQLSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfterConnectScript": "s",
      "DatabaseName": "s",
      "EventsPollInterval": "n",
      "TargetDbType": (x: jsonP.JSONValue) => cmnP.readEnum<TargetDbType>(x),
      "MaxFileSize": "n",
      "ParallelLoadThreads": "n",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "ServerTimezone": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type TargetDbType =
| "specific-database"
| "multiple-databases"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface OracleSettings {
  AddSupplementalLogging?: boolean | null;
  ArchivedLogDestId?: number | null;
  AdditionalArchivedLogDestId?: number | null;
  AllowSelectNestedTables?: boolean | null;
  ParallelAsmReadThreads?: number | null;
  ReadAheadBlocks?: number | null;
  AccessAlternateDirectly?: boolean | null;
  UseAlternateFolderForOnline?: boolean | null;
  OraclePathPrefix?: string | null;
  UsePathPrefix?: string | null;
  ReplacePathPrefix?: boolean | null;
  EnableHomogenousTablespace?: boolean | null;
  DirectPathNoLog?: boolean | null;
  ArchivedLogsOnly?: boolean | null;
  AsmPassword?: string | null;
  AsmServer?: string | null;
  AsmUser?: string | null;
  CharLengthSemantics?: CharLengthSemantics | null;
  DatabaseName?: string | null;
  DirectPathParallelLoad?: boolean | null;
  FailTasksOnLobTruncation?: boolean | null;
  NumberDatatypeScale?: number | null;
  Password?: string | null;
  Port?: number | null;
  ReadTableSpaceName?: boolean | null;
  RetryInterval?: number | null;
  SecurityDbEncryption?: string | null;
  SecurityDbEncryptionName?: string | null;
  ServerName?: string | null;
  Username?: string | null;
}
function fromOracleSettings(input?: OracleSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AddSupplementalLogging: input["AddSupplementalLogging"],
    ArchivedLogDestId: input["ArchivedLogDestId"],
    AdditionalArchivedLogDestId: input["AdditionalArchivedLogDestId"],
    AllowSelectNestedTables: input["AllowSelectNestedTables"],
    ParallelAsmReadThreads: input["ParallelAsmReadThreads"],
    ReadAheadBlocks: input["ReadAheadBlocks"],
    AccessAlternateDirectly: input["AccessAlternateDirectly"],
    UseAlternateFolderForOnline: input["UseAlternateFolderForOnline"],
    OraclePathPrefix: input["OraclePathPrefix"],
    UsePathPrefix: input["UsePathPrefix"],
    ReplacePathPrefix: input["ReplacePathPrefix"],
    EnableHomogenousTablespace: input["EnableHomogenousTablespace"],
    DirectPathNoLog: input["DirectPathNoLog"],
    ArchivedLogsOnly: input["ArchivedLogsOnly"],
    AsmPassword: input["AsmPassword"],
    AsmServer: input["AsmServer"],
    AsmUser: input["AsmUser"],
    CharLengthSemantics: input["CharLengthSemantics"],
    DatabaseName: input["DatabaseName"],
    DirectPathParallelLoad: input["DirectPathParallelLoad"],
    FailTasksOnLobTruncation: input["FailTasksOnLobTruncation"],
    NumberDatatypeScale: input["NumberDatatypeScale"],
    Password: input["Password"],
    Port: input["Port"],
    ReadTableSpaceName: input["ReadTableSpaceName"],
    RetryInterval: input["RetryInterval"],
    SecurityDbEncryption: input["SecurityDbEncryption"],
    SecurityDbEncryptionName: input["SecurityDbEncryptionName"],
    ServerName: input["ServerName"],
    Username: input["Username"],
  }
}
function toOracleSettings(root: jsonP.JSONValue): OracleSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AddSupplementalLogging": "b",
      "ArchivedLogDestId": "n",
      "AdditionalArchivedLogDestId": "n",
      "AllowSelectNestedTables": "b",
      "ParallelAsmReadThreads": "n",
      "ReadAheadBlocks": "n",
      "AccessAlternateDirectly": "b",
      "UseAlternateFolderForOnline": "b",
      "OraclePathPrefix": "s",
      "UsePathPrefix": "s",
      "ReplacePathPrefix": "b",
      "EnableHomogenousTablespace": "b",
      "DirectPathNoLog": "b",
      "ArchivedLogsOnly": "b",
      "AsmPassword": "s",
      "AsmServer": "s",
      "AsmUser": "s",
      "CharLengthSemantics": (x: jsonP.JSONValue) => cmnP.readEnum<CharLengthSemantics>(x),
      "DatabaseName": "s",
      "DirectPathParallelLoad": "b",
      "FailTasksOnLobTruncation": "b",
      "NumberDatatypeScale": "n",
      "Password": "s",
      "Port": "n",
      "ReadTableSpaceName": "b",
      "RetryInterval": "n",
      "SecurityDbEncryption": "s",
      "SecurityDbEncryptionName": "s",
      "ServerName": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type CharLengthSemantics =
| "default"
| "char"
| "byte"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface SybaseSettings {
  DatabaseName?: string | null;
  Password?: string | null;
  Port?: number | null;
  ServerName?: string | null;
  Username?: string | null;
}
function fromSybaseSettings(input?: SybaseSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    Username: input["Username"],
  }
}
function toSybaseSettings(root: jsonP.JSONValue): SybaseSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatabaseName": "s",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MicrosoftSQLServerSettings {
  Port?: number | null;
  BcpPacketSize?: number | null;
  DatabaseName?: string | null;
  ControlTablesFileGroup?: string | null;
  Password?: string | null;
  ReadBackupOnly?: boolean | null;
  SafeguardPolicy?: SafeguardPolicy | null;
  ServerName?: string | null;
  Username?: string | null;
  UseBcpFullLoad?: boolean | null;
}
function fromMicrosoftSQLServerSettings(input?: MicrosoftSQLServerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Port: input["Port"],
    BcpPacketSize: input["BcpPacketSize"],
    DatabaseName: input["DatabaseName"],
    ControlTablesFileGroup: input["ControlTablesFileGroup"],
    Password: input["Password"],
    ReadBackupOnly: input["ReadBackupOnly"],
    SafeguardPolicy: input["SafeguardPolicy"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    UseBcpFullLoad: input["UseBcpFullLoad"],
  }
}
function toMicrosoftSQLServerSettings(root: jsonP.JSONValue): MicrosoftSQLServerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Port": "n",
      "BcpPacketSize": "n",
      "DatabaseName": "s",
      "ControlTablesFileGroup": "s",
      "Password": "s",
      "ReadBackupOnly": "b",
      "SafeguardPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<SafeguardPolicy>(x),
      "ServerName": "s",
      "Username": "s",
      "UseBcpFullLoad": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type SafeguardPolicy =
| "rely-on-sql-server-replication-agent"
| "exclusive-automatic-truncation"
| "shared-automatic-truncation"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface IBMDb2Settings {
  DatabaseName?: string | null;
  Password?: string | null;
  Port?: number | null;
  ServerName?: string | null;
  SetDataCaptureChanges?: boolean | null;
  CurrentLsn?: string | null;
  MaxKBytesPerRead?: number | null;
  Username?: string | null;
}
function fromIBMDb2Settings(input?: IBMDb2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    SetDataCaptureChanges: input["SetDataCaptureChanges"],
    CurrentLsn: input["CurrentLsn"],
    MaxKBytesPerRead: input["MaxKBytesPerRead"],
    Username: input["Username"],
  }
}
function toIBMDb2Settings(root: jsonP.JSONValue): IBMDb2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatabaseName": "s",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "SetDataCaptureChanges": "b",
      "CurrentLsn": "s",
      "MaxKBytesPerRead": "n",
      "Username": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type MigrationTypeValue =
| "full-load"
| "cdc"
| "full-load-and-cdc"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, interface
export interface Filter {
  Name: string;
  Values: string[];
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "replication-instance"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TableToReload {
  SchemaName: string;
  TableName: string;
}
function fromTableToReload(input?: TableToReload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaName: input["SchemaName"],
    TableName: input["TableName"],
  }
}

// refs: 1 - tags: input, named, enum
export type ReloadOptionValue =
| "data-reload"
| "validate-only"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type StartReplicationTaskTypeValue =
| "start-replication"
| "resume-processing"
| "reload-target"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ResourcePendingMaintenanceActions {
  ResourceIdentifier?: string | null;
  PendingMaintenanceActionDetails?: PendingMaintenanceAction[] | null;
}
function toResourcePendingMaintenanceActions(root: jsonP.JSONValue): ResourcePendingMaintenanceActions {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceIdentifier": "s",
      "PendingMaintenanceActionDetails": [toPendingMaintenanceAction],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface PendingMaintenanceAction {
  Action?: string | null;
  AutoAppliedAfterDate?: Date | number | null;
  ForcedApplyDate?: Date | number | null;
  OptInStatus?: string | null;
  CurrentApplyDate?: Date | number | null;
  Description?: string | null;
}
function toPendingMaintenanceAction(root: jsonP.JSONValue): PendingMaintenanceAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": "s",
      "AutoAppliedAfterDate": "d",
      "ForcedApplyDate": "d",
      "OptInStatus": "s",
      "CurrentApplyDate": "d",
      "Description": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ReplicationTaskAssessmentRun {
  ReplicationTaskAssessmentRunArn?: string | null;
  ReplicationTaskArn?: string | null;
  Status?: string | null;
  ReplicationTaskAssessmentRunCreationDate?: Date | number | null;
  AssessmentProgress?: ReplicationTaskAssessmentRunProgress | null;
  LastFailureMessage?: string | null;
  ServiceAccessRoleArn?: string | null;
  ResultLocationBucket?: string | null;
  ResultLocationFolder?: string | null;
  ResultEncryptionMode?: string | null;
  ResultKmsKeyArn?: string | null;
  AssessmentRunName?: string | null;
}
function toReplicationTaskAssessmentRun(root: jsonP.JSONValue): ReplicationTaskAssessmentRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskAssessmentRunArn": "s",
      "ReplicationTaskArn": "s",
      "Status": "s",
      "ReplicationTaskAssessmentRunCreationDate": "d",
      "AssessmentProgress": toReplicationTaskAssessmentRunProgress,
      "LastFailureMessage": "s",
      "ServiceAccessRoleArn": "s",
      "ResultLocationBucket": "s",
      "ResultLocationFolder": "s",
      "ResultEncryptionMode": "s",
      "ResultKmsKeyArn": "s",
      "AssessmentRunName": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ReplicationTaskAssessmentRunProgress {
  IndividualAssessmentCount?: number | null;
  IndividualAssessmentCompletedCount?: number | null;
}
function toReplicationTaskAssessmentRunProgress(root: jsonP.JSONValue): ReplicationTaskAssessmentRunProgress {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndividualAssessmentCount": "n",
      "IndividualAssessmentCompletedCount": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Endpoint {
  EndpointIdentifier?: string | null;
  EndpointType?: ReplicationEndpointTypeValue | null;
  EngineName?: string | null;
  EngineDisplayName?: string | null;
  Username?: string | null;
  ServerName?: string | null;
  Port?: number | null;
  DatabaseName?: string | null;
  ExtraConnectionAttributes?: string | null;
  Status?: string | null;
  KmsKeyId?: string | null;
  EndpointArn?: string | null;
  CertificateArn?: string | null;
  SslMode?: DmsSslModeValue | null;
  ServiceAccessRoleArn?: string | null;
  ExternalTableDefinition?: string | null;
  ExternalId?: string | null;
  DynamoDbSettings?: DynamoDbSettings | null;
  S3Settings?: S3Settings | null;
  DmsTransferSettings?: DmsTransferSettings | null;
  MongoDbSettings?: MongoDbSettings | null;
  KinesisSettings?: KinesisSettings | null;
  KafkaSettings?: KafkaSettings | null;
  ElasticsearchSettings?: ElasticsearchSettings | null;
  NeptuneSettings?: NeptuneSettings | null;
  RedshiftSettings?: RedshiftSettings | null;
  PostgreSQLSettings?: PostgreSQLSettings | null;
  MySQLSettings?: MySQLSettings | null;
  OracleSettings?: OracleSettings | null;
  SybaseSettings?: SybaseSettings | null;
  MicrosoftSQLServerSettings?: MicrosoftSQLServerSettings | null;
  IBMDb2Settings?: IBMDb2Settings | null;
}
function toEndpoint(root: jsonP.JSONValue): Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointIdentifier": "s",
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<ReplicationEndpointTypeValue>(x),
      "EngineName": "s",
      "EngineDisplayName": "s",
      "Username": "s",
      "ServerName": "s",
      "Port": "n",
      "DatabaseName": "s",
      "ExtraConnectionAttributes": "s",
      "Status": "s",
      "KmsKeyId": "s",
      "EndpointArn": "s",
      "CertificateArn": "s",
      "SslMode": (x: jsonP.JSONValue) => cmnP.readEnum<DmsSslModeValue>(x),
      "ServiceAccessRoleArn": "s",
      "ExternalTableDefinition": "s",
      "ExternalId": "s",
      "DynamoDbSettings": toDynamoDbSettings,
      "S3Settings": toS3Settings,
      "DmsTransferSettings": toDmsTransferSettings,
      "MongoDbSettings": toMongoDbSettings,
      "KinesisSettings": toKinesisSettings,
      "KafkaSettings": toKafkaSettings,
      "ElasticsearchSettings": toElasticsearchSettings,
      "NeptuneSettings": toNeptuneSettings,
      "RedshiftSettings": toRedshiftSettings,
      "PostgreSQLSettings": toPostgreSQLSettings,
      "MySQLSettings": toMySQLSettings,
      "OracleSettings": toOracleSettings,
      "SybaseSettings": toSybaseSettings,
      "MicrosoftSQLServerSettings": toMicrosoftSQLServerSettings,
      "IBMDb2Settings": toIBMDb2Settings,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface EventSubscription {
  CustomerAwsId?: string | null;
  CustSubscriptionId?: string | null;
  SnsTopicArn?: string | null;
  Status?: string | null;
  SubscriptionCreationTime?: string | null;
  SourceType?: string | null;
  SourceIdsList?: string[] | null;
  EventCategoriesList?: string[] | null;
  Enabled?: boolean | null;
}
function toEventSubscription(root: jsonP.JSONValue): EventSubscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomerAwsId": "s",
      "CustSubscriptionId": "s",
      "SnsTopicArn": "s",
      "Status": "s",
      "SubscriptionCreationTime": "s",
      "SourceType": "s",
      "SourceIdsList": ["s"],
      "EventCategoriesList": ["s"],
      "Enabled": "b",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface ReplicationInstance {
  ReplicationInstanceIdentifier?: string | null;
  ReplicationInstanceClass?: string | null;
  ReplicationInstanceStatus?: string | null;
  AllocatedStorage?: number | null;
  InstanceCreateTime?: Date | number | null;
  VpcSecurityGroups?: VpcSecurityGroupMembership[] | null;
  AvailabilityZone?: string | null;
  ReplicationSubnetGroup?: ReplicationSubnetGroup | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: ReplicationPendingModifiedValues | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  KmsKeyId?: string | null;
  ReplicationInstanceArn?: string | null;
  ReplicationInstancePublicIpAddress?: string | null;
  ReplicationInstancePrivateIpAddress?: string | null;
  ReplicationInstancePublicIpAddresses?: string[] | null;
  ReplicationInstancePrivateIpAddresses?: string[] | null;
  PubliclyAccessible?: boolean | null;
  SecondaryAvailabilityZone?: string | null;
  FreeUntil?: Date | number | null;
  DnsNameServers?: string | null;
}
function toReplicationInstance(root: jsonP.JSONValue): ReplicationInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceIdentifier": "s",
      "ReplicationInstanceClass": "s",
      "ReplicationInstanceStatus": "s",
      "AllocatedStorage": "n",
      "InstanceCreateTime": "d",
      "VpcSecurityGroups": [toVpcSecurityGroupMembership],
      "AvailabilityZone": "s",
      "ReplicationSubnetGroup": toReplicationSubnetGroup,
      "PreferredMaintenanceWindow": "s",
      "PendingModifiedValues": toReplicationPendingModifiedValues,
      "MultiAZ": "b",
      "EngineVersion": "s",
      "AutoMinorVersionUpgrade": "b",
      "KmsKeyId": "s",
      "ReplicationInstanceArn": "s",
      "ReplicationInstancePublicIpAddress": "s",
      "ReplicationInstancePrivateIpAddress": "s",
      "ReplicationInstancePublicIpAddresses": ["s"],
      "ReplicationInstancePrivateIpAddresses": ["s"],
      "PubliclyAccessible": "b",
      "SecondaryAvailabilityZone": "s",
      "FreeUntil": "d",
      "DnsNameServers": "s",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string | null;
  Status?: string | null;
}
function toVpcSecurityGroupMembership(root: jsonP.JSONValue): VpcSecurityGroupMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcSecurityGroupId": "s",
      "Status": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface ReplicationSubnetGroup {
  ReplicationSubnetGroupIdentifier?: string | null;
  ReplicationSubnetGroupDescription?: string | null;
  VpcId?: string | null;
  SubnetGroupStatus?: string | null;
  Subnets?: Subnet[] | null;
}
function toReplicationSubnetGroup(root: jsonP.JSONValue): ReplicationSubnetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationSubnetGroupIdentifier": "s",
      "ReplicationSubnetGroupDescription": "s",
      "VpcId": "s",
      "SubnetGroupStatus": "s",
      "Subnets": [toSubnet],
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetStatus?: string | null;
}
function toSubnet(root: jsonP.JSONValue): Subnet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIdentifier": "s",
      "SubnetAvailabilityZone": toAvailabilityZone,
      "SubnetStatus": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
}
function toAvailabilityZone(root: jsonP.JSONValue): AvailabilityZone {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface ReplicationPendingModifiedValues {
  ReplicationInstanceClass?: string | null;
  AllocatedStorage?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
}
function toReplicationPendingModifiedValues(root: jsonP.JSONValue): ReplicationPendingModifiedValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceClass": "s",
      "AllocatedStorage": "n",
      "MultiAZ": "b",
      "EngineVersion": "s",
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface ReplicationTask {
  ReplicationTaskIdentifier?: string | null;
  SourceEndpointArn?: string | null;
  TargetEndpointArn?: string | null;
  ReplicationInstanceArn?: string | null;
  MigrationType?: MigrationTypeValue | null;
  TableMappings?: string | null;
  ReplicationTaskSettings?: string | null;
  Status?: string | null;
  LastFailureMessage?: string | null;
  StopReason?: string | null;
  ReplicationTaskCreationDate?: Date | number | null;
  ReplicationTaskStartDate?: Date | number | null;
  CdcStartPosition?: string | null;
  CdcStopPosition?: string | null;
  RecoveryCheckpoint?: string | null;
  ReplicationTaskArn?: string | null;
  ReplicationTaskStats?: ReplicationTaskStats | null;
  TaskData?: string | null;
}
function toReplicationTask(root: jsonP.JSONValue): ReplicationTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIdentifier": "s",
      "SourceEndpointArn": "s",
      "TargetEndpointArn": "s",
      "ReplicationInstanceArn": "s",
      "MigrationType": (x: jsonP.JSONValue) => cmnP.readEnum<MigrationTypeValue>(x),
      "TableMappings": "s",
      "ReplicationTaskSettings": "s",
      "Status": "s",
      "LastFailureMessage": "s",
      "StopReason": "s",
      "ReplicationTaskCreationDate": "d",
      "ReplicationTaskStartDate": "d",
      "CdcStartPosition": "s",
      "CdcStopPosition": "s",
      "RecoveryCheckpoint": "s",
      "ReplicationTaskArn": "s",
      "ReplicationTaskStats": toReplicationTaskStats,
      "TaskData": "s",
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface ReplicationTaskStats {
  FullLoadProgressPercent?: number | null;
  ElapsedTimeMillis?: number | null;
  TablesLoaded?: number | null;
  TablesLoading?: number | null;
  TablesQueued?: number | null;
  TablesErrored?: number | null;
  FreshStartDate?: Date | number | null;
  StartDate?: Date | number | null;
  StopDate?: Date | number | null;
  FullLoadStartDate?: Date | number | null;
  FullLoadFinishDate?: Date | number | null;
}
function toReplicationTaskStats(root: jsonP.JSONValue): ReplicationTaskStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "FullLoadProgressPercent": "n",
      "ElapsedTimeMillis": "n",
      "TablesLoaded": "n",
      "TablesLoading": "n",
      "TablesQueued": "n",
      "TablesErrored": "n",
      "FreshStartDate": "d",
      "StartDate": "d",
      "StopDate": "d",
      "FullLoadStartDate": "d",
      "FullLoadFinishDate": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Certificate {
  CertificateIdentifier?: string | null;
  CertificateCreationDate?: Date | number | null;
  CertificatePem?: string | null;
  CertificateWallet?: Uint8Array | string | null;
  CertificateArn?: string | null;
  CertificateOwner?: string | null;
  ValidFromDate?: Date | number | null;
  ValidToDate?: Date | number | null;
  SigningAlgorithm?: string | null;
  KeyLength?: number | null;
}
function toCertificate(root: jsonP.JSONValue): Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateIdentifier": "s",
      "CertificateCreationDate": "d",
      "CertificatePem": "s",
      "CertificateWallet": "a",
      "CertificateArn": "s",
      "CertificateOwner": "s",
      "ValidFromDate": "d",
      "ValidToDate": "d",
      "SigningAlgorithm": "s",
      "KeyLength": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Connection {
  ReplicationInstanceArn?: string | null;
  EndpointArn?: string | null;
  Status?: string | null;
  LastFailureMessage?: string | null;
  EndpointIdentifier?: string | null;
  ReplicationInstanceIdentifier?: string | null;
}
function toConnection(root: jsonP.JSONValue): Connection {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceArn": "s",
      "EndpointArn": "s",
      "Status": "s",
      "LastFailureMessage": "s",
      "EndpointIdentifier": "s",
      "ReplicationInstanceIdentifier": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AccountQuota {
  AccountQuotaName?: string | null;
  Used?: number | null;
  Max?: number | null;
}
function toAccountQuota(root: jsonP.JSONValue): AccountQuota {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountQuotaName": "s",
      "Used": "n",
      "Max": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SupportedEndpointType {
  EngineName?: string | null;
  SupportsCDC?: boolean | null;
  EndpointType?: ReplicationEndpointTypeValue | null;
  ReplicationInstanceEngineMinimumVersion?: string | null;
  EngineDisplayName?: string | null;
}
function toSupportedEndpointType(root: jsonP.JSONValue): SupportedEndpointType {
  return jsonP.readObj({
    required: {},
    optional: {
      "EngineName": "s",
      "SupportsCDC": "b",
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<ReplicationEndpointTypeValue>(x),
      "ReplicationInstanceEngineMinimumVersion": "s",
      "EngineDisplayName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EventCategoryGroup {
  SourceType?: string | null;
  EventCategories?: string[] | null;
}
function toEventCategoryGroup(root: jsonP.JSONValue): EventCategoryGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceType": "s",
      "EventCategories": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  EventCategories?: string[] | null;
  Date?: Date | number | null;
}
function toEvent(root: jsonP.JSONValue): Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceIdentifier": "s",
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<SourceType>(x),
      "Message": "s",
      "EventCategories": ["s"],
      "Date": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface OrderableReplicationInstance {
  EngineVersion?: string | null;
  ReplicationInstanceClass?: string | null;
  StorageType?: string | null;
  MinAllocatedStorage?: number | null;
  MaxAllocatedStorage?: number | null;
  DefaultAllocatedStorage?: number | null;
  IncludedAllocatedStorage?: number | null;
  AvailabilityZones?: string[] | null;
  ReleaseStatus?: ReleaseStatusValues | null;
}
function toOrderableReplicationInstance(root: jsonP.JSONValue): OrderableReplicationInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "EngineVersion": "s",
      "ReplicationInstanceClass": "s",
      "StorageType": "s",
      "MinAllocatedStorage": "n",
      "MaxAllocatedStorage": "n",
      "DefaultAllocatedStorage": "n",
      "IncludedAllocatedStorage": "n",
      "AvailabilityZones": ["s"],
      "ReleaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ReleaseStatusValues>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ReleaseStatusValues =
| "beta"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface RefreshSchemasStatus {
  EndpointArn?: string | null;
  ReplicationInstanceArn?: string | null;
  Status?: RefreshSchemasStatusTypeValue | null;
  LastRefreshDate?: Date | number | null;
  LastFailureMessage?: string | null;
}
function toRefreshSchemasStatus(root: jsonP.JSONValue): RefreshSchemasStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointArn": "s",
      "ReplicationInstanceArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<RefreshSchemasStatusTypeValue>(x),
      "LastRefreshDate": "d",
      "LastFailureMessage": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type RefreshSchemasStatusTypeValue =
| "successful"
| "failed"
| "refreshing"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ReplicationInstanceTaskLog {
  ReplicationTaskName?: string | null;
  ReplicationTaskArn?: string | null;
  ReplicationInstanceTaskLogSize?: number | null;
}
function toReplicationInstanceTaskLog(root: jsonP.JSONValue): ReplicationInstanceTaskLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskName": "s",
      "ReplicationTaskArn": "s",
      "ReplicationInstanceTaskLogSize": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReplicationTaskAssessmentResult {
  ReplicationTaskIdentifier?: string | null;
  ReplicationTaskArn?: string | null;
  ReplicationTaskLastAssessmentDate?: Date | number | null;
  AssessmentStatus?: string | null;
  AssessmentResultsFile?: string | null;
  AssessmentResults?: string | null;
  S3ObjectUrl?: string | null;
}
function toReplicationTaskAssessmentResult(root: jsonP.JSONValue): ReplicationTaskAssessmentResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIdentifier": "s",
      "ReplicationTaskArn": "s",
      "ReplicationTaskLastAssessmentDate": "d",
      "AssessmentStatus": "s",
      "AssessmentResultsFile": "s",
      "AssessmentResults": "s",
      "S3ObjectUrl": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReplicationTaskIndividualAssessment {
  ReplicationTaskIndividualAssessmentArn?: string | null;
  ReplicationTaskAssessmentRunArn?: string | null;
  IndividualAssessmentName?: string | null;
  Status?: string | null;
  ReplicationTaskIndividualAssessmentStartDate?: Date | number | null;
}
function toReplicationTaskIndividualAssessment(root: jsonP.JSONValue): ReplicationTaskIndividualAssessment {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIndividualAssessmentArn": "s",
      "ReplicationTaskAssessmentRunArn": "s",
      "IndividualAssessmentName": "s",
      "Status": "s",
      "ReplicationTaskIndividualAssessmentStartDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TableStatistics {
  SchemaName?: string | null;
  TableName?: string | null;
  Inserts?: number | null;
  Deletes?: number | null;
  Updates?: number | null;
  Ddls?: number | null;
  FullLoadRows?: number | null;
  FullLoadCondtnlChkFailedRows?: number | null;
  FullLoadErrorRows?: number | null;
  FullLoadStartTime?: Date | number | null;
  FullLoadEndTime?: Date | number | null;
  FullLoadReloaded?: boolean | null;
  LastUpdateTime?: Date | number | null;
  TableState?: string | null;
  ValidationPendingRecords?: number | null;
  ValidationFailedRecords?: number | null;
  ValidationSuspendedRecords?: number | null;
  ValidationState?: string | null;
  ValidationStateDetails?: string | null;
}
function toTableStatistics(root: jsonP.JSONValue): TableStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaName": "s",
      "TableName": "s",
      "Inserts": "n",
      "Deletes": "n",
      "Updates": "n",
      "Ddls": "n",
      "FullLoadRows": "n",
      "FullLoadCondtnlChkFailedRows": "n",
      "FullLoadErrorRows": "n",
      "FullLoadStartTime": "d",
      "FullLoadEndTime": "d",
      "FullLoadReloaded": "b",
      "LastUpdateTime": "d",
      "TableState": "s",
      "ValidationPendingRecords": "n",
      "ValidationFailedRecords": "n",
      "ValidationSuspendedRecords": "n",
      "ValidationState": "s",
      "ValidationStateDetails": "s",
    },
  }, root);
}
