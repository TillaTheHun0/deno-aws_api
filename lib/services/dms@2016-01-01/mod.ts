// Autogenerated API client for: AWS Database Migration Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class DMS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DMS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-01-01",
    "endpointPrefix": "dms",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Database Migration Service",
    "serviceId": "Database Migration Service",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonDMSv20160101",
    "uid": "dms-2016-01-01"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceMessage,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    await resp.text();
  }

  async applyPendingMaintenanceAction(
    {abortSignal, ...params}: RequestConfig & s.ApplyPendingMaintenanceActionMessage,
  ): Promise<s.ApplyPendingMaintenanceActionResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      ApplyAction: params["ApplyAction"],
      OptInType: params["OptInType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyPendingMaintenanceAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourcePendingMaintenanceActions": toResourcePendingMaintenanceActions,
      },
    }, await resp.json());
  }

  async cancelReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & s.CancelReplicationTaskAssessmentRunMessage,
  ): Promise<s.CancelReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskAssessmentRunArn: params["ReplicationTaskAssessmentRunArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async createEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateEndpointMessage,
  ): Promise<s.CreateEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointIdentifier: params["EndpointIdentifier"],
      EndpointType: params["EndpointType"],
      EngineName: params["EngineName"],
      Username: params["Username"],
      Password: params["Password"],
      ServerName: params["ServerName"],
      Port: params["Port"],
      DatabaseName: params["DatabaseName"],
      ExtraConnectionAttributes: params["ExtraConnectionAttributes"],
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      CertificateArn: params["CertificateArn"],
      SslMode: params["SslMode"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ExternalTableDefinition: params["ExternalTableDefinition"],
      DynamoDbSettings: fromDynamoDbSettings(params["DynamoDbSettings"]),
      S3Settings: fromS3Settings(params["S3Settings"]),
      DmsTransferSettings: fromDmsTransferSettings(params["DmsTransferSettings"]),
      MongoDbSettings: fromMongoDbSettings(params["MongoDbSettings"]),
      KinesisSettings: fromKinesisSettings(params["KinesisSettings"]),
      KafkaSettings: fromKafkaSettings(params["KafkaSettings"]),
      ElasticsearchSettings: fromElasticsearchSettings(params["ElasticsearchSettings"]),
      NeptuneSettings: fromNeptuneSettings(params["NeptuneSettings"]),
      RedshiftSettings: fromRedshiftSettings(params["RedshiftSettings"]),
      PostgreSQLSettings: fromPostgreSQLSettings(params["PostgreSQLSettings"]),
      MySQLSettings: fromMySQLSettings(params["MySQLSettings"]),
      OracleSettings: fromOracleSettings(params["OracleSettings"]),
      SybaseSettings: fromSybaseSettings(params["SybaseSettings"]),
      MicrosoftSQLServerSettings: fromMicrosoftSQLServerSettings(params["MicrosoftSQLServerSettings"]),
      IBMDb2Settings: fromIBMDb2Settings(params["IBMDb2Settings"]),
      ResourceIdentifier: params["ResourceIdentifier"],
      DocDbSettings: fromDocDbSettings(params["DocDbSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateEventSubscriptionMessage,
  ): Promise<s.CreateEventSubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionName: params["SubscriptionName"],
      SnsTopicArn: params["SnsTopicArn"],
      SourceType: params["SourceType"],
      EventCategories: params["EventCategories"],
      SourceIds: params["SourceIds"],
      Enabled: params["Enabled"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async createReplicationInstance(
    {abortSignal, ...params}: RequestConfig & s.CreateReplicationInstanceMessage,
  ): Promise<s.CreateReplicationInstanceResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceIdentifier: params["ReplicationInstanceIdentifier"],
      AllocatedStorage: params["AllocatedStorage"],
      ReplicationInstanceClass: params["ReplicationInstanceClass"],
      VpcSecurityGroupIds: params["VpcSecurityGroupIds"],
      AvailabilityZone: params["AvailabilityZone"],
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      MultiAZ: params["MultiAZ"],
      EngineVersion: params["EngineVersion"],
      AutoMinorVersionUpgrade: params["AutoMinorVersionUpgrade"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KmsKeyId: params["KmsKeyId"],
      PubliclyAccessible: params["PubliclyAccessible"],
      DnsNameServers: params["DnsNameServers"],
      ResourceIdentifier: params["ResourceIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async createReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateReplicationSubnetGroupMessage,
  ): Promise<s.CreateReplicationSubnetGroupResponse> {
    const body: jsonP.JSONObject = {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      ReplicationSubnetGroupDescription: params["ReplicationSubnetGroupDescription"],
      SubnetIds: params["SubnetIds"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationSubnetGroup": toReplicationSubnetGroup,
      },
    }, await resp.json());
  }

  async createReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.CreateReplicationTaskMessage,
  ): Promise<s.CreateReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskIdentifier: params["ReplicationTaskIdentifier"],
      SourceEndpointArn: params["SourceEndpointArn"],
      TargetEndpointArn: params["TargetEndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      MigrationType: params["MigrationType"],
      TableMappings: params["TableMappings"],
      ReplicationTaskSettings: params["ReplicationTaskSettings"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      TaskData: params["TaskData"],
      ResourceIdentifier: params["ResourceIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async deleteCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCertificateMessage,
  ): Promise<s.DeleteCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificate,
      },
    }, await resp.json());
  }

  async deleteConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteConnectionMessage,
  ): Promise<s.DeleteConnectionResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteEndpointMessage,
  ): Promise<s.DeleteEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventSubscriptionMessage,
  ): Promise<s.DeleteEventSubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionName: params["SubscriptionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async deleteReplicationInstance(
    {abortSignal, ...params}: RequestConfig & s.DeleteReplicationInstanceMessage,
  ): Promise<s.DeleteReplicationInstanceResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async deleteReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteReplicationSubnetGroupMessage,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationSubnetGroup",
    });
    await resp.text();
  }

  async deleteReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.DeleteReplicationTaskMessage,
  ): Promise<s.DeleteReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async deleteReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & s.DeleteReplicationTaskAssessmentRunMessage,
  ): Promise<s.DeleteReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskAssessmentRunArn: params["ReplicationTaskAssessmentRunArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async describeAccountAttributes(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeAccountAttributesResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountQuotas": [toAccountQuota],
        "UniqueAccountIdentifier": "s",
      },
    }, await resp.json());
  }

  async describeApplicableIndividualAssessments(
    {abortSignal, ...params}: RequestConfig & s.DescribeApplicableIndividualAssessmentsMessage = {},
  ): Promise<s.DescribeApplicableIndividualAssessmentsResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      SourceEngineName: params["SourceEngineName"],
      TargetEngineName: params["TargetEngineName"],
      MigrationType: params["MigrationType"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApplicableIndividualAssessments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IndividualAssessmentNames": ["s"],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeCertificates(
    {abortSignal, ...params}: RequestConfig & s.DescribeCertificatesMessage = {},
  ): Promise<s.DescribeCertificatesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Certificates": [toCertificate],
      },
    }, await resp.json());
  }

  async describeConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeConnectionsMessage = {},
  ): Promise<s.DescribeConnectionsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Connections": [toConnection],
      },
    }, await resp.json());
  }

  async describeEndpointTypes(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointTypesMessage = {},
  ): Promise<s.DescribeEndpointTypesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpointTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "SupportedEndpointTypes": [toSupportedEndpointType],
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointsMessage = {},
  ): Promise<s.DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Endpoints": [toEndpoint],
      },
    }, await resp.json());
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventCategoriesMessage = {},
  ): Promise<s.DescribeEventCategoriesResponse> {
    const body: jsonP.JSONObject = {
      SourceType: params["SourceType"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventCategoryGroupList": [toEventCategoryGroup],
      },
    }, await resp.json());
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventSubscriptionsMessage = {},
  ): Promise<s.DescribeEventSubscriptionsResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionName: params["SubscriptionName"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "EventSubscriptionsList": [toEventSubscription],
      },
    }, await resp.json());
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsMessage = {},
  ): Promise<s.DescribeEventsResponse> {
    const body: jsonP.JSONObject = {
      SourceIdentifier: params["SourceIdentifier"],
      SourceType: params["SourceType"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Duration: params["Duration"],
      EventCategories: params["EventCategories"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Events": [toEvent],
      },
    }, await resp.json());
  }

  async describeOrderableReplicationInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeOrderableReplicationInstancesMessage = {},
  ): Promise<s.DescribeOrderableReplicationInstancesResponse> {
    const body: jsonP.JSONObject = {
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableReplicationInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "OrderableReplicationInstances": [toOrderableReplicationInstance],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describePendingMaintenanceActions(
    {abortSignal, ...params}: RequestConfig & s.DescribePendingMaintenanceActionsMessage = {},
  ): Promise<s.DescribePendingMaintenanceActionsResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      Marker: params["Marker"],
      MaxRecords: params["MaxRecords"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePendingMaintenanceActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PendingMaintenanceActions": [toResourcePendingMaintenanceActions],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeRefreshSchemasStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeRefreshSchemasStatusMessage,
  ): Promise<s.DescribeRefreshSchemasStatusResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRefreshSchemasStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RefreshSchemasStatus": toRefreshSchemasStatus,
      },
    }, await resp.json());
  }

  async describeReplicationInstanceTaskLogs(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationInstanceTaskLogsMessage,
  ): Promise<s.DescribeReplicationInstanceTaskLogsResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationInstanceTaskLogs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstanceArn": "s",
        "ReplicationInstanceTaskLogs": [toReplicationInstanceTaskLog],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async describeReplicationInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationInstancesMessage = {},
  ): Promise<s.DescribeReplicationInstancesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationInstances": [toReplicationInstance],
      },
    }, await resp.json());
  }

  async describeReplicationSubnetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationSubnetGroupsMessage = {},
  ): Promise<s.DescribeReplicationSubnetGroupsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationSubnetGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationSubnetGroups": [toReplicationSubnetGroup],
      },
    }, await resp.json());
  }

  async describeReplicationTaskAssessmentResults(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationTaskAssessmentResultsMessage = {},
  ): Promise<s.DescribeReplicationTaskAssessmentResultsResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskAssessmentResults",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "BucketName": "s",
        "ReplicationTaskAssessmentResults": [toReplicationTaskAssessmentResult],
      },
    }, await resp.json());
  }

  async describeReplicationTaskAssessmentRuns(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationTaskAssessmentRunsMessage = {},
  ): Promise<s.DescribeReplicationTaskAssessmentRunsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskAssessmentRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTaskAssessmentRuns": [toReplicationTaskAssessmentRun],
      },
    }, await resp.json());
  }

  async describeReplicationTaskIndividualAssessments(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationTaskIndividualAssessmentsMessage = {},
  ): Promise<s.DescribeReplicationTaskIndividualAssessmentsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTaskIndividualAssessments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTaskIndividualAssessments": [toReplicationTaskIndividualAssessment],
      },
    }, await resp.json());
  }

  async describeReplicationTasks(
    {abortSignal, ...params}: RequestConfig & s.DescribeReplicationTasksMessage = {},
  ): Promise<s.DescribeReplicationTasksResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
      WithoutSettings: params["WithoutSettings"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReplicationTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "ReplicationTasks": [toReplicationTask],
      },
    }, await resp.json());
  }

  async describeSchemas(
    {abortSignal, ...params}: RequestConfig & s.DescribeSchemasMessage,
  ): Promise<s.DescribeSchemasResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Marker": "s",
        "Schemas": ["s"],
      },
    }, await resp.json());
  }

  async describeTableStatistics(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableStatisticsMessage,
  ): Promise<s.DescribeTableStatisticsResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      MaxRecords: params["MaxRecords"],
      Marker: params["Marker"],
      Filters: params["Filters"]?.map(x => fromFilter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTableStatistics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskArn": "s",
        "TableStatistics": [toTableStatistics],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async importCertificate(
    {abortSignal, ...params}: RequestConfig & s.ImportCertificateMessage,
  ): Promise<s.ImportCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateIdentifier: params["CertificateIdentifier"],
      CertificatePem: params["CertificatePem"],
      CertificateWallet: serializeBlob(params["CertificateWallet"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificate,
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceMessage,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TagList": [toTag],
      },
    }, await resp.json());
  }

  async modifyEndpoint(
    {abortSignal, ...params}: RequestConfig & s.ModifyEndpointMessage,
  ): Promise<s.ModifyEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
      EndpointIdentifier: params["EndpointIdentifier"],
      EndpointType: params["EndpointType"],
      EngineName: params["EngineName"],
      Username: params["Username"],
      Password: params["Password"],
      ServerName: params["ServerName"],
      Port: params["Port"],
      DatabaseName: params["DatabaseName"],
      ExtraConnectionAttributes: params["ExtraConnectionAttributes"],
      CertificateArn: params["CertificateArn"],
      SslMode: params["SslMode"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ExternalTableDefinition: params["ExternalTableDefinition"],
      DynamoDbSettings: fromDynamoDbSettings(params["DynamoDbSettings"]),
      S3Settings: fromS3Settings(params["S3Settings"]),
      DmsTransferSettings: fromDmsTransferSettings(params["DmsTransferSettings"]),
      MongoDbSettings: fromMongoDbSettings(params["MongoDbSettings"]),
      KinesisSettings: fromKinesisSettings(params["KinesisSettings"]),
      KafkaSettings: fromKafkaSettings(params["KafkaSettings"]),
      ElasticsearchSettings: fromElasticsearchSettings(params["ElasticsearchSettings"]),
      NeptuneSettings: fromNeptuneSettings(params["NeptuneSettings"]),
      RedshiftSettings: fromRedshiftSettings(params["RedshiftSettings"]),
      PostgreSQLSettings: fromPostgreSQLSettings(params["PostgreSQLSettings"]),
      MySQLSettings: fromMySQLSettings(params["MySQLSettings"]),
      OracleSettings: fromOracleSettings(params["OracleSettings"]),
      SybaseSettings: fromSybaseSettings(params["SybaseSettings"]),
      MicrosoftSQLServerSettings: fromMicrosoftSQLServerSettings(params["MicrosoftSQLServerSettings"]),
      IBMDb2Settings: fromIBMDb2Settings(params["IBMDb2Settings"]),
      DocDbSettings: fromDocDbSettings(params["DocDbSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.ModifyEventSubscriptionMessage,
  ): Promise<s.ModifyEventSubscriptionResponse> {
    const body: jsonP.JSONObject = {
      SubscriptionName: params["SubscriptionName"],
      SnsTopicArn: params["SnsTopicArn"],
      SourceType: params["SourceType"],
      EventCategories: params["EventCategories"],
      Enabled: params["Enabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventSubscription": toEventSubscription,
      },
    }, await resp.json());
  }

  async modifyReplicationInstance(
    {abortSignal, ...params}: RequestConfig & s.ModifyReplicationInstanceMessage,
  ): Promise<s.ModifyReplicationInstanceResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      AllocatedStorage: params["AllocatedStorage"],
      ApplyImmediately: params["ApplyImmediately"],
      ReplicationInstanceClass: params["ReplicationInstanceClass"],
      VpcSecurityGroupIds: params["VpcSecurityGroupIds"],
      PreferredMaintenanceWindow: params["PreferredMaintenanceWindow"],
      MultiAZ: params["MultiAZ"],
      EngineVersion: params["EngineVersion"],
      AllowMajorVersionUpgrade: params["AllowMajorVersionUpgrade"],
      AutoMinorVersionUpgrade: params["AutoMinorVersionUpgrade"],
      ReplicationInstanceIdentifier: params["ReplicationInstanceIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async modifyReplicationSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyReplicationSubnetGroupMessage,
  ): Promise<s.ModifyReplicationSubnetGroupResponse> {
    const body: jsonP.JSONObject = {
      ReplicationSubnetGroupIdentifier: params["ReplicationSubnetGroupIdentifier"],
      ReplicationSubnetGroupDescription: params["ReplicationSubnetGroupDescription"],
      SubnetIds: params["SubnetIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationSubnetGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationSubnetGroup": toReplicationSubnetGroup,
      },
    }, await resp.json());
  }

  async modifyReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.ModifyReplicationTaskMessage,
  ): Promise<s.ModifyReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ReplicationTaskIdentifier: params["ReplicationTaskIdentifier"],
      MigrationType: params["MigrationType"],
      TableMappings: params["TableMappings"],
      ReplicationTaskSettings: params["ReplicationTaskSettings"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
      TaskData: params["TaskData"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async moveReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.MoveReplicationTaskMessage,
  ): Promise<s.MoveReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      TargetReplicationInstanceArn: params["TargetReplicationInstanceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MoveReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async rebootReplicationInstance(
    {abortSignal, ...params}: RequestConfig & s.RebootReplicationInstanceMessage,
  ): Promise<s.RebootReplicationInstanceResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      ForceFailover: params["ForceFailover"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootReplicationInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationInstance": toReplicationInstance,
      },
    }, await resp.json());
  }

  async refreshSchemas(
    {abortSignal, ...params}: RequestConfig & s.RefreshSchemasMessage,
  ): Promise<s.RefreshSchemasResponse> {
    const body: jsonP.JSONObject = {
      EndpointArn: params["EndpointArn"],
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RefreshSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RefreshSchemasStatus": toRefreshSchemasStatus,
      },
    }, await resp.json());
  }

  async reloadTables(
    {abortSignal, ...params}: RequestConfig & s.ReloadTablesMessage,
  ): Promise<s.ReloadTablesResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      TablesToReload: params["TablesToReload"]?.map(x => fromTableToReload(x)),
      ReloadOption: params["ReloadOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReloadTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskArn": "s",
      },
    }, await resp.json());
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceMessage,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    await resp.text();
  }

  async startReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.StartReplicationTaskMessage,
  ): Promise<s.StartReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      StartReplicationTaskType: params["StartReplicationTaskType"],
      CdcStartTime: jsonP.serializeDate_unixTimestamp(params["CdcStartTime"]),
      CdcStartPosition: params["CdcStartPosition"],
      CdcStopPosition: params["CdcStopPosition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async startReplicationTaskAssessment(
    {abortSignal, ...params}: RequestConfig & s.StartReplicationTaskAssessmentMessage,
  ): Promise<s.StartReplicationTaskAssessmentResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTaskAssessment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async startReplicationTaskAssessmentRun(
    {abortSignal, ...params}: RequestConfig & s.StartReplicationTaskAssessmentRunMessage,
  ): Promise<s.StartReplicationTaskAssessmentRunResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
      ServiceAccessRoleArn: params["ServiceAccessRoleArn"],
      ResultLocationBucket: params["ResultLocationBucket"],
      ResultLocationFolder: params["ResultLocationFolder"],
      ResultEncryptionMode: params["ResultEncryptionMode"],
      ResultKmsKeyArn: params["ResultKmsKeyArn"],
      AssessmentRunName: params["AssessmentRunName"],
      IncludeOnly: params["IncludeOnly"],
      Exclude: params["Exclude"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartReplicationTaskAssessmentRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTaskAssessmentRun": toReplicationTaskAssessmentRun,
      },
    }, await resp.json());
  }

  async stopReplicationTask(
    {abortSignal, ...params}: RequestConfig & s.StopReplicationTaskMessage,
  ): Promise<s.StopReplicationTaskResponse> {
    const body: jsonP.JSONObject = {
      ReplicationTaskArn: params["ReplicationTaskArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopReplicationTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReplicationTask": toReplicationTask,
      },
    }, await resp.json());
  }

  async testConnection(
    {abortSignal, ...params}: RequestConfig & s.TestConnectionMessage,
  ): Promise<s.TestConnectionResponse> {
    const body: jsonP.JSONObject = {
      ReplicationInstanceArn: params["ReplicationInstanceArn"],
      EndpointArn: params["EndpointArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until testing connection succeeds.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForTestConnectionSucceeds(
    params: RequestConfig & s.DescribeConnectionsMessage,
  ): Promise<s.DescribeConnectionsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TestConnectionSucceeds';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeConnections(params);
      const field = resp?.Connections?.flatMap(x => x?.Status);
      if (field?.every(x => x === "successful")) return resp;
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until testing endpoint is deleted.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForEndpointDeleted(
    params: RequestConfig & s.DescribeEndpointsMessage,
  ): Promise<Error | s.DescribeEndpointsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeEndpoints(params);
        const field = resp?.Endpoints?.flatMap(x => x?.Status);
        if (field?.some(x => x === "active")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication instance is available.
   * Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time).
   */
  async waitForReplicationInstanceAvailable(
    params: RequestConfig & s.DescribeReplicationInstancesMessage,
  ): Promise<s.DescribeReplicationInstancesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationInstances(params);
      const field = resp?.ReplicationInstances?.flatMap(x => x?.ReplicationInstanceStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-credentials")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-network")) throw new Error(errMessage);
      if (field?.some(x => x === "inaccessible-encryption-credentials")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication instance is deleted.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationInstanceDeleted(
    params: RequestConfig & s.DescribeReplicationInstancesMessage,
  ): Promise<Error | s.DescribeReplicationInstancesResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeReplicationInstances(params);
        if (resp?.ReplicationInstances?.flatMap(x => x?.ReplicationInstanceStatus)?.some(x => x === "available")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is ready.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskReady(
    params: RequestConfig & s.DescribeReplicationTasksMessage,
  ): Promise<s.DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskReady';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "ready")) return resp;
      if (field?.some(x => x === "starting")) throw new Error(errMessage);
      if (field?.some(x => x === "running")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is stopped.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskStopped(
    params: RequestConfig & s.DescribeReplicationTasksMessage,
  ): Promise<s.DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskStopped';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "stopped")) return resp;
      if (field?.some(x => x === "ready")) throw new Error(errMessage);
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "starting")) throw new Error(errMessage);
      if (field?.some(x => x === "running")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is running.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskRunning(
    params: RequestConfig & s.DescribeReplicationTasksMessage,
  ): Promise<s.DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskRunning';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeReplicationTasks(params);
      const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
      if (field?.every(x => x === "running")) return resp;
      if (field?.some(x => x === "ready")) throw new Error(errMessage);
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "stopping")) throw new Error(errMessage);
      if (field?.some(x => x === "stopped")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "testing")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until DMS replication task is deleted.
   * Checks state up to 60 times, 15 seconds apart (about 15 minutes max wait time).
   */
  async waitForReplicationTaskDeleted(
    params: RequestConfig & s.DescribeReplicationTasksMessage,
  ): Promise<Error | s.DescribeReplicationTasksResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ReplicationTaskDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeReplicationTasks(params);
        const field = resp?.ReplicationTasks?.flatMap(x => x?.Status);
        if (field?.some(x => x === "ready")) throw new Error(errMessage);
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "stopped")) throw new Error(errMessage);
        if (field?.some(x => x === "running")) throw new Error(errMessage);
        if (field?.some(x => x === "failed")) throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundFault"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromDynamoDbSettings(input?: s.DynamoDbSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
  }
}
function toDynamoDbSettings(root: jsonP.JSONValue): s.DynamoDbSettings {
  return jsonP.readObj({
    required: {
      "ServiceAccessRoleArn": "s",
    },
    optional: {},
  }, root);
}

function fromS3Settings(input?: s.S3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    ExternalTableDefinition: input["ExternalTableDefinition"],
    CsvRowDelimiter: input["CsvRowDelimiter"],
    CsvDelimiter: input["CsvDelimiter"],
    BucketFolder: input["BucketFolder"],
    BucketName: input["BucketName"],
    CompressionType: input["CompressionType"],
    EncryptionMode: input["EncryptionMode"],
    ServerSideEncryptionKmsKeyId: input["ServerSideEncryptionKmsKeyId"],
    DataFormat: input["DataFormat"],
    EncodingType: input["EncodingType"],
    DictPageSizeLimit: input["DictPageSizeLimit"],
    RowGroupLength: input["RowGroupLength"],
    DataPageSize: input["DataPageSize"],
    ParquetVersion: input["ParquetVersion"],
    EnableStatistics: input["EnableStatistics"],
    IncludeOpForFullLoad: input["IncludeOpForFullLoad"],
    CdcInsertsOnly: input["CdcInsertsOnly"],
    TimestampColumnName: input["TimestampColumnName"],
    ParquetTimestampInMillisecond: input["ParquetTimestampInMillisecond"],
    CdcInsertsAndUpdates: input["CdcInsertsAndUpdates"],
    DatePartitionEnabled: input["DatePartitionEnabled"],
    DatePartitionSequence: input["DatePartitionSequence"],
    DatePartitionDelimiter: input["DatePartitionDelimiter"],
    UseCsvNoSupValue: input["UseCsvNoSupValue"],
    CsvNoSupValue: input["CsvNoSupValue"],
    PreserveTransactions: input["PreserveTransactions"],
    CdcPath: input["CdcPath"],
  }
}
function toS3Settings(root: jsonP.JSONValue): s.S3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceAccessRoleArn": "s",
      "ExternalTableDefinition": "s",
      "CsvRowDelimiter": "s",
      "CsvDelimiter": "s",
      "BucketFolder": "s",
      "BucketName": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionTypeValue>(x),
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionModeValue>(x),
      "ServerSideEncryptionKmsKeyId": "s",
      "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataFormatValue>(x),
      "EncodingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncodingTypeValue>(x),
      "DictPageSizeLimit": "n",
      "RowGroupLength": "n",
      "DataPageSize": "n",
      "ParquetVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParquetVersionValue>(x),
      "EnableStatistics": "b",
      "IncludeOpForFullLoad": "b",
      "CdcInsertsOnly": "b",
      "TimestampColumnName": "s",
      "ParquetTimestampInMillisecond": "b",
      "CdcInsertsAndUpdates": "b",
      "DatePartitionEnabled": "b",
      "DatePartitionSequence": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatePartitionSequenceValue>(x),
      "DatePartitionDelimiter": (x: jsonP.JSONValue) => cmnP.readEnum<s.DatePartitionDelimiterValue>(x),
      "UseCsvNoSupValue": "b",
      "CsvNoSupValue": "s",
      "PreserveTransactions": "b",
      "CdcPath": "s",
    },
  }, root);
}

function fromDmsTransferSettings(input?: s.DmsTransferSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    BucketName: input["BucketName"],
  }
}
function toDmsTransferSettings(root: jsonP.JSONValue): s.DmsTransferSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ServiceAccessRoleArn": "s",
      "BucketName": "s",
    },
  }, root);
}

function fromMongoDbSettings(input?: s.MongoDbSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
    ServerName: input["ServerName"],
    Port: input["Port"],
    DatabaseName: input["DatabaseName"],
    AuthType: input["AuthType"],
    AuthMechanism: input["AuthMechanism"],
    NestingLevel: input["NestingLevel"],
    ExtractDocId: input["ExtractDocId"],
    DocsToInvestigate: input["DocsToInvestigate"],
    AuthSource: input["AuthSource"],
    KmsKeyId: input["KmsKeyId"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toMongoDbSettings(root: jsonP.JSONValue): s.MongoDbSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Password": "s",
      "ServerName": "s",
      "Port": "n",
      "DatabaseName": "s",
      "AuthType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthTypeValue>(x),
      "AuthMechanism": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthMechanismValue>(x),
      "NestingLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.NestingLevelValue>(x),
      "ExtractDocId": "s",
      "DocsToInvestigate": "s",
      "AuthSource": "s",
      "KmsKeyId": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromKinesisSettings(input?: s.KinesisSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamArn: input["StreamArn"],
    MessageFormat: input["MessageFormat"],
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    IncludeTransactionDetails: input["IncludeTransactionDetails"],
    IncludePartitionValue: input["IncludePartitionValue"],
    PartitionIncludeSchemaTable: input["PartitionIncludeSchemaTable"],
    IncludeTableAlterOperations: input["IncludeTableAlterOperations"],
    IncludeControlDetails: input["IncludeControlDetails"],
    IncludeNullAndEmpty: input["IncludeNullAndEmpty"],
  }
}
function toKinesisSettings(root: jsonP.JSONValue): s.KinesisSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamArn": "s",
      "MessageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageFormatValue>(x),
      "ServiceAccessRoleArn": "s",
      "IncludeTransactionDetails": "b",
      "IncludePartitionValue": "b",
      "PartitionIncludeSchemaTable": "b",
      "IncludeTableAlterOperations": "b",
      "IncludeControlDetails": "b",
      "IncludeNullAndEmpty": "b",
    },
  }, root);
}

function fromKafkaSettings(input?: s.KafkaSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Broker: input["Broker"],
    Topic: input["Topic"],
    MessageFormat: input["MessageFormat"],
    IncludeTransactionDetails: input["IncludeTransactionDetails"],
    IncludePartitionValue: input["IncludePartitionValue"],
    PartitionIncludeSchemaTable: input["PartitionIncludeSchemaTable"],
    IncludeTableAlterOperations: input["IncludeTableAlterOperations"],
    IncludeControlDetails: input["IncludeControlDetails"],
    MessageMaxBytes: input["MessageMaxBytes"],
    IncludeNullAndEmpty: input["IncludeNullAndEmpty"],
  }
}
function toKafkaSettings(root: jsonP.JSONValue): s.KafkaSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Broker": "s",
      "Topic": "s",
      "MessageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageFormatValue>(x),
      "IncludeTransactionDetails": "b",
      "IncludePartitionValue": "b",
      "PartitionIncludeSchemaTable": "b",
      "IncludeTableAlterOperations": "b",
      "IncludeControlDetails": "b",
      "MessageMaxBytes": "n",
      "IncludeNullAndEmpty": "b",
    },
  }, root);
}

function fromElasticsearchSettings(input?: s.ElasticsearchSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    EndpointUri: input["EndpointUri"],
    FullLoadErrorPercentage: input["FullLoadErrorPercentage"],
    ErrorRetryDuration: input["ErrorRetryDuration"],
  }
}
function toElasticsearchSettings(root: jsonP.JSONValue): s.ElasticsearchSettings {
  return jsonP.readObj({
    required: {
      "ServiceAccessRoleArn": "s",
      "EndpointUri": "s",
    },
    optional: {
      "FullLoadErrorPercentage": "n",
      "ErrorRetryDuration": "n",
    },
  }, root);
}

function fromNeptuneSettings(input?: s.NeptuneSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    S3BucketName: input["S3BucketName"],
    S3BucketFolder: input["S3BucketFolder"],
    ErrorRetryDuration: input["ErrorRetryDuration"],
    MaxFileSize: input["MaxFileSize"],
    MaxRetryCount: input["MaxRetryCount"],
    IamAuthEnabled: input["IamAuthEnabled"],
  }
}
function toNeptuneSettings(root: jsonP.JSONValue): s.NeptuneSettings {
  return jsonP.readObj({
    required: {
      "S3BucketName": "s",
      "S3BucketFolder": "s",
    },
    optional: {
      "ServiceAccessRoleArn": "s",
      "ErrorRetryDuration": "n",
      "MaxFileSize": "n",
      "MaxRetryCount": "n",
      "IamAuthEnabled": "b",
    },
  }, root);
}

function fromRedshiftSettings(input?: s.RedshiftSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AcceptAnyDate: input["AcceptAnyDate"],
    AfterConnectScript: input["AfterConnectScript"],
    BucketFolder: input["BucketFolder"],
    BucketName: input["BucketName"],
    CaseSensitiveNames: input["CaseSensitiveNames"],
    CompUpdate: input["CompUpdate"],
    ConnectionTimeout: input["ConnectionTimeout"],
    DatabaseName: input["DatabaseName"],
    DateFormat: input["DateFormat"],
    EmptyAsNull: input["EmptyAsNull"],
    EncryptionMode: input["EncryptionMode"],
    ExplicitIds: input["ExplicitIds"],
    FileTransferUploadStreams: input["FileTransferUploadStreams"],
    LoadTimeout: input["LoadTimeout"],
    MaxFileSize: input["MaxFileSize"],
    Password: input["Password"],
    Port: input["Port"],
    RemoveQuotes: input["RemoveQuotes"],
    ReplaceInvalidChars: input["ReplaceInvalidChars"],
    ReplaceChars: input["ReplaceChars"],
    ServerName: input["ServerName"],
    ServiceAccessRoleArn: input["ServiceAccessRoleArn"],
    ServerSideEncryptionKmsKeyId: input["ServerSideEncryptionKmsKeyId"],
    TimeFormat: input["TimeFormat"],
    TrimBlanks: input["TrimBlanks"],
    TruncateColumns: input["TruncateColumns"],
    Username: input["Username"],
    WriteBufferSize: input["WriteBufferSize"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toRedshiftSettings(root: jsonP.JSONValue): s.RedshiftSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AcceptAnyDate": "b",
      "AfterConnectScript": "s",
      "BucketFolder": "s",
      "BucketName": "s",
      "CaseSensitiveNames": "b",
      "CompUpdate": "b",
      "ConnectionTimeout": "n",
      "DatabaseName": "s",
      "DateFormat": "s",
      "EmptyAsNull": "b",
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionModeValue>(x),
      "ExplicitIds": "b",
      "FileTransferUploadStreams": "n",
      "LoadTimeout": "n",
      "MaxFileSize": "n",
      "Password": "s",
      "Port": "n",
      "RemoveQuotes": "b",
      "ReplaceInvalidChars": "s",
      "ReplaceChars": "s",
      "ServerName": "s",
      "ServiceAccessRoleArn": "s",
      "ServerSideEncryptionKmsKeyId": "s",
      "TimeFormat": "s",
      "TrimBlanks": "b",
      "TruncateColumns": "b",
      "Username": "s",
      "WriteBufferSize": "n",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromPostgreSQLSettings(input?: s.PostgreSQLSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AfterConnectScript: input["AfterConnectScript"],
    CaptureDdls: input["CaptureDdls"],
    MaxFileSize: input["MaxFileSize"],
    DatabaseName: input["DatabaseName"],
    DdlArtifactsSchema: input["DdlArtifactsSchema"],
    ExecuteTimeout: input["ExecuteTimeout"],
    FailTasksOnLobTruncation: input["FailTasksOnLobTruncation"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    SlotName: input["SlotName"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toPostgreSQLSettings(root: jsonP.JSONValue): s.PostgreSQLSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfterConnectScript": "s",
      "CaptureDdls": "b",
      "MaxFileSize": "n",
      "DatabaseName": "s",
      "DdlArtifactsSchema": "s",
      "ExecuteTimeout": "n",
      "FailTasksOnLobTruncation": "b",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "Username": "s",
      "SlotName": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromMySQLSettings(input?: s.MySQLSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AfterConnectScript: input["AfterConnectScript"],
    DatabaseName: input["DatabaseName"],
    EventsPollInterval: input["EventsPollInterval"],
    TargetDbType: input["TargetDbType"],
    MaxFileSize: input["MaxFileSize"],
    ParallelLoadThreads: input["ParallelLoadThreads"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    ServerTimezone: input["ServerTimezone"],
    Username: input["Username"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toMySQLSettings(root: jsonP.JSONValue): s.MySQLSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AfterConnectScript": "s",
      "DatabaseName": "s",
      "EventsPollInterval": "n",
      "TargetDbType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetDbType>(x),
      "MaxFileSize": "n",
      "ParallelLoadThreads": "n",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "ServerTimezone": "s",
      "Username": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromOracleSettings(input?: s.OracleSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AddSupplementalLogging: input["AddSupplementalLogging"],
    ArchivedLogDestId: input["ArchivedLogDestId"],
    AdditionalArchivedLogDestId: input["AdditionalArchivedLogDestId"],
    AllowSelectNestedTables: input["AllowSelectNestedTables"],
    ParallelAsmReadThreads: input["ParallelAsmReadThreads"],
    ReadAheadBlocks: input["ReadAheadBlocks"],
    AccessAlternateDirectly: input["AccessAlternateDirectly"],
    UseAlternateFolderForOnline: input["UseAlternateFolderForOnline"],
    OraclePathPrefix: input["OraclePathPrefix"],
    UsePathPrefix: input["UsePathPrefix"],
    ReplacePathPrefix: input["ReplacePathPrefix"],
    EnableHomogenousTablespace: input["EnableHomogenousTablespace"],
    DirectPathNoLog: input["DirectPathNoLog"],
    ArchivedLogsOnly: input["ArchivedLogsOnly"],
    AsmPassword: input["AsmPassword"],
    AsmServer: input["AsmServer"],
    AsmUser: input["AsmUser"],
    CharLengthSemantics: input["CharLengthSemantics"],
    DatabaseName: input["DatabaseName"],
    DirectPathParallelLoad: input["DirectPathParallelLoad"],
    FailTasksOnLobTruncation: input["FailTasksOnLobTruncation"],
    NumberDatatypeScale: input["NumberDatatypeScale"],
    Password: input["Password"],
    Port: input["Port"],
    ReadTableSpaceName: input["ReadTableSpaceName"],
    RetryInterval: input["RetryInterval"],
    SecurityDbEncryption: input["SecurityDbEncryption"],
    SecurityDbEncryptionName: input["SecurityDbEncryptionName"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
    SecretsManagerOracleAsmAccessRoleArn: input["SecretsManagerOracleAsmAccessRoleArn"],
    SecretsManagerOracleAsmSecretId: input["SecretsManagerOracleAsmSecretId"],
  }
}
function toOracleSettings(root: jsonP.JSONValue): s.OracleSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AddSupplementalLogging": "b",
      "ArchivedLogDestId": "n",
      "AdditionalArchivedLogDestId": "n",
      "AllowSelectNestedTables": "b",
      "ParallelAsmReadThreads": "n",
      "ReadAheadBlocks": "n",
      "AccessAlternateDirectly": "b",
      "UseAlternateFolderForOnline": "b",
      "OraclePathPrefix": "s",
      "UsePathPrefix": "s",
      "ReplacePathPrefix": "b",
      "EnableHomogenousTablespace": "b",
      "DirectPathNoLog": "b",
      "ArchivedLogsOnly": "b",
      "AsmPassword": "s",
      "AsmServer": "s",
      "AsmUser": "s",
      "CharLengthSemantics": (x: jsonP.JSONValue) => cmnP.readEnum<s.CharLengthSemantics>(x),
      "DatabaseName": "s",
      "DirectPathParallelLoad": "b",
      "FailTasksOnLobTruncation": "b",
      "NumberDatatypeScale": "n",
      "Password": "s",
      "Port": "n",
      "ReadTableSpaceName": "b",
      "RetryInterval": "n",
      "SecurityDbEncryption": "s",
      "SecurityDbEncryptionName": "s",
      "ServerName": "s",
      "Username": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
      "SecretsManagerOracleAsmAccessRoleArn": "s",
      "SecretsManagerOracleAsmSecretId": "s",
    },
  }, root);
}

function fromSybaseSettings(input?: s.SybaseSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toSybaseSettings(root: jsonP.JSONValue): s.SybaseSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatabaseName": "s",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "Username": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromMicrosoftSQLServerSettings(input?: s.MicrosoftSQLServerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Port: input["Port"],
    BcpPacketSize: input["BcpPacketSize"],
    DatabaseName: input["DatabaseName"],
    ControlTablesFileGroup: input["ControlTablesFileGroup"],
    Password: input["Password"],
    ReadBackupOnly: input["ReadBackupOnly"],
    SafeguardPolicy: input["SafeguardPolicy"],
    ServerName: input["ServerName"],
    Username: input["Username"],
    UseBcpFullLoad: input["UseBcpFullLoad"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toMicrosoftSQLServerSettings(root: jsonP.JSONValue): s.MicrosoftSQLServerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Port": "n",
      "BcpPacketSize": "n",
      "DatabaseName": "s",
      "ControlTablesFileGroup": "s",
      "Password": "s",
      "ReadBackupOnly": "b",
      "SafeguardPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SafeguardPolicy>(x),
      "ServerName": "s",
      "Username": "s",
      "UseBcpFullLoad": "b",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromIBMDb2Settings(input?: s.IBMDb2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Password: input["Password"],
    Port: input["Port"],
    ServerName: input["ServerName"],
    SetDataCaptureChanges: input["SetDataCaptureChanges"],
    CurrentLsn: input["CurrentLsn"],
    MaxKBytesPerRead: input["MaxKBytesPerRead"],
    Username: input["Username"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toIBMDb2Settings(root: jsonP.JSONValue): s.IBMDb2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DatabaseName": "s",
      "Password": "s",
      "Port": "n",
      "ServerName": "s",
      "SetDataCaptureChanges": "b",
      "CurrentLsn": "s",
      "MaxKBytesPerRead": "n",
      "Username": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromDocDbSettings(input?: s.DocDbSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Username: input["Username"],
    Password: input["Password"],
    ServerName: input["ServerName"],
    Port: input["Port"],
    DatabaseName: input["DatabaseName"],
    NestingLevel: input["NestingLevel"],
    ExtractDocId: input["ExtractDocId"],
    DocsToInvestigate: input["DocsToInvestigate"],
    KmsKeyId: input["KmsKeyId"],
    SecretsManagerAccessRoleArn: input["SecretsManagerAccessRoleArn"],
    SecretsManagerSecretId: input["SecretsManagerSecretId"],
  }
}
function toDocDbSettings(root: jsonP.JSONValue): s.DocDbSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Username": "s",
      "Password": "s",
      "ServerName": "s",
      "Port": "n",
      "DatabaseName": "s",
      "NestingLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.NestingLevelValue>(x),
      "ExtractDocId": "b",
      "DocsToInvestigate": "n",
      "KmsKeyId": "s",
      "SecretsManagerAccessRoleArn": "s",
      "SecretsManagerSecretId": "s",
    },
  }, root);
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

function fromTableToReload(input?: s.TableToReload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaName: input["SchemaName"],
    TableName: input["TableName"],
  }
}

function toResourcePendingMaintenanceActions(root: jsonP.JSONValue): s.ResourcePendingMaintenanceActions {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceIdentifier": "s",
      "PendingMaintenanceActionDetails": [toPendingMaintenanceAction],
    },
  }, root);
}

function toPendingMaintenanceAction(root: jsonP.JSONValue): s.PendingMaintenanceAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": "s",
      "AutoAppliedAfterDate": "d",
      "ForcedApplyDate": "d",
      "OptInStatus": "s",
      "CurrentApplyDate": "d",
      "Description": "s",
    },
  }, root);
}

function toReplicationTaskAssessmentRun(root: jsonP.JSONValue): s.ReplicationTaskAssessmentRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskAssessmentRunArn": "s",
      "ReplicationTaskArn": "s",
      "Status": "s",
      "ReplicationTaskAssessmentRunCreationDate": "d",
      "AssessmentProgress": toReplicationTaskAssessmentRunProgress,
      "LastFailureMessage": "s",
      "ServiceAccessRoleArn": "s",
      "ResultLocationBucket": "s",
      "ResultLocationFolder": "s",
      "ResultEncryptionMode": "s",
      "ResultKmsKeyArn": "s",
      "AssessmentRunName": "s",
    },
  }, root);
}

function toReplicationTaskAssessmentRunProgress(root: jsonP.JSONValue): s.ReplicationTaskAssessmentRunProgress {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndividualAssessmentCount": "n",
      "IndividualAssessmentCompletedCount": "n",
    },
  }, root);
}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointIdentifier": "s",
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicationEndpointTypeValue>(x),
      "EngineName": "s",
      "EngineDisplayName": "s",
      "Username": "s",
      "ServerName": "s",
      "Port": "n",
      "DatabaseName": "s",
      "ExtraConnectionAttributes": "s",
      "Status": "s",
      "KmsKeyId": "s",
      "EndpointArn": "s",
      "CertificateArn": "s",
      "SslMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.DmsSslModeValue>(x),
      "ServiceAccessRoleArn": "s",
      "ExternalTableDefinition": "s",
      "ExternalId": "s",
      "DynamoDbSettings": toDynamoDbSettings,
      "S3Settings": toS3Settings,
      "DmsTransferSettings": toDmsTransferSettings,
      "MongoDbSettings": toMongoDbSettings,
      "KinesisSettings": toKinesisSettings,
      "KafkaSettings": toKafkaSettings,
      "ElasticsearchSettings": toElasticsearchSettings,
      "NeptuneSettings": toNeptuneSettings,
      "RedshiftSettings": toRedshiftSettings,
      "PostgreSQLSettings": toPostgreSQLSettings,
      "MySQLSettings": toMySQLSettings,
      "OracleSettings": toOracleSettings,
      "SybaseSettings": toSybaseSettings,
      "MicrosoftSQLServerSettings": toMicrosoftSQLServerSettings,
      "IBMDb2Settings": toIBMDb2Settings,
      "DocDbSettings": toDocDbSettings,
    },
  }, root);
}

function toEventSubscription(root: jsonP.JSONValue): s.EventSubscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomerAwsId": "s",
      "CustSubscriptionId": "s",
      "SnsTopicArn": "s",
      "Status": "s",
      "SubscriptionCreationTime": "s",
      "SourceType": "s",
      "SourceIdsList": ["s"],
      "EventCategoriesList": ["s"],
      "Enabled": "b",
    },
  }, root);
}

function toReplicationInstance(root: jsonP.JSONValue): s.ReplicationInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceIdentifier": "s",
      "ReplicationInstanceClass": "s",
      "ReplicationInstanceStatus": "s",
      "AllocatedStorage": "n",
      "InstanceCreateTime": "d",
      "VpcSecurityGroups": [toVpcSecurityGroupMembership],
      "AvailabilityZone": "s",
      "ReplicationSubnetGroup": toReplicationSubnetGroup,
      "PreferredMaintenanceWindow": "s",
      "PendingModifiedValues": toReplicationPendingModifiedValues,
      "MultiAZ": "b",
      "EngineVersion": "s",
      "AutoMinorVersionUpgrade": "b",
      "KmsKeyId": "s",
      "ReplicationInstanceArn": "s",
      "ReplicationInstancePublicIpAddress": "s",
      "ReplicationInstancePrivateIpAddress": "s",
      "ReplicationInstancePublicIpAddresses": ["s"],
      "ReplicationInstancePrivateIpAddresses": ["s"],
      "PubliclyAccessible": "b",
      "SecondaryAvailabilityZone": "s",
      "FreeUntil": "d",
      "DnsNameServers": "s",
    },
  }, root);
}

function toVpcSecurityGroupMembership(root: jsonP.JSONValue): s.VpcSecurityGroupMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcSecurityGroupId": "s",
      "Status": "s",
    },
  }, root);
}

function toReplicationSubnetGroup(root: jsonP.JSONValue): s.ReplicationSubnetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationSubnetGroupIdentifier": "s",
      "ReplicationSubnetGroupDescription": "s",
      "VpcId": "s",
      "SubnetGroupStatus": "s",
      "Subnets": [toSubnet],
    },
  }, root);
}

function toSubnet(root: jsonP.JSONValue): s.Subnet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIdentifier": "s",
      "SubnetAvailabilityZone": toAvailabilityZone,
      "SubnetStatus": "s",
    },
  }, root);
}

function toAvailabilityZone(root: jsonP.JSONValue): s.AvailabilityZone {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function toReplicationPendingModifiedValues(root: jsonP.JSONValue): s.ReplicationPendingModifiedValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceClass": "s",
      "AllocatedStorage": "n",
      "MultiAZ": "b",
      "EngineVersion": "s",
    },
  }, root);
}

function toReplicationTask(root: jsonP.JSONValue): s.ReplicationTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIdentifier": "s",
      "SourceEndpointArn": "s",
      "TargetEndpointArn": "s",
      "ReplicationInstanceArn": "s",
      "MigrationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MigrationTypeValue>(x),
      "TableMappings": "s",
      "ReplicationTaskSettings": "s",
      "Status": "s",
      "LastFailureMessage": "s",
      "StopReason": "s",
      "ReplicationTaskCreationDate": "d",
      "ReplicationTaskStartDate": "d",
      "CdcStartPosition": "s",
      "CdcStopPosition": "s",
      "RecoveryCheckpoint": "s",
      "ReplicationTaskArn": "s",
      "ReplicationTaskStats": toReplicationTaskStats,
      "TaskData": "s",
      "TargetReplicationInstanceArn": "s",
    },
  }, root);
}

function toReplicationTaskStats(root: jsonP.JSONValue): s.ReplicationTaskStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "FullLoadProgressPercent": "n",
      "ElapsedTimeMillis": "n",
      "TablesLoaded": "n",
      "TablesLoading": "n",
      "TablesQueued": "n",
      "TablesErrored": "n",
      "FreshStartDate": "d",
      "StartDate": "d",
      "StopDate": "d",
      "FullLoadStartDate": "d",
      "FullLoadFinishDate": "d",
    },
  }, root);
}

function toCertificate(root: jsonP.JSONValue): s.Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateIdentifier": "s",
      "CertificateCreationDate": "d",
      "CertificatePem": "s",
      "CertificateWallet": "a",
      "CertificateArn": "s",
      "CertificateOwner": "s",
      "ValidFromDate": "d",
      "ValidToDate": "d",
      "SigningAlgorithm": "s",
      "KeyLength": "n",
    },
  }, root);
}

function toConnection(root: jsonP.JSONValue): s.Connection {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationInstanceArn": "s",
      "EndpointArn": "s",
      "Status": "s",
      "LastFailureMessage": "s",
      "EndpointIdentifier": "s",
      "ReplicationInstanceIdentifier": "s",
    },
  }, root);
}

function toAccountQuota(root: jsonP.JSONValue): s.AccountQuota {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountQuotaName": "s",
      "Used": "n",
      "Max": "n",
    },
  }, root);
}

function toSupportedEndpointType(root: jsonP.JSONValue): s.SupportedEndpointType {
  return jsonP.readObj({
    required: {},
    optional: {
      "EngineName": "s",
      "SupportsCDC": "b",
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicationEndpointTypeValue>(x),
      "ReplicationInstanceEngineMinimumVersion": "s",
      "EngineDisplayName": "s",
    },
  }, root);
}

function toEventCategoryGroup(root: jsonP.JSONValue): s.EventCategoryGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceType": "s",
      "EventCategories": ["s"],
    },
  }, root);
}

function toEvent(root: jsonP.JSONValue): s.Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceIdentifier": "s",
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
      "Message": "s",
      "EventCategories": ["s"],
      "Date": "d",
    },
  }, root);
}

function toOrderableReplicationInstance(root: jsonP.JSONValue): s.OrderableReplicationInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "EngineVersion": "s",
      "ReplicationInstanceClass": "s",
      "StorageType": "s",
      "MinAllocatedStorage": "n",
      "MaxAllocatedStorage": "n",
      "DefaultAllocatedStorage": "n",
      "IncludedAllocatedStorage": "n",
      "AvailabilityZones": ["s"],
      "ReleaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReleaseStatusValues>(x),
    },
  }, root);
}

function toRefreshSchemasStatus(root: jsonP.JSONValue): s.RefreshSchemasStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointArn": "s",
      "ReplicationInstanceArn": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RefreshSchemasStatusTypeValue>(x),
      "LastRefreshDate": "d",
      "LastFailureMessage": "s",
    },
  }, root);
}

function toReplicationInstanceTaskLog(root: jsonP.JSONValue): s.ReplicationInstanceTaskLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskName": "s",
      "ReplicationTaskArn": "s",
      "ReplicationInstanceTaskLogSize": "n",
    },
  }, root);
}

function toReplicationTaskAssessmentResult(root: jsonP.JSONValue): s.ReplicationTaskAssessmentResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIdentifier": "s",
      "ReplicationTaskArn": "s",
      "ReplicationTaskLastAssessmentDate": "d",
      "AssessmentStatus": "s",
      "AssessmentResultsFile": "s",
      "AssessmentResults": "s",
      "S3ObjectUrl": "s",
    },
  }, root);
}

function toReplicationTaskIndividualAssessment(root: jsonP.JSONValue): s.ReplicationTaskIndividualAssessment {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReplicationTaskIndividualAssessmentArn": "s",
      "ReplicationTaskAssessmentRunArn": "s",
      "IndividualAssessmentName": "s",
      "Status": "s",
      "ReplicationTaskIndividualAssessmentStartDate": "d",
    },
  }, root);
}

function toTableStatistics(root: jsonP.JSONValue): s.TableStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaName": "s",
      "TableName": "s",
      "Inserts": "n",
      "Deletes": "n",
      "Updates": "n",
      "Ddls": "n",
      "FullLoadRows": "n",
      "FullLoadCondtnlChkFailedRows": "n",
      "FullLoadErrorRows": "n",
      "FullLoadStartTime": "d",
      "FullLoadEndTime": "d",
      "FullLoadReloaded": "b",
      "LastUpdateTime": "d",
      "TableState": "s",
      "ValidationPendingRecords": "n",
      "ValidationFailedRecords": "n",
      "ValidationSuspendedRecords": "n",
      "ValidationState": "s",
      "ValidationStateDetails": "s",
    },
  }, root);
}
