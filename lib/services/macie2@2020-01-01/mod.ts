// Autogenerated API client for: Amazon Macie 2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Macie2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Macie2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-01-01",
    "endpointPrefix": "macie2",
    "signingName": "macie2",
    "serviceFullName": "Amazon Macie 2",
    "serviceId": "Macie2",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "macie2-2020-01-01",
    "signatureVersion": "v4"
  };

  async acceptInvitation(
    {abortSignal, ...params}: RequestConfig & s.AcceptInvitationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      administratorAccountId: params["administratorAccountId"],
      invitationId: params["invitationId"],
      masterAccount: params["masterAccount"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptInvitation",
      requestUri: "/invitations/accept",
      responseCode: 200,
    });
    await resp.text();
  }

  async batchGetCustomDataIdentifiers(
    {abortSignal, ...params}: RequestConfig & s.BatchGetCustomDataIdentifiersRequest = {},
  ): Promise<s.BatchGetCustomDataIdentifiersResponse> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetCustomDataIdentifiers",
      requestUri: "/custom-data-identifiers/get",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "customDataIdentifiers": [toBatchGetCustomDataIdentifierSummary],
        "notFoundIdentifierIds": ["s"],
      },
    }, await resp.json());
  }

  async createClassificationJob(
    {abortSignal, ...params}: RequestConfig & s.CreateClassificationJobRequest,
  ): Promise<s.CreateClassificationJobResponse> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      customDataIdentifierIds: params["customDataIdentifierIds"],
      description: params["description"],
      initialRun: params["initialRun"],
      jobType: params["jobType"],
      name: params["name"],
      s3JobDefinition: fromS3JobDefinition(params["s3JobDefinition"]),
      samplingPercentage: params["samplingPercentage"],
      scheduleFrequency: fromJobScheduleFrequency(params["scheduleFrequency"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClassificationJob",
      requestUri: "/jobs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobArn": "s",
        "jobId": "s",
      },
    }, await resp.json());
  }

  async createCustomDataIdentifier(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomDataIdentifierRequest = {},
  ): Promise<s.CreateCustomDataIdentifierResponse> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      description: params["description"],
      ignoreWords: params["ignoreWords"],
      keywords: params["keywords"],
      maximumMatchDistance: params["maximumMatchDistance"],
      name: params["name"],
      regex: params["regex"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomDataIdentifier",
      requestUri: "/custom-data-identifiers",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "customDataIdentifierId": "s",
      },
    }, await resp.json());
  }

  async createFindingsFilter(
    {abortSignal, ...params}: RequestConfig & s.CreateFindingsFilterRequest,
  ): Promise<s.CreateFindingsFilterResponse> {
    const body: jsonP.JSONObject = {
      action: params["action"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      description: params["description"],
      findingCriteria: fromFindingCriteria(params["findingCriteria"]),
      name: params["name"],
      position: params["position"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFindingsFilter",
      requestUri: "/findingsfilters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "id": "s",
      },
    }, await resp.json());
  }

  async createInvitations(
    {abortSignal, ...params}: RequestConfig & s.CreateInvitationsRequest,
  ): Promise<s.CreateInvitationsResponse> {
    const body: jsonP.JSONObject = {
      accountIds: params["accountIds"],
      disableEmailNotification: params["disableEmailNotification"],
      message: params["message"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInvitations",
      requestUri: "/invitations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "unprocessedAccounts": [toUnprocessedAccount],
      },
    }, await resp.json());
  }

  async createMember(
    {abortSignal, ...params}: RequestConfig & s.CreateMemberRequest,
  ): Promise<s.CreateMemberResponse> {
    const body: jsonP.JSONObject = {
      account: fromAccountDetail(params["account"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMember",
      requestUri: "/members",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async createSampleFindings(
    {abortSignal, ...params}: RequestConfig & s.CreateSampleFindingsRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      findingTypes: params["findingTypes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSampleFindings",
      requestUri: "/findings/sample",
      responseCode: 200,
    });
    await resp.text();
  }

  async declineInvitations(
    {abortSignal, ...params}: RequestConfig & s.DeclineInvitationsRequest,
  ): Promise<s.DeclineInvitationsResponse> {
    const body: jsonP.JSONObject = {
      accountIds: params["accountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeclineInvitations",
      requestUri: "/invitations/decline",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "unprocessedAccounts": [toUnprocessedAccount],
      },
    }, await resp.json());
  }

  async deleteCustomDataIdentifier(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomDataIdentifierRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCustomDataIdentifier",
      method: "DELETE",
      requestUri: cmnP.encodePath`/custom-data-identifiers/${params["id"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async deleteFindingsFilter(
    {abortSignal, ...params}: RequestConfig & s.DeleteFindingsFilterRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFindingsFilter",
      method: "DELETE",
      requestUri: cmnP.encodePath`/findingsfilters/${params["id"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async deleteInvitations(
    {abortSignal, ...params}: RequestConfig & s.DeleteInvitationsRequest,
  ): Promise<s.DeleteInvitationsResponse> {
    const body: jsonP.JSONObject = {
      accountIds: params["accountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInvitations",
      requestUri: "/invitations/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "unprocessedAccounts": [toUnprocessedAccount],
      },
    }, await resp.json());
  }

  async deleteMember(
    {abortSignal, ...params}: RequestConfig & s.DeleteMemberRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMember",
      method: "DELETE",
      requestUri: cmnP.encodePath`/members/${params["id"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async describeBuckets(
    {abortSignal, ...params}: RequestConfig & s.DescribeBucketsRequest = {},
  ): Promise<s.DescribeBucketsResponse> {
    const body: jsonP.JSONObject = {
      criteria: jsonP.serializeMap(params["criteria"], x => fromBucketCriteriaAdditionalProperties(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sortCriteria: fromBucketSortCriteria(params["sortCriteria"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBuckets",
      requestUri: "/datasources/s3",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buckets": [toBucketMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeClassificationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeClassificationJobRequest,
  ): Promise<s.DescribeClassificationJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeClassificationJob",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "clientToken": "s",
        "createdAt": "d",
        "customDataIdentifierIds": ["s"],
        "description": "s",
        "initialRun": "b",
        "jobArn": "s",
        "jobId": "s",
        "jobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
        "jobType": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobType>(x),
        "lastRunErrorStatus": toLastRunErrorStatus,
        "lastRunTime": "d",
        "name": "s",
        "s3JobDefinition": toS3JobDefinition,
        "samplingPercentage": "n",
        "scheduleFrequency": toJobScheduleFrequency,
        "statistics": toStatistics,
        "tags": x => jsonP.readMap(String, String, x),
        "userPausedDetails": toUserPausedDetails,
      },
    }, await resp.json());
  }

  async describeOrganizationConfiguration(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeOrganizationConfigurationResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrganizationConfiguration",
      method: "GET",
      requestUri: "/admin/configuration",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "autoEnable": "b",
        "maxAccountLimitReached": "b",
      },
    }, await resp.json());
  }

  async disableMacie(
    {abortSignal}: RequestConfig = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableMacie",
      method: "DELETE",
      requestUri: "/macie",
      responseCode: 200,
    });
    await resp.text();
  }

  async disableOrganizationAdminAccount(
    {abortSignal, ...params}: RequestConfig & s.DisableOrganizationAdminAccountRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("adminAccountId", params["adminAccountId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DisableOrganizationAdminAccount",
      method: "DELETE",
      requestUri: "/admin",
      responseCode: 200,
    });
    await resp.text();
  }

  async disassociateFromAdministratorAccount(
    {abortSignal}: RequestConfig = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateFromAdministratorAccount",
      requestUri: "/administrator/disassociate",
      responseCode: 200,
    });
    await resp.text();
  }

  async disassociateFromMasterAccount(
    {abortSignal}: RequestConfig = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateFromMasterAccount",
      requestUri: "/master/disassociate",
      responseCode: 200,
    });
    await resp.text();
  }

  async disassociateMember(
    {abortSignal, ...params}: RequestConfig & s.DisassociateMemberRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisassociateMember",
      requestUri: cmnP.encodePath`/members/disassociate/${params["id"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async enableMacie(
    {abortSignal, ...params}: RequestConfig & s.EnableMacieRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      findingPublishingFrequency: params["findingPublishingFrequency"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableMacie",
      requestUri: "/macie",
      responseCode: 200,
    });
    await resp.text();
  }

  async enableOrganizationAdminAccount(
    {abortSignal, ...params}: RequestConfig & s.EnableOrganizationAdminAccountRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      adminAccountId: params["adminAccountId"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableOrganizationAdminAccount",
      requestUri: "/admin",
      responseCode: 200,
    });
    await resp.text();
  }

  async getAdministratorAccount(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetAdministratorAccountResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAdministratorAccount",
      method: "GET",
      requestUri: "/administrator",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "administrator": toInvitation,
      },
    }, await resp.json());
  }

  async getBucketStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetBucketStatisticsRequest = {},
  ): Promise<s.GetBucketStatisticsResponse> {
    const body: jsonP.JSONObject = {
      accountId: params["accountId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBucketStatistics",
      requestUri: "/datasources/s3/statistics",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bucketCount": "n",
        "bucketCountByEffectivePermission": toBucketCountByEffectivePermission,
        "bucketCountByEncryptionType": toBucketCountByEncryptionType,
        "bucketCountBySharedAccessType": toBucketCountBySharedAccessType,
        "classifiableObjectCount": "n",
        "classifiableSizeInBytes": "n",
        "lastUpdated": "d",
        "objectCount": "n",
        "sizeInBytes": "n",
        "sizeInBytesCompressed": "n",
        "unclassifiableObjectCount": toObjectLevelStatistics,
        "unclassifiableObjectSizeInBytes": toObjectLevelStatistics,
      },
    }, await resp.json());
  }

  async getClassificationExportConfiguration(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetClassificationExportConfigurationResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClassificationExportConfiguration",
      method: "GET",
      requestUri: "/classification-export-configuration",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configuration": toClassificationExportConfiguration,
      },
    }, await resp.json());
  }

  async getCustomDataIdentifier(
    {abortSignal, ...params}: RequestConfig & s.GetCustomDataIdentifierRequest,
  ): Promise<s.GetCustomDataIdentifierResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCustomDataIdentifier",
      method: "GET",
      requestUri: cmnP.encodePath`/custom-data-identifiers/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "createdAt": "d",
        "deleted": "b",
        "description": "s",
        "id": "s",
        "ignoreWords": ["s"],
        "keywords": ["s"],
        "maximumMatchDistance": "n",
        "name": "s",
        "regex": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getFindingStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetFindingStatisticsRequest,
  ): Promise<s.GetFindingStatisticsResponse> {
    const body: jsonP.JSONObject = {
      findingCriteria: fromFindingCriteria(params["findingCriteria"]),
      groupBy: params["groupBy"],
      size: params["size"],
      sortCriteria: fromFindingStatisticsSortCriteria(params["sortCriteria"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFindingStatistics",
      requestUri: "/findings/statistics",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "countsByGroup": [toGroupCount],
      },
    }, await resp.json());
  }

  async getFindings(
    {abortSignal, ...params}: RequestConfig & s.GetFindingsRequest,
  ): Promise<s.GetFindingsResponse> {
    const body: jsonP.JSONObject = {
      findingIds: params["findingIds"],
      sortCriteria: fromSortCriteria(params["sortCriteria"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFindings",
      requestUri: "/findings/describe",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "findings": [toFinding],
      },
    }, await resp.json());
  }

  async getFindingsFilter(
    {abortSignal, ...params}: RequestConfig & s.GetFindingsFilterRequest,
  ): Promise<s.GetFindingsFilterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFindingsFilter",
      method: "GET",
      requestUri: cmnP.encodePath`/findingsfilters/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingsFilterAction>(x),
        "arn": "s",
        "description": "s",
        "findingCriteria": toFindingCriteria,
        "id": "s",
        "name": "s",
        "position": "n",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getFindingsPublicationConfiguration(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetFindingsPublicationConfigurationResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFindingsPublicationConfiguration",
      method: "GET",
      requestUri: "/findings-publication-configuration",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "securityHubConfiguration": toSecurityHubConfiguration,
      },
    }, await resp.json());
  }

  async getInvitationsCount(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetInvitationsCountResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInvitationsCount",
      method: "GET",
      requestUri: "/invitations/count",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "invitationsCount": "n",
      },
    }, await resp.json());
  }

  async getMacieSession(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetMacieSessionResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMacieSession",
      method: "GET",
      requestUri: "/macie",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "createdAt": "d",
        "findingPublishingFrequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingPublishingFrequency>(x),
        "serviceRole": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MacieStatus>(x),
        "updatedAt": "d",
      },
    }, await resp.json());
  }

  async getMasterAccount(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetMasterAccountResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMasterAccount",
      method: "GET",
      requestUri: "/master",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "master": toInvitation,
      },
    }, await resp.json());
  }

  async getMember(
    {abortSignal, ...params}: RequestConfig & s.GetMemberRequest,
  ): Promise<s.GetMemberResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMember",
      method: "GET",
      requestUri: cmnP.encodePath`/members/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "accountId": "s",
        "administratorAccountId": "s",
        "arn": "s",
        "email": "s",
        "invitedAt": "d",
        "masterAccountId": "s",
        "relationshipStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationshipStatus>(x),
        "tags": x => jsonP.readMap(String, String, x),
        "updatedAt": "d",
      },
    }, await resp.json());
  }

  async getUsageStatistics(
    {abortSignal, ...params}: RequestConfig & s.GetUsageStatisticsRequest = {},
  ): Promise<s.GetUsageStatisticsResponse> {
    const body: jsonP.JSONObject = {
      filterBy: params["filterBy"]?.map(x => fromUsageStatisticsFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sortBy: fromUsageStatisticsSortBy(params["sortBy"]),
      timeRange: params["timeRange"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUsageStatistics",
      requestUri: "/usage/statistics",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "records": [toUsageRecord],
        "timeRange": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeRange>(x),
      },
    }, await resp.json());
  }

  async getUsageTotals(
    {abortSignal, ...params}: RequestConfig & s.GetUsageTotalsRequest = {},
  ): Promise<s.GetUsageTotalsResponse> {
    const query = new URLSearchParams;
    if (params["timeRange"] != null) query.set("timeRange", params["timeRange"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUsageTotals",
      method: "GET",
      requestUri: "/usage",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "timeRange": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeRange>(x),
        "usageTotals": [toUsageTotal],
      },
    }, await resp.json());
  }

  async listClassificationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListClassificationJobsRequest = {},
  ): Promise<s.ListClassificationJobsResponse> {
    const body: jsonP.JSONObject = {
      filterCriteria: fromListJobsFilterCriteria(params["filterCriteria"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sortCriteria: fromListJobsSortCriteria(params["sortCriteria"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClassificationJobs",
      requestUri: "/jobs/list",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "items": [toJobSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCustomDataIdentifiers(
    {abortSignal, ...params}: RequestConfig & s.ListCustomDataIdentifiersRequest = {},
  ): Promise<s.ListCustomDataIdentifiersResponse> {
    const body: jsonP.JSONObject = {
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCustomDataIdentifiers",
      requestUri: "/custom-data-identifiers/list",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "items": [toCustomDataIdentifierSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFindings(
    {abortSignal, ...params}: RequestConfig & s.ListFindingsRequest = {},
  ): Promise<s.ListFindingsResponse> {
    const body: jsonP.JSONObject = {
      findingCriteria: fromFindingCriteria(params["findingCriteria"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      sortCriteria: fromSortCriteria(params["sortCriteria"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFindings",
      requestUri: "/findings",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "findingIds": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listFindingsFilters(
    {abortSignal, ...params}: RequestConfig & s.ListFindingsFiltersRequest = {},
  ): Promise<s.ListFindingsFiltersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFindingsFilters",
      method: "GET",
      requestUri: "/findingsfilters",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "findingsFilterListItems": [toFindingsFilterListItem],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listInvitations(
    {abortSignal, ...params}: RequestConfig & s.ListInvitationsRequest = {},
  ): Promise<s.ListInvitationsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvitations",
      method: "GET",
      requestUri: "/invitations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "invitations": [toInvitation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listMembers(
    {abortSignal, ...params}: RequestConfig & s.ListMembersRequest = {},
  ): Promise<s.ListMembersResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["onlyAssociated"] != null) query.set("onlyAssociated", params["onlyAssociated"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMembers",
      method: "GET",
      requestUri: "/members",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "members": [toMember],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listOrganizationAdminAccounts(
    {abortSignal, ...params}: RequestConfig & s.ListOrganizationAdminAccountsRequest = {},
  ): Promise<s.ListOrganizationAdminAccountsResponse> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOrganizationAdminAccounts",
      method: "GET",
      requestUri: "/admin",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "adminAccounts": [toAdminAccount],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putClassificationExportConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutClassificationExportConfigurationRequest,
  ): Promise<s.PutClassificationExportConfigurationResponse> {
    const body: jsonP.JSONObject = {
      configuration: fromClassificationExportConfiguration(params["configuration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutClassificationExportConfiguration",
      method: "PUT",
      requestUri: "/classification-export-configuration",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "configuration": toClassificationExportConfiguration,
      },
    }, await resp.json());
  }

  async putFindingsPublicationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutFindingsPublicationConfigurationRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      securityHubConfiguration: fromSecurityHubConfiguration(params["securityHubConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutFindingsPublicationConfiguration",
      method: "PUT",
      requestUri: "/findings-publication-configuration",
      responseCode: 200,
    });
    await resp.text();
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async testCustomDataIdentifier(
    {abortSignal, ...params}: RequestConfig & s.TestCustomDataIdentifierRequest,
  ): Promise<s.TestCustomDataIdentifierResponse> {
    const body: jsonP.JSONObject = {
      ignoreWords: params["ignoreWords"],
      keywords: params["keywords"],
      maximumMatchDistance: params["maximumMatchDistance"],
      regex: params["regex"],
      sampleText: params["sampleText"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestCustomDataIdentifier",
      requestUri: "/custom-data-identifiers/test",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "matchCount": "n",
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    await resp.text();
  }

  async updateClassificationJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateClassificationJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      jobStatus: params["jobStatus"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClassificationJob",
      method: "PATCH",
      requestUri: cmnP.encodePath`/jobs/${params["jobId"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async updateFindingsFilter(
    {abortSignal, ...params}: RequestConfig & s.UpdateFindingsFilterRequest,
  ): Promise<s.UpdateFindingsFilterResponse> {
    const body: jsonP.JSONObject = {
      action: params["action"],
      description: params["description"],
      findingCriteria: fromFindingCriteria(params["findingCriteria"]),
      name: params["name"],
      position: params["position"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFindingsFilter",
      method: "PATCH",
      requestUri: cmnP.encodePath`/findingsfilters/${params["id"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
        "id": "s",
      },
    }, await resp.json());
  }

  async updateMacieSession(
    {abortSignal, ...params}: RequestConfig & s.UpdateMacieSessionRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      findingPublishingFrequency: params["findingPublishingFrequency"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMacieSession",
      method: "PATCH",
      requestUri: "/macie",
      responseCode: 200,
    });
    await resp.text();
  }

  async updateMemberSession(
    {abortSignal, ...params}: RequestConfig & s.UpdateMemberSessionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMemberSession",
      method: "PATCH",
      requestUri: cmnP.encodePath`/macie/members/${params["id"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async updateOrganizationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateOrganizationConfigurationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      autoEnable: params["autoEnable"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOrganizationConfiguration",
      method: "PATCH",
      requestUri: "/admin/configuration",
      responseCode: 200,
    });
    await resp.text();
  }

}

function fromS3JobDefinition(input?: s.S3JobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketDefinitions: input["bucketDefinitions"]?.map(x => fromS3BucketDefinitionForJob(x)),
    scoping: fromScoping(input["scoping"]),
  }
}
function toS3JobDefinition(root: jsonP.JSONValue): s.S3JobDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucketDefinitions": [toS3BucketDefinitionForJob],
      "scoping": toScoping,
    },
  }, root);
}

function fromS3BucketDefinitionForJob(input?: s.S3BucketDefinitionForJob | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accountId: input["accountId"],
    buckets: input["buckets"],
  }
}
function toS3BucketDefinitionForJob(root: jsonP.JSONValue): s.S3BucketDefinitionForJob {
  return jsonP.readObj({
    required: {
      "accountId": "s",
      "buckets": ["s"],
    },
    optional: {},
  }, root);
}

function fromScoping(input?: s.Scoping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    excludes: fromJobScopingBlock(input["excludes"]),
    includes: fromJobScopingBlock(input["includes"]),
  }
}
function toScoping(root: jsonP.JSONValue): s.Scoping {
  return jsonP.readObj({
    required: {},
    optional: {
      "excludes": toJobScopingBlock,
      "includes": toJobScopingBlock,
    },
  }, root);
}

function fromJobScopingBlock(input?: s.JobScopingBlock | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    and: input["and"]?.map(x => fromJobScopeTerm(x)),
  }
}
function toJobScopingBlock(root: jsonP.JSONValue): s.JobScopingBlock {
  return jsonP.readObj({
    required: {},
    optional: {
      "and": [toJobScopeTerm],
    },
  }, root);
}

function fromJobScopeTerm(input?: s.JobScopeTerm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    simpleScopeTerm: fromSimpleScopeTerm(input["simpleScopeTerm"]),
    tagScopeTerm: fromTagScopeTerm(input["tagScopeTerm"]),
  }
}
function toJobScopeTerm(root: jsonP.JSONValue): s.JobScopeTerm {
  return jsonP.readObj({
    required: {},
    optional: {
      "simpleScopeTerm": toSimpleScopeTerm,
      "tagScopeTerm": toTagScopeTerm,
    },
  }, root);
}

function fromSimpleScopeTerm(input?: s.SimpleScopeTerm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    comparator: input["comparator"],
    key: input["key"],
    values: input["values"],
  }
}
function toSimpleScopeTerm(root: jsonP.JSONValue): s.SimpleScopeTerm {
  return jsonP.readObj({
    required: {},
    optional: {
      "comparator": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobComparator>(x),
      "key": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScopeFilterKey>(x),
      "values": ["s"],
    },
  }, root);
}

function fromTagScopeTerm(input?: s.TagScopeTerm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    comparator: input["comparator"],
    key: input["key"],
    tagValues: input["tagValues"]?.map(x => fromTagValuePair(x)),
    target: input["target"],
  }
}
function toTagScopeTerm(root: jsonP.JSONValue): s.TagScopeTerm {
  return jsonP.readObj({
    required: {},
    optional: {
      "comparator": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobComparator>(x),
      "key": "s",
      "tagValues": [toTagValuePair],
      "target": (x: jsonP.JSONValue) => cmnP.readEnum<s.TagTarget>(x),
    },
  }, root);
}

function fromTagValuePair(input?: s.TagValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTagValuePair(root: jsonP.JSONValue): s.TagValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

function fromJobScheduleFrequency(input?: s.JobScheduleFrequency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dailySchedule: fromDailySchedule(input["dailySchedule"]),
    monthlySchedule: fromMonthlySchedule(input["monthlySchedule"]),
    weeklySchedule: fromWeeklySchedule(input["weeklySchedule"]),
  }
}
function toJobScheduleFrequency(root: jsonP.JSONValue): s.JobScheduleFrequency {
  return jsonP.readObj({
    required: {},
    optional: {
      "dailySchedule": toDailySchedule,
      "monthlySchedule": toMonthlySchedule,
      "weeklySchedule": toWeeklySchedule,
    },
  }, root);
}

function fromDailySchedule(input?: s.DailySchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toDailySchedule(root: jsonP.JSONValue): s.DailySchedule {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromMonthlySchedule(input?: s.MonthlySchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dayOfMonth: input["dayOfMonth"],
  }
}
function toMonthlySchedule(root: jsonP.JSONValue): s.MonthlySchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "dayOfMonth": "n",
    },
  }, root);
}

function fromWeeklySchedule(input?: s.WeeklySchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dayOfWeek: input["dayOfWeek"],
  }
}
function toWeeklySchedule(root: jsonP.JSONValue): s.WeeklySchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "dayOfWeek": (x: jsonP.JSONValue) => cmnP.readEnum<s.DayOfWeek>(x),
    },
  }, root);
}

function fromFindingCriteria(input?: s.FindingCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    criterion: jsonP.serializeMap(input["criterion"], x => fromCriterionAdditionalProperties(x)),
  }
}
function toFindingCriteria(root: jsonP.JSONValue): s.FindingCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "criterion": x => jsonP.readMap(String, toCriterionAdditionalProperties, x),
    },
  }, root);
}

function fromCriterionAdditionalProperties(input?: s.CriterionAdditionalProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eq: input["eq"],
    eqExactMatch: input["eqExactMatch"],
    gt: input["gt"],
    gte: input["gte"],
    lt: input["lt"],
    lte: input["lte"],
    neq: input["neq"],
  }
}
function toCriterionAdditionalProperties(root: jsonP.JSONValue): s.CriterionAdditionalProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "eq": ["s"],
      "eqExactMatch": ["s"],
      "gt": "n",
      "gte": "n",
      "lt": "n",
      "lte": "n",
      "neq": ["s"],
    },
  }, root);
}

function fromAccountDetail(input?: s.AccountDetail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accountId: input["accountId"],
    email: input["email"],
  }
}

function fromBucketCriteriaAdditionalProperties(input?: s.BucketCriteriaAdditionalProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eq: input["eq"],
    gt: input["gt"],
    gte: input["gte"],
    lt: input["lt"],
    lte: input["lte"],
    neq: input["neq"],
    prefix: input["prefix"],
  }
}

function fromBucketSortCriteria(input?: s.BucketSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

function fromFindingStatisticsSortCriteria(input?: s.FindingStatisticsSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

function fromSortCriteria(input?: s.SortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

function fromUsageStatisticsFilter(input?: s.UsageStatisticsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    comparator: input["comparator"],
    key: input["key"],
    values: input["values"],
  }
}

function fromUsageStatisticsSortBy(input?: s.UsageStatisticsSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    orderBy: input["orderBy"],
  }
}

function fromListJobsFilterCriteria(input?: s.ListJobsFilterCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    excludes: input["excludes"]?.map(x => fromListJobsFilterTerm(x)),
    includes: input["includes"]?.map(x => fromListJobsFilterTerm(x)),
  }
}

function fromListJobsFilterTerm(input?: s.ListJobsFilterTerm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    comparator: input["comparator"],
    key: input["key"],
    values: input["values"],
  }
}

function fromListJobsSortCriteria(input?: s.ListJobsSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributeName: input["attributeName"],
    orderBy: input["orderBy"],
  }
}

function fromClassificationExportConfiguration(input?: s.ClassificationExportConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Destination: fromS3Destination(input["s3Destination"]),
  }
}
function toClassificationExportConfiguration(root: jsonP.JSONValue): s.ClassificationExportConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Destination": toS3Destination,
    },
  }, root);
}

function fromS3Destination(input?: s.S3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketName: input["bucketName"],
    keyPrefix: input["keyPrefix"],
    kmsKeyArn: input["kmsKeyArn"],
  }
}
function toS3Destination(root: jsonP.JSONValue): s.S3Destination {
  return jsonP.readObj({
    required: {
      "bucketName": "s",
      "kmsKeyArn": "s",
    },
    optional: {
      "keyPrefix": "s",
    },
  }, root);
}

function fromSecurityHubConfiguration(input?: s.SecurityHubConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    publishClassificationFindings: input["publishClassificationFindings"],
    publishPolicyFindings: input["publishPolicyFindings"],
  }
}
function toSecurityHubConfiguration(root: jsonP.JSONValue): s.SecurityHubConfiguration {
  return jsonP.readObj({
    required: {
      "publishClassificationFindings": "b",
      "publishPolicyFindings": "b",
    },
    optional: {},
  }, root);
}

function toBatchGetCustomDataIdentifierSummary(root: jsonP.JSONValue): s.BatchGetCustomDataIdentifierSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "createdAt": "d",
      "deleted": "b",
      "description": "s",
      "id": "s",
      "name": "s",
    },
  }, root);
}

function toUnprocessedAccount(root: jsonP.JSONValue): s.UnprocessedAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ErrorCode>(x),
      "errorMessage": "s",
    },
  }, root);
}

function toBucketMetadata(root: jsonP.JSONValue): s.BucketMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "bucketArn": "s",
      "bucketCreatedAt": "d",
      "bucketName": "s",
      "classifiableObjectCount": "n",
      "classifiableSizeInBytes": "n",
      "jobDetails": toJobDetails,
      "lastUpdated": "d",
      "objectCount": "n",
      "objectCountByEncryptionType": toObjectCountByEncryptionType,
      "publicAccess": toBucketPublicAccess,
      "region": "s",
      "replicationDetails": toReplicationDetails,
      "serverSideEncryption": toBucketServerSideEncryption,
      "sharedAccess": (x: jsonP.JSONValue) => cmnP.readEnum<s.SharedAccess>(x),
      "sizeInBytes": "n",
      "sizeInBytesCompressed": "n",
      "tags": [toKeyValuePair],
      "unclassifiableObjectCount": toObjectLevelStatistics,
      "unclassifiableObjectSizeInBytes": toObjectLevelStatistics,
      "versioning": "b",
    },
  }, root);
}

function toJobDetails(root: jsonP.JSONValue): s.JobDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "isDefinedInJob": (x: jsonP.JSONValue) => cmnP.readEnum<s.IsDefinedInJob>(x),
      "isMonitoredByJob": (x: jsonP.JSONValue) => cmnP.readEnum<s.IsMonitoredByJob>(x),
      "lastJobId": "s",
      "lastJobRunTime": "d",
    },
  }, root);
}

function toObjectCountByEncryptionType(root: jsonP.JSONValue): s.ObjectCountByEncryptionType {
  return jsonP.readObj({
    required: {},
    optional: {
      "customerManaged": "n",
      "kmsManaged": "n",
      "s3Managed": "n",
      "unencrypted": "n",
    },
  }, root);
}

function toBucketPublicAccess(root: jsonP.JSONValue): s.BucketPublicAccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "effectivePermission": (x: jsonP.JSONValue) => cmnP.readEnum<s.EffectivePermission>(x),
      "permissionConfiguration": toBucketPermissionConfiguration,
    },
  }, root);
}

function toBucketPermissionConfiguration(root: jsonP.JSONValue): s.BucketPermissionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountLevelPermissions": toAccountLevelPermissions,
      "bucketLevelPermissions": toBucketLevelPermissions,
    },
  }, root);
}

function toAccountLevelPermissions(root: jsonP.JSONValue): s.AccountLevelPermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "blockPublicAccess": toBlockPublicAccess,
    },
  }, root);
}

function toBlockPublicAccess(root: jsonP.JSONValue): s.BlockPublicAccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "blockPublicAcls": "b",
      "blockPublicPolicy": "b",
      "ignorePublicAcls": "b",
      "restrictPublicBuckets": "b",
    },
  }, root);
}

function toBucketLevelPermissions(root: jsonP.JSONValue): s.BucketLevelPermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessControlList": toAccessControlList,
      "blockPublicAccess": toBlockPublicAccess,
      "bucketPolicy": toBucketPolicy,
    },
  }, root);
}

function toAccessControlList(root: jsonP.JSONValue): s.AccessControlList {
  return jsonP.readObj({
    required: {},
    optional: {
      "allowsPublicReadAccess": "b",
      "allowsPublicWriteAccess": "b",
    },
  }, root);
}

function toBucketPolicy(root: jsonP.JSONValue): s.BucketPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "allowsPublicReadAccess": "b",
      "allowsPublicWriteAccess": "b",
    },
  }, root);
}

function toReplicationDetails(root: jsonP.JSONValue): s.ReplicationDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "replicated": "b",
      "replicatedExternally": "b",
      "replicationAccounts": ["s"],
    },
  }, root);
}

function toBucketServerSideEncryption(root: jsonP.JSONValue): s.BucketServerSideEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "kmsMasterKeyId": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
  }, root);
}

function toKeyValuePair(root: jsonP.JSONValue): s.KeyValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

function toObjectLevelStatistics(root: jsonP.JSONValue): s.ObjectLevelStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "fileType": "n",
      "storageClass": "n",
      "total": "n",
    },
  }, root);
}

function toLastRunErrorStatus(root: jsonP.JSONValue): s.LastRunErrorStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastRunErrorStatusCode>(x),
    },
  }, root);
}

function toStatistics(root: jsonP.JSONValue): s.Statistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "approximateNumberOfObjectsToProcess": "n",
      "numberOfRuns": "n",
    },
  }, root);
}

function toUserPausedDetails(root: jsonP.JSONValue): s.UserPausedDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobExpiresAt": "d",
      "jobImminentExpirationHealthEventArn": "s",
      "jobPausedAt": "d",
    },
  }, root);
}

function toInvitation(root: jsonP.JSONValue): s.Invitation {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "invitationId": "s",
      "invitedAt": "d",
      "relationshipStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationshipStatus>(x),
    },
  }, root);
}

function toBucketCountByEffectivePermission(root: jsonP.JSONValue): s.BucketCountByEffectivePermission {
  return jsonP.readObj({
    required: {},
    optional: {
      "publiclyAccessible": "n",
      "publiclyReadable": "n",
      "publiclyWritable": "n",
      "unknown": "n",
    },
  }, root);
}

function toBucketCountByEncryptionType(root: jsonP.JSONValue): s.BucketCountByEncryptionType {
  return jsonP.readObj({
    required: {},
    optional: {
      "kmsManaged": "n",
      "s3Managed": "n",
      "unencrypted": "n",
    },
  }, root);
}

function toBucketCountBySharedAccessType(root: jsonP.JSONValue): s.BucketCountBySharedAccessType {
  return jsonP.readObj({
    required: {},
    optional: {
      "external": "n",
      "internal": "n",
      "notShared": "n",
      "unknown": "n",
    },
  }, root);
}

function toGroupCount(root: jsonP.JSONValue): s.GroupCount {
  return jsonP.readObj({
    required: {},
    optional: {
      "count": "n",
      "groupKey": "s",
    },
  }, root);
}

function toFinding(root: jsonP.JSONValue): s.Finding {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "archived": "b",
      "category": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingCategory>(x),
      "classificationDetails": toClassificationDetails,
      "count": "n",
      "createdAt": "d",
      "description": "s",
      "id": "s",
      "partition": "s",
      "policyDetails": toPolicyDetails,
      "region": "s",
      "resourcesAffected": toResourcesAffected,
      "sample": "b",
      "schemaVersion": "s",
      "severity": toSeverity,
      "title": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingType>(x),
      "updatedAt": "d",
    },
  }, root);
}

function toClassificationDetails(root: jsonP.JSONValue): s.ClassificationDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "detailedResultsLocation": "s",
      "jobArn": "s",
      "jobId": "s",
      "result": toClassificationResult,
    },
  }, root);
}

function toClassificationResult(root: jsonP.JSONValue): s.ClassificationResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "additionalOccurrences": "b",
      "customDataIdentifiers": toCustomDataIdentifiers,
      "mimeType": "s",
      "sensitiveData": [toSensitiveDataItem],
      "sizeClassified": "n",
      "status": toClassificationResultStatus,
    },
  }, root);
}

function toCustomDataIdentifiers(root: jsonP.JSONValue): s.CustomDataIdentifiers {
  return jsonP.readObj({
    required: {},
    optional: {
      "detections": [toCustomDetection],
      "totalCount": "n",
    },
  }, root);
}

function toCustomDetection(root: jsonP.JSONValue): s.CustomDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "count": "n",
      "name": "s",
      "occurrences": toOccurrences,
    },
  }, root);
}

function toOccurrences(root: jsonP.JSONValue): s.Occurrences {
  return jsonP.readObj({
    required: {},
    optional: {
      "cells": [toCell],
      "lineRanges": [toRange],
      "offsetRanges": [toRange],
      "pages": [toPage],
      "records": [toRecord],
    },
  }, root);
}

function toCell(root: jsonP.JSONValue): s.Cell {
  return jsonP.readObj({
    required: {},
    optional: {
      "cellReference": "s",
      "column": "n",
      "columnName": "s",
      "row": "n",
    },
  }, root);
}

function toRange(root: jsonP.JSONValue): s.Range {
  return jsonP.readObj({
    required: {},
    optional: {
      "end": "n",
      "start": "n",
      "startColumn": "n",
    },
  }, root);
}

function toPage(root: jsonP.JSONValue): s.Page {
  return jsonP.readObj({
    required: {},
    optional: {
      "lineRange": toRange,
      "offsetRange": toRange,
      "pageNumber": "n",
    },
  }, root);
}

function toRecord(root: jsonP.JSONValue): s.Record {
  return jsonP.readObj({
    required: {},
    optional: {
      "jsonPath": "s",
      "recordIndex": "n",
    },
  }, root);
}

function toSensitiveDataItem(root: jsonP.JSONValue): s.SensitiveDataItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "category": (x: jsonP.JSONValue) => cmnP.readEnum<s.SensitiveDataItemCategory>(x),
      "detections": [toDefaultDetection],
      "totalCount": "n",
    },
  }, root);
}

function toDefaultDetection(root: jsonP.JSONValue): s.DefaultDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "count": "n",
      "occurrences": toOccurrences,
      "type": "s",
    },
  }, root);
}

function toClassificationResultStatus(root: jsonP.JSONValue): s.ClassificationResultStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "reason": "s",
    },
  }, root);
}

function toPolicyDetails(root: jsonP.JSONValue): s.PolicyDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": toFindingAction,
      "actor": toFindingActor,
    },
  }, root);
}

function toFindingAction(root: jsonP.JSONValue): s.FindingAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingActionType>(x),
      "apiCallDetails": toApiCallDetails,
    },
  }, root);
}

function toApiCallDetails(root: jsonP.JSONValue): s.ApiCallDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "api": "s",
      "apiServiceName": "s",
      "firstSeen": "d",
      "lastSeen": "d",
    },
  }, root);
}

function toFindingActor(root: jsonP.JSONValue): s.FindingActor {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainDetails": toDomainDetails,
      "ipAddressDetails": toIpAddressDetails,
      "userIdentity": toUserIdentity,
    },
  }, root);
}

function toDomainDetails(root: jsonP.JSONValue): s.DomainDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainName": "s",
    },
  }, root);
}

function toIpAddressDetails(root: jsonP.JSONValue): s.IpAddressDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ipAddressV4": "s",
      "ipCity": toIpCity,
      "ipCountry": toIpCountry,
      "ipGeoLocation": toIpGeoLocation,
      "ipOwner": toIpOwner,
    },
  }, root);
}

function toIpCity(root: jsonP.JSONValue): s.IpCity {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function toIpCountry(root: jsonP.JSONValue): s.IpCountry {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "name": "s",
    },
  }, root);
}

function toIpGeoLocation(root: jsonP.JSONValue): s.IpGeoLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "lat": "n",
      "lon": "n",
    },
  }, root);
}

function toIpOwner(root: jsonP.JSONValue): s.IpOwner {
  return jsonP.readObj({
    required: {},
    optional: {
      "asn": "s",
      "asnOrg": "s",
      "isp": "s",
      "org": "s",
    },
  }, root);
}

function toUserIdentity(root: jsonP.JSONValue): s.UserIdentity {
  return jsonP.readObj({
    required: {},
    optional: {
      "assumedRole": toAssumedRole,
      "awsAccount": toAwsAccount,
      "awsService": toAwsService,
      "federatedUser": toFederatedUser,
      "iamUser": toIamUser,
      "root": toUserIdentityRoot,
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserIdentityType>(x),
    },
  }, root);
}

function toAssumedRole(root: jsonP.JSONValue): s.AssumedRole {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessKeyId": "s",
      "accountId": "s",
      "arn": "s",
      "principalId": "s",
      "sessionContext": toSessionContext,
    },
  }, root);
}

function toSessionContext(root: jsonP.JSONValue): s.SessionContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "attributes": toSessionContextAttributes,
      "sessionIssuer": toSessionIssuer,
    },
  }, root);
}

function toSessionContextAttributes(root: jsonP.JSONValue): s.SessionContextAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "creationDate": "d",
      "mfaAuthenticated": "b",
    },
  }, root);
}

function toSessionIssuer(root: jsonP.JSONValue): s.SessionIssuer {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "arn": "s",
      "principalId": "s",
      "type": "s",
      "userName": "s",
    },
  }, root);
}

function toAwsAccount(root: jsonP.JSONValue): s.AwsAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "principalId": "s",
    },
  }, root);
}

function toAwsService(root: jsonP.JSONValue): s.AwsService {
  return jsonP.readObj({
    required: {},
    optional: {
      "invokedBy": "s",
    },
  }, root);
}

function toFederatedUser(root: jsonP.JSONValue): s.FederatedUser {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessKeyId": "s",
      "accountId": "s",
      "arn": "s",
      "principalId": "s",
      "sessionContext": toSessionContext,
    },
  }, root);
}

function toIamUser(root: jsonP.JSONValue): s.IamUser {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "arn": "s",
      "principalId": "s",
      "userName": "s",
    },
  }, root);
}

function toUserIdentityRoot(root: jsonP.JSONValue): s.UserIdentityRoot {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "arn": "s",
      "principalId": "s",
    },
  }, root);
}

function toResourcesAffected(root: jsonP.JSONValue): s.ResourcesAffected {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3Bucket": toS3Bucket,
      "s3Object": toS3Object,
    },
  }, root);
}

function toS3Bucket(root: jsonP.JSONValue): s.S3Bucket {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "createdAt": "d",
      "defaultServerSideEncryption": toServerSideEncryption,
      "name": "s",
      "owner": toS3BucketOwner,
      "publicAccess": toBucketPublicAccess,
      "tags": [toKeyValuePair],
    },
  }, root);
}

function toServerSideEncryption(root: jsonP.JSONValue): s.ServerSideEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "encryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionType>(x),
      "kmsMasterKeyId": "s",
    },
  }, root);
}

function toS3BucketOwner(root: jsonP.JSONValue): s.S3BucketOwner {
  return jsonP.readObj({
    required: {},
    optional: {
      "displayName": "s",
      "id": "s",
    },
  }, root);
}

function toS3Object(root: jsonP.JSONValue): s.S3Object {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucketArn": "s",
      "eTag": "s",
      "extension": "s",
      "key": "s",
      "lastModified": "d",
      "path": "s",
      "publicAccess": "b",
      "serverSideEncryption": toServerSideEncryption,
      "size": "n",
      "storageClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.StorageClass>(x),
      "tags": [toKeyValuePair],
      "versionId": "s",
    },
  }, root);
}

function toSeverity(root: jsonP.JSONValue): s.Severity {
  return jsonP.readObj({
    required: {},
    optional: {
      "description": (x: jsonP.JSONValue) => cmnP.readEnum<s.SeverityDescription>(x),
      "score": "n",
    },
  }, root);
}

function toUsageRecord(root: jsonP.JSONValue): s.UsageRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "freeTrialStartDate": "d",
      "usage": [toUsageByAccount],
    },
  }, root);
}

function toUsageByAccount(root: jsonP.JSONValue): s.UsageByAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "currency": (x: jsonP.JSONValue) => cmnP.readEnum<s.Currency>(x),
      "estimatedCost": "s",
      "serviceLimit": toServiceLimit,
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageType>(x),
    },
  }, root);
}

function toServiceLimit(root: jsonP.JSONValue): s.ServiceLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "isServiceLimited": "b",
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.Unit>(x),
      "value": "n",
    },
  }, root);
}

function toUsageTotal(root: jsonP.JSONValue): s.UsageTotal {
  return jsonP.readObj({
    required: {},
    optional: {
      "currency": (x: jsonP.JSONValue) => cmnP.readEnum<s.Currency>(x),
      "estimatedCost": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageType>(x),
    },
  }, root);
}

function toJobSummary(root: jsonP.JSONValue): s.JobSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucketDefinitions": [toS3BucketDefinitionForJob],
      "createdAt": "d",
      "jobId": "s",
      "jobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "jobType": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobType>(x),
      "lastRunErrorStatus": toLastRunErrorStatus,
      "name": "s",
      "userPausedDetails": toUserPausedDetails,
    },
  }, root);
}

function toCustomDataIdentifierSummary(root: jsonP.JSONValue): s.CustomDataIdentifierSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "createdAt": "d",
      "description": "s",
      "id": "s",
      "name": "s",
    },
  }, root);
}

function toFindingsFilterListItem(root: jsonP.JSONValue): s.FindingsFilterListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingsFilterAction>(x),
      "arn": "s",
      "id": "s",
      "name": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toMember(root: jsonP.JSONValue): s.Member {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "administratorAccountId": "s",
      "arn": "s",
      "email": "s",
      "invitedAt": "d",
      "masterAccountId": "s",
      "relationshipStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationshipStatus>(x),
      "tags": x => jsonP.readMap(String, String, x),
      "updatedAt": "d",
    },
  }, root);
}

function toAdminAccount(root: jsonP.JSONValue): s.AdminAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "accountId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdminStatus>(x),
    },
  }, root);
}
