// Autogenerated API client for: Amazon Polly

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Polly {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Polly.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-06-10",
    "endpointPrefix": "polly",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Polly",
    "serviceId": "Polly",
    "signatureVersion": "v4",
    "uid": "polly-2016-06-10"
  };

  async deleteLexicon(
    {abortSignal, ...params}: RequestConfig & DeleteLexiconInput,
  ): Promise<DeleteLexiconOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteLexicon",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/lexicons/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeVoices(
    {abortSignal, ...params}: RequestConfig & DescribeVoicesInput = {},
  ): Promise<DescribeVoicesOutput> {
    const query = new URLSearchParams;
    if (params["Engine"] != null) query.set("Engine", params["Engine"]?.toString() ?? "");
    if (params["LanguageCode"] != null) query.set("LanguageCode", params["LanguageCode"]?.toString() ?? "");
    if (params["IncludeAdditionalLanguageCodes"] != null) query.set("IncludeAdditionalLanguageCodes", params["IncludeAdditionalLanguageCodes"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVoices",
      method: "GET",
      requestUri: "/v1/voices",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Voices": [toVoice],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getLexicon(
    {abortSignal, ...params}: RequestConfig & GetLexiconInput,
  ): Promise<GetLexiconOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetLexicon",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/lexicons/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Lexicon": toLexicon,
        "LexiconAttributes": toLexiconAttributes,
      },
    }, await resp.json());
  }

  async getSpeechSynthesisTask(
    {abortSignal, ...params}: RequestConfig & GetSpeechSynthesisTaskInput,
  ): Promise<GetSpeechSynthesisTaskOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSpeechSynthesisTask",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/synthesisTasks/${params["TaskId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SynthesisTask": toSynthesisTask,
      },
    }, await resp.json());
  }

  async listLexicons(
    {abortSignal, ...params}: RequestConfig & ListLexiconsInput = {},
  ): Promise<ListLexiconsOutput> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListLexicons",
      method: "GET",
      requestUri: "/v1/lexicons",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Lexicons": [toLexiconDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSpeechSynthesisTasks(
    {abortSignal, ...params}: RequestConfig & ListSpeechSynthesisTasksInput = {},
  ): Promise<ListSpeechSynthesisTasksOutput> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["Status"] != null) query.set("Status", params["Status"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSpeechSynthesisTasks",
      method: "GET",
      requestUri: "/v1/synthesisTasks",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "SynthesisTasks": [toSynthesisTask],
      },
    }, await resp.json());
  }

  async putLexicon(
    {abortSignal, ...params}: RequestConfig & PutLexiconInput,
  ): Promise<PutLexiconOutput> {
    const body: jsonP.JSONObject = {
      Content: params["Content"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLexicon",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/lexicons/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startSpeechSynthesisTask(
    {abortSignal, ...params}: RequestConfig & StartSpeechSynthesisTaskInput,
  ): Promise<StartSpeechSynthesisTaskOutput> {
    const body: jsonP.JSONObject = {
      Engine: params["Engine"],
      LanguageCode: params["LanguageCode"],
      LexiconNames: params["LexiconNames"],
      OutputFormat: params["OutputFormat"],
      OutputS3BucketName: params["OutputS3BucketName"],
      OutputS3KeyPrefix: params["OutputS3KeyPrefix"],
      SampleRate: params["SampleRate"],
      SnsTopicArn: params["SnsTopicArn"],
      SpeechMarkTypes: params["SpeechMarkTypes"],
      Text: params["Text"],
      TextType: params["TextType"],
      VoiceId: params["VoiceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSpeechSynthesisTask",
      requestUri: "/v1/synthesisTasks",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SynthesisTask": toSynthesisTask,
      },
    }, await resp.json());
  }

  async synthesizeSpeech(
    {abortSignal, ...params}: RequestConfig & SynthesizeSpeechInput,
  ): Promise<SynthesizeSpeechOutput> {
    const body: jsonP.JSONObject = {
      Engine: params["Engine"],
      LanguageCode: params["LanguageCode"],
      LexiconNames: params["LexiconNames"],
      OutputFormat: params["OutputFormat"],
      SampleRate: params["SampleRate"],
      SpeechMarkTypes: params["SpeechMarkTypes"],
      Text: params["Text"],
      TextType: params["TextType"],
      VoiceId: params["VoiceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SynthesizeSpeech",
      requestUri: "/v1/speech",
      responseCode: 200,
    });
  return {
    ContentType: resp.headers.get("Content-Type"),
    RequestCharacters: cmnP.readNum(resp.headers.get("x-amzn-RequestCharacters")),
    AudioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

}

// refs: 1 - tags: named, input
export interface DeleteLexiconInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeVoicesInput {
  Engine?: Engine | null;
  LanguageCode?: LanguageCode | null;
  IncludeAdditionalLanguageCodes?: boolean | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetLexiconInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetSpeechSynthesisTaskInput {
  TaskId: string;
}

// refs: 1 - tags: named, input
export interface ListLexiconsInput {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSpeechSynthesisTasksInput {
  MaxResults?: number | null;
  NextToken?: string | null;
  Status?: TaskStatus | null;
}

// refs: 1 - tags: named, input
export interface PutLexiconInput {
  Name: string;
  Content: string;
}

// refs: 1 - tags: named, input
export interface StartSpeechSynthesisTaskInput {
  Engine?: Engine | null;
  LanguageCode?: LanguageCode | null;
  LexiconNames?: string[] | null;
  OutputFormat: OutputFormat;
  OutputS3BucketName: string;
  OutputS3KeyPrefix?: string | null;
  SampleRate?: string | null;
  SnsTopicArn?: string | null;
  SpeechMarkTypes?: SpeechMarkType[] | null;
  Text: string;
  TextType?: TextType | null;
  VoiceId: VoiceId;
}

// refs: 1 - tags: named, input
export interface SynthesizeSpeechInput {
  Engine?: Engine | null;
  LanguageCode?: LanguageCode | null;
  LexiconNames?: string[] | null;
  OutputFormat: OutputFormat;
  SampleRate?: string | null;
  SpeechMarkTypes?: SpeechMarkType[] | null;
  Text: string;
  TextType?: TextType | null;
  VoiceId: VoiceId;
}

// refs: 1 - tags: named, output
export interface DeleteLexiconOutput {
}

// refs: 1 - tags: named, output
export interface DescribeVoicesOutput {
  Voices?: Voice[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetLexiconOutput {
  Lexicon?: Lexicon | null;
  LexiconAttributes?: LexiconAttributes | null;
}

// refs: 1 - tags: named, output
export interface GetSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask | null;
}

// refs: 1 - tags: named, output
export interface ListLexiconsOutput {
  Lexicons?: LexiconDescription[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSpeechSynthesisTasksOutput {
  NextToken?: string | null;
  SynthesisTasks?: SynthesisTask[] | null;
}

// refs: 1 - tags: named, output
export interface PutLexiconOutput {
}

// refs: 1 - tags: named, output
export interface StartSpeechSynthesisTaskOutput {
  SynthesisTask?: SynthesisTask | null;
}

// refs: 1 - tags: named, output
export interface SynthesizeSpeechOutput {
  AudioStream?: Uint8Array | string | null;
  ContentType?: string | null;
  RequestCharacters?: number | null;
}

// refs: 7 - tags: input, named, enum, output
export type Engine =
| "standard"
| "neural"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type LanguageCode =
| "arb"
| "cmn-CN"
| "cy-GB"
| "da-DK"
| "de-DE"
| "en-AU"
| "en-GB"
| "en-GB-WLS"
| "en-IN"
| "en-US"
| "es-ES"
| "es-MX"
| "es-US"
| "fr-CA"
| "fr-FR"
| "is-IS"
| "it-IT"
| "ja-JP"
| "hi-IN"
| "ko-KR"
| "nb-NO"
| "nl-NL"
| "pl-PL"
| "pt-BR"
| "pt-PT"
| "ro-RO"
| "ru-RU"
| "sv-SE"
| "tr-TR"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type TaskStatus =
| "scheduled"
| "inProgress"
| "completed"
| "failed"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type OutputFormat =
| "json"
| "mp3"
| "ogg_vorbis"
| "pcm"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type SpeechMarkType =
| "sentence"
| "ssml"
| "viseme"
| "word"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type TextType =
| "ssml"
| "text"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type VoiceId =
| "Aditi"
| "Amy"
| "Astrid"
| "Bianca"
| "Brian"
| "Camila"
| "Carla"
| "Carmen"
| "Celine"
| "Chantal"
| "Conchita"
| "Cristiano"
| "Dora"
| "Emma"
| "Enrique"
| "Ewa"
| "Filiz"
| "Geraint"
| "Giorgio"
| "Gwyneth"
| "Hans"
| "Ines"
| "Ivy"
| "Jacek"
| "Jan"
| "Joanna"
| "Joey"
| "Justin"
| "Karl"
| "Kendra"
| "Kevin"
| "Kimberly"
| "Lea"
| "Liv"
| "Lotte"
| "Lucia"
| "Lupe"
| "Mads"
| "Maja"
| "Marlene"
| "Mathieu"
| "Matthew"
| "Maxim"
| "Mia"
| "Miguel"
| "Mizuki"
| "Naja"
| "Nicole"
| "Olivia"
| "Penelope"
| "Raveena"
| "Ricardo"
| "Ruben"
| "Russell"
| "Salli"
| "Seoyeon"
| "Takumi"
| "Tatyana"
| "Vicki"
| "Vitoria"
| "Zeina"
| "Zhiyu"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Voice {
  Gender?: Gender | null;
  Id?: VoiceId | null;
  LanguageCode?: LanguageCode | null;
  LanguageName?: string | null;
  Name?: string | null;
  AdditionalLanguageCodes?: LanguageCode[] | null;
  SupportedEngines?: Engine[] | null;
}
function toVoice(root: jsonP.JSONValue): Voice {
  return jsonP.readObj({
    required: {},
    optional: {
      "Gender": (x: jsonP.JSONValue) => cmnP.readEnum<Gender>(x),
      "Id": (x: jsonP.JSONValue) => cmnP.readEnum<VoiceId>(x),
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LanguageName": "s",
      "Name": "s",
      "AdditionalLanguageCodes": [(x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x)],
      "SupportedEngines": [(x: jsonP.JSONValue) => cmnP.readEnum<Engine>(x)],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type Gender =
| "Female"
| "Male"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Lexicon {
  Content?: string | null;
  Name?: string | null;
}
function toLexicon(root: jsonP.JSONValue): Lexicon {
  return jsonP.readObj({
    required: {},
    optional: {
      "Content": "s",
      "Name": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LexiconAttributes {
  Alphabet?: string | null;
  LanguageCode?: LanguageCode | null;
  LastModified?: Date | number | null;
  LexiconArn?: string | null;
  LexemesCount?: number | null;
  Size?: number | null;
}
function toLexiconAttributes(root: jsonP.JSONValue): LexiconAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alphabet": "s",
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
      "LastModified": "d",
      "LexiconArn": "s",
      "LexemesCount": "n",
      "Size": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface SynthesisTask {
  Engine?: Engine | null;
  TaskId?: string | null;
  TaskStatus?: TaskStatus | null;
  TaskStatusReason?: string | null;
  OutputUri?: string | null;
  CreationTime?: Date | number | null;
  RequestCharacters?: number | null;
  SnsTopicArn?: string | null;
  LexiconNames?: string[] | null;
  OutputFormat?: OutputFormat | null;
  SampleRate?: string | null;
  SpeechMarkTypes?: SpeechMarkType[] | null;
  TextType?: TextType | null;
  VoiceId?: VoiceId | null;
  LanguageCode?: LanguageCode | null;
}
function toSynthesisTask(root: jsonP.JSONValue): SynthesisTask {
  return jsonP.readObj({
    required: {},
    optional: {
      "Engine": (x: jsonP.JSONValue) => cmnP.readEnum<Engine>(x),
      "TaskId": "s",
      "TaskStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TaskStatus>(x),
      "TaskStatusReason": "s",
      "OutputUri": "s",
      "CreationTime": "d",
      "RequestCharacters": "n",
      "SnsTopicArn": "s",
      "LexiconNames": ["s"],
      "OutputFormat": (x: jsonP.JSONValue) => cmnP.readEnum<OutputFormat>(x),
      "SampleRate": "s",
      "SpeechMarkTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<SpeechMarkType>(x)],
      "TextType": (x: jsonP.JSONValue) => cmnP.readEnum<TextType>(x),
      "VoiceId": (x: jsonP.JSONValue) => cmnP.readEnum<VoiceId>(x),
      "LanguageCode": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageCode>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LexiconDescription {
  Name?: string | null;
  Attributes?: LexiconAttributes | null;
}
function toLexiconDescription(root: jsonP.JSONValue): LexiconDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Attributes": toLexiconAttributes,
    },
  }, root);
}
