// Autogenerated API client for: Amazon Elasticsearch Service

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export class ES {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ES.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-01-01",
    "endpointPrefix": "es",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Elasticsearch Service",
    "serviceId": "Elasticsearch Service",
    "signatureVersion": "v4",
    "uid": "es-2015-01-01"
  };

  async acceptInboundCrossClusterSearchConnection(
    params: s.AcceptInboundCrossClusterSearchConnectionRequest,
  ): Promise<s.AcceptInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      action: "AcceptInboundCrossClusterSearchConnection",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}/accept`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async addTags(
    params: s.AddTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ARN: params["ARN"],
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "AddTags",
      requestUri: "/2015-01-01/tags",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async associatePackage(
    params: s.AssociatePackageRequest,
  ): Promise<s.AssociatePackageResponse> {

    const resp = await this.#client.performRequest({
      action: "AssociatePackage",
      requestUri: cmnP.encodePath`/2015-01-01/packages/associate/${params["PackageID"]}/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetails": toDomainPackageDetails,
      },
    }, await resp.json());
  }

  async cancelElasticsearchServiceSoftwareUpdate(
    params: s.CancelElasticsearchServiceSoftwareUpdateRequest,
  ): Promise<s.CancelElasticsearchServiceSoftwareUpdateResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CancelElasticsearchServiceSoftwareUpdate",
      requestUri: "/2015-01-01/es/serviceSoftwareUpdate/cancel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSoftwareOptions": toServiceSoftwareOptions,
      },
    }, await resp.json());
  }

  async createElasticsearchDomain(
    params: s.CreateElasticsearchDomainRequest,
  ): Promise<s.CreateElasticsearchDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      ElasticsearchVersion: params["ElasticsearchVersion"],
      ElasticsearchClusterConfig: fromElasticsearchClusterConfig(params["ElasticsearchClusterConfig"]),
      EBSOptions: fromEBSOptions(params["EBSOptions"]),
      AccessPolicies: params["AccessPolicies"],
      SnapshotOptions: fromSnapshotOptions(params["SnapshotOptions"]),
      VPCOptions: fromVPCOptions(params["VPCOptions"]),
      CognitoOptions: fromCognitoOptions(params["CognitoOptions"]),
      EncryptionAtRestOptions: fromEncryptionAtRestOptions(params["EncryptionAtRestOptions"]),
      NodeToNodeEncryptionOptions: fromNodeToNodeEncryptionOptions(params["NodeToNodeEncryptionOptions"]),
      AdvancedOptions: params["AdvancedOptions"],
      LogPublishingOptions: jsonP.serializeMap(params["LogPublishingOptions"], x => fromLogPublishingOption(x)),
      DomainEndpointOptions: fromDomainEndpointOptions(params["DomainEndpointOptions"]),
      AdvancedSecurityOptions: fromAdvancedSecurityOptionsInput(params["AdvancedSecurityOptions"]),
      AutoTuneOptions: fromAutoTuneOptionsInput(params["AutoTuneOptions"]),
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateElasticsearchDomain",
      requestUri: "/2015-01-01/es/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
    }, await resp.json());
  }

  async createOutboundCrossClusterSearchConnection(
    params: s.CreateOutboundCrossClusterSearchConnectionRequest,
  ): Promise<s.CreateOutboundCrossClusterSearchConnectionResponse> {
    const body: jsonP.JSONObject = {
      SourceDomainInfo: fromDomainInformation(params["SourceDomainInfo"]),
      DestinationDomainInfo: fromDomainInformation(params["DestinationDomainInfo"]),
      ConnectionAlias: params["ConnectionAlias"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateOutboundCrossClusterSearchConnection",
      requestUri: "/2015-01-01/es/ccs/outboundConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SourceDomainInfo": toDomainInformation,
        "DestinationDomainInfo": toDomainInformation,
        "ConnectionAlias": "s",
        "ConnectionStatus": toOutboundCrossClusterSearchConnectionStatus,
        "CrossClusterSearchConnectionId": "s",
      },
    }, await resp.json());
  }

  async createPackage(
    params: s.CreatePackageRequest,
  ): Promise<s.CreatePackageResponse> {
    const body: jsonP.JSONObject = {
      PackageName: params["PackageName"],
      PackageType: params["PackageType"],
      PackageDescription: params["PackageDescription"],
      PackageSource: fromPackageSource(params["PackageSource"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreatePackage",
      requestUri: "/2015-01-01/packages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async deleteElasticsearchDomain(
    params: s.DeleteElasticsearchDomainRequest,
  ): Promise<s.DeleteElasticsearchDomainResponse> {

    const resp = await this.#client.performRequest({
      action: "DeleteElasticsearchDomain",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
    }, await resp.json());
  }

  async deleteElasticsearchServiceRole(): Promise<void> {
    const resp = await this.#client.performRequest({
      action: "DeleteElasticsearchServiceRole",
      method: "DELETE",
      requestUri: "/2015-01-01/es/role",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteInboundCrossClusterSearchConnection(
    params: s.DeleteInboundCrossClusterSearchConnectionRequest,
  ): Promise<s.DeleteInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      action: "DeleteInboundCrossClusterSearchConnection",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async deleteOutboundCrossClusterSearchConnection(
    params: s.DeleteOutboundCrossClusterSearchConnectionRequest,
  ): Promise<s.DeleteOutboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      action: "DeleteOutboundCrossClusterSearchConnection",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/outboundConnection/${params["CrossClusterSearchConnectionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toOutboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async deletePackage(
    params: s.DeletePackageRequest,
  ): Promise<s.DeletePackageResponse> {

    const resp = await this.#client.performRequest({
      action: "DeletePackage",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async describeDomainAutoTunes(
    params: s.DescribeDomainAutoTunesRequest,
  ): Promise<s.DescribeDomainAutoTunesResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "DescribeDomainAutoTunes",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}/autoTunes`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutoTunes": [toAutoTune],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeElasticsearchDomain(
    params: s.DescribeElasticsearchDomainRequest,
  ): Promise<s.DescribeElasticsearchDomainResponse> {

    const resp = await this.#client.performRequest({
      action: "DescribeElasticsearchDomain",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchDomainConfig(
    params: s.DescribeElasticsearchDomainConfigRequest,
  ): Promise<s.DescribeElasticsearchDomainConfigResponse> {

    const resp = await this.#client.performRequest({
      action: "DescribeElasticsearchDomainConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}/config`,
    });
    return jsonP.readObj({
      required: {
        "DomainConfig": toElasticsearchDomainConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchDomains(
    params: s.DescribeElasticsearchDomainsRequest,
  ): Promise<s.DescribeElasticsearchDomainsResponse> {
    const body: jsonP.JSONObject = {
      DomainNames: params["DomainNames"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "DescribeElasticsearchDomains",
      requestUri: "/2015-01-01/es/domain-info",
    });
    return jsonP.readObj({
      required: {
        "DomainStatusList": [toElasticsearchDomainStatus],
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchInstanceTypeLimits(
    params: s.DescribeElasticsearchInstanceTypeLimitsRequest,
  ): Promise<s.DescribeElasticsearchInstanceTypeLimitsResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DescribeElasticsearchInstanceTypeLimits",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/instanceTypeLimits/${params["ElasticsearchVersion"]}/${params["InstanceType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LimitsByRole": x => jsonP.readMap(String, toLimits, x),
      },
    }, await resp.json());
  }

  async describeInboundCrossClusterSearchConnections(
    params: s.DescribeInboundCrossClusterSearchConnectionsRequest = {},
  ): Promise<s.DescribeInboundCrossClusterSearchConnectionsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "DescribeInboundCrossClusterSearchConnections",
      requestUri: "/2015-01-01/es/ccs/inboundConnection/search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnections": [toInboundCrossClusterSearchConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeOutboundCrossClusterSearchConnections(
    params: s.DescribeOutboundCrossClusterSearchConnectionsRequest = {},
  ): Promise<s.DescribeOutboundCrossClusterSearchConnectionsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "DescribeOutboundCrossClusterSearchConnections",
      requestUri: "/2015-01-01/es/ccs/outboundConnection/search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnections": [toOutboundCrossClusterSearchConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePackages(
    params: s.DescribePackagesRequest = {},
  ): Promise<s.DescribePackagesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromDescribePackagesFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "DescribePackages",
      requestUri: "/2015-01-01/packages/describe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetailsList": [toPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeReservedElasticsearchInstanceOfferings(
    params: s.DescribeReservedElasticsearchInstanceOfferingsRequest = {},
  ): Promise<s.DescribeReservedElasticsearchInstanceOfferingsResponse> {
    const query = new URLSearchParams;
    if (params["ReservedElasticsearchInstanceOfferingId"] != null) query.set("offeringId", params["ReservedElasticsearchInstanceOfferingId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DescribeReservedElasticsearchInstanceOfferings",
      method: "GET",
      requestUri: "/2015-01-01/es/reservedInstanceOfferings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ReservedElasticsearchInstanceOfferings": [toReservedElasticsearchInstanceOffering],
      },
    }, await resp.json());
  }

  async describeReservedElasticsearchInstances(
    params: s.DescribeReservedElasticsearchInstancesRequest = {},
  ): Promise<s.DescribeReservedElasticsearchInstancesResponse> {
    const query = new URLSearchParams;
    if (params["ReservedElasticsearchInstanceId"] != null) query.set("reservationId", params["ReservedElasticsearchInstanceId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DescribeReservedElasticsearchInstances",
      method: "GET",
      requestUri: "/2015-01-01/es/reservedInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ReservedElasticsearchInstances": [toReservedElasticsearchInstance],
      },
    }, await resp.json());
  }

  async dissociatePackage(
    params: s.DissociatePackageRequest,
  ): Promise<s.DissociatePackageResponse> {

    const resp = await this.#client.performRequest({
      action: "DissociatePackage",
      requestUri: cmnP.encodePath`/2015-01-01/packages/dissociate/${params["PackageID"]}/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetails": toDomainPackageDetails,
      },
    }, await resp.json());
  }

  async getCompatibleElasticsearchVersions(
    params: s.GetCompatibleElasticsearchVersionsRequest = {},
  ): Promise<s.GetCompatibleElasticsearchVersionsResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetCompatibleElasticsearchVersions",
      method: "GET",
      requestUri: "/2015-01-01/es/compatibleVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CompatibleElasticsearchVersions": [toCompatibleVersionsMap],
      },
    }, await resp.json());
  }

  async getPackageVersionHistory(
    params: s.GetPackageVersionHistoryRequest,
  ): Promise<s.GetPackageVersionHistoryResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetPackageVersionHistory",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}/history`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageID": "s",
        "PackageVersionHistoryList": [toPackageVersionHistory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUpgradeHistory(
    params: s.GetUpgradeHistoryRequest,
  ): Promise<s.GetUpgradeHistoryResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetUpgradeHistory",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/upgradeDomain/${params["DomainName"]}/history`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradeHistories": [toUpgradeHistory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUpgradeStatus(
    params: s.GetUpgradeStatusRequest,
  ): Promise<s.GetUpgradeStatusResponse> {

    const resp = await this.#client.performRequest({
      action: "GetUpgradeStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/upgradeDomain/${params["DomainName"]}/status`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradeStep": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpgradeStep>(x),
        "StepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpgradeStatus>(x),
        "UpgradeName": "s",
      },
    }, await resp.json());
  }

  async listDomainNames(): Promise<s.ListDomainNamesResponse> {
    const resp = await this.#client.performRequest({
      action: "ListDomainNames",
      method: "GET",
      requestUri: "/2015-01-01/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainNames": [toDomainInfo],
      },
    }, await resp.json());
  }

  async listDomainsForPackage(
    params: s.ListDomainsForPackageRequest,
  ): Promise<s.ListDomainsForPackageResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListDomainsForPackage",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}/domains`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetailsList": [toDomainPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listElasticsearchInstanceTypes(
    params: s.ListElasticsearchInstanceTypesRequest,
  ): Promise<s.ListElasticsearchInstanceTypesResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListElasticsearchInstanceTypes",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/instanceTypes/${params["ElasticsearchVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticsearchInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ESPartitionInstanceType>(x)],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listElasticsearchVersions(
    params: s.ListElasticsearchVersionsRequest = {},
  ): Promise<s.ListElasticsearchVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListElasticsearchVersions",
      method: "GET",
      requestUri: "/2015-01-01/es/versions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticsearchVersions": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPackagesForDomain(
    params: s.ListPackagesForDomainRequest,
  ): Promise<s.ListPackagesForDomainResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListPackagesForDomain",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/domain/${params["DomainName"]}/packages`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetailsList": [toDomainPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTags(
    params: s.ListTagsRequest,
  ): Promise<s.ListTagsResponse> {
    const query = new URLSearchParams;
    query.set("arn", params["ARN"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTags",
      method: "GET",
      requestUri: "/2015-01-01/tags/",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TagList": [toTag],
      },
    }, await resp.json());
  }

  async purchaseReservedElasticsearchInstanceOffering(
    params: s.PurchaseReservedElasticsearchInstanceOfferingRequest,
  ): Promise<s.PurchaseReservedElasticsearchInstanceOfferingResponse> {
    const body: jsonP.JSONObject = {
      ReservedElasticsearchInstanceOfferingId: params["ReservedElasticsearchInstanceOfferingId"],
      ReservationName: params["ReservationName"],
      InstanceCount: params["InstanceCount"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "PurchaseReservedElasticsearchInstanceOffering",
      requestUri: "/2015-01-01/es/purchaseReservedInstanceOffering",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedElasticsearchInstanceId": "s",
        "ReservationName": "s",
      },
    }, await resp.json());
  }

  async rejectInboundCrossClusterSearchConnection(
    params: s.RejectInboundCrossClusterSearchConnectionRequest,
  ): Promise<s.RejectInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      action: "RejectInboundCrossClusterSearchConnection",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}/reject`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async removeTags(
    params: s.RemoveTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ARN: params["ARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "RemoveTags",
      requestUri: "/2015-01-01/tags-removal",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async startElasticsearchServiceSoftwareUpdate(
    params: s.StartElasticsearchServiceSoftwareUpdateRequest,
  ): Promise<s.StartElasticsearchServiceSoftwareUpdateResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "StartElasticsearchServiceSoftwareUpdate",
      requestUri: "/2015-01-01/es/serviceSoftwareUpdate/start",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSoftwareOptions": toServiceSoftwareOptions,
      },
    }, await resp.json());
  }

  async updateElasticsearchDomainConfig(
    params: s.UpdateElasticsearchDomainConfigRequest,
  ): Promise<s.UpdateElasticsearchDomainConfigResponse> {
    const body: jsonP.JSONObject = {
      ElasticsearchClusterConfig: fromElasticsearchClusterConfig(params["ElasticsearchClusterConfig"]),
      EBSOptions: fromEBSOptions(params["EBSOptions"]),
      SnapshotOptions: fromSnapshotOptions(params["SnapshotOptions"]),
      VPCOptions: fromVPCOptions(params["VPCOptions"]),
      CognitoOptions: fromCognitoOptions(params["CognitoOptions"]),
      AdvancedOptions: params["AdvancedOptions"],
      AccessPolicies: params["AccessPolicies"],
      LogPublishingOptions: jsonP.serializeMap(params["LogPublishingOptions"], x => fromLogPublishingOption(x)),
      DomainEndpointOptions: fromDomainEndpointOptions(params["DomainEndpointOptions"]),
      AdvancedSecurityOptions: fromAdvancedSecurityOptionsInput(params["AdvancedSecurityOptions"]),
      NodeToNodeEncryptionOptions: fromNodeToNodeEncryptionOptions(params["NodeToNodeEncryptionOptions"]),
      EncryptionAtRestOptions: fromEncryptionAtRestOptions(params["EncryptionAtRestOptions"]),
      AutoTuneOptions: fromAutoTuneOptions(params["AutoTuneOptions"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateElasticsearchDomainConfig",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}/config`,
    });
    return jsonP.readObj({
      required: {
        "DomainConfig": toElasticsearchDomainConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePackage(
    params: s.UpdatePackageRequest,
  ): Promise<s.UpdatePackageResponse> {
    const body: jsonP.JSONObject = {
      PackageID: params["PackageID"],
      PackageSource: fromPackageSource(params["PackageSource"]),
      PackageDescription: params["PackageDescription"],
      CommitMessage: params["CommitMessage"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdatePackage",
      requestUri: "/2015-01-01/packages/update",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async upgradeElasticsearchDomain(
    params: s.UpgradeElasticsearchDomainRequest,
  ): Promise<s.UpgradeElasticsearchDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      TargetVersion: params["TargetVersion"],
      PerformCheckOnly: params["PerformCheckOnly"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpgradeElasticsearchDomain",
      requestUri: "/2015-01-01/es/upgradeDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainName": "s",
        "TargetVersion": "s",
        "PerformCheckOnly": "b",
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromElasticsearchClusterConfig(input?: s.ElasticsearchClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    DedicatedMasterEnabled: input["DedicatedMasterEnabled"],
    ZoneAwarenessEnabled: input["ZoneAwarenessEnabled"],
    ZoneAwarenessConfig: fromZoneAwarenessConfig(input["ZoneAwarenessConfig"]),
    DedicatedMasterType: input["DedicatedMasterType"],
    DedicatedMasterCount: input["DedicatedMasterCount"],
    WarmEnabled: input["WarmEnabled"],
    WarmType: input["WarmType"],
    WarmCount: input["WarmCount"],
  }
}
function toElasticsearchClusterConfig(root: jsonP.JSONValue): s.ElasticsearchClusterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ESPartitionInstanceType>(x),
      "InstanceCount": "n",
      "DedicatedMasterEnabled": "b",
      "ZoneAwarenessEnabled": "b",
      "ZoneAwarenessConfig": toZoneAwarenessConfig,
      "DedicatedMasterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ESPartitionInstanceType>(x),
      "DedicatedMasterCount": "n",
      "WarmEnabled": "b",
      "WarmType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ESWarmPartitionInstanceType>(x),
      "WarmCount": "n",
    },
  }, root);
}

function fromZoneAwarenessConfig(input?: s.ZoneAwarenessConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZoneCount: input["AvailabilityZoneCount"],
  }
}
function toZoneAwarenessConfig(root: jsonP.JSONValue): s.ZoneAwarenessConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZoneCount": "n",
    },
  }, root);
}

function fromEBSOptions(input?: s.EBSOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EBSEnabled: input["EBSEnabled"],
    VolumeType: input["VolumeType"],
    VolumeSize: input["VolumeSize"],
    Iops: input["Iops"],
  }
}
function toEBSOptions(root: jsonP.JSONValue): s.EBSOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "EBSEnabled": "b",
      "VolumeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.VolumeType>(x),
      "VolumeSize": "n",
      "Iops": "n",
    },
  }, root);
}

function fromSnapshotOptions(input?: s.SnapshotOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomatedSnapshotStartHour: input["AutomatedSnapshotStartHour"],
  }
}
function toSnapshotOptions(root: jsonP.JSONValue): s.SnapshotOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomatedSnapshotStartHour": "n",
    },
  }, root);
}

function fromVPCOptions(input?: s.VPCOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

function fromCognitoOptions(input?: s.CognitoOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    UserPoolId: input["UserPoolId"],
    IdentityPoolId: input["IdentityPoolId"],
    RoleArn: input["RoleArn"],
  }
}
function toCognitoOptions(root: jsonP.JSONValue): s.CognitoOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "UserPoolId": "s",
      "IdentityPoolId": "s",
      "RoleArn": "s",
    },
  }, root);
}

function fromEncryptionAtRestOptions(input?: s.EncryptionAtRestOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toEncryptionAtRestOptions(root: jsonP.JSONValue): s.EncryptionAtRestOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "KmsKeyId": "s",
    },
  }, root);
}

function fromNodeToNodeEncryptionOptions(input?: s.NodeToNodeEncryptionOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toNodeToNodeEncryptionOptions(root: jsonP.JSONValue): s.NodeToNodeEncryptionOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromLogPublishingOption(input?: s.LogPublishingOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchLogsLogGroupArn: input["CloudWatchLogsLogGroupArn"],
    Enabled: input["Enabled"],
  }
}
function toLogPublishingOption(root: jsonP.JSONValue): s.LogPublishingOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogsLogGroupArn": "s",
      "Enabled": "b",
    },
  }, root);
}

function fromDomainEndpointOptions(input?: s.DomainEndpointOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnforceHTTPS: input["EnforceHTTPS"],
    TLSSecurityPolicy: input["TLSSecurityPolicy"],
    CustomEndpointEnabled: input["CustomEndpointEnabled"],
    CustomEndpoint: input["CustomEndpoint"],
    CustomEndpointCertificateArn: input["CustomEndpointCertificateArn"],
  }
}
function toDomainEndpointOptions(root: jsonP.JSONValue): s.DomainEndpointOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnforceHTTPS": "b",
      "TLSSecurityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.TLSSecurityPolicy>(x),
      "CustomEndpointEnabled": "b",
      "CustomEndpoint": "s",
      "CustomEndpointCertificateArn": "s",
    },
  }, root);
}

function fromAdvancedSecurityOptionsInput(input?: s.AdvancedSecurityOptionsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    InternalUserDatabaseEnabled: input["InternalUserDatabaseEnabled"],
    MasterUserOptions: fromMasterUserOptions(input["MasterUserOptions"]),
    SAMLOptions: fromSAMLOptionsInput(input["SAMLOptions"]),
  }
}

function fromMasterUserOptions(input?: s.MasterUserOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MasterUserARN: input["MasterUserARN"],
    MasterUserName: input["MasterUserName"],
    MasterUserPassword: input["MasterUserPassword"],
  }
}

function fromSAMLOptionsInput(input?: s.SAMLOptionsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    Idp: fromSAMLIdp(input["Idp"]),
    MasterUserName: input["MasterUserName"],
    MasterBackendRole: input["MasterBackendRole"],
    SubjectKey: input["SubjectKey"],
    RolesKey: input["RolesKey"],
    SessionTimeoutMinutes: input["SessionTimeoutMinutes"],
  }
}

function fromSAMLIdp(input?: s.SAMLIdp | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetadataContent: input["MetadataContent"],
    EntityId: input["EntityId"],
  }
}
function toSAMLIdp(root: jsonP.JSONValue): s.SAMLIdp {
  return jsonP.readObj({
    required: {
      "MetadataContent": "s",
      "EntityId": "s",
    },
    optional: {},
  }, root);
}

function fromAutoTuneOptionsInput(input?: s.AutoTuneOptionsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DesiredState: input["DesiredState"],
    MaintenanceSchedules: input["MaintenanceSchedules"]?.map(x => fromAutoTuneMaintenanceSchedule(x)),
  }
}

function fromAutoTuneMaintenanceSchedule(input?: s.AutoTuneMaintenanceSchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartAt: jsonP.serializeDate_unixTimestamp(input["StartAt"]),
    Duration: fromDuration(input["Duration"]),
    CronExpressionForRecurrence: input["CronExpressionForRecurrence"],
  }
}
function toAutoTuneMaintenanceSchedule(root: jsonP.JSONValue): s.AutoTuneMaintenanceSchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "StartAt": "d",
      "Duration": toDuration,
      "CronExpressionForRecurrence": "s",
    },
  }, root);
}

function fromDuration(input?: s.Duration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Unit: input["Unit"],
  }
}
function toDuration(root: jsonP.JSONValue): s.Duration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "n",
      "Unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnit>(x),
    },
  }, root);
}

function fromDomainInformation(input?: s.DomainInformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OwnerId: input["OwnerId"],
    DomainName: input["DomainName"],
    Region: input["Region"],
  }
}
function toDomainInformation(root: jsonP.JSONValue): s.DomainInformation {
  return jsonP.readObj({
    required: {
      "DomainName": "s",
    },
    optional: {
      "OwnerId": "s",
      "Region": "s",
    },
  }, root);
}

function fromPackageSource(input?: s.PackageSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3BucketName: input["S3BucketName"],
    S3Key: input["S3Key"],
  }
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

function fromDescribePackagesFilter(input?: s.DescribePackagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}

function fromAutoTuneOptions(input?: s.AutoTuneOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DesiredState: input["DesiredState"],
    RollbackOnDisable: input["RollbackOnDisable"],
    MaintenanceSchedules: input["MaintenanceSchedules"]?.map(x => fromAutoTuneMaintenanceSchedule(x)),
  }
}
function toAutoTuneOptions(root: jsonP.JSONValue): s.AutoTuneOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "DesiredState": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoTuneDesiredState>(x),
      "RollbackOnDisable": (x: jsonP.JSONValue) => cmnP.readEnum<s.RollbackOnDisable>(x),
      "MaintenanceSchedules": [toAutoTuneMaintenanceSchedule],
    },
  }, root);
}

function toInboundCrossClusterSearchConnection(root: jsonP.JSONValue): s.InboundCrossClusterSearchConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceDomainInfo": toDomainInformation,
      "DestinationDomainInfo": toDomainInformation,
      "CrossClusterSearchConnectionId": "s",
      "ConnectionStatus": toInboundCrossClusterSearchConnectionStatus,
    },
  }, root);
}

function toInboundCrossClusterSearchConnectionStatus(root: jsonP.JSONValue): s.InboundCrossClusterSearchConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.InboundCrossClusterSearchConnectionStatusCode>(x),
      "Message": "s",
    },
  }, root);
}

function toDomainPackageDetails(root: jsonP.JSONValue): s.DomainPackageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageID": "s",
      "PackageName": "s",
      "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
      "LastUpdated": "d",
      "DomainName": "s",
      "DomainPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainPackageStatus>(x),
      "PackageVersion": "s",
      "ReferencePath": "s",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

function toErrorDetails(root: jsonP.JSONValue): s.ErrorDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorType": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toServiceSoftwareOptions(root: jsonP.JSONValue): s.ServiceSoftwareOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "CurrentVersion": "s",
      "NewVersion": "s",
      "UpdateAvailable": "b",
      "Cancellable": "b",
      "UpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeploymentStatus>(x),
      "Description": "s",
      "AutomatedUpdateDate": "d",
      "OptionalDeployment": "b",
    },
  }, root);
}

function toElasticsearchDomainStatus(root: jsonP.JSONValue): s.ElasticsearchDomainStatus {
  return jsonP.readObj({
    required: {
      "DomainId": "s",
      "DomainName": "s",
      "ARN": "s",
      "ElasticsearchClusterConfig": toElasticsearchClusterConfig,
    },
    optional: {
      "Created": "b",
      "Deleted": "b",
      "Endpoint": "s",
      "Endpoints": x => jsonP.readMap(String, String, x),
      "Processing": "b",
      "UpgradeProcessing": "b",
      "ElasticsearchVersion": "s",
      "EBSOptions": toEBSOptions,
      "AccessPolicies": "s",
      "SnapshotOptions": toSnapshotOptions,
      "VPCOptions": toVPCDerivedInfo,
      "CognitoOptions": toCognitoOptions,
      "EncryptionAtRestOptions": toEncryptionAtRestOptions,
      "NodeToNodeEncryptionOptions": toNodeToNodeEncryptionOptions,
      "AdvancedOptions": x => jsonP.readMap(String, String, x),
      "LogPublishingOptions": x => jsonP.readMap(x => cmnP.readEnumReq<s.LogType>(x), toLogPublishingOption, x),
      "ServiceSoftwareOptions": toServiceSoftwareOptions,
      "DomainEndpointOptions": toDomainEndpointOptions,
      "AdvancedSecurityOptions": toAdvancedSecurityOptions,
      "AutoTuneOptions": toAutoTuneOptionsOutput,
    },
  }, root);
}

function toVPCDerivedInfo(root: jsonP.JSONValue): s.VPCDerivedInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VPCId": "s",
      "SubnetIds": ["s"],
      "AvailabilityZones": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

function toAdvancedSecurityOptions(root: jsonP.JSONValue): s.AdvancedSecurityOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "InternalUserDatabaseEnabled": "b",
      "SAMLOptions": toSAMLOptionsOutput,
    },
  }, root);
}

function toSAMLOptionsOutput(root: jsonP.JSONValue): s.SAMLOptionsOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "Idp": toSAMLIdp,
      "SubjectKey": "s",
      "RolesKey": "s",
      "SessionTimeoutMinutes": "n",
    },
  }, root);
}

function toAutoTuneOptionsOutput(root: jsonP.JSONValue): s.AutoTuneOptionsOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoTuneState>(x),
      "ErrorMessage": "s",
    },
  }, root);
}

function toOutboundCrossClusterSearchConnectionStatus(root: jsonP.JSONValue): s.OutboundCrossClusterSearchConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.OutboundCrossClusterSearchConnectionStatusCode>(x),
      "Message": "s",
    },
  }, root);
}

function toPackageDetails(root: jsonP.JSONValue): s.PackageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageID": "s",
      "PackageName": "s",
      "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
      "PackageDescription": "s",
      "PackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageStatus>(x),
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "AvailablePackageVersion": "s",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

function toOutboundCrossClusterSearchConnection(root: jsonP.JSONValue): s.OutboundCrossClusterSearchConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceDomainInfo": toDomainInformation,
      "DestinationDomainInfo": toDomainInformation,
      "CrossClusterSearchConnectionId": "s",
      "ConnectionAlias": "s",
      "ConnectionStatus": toOutboundCrossClusterSearchConnectionStatus,
    },
  }, root);
}

function toAutoTune(root: jsonP.JSONValue): s.AutoTune {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutoTuneType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoTuneType>(x),
      "AutoTuneDetails": toAutoTuneDetails,
    },
  }, root);
}

function toAutoTuneDetails(root: jsonP.JSONValue): s.AutoTuneDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScheduledAutoTuneDetails": toScheduledAutoTuneDetails,
    },
  }, root);
}

function toScheduledAutoTuneDetails(root: jsonP.JSONValue): s.ScheduledAutoTuneDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Date": "d",
      "ActionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduledAutoTuneActionType>(x),
      "Action": "s",
      "Severity": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduledAutoTuneSeverityType>(x),
    },
  }, root);
}

function toElasticsearchDomainConfig(root: jsonP.JSONValue): s.ElasticsearchDomainConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ElasticsearchVersion": toElasticsearchVersionStatus,
      "ElasticsearchClusterConfig": toElasticsearchClusterConfigStatus,
      "EBSOptions": toEBSOptionsStatus,
      "AccessPolicies": toAccessPoliciesStatus,
      "SnapshotOptions": toSnapshotOptionsStatus,
      "VPCOptions": toVPCDerivedInfoStatus,
      "CognitoOptions": toCognitoOptionsStatus,
      "EncryptionAtRestOptions": toEncryptionAtRestOptionsStatus,
      "NodeToNodeEncryptionOptions": toNodeToNodeEncryptionOptionsStatus,
      "AdvancedOptions": toAdvancedOptionsStatus,
      "LogPublishingOptions": toLogPublishingOptionsStatus,
      "DomainEndpointOptions": toDomainEndpointOptionsStatus,
      "AdvancedSecurityOptions": toAdvancedSecurityOptionsStatus,
      "AutoTuneOptions": toAutoTuneOptionsStatus,
    },
  }, root);
}

function toElasticsearchVersionStatus(root: jsonP.JSONValue): s.ElasticsearchVersionStatus {
  return jsonP.readObj({
    required: {
      "Options": "s",
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toOptionStatus(root: jsonP.JSONValue): s.OptionStatus {
  return jsonP.readObj({
    required: {
      "CreationDate": "d",
      "UpdateDate": "d",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.OptionState>(x),
    },
    optional: {
      "UpdateVersion": "n",
      "PendingDeletion": "b",
    },
  }, root);
}

function toElasticsearchClusterConfigStatus(root: jsonP.JSONValue): s.ElasticsearchClusterConfigStatus {
  return jsonP.readObj({
    required: {
      "Options": toElasticsearchClusterConfig,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toEBSOptionsStatus(root: jsonP.JSONValue): s.EBSOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toEBSOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toAccessPoliciesStatus(root: jsonP.JSONValue): s.AccessPoliciesStatus {
  return jsonP.readObj({
    required: {
      "Options": "s",
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toSnapshotOptionsStatus(root: jsonP.JSONValue): s.SnapshotOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toSnapshotOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toVPCDerivedInfoStatus(root: jsonP.JSONValue): s.VPCDerivedInfoStatus {
  return jsonP.readObj({
    required: {
      "Options": toVPCDerivedInfo,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toCognitoOptionsStatus(root: jsonP.JSONValue): s.CognitoOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toCognitoOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toEncryptionAtRestOptionsStatus(root: jsonP.JSONValue): s.EncryptionAtRestOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toEncryptionAtRestOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toNodeToNodeEncryptionOptionsStatus(root: jsonP.JSONValue): s.NodeToNodeEncryptionOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toNodeToNodeEncryptionOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toAdvancedOptionsStatus(root: jsonP.JSONValue): s.AdvancedOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": x => jsonP.readMap(String, String, x),
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toLogPublishingOptionsStatus(root: jsonP.JSONValue): s.LogPublishingOptionsStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Options": x => jsonP.readMap(x => cmnP.readEnumReq<s.LogType>(x), toLogPublishingOption, x),
      "Status": toOptionStatus,
    },
  }, root);
}

function toDomainEndpointOptionsStatus(root: jsonP.JSONValue): s.DomainEndpointOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toDomainEndpointOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toAdvancedSecurityOptionsStatus(root: jsonP.JSONValue): s.AdvancedSecurityOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toAdvancedSecurityOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

function toAutoTuneOptionsStatus(root: jsonP.JSONValue): s.AutoTuneOptionsStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Options": toAutoTuneOptions,
      "Status": toAutoTuneStatus,
    },
  }, root);
}

function toAutoTuneStatus(root: jsonP.JSONValue): s.AutoTuneStatus {
  return jsonP.readObj({
    required: {
      "CreationDate": "d",
      "UpdateDate": "d",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoTuneState>(x),
    },
    optional: {
      "UpdateVersion": "n",
      "ErrorMessage": "s",
      "PendingDeletion": "b",
    },
  }, root);
}

function toLimits(root: jsonP.JSONValue): s.Limits {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageTypes": [toStorageType],
      "InstanceLimits": toInstanceLimits,
      "AdditionalLimits": [toAdditionalLimit],
    },
  }, root);
}

function toStorageType(root: jsonP.JSONValue): s.StorageType {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageTypeName": "s",
      "StorageSubTypeName": "s",
      "StorageTypeLimits": [toStorageTypeLimit],
    },
  }, root);
}

function toStorageTypeLimit(root: jsonP.JSONValue): s.StorageTypeLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "LimitName": "s",
      "LimitValues": ["s"],
    },
  }, root);
}

function toInstanceLimits(root: jsonP.JSONValue): s.InstanceLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceCountLimits": toInstanceCountLimits,
    },
  }, root);
}

function toInstanceCountLimits(root: jsonP.JSONValue): s.InstanceCountLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinimumInstanceCount": "n",
      "MaximumInstanceCount": "n",
    },
  }, root);
}

function toAdditionalLimit(root: jsonP.JSONValue): s.AdditionalLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "LimitName": "s",
      "LimitValues": ["s"],
    },
  }, root);
}

function toReservedElasticsearchInstanceOffering(root: jsonP.JSONValue): s.ReservedElasticsearchInstanceOffering {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservedElasticsearchInstanceOfferingId": "s",
      "ElasticsearchInstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ESPartitionInstanceType>(x),
      "Duration": "n",
      "FixedPrice": "n",
      "UsagePrice": "n",
      "CurrencyCode": "s",
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservedElasticsearchInstancePaymentOption>(x),
      "RecurringCharges": [toRecurringCharge],
    },
  }, root);
}

function toRecurringCharge(root: jsonP.JSONValue): s.RecurringCharge {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecurringChargeAmount": "n",
      "RecurringChargeFrequency": "s",
    },
  }, root);
}

function toReservedElasticsearchInstance(root: jsonP.JSONValue): s.ReservedElasticsearchInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservationName": "s",
      "ReservedElasticsearchInstanceId": "s",
      "ReservedElasticsearchInstanceOfferingId": "s",
      "ElasticsearchInstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ESPartitionInstanceType>(x),
      "StartTime": "d",
      "Duration": "n",
      "FixedPrice": "n",
      "UsagePrice": "n",
      "CurrencyCode": "s",
      "ElasticsearchInstanceCount": "n",
      "State": "s",
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservedElasticsearchInstancePaymentOption>(x),
      "RecurringCharges": [toRecurringCharge],
    },
  }, root);
}

function toCompatibleVersionsMap(root: jsonP.JSONValue): s.CompatibleVersionsMap {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceVersion": "s",
      "TargetVersions": ["s"],
    },
  }, root);
}

function toPackageVersionHistory(root: jsonP.JSONValue): s.PackageVersionHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageVersion": "s",
      "CommitMessage": "s",
      "CreatedAt": "d",
    },
  }, root);
}

function toUpgradeHistory(root: jsonP.JSONValue): s.UpgradeHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpgradeName": "s",
      "StartTimestamp": "d",
      "UpgradeStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpgradeStatus>(x),
      "StepsList": [toUpgradeStepItem],
    },
  }, root);
}

function toUpgradeStepItem(root: jsonP.JSONValue): s.UpgradeStepItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpgradeStep": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpgradeStep>(x),
      "UpgradeStepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpgradeStatus>(x),
      "Issues": ["s"],
      "ProgressPercent": "n",
    },
  }, root);
}

function toDomainInfo(root: jsonP.JSONValue): s.DomainInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainName": "s",
    },
  }, root);
}
