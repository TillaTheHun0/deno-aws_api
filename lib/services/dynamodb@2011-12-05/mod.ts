// Autogenerated API client for: Amazon DynamoDB

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class DynamoDB {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DynamoDB.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2011-12-05",
    "endpointPrefix": "dynamodb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "DynamoDB",
    "serviceFullName": "Amazon DynamoDB",
    "serviceId": "DynamoDB",
    "signatureVersion": "v4",
    "targetPrefix": "DynamoDB_20111205",
    "uid": "dynamodb-2011-12-05"
  };

  async batchGetItem(
    {abortSignal, ...params}: RequestConfig & s.BatchGetItemInput,
  ): Promise<s.BatchGetItemOutput> {
    const body: jsonP.JSONObject = {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => fromKeysAndAttributes(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, toBatchResponse, x),
        "UnprocessedKeys": x => jsonP.readMap(String, toKeysAndAttributes, x),
      },
    }, await resp.json());
  }

  async batchWriteItem(
    {abortSignal, ...params}: RequestConfig & s.BatchWriteItemInput,
  ): Promise<s.BatchWriteItemOutput> {
    const body: jsonP.JSONObject = {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => x?.map(fromWriteRequest)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchWriteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, toBatchWriteResponse, x),
        "UnprocessedItems": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toWriteRequest) : [], x),
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & s.CreateTableInput,
  ): Promise<s.CreateTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      KeySchema: fromKeySchema(params["KeySchema"]),
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async deleteItem(
    {abortSignal, ...params}: RequestConfig & s.DeleteItemInput,
  ): Promise<s.DeleteItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteTableInput,
  ): Promise<s.DeleteTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async describeTable(
    {abortSignal, ...params}: RequestConfig & s.DescribeTableInput,
  ): Promise<s.DescribeTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTableDescription,
      },
    }, await resp.json());
  }

  async getItem(
    {abortSignal, ...params}: RequestConfig & s.GetItemInput,
  ): Promise<s.GetItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      AttributesToGet: params["AttributesToGet"],
      ConsistentRead: params["ConsistentRead"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Item": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & s.ListTablesInput = {},
  ): Promise<s.ListTablesOutput> {
    const body: jsonP.JSONObject = {
      ExclusiveStartTableName: params["ExclusiveStartTableName"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableNames": ["s"],
        "LastEvaluatedTableName": "s",
      },
    }, await resp.json());
  }

  async putItem(
    {abortSignal, ...params}: RequestConfig & s.PutItemInput,
  ): Promise<s.PutItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Item: jsonP.serializeMap(params["Item"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & s.QueryInput,
  ): Promise<s.QueryOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      ConsistentRead: params["ConsistentRead"],
      Count: params["Count"],
      HashKeyValue: fromAttributeValue(params["HashKeyValue"]),
      RangeKeyCondition: fromCondition(params["RangeKeyCondition"]),
      ScanIndexForward: params["ScanIndexForward"],
      ExclusiveStartKey: fromKey(params["ExclusiveStartKey"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "LastEvaluatedKey": toKey,
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async scan(
    {abortSignal, ...params}: RequestConfig & s.ScanInput,
  ): Promise<s.ScanOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      Count: params["Count"],
      ScanFilter: jsonP.serializeMap(params["ScanFilter"], x => fromCondition(x)),
      ExclusiveStartKey: fromKey(params["ExclusiveStartKey"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Scan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": toKey,
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async updateItem(
    {abortSignal, ...params}: RequestConfig & s.UpdateItemInput,
  ): Promise<s.UpdateItemOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      AttributeUpdates: jsonP.serializeMap(params["AttributeUpdates"], x => fromAttributeValueUpdate(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & s.UpdateTableInput,
  ): Promise<s.UpdateTableOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableExists(
    params: RequestConfig & s.DescribeTableInput,
  ): Promise<s.DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
        if (resp?.Table?.TableStatus === "ACTIVE") return resp;
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableNotExists(
    params: RequestConfig & s.DescribeTableInput,
  ): Promise<Error | s.DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableNotExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

function fromKeysAndAttributes(input?: s.KeysAndAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"]?.map(x => fromKey(x)),
    AttributesToGet: input["AttributesToGet"],
    ConsistentRead: input["ConsistentRead"],
  }
}
function toKeysAndAttributes(root: jsonP.JSONValue): s.KeysAndAttributes {
  return jsonP.readObj({
    required: {
      "Keys": [toKey],
    },
    optional: {
      "AttributesToGet": ["s"],
      "ConsistentRead": "b",
    },
  }, root);
}

function fromKey(input?: s.Key | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HashKeyElement: fromAttributeValue(input["HashKeyElement"]),
    RangeKeyElement: fromAttributeValue(input["RangeKeyElement"]),
  }
}
function toKey(root: jsonP.JSONValue): s.Key {
  return jsonP.readObj({
    required: {
      "HashKeyElement": toAttributeValue,
    },
    optional: {
      "RangeKeyElement": toAttributeValue,
    },
  }, root);
}

function fromAttributeValue(input?: s.AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    B: serializeBlob(input["B"]),
    SS: input["SS"],
    NS: input["NS"],
    BS: input["BS"]?.map(x => serializeBlob(x)),
  }
}
function toAttributeValue(root: jsonP.JSONValue): s.AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "s",
      "B": "a",
      "SS": ["s"],
      "NS": ["s"],
      "BS": ["a"],
    },
  }, root);
}

function fromWriteRequest(input?: s.WriteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PutRequest: fromPutRequest(input["PutRequest"]),
    DeleteRequest: fromDeleteRequest(input["DeleteRequest"]),
  }
}
function toWriteRequest(root: jsonP.JSONValue): s.WriteRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "PutRequest": toPutRequest,
      "DeleteRequest": toDeleteRequest,
    },
  }, root);
}

function fromPutRequest(input?: s.PutRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
  }
}
function toPutRequest(root: jsonP.JSONValue): s.PutRequest {
  return jsonP.readObj({
    required: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

function fromDeleteRequest(input?: s.DeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: fromKey(input["Key"]),
  }
}
function toDeleteRequest(root: jsonP.JSONValue): s.DeleteRequest {
  return jsonP.readObj({
    required: {
      "Key": toKey,
    },
    optional: {},
  }, root);
}

function fromKeySchema(input?: s.KeySchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HashKeyElement: fromKeySchemaElement(input["HashKeyElement"]),
    RangeKeyElement: fromKeySchemaElement(input["RangeKeyElement"]),
  }
}
function toKeySchema(root: jsonP.JSONValue): s.KeySchema {
  return jsonP.readObj({
    required: {
      "HashKeyElement": toKeySchemaElement,
    },
    optional: {
      "RangeKeyElement": toKeySchemaElement,
    },
  }, root);
}

function fromKeySchemaElement(input?: s.KeySchemaElement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toKeySchemaElement(root: jsonP.JSONValue): s.KeySchemaElement {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalarAttributeType>(x),
    },
    optional: {},
  }, root);
}

function fromProvisionedThroughput(input?: s.ProvisionedThroughput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
    WriteCapacityUnits: input["WriteCapacityUnits"],
  }
}

function fromExpectedAttributeValue(input?: s.ExpectedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Exists: input["Exists"],
  }
}

function fromCondition(input?: s.Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
    ComparisonOperator: input["ComparisonOperator"],
  }
}

function fromAttributeValueUpdate(input?: s.AttributeValueUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Action: input["Action"],
  }
}

function toBatchResponse(root: jsonP.JSONValue): s.BatchResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
      "ConsumedCapacityUnits": "n",
    },
  }, root);
}

function toBatchWriteResponse(root: jsonP.JSONValue): s.BatchWriteResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConsumedCapacityUnits": "n",
    },
  }, root);
}

function toTableDescription(root: jsonP.JSONValue): s.TableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "KeySchema": toKeySchema,
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TableStatus>(x),
      "CreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "TableSizeBytes": "n",
      "ItemCount": "n",
    },
  }, root);
}

function toProvisionedThroughputDescription(root: jsonP.JSONValue): s.ProvisionedThroughputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastIncreaseDateTime": "d",
      "LastDecreaseDateTime": "d",
      "NumberOfDecreasesToday": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
  }, root);
}
