// Autogenerated API client for: Amazon DynamoDB

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class DynamoDB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DynamoDB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2011-12-05",
    "endpointPrefix": "dynamodb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "DynamoDB",
    "serviceFullName": "Amazon DynamoDB",
    "serviceId": "DynamoDB",
    "signatureVersion": "v4",
    "targetPrefix": "DynamoDB_20111205",
    "uid": "dynamodb-2011-12-05"
  };

  async batchGetItem(
    {abortSignal, ...params}: RequestConfig & BatchGetItemInput,
  ): Promise<BatchGetItemOutput> {
    const body: jsonP.JSONObject = params ? {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => fromKeysAndAttributes(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, toBatchResponse, x),
        "UnprocessedKeys": x => jsonP.readMap(String, toKeysAndAttributes, x),
      },
    }, await resp.json());
  }

  async batchWriteItem(
    {abortSignal, ...params}: RequestConfig & BatchWriteItemInput,
  ): Promise<BatchWriteItemOutput> {
    const body: jsonP.JSONObject = params ? {
      RequestItems: jsonP.serializeMap(params["RequestItems"], x => x?.map(fromWriteRequest)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchWriteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Responses": x => jsonP.readMap(String, toBatchWriteResponse, x),
        "UnprocessedItems": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toWriteRequest) : [], x),
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & CreateTableInput,
  ): Promise<CreateTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      KeySchema: fromKeySchema(params["KeySchema"]),
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async deleteItem(
    {abortSignal, ...params}: RequestConfig & DeleteItemInput,
  ): Promise<DeleteItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & DeleteTableInput,
  ): Promise<DeleteTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  async describeTable(
    {abortSignal, ...params}: RequestConfig & DescribeTableInput,
  ): Promise<DescribeTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTableDescription,
      },
    }, await resp.json());
  }

  async getItem(
    {abortSignal, ...params}: RequestConfig & GetItemInput,
  ): Promise<GetItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      AttributesToGet: params["AttributesToGet"],
      ConsistentRead: params["ConsistentRead"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Item": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & ListTablesInput = {},
  ): Promise<ListTablesOutput> {
    const body: jsonP.JSONObject = params ? {
      ExclusiveStartTableName: params["ExclusiveStartTableName"],
      Limit: params["Limit"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableNames": ["s"],
        "LastEvaluatedTableName": "s",
      },
    }, await resp.json());
  }

  async putItem(
    {abortSignal, ...params}: RequestConfig & PutItemInput,
  ): Promise<PutItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Item: jsonP.serializeMap(params["Item"], x => fromAttributeValue(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & QueryInput,
  ): Promise<QueryOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      ConsistentRead: params["ConsistentRead"],
      Count: params["Count"],
      HashKeyValue: fromAttributeValue(params["HashKeyValue"]),
      RangeKeyCondition: fromCondition(params["RangeKeyCondition"]),
      ScanIndexForward: params["ScanIndexForward"],
      ExclusiveStartKey: fromKey(params["ExclusiveStartKey"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "LastEvaluatedKey": toKey,
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async scan(
    {abortSignal, ...params}: RequestConfig & ScanInput,
  ): Promise<ScanOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      AttributesToGet: params["AttributesToGet"],
      Limit: params["Limit"],
      Count: params["Count"],
      ScanFilter: jsonP.serializeMap(params["ScanFilter"], x => fromCondition(x)),
      ExclusiveStartKey: fromKey(params["ExclusiveStartKey"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Scan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
        "Count": "n",
        "ScannedCount": "n",
        "LastEvaluatedKey": toKey,
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async updateItem(
    {abortSignal, ...params}: RequestConfig & UpdateItemInput,
  ): Promise<UpdateItemOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      Key: fromKey(params["Key"]),
      AttributeUpdates: jsonP.serializeMap(params["AttributeUpdates"], x => fromAttributeValueUpdate(x)),
      Expected: jsonP.serializeMap(params["Expected"], x => fromExpectedAttributeValue(x)),
      ReturnValues: params["ReturnValues"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateItem",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(String, toAttributeValue, x),
        "ConsumedCapacityUnits": "n",
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & UpdateTableInput,
  ): Promise<UpdateTableOutput> {
    const body: jsonP.JSONObject = params ? {
      TableName: params["TableName"],
      ProvisionedThroughput: fromProvisionedThroughput(params["ProvisionedThroughput"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableDescription": toTableDescription,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableExists(
    params: RequestConfig & DescribeTableInput,
  ): Promise<DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
        if (resp?.Table?.TableStatus === "ACTIVE") return resp;
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForTableNotExists(
    params: RequestConfig & DescribeTableInput,
  ): Promise<Error | DescribeTableOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TableNotExists';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeTable(params);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface BatchGetItemInput {
  RequestItems: { [key: string]: KeysAndAttributes | null | undefined };
}

// refs: 1 - tags: named, input
export interface BatchWriteItemInput {
  RequestItems: { [key: string]: WriteRequest[] | null | undefined };
}

// refs: 1 - tags: named, input
export interface CreateTableInput {
  TableName: string;
  KeySchema: KeySchema;
  ProvisionedThroughput: ProvisionedThroughput;
}

// refs: 1 - tags: named, input
export interface DeleteItemInput {
  TableName: string;
  Key: Key;
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ReturnValues?: ReturnValue | null;
}

// refs: 1 - tags: named, input
export interface DeleteTableInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTableInput {
  TableName: string;
}

// refs: 1 - tags: named, input
export interface GetItemInput {
  TableName: string;
  Key: Key;
  AttributesToGet?: string[] | null;
  ConsistentRead?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ListTablesInput {
  ExclusiveStartTableName?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface PutItemInput {
  TableName: string;
  Item: { [key: string]: AttributeValue | null | undefined };
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ReturnValues?: ReturnValue | null;
}

// refs: 1 - tags: named, input
export interface QueryInput {
  TableName: string;
  AttributesToGet?: string[] | null;
  Limit?: number | null;
  ConsistentRead?: boolean | null;
  Count?: boolean | null;
  HashKeyValue: AttributeValue;
  RangeKeyCondition?: Condition | null;
  ScanIndexForward?: boolean | null;
  ExclusiveStartKey?: Key | null;
}

// refs: 1 - tags: named, input
export interface ScanInput {
  TableName: string;
  AttributesToGet?: string[] | null;
  Limit?: number | null;
  Count?: boolean | null;
  ScanFilter?: { [key: string]: Condition | null | undefined } | null;
  ExclusiveStartKey?: Key | null;
}

// refs: 1 - tags: named, input
export interface UpdateItemInput {
  TableName: string;
  Key: Key;
  AttributeUpdates: { [key: string]: AttributeValueUpdate | null | undefined };
  Expected?: { [key: string]: ExpectedAttributeValue | null | undefined } | null;
  ReturnValues?: ReturnValue | null;
}

// refs: 1 - tags: named, input
export interface UpdateTableInput {
  TableName: string;
  ProvisionedThroughput: ProvisionedThroughput;
}

// refs: 1 - tags: named, output
export interface BatchGetItemOutput {
  Responses?: { [key: string]: BatchResponse | null | undefined } | null;
  UnprocessedKeys?: { [key: string]: KeysAndAttributes | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface BatchWriteItemOutput {
  Responses?: { [key: string]: BatchWriteResponse | null | undefined } | null;
  UnprocessedItems?: { [key: string]: WriteRequest[] | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface DeleteTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribeTableOutput {
  Table?: TableDescription | null;
}

// refs: 1 - tags: named, output
export interface GetItemOutput {
  Item?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface ListTablesOutput {
  TableNames?: string[] | null;
  LastEvaluatedTableName?: string | null;
}

// refs: 1 - tags: named, output
export interface PutItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface QueryOutput {
  Items?: ({ [key: string]: AttributeValue | null | undefined })[] | null;
  Count?: number | null;
  LastEvaluatedKey?: Key | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface ScanOutput {
  Items?: ({ [key: string]: AttributeValue | null | undefined })[] | null;
  Count?: number | null;
  ScannedCount?: number | null;
  LastEvaluatedKey?: Key | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface UpdateItemOutput {
  Attributes?: { [key: string]: AttributeValue | null | undefined } | null;
  ConsumedCapacityUnits?: number | null;
}

// refs: 1 - tags: named, output
export interface UpdateTableOutput {
  TableDescription?: TableDescription | null;
}

// refs: 2 - tags: input, named, interface, output
export interface KeysAndAttributes {
  Keys: Key[];
  AttributesToGet?: string[] | null;
  ConsistentRead?: boolean | null;
}
function fromKeysAndAttributes(input?: KeysAndAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"]?.map(x => fromKey(x)),
    AttributesToGet: input["AttributesToGet"],
    ConsistentRead: input["ConsistentRead"],
  }
}
function toKeysAndAttributes(root: jsonP.JSONValue): KeysAndAttributes {
  return jsonP.readObj({
    required: {
      "Keys": [toKey],
    },
    optional: {
      "AttributesToGet": ["s"],
      "ConsistentRead": "b",
    },
  }, root);
}

// refs: 11 - tags: input, named, interface, output
export interface Key {
  HashKeyElement: AttributeValue;
  RangeKeyElement?: AttributeValue | null;
}
function fromKey(input?: Key | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HashKeyElement: fromAttributeValue(input["HashKeyElement"]),
    RangeKeyElement: fromAttributeValue(input["RangeKeyElement"]),
  }
}
function toKey(root: jsonP.JSONValue): Key {
  return jsonP.readObj({
    required: {
      "HashKeyElement": toAttributeValue,
    },
    optional: {
      "RangeKeyElement": toAttributeValue,
    },
  }, root);
}

// refs: 39 - tags: input, named, interface, output
export interface AttributeValue {
  S?: string | null;
  N?: string | null;
  B?: Uint8Array | string | null;
  SS?: string[] | null;
  NS?: string[] | null;
  BS?: (Uint8Array | string)[] | null;
}
function fromAttributeValue(input?: AttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S: input["S"],
    N: input["N"],
    B: jsonP.serializeBlob(input["B"]),
    SS: input["SS"],
    NS: input["NS"],
    BS: input["BS"]?.map(x => jsonP.serializeBlob(x)),
  }
}
function toAttributeValue(root: jsonP.JSONValue): AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "s",
      "B": "a",
      "SS": ["s"],
      "NS": ["s"],
      "BS": ["a"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface WriteRequest {
  PutRequest?: PutRequest | null;
  DeleteRequest?: DeleteRequest | null;
}
function fromWriteRequest(input?: WriteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PutRequest: fromPutRequest(input["PutRequest"]),
    DeleteRequest: fromDeleteRequest(input["DeleteRequest"]),
  }
}
function toWriteRequest(root: jsonP.JSONValue): WriteRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "PutRequest": toPutRequest,
      "DeleteRequest": toDeleteRequest,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PutRequest {
  Item: { [key: string]: AttributeValue | null | undefined };
}
function fromPutRequest(input?: PutRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: jsonP.serializeMap(input["Item"], x => fromAttributeValue(x)),
  }
}
function toPutRequest(root: jsonP.JSONValue): PutRequest {
  return jsonP.readObj({
    required: {
      "Item": x => jsonP.readMap(String, toAttributeValue, x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface DeleteRequest {
  Key: Key;
}
function fromDeleteRequest(input?: DeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: fromKey(input["Key"]),
  }
}
function toDeleteRequest(root: jsonP.JSONValue): DeleteRequest {
  return jsonP.readObj({
    required: {
      "Key": toKey,
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface KeySchema {
  HashKeyElement: KeySchemaElement;
  RangeKeyElement?: KeySchemaElement | null;
}
function fromKeySchema(input?: KeySchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HashKeyElement: fromKeySchemaElement(input["HashKeyElement"]),
    RangeKeyElement: fromKeySchemaElement(input["RangeKeyElement"]),
  }
}
function toKeySchema(root: jsonP.JSONValue): KeySchema {
  return jsonP.readObj({
    required: {
      "HashKeyElement": toKeySchemaElement,
    },
    optional: {
      "RangeKeyElement": toKeySchemaElement,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface KeySchemaElement {
  AttributeName: string;
  AttributeType: ScalarAttributeType;
}
function fromKeySchemaElement(input?: KeySchemaElement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toKeySchemaElement(root: jsonP.JSONValue): KeySchemaElement {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<ScalarAttributeType>(x),
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type ScalarAttributeType =
| "S"
| "N"
| "B"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ProvisionedThroughput {
  ReadCapacityUnits: number;
  WriteCapacityUnits: number;
}
function fromProvisionedThroughput(input?: ProvisionedThroughput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
    WriteCapacityUnits: input["WriteCapacityUnits"],
  }
}

// refs: 3 - tags: input, named, interface
export interface ExpectedAttributeValue {
  Value?: AttributeValue | null;
  Exists?: boolean | null;
}
function fromExpectedAttributeValue(input?: ExpectedAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Exists: input["Exists"],
  }
}

// refs: 3 - tags: input, named, enum
export type ReturnValue =
| "NONE"
| "ALL_OLD"
| "UPDATED_OLD"
| "ALL_NEW"
| "UPDATED_NEW"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface Condition {
  AttributeValueList?: AttributeValue[] | null;
  ComparisonOperator: ComparisonOperator;
}
function fromCondition(input?: Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeValueList: input["AttributeValueList"]?.map(x => fromAttributeValue(x)),
    ComparisonOperator: input["ComparisonOperator"],
  }
}

// refs: 2 - tags: input, named, enum
export type ComparisonOperator =
| "EQ"
| "NE"
| "IN"
| "LE"
| "LT"
| "GE"
| "GT"
| "BETWEEN"
| "NOT_NULL"
| "NULL"
| "CONTAINS"
| "NOT_CONTAINS"
| "BEGINS_WITH"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface AttributeValueUpdate {
  Value?: AttributeValue | null;
  Action?: AttributeAction | null;
}
function fromAttributeValueUpdate(input?: AttributeValueUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: fromAttributeValue(input["Value"]),
    Action: input["Action"],
  }
}

// refs: 1 - tags: input, named, enum
export type AttributeAction =
| "ADD"
| "PUT"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BatchResponse {
  Items?: ({ [key: string]: AttributeValue | null | undefined })[] | null;
  ConsumedCapacityUnits?: number | null;
}
function toBatchResponse(root: jsonP.JSONValue): BatchResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": [x => jsonP.readMap(String, toAttributeValue, x)],
      "ConsumedCapacityUnits": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchWriteResponse {
  ConsumedCapacityUnits?: number | null;
}
function toBatchWriteResponse(root: jsonP.JSONValue): BatchWriteResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConsumedCapacityUnits": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface TableDescription {
  TableName?: string | null;
  KeySchema?: KeySchema | null;
  TableStatus?: TableStatus | null;
  CreationDateTime?: Date | number | null;
  ProvisionedThroughput?: ProvisionedThroughputDescription | null;
  TableSizeBytes?: number | null;
  ItemCount?: number | null;
}
function toTableDescription(root: jsonP.JSONValue): TableDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "KeySchema": toKeySchema,
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TableStatus>(x),
      "CreationDateTime": "d",
      "ProvisionedThroughput": toProvisionedThroughputDescription,
      "TableSizeBytes": "n",
      "ItemCount": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type TableStatus =
| "CREATING"
| "UPDATING"
| "DELETING"
| "ACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface ProvisionedThroughputDescription {
  LastIncreaseDateTime?: Date | number | null;
  LastDecreaseDateTime?: Date | number | null;
  NumberOfDecreasesToday?: number | null;
  ReadCapacityUnits?: number | null;
  WriteCapacityUnits?: number | null;
}
function toProvisionedThroughputDescription(root: jsonP.JSONValue): ProvisionedThroughputDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastIncreaseDateTime": "d",
      "LastDecreaseDateTime": "d",
      "NumberOfDecreasesToday": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
  }, root);
}
