// Autogenerated API client for: Amazon Timestream Query

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.91.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class TimestreamQuery {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(TimestreamQuery.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-11-01",
    "endpointPrefix": "query.timestream",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "Timestream Query",
    "serviceFullName": "Amazon Timestream Query",
    "serviceId": "Timestream Query",
    "signatureVersion": "v4",
    "signingName": "timestream",
    "targetPrefix": "Timestream_20181101",
    "uid": "timestream-query-2018-11-01"
  };

  async cancelQuery(
    {abortSignal, ...params}: RequestConfig & s.CancelQueryRequest,
  ): Promise<s.CancelQueryResponse> {
    const body: jsonP.JSONObject = {
      QueryId: params["QueryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelQuery",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CancellationMessage": "s",
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpoint],
      },
      optional: {},
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & s.QueryRequest,
  ): Promise<s.QueryResponse> {
    const body: jsonP.JSONObject = {
      QueryString: params["QueryString"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      NextToken: params["NextToken"],
      MaxRows: params["MaxRows"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return jsonP.readObj({
      required: {
        "QueryId": "s",
        "Rows": [toRow],
        "ColumnInfo": [toColumnInfo],
      },
      optional: {
        "NextToken": "s",
        "QueryStatus": toQueryStatus,
      },
    }, await resp.json());
  }

}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {
      "Address": "s",
      "CachePeriodInMinutes": "n",
    },
    optional: {},
  }, root);
}

function toRow(root: jsonP.JSONValue): s.Row {
  return jsonP.readObj({
    required: {
      "Data": [toDatum],
    },
    optional: {},
  }, root);
}

function toDatum(root: jsonP.JSONValue): s.Datum {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScalarValue": "s",
      "TimeSeriesValue": [toTimeSeriesDataPoint],
      "ArrayValue": [toDatum],
      "RowValue": toRow,
      "NullValue": "b",
    },
  }, root);
}

function toTimeSeriesDataPoint(root: jsonP.JSONValue): s.TimeSeriesDataPoint {
  return jsonP.readObj({
    required: {
      "Time": "s",
      "Value": toDatum,
    },
    optional: {},
  }, root);
}

function toColumnInfo(root: jsonP.JSONValue): s.ColumnInfo {
  return jsonP.readObj({
    required: {
      "Type": toType,
    },
    optional: {
      "Name": "s",
    },
  }, root);
}

function toType(root: jsonP.JSONValue): s.Type {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScalarType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScalarType>(x),
      "ArrayColumnInfo": toColumnInfo,
      "TimeSeriesMeasureValueColumnInfo": toColumnInfo,
      "RowColumnInfo": [toColumnInfo],
    },
  }, root);
}

function toQueryStatus(root: jsonP.JSONValue): s.QueryStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProgressPercentage": "n",
      "CumulativeBytesScanned": "n",
      "CumulativeBytesMetered": "n",
    },
  }, root);
}
