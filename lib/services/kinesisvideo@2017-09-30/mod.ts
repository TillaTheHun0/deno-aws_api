// Autogenerated API client for: Amazon Kinesis Video Streams

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class KinesisVideo {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KinesisVideo.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-09-30",
    "endpointPrefix": "kinesisvideo",
    "protocol": "rest-json",
    "serviceAbbreviation": "Kinesis Video",
    "serviceFullName": "Amazon Kinesis Video Streams",
    "serviceId": "Kinesis Video",
    "signatureVersion": "v4",
    "uid": "kinesisvideo-2017-09-30"
  };

  async createSignalingChannel(
    {abortSignal, ...params}: RequestConfig & CreateSignalingChannelInput,
  ): Promise<CreateSignalingChannelOutput> {
    const body: jsonP.JSONObject = params ? {
      ChannelName: params["ChannelName"],
      ChannelType: params["ChannelType"],
      SingleMasterConfiguration: fromSingleMasterConfiguration(params["SingleMasterConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSignalingChannel",
      requestUri: "/createSignalingChannel",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ChannelARN": "s",
        },
      }, await resp.json()),
  };
  }

  async createStream(
    {abortSignal, ...params}: RequestConfig & CreateStreamInput,
  ): Promise<CreateStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      DeviceName: params["DeviceName"],
      StreamName: params["StreamName"],
      MediaType: params["MediaType"],
      KmsKeyId: params["KmsKeyId"],
      DataRetentionInHours: params["DataRetentionInHours"],
      Tags: params["Tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStream",
      requestUri: "/createStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StreamARN": "s",
        },
      }, await resp.json()),
  };
  }

  async deleteSignalingChannel(
    {abortSignal, ...params}: RequestConfig & DeleteSignalingChannelInput,
  ): Promise<DeleteSignalingChannelOutput> {
    const body: jsonP.JSONObject = params ? {
      ChannelARN: params["ChannelARN"],
      CurrentVersion: params["CurrentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSignalingChannel",
      requestUri: "/deleteSignalingChannel",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async deleteStream(
    {abortSignal, ...params}: RequestConfig & DeleteStreamInput,
  ): Promise<DeleteStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamARN: params["StreamARN"],
      CurrentVersion: params["CurrentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStream",
      requestUri: "/deleteStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async describeSignalingChannel(
    {abortSignal, ...params}: RequestConfig & DescribeSignalingChannelInput = {},
  ): Promise<DescribeSignalingChannelOutput> {
    const body: jsonP.JSONObject = params ? {
      ChannelName: params["ChannelName"],
      ChannelARN: params["ChannelARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSignalingChannel",
      requestUri: "/describeSignalingChannel",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ChannelInfo": toChannelInfo,
        },
      }, await resp.json()),
  };
  }

  async describeStream(
    {abortSignal, ...params}: RequestConfig & DescribeStreamInput = {},
  ): Promise<DescribeStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStream",
      requestUri: "/describeStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StreamInfo": toStreamInfo,
        },
      }, await resp.json()),
  };
  }

  async getDataEndpoint(
    {abortSignal, ...params}: RequestConfig & GetDataEndpointInput,
  ): Promise<GetDataEndpointOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      APIName: params["APIName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataEndpoint",
      requestUri: "/getDataEndpoint",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "DataEndpoint": "s",
        },
      }, await resp.json()),
  };
  }

  async getSignalingChannelEndpoint(
    {abortSignal, ...params}: RequestConfig & GetSignalingChannelEndpointInput,
  ): Promise<GetSignalingChannelEndpointOutput> {
    const body: jsonP.JSONObject = params ? {
      ChannelARN: params["ChannelARN"],
      SingleMasterChannelEndpointConfiguration: fromSingleMasterChannelEndpointConfiguration(params["SingleMasterChannelEndpointConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSignalingChannelEndpoint",
      requestUri: "/getSignalingChannelEndpoint",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ResourceEndpointList": [toResourceEndpointListItem],
        },
      }, await resp.json()),
  };
  }

  async listSignalingChannels(
    {abortSignal, ...params}: RequestConfig & ListSignalingChannelsInput = {},
  ): Promise<ListSignalingChannelsOutput> {
    const body: jsonP.JSONObject = params ? {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      ChannelNameCondition: fromChannelNameCondition(params["ChannelNameCondition"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSignalingChannels",
      requestUri: "/listSignalingChannels",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "ChannelInfoList": [toChannelInfo],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & ListStreamsInput = {},
  ): Promise<ListStreamsOutput> {
    const body: jsonP.JSONObject = params ? {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      StreamNameCondition: fromStreamNameCondition(params["StreamNameCondition"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreams",
      requestUri: "/listStreams",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "StreamInfoList": [toStreamInfo],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      ResourceARN: params["ResourceARN"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
      requestUri: "/ListTagsForResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "NextToken": "s",
          "Tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async listTagsForStream(
    {abortSignal, ...params}: RequestConfig & ListTagsForStreamInput = {},
  ): Promise<ListTagsForStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      NextToken: params["NextToken"],
      StreamARN: params["StreamARN"],
      StreamName: params["StreamName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForStream",
      requestUri: "/listTagsForStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "NextToken": "s",
          "Tags": x => jsonP.readMap(String, String, x),
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<TagResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: "/TagResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async tagStream(
    {abortSignal, ...params}: RequestConfig & TagStreamInput,
  ): Promise<TagStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamARN: params["StreamARN"],
      StreamName: params["StreamName"],
      Tags: params["Tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagStream",
      requestUri: "/tagStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<UntagResourceOutput> {
    const body: jsonP.JSONObject = params ? {
      ResourceARN: params["ResourceARN"],
      TagKeyList: params["TagKeyList"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
      requestUri: "/UntagResource",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async untagStream(
    {abortSignal, ...params}: RequestConfig & UntagStreamInput,
  ): Promise<UntagStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamARN: params["StreamARN"],
      StreamName: params["StreamName"],
      TagKeyList: params["TagKeyList"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagStream",
      requestUri: "/untagStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateDataRetention(
    {abortSignal, ...params}: RequestConfig & UpdateDataRetentionInput,
  ): Promise<UpdateDataRetentionOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      CurrentVersion: params["CurrentVersion"],
      Operation: params["Operation"],
      DataRetentionChangeInHours: params["DataRetentionChangeInHours"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataRetention",
      requestUri: "/updateDataRetention",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateSignalingChannel(
    {abortSignal, ...params}: RequestConfig & UpdateSignalingChannelInput,
  ): Promise<UpdateSignalingChannelOutput> {
    const body: jsonP.JSONObject = params ? {
      ChannelARN: params["ChannelARN"],
      CurrentVersion: params["CurrentVersion"],
      SingleMasterConfiguration: fromSingleMasterConfiguration(params["SingleMasterConfiguration"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSignalingChannel",
      requestUri: "/updateSignalingChannel",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

  async updateStream(
    {abortSignal, ...params}: RequestConfig & UpdateStreamInput,
  ): Promise<UpdateStreamOutput> {
    const body: jsonP.JSONObject = params ? {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      CurrentVersion: params["CurrentVersion"],
      DeviceName: params["DeviceName"],
      MediaType: params["MediaType"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStream",
      requestUri: "/updateStream",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CreateSignalingChannelInput {
  ChannelName: string;
  ChannelType?: ChannelType | null;
  SingleMasterConfiguration?: SingleMasterConfiguration | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateStreamInput {
  DeviceName?: string | null;
  StreamName: string;
  MediaType?: string | null;
  KmsKeyId?: string | null;
  DataRetentionInHours?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteSignalingChannelInput {
  ChannelARN: string;
  CurrentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStreamInput {
  StreamARN: string;
  CurrentVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeSignalingChannelInput {
  ChannelName?: string | null;
  ChannelARN?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStreamInput {
  StreamName?: string | null;
  StreamARN?: string | null;
}

// refs: 1 - tags: named, input
export interface GetDataEndpointInput {
  StreamName?: string | null;
  StreamARN?: string | null;
  APIName: APIName;
}

// refs: 1 - tags: named, input
export interface GetSignalingChannelEndpointInput {
  ChannelARN: string;
  SingleMasterChannelEndpointConfiguration?: SingleMasterChannelEndpointConfiguration | null;
}

// refs: 1 - tags: named, input
export interface ListSignalingChannelsInput {
  MaxResults?: number | null;
  NextToken?: string | null;
  ChannelNameCondition?: ChannelNameCondition | null;
}

// refs: 1 - tags: named, input
export interface ListStreamsInput {
  MaxResults?: number | null;
  NextToken?: string | null;
  StreamNameCondition?: StreamNameCondition | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  NextToken?: string | null;
  ResourceARN: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForStreamInput {
  NextToken?: string | null;
  StreamARN?: string | null;
  StreamName?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface TagStreamInput {
  StreamARN?: string | null;
  StreamName?: string | null;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  ResourceARN: string;
  TagKeyList: string[];
}

// refs: 1 - tags: named, input
export interface UntagStreamInput {
  StreamARN?: string | null;
  StreamName?: string | null;
  TagKeyList: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDataRetentionInput {
  StreamName?: string | null;
  StreamARN?: string | null;
  CurrentVersion: string;
  Operation: UpdateDataRetentionOperation;
  DataRetentionChangeInHours: number;
}

// refs: 1 - tags: named, input
export interface UpdateSignalingChannelInput {
  ChannelARN: string;
  CurrentVersion: string;
  SingleMasterConfiguration?: SingleMasterConfiguration | null;
}

// refs: 1 - tags: named, input
export interface UpdateStreamInput {
  StreamName?: string | null;
  StreamARN?: string | null;
  CurrentVersion: string;
  DeviceName?: string | null;
  MediaType?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSignalingChannelOutput {
  ChannelARN?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamOutput {
  StreamARN?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteSignalingChannelOutput {
}

// refs: 1 - tags: named, output
export interface DeleteStreamOutput {
}

// refs: 1 - tags: named, output
export interface DescribeSignalingChannelOutput {
  ChannelInfo?: ChannelInfo | null;
}

// refs: 1 - tags: named, output
export interface DescribeStreamOutput {
  StreamInfo?: StreamInfo | null;
}

// refs: 1 - tags: named, output
export interface GetDataEndpointOutput {
  DataEndpoint?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSignalingChannelEndpointOutput {
  ResourceEndpointList?: ResourceEndpointListItem[] | null;
}

// refs: 1 - tags: named, output
export interface ListSignalingChannelsOutput {
  ChannelInfoList?: ChannelInfo[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStreamsOutput {
  StreamInfoList?: StreamInfo[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  NextToken?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForStreamOutput {
  NextToken?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TagResourceOutput {
}

// refs: 1 - tags: named, output
export interface TagStreamOutput {
}

// refs: 1 - tags: named, output
export interface UntagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UntagStreamOutput {
}

// refs: 1 - tags: named, output
export interface UpdateDataRetentionOutput {
}

// refs: 1 - tags: named, output
export interface UpdateSignalingChannelOutput {
}

// refs: 1 - tags: named, output
export interface UpdateStreamOutput {
}

// refs: 3 - tags: input, named, enum, output
export type ChannelType =
| "SINGLE_MASTER"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface SingleMasterConfiguration {
  MessageTtlSeconds?: number | null;
}
function fromSingleMasterConfiguration(input?: SingleMasterConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageTtlSeconds: input["MessageTtlSeconds"],
  }
}
function toSingleMasterConfiguration(root: jsonP.JSONValue): SingleMasterConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageTtlSeconds": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}

// refs: 1 - tags: input, named, enum
export type APIName =
| "PUT_MEDIA"
| "GET_MEDIA"
| "LIST_FRAGMENTS"
| "GET_MEDIA_FOR_FRAGMENT_LIST"
| "GET_HLS_STREAMING_SESSION_URL"
| "GET_DASH_STREAMING_SESSION_URL"
| "GET_CLIP"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SingleMasterChannelEndpointConfiguration {
  Protocols?: ChannelProtocol[] | null;
  Role?: ChannelRole | null;
}
function fromSingleMasterChannelEndpointConfiguration(input?: SingleMasterChannelEndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Protocols: input["Protocols"],
    Role: input["Role"],
  }
}

// refs: 2 - tags: input, named, enum, output
export type ChannelProtocol =
| "WSS"
| "HTTPS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ChannelRole =
| "MASTER"
| "VIEWER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ChannelNameCondition {
  ComparisonOperator?: ComparisonOperator | null;
  ComparisonValue?: string | null;
}
function fromChannelNameCondition(input?: ChannelNameCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComparisonOperator: input["ComparisonOperator"],
    ComparisonValue: input["ComparisonValue"],
  }
}

// refs: 2 - tags: input, named, enum
export type ComparisonOperator =
| "BEGINS_WITH"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface StreamNameCondition {
  ComparisonOperator?: ComparisonOperator | null;
  ComparisonValue?: string | null;
}
function fromStreamNameCondition(input?: StreamNameCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComparisonOperator: input["ComparisonOperator"],
    ComparisonValue: input["ComparisonValue"],
  }
}

// refs: 1 - tags: input, named, enum
export type UpdateDataRetentionOperation =
| "INCREASE_DATA_RETENTION"
| "DECREASE_DATA_RETENTION"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ChannelInfo {
  ChannelName?: string | null;
  ChannelARN?: string | null;
  ChannelType?: ChannelType | null;
  ChannelStatus?: Status | null;
  CreationTime?: Date | number | null;
  SingleMasterConfiguration?: SingleMasterConfiguration | null;
  Version?: string | null;
}
function toChannelInfo(root: jsonP.JSONValue): ChannelInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelName": "s",
      "ChannelARN": "s",
      "ChannelType": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelType>(x),
      "ChannelStatus": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      "CreationTime": "d",
      "SingleMasterConfiguration": toSingleMasterConfiguration,
      "Version": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type Status =
| "CREATING"
| "ACTIVE"
| "UPDATING"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface StreamInfo {
  DeviceName?: string | null;
  StreamName?: string | null;
  StreamARN?: string | null;
  MediaType?: string | null;
  KmsKeyId?: string | null;
  Version?: string | null;
  Status?: Status | null;
  CreationTime?: Date | number | null;
  DataRetentionInHours?: number | null;
}
function toStreamInfo(root: jsonP.JSONValue): StreamInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeviceName": "s",
      "StreamName": "s",
      "StreamARN": "s",
      "MediaType": "s",
      "KmsKeyId": "s",
      "Version": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<Status>(x),
      "CreationTime": "d",
      "DataRetentionInHours": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResourceEndpointListItem {
  Protocol?: ChannelProtocol | null;
  ResourceEndpoint?: string | null;
}
function toResourceEndpointListItem(root: jsonP.JSONValue): ResourceEndpointListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "Protocol": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelProtocol>(x),
      "ResourceEndpoint": "s",
    },
  }, root);
}
