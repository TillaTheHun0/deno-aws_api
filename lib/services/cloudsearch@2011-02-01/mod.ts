// Autogenerated API client for: Amazon CloudSearch

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";

export default class CloudSearch {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudSearch.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2011-02-01",
    "endpointPrefix": "cloudsearch",
    "serviceFullName": "Amazon CloudSearch",
    "serviceId": "CloudSearch",
    "signatureVersion": "v4",
    "xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2011-02-01/",
    "protocol": "query",
    "uid": "cloudsearch-2011-02-01"
  };

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<s.CreateDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async defineIndexField(
    {abortSignal, ...params}: RequestConfig & s.DefineIndexFieldRequest,
  ): Promise<s.DefineIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    IndexField_Serialize(body, prefix+"IndexField", params["IndexField"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineIndexField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async defineRankExpression(
    {abortSignal, ...params}: RequestConfig & s.DefineRankExpressionRequest,
  ): Promise<s.DefineRankExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    NamedRankExpression_Serialize(body, prefix+"RankExpression", params["RankExpression"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineRankExpression",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineRankExpressionResult");
    return {
      RankExpression: xml.first("RankExpression", true, RankExpressionStatus_Parse),
    };
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<s.DeleteDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async deleteIndexField(
    {abortSignal, ...params}: RequestConfig & s.DeleteIndexFieldRequest,
  ): Promise<s.DeleteIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIndexField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async deleteRankExpression(
    {abortSignal, ...params}: RequestConfig & s.DeleteRankExpressionRequest,
  ): Promise<s.DeleteRankExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"RankName", (params["RankName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRankExpression",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteRankExpressionResult");
    return {
      RankExpression: xml.first("RankExpression", true, RankExpressionStatus_Parse),
    };
  }

  async describeAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAvailabilityOptionsRequest,
  ): Promise<s.DescribeAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async describeDefaultSearchField(
    {abortSignal, ...params}: RequestConfig & s.DescribeDefaultSearchFieldRequest,
  ): Promise<s.DescribeDefaultSearchFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDefaultSearchField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDefaultSearchFieldResult");
    return {
      DefaultSearchField: xml.first("DefaultSearchField", true, DefaultSearchFieldStatus_Parse),
    };
  }

  async describeDomains(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainsRequest = {},
  ): Promise<s.DescribeDomainsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DomainNames"]) qsP.appendList(body, prefix+"DomainNames", params["DomainNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDomainsResult");
    return {
      DomainStatusList: xml.getList("DomainStatusList", "member").map(DomainStatus_Parse),
    };
  }

  async describeIndexFields(
    {abortSignal, ...params}: RequestConfig & s.DescribeIndexFieldsRequest,
  ): Promise<s.DescribeIndexFieldsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["FieldNames"]) qsP.appendList(body, prefix+"FieldNames", params["FieldNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIndexFields",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeIndexFieldsResult");
    return {
      IndexFields: xml.getList("IndexFields", "member").map(IndexFieldStatus_Parse),
    };
  }

  async describeRankExpressions(
    {abortSignal, ...params}: RequestConfig & s.DescribeRankExpressionsRequest,
  ): Promise<s.DescribeRankExpressionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["RankNames"]) qsP.appendList(body, prefix+"RankNames", params["RankNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRankExpressions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeRankExpressionsResult");
    return {
      RankExpressions: xml.getList("RankExpressions", "member").map(RankExpressionStatus_Parse),
    };
  }

  async describeServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribeServiceAccessPoliciesRequest,
  ): Promise<s.DescribeServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceAccessPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async describeStemmingOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeStemmingOptionsRequest,
  ): Promise<s.DescribeStemmingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStemmingOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStemmingOptionsResult");
    return {
      Stems: xml.first("Stems", true, StemmingOptionsStatus_Parse),
    };
  }

  async describeStopwordOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeStopwordOptionsRequest,
  ): Promise<s.DescribeStopwordOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStopwordOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStopwordOptionsResult");
    return {
      Stopwords: xml.first("Stopwords", true, StopwordOptionsStatus_Parse),
    };
  }

  async describeSynonymOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeSynonymOptionsRequest,
  ): Promise<s.DescribeSynonymOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSynonymOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSynonymOptionsResult");
    return {
      Synonyms: xml.first("Synonyms", true, SynonymOptionsStatus_Parse),
    };
  }

  async indexDocuments(
    {abortSignal, ...params}: RequestConfig & s.IndexDocumentsRequest,
  ): Promise<s.IndexDocumentsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IndexDocuments",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IndexDocumentsResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async updateAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateAvailabilityOptionsRequest,
  ): Promise<s.UpdateAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAvailabilityOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async updateDefaultSearchField(
    {abortSignal, ...params}: RequestConfig & s.UpdateDefaultSearchFieldRequest,
  ): Promise<s.UpdateDefaultSearchFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"DefaultSearchField", (params["DefaultSearchField"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDefaultSearchField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateDefaultSearchFieldResult");
    return {
      DefaultSearchField: xml.first("DefaultSearchField", true, DefaultSearchFieldStatus_Parse),
    };
  }

  async updateServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & s.UpdateServiceAccessPoliciesRequest,
  ): Promise<s.UpdateServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AccessPolicies", (params["AccessPolicies"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceAccessPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async updateStemmingOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateStemmingOptionsRequest,
  ): Promise<s.UpdateStemmingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Stems", (params["Stems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStemmingOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStemmingOptionsResult");
    return {
      Stems: xml.first("Stems", true, StemmingOptionsStatus_Parse),
    };
  }

  async updateStopwordOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateStopwordOptionsRequest,
  ): Promise<s.UpdateStopwordOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Stopwords", (params["Stopwords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStopwordOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStopwordOptionsResult");
    return {
      Stopwords: xml.first("Stopwords", true, StopwordOptionsStatus_Parse),
    };
  }

  async updateSynonymOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateSynonymOptionsRequest,
  ): Promise<s.UpdateSynonymOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Synonyms", (params["Synonyms"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSynonymOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateSynonymOptionsResult");
    return {
      Synonyms: xml.first("Synonyms", true, SynonymOptionsStatus_Parse),
    };
  }

}

function IndexField_Serialize(body: URLSearchParams, prefix: string, params: s.IndexField) {
    body.append(prefix+".IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    body.append(prefix+".IndexFieldType", (params["IndexFieldType"] ?? '').toString());
    if (params["UIntOptions"] != null) UIntOptions_Serialize(body, prefix+".UIntOptions", params["UIntOptions"]);
    if (params["LiteralOptions"] != null) LiteralOptions_Serialize(body, prefix+".LiteralOptions", params["LiteralOptions"]);
    if (params["TextOptions"] != null) TextOptions_Serialize(body, prefix+".TextOptions", params["TextOptions"]);
    if (params["SourceAttributes"]) qsP.appendList(body, prefix+".SourceAttributes", params["SourceAttributes"], {"appender":SourceAttribute_Serialize,"entryPrefix":".member."})
}
function IndexField_Parse(node: xmlP.XmlNode): s.IndexField {
  return {
    ...node.strings({
      required: {"IndexFieldName":true},
    }),
    IndexFieldType: node.first("IndexFieldType", true, x => (x.content ?? '') as s.IndexFieldType),
    UIntOptions: node.first("UIntOptions", false, UIntOptions_Parse),
    LiteralOptions: node.first("LiteralOptions", false, LiteralOptions_Parse),
    TextOptions: node.first("TextOptions", false, TextOptions_Parse),
    SourceAttributes: node.getList("SourceAttributes", "member").map(SourceAttribute_Parse),
  };
}

function UIntOptions_Serialize(body: URLSearchParams, prefix: string, params: s.UIntOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
}
function UIntOptions_Parse(node: xmlP.XmlNode): s.UIntOptions {
  return {
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
  };
}

function LiteralOptions_Serialize(body: URLSearchParams, prefix: string, params: s.LiteralOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("ResultEnabled" in params) body.append(prefix+".ResultEnabled", (params["ResultEnabled"] ?? '').toString());
}
function LiteralOptions_Parse(node: xmlP.XmlNode): s.LiteralOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true},
    }),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    ResultEnabled: node.first("ResultEnabled", false, x => x.content === 'true'),
  };
}

function TextOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TextOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("ResultEnabled" in params) body.append(prefix+".ResultEnabled", (params["ResultEnabled"] ?? '').toString());
    if ("TextProcessor" in params) body.append(prefix+".TextProcessor", (params["TextProcessor"] ?? '').toString());
}
function TextOptions_Parse(node: xmlP.XmlNode): s.TextOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"TextProcessor":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    ResultEnabled: node.first("ResultEnabled", false, x => x.content === 'true'),
  };
}

function SourceAttribute_Serialize(body: URLSearchParams, prefix: string, params: s.SourceAttribute) {
    body.append(prefix+".SourceDataFunction", (params["SourceDataFunction"] ?? '').toString());
    if (params["SourceDataCopy"] != null) SourceData_Serialize(body, prefix+".SourceDataCopy", params["SourceDataCopy"]);
    if (params["SourceDataTrimTitle"] != null) SourceDataTrimTitle_Serialize(body, prefix+".SourceDataTrimTitle", params["SourceDataTrimTitle"]);
    if (params["SourceDataMap"] != null) SourceDataMap_Serialize(body, prefix+".SourceDataMap", params["SourceDataMap"]);
}
function SourceAttribute_Parse(node: xmlP.XmlNode): s.SourceAttribute {
  return {
    SourceDataFunction: node.first("SourceDataFunction", true, x => (x.content ?? '') as s.SourceDataFunction),
    SourceDataCopy: node.first("SourceDataCopy", false, SourceData_Parse),
    SourceDataTrimTitle: node.first("SourceDataTrimTitle", false, SourceDataTrimTitle_Parse),
    SourceDataMap: node.first("SourceDataMap", false, SourceDataMap_Parse),
  };
}

function SourceData_Serialize(body: URLSearchParams, prefix: string, params: s.SourceData) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
}
function SourceData_Parse(node: xmlP.XmlNode): s.SourceData {
  return node.strings({
    required: {"SourceName":true},
    optional: {"DefaultValue":true},
  });
}

function SourceDataTrimTitle_Serialize(body: URLSearchParams, prefix: string, params: s.SourceDataTrimTitle) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("Separator" in params) body.append(prefix+".Separator", (params["Separator"] ?? '').toString());
    if ("Language" in params) body.append(prefix+".Language", (params["Language"] ?? '').toString());
}
function SourceDataTrimTitle_Parse(node: xmlP.XmlNode): s.SourceDataTrimTitle {
  return node.strings({
    required: {"SourceName":true},
    optional: {"DefaultValue":true,"Separator":true,"Language":true},
  });
}

function SourceDataMap_Serialize(body: URLSearchParams, prefix: string, params: s.SourceDataMap) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if (params["Cases"]) qsP.appendMap(body, prefix+".Cases", params["Cases"], {"entryPrefix":".entry."})
}
function SourceDataMap_Parse(node: xmlP.XmlNode): s.SourceDataMap {
  return {
    ...node.strings({
      required: {"SourceName":true},
      optional: {"DefaultValue":true},
    }),
    Cases: xmlP.readXmlMap(node.getList("Cases", "entry"), x => x.content ?? '', {}),
  };
}

function NamedRankExpression_Serialize(body: URLSearchParams, prefix: string, params: s.NamedRankExpression) {
    body.append(prefix+".RankName", (params["RankName"] ?? '').toString());
    body.append(prefix+".RankExpression", (params["RankExpression"] ?? '').toString());
}
function NamedRankExpression_Parse(node: xmlP.XmlNode): s.NamedRankExpression {
  return node.strings({
    required: {"RankName":true,"RankExpression":true},
  });
}

function DomainStatus_Parse(node: xmlP.XmlNode): s.DomainStatus {
  return {
    ...node.strings({
      required: {"DomainId":true,"DomainName":true},
      optional: {"SearchInstanceType":true},
    }),
    Created: node.first("Created", false, x => x.content === 'true'),
    Deleted: node.first("Deleted", false, x => x.content === 'true'),
    NumSearchableDocs: node.first("NumSearchableDocs", false, x => parseInt(x.content ?? '0')),
    DocService: node.first("DocService", false, ServiceEndpoint_Parse),
    SearchService: node.first("SearchService", false, ServiceEndpoint_Parse),
    RequiresIndexDocuments: node.first("RequiresIndexDocuments", true, x => x.content === 'true'),
    Processing: node.first("Processing", false, x => x.content === 'true'),
    SearchPartitionCount: node.first("SearchPartitionCount", false, x => parseInt(x.content ?? '0')),
    SearchInstanceCount: node.first("SearchInstanceCount", false, x => parseInt(x.content ?? '0')),
  };
}

function ServiceEndpoint_Parse(node: xmlP.XmlNode): s.ServiceEndpoint {
  return node.strings({
    optional: {"Arn":true,"Endpoint":true},
  });
}

function IndexFieldStatus_Parse(node: xmlP.XmlNode): s.IndexFieldStatus {
  return {
    Options: node.first("Options", true, IndexField_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function OptionStatus_Parse(node: xmlP.XmlNode): s.OptionStatus {
  return {
    CreationDate: node.first("CreationDate", true, x => xmlP.parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", true, x => xmlP.parseTimestamp(x.content)),
    UpdateVersion: node.first("UpdateVersion", false, x => parseInt(x.content ?? '0')),
    State: node.first("State", true, x => (x.content ?? '') as s.OptionState),
    PendingDeletion: node.first("PendingDeletion", false, x => x.content === 'true'),
  };
}

function RankExpressionStatus_Parse(node: xmlP.XmlNode): s.RankExpressionStatus {
  return {
    Options: node.first("Options", true, NamedRankExpression_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function AvailabilityOptionsStatus_Parse(node: xmlP.XmlNode): s.AvailabilityOptionsStatus {
  return {
    Options: node.first("Options", true, x => x.content === 'true'),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function DefaultSearchFieldStatus_Parse(node: xmlP.XmlNode): s.DefaultSearchFieldStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function AccessPoliciesStatus_Parse(node: xmlP.XmlNode): s.AccessPoliciesStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function StemmingOptionsStatus_Parse(node: xmlP.XmlNode): s.StemmingOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function StopwordOptionsStatus_Parse(node: xmlP.XmlNode): s.StopwordOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function SynonymOptionsStatus_Parse(node: xmlP.XmlNode): s.SynonymOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}
