// Autogenerated API client for: Amazon CloudSearch

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class CloudSearch {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudSearch.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2011-02-01",
    "endpointPrefix": "cloudsearch",
    "serviceFullName": "Amazon CloudSearch",
    "serviceId": "CloudSearch",
    "signatureVersion": "v4",
    "xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2011-02-01/",
    "protocol": "query",
    "uid": "cloudsearch-2011-02-01"
  };

  async createDomain(
    {abortSignal, ...params}: RequestConfig & CreateDomainRequest,
  ): Promise<CreateDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    const xml = readXmlResult(await resp.text(), "CreateDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async defineIndexField(
    {abortSignal, ...params}: RequestConfig & DefineIndexFieldRequest,
  ): Promise<DefineIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    IndexField_Serialize(body, prefix+"IndexField", params["IndexField"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineIndexField",
    });
    const xml = readXmlResult(await resp.text(), "DefineIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async defineRankExpression(
    {abortSignal, ...params}: RequestConfig & DefineRankExpressionRequest,
  ): Promise<DefineRankExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    NamedRankExpression_Serialize(body, prefix+"RankExpression", params["RankExpression"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineRankExpression",
    });
    const xml = readXmlResult(await resp.text(), "DefineRankExpressionResult");
    return {
      RankExpression: xml.first("RankExpression", true, RankExpressionStatus_Parse),
    };
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & DeleteDomainRequest,
  ): Promise<DeleteDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async deleteIndexField(
    {abortSignal, ...params}: RequestConfig & DeleteIndexFieldRequest,
  ): Promise<DeleteIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIndexField",
    });
    const xml = readXmlResult(await resp.text(), "DeleteIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async deleteRankExpression(
    {abortSignal, ...params}: RequestConfig & DeleteRankExpressionRequest,
  ): Promise<DeleteRankExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"RankName", (params["RankName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRankExpression",
    });
    const xml = readXmlResult(await resp.text(), "DeleteRankExpressionResult");
    return {
      RankExpression: xml.first("RankExpression", true, RankExpressionStatus_Parse),
    };
  }

  async describeAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & DescribeAvailabilityOptionsRequest,
  ): Promise<DescribeAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async describeDefaultSearchField(
    {abortSignal, ...params}: RequestConfig & DescribeDefaultSearchFieldRequest,
  ): Promise<DescribeDefaultSearchFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDefaultSearchField",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDefaultSearchFieldResult");
    return {
      DefaultSearchField: xml.first("DefaultSearchField", true, DefaultSearchFieldStatus_Parse),
    };
  }

  async describeDomains(
    {abortSignal, ...params}: RequestConfig & DescribeDomainsRequest = {},
  ): Promise<DescribeDomainsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DomainNames"]) prt.appendList(body, prefix+"DomainNames", params["DomainNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomains",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDomainsResult");
    return {
      DomainStatusList: xml.getList("DomainStatusList", "member").map(DomainStatus_Parse),
    };
  }

  async describeIndexFields(
    {abortSignal, ...params}: RequestConfig & DescribeIndexFieldsRequest,
  ): Promise<DescribeIndexFieldsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["FieldNames"]) prt.appendList(body, prefix+"FieldNames", params["FieldNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIndexFields",
    });
    const xml = readXmlResult(await resp.text(), "DescribeIndexFieldsResult");
    return {
      IndexFields: xml.getList("IndexFields", "member").map(IndexFieldStatus_Parse),
    };
  }

  async describeRankExpressions(
    {abortSignal, ...params}: RequestConfig & DescribeRankExpressionsRequest,
  ): Promise<DescribeRankExpressionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["RankNames"]) prt.appendList(body, prefix+"RankNames", params["RankNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRankExpressions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeRankExpressionsResult");
    return {
      RankExpressions: xml.getList("RankExpressions", "member").map(RankExpressionStatus_Parse),
    };
  }

  async describeServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & DescribeServiceAccessPoliciesRequest,
  ): Promise<DescribeServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceAccessPolicies",
    });
    const xml = readXmlResult(await resp.text(), "DescribeServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async describeStemmingOptions(
    {abortSignal, ...params}: RequestConfig & DescribeStemmingOptionsRequest,
  ): Promise<DescribeStemmingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStemmingOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeStemmingOptionsResult");
    return {
      Stems: xml.first("Stems", true, StemmingOptionsStatus_Parse),
    };
  }

  async describeStopwordOptions(
    {abortSignal, ...params}: RequestConfig & DescribeStopwordOptionsRequest,
  ): Promise<DescribeStopwordOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStopwordOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeStopwordOptionsResult");
    return {
      Stopwords: xml.first("Stopwords", true, StopwordOptionsStatus_Parse),
    };
  }

  async describeSynonymOptions(
    {abortSignal, ...params}: RequestConfig & DescribeSynonymOptionsRequest,
  ): Promise<DescribeSynonymOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSynonymOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeSynonymOptionsResult");
    return {
      Synonyms: xml.first("Synonyms", true, SynonymOptionsStatus_Parse),
    };
  }

  async indexDocuments(
    {abortSignal, ...params}: RequestConfig & IndexDocumentsRequest,
  ): Promise<IndexDocumentsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IndexDocuments",
    });
    const xml = readXmlResult(await resp.text(), "IndexDocumentsResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async updateAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & UpdateAvailabilityOptionsRequest,
  ): Promise<UpdateAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAvailabilityOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async updateDefaultSearchField(
    {abortSignal, ...params}: RequestConfig & UpdateDefaultSearchFieldRequest,
  ): Promise<UpdateDefaultSearchFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"DefaultSearchField", (params["DefaultSearchField"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDefaultSearchField",
    });
    const xml = readXmlResult(await resp.text(), "UpdateDefaultSearchFieldResult");
    return {
      DefaultSearchField: xml.first("DefaultSearchField", true, DefaultSearchFieldStatus_Parse),
    };
  }

  async updateServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & UpdateServiceAccessPoliciesRequest,
  ): Promise<UpdateServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AccessPolicies", (params["AccessPolicies"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceAccessPolicies",
    });
    const xml = readXmlResult(await resp.text(), "UpdateServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async updateStemmingOptions(
    {abortSignal, ...params}: RequestConfig & UpdateStemmingOptionsRequest,
  ): Promise<UpdateStemmingOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Stems", (params["Stems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStemmingOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateStemmingOptionsResult");
    return {
      Stems: xml.first("Stems", true, StemmingOptionsStatus_Parse),
    };
  }

  async updateStopwordOptions(
    {abortSignal, ...params}: RequestConfig & UpdateStopwordOptionsRequest,
  ): Promise<UpdateStopwordOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Stopwords", (params["Stopwords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStopwordOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateStopwordOptionsResult");
    return {
      Stopwords: xml.first("Stopwords", true, StopwordOptionsStatus_Parse),
    };
  }

  async updateSynonymOptions(
    {abortSignal, ...params}: RequestConfig & UpdateSynonymOptionsRequest,
  ): Promise<UpdateSynonymOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"Synonyms", (params["Synonyms"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSynonymOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateSynonymOptionsResult");
    return {
      Synonyms: xml.first("Synonyms", true, SynonymOptionsStatus_Parse),
    };
  }

}

// refs: 1 - tags: named, input
export interface CreateDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DefineIndexFieldRequest {
  DomainName: string;
  IndexField: IndexField;
}

// refs: 1 - tags: named, input
export interface DefineRankExpressionRequest {
  DomainName: string;
  RankExpression: NamedRankExpression;
}

// refs: 1 - tags: named, input
export interface DeleteDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DeleteIndexFieldRequest {
  DomainName: string;
  IndexFieldName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRankExpressionRequest {
  DomainName: string;
  RankName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAvailabilityOptionsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDefaultSearchFieldRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDomainsRequest {
  DomainNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeIndexFieldsRequest {
  DomainName: string;
  FieldNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeRankExpressionsRequest {
  DomainName: string;
  RankNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeServiceAccessPoliciesRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeStemmingOptionsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeStopwordOptionsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeSynonymOptionsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface IndexDocumentsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface UpdateAvailabilityOptionsRequest {
  DomainName: string;
  MultiAZ: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateDefaultSearchFieldRequest {
  DomainName: string;
  DefaultSearchField: string;
}

// refs: 1 - tags: named, input
export interface UpdateServiceAccessPoliciesRequest {
  DomainName: string;
  AccessPolicies: string;
}

// refs: 1 - tags: named, input
export interface UpdateStemmingOptionsRequest {
  DomainName: string;
  Stems: string;
}

// refs: 1 - tags: named, input
export interface UpdateStopwordOptionsRequest {
  DomainName: string;
  Stopwords: string;
}

// refs: 1 - tags: named, input
export interface UpdateSynonymOptionsRequest {
  DomainName: string;
  Synonyms: string;
}

// refs: 1 - tags: named, output
export interface CreateDomainResponse {
  DomainStatus?: DomainStatus | null;
}

// refs: 1 - tags: named, output
export interface DefineIndexFieldResponse {
  IndexField: IndexFieldStatus;
}

// refs: 1 - tags: named, output
export interface DefineRankExpressionResponse {
  RankExpression: RankExpressionStatus;
}

// refs: 1 - tags: named, output
export interface DeleteDomainResponse {
  DomainStatus?: DomainStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteIndexFieldResponse {
  IndexField: IndexFieldStatus;
}

// refs: 1 - tags: named, output
export interface DeleteRankExpressionResponse {
  RankExpression: RankExpressionStatus;
}

// refs: 1 - tags: named, output
export interface DescribeAvailabilityOptionsResponse {
  AvailabilityOptions?: AvailabilityOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface DescribeDefaultSearchFieldResponse {
  DefaultSearchField: DefaultSearchFieldStatus;
}

// refs: 1 - tags: named, output
export interface DescribeDomainsResponse {
  DomainStatusList: DomainStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeIndexFieldsResponse {
  IndexFields: IndexFieldStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeRankExpressionsResponse {
  RankExpressions: RankExpressionStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeServiceAccessPoliciesResponse {
  AccessPolicies: AccessPoliciesStatus;
}

// refs: 1 - tags: named, output
export interface DescribeStemmingOptionsResponse {
  Stems: StemmingOptionsStatus;
}

// refs: 1 - tags: named, output
export interface DescribeStopwordOptionsResponse {
  Stopwords: StopwordOptionsStatus;
}

// refs: 1 - tags: named, output
export interface DescribeSynonymOptionsResponse {
  Synonyms: SynonymOptionsStatus;
}

// refs: 1 - tags: named, output
export interface IndexDocumentsResponse {
  FieldNames: string[];
}

// refs: 1 - tags: named, output
export interface UpdateAvailabilityOptionsResponse {
  AvailabilityOptions?: AvailabilityOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface UpdateDefaultSearchFieldResponse {
  DefaultSearchField: DefaultSearchFieldStatus;
}

// refs: 1 - tags: named, output
export interface UpdateServiceAccessPoliciesResponse {
  AccessPolicies: AccessPoliciesStatus;
}

// refs: 1 - tags: named, output
export interface UpdateStemmingOptionsResponse {
  Stems: StemmingOptionsStatus;
}

// refs: 1 - tags: named, output
export interface UpdateStopwordOptionsResponse {
  Stopwords: StopwordOptionsStatus;
}

// refs: 1 - tags: named, output
export interface UpdateSynonymOptionsResponse {
  Synonyms: SynonymOptionsStatus;
}

// refs: 4 - tags: input, named, interface, output
export interface IndexField {
  IndexFieldName: string;
  IndexFieldType: IndexFieldType;
  UIntOptions?: UIntOptions | null;
  LiteralOptions?: LiteralOptions | null;
  TextOptions?: TextOptions | null;
  SourceAttributes: SourceAttribute[];
}
function IndexField_Serialize(body: URLSearchParams, prefix: string, params: IndexField) {
    body.append(prefix+".IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    body.append(prefix+".IndexFieldType", (params["IndexFieldType"] ?? '').toString());
    if (params["UIntOptions"] != null) UIntOptions_Serialize(body, prefix+".UIntOptions", params["UIntOptions"]);
    if (params["LiteralOptions"] != null) LiteralOptions_Serialize(body, prefix+".LiteralOptions", params["LiteralOptions"]);
    if (params["TextOptions"] != null) TextOptions_Serialize(body, prefix+".TextOptions", params["TextOptions"]);
    if (params["SourceAttributes"]) prt.appendList(body, prefix+".SourceAttributes", params["SourceAttributes"], {"appender":SourceAttribute_Serialize,"entryPrefix":".member."})
}
function IndexField_Parse(node: XmlNode): IndexField {
  return {
    ...node.strings({
      required: {"IndexFieldName":true},
    }),
    IndexFieldType: node.first("IndexFieldType", true, x => (x.content ?? '') as IndexFieldType),
    UIntOptions: node.first("UIntOptions", false, UIntOptions_Parse),
    LiteralOptions: node.first("LiteralOptions", false, LiteralOptions_Parse),
    TextOptions: node.first("TextOptions", false, TextOptions_Parse),
    SourceAttributes: node.getList("SourceAttributes", "member").map(SourceAttribute_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type IndexFieldType =
| "uint"
| "literal"
| "text"
;



// refs: 4 - tags: input, named, interface, output
export interface UIntOptions {
  DefaultValue?: number | null;
}
function UIntOptions_Serialize(body: URLSearchParams, prefix: string, params: UIntOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
}
function UIntOptions_Parse(node: XmlNode): UIntOptions {
  return {
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface LiteralOptions {
  DefaultValue?: string | null;
  SearchEnabled?: boolean | null;
  FacetEnabled?: boolean | null;
  ResultEnabled?: boolean | null;
}
function LiteralOptions_Serialize(body: URLSearchParams, prefix: string, params: LiteralOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("ResultEnabled" in params) body.append(prefix+".ResultEnabled", (params["ResultEnabled"] ?? '').toString());
}
function LiteralOptions_Parse(node: XmlNode): LiteralOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true},
    }),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    ResultEnabled: node.first("ResultEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface TextOptions {
  DefaultValue?: string | null;
  FacetEnabled?: boolean | null;
  ResultEnabled?: boolean | null;
  TextProcessor?: string | null;
}
function TextOptions_Serialize(body: URLSearchParams, prefix: string, params: TextOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("ResultEnabled" in params) body.append(prefix+".ResultEnabled", (params["ResultEnabled"] ?? '').toString());
    if ("TextProcessor" in params) body.append(prefix+".TextProcessor", (params["TextProcessor"] ?? '').toString());
}
function TextOptions_Parse(node: XmlNode): TextOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"TextProcessor":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    ResultEnabled: node.first("ResultEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface SourceAttribute {
  SourceDataFunction: SourceDataFunction;
  SourceDataCopy?: SourceData | null;
  SourceDataTrimTitle?: SourceDataTrimTitle | null;
  SourceDataMap?: SourceDataMap | null;
}
function SourceAttribute_Serialize(body: URLSearchParams, prefix: string, params: SourceAttribute) {
    body.append(prefix+".SourceDataFunction", (params["SourceDataFunction"] ?? '').toString());
    if (params["SourceDataCopy"] != null) SourceData_Serialize(body, prefix+".SourceDataCopy", params["SourceDataCopy"]);
    if (params["SourceDataTrimTitle"] != null) SourceDataTrimTitle_Serialize(body, prefix+".SourceDataTrimTitle", params["SourceDataTrimTitle"]);
    if (params["SourceDataMap"] != null) SourceDataMap_Serialize(body, prefix+".SourceDataMap", params["SourceDataMap"]);
}
function SourceAttribute_Parse(node: XmlNode): SourceAttribute {
  return {
    SourceDataFunction: node.first("SourceDataFunction", true, x => (x.content ?? '') as SourceDataFunction),
    SourceDataCopy: node.first("SourceDataCopy", false, SourceData_Parse),
    SourceDataTrimTitle: node.first("SourceDataTrimTitle", false, SourceDataTrimTitle_Parse),
    SourceDataMap: node.first("SourceDataMap", false, SourceDataMap_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type SourceDataFunction =
| "Copy"
| "TrimTitle"
| "Map"
;



// refs: 4 - tags: input, named, interface, output
export interface SourceData {
  SourceName: string;
  DefaultValue?: string | null;
}
function SourceData_Serialize(body: URLSearchParams, prefix: string, params: SourceData) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
}
function SourceData_Parse(node: XmlNode): SourceData {
  return node.strings({
    required: {"SourceName":true},
    optional: {"DefaultValue":true},
  });
}

// refs: 4 - tags: input, named, interface, output
export interface SourceDataTrimTitle {
  SourceName: string;
  DefaultValue?: string | null;
  Separator?: string | null;
  Language?: string | null;
}
function SourceDataTrimTitle_Serialize(body: URLSearchParams, prefix: string, params: SourceDataTrimTitle) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("Separator" in params) body.append(prefix+".Separator", (params["Separator"] ?? '').toString());
    if ("Language" in params) body.append(prefix+".Language", (params["Language"] ?? '').toString());
}
function SourceDataTrimTitle_Parse(node: XmlNode): SourceDataTrimTitle {
  return node.strings({
    required: {"SourceName":true},
    optional: {"DefaultValue":true,"Separator":true,"Language":true},
  });
}

// refs: 4 - tags: input, named, interface, output
export interface SourceDataMap {
  SourceName: string;
  DefaultValue?: string | null;
  Cases: { [key: string]: string };
}
function SourceDataMap_Serialize(body: URLSearchParams, prefix: string, params: SourceDataMap) {
    body.append(prefix+".SourceName", (params["SourceName"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if (params["Cases"]) prt.appendMap(body, prefix+".Cases", params["Cases"], {"entryPrefix":".entry."})
}
function SourceDataMap_Parse(node: XmlNode): SourceDataMap {
  return {
    ...node.strings({
      required: {"SourceName":true},
      optional: {"DefaultValue":true},
    }),
    Cases: readXmlMap(node.getList("Cases", "entry"), x => x.content ?? '', {}),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface NamedRankExpression {
  RankName: string;
  RankExpression: string;
}
function NamedRankExpression_Serialize(body: URLSearchParams, prefix: string, params: NamedRankExpression) {
    body.append(prefix+".RankName", (params["RankName"] ?? '').toString());
    body.append(prefix+".RankExpression", (params["RankExpression"] ?? '').toString());
}
function NamedRankExpression_Parse(node: XmlNode): NamedRankExpression {
  return node.strings({
    required: {"RankName":true,"RankExpression":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface DomainStatus {
  DomainId: string;
  DomainName: string;
  Created?: boolean | null;
  Deleted?: boolean | null;
  NumSearchableDocs?: number | null;
  DocService?: ServiceEndpoint | null;
  SearchService?: ServiceEndpoint | null;
  RequiresIndexDocuments: boolean;
  Processing?: boolean | null;
  SearchInstanceType?: string | null;
  SearchPartitionCount?: number | null;
  SearchInstanceCount?: number | null;
}
function DomainStatus_Parse(node: XmlNode): DomainStatus {
  return {
    ...node.strings({
      required: {"DomainId":true,"DomainName":true},
      optional: {"SearchInstanceType":true},
    }),
    Created: node.first("Created", false, x => x.content === 'true'),
    Deleted: node.first("Deleted", false, x => x.content === 'true'),
    NumSearchableDocs: node.first("NumSearchableDocs", false, x => parseInt(x.content ?? '0')),
    DocService: node.first("DocService", false, ServiceEndpoint_Parse),
    SearchService: node.first("SearchService", false, ServiceEndpoint_Parse),
    RequiresIndexDocuments: node.first("RequiresIndexDocuments", true, x => x.content === 'true'),
    Processing: node.first("Processing", false, x => x.content === 'true'),
    SearchPartitionCount: node.first("SearchPartitionCount", false, x => parseInt(x.content ?? '0')),
    SearchInstanceCount: node.first("SearchInstanceCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 6 - tags: output, named, interface
export interface ServiceEndpoint {
  Arn?: string | null;
  Endpoint?: string | null;
}
function ServiceEndpoint_Parse(node: XmlNode): ServiceEndpoint {
  return node.strings({
    optional: {"Arn":true,"Endpoint":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface IndexFieldStatus {
  Options: IndexField;
  Status: OptionStatus;
}
function IndexFieldStatus_Parse(node: XmlNode): IndexFieldStatus {
  return {
    Options: node.first("Options", true, IndexField_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 18 - tags: output, named, interface
export interface OptionStatus {
  CreationDate: Date | number;
  UpdateDate: Date | number;
  UpdateVersion?: number | null;
  State: OptionState;
  PendingDeletion?: boolean | null;
}
function OptionStatus_Parse(node: XmlNode): OptionStatus {
  return {
    CreationDate: node.first("CreationDate", true, x => parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", true, x => parseTimestamp(x.content)),
    UpdateVersion: node.first("UpdateVersion", false, x => parseInt(x.content ?? '0')),
    State: node.first("State", true, x => (x.content ?? '') as OptionState),
    PendingDeletion: node.first("PendingDeletion", false, x => x.content === 'true'),
  };
}

// refs: 18 - tags: output, named, enum
export type OptionState =
| "RequiresIndexDocuments"
| "Processing"
| "Active"
;


// refs: 3 - tags: output, named, interface
export interface RankExpressionStatus {
  Options: NamedRankExpression;
  Status: OptionStatus;
}
function RankExpressionStatus_Parse(node: XmlNode): RankExpressionStatus {
  return {
    Options: node.first("Options", true, NamedRankExpression_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface AvailabilityOptionsStatus {
  Options: boolean;
  Status: OptionStatus;
}
function AvailabilityOptionsStatus_Parse(node: XmlNode): AvailabilityOptionsStatus {
  return {
    Options: node.first("Options", true, x => x.content === 'true'),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DefaultSearchFieldStatus {
  Options: string;
  Status: OptionStatus;
}
function DefaultSearchFieldStatus_Parse(node: XmlNode): DefaultSearchFieldStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface AccessPoliciesStatus {
  Options: string;
  Status: OptionStatus;
}
function AccessPoliciesStatus_Parse(node: XmlNode): AccessPoliciesStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface StemmingOptionsStatus {
  Options: string;
  Status: OptionStatus;
}
function StemmingOptionsStatus_Parse(node: XmlNode): StemmingOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface StopwordOptionsStatus {
  Options: string;
  Status: OptionStatus;
}
function StopwordOptionsStatus_Parse(node: XmlNode): StopwordOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface SynonymOptionsStatus {
  Options: string;
  Status: OptionStatus;
}
function SynonymOptionsStatus_Parse(node: XmlNode): SynonymOptionsStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}
