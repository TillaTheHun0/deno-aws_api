// Autogenerated API client for: AWS Key Management Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class KMS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KMS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2014-11-01",
    "endpointPrefix": "kms",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "KMS",
    "serviceFullName": "AWS Key Management Service",
    "serviceId": "KMS",
    "signatureVersion": "v4",
    "targetPrefix": "TrentService",
    "uid": "kms-2014-11-01"
  };

  async cancelKeyDeletion(
    {abortSignal, ...params}: RequestConfig & s.CancelKeyDeletionRequest,
  ): Promise<s.CancelKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async connectCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & s.ConnectCustomKeyStoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConnectCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomKeyStoreRequest,
  ): Promise<s.CreateCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreName: params["CustomKeyStoreName"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
      TrustAnchorCertificate: params["TrustAnchorCertificate"],
      KeyStorePassword: params["KeyStorePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStoreId": "s",
      },
    }, await resp.json());
  }

  async createGrant(
    {abortSignal, ...params}: RequestConfig & s.CreateGrantRequest,
  ): Promise<s.CreateGrantResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GranteePrincipal: params["GranteePrincipal"],
      RetiringPrincipal: params["RetiringPrincipal"],
      Operations: params["Operations"],
      Constraints: fromGrantConstraints(params["Constraints"]),
      GrantTokens: params["GrantTokens"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGrant",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GrantToken": "s",
        "GrantId": "s",
      },
    }, await resp.json());
  }

  async createKey(
    {abortSignal, ...params}: RequestConfig & s.CreateKeyRequest = {},
  ): Promise<s.CreateKeyResponse> {
    const body: jsonP.JSONObject = {
      Policy: params["Policy"],
      Description: params["Description"],
      KeyUsage: params["KeyUsage"],
      CustomerMasterKeySpec: params["CustomerMasterKeySpec"],
      Origin: params["Origin"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async decrypt(
    {abortSignal, ...params}: RequestConfig & s.DecryptRequest,
  ): Promise<s.DecryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: serializeBlob(params["CiphertextBlob"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      KeyId: params["KeyId"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Decrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Plaintext": "a",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async deleteAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomKeyStoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteImportedKeyMaterial(
    {abortSignal, ...params}: RequestConfig & s.DeleteImportedKeyMaterialRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImportedKeyMaterial",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async describeCustomKeyStores(
    {abortSignal, ...params}: RequestConfig & s.DescribeCustomKeyStoresRequest = {},
  ): Promise<s.DescribeCustomKeyStoresResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      CustomKeyStoreName: params["CustomKeyStoreName"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCustomKeyStores",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStores": [toCustomKeyStoresListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async describeKey(
    {abortSignal, ...params}: RequestConfig & s.DescribeKeyRequest,
  ): Promise<s.DescribeKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async disableKey(
    {abortSignal, ...params}: RequestConfig & s.DisableKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableKey",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async disableKeyRotation(
    {abortSignal, ...params}: RequestConfig & s.DisableKeyRotationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableKeyRotation",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async disconnectCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & s.DisconnectCustomKeyStoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisconnectCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async enableKey(
    {abortSignal, ...params}: RequestConfig & s.EnableKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableKey",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async enableKeyRotation(
    {abortSignal, ...params}: RequestConfig & s.EnableKeyRotationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableKeyRotation",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async encrypt(
    {abortSignal, ...params}: RequestConfig & s.EncryptRequest,
  ): Promise<s.EncryptResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Plaintext: serializeBlob(params["Plaintext"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Encrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKey(
    {abortSignal, ...params}: RequestConfig & s.GenerateDataKeyRequest,
  ): Promise<s.GenerateDataKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      NumberOfBytes: params["NumberOfBytes"],
      KeySpec: params["KeySpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "Plaintext": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateDataKeyPair(
    {abortSignal, ...params}: RequestConfig & s.GenerateDataKeyPairRequest,
  ): Promise<s.GenerateDataKeyPairResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PrivateKeyPlaintext": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyPairWithoutPlaintext(
    {abortSignal, ...params}: RequestConfig & s.GenerateDataKeyPairWithoutPlaintextRequest,
  ): Promise<s.GenerateDataKeyPairWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyPairWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyWithoutPlaintext(
    {abortSignal, ...params}: RequestConfig & s.GenerateDataKeyWithoutPlaintextRequest,
  ): Promise<s.GenerateDataKeyWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      KeySpec: params["KeySpec"],
      NumberOfBytes: params["NumberOfBytes"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateRandom(
    {abortSignal, ...params}: RequestConfig & s.GenerateRandomRequest = {},
  ): Promise<s.GenerateRandomResponse> {
    const body: jsonP.JSONObject = {
      NumberOfBytes: params["NumberOfBytes"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateRandom",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Plaintext": "a",
      },
    }, await resp.json());
  }

  async getKeyPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetKeyPolicyRequest,
  ): Promise<s.GetKeyPolicyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async getKeyRotationStatus(
    {abortSignal, ...params}: RequestConfig & s.GetKeyRotationStatusRequest,
  ): Promise<s.GetKeyRotationStatusResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyRotationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyRotationEnabled": "b",
      },
    }, await resp.json());
  }

  async getParametersForImport(
    {abortSignal, ...params}: RequestConfig & s.GetParametersForImportRequest,
  ): Promise<s.GetParametersForImportResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      WrappingAlgorithm: params["WrappingAlgorithm"],
      WrappingKeySpec: params["WrappingKeySpec"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParametersForImport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "ImportToken": "a",
        "PublicKey": "a",
        "ParametersValidTo": "d",
      },
    }, await resp.json());
  }

  async getPublicKey(
    {abortSignal, ...params}: RequestConfig & s.GetPublicKeyRequest,
  ): Promise<s.GetPublicKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPublicKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "PublicKey": "a",
        "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomerMasterKeySpec>(x),
        "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyUsageType>(x),
        "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x)],
        "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x)],
      },
    }, await resp.json());
  }

  async importKeyMaterial(
    {abortSignal, ...params}: RequestConfig & s.ImportKeyMaterialRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      ImportToken: serializeBlob(params["ImportToken"]),
      EncryptedKeyMaterial: serializeBlob(params["EncryptedKeyMaterial"]),
      ValidTo: jsonP.serializeDate_unixTimestamp(params["ValidTo"]),
      ExpirationModel: params["ExpirationModel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportKeyMaterial",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async listAliases(
    {abortSignal, ...params}: RequestConfig & s.ListAliasesRequest = {},
  ): Promise<s.ListAliasesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Aliases": [toAliasListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listGrants(
    {abortSignal, ...params}: RequestConfig & s.ListGrantsRequest,
  ): Promise<s.ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
      GranteePrincipal: params["GranteePrincipal"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeyPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListKeyPoliciesRequest,
  ): Promise<s.ListKeyPoliciesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListKeyPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyNames": ["s"],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeys(
    {abortSignal, ...params}: RequestConfig & s.ListKeysRequest = {},
  ): Promise<s.ListKeysResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Keys": [toKeyListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listResourceTags(
    {abortSignal, ...params}: RequestConfig & s.ListResourceTagsRequest,
  ): Promise<s.ListResourceTagsResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourceTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listRetirableGrants(
    {abortSignal, ...params}: RequestConfig & s.ListRetirableGrantsRequest,
  ): Promise<s.ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      RetiringPrincipal: params["RetiringPrincipal"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRetirableGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async putKeyPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutKeyPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
      Policy: params["Policy"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutKeyPolicy",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async reEncrypt(
    {abortSignal, ...params}: RequestConfig & s.ReEncryptRequest,
  ): Promise<s.ReEncryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: serializeBlob(params["CiphertextBlob"]),
      SourceEncryptionContext: params["SourceEncryptionContext"],
      SourceKeyId: params["SourceKeyId"],
      DestinationKeyId: params["DestinationKeyId"],
      DestinationEncryptionContext: params["DestinationEncryptionContext"],
      SourceEncryptionAlgorithm: params["SourceEncryptionAlgorithm"],
      DestinationEncryptionAlgorithm: params["DestinationEncryptionAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReEncrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "SourceKeyId": "s",
        "KeyId": "s",
        "SourceEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
        "DestinationEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async retireGrant(
    {abortSignal, ...params}: RequestConfig & s.RetireGrantRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GrantToken: params["GrantToken"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetireGrant",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async revokeGrant(
    {abortSignal, ...params}: RequestConfig & s.RevokeGrantRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeGrant",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async scheduleKeyDeletion(
    {abortSignal, ...params}: RequestConfig & s.ScheduleKeyDeletionRequest,
  ): Promise<s.ScheduleKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PendingWindowInDays: params["PendingWindowInDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ScheduleKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "DeletionDate": "d",
      },
    }, await resp.json());
  }

  async sign(
    {abortSignal, ...params}: RequestConfig & s.SignRequest,
  ): Promise<s.SignResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      GrantTokens: params["GrantTokens"],
      SigningAlgorithm: params["SigningAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Sign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Signature": "a",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAlias",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & s.UpdateCustomKeyStoreRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      NewCustomKeyStoreName: params["NewCustomKeyStoreName"],
      KeyStorePassword: params["KeyStorePassword"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCustomKeyStore",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async updateKeyDescription(
    {abortSignal, ...params}: RequestConfig & s.UpdateKeyDescriptionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateKeyDescription",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async verify(
    {abortSignal, ...params}: RequestConfig & s.VerifyRequest,
  ): Promise<s.VerifyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      Signature: serializeBlob(params["Signature"]),
      SigningAlgorithm: params["SigningAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Verify",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "SignatureValid": "b",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

}

function fromGrantConstraints(input?: s.GrantConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionContextSubset: input["EncryptionContextSubset"],
    EncryptionContextEquals: input["EncryptionContextEquals"],
  }
}
function toGrantConstraints(root: jsonP.JSONValue): s.GrantConstraints {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionContextSubset": x => jsonP.readMap(String, String, x),
      "EncryptionContextEquals": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TagKey: input["TagKey"],
    TagValue: input["TagValue"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "TagKey": "s",
      "TagValue": "s",
    },
    optional: {},
  }, root);
}

function toKeyMetadata(root: jsonP.JSONValue): s.KeyMetadata {
  return jsonP.readObj({
    required: {
      "KeyId": "s",
    },
    optional: {
      "AWSAccountId": "s",
      "Arn": "s",
      "CreationDate": "d",
      "Enabled": "b",
      "Description": "s",
      "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyUsageType>(x),
      "KeyState": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyState>(x),
      "DeletionDate": "d",
      "ValidTo": "d",
      "Origin": (x: jsonP.JSONValue) => cmnP.readEnum<s.OriginType>(x),
      "CustomKeyStoreId": "s",
      "CloudHsmClusterId": "s",
      "ExpirationModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExpirationModelType>(x),
      "KeyManager": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyManagerType>(x),
      "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<s.CustomerMasterKeySpec>(x),
      "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionAlgorithmSpec>(x)],
      "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.SigningAlgorithmSpec>(x)],
    },
  }, root);
}

function toCustomKeyStoresListEntry(root: jsonP.JSONValue): s.CustomKeyStoresListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomKeyStoreId": "s",
      "CustomKeyStoreName": "s",
      "CloudHsmClusterId": "s",
      "TrustAnchorCertificate": "s",
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionStateType>(x),
      "ConnectionErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionErrorCodeType>(x),
      "CreationDate": "d",
    },
  }, root);
}

function toAliasListEntry(root: jsonP.JSONValue): s.AliasListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasName": "s",
      "AliasArn": "s",
      "TargetKeyId": "s",
      "CreationDate": "d",
      "LastUpdatedDate": "d",
    },
  }, root);
}

function toGrantListEntry(root: jsonP.JSONValue): s.GrantListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "GrantId": "s",
      "Name": "s",
      "CreationDate": "d",
      "GranteePrincipal": "s",
      "RetiringPrincipal": "s",
      "IssuingAccount": "s",
      "Operations": [(x: jsonP.JSONValue) => cmnP.readEnum<s.GrantOperation>(x)],
      "Constraints": toGrantConstraints,
    },
  }, root);
}

function toKeyListEntry(root: jsonP.JSONValue): s.KeyListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "KeyArn": "s",
    },
  }, root);
}
