// Autogenerated API client for: AWS Key Management Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class KMS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KMS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2014-11-01",
    "endpointPrefix": "kms",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "KMS",
    "serviceFullName": "AWS Key Management Service",
    "serviceId": "KMS",
    "signatureVersion": "v4",
    "targetPrefix": "TrentService",
    "uid": "kms-2014-11-01"
  };

  async cancelKeyDeletion(
    {abortSignal, ...params}: RequestConfig & CancelKeyDeletionRequest,
  ): Promise<CancelKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async connectCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & ConnectCustomKeyStoreRequest,
  ): Promise<ConnectCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConnectCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & CreateAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
    });
  }

  async createCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & CreateCustomKeyStoreRequest,
  ): Promise<CreateCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreName: params["CustomKeyStoreName"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
      TrustAnchorCertificate: params["TrustAnchorCertificate"],
      KeyStorePassword: params["KeyStorePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStoreId": "s",
      },
    }, await resp.json());
  }

  async createGrant(
    {abortSignal, ...params}: RequestConfig & CreateGrantRequest,
  ): Promise<CreateGrantResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GranteePrincipal: params["GranteePrincipal"],
      RetiringPrincipal: params["RetiringPrincipal"],
      Operations: params["Operations"],
      Constraints: fromGrantConstraints(params["Constraints"]),
      GrantTokens: params["GrantTokens"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateGrant",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GrantToken": "s",
        "GrantId": "s",
      },
    }, await resp.json());
  }

  async createKey(
    {abortSignal, ...params}: RequestConfig & CreateKeyRequest = {},
  ): Promise<CreateKeyResponse> {
    const body: jsonP.JSONObject = {
      Policy: params["Policy"],
      Description: params["Description"],
      KeyUsage: params["KeyUsage"],
      CustomerMasterKeySpec: params["CustomerMasterKeySpec"],
      Origin: params["Origin"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async decrypt(
    {abortSignal, ...params}: RequestConfig & DecryptRequest,
  ): Promise<DecryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: jsonP.serializeBlob(params["CiphertextBlob"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      KeyId: params["KeyId"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Decrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Plaintext": "a",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async deleteAlias(
    {abortSignal, ...params}: RequestConfig & DeleteAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlias",
    });
  }

  async deleteCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & DeleteCustomKeyStoreRequest,
  ): Promise<DeleteCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImportedKeyMaterial(
    {abortSignal, ...params}: RequestConfig & DeleteImportedKeyMaterialRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImportedKeyMaterial",
    });
  }

  async describeCustomKeyStores(
    {abortSignal, ...params}: RequestConfig & DescribeCustomKeyStoresRequest = {},
  ): Promise<DescribeCustomKeyStoresResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      CustomKeyStoreName: params["CustomKeyStoreName"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCustomKeyStores",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomKeyStores": [toCustomKeyStoresListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async describeKey(
    {abortSignal, ...params}: RequestConfig & DescribeKeyRequest,
  ): Promise<DescribeKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyMetadata": toKeyMetadata,
      },
    }, await resp.json());
  }

  async disableKey(
    {abortSignal, ...params}: RequestConfig & DisableKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableKey",
    });
  }

  async disableKeyRotation(
    {abortSignal, ...params}: RequestConfig & DisableKeyRotationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableKeyRotation",
    });
  }

  async disconnectCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & DisconnectCustomKeyStoreRequest,
  ): Promise<DisconnectCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisconnectCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async enableKey(
    {abortSignal, ...params}: RequestConfig & EnableKeyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableKey",
    });
  }

  async enableKeyRotation(
    {abortSignal, ...params}: RequestConfig & EnableKeyRotationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableKeyRotation",
    });
  }

  async encrypt(
    {abortSignal, ...params}: RequestConfig & EncryptRequest,
  ): Promise<EncryptResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Plaintext: jsonP.serializeBlob(params["Plaintext"]),
      EncryptionContext: params["EncryptionContext"],
      GrantTokens: params["GrantTokens"],
      EncryptionAlgorithm: params["EncryptionAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Encrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
        "EncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKey(
    {abortSignal, ...params}: RequestConfig & GenerateDataKeyRequest,
  ): Promise<GenerateDataKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      NumberOfBytes: params["NumberOfBytes"],
      KeySpec: params["KeySpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "Plaintext": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateDataKeyPair(
    {abortSignal, ...params}: RequestConfig & GenerateDataKeyPairRequest,
  ): Promise<GenerateDataKeyPairResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PrivateKeyPlaintext": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyPairWithoutPlaintext(
    {abortSignal, ...params}: RequestConfig & GenerateDataKeyPairWithoutPlaintextRequest,
  ): Promise<GenerateDataKeyPairWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      EncryptionContext: params["EncryptionContext"],
      KeyId: params["KeyId"],
      KeyPairSpec: params["KeyPairSpec"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyPairWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PrivateKeyCiphertextBlob": "a",
        "PublicKey": "a",
        "KeyId": "s",
        "KeyPairSpec": (x: jsonP.JSONValue) => cmnP.readEnum<DataKeyPairSpec>(x),
      },
    }, await resp.json());
  }

  async generateDataKeyWithoutPlaintext(
    {abortSignal, ...params}: RequestConfig & GenerateDataKeyWithoutPlaintextRequest,
  ): Promise<GenerateDataKeyWithoutPlaintextResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      EncryptionContext: params["EncryptionContext"],
      KeySpec: params["KeySpec"],
      NumberOfBytes: params["NumberOfBytes"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateDataKeyWithoutPlaintext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "KeyId": "s",
      },
    }, await resp.json());
  }

  async generateRandom(
    {abortSignal, ...params}: RequestConfig & GenerateRandomRequest = {},
  ): Promise<GenerateRandomResponse> {
    const body: jsonP.JSONObject = {
      NumberOfBytes: params["NumberOfBytes"],
      CustomKeyStoreId: params["CustomKeyStoreId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GenerateRandom",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Plaintext": "a",
      },
    }, await resp.json());
  }

  async getKeyPolicy(
    {abortSignal, ...params}: RequestConfig & GetKeyPolicyRequest,
  ): Promise<GetKeyPolicyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async getKeyRotationStatus(
    {abortSignal, ...params}: RequestConfig & GetKeyRotationStatusRequest,
  ): Promise<GetKeyRotationStatusResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyRotationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyRotationEnabled": "b",
      },
    }, await resp.json());
  }

  async getParametersForImport(
    {abortSignal, ...params}: RequestConfig & GetParametersForImportRequest,
  ): Promise<GetParametersForImportResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      WrappingAlgorithm: params["WrappingAlgorithm"],
      WrappingKeySpec: params["WrappingKeySpec"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParametersForImport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "ImportToken": "a",
        "PublicKey": "a",
        "ParametersValidTo": "d",
      },
    }, await resp.json());
  }

  async getPublicKey(
    {abortSignal, ...params}: RequestConfig & GetPublicKeyRequest,
  ): Promise<GetPublicKeyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPublicKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "PublicKey": "a",
        "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<CustomerMasterKeySpec>(x),
        "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<KeyUsageType>(x),
        "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x)],
        "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<SigningAlgorithmSpec>(x)],
      },
    }, await resp.json());
  }

  async importKeyMaterial(
    {abortSignal, ...params}: RequestConfig & ImportKeyMaterialRequest,
  ): Promise<ImportKeyMaterialResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      ImportToken: jsonP.serializeBlob(params["ImportToken"]),
      EncryptedKeyMaterial: jsonP.serializeBlob(params["EncryptedKeyMaterial"]),
      ValidTo: jsonP.serializeDate_unixTimestamp(params["ValidTo"]),
      ExpirationModel: params["ExpirationModel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportKeyMaterial",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listAliases(
    {abortSignal, ...params}: RequestConfig & ListAliasesRequest = {},
  ): Promise<ListAliasesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAliases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Aliases": [toAliasListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listGrants(
    {abortSignal, ...params}: RequestConfig & ListGrantsRequest,
  ): Promise<ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
      GranteePrincipal: params["GranteePrincipal"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeyPolicies(
    {abortSignal, ...params}: RequestConfig & ListKeyPoliciesRequest,
  ): Promise<ListKeyPoliciesResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListKeyPolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyNames": ["s"],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listKeys(
    {abortSignal, ...params}: RequestConfig & ListKeysRequest = {},
  ): Promise<ListKeysResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Keys": [toKeyListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listResourceTags(
    {abortSignal, ...params}: RequestConfig & ListResourceTagsRequest,
  ): Promise<ListResourceTagsResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Limit: params["Limit"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourceTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async listRetirableGrants(
    {abortSignal, ...params}: RequestConfig & ListRetirableGrantsRequest,
  ): Promise<ListGrantsResponse> {
    const body: jsonP.JSONObject = {
      Limit: params["Limit"],
      Marker: params["Marker"],
      RetiringPrincipal: params["RetiringPrincipal"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRetirableGrants",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Grants": [toGrantListEntry],
        "NextMarker": "s",
        "Truncated": "b",
      },
    }, await resp.json());
  }

  async putKeyPolicy(
    {abortSignal, ...params}: RequestConfig & PutKeyPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PolicyName: params["PolicyName"],
      Policy: params["Policy"],
      BypassPolicyLockoutSafetyCheck: params["BypassPolicyLockoutSafetyCheck"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutKeyPolicy",
    });
  }

  async reEncrypt(
    {abortSignal, ...params}: RequestConfig & ReEncryptRequest,
  ): Promise<ReEncryptResponse> {
    const body: jsonP.JSONObject = {
      CiphertextBlob: jsonP.serializeBlob(params["CiphertextBlob"]),
      SourceEncryptionContext: params["SourceEncryptionContext"],
      SourceKeyId: params["SourceKeyId"],
      DestinationKeyId: params["DestinationKeyId"],
      DestinationEncryptionContext: params["DestinationEncryptionContext"],
      SourceEncryptionAlgorithm: params["SourceEncryptionAlgorithm"],
      DestinationEncryptionAlgorithm: params["DestinationEncryptionAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReEncrypt",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CiphertextBlob": "a",
        "SourceKeyId": "s",
        "KeyId": "s",
        "SourceEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x),
        "DestinationEncryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async retireGrant(
    {abortSignal, ...params}: RequestConfig & RetireGrantRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GrantToken: params["GrantToken"],
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetireGrant",
    });
  }

  async revokeGrant(
    {abortSignal, ...params}: RequestConfig & RevokeGrantRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      GrantId: params["GrantId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeGrant",
    });
  }

  async scheduleKeyDeletion(
    {abortSignal, ...params}: RequestConfig & ScheduleKeyDeletionRequest,
  ): Promise<ScheduleKeyDeletionResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      PendingWindowInDays: params["PendingWindowInDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ScheduleKeyDeletion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "DeletionDate": "d",
      },
    }, await resp.json());
  }

  async sign(
    {abortSignal, ...params}: RequestConfig & SignRequest,
  ): Promise<SignResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: jsonP.serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      GrantTokens: params["GrantTokens"],
      SigningAlgorithm: params["SigningAlgorithm"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Sign",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "Signature": "a",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
  }

  async updateAlias(
    {abortSignal, ...params}: RequestConfig & UpdateAliasRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AliasName: params["AliasName"],
      TargetKeyId: params["TargetKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAlias",
    });
  }

  async updateCustomKeyStore(
    {abortSignal, ...params}: RequestConfig & UpdateCustomKeyStoreRequest,
  ): Promise<UpdateCustomKeyStoreResponse> {
    const body: jsonP.JSONObject = {
      CustomKeyStoreId: params["CustomKeyStoreId"],
      NewCustomKeyStoreName: params["NewCustomKeyStoreName"],
      KeyStorePassword: params["KeyStorePassword"],
      CloudHsmClusterId: params["CloudHsmClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCustomKeyStore",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateKeyDescription(
    {abortSignal, ...params}: RequestConfig & UpdateKeyDescriptionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateKeyDescription",
    });
  }

  async verify(
    {abortSignal, ...params}: RequestConfig & VerifyRequest,
  ): Promise<VerifyResponse> {
    const body: jsonP.JSONObject = {
      KeyId: params["KeyId"],
      Message: jsonP.serializeBlob(params["Message"]),
      MessageType: params["MessageType"],
      Signature: jsonP.serializeBlob(params["Signature"]),
      SigningAlgorithm: params["SigningAlgorithm"],
      GrantTokens: params["GrantTokens"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Verify",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "KeyId": "s",
        "SignatureValid": "b",
        "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<SigningAlgorithmSpec>(x),
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CancelKeyDeletionRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface ConnectCustomKeyStoreRequest {
  CustomKeyStoreId: string;
}

// refs: 1 - tags: named, input
export interface CreateAliasRequest {
  AliasName: string;
  TargetKeyId: string;
}

// refs: 1 - tags: named, input
export interface CreateCustomKeyStoreRequest {
  CustomKeyStoreName: string;
  CloudHsmClusterId: string;
  TrustAnchorCertificate: string;
  KeyStorePassword: string;
}

// refs: 1 - tags: named, input
export interface CreateGrantRequest {
  KeyId: string;
  GranteePrincipal: string;
  RetiringPrincipal?: string | null;
  Operations: GrantOperation[];
  Constraints?: GrantConstraints | null;
  GrantTokens?: string[] | null;
  Name?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateKeyRequest {
  Policy?: string | null;
  Description?: string | null;
  KeyUsage?: KeyUsageType | null;
  CustomerMasterKeySpec?: CustomerMasterKeySpec | null;
  Origin?: OriginType | null;
  CustomKeyStoreId?: string | null;
  BypassPolicyLockoutSafetyCheck?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DecryptRequest {
  CiphertextBlob: Uint8Array | string;
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  GrantTokens?: string[] | null;
  KeyId?: string | null;
  EncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
}

// refs: 1 - tags: named, input
export interface DeleteAliasRequest {
  AliasName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCustomKeyStoreRequest {
  CustomKeyStoreId: string;
}

// refs: 1 - tags: named, input
export interface DeleteImportedKeyMaterialRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface DescribeCustomKeyStoresRequest {
  CustomKeyStoreId?: string | null;
  CustomKeyStoreName?: string | null;
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeKeyRequest {
  KeyId: string;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DisableKeyRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface DisableKeyRotationRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface DisconnectCustomKeyStoreRequest {
  CustomKeyStoreId: string;
}

// refs: 1 - tags: named, input
export interface EnableKeyRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface EnableKeyRotationRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface EncryptRequest {
  KeyId: string;
  Plaintext: Uint8Array | string;
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  GrantTokens?: string[] | null;
  EncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
}

// refs: 1 - tags: named, input
export interface GenerateDataKeyRequest {
  KeyId: string;
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  NumberOfBytes?: number | null;
  KeySpec?: DataKeySpec | null;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GenerateDataKeyPairRequest {
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  KeyId: string;
  KeyPairSpec: DataKeyPairSpec;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GenerateDataKeyPairWithoutPlaintextRequest {
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  KeyId: string;
  KeyPairSpec: DataKeyPairSpec;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GenerateDataKeyWithoutPlaintextRequest {
  KeyId: string;
  EncryptionContext?: { [key: string]: string | null | undefined } | null;
  KeySpec?: DataKeySpec | null;
  NumberOfBytes?: number | null;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface GenerateRandomRequest {
  NumberOfBytes?: number | null;
  CustomKeyStoreId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetKeyPolicyRequest {
  KeyId: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface GetKeyRotationStatusRequest {
  KeyId: string;
}

// refs: 1 - tags: named, input
export interface GetParametersForImportRequest {
  KeyId: string;
  WrappingAlgorithm: AlgorithmSpec;
  WrappingKeySpec: WrappingKeySpec;
}

// refs: 1 - tags: named, input
export interface GetPublicKeyRequest {
  KeyId: string;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ImportKeyMaterialRequest {
  KeyId: string;
  ImportToken: Uint8Array | string;
  EncryptedKeyMaterial: Uint8Array | string;
  ValidTo?: Date | number | null;
  ExpirationModel?: ExpirationModelType | null;
}

// refs: 1 - tags: named, input
export interface ListAliasesRequest {
  KeyId?: string | null;
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListGrantsRequest {
  Limit?: number | null;
  Marker?: string | null;
  KeyId: string;
  GrantId?: string | null;
  GranteePrincipal?: string | null;
}

// refs: 1 - tags: named, input
export interface ListKeyPoliciesRequest {
  KeyId: string;
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListKeysRequest {
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListResourceTagsRequest {
  KeyId: string;
  Limit?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListRetirableGrantsRequest {
  Limit?: number | null;
  Marker?: string | null;
  RetiringPrincipal: string;
}

// refs: 1 - tags: named, input
export interface PutKeyPolicyRequest {
  KeyId: string;
  PolicyName: string;
  Policy: string;
  BypassPolicyLockoutSafetyCheck?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ReEncryptRequest {
  CiphertextBlob: Uint8Array | string;
  SourceEncryptionContext?: { [key: string]: string | null | undefined } | null;
  SourceKeyId?: string | null;
  DestinationKeyId: string;
  DestinationEncryptionContext?: { [key: string]: string | null | undefined } | null;
  SourceEncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
  DestinationEncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, input
export interface RetireGrantRequest {
  GrantToken?: string | null;
  KeyId?: string | null;
  GrantId?: string | null;
}

// refs: 1 - tags: named, input
export interface RevokeGrantRequest {
  KeyId: string;
  GrantId: string;
}

// refs: 1 - tags: named, input
export interface ScheduleKeyDeletionRequest {
  KeyId: string;
  PendingWindowInDays?: number | null;
}

// refs: 1 - tags: named, input
export interface SignRequest {
  KeyId: string;
  Message: Uint8Array | string;
  MessageType?: MessageType | null;
  GrantTokens?: string[] | null;
  SigningAlgorithm: SigningAlgorithmSpec;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  KeyId: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  KeyId: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAliasRequest {
  AliasName: string;
  TargetKeyId: string;
}

// refs: 1 - tags: named, input
export interface UpdateCustomKeyStoreRequest {
  CustomKeyStoreId: string;
  NewCustomKeyStoreName?: string | null;
  KeyStorePassword?: string | null;
  CloudHsmClusterId?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateKeyDescriptionRequest {
  KeyId: string;
  Description: string;
}

// refs: 1 - tags: named, input
export interface VerifyRequest {
  KeyId: string;
  Message: Uint8Array | string;
  MessageType?: MessageType | null;
  Signature: Uint8Array | string;
  SigningAlgorithm: SigningAlgorithmSpec;
  GrantTokens?: string[] | null;
}

// refs: 1 - tags: named, output
export interface CancelKeyDeletionResponse {
  KeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface ConnectCustomKeyStoreResponse {
}

// refs: 1 - tags: named, output
export interface CreateCustomKeyStoreResponse {
  CustomKeyStoreId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateGrantResponse {
  GrantToken?: string | null;
  GrantId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateKeyResponse {
  KeyMetadata?: KeyMetadata | null;
}

// refs: 1 - tags: named, output
export interface DecryptResponse {
  KeyId?: string | null;
  Plaintext?: Uint8Array | string | null;
  EncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
}

// refs: 1 - tags: named, output
export interface DeleteCustomKeyStoreResponse {
}

// refs: 1 - tags: named, output
export interface DescribeCustomKeyStoresResponse {
  CustomKeyStores?: CustomKeyStoresListEntry[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeKeyResponse {
  KeyMetadata?: KeyMetadata | null;
}

// refs: 1 - tags: named, output
export interface DisconnectCustomKeyStoreResponse {
}

// refs: 1 - tags: named, output
export interface EncryptResponse {
  CiphertextBlob?: Uint8Array | string | null;
  KeyId?: string | null;
  EncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
}

// refs: 1 - tags: named, output
export interface GenerateDataKeyResponse {
  CiphertextBlob?: Uint8Array | string | null;
  Plaintext?: Uint8Array | string | null;
  KeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface GenerateDataKeyPairResponse {
  PrivateKeyCiphertextBlob?: Uint8Array | string | null;
  PrivateKeyPlaintext?: Uint8Array | string | null;
  PublicKey?: Uint8Array | string | null;
  KeyId?: string | null;
  KeyPairSpec?: DataKeyPairSpec | null;
}

// refs: 1 - tags: named, output
export interface GenerateDataKeyPairWithoutPlaintextResponse {
  PrivateKeyCiphertextBlob?: Uint8Array | string | null;
  PublicKey?: Uint8Array | string | null;
  KeyId?: string | null;
  KeyPairSpec?: DataKeyPairSpec | null;
}

// refs: 1 - tags: named, output
export interface GenerateDataKeyWithoutPlaintextResponse {
  CiphertextBlob?: Uint8Array | string | null;
  KeyId?: string | null;
}

// refs: 1 - tags: named, output
export interface GenerateRandomResponse {
  Plaintext?: Uint8Array | string | null;
}

// refs: 1 - tags: named, output
export interface GetKeyPolicyResponse {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetKeyRotationStatusResponse {
  KeyRotationEnabled?: boolean | null;
}

// refs: 1 - tags: named, output
export interface GetParametersForImportResponse {
  KeyId?: string | null;
  ImportToken?: Uint8Array | string | null;
  PublicKey?: Uint8Array | string | null;
  ParametersValidTo?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetPublicKeyResponse {
  KeyId?: string | null;
  PublicKey?: Uint8Array | string | null;
  CustomerMasterKeySpec?: CustomerMasterKeySpec | null;
  KeyUsage?: KeyUsageType | null;
  EncryptionAlgorithms?: EncryptionAlgorithmSpec[] | null;
  SigningAlgorithms?: SigningAlgorithmSpec[] | null;
}

// refs: 1 - tags: named, output
export interface ImportKeyMaterialResponse {
}

// refs: 1 - tags: named, output
export interface ListAliasesResponse {
  Aliases?: AliasListEntry[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ListGrantsResponse {
  Grants?: GrantListEntry[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ListKeyPoliciesResponse {
  PolicyNames?: string[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ListKeysResponse {
  Keys?: KeyListEntry[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ListResourceTagsResponse {
  Tags?: Tag[] | null;
  NextMarker?: string | null;
  Truncated?: boolean | null;
}

// refs: 1 - tags: named, output
export interface ReEncryptResponse {
  CiphertextBlob?: Uint8Array | string | null;
  SourceKeyId?: string | null;
  KeyId?: string | null;
  SourceEncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
  DestinationEncryptionAlgorithm?: EncryptionAlgorithmSpec | null;
}

// refs: 1 - tags: named, output
export interface ScheduleKeyDeletionResponse {
  KeyId?: string | null;
  DeletionDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface SignResponse {
  KeyId?: string | null;
  Signature?: Uint8Array | string | null;
  SigningAlgorithm?: SigningAlgorithmSpec | null;
}

// refs: 1 - tags: named, output
export interface UpdateCustomKeyStoreResponse {
}

// refs: 1 - tags: named, output
export interface VerifyResponse {
  KeyId?: string | null;
  SignatureValid?: boolean | null;
  SigningAlgorithm?: SigningAlgorithmSpec | null;
}

// refs: 2 - tags: input, named, enum, output
export type GrantOperation =
| "Decrypt"
| "Encrypt"
| "GenerateDataKey"
| "GenerateDataKeyWithoutPlaintext"
| "ReEncryptFrom"
| "ReEncryptTo"
| "Sign"
| "Verify"
| "GetPublicKey"
| "CreateGrant"
| "RetireGrant"
| "DescribeKey"
| "GenerateDataKeyPair"
| "GenerateDataKeyPairWithoutPlaintext"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface GrantConstraints {
  EncryptionContextSubset?: { [key: string]: string | null | undefined } | null;
  EncryptionContextEquals?: { [key: string]: string | null | undefined } | null;
}
function fromGrantConstraints(input?: GrantConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionContextSubset: input["EncryptionContextSubset"],
    EncryptionContextEquals: input["EncryptionContextEquals"],
  }
}
function toGrantConstraints(root: jsonP.JSONValue): GrantConstraints {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionContextSubset": x => jsonP.readMap(String, String, x),
      "EncryptionContextEquals": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type KeyUsageType =
| "SIGN_VERIFY"
| "ENCRYPT_DECRYPT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type CustomerMasterKeySpec =
| "RSA_2048"
| "RSA_3072"
| "RSA_4096"
| "ECC_NIST_P256"
| "ECC_NIST_P384"
| "ECC_NIST_P521"
| "ECC_SECG_P256K1"
| "SYMMETRIC_DEFAULT"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type OriginType =
| "AWS_KMS"
| "EXTERNAL"
| "AWS_CLOUDHSM"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  TagKey: string;
  TagValue: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TagKey: input["TagKey"],
    TagValue: input["TagValue"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "TagKey": "s",
      "TagValue": "s",
    },
    optional: {},
  }, root);
}

// refs: 11 - tags: input, named, enum, output
export type EncryptionAlgorithmSpec =
| "SYMMETRIC_DEFAULT"
| "RSAES_OAEP_SHA_1"
| "RSAES_OAEP_SHA_256"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type DataKeySpec =
| "AES_256"
| "AES_128"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type DataKeyPairSpec =
| "RSA_2048"
| "RSA_3072"
| "RSA_4096"
| "ECC_NIST_P256"
| "ECC_NIST_P384"
| "ECC_NIST_P521"
| "ECC_SECG_P256K1"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type AlgorithmSpec =
| "RSAES_PKCS1_V1_5"
| "RSAES_OAEP_SHA_1"
| "RSAES_OAEP_SHA_256"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type WrappingKeySpec =
| "RSA_2048"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ExpirationModelType =
| "KEY_MATERIAL_EXPIRES"
| "KEY_MATERIAL_DOES_NOT_EXPIRE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type MessageType =
| "RAW"
| "DIGEST"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type SigningAlgorithmSpec =
| "RSASSA_PSS_SHA_256"
| "RSASSA_PSS_SHA_384"
| "RSASSA_PSS_SHA_512"
| "RSASSA_PKCS1_V1_5_SHA_256"
| "RSASSA_PKCS1_V1_5_SHA_384"
| "RSASSA_PKCS1_V1_5_SHA_512"
| "ECDSA_SHA_256"
| "ECDSA_SHA_384"
| "ECDSA_SHA_512"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface KeyMetadata {
  AWSAccountId?: string | null;
  KeyId: string;
  Arn?: string | null;
  CreationDate?: Date | number | null;
  Enabled?: boolean | null;
  Description?: string | null;
  KeyUsage?: KeyUsageType | null;
  KeyState?: KeyState | null;
  DeletionDate?: Date | number | null;
  ValidTo?: Date | number | null;
  Origin?: OriginType | null;
  CustomKeyStoreId?: string | null;
  CloudHsmClusterId?: string | null;
  ExpirationModel?: ExpirationModelType | null;
  KeyManager?: KeyManagerType | null;
  CustomerMasterKeySpec?: CustomerMasterKeySpec | null;
  EncryptionAlgorithms?: EncryptionAlgorithmSpec[] | null;
  SigningAlgorithms?: SigningAlgorithmSpec[] | null;
}
function toKeyMetadata(root: jsonP.JSONValue): KeyMetadata {
  return jsonP.readObj({
    required: {
      "KeyId": "s",
    },
    optional: {
      "AWSAccountId": "s",
      "Arn": "s",
      "CreationDate": "d",
      "Enabled": "b",
      "Description": "s",
      "KeyUsage": (x: jsonP.JSONValue) => cmnP.readEnum<KeyUsageType>(x),
      "KeyState": (x: jsonP.JSONValue) => cmnP.readEnum<KeyState>(x),
      "DeletionDate": "d",
      "ValidTo": "d",
      "Origin": (x: jsonP.JSONValue) => cmnP.readEnum<OriginType>(x),
      "CustomKeyStoreId": "s",
      "CloudHsmClusterId": "s",
      "ExpirationModel": (x: jsonP.JSONValue) => cmnP.readEnum<ExpirationModelType>(x),
      "KeyManager": (x: jsonP.JSONValue) => cmnP.readEnum<KeyManagerType>(x),
      "CustomerMasterKeySpec": (x: jsonP.JSONValue) => cmnP.readEnum<CustomerMasterKeySpec>(x),
      "EncryptionAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithmSpec>(x)],
      "SigningAlgorithms": [(x: jsonP.JSONValue) => cmnP.readEnum<SigningAlgorithmSpec>(x)],
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type KeyState =
| "Enabled"
| "Disabled"
| "PendingDeletion"
| "PendingImport"
| "Unavailable"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type KeyManagerType =
| "AWS"
| "CUSTOMER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CustomKeyStoresListEntry {
  CustomKeyStoreId?: string | null;
  CustomKeyStoreName?: string | null;
  CloudHsmClusterId?: string | null;
  TrustAnchorCertificate?: string | null;
  ConnectionState?: ConnectionStateType | null;
  ConnectionErrorCode?: ConnectionErrorCodeType | null;
  CreationDate?: Date | number | null;
}
function toCustomKeyStoresListEntry(root: jsonP.JSONValue): CustomKeyStoresListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomKeyStoreId": "s",
      "CustomKeyStoreName": "s",
      "CloudHsmClusterId": "s",
      "TrustAnchorCertificate": "s",
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionStateType>(x),
      "ConnectionErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionErrorCodeType>(x),
      "CreationDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ConnectionStateType =
| "CONNECTED"
| "CONNECTING"
| "FAILED"
| "DISCONNECTED"
| "DISCONNECTING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type ConnectionErrorCodeType =
| "INVALID_CREDENTIALS"
| "CLUSTER_NOT_FOUND"
| "NETWORK_ERRORS"
| "INTERNAL_ERROR"
| "INSUFFICIENT_CLOUDHSM_HSMS"
| "USER_LOCKED_OUT"
| "USER_NOT_FOUND"
| "USER_LOGGED_IN"
| "SUBNET_NOT_FOUND"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AliasListEntry {
  AliasName?: string | null;
  AliasArn?: string | null;
  TargetKeyId?: string | null;
  CreationDate?: Date | number | null;
  LastUpdatedDate?: Date | number | null;
}
function toAliasListEntry(root: jsonP.JSONValue): AliasListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasName": "s",
      "AliasArn": "s",
      "TargetKeyId": "s",
      "CreationDate": "d",
      "LastUpdatedDate": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface GrantListEntry {
  KeyId?: string | null;
  GrantId?: string | null;
  Name?: string | null;
  CreationDate?: Date | number | null;
  GranteePrincipal?: string | null;
  RetiringPrincipal?: string | null;
  IssuingAccount?: string | null;
  Operations?: GrantOperation[] | null;
  Constraints?: GrantConstraints | null;
}
function toGrantListEntry(root: jsonP.JSONValue): GrantListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "GrantId": "s",
      "Name": "s",
      "CreationDate": "d",
      "GranteePrincipal": "s",
      "RetiringPrincipal": "s",
      "IssuingAccount": "s",
      "Operations": [(x: jsonP.JSONValue) => cmnP.readEnum<GrantOperation>(x)],
      "Constraints": toGrantConstraints,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface KeyListEntry {
  KeyId?: string | null;
  KeyArn?: string | null;
}
function toKeyListEntry(root: jsonP.JSONValue): KeyListEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyId": "s",
      "KeyArn": "s",
    },
  }, root);
}
