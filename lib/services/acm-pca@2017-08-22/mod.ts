// Autogenerated API client for: AWS Certificate Manager Private Certificate Authority

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ACMPCA {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ACMPCA.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-08-22",
    "endpointPrefix": "acm-pca",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "ACM-PCA",
    "serviceFullName": "AWS Certificate Manager Private Certificate Authority",
    "serviceId": "ACM PCA",
    "signatureVersion": "v4",
    "targetPrefix": "ACMPrivateCA",
    "uid": "acm-pca-2017-08-22"
  };

  async createCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & CreateCertificateAuthorityRequest,
  ): Promise<CreateCertificateAuthorityResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityConfiguration: fromCertificateAuthorityConfiguration(params["CertificateAuthorityConfiguration"]),
      RevocationConfiguration: fromRevocationConfiguration(params["RevocationConfiguration"]),
      CertificateAuthorityType: params["CertificateAuthorityType"],
      IdempotencyToken: params["IdempotencyToken"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCertificateAuthority",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateAuthorityArn": "s",
      },
    }, await resp.json());
  }

  async createCertificateAuthorityAuditReport(
    {abortSignal, ...params}: RequestConfig & CreateCertificateAuthorityAuditReportRequest,
  ): Promise<CreateCertificateAuthorityAuditReportResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      S3BucketName: params["S3BucketName"],
      AuditReportResponseFormat: params["AuditReportResponseFormat"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCertificateAuthorityAuditReport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuditReportId": "s",
        "S3Key": "s",
      },
    }, await resp.json());
  }

  async createPermission(
    {abortSignal, ...params}: RequestConfig & CreatePermissionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Principal: params["Principal"],
      SourceAccount: params["SourceAccount"],
      Actions: params["Actions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePermission",
    });
  }

  async deleteCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & DeleteCertificateAuthorityRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      PermanentDeletionTimeInDays: params["PermanentDeletionTimeInDays"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCertificateAuthority",
    });
  }

  async deletePermission(
    {abortSignal, ...params}: RequestConfig & DeletePermissionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Principal: params["Principal"],
      SourceAccount: params["SourceAccount"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePermission",
    });
  }

  async deletePolicy(
    {abortSignal, ...params}: RequestConfig & DeletePolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePolicy",
    });
  }

  async describeCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & DescribeCertificateAuthorityRequest,
  ): Promise<DescribeCertificateAuthorityResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificateAuthority",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateAuthority": toCertificateAuthority,
      },
    }, await resp.json());
  }

  async describeCertificateAuthorityAuditReport(
    {abortSignal, ...params}: RequestConfig & DescribeCertificateAuthorityAuditReportRequest,
  ): Promise<DescribeCertificateAuthorityAuditReportResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      AuditReportId: params["AuditReportId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificateAuthorityAuditReport",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuditReportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AuditReportStatus>(x),
        "S3BucketName": "s",
        "S3Key": "s",
        "CreatedAt": "d",
      },
    }, await resp.json());
  }

  async getCertificate(
    {abortSignal, ...params}: RequestConfig & GetCertificateRequest,
  ): Promise<GetCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": "s",
        "CertificateChain": "s",
      },
    }, await resp.json());
  }

  async getCertificateAuthorityCertificate(
    {abortSignal, ...params}: RequestConfig & GetCertificateAuthorityCertificateRequest,
  ): Promise<GetCertificateAuthorityCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCertificateAuthorityCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": "s",
        "CertificateChain": "s",
      },
    }, await resp.json());
  }

  async getCertificateAuthorityCsr(
    {abortSignal, ...params}: RequestConfig & GetCertificateAuthorityCsrRequest,
  ): Promise<GetCertificateAuthorityCsrResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCertificateAuthorityCsr",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Csr": "s",
      },
    }, await resp.json());
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & GetPolicyRequest,
  ): Promise<GetPolicyResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async importCertificateAuthorityCertificate(
    {abortSignal, ...params}: RequestConfig & ImportCertificateAuthorityCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Certificate: jsonP.serializeBlob(params["Certificate"]),
      CertificateChain: jsonP.serializeBlob(params["CertificateChain"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCertificateAuthorityCertificate",
    });
  }

  async issueCertificate(
    {abortSignal, ...params}: RequestConfig & IssueCertificateRequest,
  ): Promise<IssueCertificateResponse> {
    const body: jsonP.JSONObject = {
      ApiPassthrough: fromApiPassthrough(params["ApiPassthrough"]),
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Csr: jsonP.serializeBlob(params["Csr"]),
      SigningAlgorithm: params["SigningAlgorithm"],
      TemplateArn: params["TemplateArn"],
      Validity: fromValidity(params["Validity"]),
      ValidityNotBefore: fromValidity(params["ValidityNotBefore"]),
      IdempotencyToken: params["IdempotencyToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IssueCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateArn": "s",
      },
    }, await resp.json());
  }

  async listCertificateAuthorities(
    {abortSignal, ...params}: RequestConfig & ListCertificateAuthoritiesRequest = {},
  ): Promise<ListCertificateAuthoritiesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ResourceOwner: params["ResourceOwner"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCertificateAuthorities",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateAuthorities": [toCertificateAuthority],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPermissions(
    {abortSignal, ...params}: RequestConfig & ListPermissionsRequest,
  ): Promise<ListPermissionsResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Permissions": [toPermission],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & ListTagsRequest,
  ): Promise<ListTagsResponse> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putPolicy(
    {abortSignal, ...params}: RequestConfig & PutPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Policy: params["Policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPolicy",
    });
  }

  async restoreCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & RestoreCertificateAuthorityRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreCertificateAuthority",
    });
  }

  async revokeCertificate(
    {abortSignal, ...params}: RequestConfig & RevokeCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      CertificateSerial: params["CertificateSerial"],
      RevocationReason: params["RevocationReason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeCertificate",
    });
  }

  async tagCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & TagCertificateAuthorityRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagCertificateAuthority",
    });
  }

  async untagCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & UntagCertificateAuthorityRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagCertificateAuthority",
    });
  }

  async updateCertificateAuthority(
    {abortSignal, ...params}: RequestConfig & UpdateCertificateAuthorityRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      RevocationConfiguration: fromRevocationConfiguration(params["RevocationConfiguration"]),
      Status: params["Status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCertificateAuthority",
    });
  }

  // Resource State Waiters

  /**
   * Wait until a Certificate Authority CSR is created
   * Checks state up to 60 times, 3 seconds apart (about 3 minutes max wait time).
   */
  async waitForCertificateAuthorityCSRCreated(
    params: RequestConfig & GetCertificateAuthorityCsrRequest,
  ): Promise<GetCertificateAuthorityCsrResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CertificateAuthorityCSRCreated';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.getCertificateAuthorityCsr(params);
        return resp; // for status 200
      } catch (err) {
        if (!["RequestInProgressException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a certificate is issued
   * Checks state up to 60 times, 3 seconds apart (about 3 minutes max wait time).
   */
  async waitForCertificateIssued(
    params: RequestConfig & GetCertificateRequest,
  ): Promise<GetCertificateResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CertificateIssued';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.getCertificate(params);
        return resp; // for status 200
      } catch (err) {
        if (!["RequestInProgressException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a Audit Report is created
   * Checks state up to 60 times, 3 seconds apart (about 3 minutes max wait time).
   */
  async waitForAuditReportCreated(
    params: RequestConfig & DescribeCertificateAuthorityAuditReportRequest,
  ): Promise<DescribeCertificateAuthorityAuditReportResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AuditReportCreated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCertificateAuthorityAuditReport(params);
      const field = resp?.AuditReportStatus;
      if (field === "SUCCESS") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CreateCertificateAuthorityRequest {
  CertificateAuthorityConfiguration: CertificateAuthorityConfiguration;
  RevocationConfiguration?: RevocationConfiguration | null;
  CertificateAuthorityType: CertificateAuthorityType;
  IdempotencyToken?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateCertificateAuthorityAuditReportRequest {
  CertificateAuthorityArn: string;
  S3BucketName: string;
  AuditReportResponseFormat: AuditReportResponseFormat;
}

// refs: 1 - tags: named, input
export interface CreatePermissionRequest {
  CertificateAuthorityArn: string;
  Principal: string;
  SourceAccount?: string | null;
  Actions: ActionType[];
}

// refs: 1 - tags: named, input
export interface DeleteCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
  PermanentDeletionTimeInDays?: number | null;
}

// refs: 1 - tags: named, input
export interface DeletePermissionRequest {
  CertificateAuthorityArn: string;
  Principal: string;
  SourceAccount?: string | null;
}

// refs: 1 - tags: named, input
export interface DeletePolicyRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeCertificateAuthorityAuditReportRequest {
  CertificateAuthorityArn: string;
  AuditReportId: string;
}

// refs: 1 - tags: named, input
export interface GetCertificateRequest {
  CertificateAuthorityArn: string;
  CertificateArn: string;
}

// refs: 1 - tags: named, input
export interface GetCertificateAuthorityCertificateRequest {
  CertificateAuthorityArn: string;
}

// refs: 1 - tags: named, input
export interface GetCertificateAuthorityCsrRequest {
  CertificateAuthorityArn: string;
}

// refs: 1 - tags: named, input
export interface GetPolicyRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface ImportCertificateAuthorityCertificateRequest {
  CertificateAuthorityArn: string;
  Certificate: Uint8Array | string;
  CertificateChain?: Uint8Array | string | null;
}

// refs: 1 - tags: named, input
export interface IssueCertificateRequest {
  ApiPassthrough?: ApiPassthrough | null;
  CertificateAuthorityArn: string;
  Csr: Uint8Array | string;
  SigningAlgorithm: SigningAlgorithm;
  TemplateArn?: string | null;
  Validity: Validity;
  ValidityNotBefore?: Validity | null;
  IdempotencyToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCertificateAuthoritiesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  ResourceOwner?: ResourceOwner | null;
}

// refs: 1 - tags: named, input
export interface ListPermissionsRequest {
  CertificateAuthorityArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsRequest {
  CertificateAuthorityArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface PutPolicyRequest {
  ResourceArn: string;
  Policy: string;
}

// refs: 1 - tags: named, input
export interface RestoreCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
}

// refs: 1 - tags: named, input
export interface RevokeCertificateRequest {
  CertificateAuthorityArn: string;
  CertificateSerial: string;
  RevocationReason: RevocationReason;
}

// refs: 1 - tags: named, input
export interface TagCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UpdateCertificateAuthorityRequest {
  CertificateAuthorityArn: string;
  RevocationConfiguration?: RevocationConfiguration | null;
  Status?: CertificateAuthorityStatus | null;
}

// refs: 1 - tags: named, output
export interface CreateCertificateAuthorityResponse {
  CertificateAuthorityArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCertificateAuthorityAuditReportResponse {
  AuditReportId?: string | null;
  S3Key?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeCertificateAuthorityResponse {
  CertificateAuthority?: CertificateAuthority | null;
}

// refs: 1 - tags: named, output
export interface DescribeCertificateAuthorityAuditReportResponse {
  AuditReportStatus?: AuditReportStatus | null;
  S3BucketName?: string | null;
  S3Key?: string | null;
  CreatedAt?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetCertificateResponse {
  Certificate?: string | null;
  CertificateChain?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCertificateAuthorityCertificateResponse {
  Certificate?: string | null;
  CertificateChain?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCertificateAuthorityCsrResponse {
  Csr?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPolicyResponse {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface IssueCertificateResponse {
  CertificateArn?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCertificateAuthoritiesResponse {
  CertificateAuthorities?: CertificateAuthority[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPermissionsResponse {
  Permissions?: Permission[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsResponse {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 3 - tags: input, named, interface, output
export interface CertificateAuthorityConfiguration {
  KeyAlgorithm: KeyAlgorithm;
  SigningAlgorithm: SigningAlgorithm;
  Subject: ASN1Subject;
  CsrExtensions?: CsrExtensions | null;
}
function fromCertificateAuthorityConfiguration(input?: CertificateAuthorityConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KeyAlgorithm: input["KeyAlgorithm"],
    SigningAlgorithm: input["SigningAlgorithm"],
    Subject: fromASN1Subject(input["Subject"]),
    CsrExtensions: fromCsrExtensions(input["CsrExtensions"]),
  }
}
function toCertificateAuthorityConfiguration(root: jsonP.JSONValue): CertificateAuthorityConfiguration {
  return jsonP.readObj({
    required: {
      "KeyAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<KeyAlgorithm>(x),
      "SigningAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<SigningAlgorithm>(x),
      "Subject": toASN1Subject,
    },
    optional: {
      "CsrExtensions": toCsrExtensions,
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type KeyAlgorithm =
| "RSA_2048"
| "RSA_4096"
| "EC_prime256v1"
| "EC_secp384r1"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type SigningAlgorithm =
| "SHA256WITHECDSA"
| "SHA384WITHECDSA"
| "SHA512WITHECDSA"
| "SHA256WITHRSA"
| "SHA384WITHRSA"
| "SHA512WITHRSA"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface ASN1Subject {
  Country?: string | null;
  Organization?: string | null;
  OrganizationalUnit?: string | null;
  DistinguishedNameQualifier?: string | null;
  State?: string | null;
  CommonName?: string | null;
  SerialNumber?: string | null;
  Locality?: string | null;
  Title?: string | null;
  Surname?: string | null;
  GivenName?: string | null;
  Initials?: string | null;
  Pseudonym?: string | null;
  GenerationQualifier?: string | null;
}
function fromASN1Subject(input?: ASN1Subject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Country: input["Country"],
    Organization: input["Organization"],
    OrganizationalUnit: input["OrganizationalUnit"],
    DistinguishedNameQualifier: input["DistinguishedNameQualifier"],
    State: input["State"],
    CommonName: input["CommonName"],
    SerialNumber: input["SerialNumber"],
    Locality: input["Locality"],
    Title: input["Title"],
    Surname: input["Surname"],
    GivenName: input["GivenName"],
    Initials: input["Initials"],
    Pseudonym: input["Pseudonym"],
    GenerationQualifier: input["GenerationQualifier"],
  }
}
function toASN1Subject(root: jsonP.JSONValue): ASN1Subject {
  return jsonP.readObj({
    required: {},
    optional: {
      "Country": "s",
      "Organization": "s",
      "OrganizationalUnit": "s",
      "DistinguishedNameQualifier": "s",
      "State": "s",
      "CommonName": "s",
      "SerialNumber": "s",
      "Locality": "s",
      "Title": "s",
      "Surname": "s",
      "GivenName": "s",
      "Initials": "s",
      "Pseudonym": "s",
      "GenerationQualifier": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface CsrExtensions {
  KeyUsage?: KeyUsage | null;
  SubjectInformationAccess?: AccessDescription[] | null;
}
function fromCsrExtensions(input?: CsrExtensions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KeyUsage: fromKeyUsage(input["KeyUsage"]),
    SubjectInformationAccess: input["SubjectInformationAccess"]?.map(x => fromAccessDescription(x)),
  }
}
function toCsrExtensions(root: jsonP.JSONValue): CsrExtensions {
  return jsonP.readObj({
    required: {},
    optional: {
      "KeyUsage": toKeyUsage,
      "SubjectInformationAccess": [toAccessDescription],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface KeyUsage {
  DigitalSignature?: boolean | null;
  NonRepudiation?: boolean | null;
  KeyEncipherment?: boolean | null;
  DataEncipherment?: boolean | null;
  KeyAgreement?: boolean | null;
  KeyCertSign?: boolean | null;
  CRLSign?: boolean | null;
  EncipherOnly?: boolean | null;
  DecipherOnly?: boolean | null;
}
function fromKeyUsage(input?: KeyUsage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DigitalSignature: input["DigitalSignature"],
    NonRepudiation: input["NonRepudiation"],
    KeyEncipherment: input["KeyEncipherment"],
    DataEncipherment: input["DataEncipherment"],
    KeyAgreement: input["KeyAgreement"],
    KeyCertSign: input["KeyCertSign"],
    CRLSign: input["CRLSign"],
    EncipherOnly: input["EncipherOnly"],
    DecipherOnly: input["DecipherOnly"],
  }
}
function toKeyUsage(root: jsonP.JSONValue): KeyUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "DigitalSignature": "b",
      "NonRepudiation": "b",
      "KeyEncipherment": "b",
      "DataEncipherment": "b",
      "KeyAgreement": "b",
      "KeyCertSign": "b",
      "CRLSign": "b",
      "EncipherOnly": "b",
      "DecipherOnly": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface AccessDescription {
  AccessMethod: AccessMethod;
  AccessLocation: GeneralName;
}
function fromAccessDescription(input?: AccessDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccessMethod: fromAccessMethod(input["AccessMethod"]),
    AccessLocation: fromGeneralName(input["AccessLocation"]),
  }
}
function toAccessDescription(root: jsonP.JSONValue): AccessDescription {
  return jsonP.readObj({
    required: {
      "AccessMethod": toAccessMethod,
      "AccessLocation": toGeneralName,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface AccessMethod {
  CustomObjectIdentifier?: string | null;
  AccessMethodType?: AccessMethodType | null;
}
function fromAccessMethod(input?: AccessMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CustomObjectIdentifier: input["CustomObjectIdentifier"],
    AccessMethodType: input["AccessMethodType"],
  }
}
function toAccessMethod(root: jsonP.JSONValue): AccessMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "CustomObjectIdentifier": "s",
      "AccessMethodType": (x: jsonP.JSONValue) => cmnP.readEnum<AccessMethodType>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type AccessMethodType =
| "CA_REPOSITORY"
| "RESOURCE_PKI_MANIFEST"
| "RESOURCE_PKI_NOTIFY"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface GeneralName {
  OtherName?: OtherName | null;
  Rfc822Name?: string | null;
  DnsName?: string | null;
  DirectoryName?: ASN1Subject | null;
  EdiPartyName?: EdiPartyName | null;
  UniformResourceIdentifier?: string | null;
  IpAddress?: string | null;
  RegisteredId?: string | null;
}
function fromGeneralName(input?: GeneralName | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OtherName: fromOtherName(input["OtherName"]),
    Rfc822Name: input["Rfc822Name"],
    DnsName: input["DnsName"],
    DirectoryName: fromASN1Subject(input["DirectoryName"]),
    EdiPartyName: fromEdiPartyName(input["EdiPartyName"]),
    UniformResourceIdentifier: input["UniformResourceIdentifier"],
    IpAddress: input["IpAddress"],
    RegisteredId: input["RegisteredId"],
  }
}
function toGeneralName(root: jsonP.JSONValue): GeneralName {
  return jsonP.readObj({
    required: {},
    optional: {
      "OtherName": toOtherName,
      "Rfc822Name": "s",
      "DnsName": "s",
      "DirectoryName": toASN1Subject,
      "EdiPartyName": toEdiPartyName,
      "UniformResourceIdentifier": "s",
      "IpAddress": "s",
      "RegisteredId": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface OtherName {
  TypeId: string;
  Value: string;
}
function fromOtherName(input?: OtherName | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TypeId: input["TypeId"],
    Value: input["Value"],
  }
}
function toOtherName(root: jsonP.JSONValue): OtherName {
  return jsonP.readObj({
    required: {
      "TypeId": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface EdiPartyName {
  PartyName: string;
  NameAssigner?: string | null;
}
function fromEdiPartyName(input?: EdiPartyName | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PartyName: input["PartyName"],
    NameAssigner: input["NameAssigner"],
  }
}
function toEdiPartyName(root: jsonP.JSONValue): EdiPartyName {
  return jsonP.readObj({
    required: {
      "PartyName": "s",
    },
    optional: {
      "NameAssigner": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface RevocationConfiguration {
  CrlConfiguration?: CrlConfiguration | null;
}
function fromRevocationConfiguration(input?: RevocationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CrlConfiguration: fromCrlConfiguration(input["CrlConfiguration"]),
  }
}
function toRevocationConfiguration(root: jsonP.JSONValue): RevocationConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CrlConfiguration": toCrlConfiguration,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface CrlConfiguration {
  Enabled: boolean;
  ExpirationInDays?: number | null;
  CustomCname?: string | null;
  S3BucketName?: string | null;
}
function fromCrlConfiguration(input?: CrlConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    ExpirationInDays: input["ExpirationInDays"],
    CustomCname: input["CustomCname"],
    S3BucketName: input["S3BucketName"],
  }
}
function toCrlConfiguration(root: jsonP.JSONValue): CrlConfiguration {
  return jsonP.readObj({
    required: {
      "Enabled": "b",
    },
    optional: {
      "ExpirationInDays": "n",
      "CustomCname": "s",
      "S3BucketName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type CertificateAuthorityType =
| "ROOT"
| "SUBORDINATE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type AuditReportResponseFormat =
| "JSON"
| "CSV"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ActionType =
| "IssueCertificate"
| "GetCertificate"
| "ListPermissions"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ApiPassthrough {
  Extensions?: Extensions | null;
  Subject?: ASN1Subject | null;
}
function fromApiPassthrough(input?: ApiPassthrough | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Extensions: fromExtensions(input["Extensions"]),
    Subject: fromASN1Subject(input["Subject"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface Extensions {
  CertificatePolicies?: PolicyInformation[] | null;
  ExtendedKeyUsage?: ExtendedKeyUsage[] | null;
  KeyUsage?: KeyUsage | null;
  SubjectAlternativeNames?: GeneralName[] | null;
}
function fromExtensions(input?: Extensions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificatePolicies: input["CertificatePolicies"]?.map(x => fromPolicyInformation(x)),
    ExtendedKeyUsage: input["ExtendedKeyUsage"]?.map(x => fromExtendedKeyUsage(x)),
    KeyUsage: fromKeyUsage(input["KeyUsage"]),
    SubjectAlternativeNames: input["SubjectAlternativeNames"]?.map(x => fromGeneralName(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface PolicyInformation {
  CertPolicyId: string;
  PolicyQualifiers?: PolicyQualifierInfo[] | null;
}
function fromPolicyInformation(input?: PolicyInformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertPolicyId: input["CertPolicyId"],
    PolicyQualifiers: input["PolicyQualifiers"]?.map(x => fromPolicyQualifierInfo(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface PolicyQualifierInfo {
  PolicyQualifierId: PolicyQualifierId;
  Qualifier: Qualifier;
}
function fromPolicyQualifierInfo(input?: PolicyQualifierInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyQualifierId: input["PolicyQualifierId"],
    Qualifier: fromQualifier(input["Qualifier"]),
  }
}

// refs: 1 - tags: input, named, enum
export type PolicyQualifierId =
| "CPS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Qualifier {
  CpsUri: string;
}
function fromQualifier(input?: Qualifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CpsUri: input["CpsUri"],
  }
}

// refs: 1 - tags: input, named, interface
export interface ExtendedKeyUsage {
  ExtendedKeyUsageType?: ExtendedKeyUsageType | null;
  ExtendedKeyUsageObjectIdentifier?: string | null;
}
function fromExtendedKeyUsage(input?: ExtendedKeyUsage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExtendedKeyUsageType: input["ExtendedKeyUsageType"],
    ExtendedKeyUsageObjectIdentifier: input["ExtendedKeyUsageObjectIdentifier"],
  }
}

// refs: 1 - tags: input, named, enum
export type ExtendedKeyUsageType =
| "SERVER_AUTH"
| "CLIENT_AUTH"
| "CODE_SIGNING"
| "EMAIL_PROTECTION"
| "TIME_STAMPING"
| "OCSP_SIGNING"
| "SMART_CARD_LOGIN"
| "DOCUMENT_SIGNING"
| "CERTIFICATE_TRANSPARENCY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface Validity {
  Value: number;
  Type: ValidityPeriodType;
}
function fromValidity(input?: Validity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Type: input["Type"],
  }
}

// refs: 2 - tags: input, named, enum
export type ValidityPeriodType =
| "END_DATE"
| "ABSOLUTE"
| "DAYS"
| "MONTHS"
| "YEARS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ResourceOwner =
| "SELF"
| "OTHER_ACCOUNTS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type RevocationReason =
| "UNSPECIFIED"
| "KEY_COMPROMISE"
| "CERTIFICATE_AUTHORITY_COMPROMISE"
| "AFFILIATION_CHANGED"
| "SUPERSEDED"
| "CESSATION_OF_OPERATION"
| "PRIVILEGE_WITHDRAWN"
| "A_A_COMPROMISE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CertificateAuthorityStatus =
| "CREATING"
| "PENDING_CERTIFICATE"
| "ACTIVE"
| "DELETED"
| "DISABLED"
| "EXPIRED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface CertificateAuthority {
  Arn?: string | null;
  OwnerAccount?: string | null;
  CreatedAt?: Date | number | null;
  LastStateChangeAt?: Date | number | null;
  Type?: CertificateAuthorityType | null;
  Serial?: string | null;
  Status?: CertificateAuthorityStatus | null;
  NotBefore?: Date | number | null;
  NotAfter?: Date | number | null;
  FailureReason?: FailureReason | null;
  CertificateAuthorityConfiguration?: CertificateAuthorityConfiguration | null;
  RevocationConfiguration?: RevocationConfiguration | null;
  RestorableUntil?: Date | number | null;
}
function toCertificateAuthority(root: jsonP.JSONValue): CertificateAuthority {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "OwnerAccount": "s",
      "CreatedAt": "d",
      "LastStateChangeAt": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<CertificateAuthorityType>(x),
      "Serial": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<CertificateAuthorityStatus>(x),
      "NotBefore": "d",
      "NotAfter": "d",
      "FailureReason": (x: jsonP.JSONValue) => cmnP.readEnum<FailureReason>(x),
      "CertificateAuthorityConfiguration": toCertificateAuthorityConfiguration,
      "RevocationConfiguration": toRevocationConfiguration,
      "RestorableUntil": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type FailureReason =
| "REQUEST_TIMED_OUT"
| "UNSUPPORTED_ALGORITHM"
| "OTHER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type AuditReportStatus =
| "CREATING"
| "SUCCESS"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Permission {
  CertificateAuthorityArn?: string | null;
  CreatedAt?: Date | number | null;
  Principal?: string | null;
  SourceAccount?: string | null;
  Actions?: ActionType[] | null;
  Policy?: string | null;
}
function toPermission(root: jsonP.JSONValue): Permission {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateAuthorityArn": "s",
      "CreatedAt": "d",
      "Principal": "s",
      "SourceAccount": "s",
      "Actions": [(x: jsonP.JSONValue) => cmnP.readEnum<ActionType>(x)],
      "Policy": "s",
    },
  }, root);
}
