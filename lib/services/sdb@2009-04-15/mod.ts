// Autogenerated API client for: Amazon SimpleDB

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class SimpleDB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SimpleDB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2009-04-15",
    "endpointPrefix": "sdb",
    "serviceFullName": "Amazon SimpleDB",
    "serviceId": "SimpleDB",
    "signatureVersion": "v2",
    "xmlNamespace": "http://sdb.amazonaws.com/doc/2009-04-15/",
    "protocol": "query",
    "uid": "sdb-2009-04-15"
  };

  async batchDeleteAttributes(
    {abortSignal, ...params}: RequestConfig & BatchDeleteAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["Items"]) qsP.appendList(body, prefix+"Item", params["Items"], {"appender":DeletableItem_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteAttributes",
    });
  }

  async batchPutAttributes(
    {abortSignal, ...params}: RequestConfig & BatchPutAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["Items"]) qsP.appendList(body, prefix+"Item", params["Items"], {"appender":ReplaceableItem_Serialize,"entryPrefix":"."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchPutAttributes",
    });
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & CreateDomainRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
  }

  async deleteAttributes(
    {abortSignal, ...params}: RequestConfig & DeleteAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attribute", params["Attributes"], {"appender":DeletableAttribute_Serialize,"entryPrefix":"."})
    if (params["Expected"] != null) UpdateCondition_Serialize(body, prefix+"Expected", params["Expected"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAttributes",
    });
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & DeleteDomainRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
  }

  async domainMetadata(
    {abortSignal, ...params}: RequestConfig & DomainMetadataRequest,
  ): Promise<DomainMetadataResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DomainMetadata",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DomainMetadataResult");
    return {
      ItemCount: xml.first("ItemCount", false, x => parseInt(x.content ?? '0')),
      ItemNamesSizeBytes: xml.first("ItemNamesSizeBytes", false, x => parseInt(x.content ?? '0')),
      AttributeNameCount: xml.first("AttributeNameCount", false, x => parseInt(x.content ?? '0')),
      AttributeNamesSizeBytes: xml.first("AttributeNamesSizeBytes", false, x => parseInt(x.content ?? '0')),
      AttributeValueCount: xml.first("AttributeValueCount", false, x => parseInt(x.content ?? '0')),
      AttributeValuesSizeBytes: xml.first("AttributeValuesSizeBytes", false, x => parseInt(x.content ?? '0')),
      Timestamp: xml.first("Timestamp", false, x => parseInt(x.content ?? '0')),
    };
  }

  async getAttributes(
    {abortSignal, ...params}: RequestConfig & GetAttributesRequest,
  ): Promise<GetAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeName", params["AttributeNames"], {"entryPrefix":"."})
    if ("ConsistentRead" in params) body.append(prefix+"ConsistentRead", (params["ConsistentRead"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetAttributesResult");
    return {
      Attributes: xml.getList("Attribute").map(Attribute_Parse),
    };
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & ListDomainsRequest = {},
  ): Promise<ListDomainsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("MaxNumberOfDomains" in params) body.append(prefix+"MaxNumberOfDomains", (params["MaxNumberOfDomains"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListDomainsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      DomainNames: xml.getList("DomainName").map(x => x.content ?? ''),
    };
  }

  async putAttributes(
    {abortSignal, ...params}: RequestConfig & PutAttributesRequest,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ItemName", (params["ItemName"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attribute", params["Attributes"], {"appender":ReplaceableAttribute_Serialize,"entryPrefix":"."})
    if (params["Expected"] != null) UpdateCondition_Serialize(body, prefix+"Expected", params["Expected"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAttributes",
    });
  }

  async select(
    {abortSignal, ...params}: RequestConfig & SelectRequest,
  ): Promise<SelectResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SelectExpression", (params["SelectExpression"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("ConsistentRead" in params) body.append(prefix+"ConsistentRead", (params["ConsistentRead"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Select",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SelectResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Items: xml.getList("Item").map(Item_Parse),
    };
  }

}

// refs: 1 - tags: named, input
export interface BatchDeleteAttributesRequest {
  DomainName: string;
  Items: DeletableItem[];
}

// refs: 1 - tags: named, input
export interface BatchPutAttributesRequest {
  DomainName: string;
  Items: ReplaceableItem[];
}

// refs: 1 - tags: named, input
export interface CreateDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DeleteAttributesRequest {
  DomainName: string;
  ItemName: string;
  Attributes?: DeletableAttribute[] | null;
  Expected?: UpdateCondition | null;
}

// refs: 1 - tags: named, input
export interface DeleteDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DomainMetadataRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface GetAttributesRequest {
  DomainName: string;
  ItemName: string;
  AttributeNames?: string[] | null;
  ConsistentRead?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ListDomainsRequest {
  MaxNumberOfDomains?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutAttributesRequest {
  DomainName: string;
  ItemName: string;
  Attributes: ReplaceableAttribute[];
  Expected?: UpdateCondition | null;
}

// refs: 1 - tags: named, input
export interface SelectRequest {
  SelectExpression: string;
  NextToken?: string | null;
  ConsistentRead?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DomainMetadataResult {
  ItemCount?: number | null;
  ItemNamesSizeBytes?: number | null;
  AttributeNameCount?: number | null;
  AttributeNamesSizeBytes?: number | null;
  AttributeValueCount?: number | null;
  AttributeValuesSizeBytes?: number | null;
  Timestamp?: number | null;
}

// refs: 1 - tags: named, output
export interface GetAttributesResult {
  Attributes: Attribute[];
}

// refs: 1 - tags: named, output
export interface ListDomainsResult {
  DomainNames: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface SelectResult {
  Items: Item[];
  NextToken?: string | null;
}

// refs: 1 - tags: input, named, interface
export interface DeletableItem {
  Name: string;
  Attributes?: DeletableAttribute[] | null;
}
function DeletableItem_Serialize(body: URLSearchParams, prefix: string, params: DeletableItem) {
    body.append(prefix+".ItemName", (params["Name"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+".Attribute", params["Attributes"], {"appender":DeletableAttribute_Serialize,"entryPrefix":"."})
}

// refs: 2 - tags: input, named, interface
export interface DeletableAttribute {
  Name: string;
  Value?: string | null;
}
function DeletableAttribute_Serialize(body: URLSearchParams, prefix: string, params: DeletableAttribute) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}

// refs: 1 - tags: input, named, interface
export interface ReplaceableItem {
  Name: string;
  Attributes: ReplaceableAttribute[];
}
function ReplaceableItem_Serialize(body: URLSearchParams, prefix: string, params: ReplaceableItem) {
    body.append(prefix+".ItemName", (params["Name"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+".Attribute", params["Attributes"], {"appender":ReplaceableAttribute_Serialize,"entryPrefix":"."})
}

// refs: 2 - tags: input, named, interface
export interface ReplaceableAttribute {
  Name: string;
  Value: string;
  Replace?: boolean | null;
}
function ReplaceableAttribute_Serialize(body: URLSearchParams, prefix: string, params: ReplaceableAttribute) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("Replace" in params) body.append(prefix+".Replace", (params["Replace"] ?? '').toString());
}

// refs: 2 - tags: input, named, interface
export interface UpdateCondition {
  Name?: string | null;
  Value?: string | null;
  Exists?: boolean | null;
}
function UpdateCondition_Serialize(body: URLSearchParams, prefix: string, params: UpdateCondition) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("Exists" in params) body.append(prefix+".Exists", (params["Exists"] ?? '').toString());
}

// refs: 2 - tags: output, named, interface
export interface Attribute {
  Name: string;
  AlternateNameEncoding?: string | null;
  Value: string;
  AlternateValueEncoding?: string | null;
}
function Attribute_Parse(node: xmlP.XmlNode): Attribute {
  return node.strings({
    required: {"Name":true,"Value":true},
    optional: {"AlternateNameEncoding":true,"AlternateValueEncoding":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface Item {
  Name: string;
  AlternateNameEncoding?: string | null;
  Attributes: Attribute[];
}
function Item_Parse(node: xmlP.XmlNode): Item {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"AlternateNameEncoding":true},
    }),
    Attributes: node.getList("Attribute").map(Attribute_Parse),
  };
}
