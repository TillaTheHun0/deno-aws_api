// Autogenerated API client for: Elastic Load Balancing

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class ELB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ELB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2012-06-01",
    "endpointPrefix": "elasticloadbalancing",
    "protocol": "query",
    "serviceFullName": "Elastic Load Balancing",
    "serviceId": "Elastic Load Balancing",
    "signatureVersion": "v4",
    "uid": "elasticloadbalancing-2012-06-01",
    "xmlNamespace": "http://elasticloadbalancing.amazonaws.com/doc/2012-06-01/"
  };

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerNames"]) prt.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    const xml = readXmlResult(await resp.text(), "AddTagsResult");
    return {};
  }

  async applySecurityGroupsToLoadBalancer(
    {abortSignal, ...params}: RequestConfig & ApplySecurityGroupsToLoadBalancerInput,
  ): Promise<ApplySecurityGroupsToLoadBalancerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["SecurityGroups"]) prt.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplySecurityGroupsToLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "ApplySecurityGroupsToLoadBalancerResult");
    return {
      SecurityGroups: xml.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    };
  }

  async attachLoadBalancerToSubnets(
    {abortSignal, ...params}: RequestConfig & AttachLoadBalancerToSubnetsInput,
  ): Promise<AttachLoadBalancerToSubnetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Subnets"]) prt.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancerToSubnets",
    });
    const xml = readXmlResult(await resp.text(), "AttachLoadBalancerToSubnetsResult");
    return {
      Subnets: xml.getList("Subnets", "member").map(x => x.content ?? ''),
    };
  }

  async configureHealthCheck(
    {abortSignal, ...params}: RequestConfig & ConfigureHealthCheckInput,
  ): Promise<ConfigureHealthCheckOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    HealthCheck_Serialize(body, prefix+"HealthCheck", params["HealthCheck"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfigureHealthCheck",
    });
    const xml = readXmlResult(await resp.text(), "ConfigureHealthCheckResult");
    return {
      HealthCheck: xml.first("HealthCheck", false, HealthCheck_Parse),
    };
  }

  async createAppCookieStickinessPolicy(
    {abortSignal, ...params}: RequestConfig & CreateAppCookieStickinessPolicyInput,
  ): Promise<CreateAppCookieStickinessPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"CookieName", (params["CookieName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAppCookieStickinessPolicy",
    });
    const xml = readXmlResult(await resp.text(), "CreateAppCookieStickinessPolicyResult");
    return {};
  }

  async createLBCookieStickinessPolicy(
    {abortSignal, ...params}: RequestConfig & CreateLBCookieStickinessPolicyInput,
  ): Promise<CreateLBCookieStickinessPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    if ("CookieExpirationPeriod" in params) body.append(prefix+"CookieExpirationPeriod", (params["CookieExpirationPeriod"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLBCookieStickinessPolicy",
    });
    const xml = readXmlResult(await resp.text(), "CreateLBCookieStickinessPolicyResult");
    return {};
  }

  async createLoadBalancer(
    {abortSignal, ...params}: RequestConfig & CreateAccessPointInput,
  ): Promise<CreateAccessPointOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Listeners"]) prt.appendList(body, prefix+"Listeners", params["Listeners"], {"appender":Listener_Serialize,"entryPrefix":".member."})
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    if (params["Subnets"]) prt.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    if (params["SecurityGroups"]) prt.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    if ("Scheme" in params) body.append(prefix+"Scheme", (params["Scheme"] ?? '').toString());
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "CreateLoadBalancerResult");
    return xml.strings({
      optional: {"DNSName":true},
    });
  }

  async createLoadBalancerListeners(
    {abortSignal, ...params}: RequestConfig & CreateLoadBalancerListenerInput,
  ): Promise<CreateLoadBalancerListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Listeners"]) prt.appendList(body, prefix+"Listeners", params["Listeners"], {"appender":Listener_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancerListeners",
    });
    const xml = readXmlResult(await resp.text(), "CreateLoadBalancerListenersResult");
    return {};
  }

  async createLoadBalancerPolicy(
    {abortSignal, ...params}: RequestConfig & CreateLoadBalancerPolicyInput,
  ): Promise<CreateLoadBalancerPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    body.append(prefix+"PolicyTypeName", (params["PolicyTypeName"] ?? '').toString());
    if (params["PolicyAttributes"]) prt.appendList(body, prefix+"PolicyAttributes", params["PolicyAttributes"], {"appender":PolicyAttribute_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancerPolicy",
    });
    const xml = readXmlResult(await resp.text(), "CreateLoadBalancerPolicyResult");
    return {};
  }

  async deleteLoadBalancer(
    {abortSignal, ...params}: RequestConfig & DeleteAccessPointInput,
  ): Promise<DeleteAccessPointOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "DeleteLoadBalancerResult");
    return {};
  }

  async deleteLoadBalancerListeners(
    {abortSignal, ...params}: RequestConfig & DeleteLoadBalancerListenerInput,
  ): Promise<DeleteLoadBalancerListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["LoadBalancerPorts"]) prt.appendList(body, prefix+"LoadBalancerPorts", params["LoadBalancerPorts"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancerListeners",
    });
    const xml = readXmlResult(await resp.text(), "DeleteLoadBalancerListenersResult");
    return {};
  }

  async deleteLoadBalancerPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteLoadBalancerPolicyInput,
  ): Promise<DeleteLoadBalancerPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"PolicyName", (params["PolicyName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancerPolicy",
    });
    const xml = readXmlResult(await resp.text(), "DeleteLoadBalancerPolicyResult");
    return {};
  }

  async deregisterInstancesFromLoadBalancer(
    {abortSignal, ...params}: RequestConfig & DeregisterEndPointsInput,
  ): Promise<DeregisterEndPointsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Instances"]) prt.appendList(body, prefix+"Instances", params["Instances"], {"appender":Instance_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterInstancesFromLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "DeregisterInstancesFromLoadBalancerResult");
    return {
      Instances: xml.getList("Instances", "member").map(Instance_Parse),
    };
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig & DescribeAccountLimitsInput = {},
  ): Promise<DescribeAccountLimitsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountLimits",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Limits: xml.getList("Limits", "member").map(Limit_Parse),
    };
  }

  async describeInstanceHealth(
    {abortSignal, ...params}: RequestConfig & DescribeEndPointStateInput,
  ): Promise<DescribeEndPointStateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Instances"]) prt.appendList(body, prefix+"Instances", params["Instances"], {"appender":Instance_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstanceHealth",
    });
    const xml = readXmlResult(await resp.text(), "DescribeInstanceHealthResult");
    return {
      InstanceStates: xml.getList("InstanceStates", "member").map(InstanceState_Parse),
    };
  }

  async describeLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancerAttributesInput,
  ): Promise<DescribeLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerAttributes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancerAttributesResult");
    return {
      LoadBalancerAttributes: xml.first("LoadBalancerAttributes", false, LoadBalancerAttributes_Parse),
    };
  }

  async describeLoadBalancerPolicies(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancerPoliciesInput = {},
  ): Promise<DescribeLoadBalancerPoliciesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("LoadBalancerName" in params) body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["PolicyNames"]) prt.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerPolicies",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancerPoliciesResult");
    return {
      PolicyDescriptions: xml.getList("PolicyDescriptions", "member").map(PolicyDescription_Parse),
    };
  }

  async describeLoadBalancerPolicyTypes(
    {abortSignal, ...params}: RequestConfig & DescribeLoadBalancerPolicyTypesInput = {},
  ): Promise<DescribeLoadBalancerPolicyTypesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["PolicyTypeNames"]) prt.appendList(body, prefix+"PolicyTypeNames", params["PolicyTypeNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerPolicyTypes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancerPolicyTypesResult");
    return {
      PolicyTypeDescriptions: xml.getList("PolicyTypeDescriptions", "member").map(PolicyTypeDescription_Parse),
    };
  }

  async describeLoadBalancers(
    {abortSignal, ...params}: RequestConfig & DescribeAccessPointsInput = {},
  ): Promise<DescribeAccessPointsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerNames"]) prt.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancers",
    });
    const xml = readXmlResult(await resp.text(), "DescribeLoadBalancersResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      LoadBalancerDescriptions: xml.getList("LoadBalancerDescriptions", "member").map(LoadBalancerDescription_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & DescribeTagsInput,
  ): Promise<DescribeTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerNames"]) prt.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      TagDescriptions: xml.getList("TagDescriptions", "member").map(TagDescription_Parse),
    };
  }

  async detachLoadBalancerFromSubnets(
    {abortSignal, ...params}: RequestConfig & DetachLoadBalancerFromSubnetsInput,
  ): Promise<DetachLoadBalancerFromSubnetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Subnets"]) prt.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachLoadBalancerFromSubnets",
    });
    const xml = readXmlResult(await resp.text(), "DetachLoadBalancerFromSubnetsResult");
    return {
      Subnets: xml.getList("Subnets", "member").map(x => x.content ?? ''),
    };
  }

  async disableAvailabilityZonesForLoadBalancer(
    {abortSignal, ...params}: RequestConfig & RemoveAvailabilityZonesInput,
  ): Promise<RemoveAvailabilityZonesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableAvailabilityZonesForLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "DisableAvailabilityZonesForLoadBalancerResult");
    return {
      AvailabilityZones: xml.getList("AvailabilityZones", "member").map(x => x.content ?? ''),
    };
  }

  async enableAvailabilityZonesForLoadBalancer(
    {abortSignal, ...params}: RequestConfig & AddAvailabilityZonesInput,
  ): Promise<AddAvailabilityZonesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["AvailabilityZones"]) prt.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableAvailabilityZonesForLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "EnableAvailabilityZonesForLoadBalancerResult");
    return {
      AvailabilityZones: xml.getList("AvailabilityZones", "member").map(x => x.content ?? ''),
    };
  }

  async modifyLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & ModifyLoadBalancerAttributesInput,
  ): Promise<ModifyLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    LoadBalancerAttributes_Serialize(body, prefix+"LoadBalancerAttributes", params["LoadBalancerAttributes"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyLoadBalancerAttributes",
    });
    const xml = readXmlResult(await resp.text(), "ModifyLoadBalancerAttributesResult");
    return {
      ...xml.strings({
        optional: {"LoadBalancerName":true},
      }),
      LoadBalancerAttributes: xml.first("LoadBalancerAttributes", false, LoadBalancerAttributes_Parse),
    };
  }

  async registerInstancesWithLoadBalancer(
    {abortSignal, ...params}: RequestConfig & RegisterEndPointsInput,
  ): Promise<RegisterEndPointsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    if (params["Instances"]) prt.appendList(body, prefix+"Instances", params["Instances"], {"appender":Instance_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterInstancesWithLoadBalancer",
    });
    const xml = readXmlResult(await resp.text(), "RegisterInstancesWithLoadBalancerResult");
    return {
      Instances: xml.getList("Instances", "member").map(Instance_Parse),
    };
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & RemoveTagsInput,
  ): Promise<RemoveTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerNames"]) prt.appendList(body, prefix+"LoadBalancerNames", params["LoadBalancerNames"], {"entryPrefix":".member."})
    if (params["Tags"]) prt.appendList(body, prefix+"Tags", params["Tags"], {"appender":TagKeyOnly_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    const xml = readXmlResult(await resp.text(), "RemoveTagsResult");
    return {};
  }

  async setLoadBalancerListenerSSLCertificate(
    {abortSignal, ...params}: RequestConfig & SetLoadBalancerListenerSSLCertificateInput,
  ): Promise<SetLoadBalancerListenerSSLCertificateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"LoadBalancerPort", (params["LoadBalancerPort"] ?? '').toString());
    body.append(prefix+"SSLCertificateId", (params["SSLCertificateId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoadBalancerListenerSSLCertificate",
    });
    const xml = readXmlResult(await resp.text(), "SetLoadBalancerListenerSSLCertificateResult");
    return {};
  }

  async setLoadBalancerPoliciesForBackendServer(
    {abortSignal, ...params}: RequestConfig & SetLoadBalancerPoliciesForBackendServerInput,
  ): Promise<SetLoadBalancerPoliciesForBackendServerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"InstancePort", (params["InstancePort"] ?? '').toString());
    if (params["PolicyNames"]) prt.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoadBalancerPoliciesForBackendServer",
    });
    const xml = readXmlResult(await resp.text(), "SetLoadBalancerPoliciesForBackendServerResult");
    return {};
  }

  async setLoadBalancerPoliciesOfListener(
    {abortSignal, ...params}: RequestConfig & SetLoadBalancerPoliciesOfListenerInput,
  ): Promise<SetLoadBalancerPoliciesOfListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerName", (params["LoadBalancerName"] ?? '').toString());
    body.append(prefix+"LoadBalancerPort", (params["LoadBalancerPort"] ?? '').toString());
    if (params["PolicyNames"]) prt.appendList(body, prefix+"PolicyNames", params["PolicyNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetLoadBalancerPoliciesOfListener",
    });
    const xml = readXmlResult(await resp.text(), "SetLoadBalancerPoliciesOfListenerResult");
    return {};
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceDeregistered(
    params: RequestConfig & DescribeEndPointStateInput,
  ): Promise<Error | DescribeEndPointStateOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceDeregistered';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstanceHealth(params);
        if (resp["InstanceStates"].flatMap(x => x["State"]).every(x => x === "OutOfService")) return resp;
      } catch (err) {
        if (["InvalidInstance"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForAnyInstanceInService(
    params: RequestConfig & DescribeEndPointStateInput,
  ): Promise<DescribeEndPointStateOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state AnyInstanceInService';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeInstanceHealth(params);
      if (resp["InstanceStates"].flatMap(x => x["State"]).some(x => x === "InService")) return resp;
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForInstanceInService(
    params: RequestConfig & DescribeEndPointStateInput,
  ): Promise<DescribeEndPointStateOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InstanceInService';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeInstanceHealth(params);
        if (resp["InstanceStates"].flatMap(x => x["State"]).every(x => x === "InService")) return resp;
      } catch (err) {
        if (!["InvalidInstance"].includes(err.code)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  LoadBalancerNames: string[];
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface ApplySecurityGroupsToLoadBalancerInput {
  LoadBalancerName: string;
  SecurityGroups: string[];
}

// refs: 1 - tags: named, input
export interface AttachLoadBalancerToSubnetsInput {
  LoadBalancerName: string;
  Subnets: string[];
}

// refs: 1 - tags: named, input
export interface ConfigureHealthCheckInput {
  LoadBalancerName: string;
  HealthCheck: HealthCheck;
}

// refs: 1 - tags: named, input
export interface CreateAppCookieStickinessPolicyInput {
  LoadBalancerName: string;
  PolicyName: string;
  CookieName: string;
}

// refs: 1 - tags: named, input
export interface CreateLBCookieStickinessPolicyInput {
  LoadBalancerName: string;
  PolicyName: string;
  CookieExpirationPeriod?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateAccessPointInput {
  LoadBalancerName: string;
  Listeners: Listener[];
  AvailabilityZones?: string[] | null;
  Subnets?: string[] | null;
  SecurityGroups?: string[] | null;
  Scheme?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateLoadBalancerListenerInput {
  LoadBalancerName: string;
  Listeners: Listener[];
}

// refs: 1 - tags: named, input
export interface CreateLoadBalancerPolicyInput {
  LoadBalancerName: string;
  PolicyName: string;
  PolicyTypeName: string;
  PolicyAttributes?: PolicyAttribute[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAccessPointInput {
  LoadBalancerName: string;
}

// refs: 1 - tags: named, input
export interface DeleteLoadBalancerListenerInput {
  LoadBalancerName: string;
  LoadBalancerPorts: number[];
}

// refs: 1 - tags: named, input
export interface DeleteLoadBalancerPolicyInput {
  LoadBalancerName: string;
  PolicyName: string;
}

// refs: 1 - tags: named, input
export interface DeregisterEndPointsInput {
  LoadBalancerName: string;
  Instances: Instance[];
}

// refs: 1 - tags: named, input
export interface DescribeAccountLimitsInput {
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeEndPointStateInput {
  LoadBalancerName: string;
  Instances?: Instance[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancerAttributesInput {
  LoadBalancerName: string;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancerPoliciesInput {
  LoadBalancerName?: string | null;
  PolicyNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeLoadBalancerPolicyTypesInput {
  PolicyTypeNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeAccessPointsInput {
  LoadBalancerNames?: string[] | null;
  Marker?: string | null;
  PageSize?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTagsInput {
  LoadBalancerNames: string[];
}

// refs: 1 - tags: named, input
export interface DetachLoadBalancerFromSubnetsInput {
  LoadBalancerName: string;
  Subnets: string[];
}

// refs: 1 - tags: named, input
export interface RemoveAvailabilityZonesInput {
  LoadBalancerName: string;
  AvailabilityZones: string[];
}

// refs: 1 - tags: named, input
export interface AddAvailabilityZonesInput {
  LoadBalancerName: string;
  AvailabilityZones: string[];
}

// refs: 1 - tags: named, input
export interface ModifyLoadBalancerAttributesInput {
  LoadBalancerName: string;
  LoadBalancerAttributes: LoadBalancerAttributes;
}

// refs: 1 - tags: named, input
export interface RegisterEndPointsInput {
  LoadBalancerName: string;
  Instances: Instance[];
}

// refs: 1 - tags: named, input
export interface RemoveTagsInput {
  LoadBalancerNames: string[];
  Tags: TagKeyOnly[];
}

// refs: 1 - tags: named, input
export interface SetLoadBalancerListenerSSLCertificateInput {
  LoadBalancerName: string;
  LoadBalancerPort: number;
  SSLCertificateId: string;
}

// refs: 1 - tags: named, input
export interface SetLoadBalancerPoliciesForBackendServerInput {
  LoadBalancerName: string;
  InstancePort: number;
  PolicyNames: string[];
}

// refs: 1 - tags: named, input
export interface SetLoadBalancerPoliciesOfListenerInput {
  LoadBalancerName: string;
  LoadBalancerPort: number;
  PolicyNames: string[];
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
}

// refs: 1 - tags: named, output
export interface ApplySecurityGroupsToLoadBalancerOutput {
  SecurityGroups: string[];
}

// refs: 1 - tags: named, output
export interface AttachLoadBalancerToSubnetsOutput {
  Subnets: string[];
}

// refs: 1 - tags: named, output
export interface ConfigureHealthCheckOutput {
  HealthCheck?: HealthCheck | null;
}

// refs: 1 - tags: named, output
export interface CreateAppCookieStickinessPolicyOutput {
}

// refs: 1 - tags: named, output
export interface CreateLBCookieStickinessPolicyOutput {
}

// refs: 1 - tags: named, output
export interface CreateAccessPointOutput {
  DNSName?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateLoadBalancerListenerOutput {
}

// refs: 1 - tags: named, output
export interface CreateLoadBalancerPolicyOutput {
}

// refs: 1 - tags: named, output
export interface DeleteAccessPointOutput {
}

// refs: 1 - tags: named, output
export interface DeleteLoadBalancerListenerOutput {
}

// refs: 1 - tags: named, output
export interface DeleteLoadBalancerPolicyOutput {
}

// refs: 1 - tags: named, output
export interface DeregisterEndPointsOutput {
  Instances: Instance[];
}

// refs: 1 - tags: named, output
export interface DescribeAccountLimitsOutput {
  Limits: Limit[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndPointStateOutput {
  InstanceStates: InstanceState[];
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancerAttributesOutput {
  LoadBalancerAttributes?: LoadBalancerAttributes | null;
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancerPoliciesOutput {
  PolicyDescriptions: PolicyDescription[];
}

// refs: 1 - tags: named, output
export interface DescribeLoadBalancerPolicyTypesOutput {
  PolicyTypeDescriptions: PolicyTypeDescription[];
}

// refs: 1 - tags: named, output
export interface DescribeAccessPointsOutput {
  LoadBalancerDescriptions: LoadBalancerDescription[];
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTagsOutput {
  TagDescriptions: TagDescription[];
}

// refs: 1 - tags: named, output
export interface DetachLoadBalancerFromSubnetsOutput {
  Subnets: string[];
}

// refs: 1 - tags: named, output
export interface RemoveAvailabilityZonesOutput {
  AvailabilityZones: string[];
}

// refs: 1 - tags: named, output
export interface AddAvailabilityZonesOutput {
  AvailabilityZones: string[];
}

// refs: 1 - tags: named, output
export interface ModifyLoadBalancerAttributesOutput {
  LoadBalancerName?: string | null;
  LoadBalancerAttributes?: LoadBalancerAttributes | null;
}

// refs: 1 - tags: named, output
export interface RegisterEndPointsOutput {
  Instances: Instance[];
}

// refs: 1 - tags: named, output
export interface RemoveTagsOutput {
}

// refs: 1 - tags: named, output
export interface SetLoadBalancerListenerSSLCertificateOutput {
}

// refs: 1 - tags: named, output
export interface SetLoadBalancerPoliciesForBackendServerOutput {
}

// refs: 1 - tags: named, output
export interface SetLoadBalancerPoliciesOfListenerOutput {
}

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: XmlNode): Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface HealthCheck {
  Target: string;
  Interval: number;
  Timeout: number;
  UnhealthyThreshold: number;
  HealthyThreshold: number;
}
function HealthCheck_Serialize(body: URLSearchParams, prefix: string, params: HealthCheck) {
    body.append(prefix+".Target", (params["Target"] ?? '').toString());
    body.append(prefix+".Interval", (params["Interval"] ?? '').toString());
    body.append(prefix+".Timeout", (params["Timeout"] ?? '').toString());
    body.append(prefix+".UnhealthyThreshold", (params["UnhealthyThreshold"] ?? '').toString());
    body.append(prefix+".HealthyThreshold", (params["HealthyThreshold"] ?? '').toString());
}
function HealthCheck_Parse(node: XmlNode): HealthCheck {
  return {
    ...node.strings({
      required: {"Target":true},
    }),
    Interval: node.first("Interval", true, x => parseInt(x.content ?? '0')),
    Timeout: node.first("Timeout", true, x => parseInt(x.content ?? '0')),
    UnhealthyThreshold: node.first("UnhealthyThreshold", true, x => parseInt(x.content ?? '0')),
    HealthyThreshold: node.first("HealthyThreshold", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface Listener {
  Protocol: string;
  LoadBalancerPort: number;
  InstanceProtocol?: string | null;
  InstancePort: number;
  SSLCertificateId?: string | null;
}
function Listener_Serialize(body: URLSearchParams, prefix: string, params: Listener) {
    body.append(prefix+".Protocol", (params["Protocol"] ?? '').toString());
    body.append(prefix+".LoadBalancerPort", (params["LoadBalancerPort"] ?? '').toString());
    if ("InstanceProtocol" in params) body.append(prefix+".InstanceProtocol", (params["InstanceProtocol"] ?? '').toString());
    body.append(prefix+".InstancePort", (params["InstancePort"] ?? '').toString());
    if ("SSLCertificateId" in params) body.append(prefix+".SSLCertificateId", (params["SSLCertificateId"] ?? '').toString());
}
function Listener_Parse(node: XmlNode): Listener {
  return {
    ...node.strings({
      required: {"Protocol":true},
      optional: {"InstanceProtocol":true,"SSLCertificateId":true},
    }),
    LoadBalancerPort: node.first("LoadBalancerPort", true, x => parseInt(x.content ?? '0')),
    InstancePort: node.first("InstancePort", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: input, named, interface
export interface PolicyAttribute {
  AttributeName?: string | null;
  AttributeValue?: string | null;
}
function PolicyAttribute_Serialize(body: URLSearchParams, prefix: string, params: PolicyAttribute) {
    if ("AttributeName" in params) body.append(prefix+".AttributeName", (params["AttributeName"] ?? '').toString());
    if ("AttributeValue" in params) body.append(prefix+".AttributeValue", (params["AttributeValue"] ?? '').toString());
}

// refs: 6 - tags: input, named, interface, output
export interface Instance {
  InstanceId?: string | null;
}
function Instance_Serialize(body: URLSearchParams, prefix: string, params: Instance) {
    if ("InstanceId" in params) body.append(prefix+".InstanceId", (params["InstanceId"] ?? '').toString());
}
function Instance_Parse(node: XmlNode): Instance {
  return node.strings({
    optional: {"InstanceId":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface LoadBalancerAttributes {
  CrossZoneLoadBalancing?: CrossZoneLoadBalancing | null;
  AccessLog?: AccessLog | null;
  ConnectionDraining?: ConnectionDraining | null;
  ConnectionSettings?: ConnectionSettings | null;
  AdditionalAttributes: AdditionalAttribute[];
}
function LoadBalancerAttributes_Serialize(body: URLSearchParams, prefix: string, params: LoadBalancerAttributes) {
    if (params["CrossZoneLoadBalancing"] != null) CrossZoneLoadBalancing_Serialize(body, prefix+".CrossZoneLoadBalancing", params["CrossZoneLoadBalancing"]);
    if (params["AccessLog"] != null) AccessLog_Serialize(body, prefix+".AccessLog", params["AccessLog"]);
    if (params["ConnectionDraining"] != null) ConnectionDraining_Serialize(body, prefix+".ConnectionDraining", params["ConnectionDraining"]);
    if (params["ConnectionSettings"] != null) ConnectionSettings_Serialize(body, prefix+".ConnectionSettings", params["ConnectionSettings"]);
    if (params["AdditionalAttributes"]) prt.appendList(body, prefix+".AdditionalAttributes", params["AdditionalAttributes"], {"appender":AdditionalAttribute_Serialize,"entryPrefix":".member."})
}
function LoadBalancerAttributes_Parse(node: XmlNode): LoadBalancerAttributes {
  return {
    CrossZoneLoadBalancing: node.first("CrossZoneLoadBalancing", false, CrossZoneLoadBalancing_Parse),
    AccessLog: node.first("AccessLog", false, AccessLog_Parse),
    ConnectionDraining: node.first("ConnectionDraining", false, ConnectionDraining_Parse),
    ConnectionSettings: node.first("ConnectionSettings", false, ConnectionSettings_Parse),
    AdditionalAttributes: node.getList("AdditionalAttributes", "member").map(AdditionalAttribute_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface CrossZoneLoadBalancing {
  Enabled: boolean;
}
function CrossZoneLoadBalancing_Serialize(body: URLSearchParams, prefix: string, params: CrossZoneLoadBalancing) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
}
function CrossZoneLoadBalancing_Parse(node: XmlNode): CrossZoneLoadBalancing {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface AccessLog {
  Enabled: boolean;
  S3BucketName?: string | null;
  EmitInterval?: number | null;
  S3BucketPrefix?: string | null;
}
function AccessLog_Serialize(body: URLSearchParams, prefix: string, params: AccessLog) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("S3BucketName" in params) body.append(prefix+".S3BucketName", (params["S3BucketName"] ?? '').toString());
    if ("EmitInterval" in params) body.append(prefix+".EmitInterval", (params["EmitInterval"] ?? '').toString());
    if ("S3BucketPrefix" in params) body.append(prefix+".S3BucketPrefix", (params["S3BucketPrefix"] ?? '').toString());
}
function AccessLog_Parse(node: XmlNode): AccessLog {
  return {
    ...node.strings({
      optional: {"S3BucketName":true,"S3BucketPrefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    EmitInterval: node.first("EmitInterval", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface ConnectionDraining {
  Enabled: boolean;
  Timeout?: number | null;
}
function ConnectionDraining_Serialize(body: URLSearchParams, prefix: string, params: ConnectionDraining) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("Timeout" in params) body.append(prefix+".Timeout", (params["Timeout"] ?? '').toString());
}
function ConnectionDraining_Parse(node: XmlNode): ConnectionDraining {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Timeout: node.first("Timeout", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface ConnectionSettings {
  IdleTimeout: number;
}
function ConnectionSettings_Serialize(body: URLSearchParams, prefix: string, params: ConnectionSettings) {
    body.append(prefix+".IdleTimeout", (params["IdleTimeout"] ?? '').toString());
}
function ConnectionSettings_Parse(node: XmlNode): ConnectionSettings {
  return {
    IdleTimeout: node.first("IdleTimeout", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface AdditionalAttribute {
  Key?: string | null;
  Value?: string | null;
}
function AdditionalAttribute_Serialize(body: URLSearchParams, prefix: string, params: AdditionalAttribute) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function AdditionalAttribute_Parse(node: XmlNode): AdditionalAttribute {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 1 - tags: input, named, interface
export interface TagKeyOnly {
  Key?: string | null;
}
function TagKeyOnly_Serialize(body: URLSearchParams, prefix: string, params: TagKeyOnly) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
}

// refs: 1 - tags: output, named, interface
export interface Limit {
  Name?: string | null;
  Max?: string | null;
}
function Limit_Parse(node: XmlNode): Limit {
  return node.strings({
    optional: {"Name":true,"Max":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface InstanceState {
  InstanceId?: string | null;
  State?: string | null;
  ReasonCode?: string | null;
  Description?: string | null;
}
function InstanceState_Parse(node: XmlNode): InstanceState {
  return node.strings({
    optional: {"InstanceId":true,"State":true,"ReasonCode":true,"Description":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface PolicyDescription {
  PolicyName?: string | null;
  PolicyTypeName?: string | null;
  PolicyAttributeDescriptions: PolicyAttributeDescription[];
}
function PolicyDescription_Parse(node: XmlNode): PolicyDescription {
  return {
    ...node.strings({
      optional: {"PolicyName":true,"PolicyTypeName":true},
    }),
    PolicyAttributeDescriptions: node.getList("PolicyAttributeDescriptions", "member").map(PolicyAttributeDescription_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PolicyAttributeDescription {
  AttributeName?: string | null;
  AttributeValue?: string | null;
}
function PolicyAttributeDescription_Parse(node: XmlNode): PolicyAttributeDescription {
  return node.strings({
    optional: {"AttributeName":true,"AttributeValue":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface PolicyTypeDescription {
  PolicyTypeName?: string | null;
  Description?: string | null;
  PolicyAttributeTypeDescriptions: PolicyAttributeTypeDescription[];
}
function PolicyTypeDescription_Parse(node: XmlNode): PolicyTypeDescription {
  return {
    ...node.strings({
      optional: {"PolicyTypeName":true,"Description":true},
    }),
    PolicyAttributeTypeDescriptions: node.getList("PolicyAttributeTypeDescriptions", "member").map(PolicyAttributeTypeDescription_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PolicyAttributeTypeDescription {
  AttributeName?: string | null;
  AttributeType?: string | null;
  Description?: string | null;
  DefaultValue?: string | null;
  Cardinality?: string | null;
}
function PolicyAttributeTypeDescription_Parse(node: XmlNode): PolicyAttributeTypeDescription {
  return node.strings({
    optional: {"AttributeName":true,"AttributeType":true,"Description":true,"DefaultValue":true,"Cardinality":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface LoadBalancerDescription {
  LoadBalancerName?: string | null;
  DNSName?: string | null;
  CanonicalHostedZoneName?: string | null;
  CanonicalHostedZoneNameID?: string | null;
  ListenerDescriptions: ListenerDescription[];
  Policies?: Policies | null;
  BackendServerDescriptions: BackendServerDescription[];
  AvailabilityZones: string[];
  Subnets: string[];
  VPCId?: string | null;
  Instances: Instance[];
  HealthCheck?: HealthCheck | null;
  SourceSecurityGroup?: SourceSecurityGroup | null;
  SecurityGroups: string[];
  CreatedTime?: Date | number | null;
  Scheme?: string | null;
}
function LoadBalancerDescription_Parse(node: XmlNode): LoadBalancerDescription {
  return {
    ...node.strings({
      optional: {"LoadBalancerName":true,"DNSName":true,"CanonicalHostedZoneName":true,"CanonicalHostedZoneNameID":true,"VPCId":true,"Scheme":true},
    }),
    ListenerDescriptions: node.getList("ListenerDescriptions", "member").map(ListenerDescription_Parse),
    Policies: node.first("Policies", false, Policies_Parse),
    BackendServerDescriptions: node.getList("BackendServerDescriptions", "member").map(BackendServerDescription_Parse),
    AvailabilityZones: node.getList("AvailabilityZones", "member").map(x => x.content ?? ''),
    Subnets: node.getList("Subnets", "member").map(x => x.content ?? ''),
    Instances: node.getList("Instances", "member").map(Instance_Parse),
    HealthCheck: node.first("HealthCheck", false, HealthCheck_Parse),
    SourceSecurityGroup: node.first("SourceSecurityGroup", false, SourceSecurityGroup_Parse),
    SecurityGroups: node.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    CreatedTime: node.first("CreatedTime", false, x => parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ListenerDescription {
  Listener?: Listener | null;
  PolicyNames: string[];
}
function ListenerDescription_Parse(node: XmlNode): ListenerDescription {
  return {
    Listener: node.first("Listener", false, Listener_Parse),
    PolicyNames: node.getList("PolicyNames", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Policies {
  AppCookieStickinessPolicies: AppCookieStickinessPolicy[];
  LBCookieStickinessPolicies: LBCookieStickinessPolicy[];
  OtherPolicies: string[];
}
function Policies_Parse(node: XmlNode): Policies {
  return {
    AppCookieStickinessPolicies: node.getList("AppCookieStickinessPolicies", "member").map(AppCookieStickinessPolicy_Parse),
    LBCookieStickinessPolicies: node.getList("LBCookieStickinessPolicies", "member").map(LBCookieStickinessPolicy_Parse),
    OtherPolicies: node.getList("OtherPolicies", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface AppCookieStickinessPolicy {
  PolicyName?: string | null;
  CookieName?: string | null;
}
function AppCookieStickinessPolicy_Parse(node: XmlNode): AppCookieStickinessPolicy {
  return node.strings({
    optional: {"PolicyName":true,"CookieName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface LBCookieStickinessPolicy {
  PolicyName?: string | null;
  CookieExpirationPeriod?: number | null;
}
function LBCookieStickinessPolicy_Parse(node: XmlNode): LBCookieStickinessPolicy {
  return {
    ...node.strings({
      optional: {"PolicyName":true},
    }),
    CookieExpirationPeriod: node.first("CookieExpirationPeriod", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface BackendServerDescription {
  InstancePort?: number | null;
  PolicyNames: string[];
}
function BackendServerDescription_Parse(node: XmlNode): BackendServerDescription {
  return {
    InstancePort: node.first("InstancePort", false, x => parseInt(x.content ?? '0')),
    PolicyNames: node.getList("PolicyNames", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface SourceSecurityGroup {
  OwnerAlias?: string | null;
  GroupName?: string | null;
}
function SourceSecurityGroup_Parse(node: XmlNode): SourceSecurityGroup {
  return node.strings({
    optional: {"OwnerAlias":true,"GroupName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface TagDescription {
  LoadBalancerName?: string | null;
  Tags: Tag[];
}
function TagDescription_Parse(node: XmlNode): TagDescription {
  return {
    ...node.strings({
      optional: {"LoadBalancerName":true},
    }),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}
