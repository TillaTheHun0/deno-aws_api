// Autogenerated API client for: Amazon Lightsail

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Lightsail {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Lightsail.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-11-28",
    "endpointPrefix": "lightsail",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Lightsail",
    "serviceId": "Lightsail",
    "signatureVersion": "v4",
    "targetPrefix": "Lightsail_20161128",
    "uid": "lightsail-2016-11-28"
  };

  async allocateStaticIp(
    {abortSignal, ...params}: RequestConfig & s.AllocateStaticIpRequest,
  ): Promise<s.AllocateStaticIpResult> {
    const body: jsonP.JSONObject = {
      staticIpName: params["staticIpName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateStaticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async attachCertificateToDistribution(
    {abortSignal, ...params}: RequestConfig & s.AttachCertificateToDistributionRequest,
  ): Promise<s.AttachCertificateToDistributionResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      certificateName: params["certificateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachCertificateToDistribution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async attachDisk(
    {abortSignal, ...params}: RequestConfig & s.AttachDiskRequest,
  ): Promise<s.AttachDiskResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
      instanceName: params["instanceName"],
      diskPath: params["diskPath"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachDisk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async attachInstancesToLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.AttachInstancesToLoadBalancerRequest,
  ): Promise<s.AttachInstancesToLoadBalancerResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      instanceNames: params["instanceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachInstancesToLoadBalancer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async attachLoadBalancerTlsCertificate(
    {abortSignal, ...params}: RequestConfig & s.AttachLoadBalancerTlsCertificateRequest,
  ): Promise<s.AttachLoadBalancerTlsCertificateResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      certificateName: params["certificateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachLoadBalancerTlsCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async attachStaticIp(
    {abortSignal, ...params}: RequestConfig & s.AttachStaticIpRequest,
  ): Promise<s.AttachStaticIpResult> {
    const body: jsonP.JSONObject = {
      staticIpName: params["staticIpName"],
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AttachStaticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async closeInstancePublicPorts(
    {abortSignal, ...params}: RequestConfig & s.CloseInstancePublicPortsRequest,
  ): Promise<s.CloseInstancePublicPortsResult> {
    const body: jsonP.JSONObject = {
      portInfo: fromPortInfo(params["portInfo"]),
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CloseInstancePublicPorts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async copySnapshot(
    {abortSignal, ...params}: RequestConfig & s.CopySnapshotRequest,
  ): Promise<s.CopySnapshotResult> {
    const body: jsonP.JSONObject = {
      sourceSnapshotName: params["sourceSnapshotName"],
      sourceResourceName: params["sourceResourceName"],
      restoreDate: params["restoreDate"],
      useLatestRestorableAutoSnapshot: params["useLatestRestorableAutoSnapshot"],
      targetSnapshotName: params["targetSnapshotName"],
      sourceRegion: params["sourceRegion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopySnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createCertificate(
    {abortSignal, ...params}: RequestConfig & s.CreateCertificateRequest,
  ): Promise<s.CreateCertificateResult> {
    const body: jsonP.JSONObject = {
      certificateName: params["certificateName"],
      domainName: params["domainName"],
      subjectAlternativeNames: params["subjectAlternativeNames"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificate": toCertificateSummary,
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createCloudFormationStack(
    {abortSignal, ...params}: RequestConfig & s.CreateCloudFormationStackRequest,
  ): Promise<s.CreateCloudFormationStackResult> {
    const body: jsonP.JSONObject = {
      instances: params["instances"]?.map(x => fromInstanceEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFormationStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createContactMethod(
    {abortSignal, ...params}: RequestConfig & s.CreateContactMethodRequest,
  ): Promise<s.CreateContactMethodResult> {
    const body: jsonP.JSONObject = {
      protocol: params["protocol"],
      contactEndpoint: params["contactEndpoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContactMethod",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createContainerService(
    {abortSignal, ...params}: RequestConfig & s.CreateContainerServiceRequest,
  ): Promise<s.CreateContainerServiceResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      power: params["power"],
      scale: params["scale"],
      tags: params["tags"]?.map(x => fromTag(x)),
      publicDomainNames: params["publicDomainNames"],
      deployment: fromContainerServiceDeploymentRequest(params["deployment"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContainerService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerService": toContainerService,
      },
    }, await resp.json());
  }

  async createContainerServiceDeployment(
    {abortSignal, ...params}: RequestConfig & s.CreateContainerServiceDeploymentRequest,
  ): Promise<s.CreateContainerServiceDeploymentResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      containers: jsonP.serializeMap(params["containers"], x => fromContainer(x)),
      publicEndpoint: fromEndpointRequest(params["publicEndpoint"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContainerServiceDeployment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerService": toContainerService,
      },
    }, await resp.json());
  }

  async createContainerServiceRegistryLogin(
    {abortSignal, ...params}: RequestConfig & s.CreateContainerServiceRegistryLoginRequest = {},
  ): Promise<s.CreateContainerServiceRegistryLoginResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContainerServiceRegistryLogin",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryLogin": toContainerServiceRegistryLogin,
      },
    }, await resp.json());
  }

  async createDisk(
    {abortSignal, ...params}: RequestConfig & s.CreateDiskRequest,
  ): Promise<s.CreateDiskResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
      availabilityZone: params["availabilityZone"],
      sizeInGb: params["sizeInGb"],
      tags: params["tags"]?.map(x => fromTag(x)),
      addOns: params["addOns"]?.map(x => fromAddOnRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDisk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createDiskFromSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateDiskFromSnapshotRequest,
  ): Promise<s.CreateDiskFromSnapshotResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
      diskSnapshotName: params["diskSnapshotName"],
      availabilityZone: params["availabilityZone"],
      sizeInGb: params["sizeInGb"],
      tags: params["tags"]?.map(x => fromTag(x)),
      addOns: params["addOns"]?.map(x => fromAddOnRequest(x)),
      sourceDiskName: params["sourceDiskName"],
      restoreDate: params["restoreDate"],
      useLatestRestorableAutoSnapshot: params["useLatestRestorableAutoSnapshot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDiskFromSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createDiskSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateDiskSnapshotRequest,
  ): Promise<s.CreateDiskSnapshotResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
      diskSnapshotName: params["diskSnapshotName"],
      instanceName: params["instanceName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDiskSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createDistribution(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionRequest,
  ): Promise<s.CreateDistributionResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      origin: fromInputOrigin(params["origin"]),
      defaultCacheBehavior: fromCacheBehavior(params["defaultCacheBehavior"]),
      cacheBehaviorSettings: fromCacheSettings(params["cacheBehaviorSettings"]),
      cacheBehaviors: params["cacheBehaviors"]?.map(x => fromCacheBehaviorPerPath(x)),
      bundleId: params["bundleId"],
      ipAddressType: params["ipAddressType"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistribution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "distribution": toLightsailDistribution,
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<s.CreateDomainResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async createDomainEntry(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainEntryRequest,
  ): Promise<s.CreateDomainEntryResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      domainEntry: fromDomainEntry(params["domainEntry"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomainEntry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async createInstanceSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateInstanceSnapshotRequest,
  ): Promise<s.CreateInstanceSnapshotResult> {
    const body: jsonP.JSONObject = {
      instanceSnapshotName: params["instanceSnapshotName"],
      instanceName: params["instanceName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstanceSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createInstances(
    {abortSignal, ...params}: RequestConfig & s.CreateInstancesRequest,
  ): Promise<s.CreateInstancesResult> {
    const body: jsonP.JSONObject = {
      instanceNames: params["instanceNames"],
      availabilityZone: params["availabilityZone"],
      customImageName: params["customImageName"],
      blueprintId: params["blueprintId"],
      bundleId: params["bundleId"],
      userData: params["userData"],
      keyPairName: params["keyPairName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      addOns: params["addOns"]?.map(x => fromAddOnRequest(x)),
      ipAddressType: params["ipAddressType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createInstancesFromSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateInstancesFromSnapshotRequest,
  ): Promise<s.CreateInstancesFromSnapshotResult> {
    const body: jsonP.JSONObject = {
      instanceNames: params["instanceNames"],
      attachedDiskMapping: jsonP.serializeMap(params["attachedDiskMapping"], x => x?.map(fromDiskMap)),
      availabilityZone: params["availabilityZone"],
      instanceSnapshotName: params["instanceSnapshotName"],
      bundleId: params["bundleId"],
      userData: params["userData"],
      keyPairName: params["keyPairName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      addOns: params["addOns"]?.map(x => fromAddOnRequest(x)),
      ipAddressType: params["ipAddressType"],
      sourceInstanceName: params["sourceInstanceName"],
      restoreDate: params["restoreDate"],
      useLatestRestorableAutoSnapshot: params["useLatestRestorableAutoSnapshot"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInstancesFromSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createKeyPair(
    {abortSignal, ...params}: RequestConfig & s.CreateKeyPairRequest,
  ): Promise<s.CreateKeyPairResult> {
    const body: jsonP.JSONObject = {
      keyPairName: params["keyPairName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toKeyPair,
        "publicKeyBase64": "s",
        "privateKeyBase64": "s",
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async createLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.CreateLoadBalancerRequest,
  ): Promise<s.CreateLoadBalancerResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      instancePort: params["instancePort"],
      healthCheckPath: params["healthCheckPath"],
      certificateName: params["certificateName"],
      certificateDomainName: params["certificateDomainName"],
      certificateAlternativeNames: params["certificateAlternativeNames"],
      tags: params["tags"]?.map(x => fromTag(x)),
      ipAddressType: params["ipAddressType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createLoadBalancerTlsCertificate(
    {abortSignal, ...params}: RequestConfig & s.CreateLoadBalancerTlsCertificateRequest,
  ): Promise<s.CreateLoadBalancerTlsCertificateResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      certificateName: params["certificateName"],
      certificateDomainName: params["certificateDomainName"],
      certificateAlternativeNames: params["certificateAlternativeNames"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancerTlsCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.CreateRelationalDatabaseRequest,
  ): Promise<s.CreateRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      availabilityZone: params["availabilityZone"],
      relationalDatabaseBlueprintId: params["relationalDatabaseBlueprintId"],
      relationalDatabaseBundleId: params["relationalDatabaseBundleId"],
      masterDatabaseName: params["masterDatabaseName"],
      masterUsername: params["masterUsername"],
      masterUserPassword: params["masterUserPassword"],
      preferredBackupWindow: params["preferredBackupWindow"],
      preferredMaintenanceWindow: params["preferredMaintenanceWindow"],
      publiclyAccessible: params["publiclyAccessible"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createRelationalDatabaseFromSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateRelationalDatabaseFromSnapshotRequest,
  ): Promise<s.CreateRelationalDatabaseFromSnapshotResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      availabilityZone: params["availabilityZone"],
      publiclyAccessible: params["publiclyAccessible"],
      relationalDatabaseSnapshotName: params["relationalDatabaseSnapshotName"],
      relationalDatabaseBundleId: params["relationalDatabaseBundleId"],
      sourceRelationalDatabaseName: params["sourceRelationalDatabaseName"],
      restoreTime: jsonP.serializeDate_unixTimestamp(params["restoreTime"]),
      useLatestRestorableTime: params["useLatestRestorableTime"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRelationalDatabaseFromSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async createRelationalDatabaseSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateRelationalDatabaseSnapshotRequest,
  ): Promise<s.CreateRelationalDatabaseSnapshotResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      relationalDatabaseSnapshotName: params["relationalDatabaseSnapshotName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRelationalDatabaseSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteAlarm(
    {abortSignal, ...params}: RequestConfig & s.DeleteAlarmRequest,
  ): Promise<s.DeleteAlarmResult> {
    const body: jsonP.JSONObject = {
      alarmName: params["alarmName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlarm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteAutoSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteAutoSnapshotRequest,
  ): Promise<s.DeleteAutoSnapshotResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
      date: params["date"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAutoSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCertificateRequest,
  ): Promise<s.DeleteCertificateResult> {
    const body: jsonP.JSONObject = {
      certificateName: params["certificateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteContactMethod(
    {abortSignal, ...params}: RequestConfig & s.DeleteContactMethodRequest,
  ): Promise<s.DeleteContactMethodResult> {
    const body: jsonP.JSONObject = {
      protocol: params["protocol"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteContactMethod",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteContainerImage(
    {abortSignal, ...params}: RequestConfig & s.DeleteContainerImageRequest,
  ): Promise<s.DeleteContainerImageResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      image: params["image"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteContainerImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteContainerService(
    {abortSignal, ...params}: RequestConfig & s.DeleteContainerServiceRequest,
  ): Promise<s.DeleteContainerServiceResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteContainerService",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDisk(
    {abortSignal, ...params}: RequestConfig & s.DeleteDiskRequest,
  ): Promise<s.DeleteDiskResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
      forceDeleteAddOns: params["forceDeleteAddOns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDisk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteDiskSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteDiskSnapshotRequest,
  ): Promise<s.DeleteDiskSnapshotResult> {
    const body: jsonP.JSONObject = {
      diskSnapshotName: params["diskSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDiskSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteDistribution(
    {abortSignal, ...params}: RequestConfig & s.DeleteDistributionRequest = {},
  ): Promise<s.DeleteDistributionResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDistribution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<s.DeleteDomainResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async deleteDomainEntry(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainEntryRequest,
  ): Promise<s.DeleteDomainEntryResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      domainEntry: fromDomainEntry(params["domainEntry"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomainEntry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async deleteInstance(
    {abortSignal, ...params}: RequestConfig & s.DeleteInstanceRequest,
  ): Promise<s.DeleteInstanceResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
      forceDeleteAddOns: params["forceDeleteAddOns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteInstanceSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteInstanceSnapshotRequest,
  ): Promise<s.DeleteInstanceSnapshotResult> {
    const body: jsonP.JSONObject = {
      instanceSnapshotName: params["instanceSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInstanceSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteKeyPair(
    {abortSignal, ...params}: RequestConfig & s.DeleteKeyPairRequest,
  ): Promise<s.DeleteKeyPairResult> {
    const body: jsonP.JSONObject = {
      keyPairName: params["keyPairName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async deleteKnownHostKeys(
    {abortSignal, ...params}: RequestConfig & s.DeleteKnownHostKeysRequest,
  ): Promise<s.DeleteKnownHostKeysResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteKnownHostKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.DeleteLoadBalancerRequest,
  ): Promise<s.DeleteLoadBalancerResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteLoadBalancerTlsCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteLoadBalancerTlsCertificateRequest,
  ): Promise<s.DeleteLoadBalancerTlsCertificateResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      certificateName: params["certificateName"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancerTlsCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.DeleteRelationalDatabaseRequest,
  ): Promise<s.DeleteRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      skipFinalSnapshot: params["skipFinalSnapshot"],
      finalRelationalDatabaseSnapshotName: params["finalRelationalDatabaseSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async deleteRelationalDatabaseSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteRelationalDatabaseSnapshotRequest,
  ): Promise<s.DeleteRelationalDatabaseSnapshotResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseSnapshotName: params["relationalDatabaseSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRelationalDatabaseSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async detachCertificateFromDistribution(
    {abortSignal, ...params}: RequestConfig & s.DetachCertificateFromDistributionRequest,
  ): Promise<s.DetachCertificateFromDistributionResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachCertificateFromDistribution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async detachDisk(
    {abortSignal, ...params}: RequestConfig & s.DetachDiskRequest,
  ): Promise<s.DetachDiskResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachDisk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async detachInstancesFromLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.DetachInstancesFromLoadBalancerRequest,
  ): Promise<s.DetachInstancesFromLoadBalancerResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      instanceNames: params["instanceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachInstancesFromLoadBalancer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async detachStaticIp(
    {abortSignal, ...params}: RequestConfig & s.DetachStaticIpRequest,
  ): Promise<s.DetachStaticIpResult> {
    const body: jsonP.JSONObject = {
      staticIpName: params["staticIpName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetachStaticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async disableAddOn(
    {abortSignal, ...params}: RequestConfig & s.DisableAddOnRequest,
  ): Promise<s.DisableAddOnResult> {
    const body: jsonP.JSONObject = {
      addOnType: params["addOnType"],
      resourceName: params["resourceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableAddOn",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async downloadDefaultKeyPair(
    {abortSignal, ...params}: RequestConfig & s.DownloadDefaultKeyPairRequest = {},
  ): Promise<s.DownloadDefaultKeyPairResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DownloadDefaultKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "publicKeyBase64": "s",
        "privateKeyBase64": "s",
      },
    }, await resp.json());
  }

  async enableAddOn(
    {abortSignal, ...params}: RequestConfig & s.EnableAddOnRequest,
  ): Promise<s.EnableAddOnResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
      addOnRequest: fromAddOnRequest(params["addOnRequest"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableAddOn",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async exportSnapshot(
    {abortSignal, ...params}: RequestConfig & s.ExportSnapshotRequest,
  ): Promise<s.ExportSnapshotResult> {
    const body: jsonP.JSONObject = {
      sourceSnapshotName: params["sourceSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async getActiveNames(
    {abortSignal, ...params}: RequestConfig & s.GetActiveNamesRequest = {},
  ): Promise<s.GetActiveNamesResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetActiveNames",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "activeNames": ["s"],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAlarms(
    {abortSignal, ...params}: RequestConfig & s.GetAlarmsRequest = {},
  ): Promise<s.GetAlarmsResult> {
    const body: jsonP.JSONObject = {
      alarmName: params["alarmName"],
      pageToken: params["pageToken"],
      monitoredResourceName: params["monitoredResourceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAlarms",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "alarms": [toAlarm],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getAutoSnapshots(
    {abortSignal, ...params}: RequestConfig & s.GetAutoSnapshotsRequest,
  ): Promise<s.GetAutoSnapshotsResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAutoSnapshots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceName": "s",
        "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
        "autoSnapshots": [toAutoSnapshotDetails],
      },
    }, await resp.json());
  }

  async getBlueprints(
    {abortSignal, ...params}: RequestConfig & s.GetBlueprintsRequest = {},
  ): Promise<s.GetBlueprintsResult> {
    const body: jsonP.JSONObject = {
      includeInactive: params["includeInactive"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlueprints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "blueprints": [toBlueprint],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getBundles(
    {abortSignal, ...params}: RequestConfig & s.GetBundlesRequest = {},
  ): Promise<s.GetBundlesResult> {
    const body: jsonP.JSONObject = {
      includeInactive: params["includeInactive"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBundles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bundles": [toBundle],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getCertificates(
    {abortSignal, ...params}: RequestConfig & s.GetCertificatesRequest = {},
  ): Promise<s.GetCertificatesResult> {
    const body: jsonP.JSONObject = {
      certificateStatuses: params["certificateStatuses"],
      includeCertificateDetails: params["includeCertificateDetails"],
      certificateName: params["certificateName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "certificates": [toCertificateSummary],
      },
    }, await resp.json());
  }

  async getCloudFormationStackRecords(
    {abortSignal, ...params}: RequestConfig & s.GetCloudFormationStackRecordsRequest = {},
  ): Promise<s.GetCloudFormationStackRecordsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCloudFormationStackRecords",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "cloudFormationStackRecords": [toCloudFormationStackRecord],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getContactMethods(
    {abortSignal, ...params}: RequestConfig & s.GetContactMethodsRequest = {},
  ): Promise<s.GetContactMethodsResult> {
    const body: jsonP.JSONObject = {
      protocols: params["protocols"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContactMethods",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "contactMethods": [toContactMethod],
      },
    }, await resp.json());
  }

  async getContainerAPIMetadata(
    {abortSignal, ...params}: RequestConfig & s.GetContainerAPIMetadataRequest = {},
  ): Promise<s.GetContainerAPIMetadataResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerAPIMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metadata": [x => jsonP.readMap(String, String, x)],
      },
    }, await resp.json());
  }

  async getContainerImages(
    {abortSignal, ...params}: RequestConfig & s.GetContainerImagesRequest,
  ): Promise<s.GetContainerImagesResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerImages": [toContainerImage],
      },
    }, await resp.json());
  }

  async getContainerLog(
    {abortSignal, ...params}: RequestConfig & s.GetContainerLogRequest,
  ): Promise<s.GetContainerLogResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      containerName: params["containerName"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      filterPattern: params["filterPattern"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerLog",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logEvents": [toContainerServiceLogEvent],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getContainerServiceDeployments(
    {abortSignal, ...params}: RequestConfig & s.GetContainerServiceDeploymentsRequest,
  ): Promise<s.GetContainerServiceDeploymentsResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerServiceDeployments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deployments": [toContainerServiceDeployment],
      },
    }, await resp.json());
  }

  async getContainerServiceMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetContainerServiceMetricDataRequest,
  ): Promise<s.GetContainerServiceMetricDataResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      metricName: params["metricName"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      period: params["period"],
      statistics: params["statistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerServiceMetricData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerServiceMetricName>(x),
        "metricData": [toMetricDatapoint],
      },
    }, await resp.json());
  }

  async getContainerServicePowers(
    {abortSignal, ...params}: RequestConfig & s.GetContainerServicePowersRequest = {},
  ): Promise<s.GetContainerServicePowersResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerServicePowers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "powers": [toContainerServicePower],
      },
    }, await resp.json());
  }

  async getContainerServices(
    {abortSignal, ...params}: RequestConfig & s.GetContainerServicesRequest = {},
  ): Promise<s.ContainerServicesListResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContainerServices",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerServices": [toContainerService],
      },
    }, await resp.json());
  }

  async getDisk(
    {abortSignal, ...params}: RequestConfig & s.GetDiskRequest,
  ): Promise<s.GetDiskResult> {
    const body: jsonP.JSONObject = {
      diskName: params["diskName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDisk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "disk": toDisk,
      },
    }, await resp.json());
  }

  async getDiskSnapshot(
    {abortSignal, ...params}: RequestConfig & s.GetDiskSnapshotRequest,
  ): Promise<s.GetDiskSnapshotResult> {
    const body: jsonP.JSONObject = {
      diskSnapshotName: params["diskSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDiskSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "diskSnapshot": toDiskSnapshot,
      },
    }, await resp.json());
  }

  async getDiskSnapshots(
    {abortSignal, ...params}: RequestConfig & s.GetDiskSnapshotsRequest = {},
  ): Promise<s.GetDiskSnapshotsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDiskSnapshots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "diskSnapshots": [toDiskSnapshot],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getDisks(
    {abortSignal, ...params}: RequestConfig & s.GetDisksRequest = {},
  ): Promise<s.GetDisksResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDisks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "disks": [toDisk],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getDistributionBundles(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionBundlesRequest = {},
  ): Promise<s.GetDistributionBundlesResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDistributionBundles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bundles": [toDistributionBundle],
      },
    }, await resp.json());
  }

  async getDistributionLatestCacheReset(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionLatestCacheResetRequest = {},
  ): Promise<s.GetDistributionLatestCacheResetResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDistributionLatestCacheReset",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": "s",
        "createTime": "d",
      },
    }, await resp.json());
  }

  async getDistributionMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionMetricDataRequest,
  ): Promise<s.GetDistributionMetricDataResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      metricName: params["metricName"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      period: params["period"],
      unit: params["unit"],
      statistics: params["statistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDistributionMetricData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.DistributionMetricName>(x),
        "metricData": [toMetricDatapoint],
      },
    }, await resp.json());
  }

  async getDistributions(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionsRequest = {},
  ): Promise<s.GetDistributionsResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDistributions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "distributions": [toLightsailDistribution],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getDomain(
    {abortSignal, ...params}: RequestConfig & s.GetDomainRequest,
  ): Promise<s.GetDomainResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domain": toDomain,
      },
    }, await resp.json());
  }

  async getDomains(
    {abortSignal, ...params}: RequestConfig & s.GetDomainsRequest = {},
  ): Promise<s.GetDomainsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDomains",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domains": [toDomain],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getExportSnapshotRecords(
    {abortSignal, ...params}: RequestConfig & s.GetExportSnapshotRecordsRequest = {},
  ): Promise<s.GetExportSnapshotRecordsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetExportSnapshotRecords",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "exportSnapshotRecords": [toExportSnapshotRecord],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getInstance(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceRequest,
  ): Promise<s.GetInstanceResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instance": toInstance,
      },
    }, await resp.json());
  }

  async getInstanceAccessDetails(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceAccessDetailsRequest,
  ): Promise<s.GetInstanceAccessDetailsResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
      protocol: params["protocol"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceAccessDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "accessDetails": toInstanceAccessDetails,
      },
    }, await resp.json());
  }

  async getInstanceMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceMetricDataRequest,
  ): Promise<s.GetInstanceMetricDataResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
      metricName: params["metricName"],
      period: params["period"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      unit: params["unit"],
      statistics: params["statistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceMetricData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceMetricName>(x),
        "metricData": [toMetricDatapoint],
      },
    }, await resp.json());
  }

  async getInstancePortStates(
    {abortSignal, ...params}: RequestConfig & s.GetInstancePortStatesRequest,
  ): Promise<s.GetInstancePortStatesResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstancePortStates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "portStates": [toInstancePortState],
      },
    }, await resp.json());
  }

  async getInstanceSnapshot(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceSnapshotRequest,
  ): Promise<s.GetInstanceSnapshotResult> {
    const body: jsonP.JSONObject = {
      instanceSnapshotName: params["instanceSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceSnapshot": toInstanceSnapshot,
      },
    }, await resp.json());
  }

  async getInstanceSnapshots(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceSnapshotsRequest = {},
  ): Promise<s.GetInstanceSnapshotsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceSnapshots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instanceSnapshots": [toInstanceSnapshot],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getInstanceState(
    {abortSignal, ...params}: RequestConfig & s.GetInstanceStateRequest,
  ): Promise<s.GetInstanceStateResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstanceState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "state": toInstanceState,
      },
    }, await resp.json());
  }

  async getInstances(
    {abortSignal, ...params}: RequestConfig & s.GetInstancesRequest = {},
  ): Promise<s.GetInstancesResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "instances": [toInstance],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getKeyPair(
    {abortSignal, ...params}: RequestConfig & s.GetKeyPairRequest,
  ): Promise<s.GetKeyPairResult> {
    const body: jsonP.JSONObject = {
      keyPairName: params["keyPairName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPair": toKeyPair,
      },
    }, await resp.json());
  }

  async getKeyPairs(
    {abortSignal, ...params}: RequestConfig & s.GetKeyPairsRequest = {},
  ): Promise<s.GetKeyPairsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetKeyPairs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "keyPairs": [toKeyPair],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.GetLoadBalancerRequest,
  ): Promise<s.GetLoadBalancerResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoadBalancer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loadBalancer": toLoadBalancer,
      },
    }, await resp.json());
  }

  async getLoadBalancerMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetLoadBalancerMetricDataRequest,
  ): Promise<s.GetLoadBalancerMetricDataResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      metricName: params["metricName"],
      period: params["period"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      unit: params["unit"],
      statistics: params["statistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoadBalancerMetricData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerMetricName>(x),
        "metricData": [toMetricDatapoint],
      },
    }, await resp.json());
  }

  async getLoadBalancerTlsCertificates(
    {abortSignal, ...params}: RequestConfig & s.GetLoadBalancerTlsCertificatesRequest,
  ): Promise<s.GetLoadBalancerTlsCertificatesResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoadBalancerTlsCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tlsCertificates": [toLoadBalancerTlsCertificate],
      },
    }, await resp.json());
  }

  async getLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.GetLoadBalancersRequest = {},
  ): Promise<s.GetLoadBalancersResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoadBalancers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loadBalancers": [toLoadBalancer],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getOperation(
    {abortSignal, ...params}: RequestConfig & s.GetOperationRequest,
  ): Promise<s.GetOperationResult> {
    const body: jsonP.JSONObject = {
      operationId: params["operationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOperation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async getOperations(
    {abortSignal, ...params}: RequestConfig & s.GetOperationsRequest = {},
  ): Promise<s.GetOperationsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOperations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getOperationsForResource(
    {abortSignal, ...params}: RequestConfig & s.GetOperationsForResourceRequest,
  ): Promise<s.GetOperationsForResourceResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOperationsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
        "nextPageCount": "s",
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRegions(
    {abortSignal, ...params}: RequestConfig & s.GetRegionsRequest = {},
  ): Promise<s.GetRegionsResult> {
    const body: jsonP.JSONObject = {
      includeAvailabilityZones: params["includeAvailabilityZones"],
      includeRelationalDatabaseAvailabilityZones: params["includeRelationalDatabaseAvailabilityZones"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "regions": [toRegion],
      },
    }, await resp.json());
  }

  async getRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseRequest,
  ): Promise<s.GetRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "relationalDatabase": toRelationalDatabase,
      },
    }, await resp.json());
  }

  async getRelationalDatabaseBlueprints(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseBlueprintsRequest = {},
  ): Promise<s.GetRelationalDatabaseBlueprintsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseBlueprints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "blueprints": [toRelationalDatabaseBlueprint],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseBundles(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseBundlesRequest = {},
  ): Promise<s.GetRelationalDatabaseBundlesResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseBundles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bundles": [toRelationalDatabaseBundle],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseEvents(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseEventsRequest,
  ): Promise<s.GetRelationalDatabaseEventsResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      durationInMinutes: params["durationInMinutes"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "relationalDatabaseEvents": [toRelationalDatabaseEvent],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseLogEvents(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseLogEventsRequest,
  ): Promise<s.GetRelationalDatabaseLogEventsResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      logStreamName: params["logStreamName"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      startFromHead: params["startFromHead"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseLogEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceLogEvents": [toLogEvent],
        "nextBackwardToken": "s",
        "nextForwardToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseLogStreams(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseLogStreamsRequest,
  ): Promise<s.GetRelationalDatabaseLogStreamsResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseLogStreams",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "logStreams": ["s"],
      },
    }, await resp.json());
  }

  async getRelationalDatabaseMasterUserPassword(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseMasterUserPasswordRequest,
  ): Promise<s.GetRelationalDatabaseMasterUserPasswordResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      passwordVersion: params["passwordVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseMasterUserPassword",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "masterUserPassword": "s",
        "createdAt": "d",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseMetricData(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseMetricDataRequest,
  ): Promise<s.GetRelationalDatabaseMetricDataResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      metricName: params["metricName"],
      period: params["period"],
      startTime: jsonP.serializeDate_unixTimestamp(params["startTime"]),
      endTime: jsonP.serializeDate_unixTimestamp(params["endTime"]),
      unit: params["unit"],
      statistics: params["statistics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseMetricData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationalDatabaseMetricName>(x),
        "metricData": [toMetricDatapoint],
      },
    }, await resp.json());
  }

  async getRelationalDatabaseParameters(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseParametersRequest,
  ): Promise<s.GetRelationalDatabaseParametersResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "parameters": [toRelationalDatabaseParameter],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabaseSnapshot(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseSnapshotRequest,
  ): Promise<s.GetRelationalDatabaseSnapshotResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseSnapshotName: params["relationalDatabaseSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "relationalDatabaseSnapshot": toRelationalDatabaseSnapshot,
      },
    }, await resp.json());
  }

  async getRelationalDatabaseSnapshots(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabaseSnapshotsRequest = {},
  ): Promise<s.GetRelationalDatabaseSnapshotsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabaseSnapshots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "relationalDatabaseSnapshots": [toRelationalDatabaseSnapshot],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getRelationalDatabases(
    {abortSignal, ...params}: RequestConfig & s.GetRelationalDatabasesRequest = {},
  ): Promise<s.GetRelationalDatabasesResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRelationalDatabases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "relationalDatabases": [toRelationalDatabase],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async getStaticIp(
    {abortSignal, ...params}: RequestConfig & s.GetStaticIpRequest,
  ): Promise<s.GetStaticIpResult> {
    const body: jsonP.JSONObject = {
      staticIpName: params["staticIpName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStaticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "staticIp": toStaticIp,
      },
    }, await resp.json());
  }

  async getStaticIps(
    {abortSignal, ...params}: RequestConfig & s.GetStaticIpsRequest = {},
  ): Promise<s.GetStaticIpsResult> {
    const body: jsonP.JSONObject = {
      pageToken: params["pageToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStaticIps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "staticIps": [toStaticIp],
        "nextPageToken": "s",
      },
    }, await resp.json());
  }

  async importKeyPair(
    {abortSignal, ...params}: RequestConfig & s.ImportKeyPairRequest,
  ): Promise<s.ImportKeyPairResult> {
    const body: jsonP.JSONObject = {
      keyPairName: params["keyPairName"],
      publicKeyBase64: params["publicKeyBase64"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportKeyPair",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async isVpcPeered(
    {abortSignal, ...params}: RequestConfig & s.IsVpcPeeredRequest = {},
  ): Promise<s.IsVpcPeeredResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IsVpcPeered",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "isPeered": "b",
      },
    }, await resp.json());
  }

  async openInstancePublicPorts(
    {abortSignal, ...params}: RequestConfig & s.OpenInstancePublicPortsRequest,
  ): Promise<s.OpenInstancePublicPortsResult> {
    const body: jsonP.JSONObject = {
      portInfo: fromPortInfo(params["portInfo"]),
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "OpenInstancePublicPorts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async peerVpc(
    {abortSignal, ...params}: RequestConfig & s.PeerVpcRequest = {},
  ): Promise<s.PeerVpcResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PeerVpc",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async putAlarm(
    {abortSignal, ...params}: RequestConfig & s.PutAlarmRequest,
  ): Promise<s.PutAlarmResult> {
    const body: jsonP.JSONObject = {
      alarmName: params["alarmName"],
      metricName: params["metricName"],
      monitoredResourceName: params["monitoredResourceName"],
      comparisonOperator: params["comparisonOperator"],
      threshold: params["threshold"],
      evaluationPeriods: params["evaluationPeriods"],
      datapointsToAlarm: params["datapointsToAlarm"],
      treatMissingData: params["treatMissingData"],
      contactProtocols: params["contactProtocols"],
      notificationTriggers: params["notificationTriggers"],
      notificationEnabled: params["notificationEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAlarm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async putInstancePublicPorts(
    {abortSignal, ...params}: RequestConfig & s.PutInstancePublicPortsRequest,
  ): Promise<s.PutInstancePublicPortsResult> {
    const body: jsonP.JSONObject = {
      portInfos: params["portInfos"]?.map(x => fromPortInfo(x)),
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutInstancePublicPorts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async rebootInstance(
    {abortSignal, ...params}: RequestConfig & s.RebootInstanceRequest,
  ): Promise<s.RebootInstanceResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async rebootRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.RebootRelationalDatabaseRequest,
  ): Promise<s.RebootRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async registerContainerImage(
    {abortSignal, ...params}: RequestConfig & s.RegisterContainerImageRequest,
  ): Promise<s.RegisterContainerImageResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      label: params["label"],
      digest: params["digest"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterContainerImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerImage": toContainerImage,
      },
    }, await resp.json());
  }

  async releaseStaticIp(
    {abortSignal, ...params}: RequestConfig & s.ReleaseStaticIpRequest,
  ): Promise<s.ReleaseStaticIpResult> {
    const body: jsonP.JSONObject = {
      staticIpName: params["staticIpName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReleaseStaticIp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async resetDistributionCache(
    {abortSignal, ...params}: RequestConfig & s.ResetDistributionCacheRequest = {},
  ): Promise<s.ResetDistributionCacheResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDistributionCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": "s",
        "createTime": "d",
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async sendContactMethodVerification(
    {abortSignal, ...params}: RequestConfig & s.SendContactMethodVerificationRequest,
  ): Promise<s.SendContactMethodVerificationResult> {
    const body: jsonP.JSONObject = {
      protocol: params["protocol"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendContactMethodVerification",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async setIpAddressType(
    {abortSignal, ...params}: RequestConfig & s.SetIpAddressTypeRequest,
  ): Promise<s.SetIpAddressTypeResult> {
    const body: jsonP.JSONObject = {
      resourceType: params["resourceType"],
      resourceName: params["resourceName"],
      ipAddressType: params["ipAddressType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIpAddressType",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async startInstance(
    {abortSignal, ...params}: RequestConfig & s.StartInstanceRequest,
  ): Promise<s.StartInstanceResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async startRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.StartRelationalDatabaseRequest,
  ): Promise<s.StartRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async stopInstance(
    {abortSignal, ...params}: RequestConfig & s.StopInstanceRequest,
  ): Promise<s.StopInstanceResult> {
    const body: jsonP.JSONObject = {
      instanceName: params["instanceName"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async stopRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.StopRelationalDatabaseRequest,
  ): Promise<s.StopRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      relationalDatabaseSnapshotName: params["relationalDatabaseSnapshotName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async testAlarm(
    {abortSignal, ...params}: RequestConfig & s.TestAlarmRequest,
  ): Promise<s.TestAlarmResult> {
    const body: jsonP.JSONObject = {
      alarmName: params["alarmName"],
      state: params["state"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TestAlarm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async unpeerVpc(
    {abortSignal, ...params}: RequestConfig & s.UnpeerVpcRequest = {},
  ): Promise<s.UnpeerVpcResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnpeerVpc",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResult> {
    const body: jsonP.JSONObject = {
      resourceName: params["resourceName"],
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async updateContainerService(
    {abortSignal, ...params}: RequestConfig & s.UpdateContainerServiceRequest,
  ): Promise<s.UpdateContainerServiceResult> {
    const body: jsonP.JSONObject = {
      serviceName: params["serviceName"],
      power: params["power"],
      scale: params["scale"],
      isDisabled: params["isDisabled"],
      publicDomainNames: params["publicDomainNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContainerService",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "containerService": toContainerService,
      },
    }, await resp.json());
  }

  async updateDistribution(
    {abortSignal, ...params}: RequestConfig & s.UpdateDistributionRequest,
  ): Promise<s.UpdateDistributionResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      origin: fromInputOrigin(params["origin"]),
      defaultCacheBehavior: fromCacheBehavior(params["defaultCacheBehavior"]),
      cacheBehaviorSettings: fromCacheSettings(params["cacheBehaviorSettings"]),
      cacheBehaviors: params["cacheBehaviors"]?.map(x => fromCacheBehaviorPerPath(x)),
      isEnabled: params["isEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDistribution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async updateDistributionBundle(
    {abortSignal, ...params}: RequestConfig & s.UpdateDistributionBundleRequest = {},
  ): Promise<s.UpdateDistributionBundleResult> {
    const body: jsonP.JSONObject = {
      distributionName: params["distributionName"],
      bundleId: params["bundleId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDistributionBundle",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operation": toOperation,
      },
    }, await resp.json());
  }

  async updateDomainEntry(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainEntryRequest,
  ): Promise<s.UpdateDomainEntryResult> {
    const body: jsonP.JSONObject = {
      domainName: params["domainName"],
      domainEntry: fromDomainEntry(params["domainEntry"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainEntry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async updateLoadBalancerAttribute(
    {abortSignal, ...params}: RequestConfig & s.UpdateLoadBalancerAttributeRequest,
  ): Promise<s.UpdateLoadBalancerAttributeResult> {
    const body: jsonP.JSONObject = {
      loadBalancerName: params["loadBalancerName"],
      attributeName: params["attributeName"],
      attributeValue: params["attributeValue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLoadBalancerAttribute",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async updateRelationalDatabase(
    {abortSignal, ...params}: RequestConfig & s.UpdateRelationalDatabaseRequest,
  ): Promise<s.UpdateRelationalDatabaseResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      masterUserPassword: params["masterUserPassword"],
      rotateMasterUserPassword: params["rotateMasterUserPassword"],
      preferredBackupWindow: params["preferredBackupWindow"],
      preferredMaintenanceWindow: params["preferredMaintenanceWindow"],
      enableBackupRetention: params["enableBackupRetention"],
      disableBackupRetention: params["disableBackupRetention"],
      publiclyAccessible: params["publiclyAccessible"],
      applyImmediately: params["applyImmediately"],
      caCertificateIdentifier: params["caCertificateIdentifier"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRelationalDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

  async updateRelationalDatabaseParameters(
    {abortSignal, ...params}: RequestConfig & s.UpdateRelationalDatabaseParametersRequest,
  ): Promise<s.UpdateRelationalDatabaseParametersResult> {
    const body: jsonP.JSONObject = {
      relationalDatabaseName: params["relationalDatabaseName"],
      parameters: params["parameters"]?.map(x => fromRelationalDatabaseParameter(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRelationalDatabaseParameters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "operations": [toOperation],
      },
    }, await resp.json());
  }

}

function fromPortInfo(input?: s.PortInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fromPort: input["fromPort"],
    toPort: input["toPort"],
    protocol: input["protocol"],
    cidrs: input["cidrs"],
    ipv6Cidrs: input["ipv6Cidrs"],
    cidrListAliases: input["cidrListAliases"],
  }
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

function fromInstanceEntry(input?: s.InstanceEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceName: input["sourceName"],
    instanceType: input["instanceType"],
    portInfoSource: input["portInfoSource"],
    userData: input["userData"],
    availabilityZone: input["availabilityZone"],
  }
}

function fromContainerServiceDeploymentRequest(input?: s.ContainerServiceDeploymentRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containers: jsonP.serializeMap(input["containers"], x => fromContainer(x)),
    publicEndpoint: fromEndpointRequest(input["publicEndpoint"]),
  }
}

function fromContainer(input?: s.Container | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    image: input["image"],
    command: input["command"],
    environment: input["environment"],
    ports: input["ports"],
  }
}
function toContainer(root: jsonP.JSONValue): s.Container {
  return jsonP.readObj({
    required: {},
    optional: {
      "image": "s",
      "command": ["s"],
      "environment": x => jsonP.readMap(String, String, x),
      "ports": x => jsonP.readMap(String, y => cmnP.readEnum<s.ContainerServiceProtocol>(y), x),
    },
  }, root);
}

function fromEndpointRequest(input?: s.EndpointRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerName: input["containerName"],
    containerPort: input["containerPort"],
    healthCheck: fromContainerServiceHealthCheckConfig(input["healthCheck"]),
  }
}

function fromContainerServiceHealthCheckConfig(input?: s.ContainerServiceHealthCheckConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthyThreshold: input["healthyThreshold"],
    unhealthyThreshold: input["unhealthyThreshold"],
    timeoutSeconds: input["timeoutSeconds"],
    intervalSeconds: input["intervalSeconds"],
    path: input["path"],
    successCodes: input["successCodes"],
  }
}
function toContainerServiceHealthCheckConfig(root: jsonP.JSONValue): s.ContainerServiceHealthCheckConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "healthyThreshold": "n",
      "unhealthyThreshold": "n",
      "timeoutSeconds": "n",
      "intervalSeconds": "n",
      "path": "s",
      "successCodes": "s",
    },
  }, root);
}

function fromAddOnRequest(input?: s.AddOnRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    addOnType: input["addOnType"],
    autoSnapshotAddOnRequest: fromAutoSnapshotAddOnRequest(input["autoSnapshotAddOnRequest"]),
  }
}

function fromAutoSnapshotAddOnRequest(input?: s.AutoSnapshotAddOnRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    snapshotTimeOfDay: input["snapshotTimeOfDay"],
  }
}

function fromInputOrigin(input?: s.InputOrigin | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    regionName: input["regionName"],
    protocolPolicy: input["protocolPolicy"],
  }
}

function fromCacheBehavior(input?: s.CacheBehavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    behavior: input["behavior"],
  }
}
function toCacheBehavior(root: jsonP.JSONValue): s.CacheBehavior {
  return jsonP.readObj({
    required: {},
    optional: {
      "behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.BehaviorEnum>(x),
    },
  }, root);
}

function fromCacheSettings(input?: s.CacheSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultTTL: input["defaultTTL"],
    minimumTTL: input["minimumTTL"],
    maximumTTL: input["maximumTTL"],
    allowedHTTPMethods: input["allowedHTTPMethods"],
    cachedHTTPMethods: input["cachedHTTPMethods"],
    forwardedCookies: fromCookieObject(input["forwardedCookies"]),
    forwardedHeaders: fromHeaderObject(input["forwardedHeaders"]),
    forwardedQueryStrings: fromQueryStringObject(input["forwardedQueryStrings"]),
  }
}
function toCacheSettings(root: jsonP.JSONValue): s.CacheSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "defaultTTL": "n",
      "minimumTTL": "n",
      "maximumTTL": "n",
      "allowedHTTPMethods": "s",
      "cachedHTTPMethods": "s",
      "forwardedCookies": toCookieObject,
      "forwardedHeaders": toHeaderObject,
      "forwardedQueryStrings": toQueryStringObject,
    },
  }, root);
}

function fromCookieObject(input?: s.CookieObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    option: input["option"],
    cookiesAllowList: input["cookiesAllowList"],
  }
}
function toCookieObject(root: jsonP.JSONValue): s.CookieObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "option": (x: jsonP.JSONValue) => cmnP.readEnum<s.ForwardValues>(x),
      "cookiesAllowList": ["s"],
    },
  }, root);
}

function fromHeaderObject(input?: s.HeaderObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    option: input["option"],
    headersAllowList: input["headersAllowList"],
  }
}
function toHeaderObject(root: jsonP.JSONValue): s.HeaderObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "option": (x: jsonP.JSONValue) => cmnP.readEnum<s.ForwardValues>(x),
      "headersAllowList": [(x: jsonP.JSONValue) => cmnP.readEnum<s.HeaderEnum>(x)],
    },
  }, root);
}

function fromQueryStringObject(input?: s.QueryStringObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    option: input["option"],
    queryStringsAllowList: input["queryStringsAllowList"],
  }
}
function toQueryStringObject(root: jsonP.JSONValue): s.QueryStringObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "option": "b",
      "queryStringsAllowList": ["s"],
    },
  }, root);
}

function fromCacheBehaviorPerPath(input?: s.CacheBehaviorPerPath | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
    behavior: input["behavior"],
  }
}
function toCacheBehaviorPerPath(root: jsonP.JSONValue): s.CacheBehaviorPerPath {
  return jsonP.readObj({
    required: {},
    optional: {
      "path": "s",
      "behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.BehaviorEnum>(x),
    },
  }, root);
}

function fromDomainEntry(input?: s.DomainEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    name: input["name"],
    target: input["target"],
    isAlias: input["isAlias"],
    type: input["type"],
    options: input["options"],
  }
}
function toDomainEntry(root: jsonP.JSONValue): s.DomainEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "target": "s",
      "isAlias": "b",
      "type": "s",
      "options": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromDiskMap(input?: s.DiskMap | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    originalDiskPath: input["originalDiskPath"],
    newDiskName: input["newDiskName"],
  }
}

function fromRelationalDatabaseParameter(input?: s.RelationalDatabaseParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    allowedValues: input["allowedValues"],
    applyMethod: input["applyMethod"],
    applyType: input["applyType"],
    dataType: input["dataType"],
    description: input["description"],
    isModifiable: input["isModifiable"],
    parameterName: input["parameterName"],
    parameterValue: input["parameterValue"],
  }
}
function toRelationalDatabaseParameter(root: jsonP.JSONValue): s.RelationalDatabaseParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "allowedValues": "s",
      "applyMethod": "s",
      "applyType": "s",
      "dataType": "s",
      "description": "s",
      "isModifiable": "b",
      "parameterName": "s",
      "parameterValue": "s",
    },
  }, root);
}

function toOperation(root: jsonP.JSONValue): s.Operation {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "resourceName": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "createdAt": "d",
      "location": toResourceLocation,
      "isTerminal": "b",
      "operationDetails": "s",
      "operationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperationType>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperationStatus>(x),
      "statusChangedAt": "d",
      "errorCode": "s",
      "errorDetails": "s",
    },
  }, root);
}

function toResourceLocation(root: jsonP.JSONValue): s.ResourceLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "availabilityZone": "s",
      "regionName": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegionName>(x),
    },
  }, root);
}

function toCertificateSummary(root: jsonP.JSONValue): s.CertificateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "certificateArn": "s",
      "certificateName": "s",
      "domainName": "s",
      "certificateDetail": toCertificate,
      "tags": [toTag],
    },
  }, root);
}

function toCertificate(root: jsonP.JSONValue): s.Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "domainName": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateStatus>(x),
      "serialNumber": "s",
      "subjectAlternativeNames": ["s"],
      "domainValidationRecords": [toDomainValidationRecord],
      "requestFailureReason": "s",
      "inUseResourceCount": "n",
      "keyAlgorithm": "s",
      "createdAt": "d",
      "issuedAt": "d",
      "issuerCA": "s",
      "notBefore": "d",
      "notAfter": "d",
      "eligibleToRenew": "s",
      "renewalSummary": toRenewalSummary,
      "revokedAt": "d",
      "revocationReason": "s",
      "tags": [toTag],
      "supportCode": "s",
    },
  }, root);
}

function toDomainValidationRecord(root: jsonP.JSONValue): s.DomainValidationRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainName": "s",
      "resourceRecord": toResourceRecord,
    },
  }, root);
}

function toResourceRecord(root: jsonP.JSONValue): s.ResourceRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "type": "s",
      "value": "s",
    },
  }, root);
}

function toRenewalSummary(root: jsonP.JSONValue): s.RenewalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainValidationRecords": [toDomainValidationRecord],
      "renewalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RenewalStatus>(x),
      "renewalStatusReason": "s",
      "updatedAt": "d",
    },
  }, root);
}

function toContainerService(root: jsonP.JSONValue): s.ContainerService {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerServiceName": "s",
      "arn": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "power": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerServicePowerName>(x),
      "powerId": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerServiceState>(x),
      "scale": "n",
      "currentDeployment": toContainerServiceDeployment,
      "nextDeployment": toContainerServiceDeployment,
      "isDisabled": "b",
      "principalArn": "s",
      "privateDomainName": "s",
      "publicDomainNames": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "url": "s",
    },
  }, root);
}

function toContainerServiceDeployment(root: jsonP.JSONValue): s.ContainerServiceDeployment {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "n",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerServiceDeploymentState>(x),
      "containers": x => jsonP.readMap(String, toContainer, x),
      "publicEndpoint": toContainerServiceEndpoint,
      "createdAt": "d",
    },
  }, root);
}

function toContainerServiceEndpoint(root: jsonP.JSONValue): s.ContainerServiceEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerName": "s",
      "containerPort": "n",
      "healthCheck": toContainerServiceHealthCheckConfig,
    },
  }, root);
}

function toContainerServiceRegistryLogin(root: jsonP.JSONValue): s.ContainerServiceRegistryLogin {
  return jsonP.readObj({
    required: {},
    optional: {
      "username": "s",
      "password": "s",
      "expiresAt": "d",
      "registry": "s",
    },
  }, root);
}

function toLightsailDistribution(root: jsonP.JSONValue): s.LightsailDistribution {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "alternativeDomainNames": ["s"],
      "status": "s",
      "isEnabled": "b",
      "domainName": "s",
      "bundleId": "s",
      "certificateName": "s",
      "origin": toOrigin,
      "originPublicDNS": "s",
      "defaultCacheBehavior": toCacheBehavior,
      "cacheBehaviorSettings": toCacheSettings,
      "cacheBehaviors": [toCacheBehaviorPerPath],
      "ableToUpdateBundle": "b",
      "ipAddressType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpAddressType>(x),
      "tags": [toTag],
    },
  }, root);
}

function toOrigin(root: jsonP.JSONValue): s.Origin {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "regionName": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegionName>(x),
      "protocolPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.OriginProtocolPolicyEnum>(x),
    },
  }, root);
}

function toKeyPair(root: jsonP.JSONValue): s.KeyPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "fingerprint": "s",
    },
  }, root);
}

function toAlarm(root: jsonP.JSONValue): s.Alarm {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "supportCode": "s",
      "monitoredResourceInfo": toMonitoredResourceInfo,
      "comparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperator>(x),
      "evaluationPeriods": "n",
      "period": "n",
      "threshold": "n",
      "datapointsToAlarm": "n",
      "treatMissingData": (x: jsonP.JSONValue) => cmnP.readEnum<s.TreatMissingData>(x),
      "statistic": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricStatistic>(x),
      "metricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricName>(x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.AlarmState>(x),
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricUnit>(x),
      "contactProtocols": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ContactProtocol>(x)],
      "notificationTriggers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.AlarmState>(x)],
      "notificationEnabled": "b",
    },
  }, root);
}

function toMonitoredResourceInfo(root: jsonP.JSONValue): s.MonitoredResourceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
    },
  }, root);
}

function toAutoSnapshotDetails(root: jsonP.JSONValue): s.AutoSnapshotDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "date": "s",
      "createdAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoSnapshotStatus>(x),
      "fromAttachedDisks": [toAttachedDisk],
    },
  }, root);
}

function toAttachedDisk(root: jsonP.JSONValue): s.AttachedDisk {
  return jsonP.readObj({
    required: {},
    optional: {
      "path": "s",
      "sizeInGb": "n",
    },
  }, root);
}

function toBlueprint(root: jsonP.JSONValue): s.Blueprint {
  return jsonP.readObj({
    required: {},
    optional: {
      "blueprintId": "s",
      "name": "s",
      "group": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.BlueprintType>(x),
      "description": "s",
      "isActive": "b",
      "minPower": "n",
      "version": "s",
      "versionCode": "s",
      "productUrl": "s",
      "licenseUrl": "s",
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstancePlatform>(x),
    },
  }, root);
}

function toBundle(root: jsonP.JSONValue): s.Bundle {
  return jsonP.readObj({
    required: {},
    optional: {
      "price": "n",
      "cpuCount": "n",
      "diskSizeInGb": "n",
      "bundleId": "s",
      "instanceType": "s",
      "isActive": "b",
      "name": "s",
      "power": "n",
      "ramSizeInGb": "n",
      "transferPerMonthInGb": "n",
      "supportedPlatforms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.InstancePlatform>(x)],
    },
  }, root);
}

function toCloudFormationStackRecord(root: jsonP.JSONValue): s.CloudFormationStackRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordState>(x),
      "sourceInfo": [toCloudFormationStackRecordSourceInfo],
      "destinationInfo": toDestinationInfo,
    },
  }, root);
}

function toCloudFormationStackRecordSourceInfo(root: jsonP.JSONValue): s.CloudFormationStackRecordSourceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloudFormationStackRecordSourceType>(x),
      "name": "s",
      "arn": "s",
    },
  }, root);
}

function toDestinationInfo(root: jsonP.JSONValue): s.DestinationInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "service": "s",
    },
  }, root);
}

function toContactMethod(root: jsonP.JSONValue): s.ContactMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "contactEndpoint": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContactMethodStatus>(x),
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContactProtocol>(x),
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "supportCode": "s",
    },
  }, root);
}

function toContainerImage(root: jsonP.JSONValue): s.ContainerImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "image": "s",
      "digest": "s",
      "createdAt": "d",
    },
  }, root);
}

function toContainerServiceLogEvent(root: jsonP.JSONValue): s.ContainerServiceLogEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "createdAt": "d",
      "message": "s",
    },
  }, root);
}

function toMetricDatapoint(root: jsonP.JSONValue): s.MetricDatapoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "average": "n",
      "maximum": "n",
      "minimum": "n",
      "sampleCount": "n",
      "sum": "n",
      "timestamp": "d",
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricUnit>(x),
    },
  }, root);
}

function toContainerServicePower(root: jsonP.JSONValue): s.ContainerServicePower {
  return jsonP.readObj({
    required: {},
    optional: {
      "powerId": "s",
      "price": "n",
      "cpuCount": "n",
      "ramSizeInGb": "n",
      "name": "s",
      "isActive": "b",
    },
  }, root);
}

function toDisk(root: jsonP.JSONValue): s.Disk {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "addOns": [toAddOn],
      "sizeInGb": "n",
      "isSystemDisk": "b",
      "iops": "n",
      "path": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.DiskState>(x),
      "attachedTo": "s",
      "isAttached": "b",
      "attachmentState": "s",
      "gbInUse": "n",
    },
  }, root);
}

function toAddOn(root: jsonP.JSONValue): s.AddOn {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "status": "s",
      "snapshotTimeOfDay": "s",
      "nextSnapshotTimeOfDay": "s",
    },
  }, root);
}

function toDiskSnapshot(root: jsonP.JSONValue): s.DiskSnapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "sizeInGb": "n",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.DiskSnapshotState>(x),
      "progress": "s",
      "fromDiskName": "s",
      "fromDiskArn": "s",
      "fromInstanceName": "s",
      "fromInstanceArn": "s",
      "isFromAutoSnapshot": "b",
    },
  }, root);
}

function toDistributionBundle(root: jsonP.JSONValue): s.DistributionBundle {
  return jsonP.readObj({
    required: {},
    optional: {
      "bundleId": "s",
      "name": "s",
      "price": "n",
      "transferPerMonthInGb": "n",
      "isActive": "b",
    },
  }, root);
}

function toDomain(root: jsonP.JSONValue): s.Domain {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "domainEntries": [toDomainEntry],
    },
  }, root);
}

function toExportSnapshotRecord(root: jsonP.JSONValue): s.ExportSnapshotRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordState>(x),
      "sourceInfo": toExportSnapshotRecordSourceInfo,
      "destinationInfo": toDestinationInfo,
    },
  }, root);
}

function toExportSnapshotRecordSourceInfo(root: jsonP.JSONValue): s.ExportSnapshotRecordSourceInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportSnapshotRecordSourceType>(x),
      "createdAt": "d",
      "name": "s",
      "arn": "s",
      "fromResourceName": "s",
      "fromResourceArn": "s",
      "instanceSnapshotInfo": toInstanceSnapshotInfo,
      "diskSnapshotInfo": toDiskSnapshotInfo,
    },
  }, root);
}

function toInstanceSnapshotInfo(root: jsonP.JSONValue): s.InstanceSnapshotInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "fromBundleId": "s",
      "fromBlueprintId": "s",
      "fromDiskInfo": [toDiskInfo],
    },
  }, root);
}

function toDiskInfo(root: jsonP.JSONValue): s.DiskInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "path": "s",
      "sizeInGb": "n",
      "isSystemDisk": "b",
    },
  }, root);
}

function toDiskSnapshotInfo(root: jsonP.JSONValue): s.DiskSnapshotInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "sizeInGb": "n",
    },
  }, root);
}

function toInstance(root: jsonP.JSONValue): s.Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "blueprintId": "s",
      "blueprintName": "s",
      "bundleId": "s",
      "addOns": [toAddOn],
      "isStaticIp": "b",
      "privateIpAddress": "s",
      "publicIpAddress": "s",
      "ipv6Addresses": ["s"],
      "ipAddressType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpAddressType>(x),
      "hardware": toInstanceHardware,
      "networking": toInstanceNetworking,
      "state": toInstanceState,
      "username": "s",
      "sshKeyName": "s",
    },
  }, root);
}

function toInstanceHardware(root: jsonP.JSONValue): s.InstanceHardware {
  return jsonP.readObj({
    required: {},
    optional: {
      "cpuCount": "n",
      "disks": [toDisk],
      "ramSizeInGb": "n",
    },
  }, root);
}

function toInstanceNetworking(root: jsonP.JSONValue): s.InstanceNetworking {
  return jsonP.readObj({
    required: {},
    optional: {
      "monthlyTransfer": toMonthlyTransfer,
      "ports": [toInstancePortInfo],
    },
  }, root);
}

function toMonthlyTransfer(root: jsonP.JSONValue): s.MonthlyTransfer {
  return jsonP.readObj({
    required: {},
    optional: {
      "gbPerMonthAllocated": "n",
    },
  }, root);
}

function toInstancePortInfo(root: jsonP.JSONValue): s.InstancePortInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "fromPort": "n",
      "toPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkProtocol>(x),
      "accessFrom": "s",
      "accessType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PortAccessType>(x),
      "commonName": "s",
      "accessDirection": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccessDirection>(x),
      "cidrs": ["s"],
      "ipv6Cidrs": ["s"],
      "cidrListAliases": ["s"],
    },
  }, root);
}

function toInstanceState(root: jsonP.JSONValue): s.InstanceState {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "n",
      "name": "s",
    },
  }, root);
}

function toInstanceAccessDetails(root: jsonP.JSONValue): s.InstanceAccessDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "certKey": "s",
      "expiresAt": "d",
      "ipAddress": "s",
      "password": "s",
      "passwordData": toPasswordData,
      "privateKey": "s",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceAccessProtocol>(x),
      "instanceName": "s",
      "username": "s",
      "hostKeys": [toHostKeyAttributes],
    },
  }, root);
}

function toPasswordData(root: jsonP.JSONValue): s.PasswordData {
  return jsonP.readObj({
    required: {},
    optional: {
      "ciphertext": "s",
      "keyPairName": "s",
    },
  }, root);
}

function toHostKeyAttributes(root: jsonP.JSONValue): s.HostKeyAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "algorithm": "s",
      "publicKey": "s",
      "witnessedAt": "d",
      "fingerprintSHA1": "s",
      "fingerprintSHA256": "s",
      "notValidBefore": "d",
      "notValidAfter": "d",
    },
  }, root);
}

function toInstancePortState(root: jsonP.JSONValue): s.InstancePortState {
  return jsonP.readObj({
    required: {},
    optional: {
      "fromPort": "n",
      "toPort": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkProtocol>(x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.PortState>(x),
      "cidrs": ["s"],
      "ipv6Cidrs": ["s"],
      "cidrListAliases": ["s"],
    },
  }, root);
}

function toInstanceSnapshot(root: jsonP.JSONValue): s.InstanceSnapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceSnapshotState>(x),
      "progress": "s",
      "fromAttachedDisks": [toDisk],
      "fromInstanceName": "s",
      "fromInstanceArn": "s",
      "fromBlueprintId": "s",
      "fromBundleId": "s",
      "isFromAutoSnapshot": "b",
      "sizeInGb": "n",
    },
  }, root);
}

function toLoadBalancer(root: jsonP.JSONValue): s.LoadBalancer {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "dnsName": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerState>(x),
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerProtocol>(x),
      "publicPorts": ["n"],
      "healthCheckPath": "s",
      "instancePort": "n",
      "instanceHealthSummary": [toInstanceHealthSummary],
      "tlsCertificateSummaries": [toLoadBalancerTlsCertificateSummary],
      "configurationOptions": x => jsonP.readMap(x => cmnP.readEnumReq<s.LoadBalancerAttributeName>(x), String, x),
      "ipAddressType": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpAddressType>(x),
    },
  }, root);
}

function toInstanceHealthSummary(root: jsonP.JSONValue): s.InstanceHealthSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "instanceName": "s",
      "instanceHealth": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceHealthState>(x),
      "instanceHealthReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceHealthReason>(x),
    },
  }, root);
}

function toLoadBalancerTlsCertificateSummary(root: jsonP.JSONValue): s.LoadBalancerTlsCertificateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "isAttached": "b",
    },
  }, root);
}

function toLoadBalancerTlsCertificate(root: jsonP.JSONValue): s.LoadBalancerTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "loadBalancerName": "s",
      "isAttached": "b",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateStatus>(x),
      "domainName": "s",
      "domainValidationRecords": [toLoadBalancerTlsCertificateDomainValidationRecord],
      "failureReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateFailureReason>(x),
      "issuedAt": "d",
      "issuer": "s",
      "keyAlgorithm": "s",
      "notAfter": "d",
      "notBefore": "d",
      "renewalSummary": toLoadBalancerTlsCertificateRenewalSummary,
      "revocationReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateRevocationReason>(x),
      "revokedAt": "d",
      "serial": "s",
      "signatureAlgorithm": "s",
      "subject": "s",
      "subjectAlternativeNames": ["s"],
    },
  }, root);
}

function toLoadBalancerTlsCertificateDomainValidationRecord(root: jsonP.JSONValue): s.LoadBalancerTlsCertificateDomainValidationRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "type": "s",
      "value": "s",
      "validationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateDomainStatus>(x),
      "domainName": "s",
    },
  }, root);
}

function toLoadBalancerTlsCertificateRenewalSummary(root: jsonP.JSONValue): s.LoadBalancerTlsCertificateRenewalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "renewalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateRenewalStatus>(x),
      "domainValidationOptions": [toLoadBalancerTlsCertificateDomainValidationOption],
    },
  }, root);
}

function toLoadBalancerTlsCertificateDomainValidationOption(root: jsonP.JSONValue): s.LoadBalancerTlsCertificateDomainValidationOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "domainName": "s",
      "validationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoadBalancerTlsCertificateDomainStatus>(x),
    },
  }, root);
}

function toRegion(root: jsonP.JSONValue): s.Region {
  return jsonP.readObj({
    required: {},
    optional: {
      "continentCode": "s",
      "description": "s",
      "displayName": "s",
      "name": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegionName>(x),
      "availabilityZones": [toAvailabilityZone],
      "relationalDatabaseAvailabilityZones": [toAvailabilityZone],
    },
  }, root);
}

function toAvailabilityZone(root: jsonP.JSONValue): s.AvailabilityZone {
  return jsonP.readObj({
    required: {},
    optional: {
      "zoneName": "s",
      "state": "s",
    },
  }, root);
}

function toRelationalDatabase(root: jsonP.JSONValue): s.RelationalDatabase {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "relationalDatabaseBlueprintId": "s",
      "relationalDatabaseBundleId": "s",
      "masterDatabaseName": "s",
      "hardware": toRelationalDatabaseHardware,
      "state": "s",
      "secondaryAvailabilityZone": "s",
      "backupRetentionEnabled": "b",
      "pendingModifiedValues": toPendingModifiedRelationalDatabaseValues,
      "engine": "s",
      "engineVersion": "s",
      "latestRestorableTime": "d",
      "masterUsername": "s",
      "parameterApplyStatus": "s",
      "preferredBackupWindow": "s",
      "preferredMaintenanceWindow": "s",
      "publiclyAccessible": "b",
      "masterEndpoint": toRelationalDatabaseEndpoint,
      "pendingMaintenanceActions": [toPendingMaintenanceAction],
      "caCertificateIdentifier": "s",
    },
  }, root);
}

function toRelationalDatabaseHardware(root: jsonP.JSONValue): s.RelationalDatabaseHardware {
  return jsonP.readObj({
    required: {},
    optional: {
      "cpuCount": "n",
      "diskSizeInGb": "n",
      "ramSizeInGb": "n",
    },
  }, root);
}

function toPendingModifiedRelationalDatabaseValues(root: jsonP.JSONValue): s.PendingModifiedRelationalDatabaseValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "masterUserPassword": "s",
      "engineVersion": "s",
      "backupRetentionEnabled": "b",
    },
  }, root);
}

function toRelationalDatabaseEndpoint(root: jsonP.JSONValue): s.RelationalDatabaseEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "port": "n",
      "address": "s",
    },
  }, root);
}

function toPendingMaintenanceAction(root: jsonP.JSONValue): s.PendingMaintenanceAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "action": "s",
      "description": "s",
      "currentApplyDate": "d",
    },
  }, root);
}

function toRelationalDatabaseBlueprint(root: jsonP.JSONValue): s.RelationalDatabaseBlueprint {
  return jsonP.readObj({
    required: {},
    optional: {
      "blueprintId": "s",
      "engine": (x: jsonP.JSONValue) => cmnP.readEnum<s.RelationalDatabaseEngine>(x),
      "engineVersion": "s",
      "engineDescription": "s",
      "engineVersionDescription": "s",
      "isEngineDefault": "b",
    },
  }, root);
}

function toRelationalDatabaseBundle(root: jsonP.JSONValue): s.RelationalDatabaseBundle {
  return jsonP.readObj({
    required: {},
    optional: {
      "bundleId": "s",
      "name": "s",
      "price": "n",
      "ramSizeInGb": "n",
      "diskSizeInGb": "n",
      "transferPerMonthInGb": "n",
      "cpuCount": "n",
      "isEncrypted": "b",
      "isActive": "b",
    },
  }, root);
}

function toRelationalDatabaseEvent(root: jsonP.JSONValue): s.RelationalDatabaseEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "resource": "s",
      "createdAt": "d",
      "message": "s",
      "eventCategories": ["s"],
    },
  }, root);
}

function toLogEvent(root: jsonP.JSONValue): s.LogEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "createdAt": "d",
      "message": "s",
    },
  }, root);
}

function toRelationalDatabaseSnapshot(root: jsonP.JSONValue): s.RelationalDatabaseSnapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "tags": [toTag],
      "engine": "s",
      "engineVersion": "s",
      "sizeInGb": "n",
      "state": "s",
      "fromRelationalDatabaseName": "s",
      "fromRelationalDatabaseArn": "s",
      "fromRelationalDatabaseBundleId": "s",
      "fromRelationalDatabaseBlueprintId": "s",
    },
  }, root);
}

function toStaticIp(root: jsonP.JSONValue): s.StaticIp {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "supportCode": "s",
      "createdAt": "d",
      "location": toResourceLocation,
      "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "ipAddress": "s",
      "attachedTo": "s",
      "isAttached": "b",
    },
  }, root);
}
