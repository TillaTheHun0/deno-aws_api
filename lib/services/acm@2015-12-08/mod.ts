// Autogenerated API client for: AWS Certificate Manager

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class ACM {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ACM.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-12-08",
    "endpointPrefix": "acm",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "ACM",
    "serviceFullName": "AWS Certificate Manager",
    "serviceId": "ACM",
    "signatureVersion": "v4",
    "targetPrefix": "CertificateManager",
    "uid": "acm-2015-12-08"
  };

  async addTagsToCertificate(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToCertificate",
    });
  }

  async deleteCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeleteCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCertificate",
    });
  }

  async describeCertificate(
    {abortSignal, ...params}: RequestConfig & s.DescribeCertificateRequest,
  ): Promise<s.DescribeCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificateDetail,
      },
    }, await resp.json());
  }

  async exportCertificate(
    {abortSignal, ...params}: RequestConfig & s.ExportCertificateRequest,
  ): Promise<s.ExportCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Passphrase: serializeBlob(params["Passphrase"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExportCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": "s",
        "CertificateChain": "s",
        "PrivateKey": "s",
      },
    }, await resp.json());
  }

  async getCertificate(
    {abortSignal, ...params}: RequestConfig & s.GetCertificateRequest,
  ): Promise<s.GetCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": "s",
        "CertificateChain": "s",
      },
    }, await resp.json());
  }

  async importCertificate(
    {abortSignal, ...params}: RequestConfig & s.ImportCertificateRequest,
  ): Promise<s.ImportCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Certificate: serializeBlob(params["Certificate"]),
      PrivateKey: serializeBlob(params["PrivateKey"]),
      CertificateChain: serializeBlob(params["CertificateChain"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateArn": "s",
      },
    }, await resp.json());
  }

  async listCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListCertificatesRequest = {},
  ): Promise<s.ListCertificatesResponse> {
    const body: jsonP.JSONObject = {
      CertificateStatuses: params["CertificateStatuses"],
      Includes: fromFilters(params["Includes"]),
      NextToken: params["NextToken"],
      MaxItems: params["MaxItems"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "CertificateSummaryList": [toCertificateSummary],
      },
    }, await resp.json());
  }

  async listTagsForCertificate(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForCertificateRequest,
  ): Promise<s.ListTagsForCertificateResponse> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async removeTagsFromCertificate(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromCertificate",
    });
  }

  async renewCertificate(
    {abortSignal, ...params}: RequestConfig & s.RenewCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RenewCertificate",
    });
  }

  async requestCertificate(
    {abortSignal, ...params}: RequestConfig & s.RequestCertificateRequest,
  ): Promise<s.RequestCertificateResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      ValidationMethod: params["ValidationMethod"],
      SubjectAlternativeNames: params["SubjectAlternativeNames"],
      IdempotencyToken: params["IdempotencyToken"],
      DomainValidationOptions: params["DomainValidationOptions"]?.map(x => fromDomainValidationOption(x)),
      Options: fromCertificateOptions(params["Options"]),
      CertificateAuthorityArn: params["CertificateAuthorityArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateArn": "s",
      },
    }, await resp.json());
  }

  async resendValidationEmail(
    {abortSignal, ...params}: RequestConfig & s.ResendValidationEmailRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Domain: params["Domain"],
      ValidationDomain: params["ValidationDomain"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResendValidationEmail",
    });
  }

  async updateCertificateOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateCertificateOptionsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CertificateArn: params["CertificateArn"],
      Options: fromCertificateOptions(params["Options"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCertificateOptions",
    });
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 60 seconds apart (about 40 minutes max wait time). */
  async waitForCertificateValidated(
    params: RequestConfig & s.DescribeCertificateRequest,
  ): Promise<s.DescribeCertificateResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state CertificateValidated';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeCertificate(params);
        if (resp?.Certificate?.DomainValidationOptions?.flatMap(x => x?.ValidationStatus)?.every(x => x === "SUCCESS")) return resp;
        if (resp?.Certificate?.DomainValidationOptions?.flatMap(x => x?.ValidationStatus)?.some(x => x === "PENDING_VALIDATION")) continue;
        if (resp?.Certificate?.Status === "FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromFilters(input?: s.Filters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    extendedKeyUsage: input["extendedKeyUsage"],
    keyUsage: input["keyUsage"],
    keyTypes: input["keyTypes"],
  }
}

function fromDomainValidationOption(input?: s.DomainValidationOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DomainName: input["DomainName"],
    ValidationDomain: input["ValidationDomain"],
  }
}

function fromCertificateOptions(input?: s.CertificateOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateTransparencyLoggingPreference: input["CertificateTransparencyLoggingPreference"],
  }
}
function toCertificateOptions(root: jsonP.JSONValue): s.CertificateOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateTransparencyLoggingPreference": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateTransparencyLoggingPreference>(x),
    },
  }, root);
}

function toCertificateDetail(root: jsonP.JSONValue): s.CertificateDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "DomainName": "s",
      "SubjectAlternativeNames": ["s"],
      "DomainValidationOptions": [toDomainValidation],
      "Serial": "s",
      "Subject": "s",
      "Issuer": "s",
      "CreatedAt": "d",
      "IssuedAt": "d",
      "ImportedAt": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateStatus>(x),
      "RevokedAt": "d",
      "RevocationReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.RevocationReason>(x),
      "NotBefore": "d",
      "NotAfter": "d",
      "KeyAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyAlgorithm>(x),
      "SignatureAlgorithm": "s",
      "InUseBy": ["s"],
      "FailureReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureReason>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateType>(x),
      "RenewalSummary": toRenewalSummary,
      "KeyUsages": [toKeyUsage],
      "ExtendedKeyUsages": [toExtendedKeyUsage],
      "CertificateAuthorityArn": "s",
      "RenewalEligibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.RenewalEligibility>(x),
      "Options": toCertificateOptions,
    },
  }, root);
}

function toDomainValidation(root: jsonP.JSONValue): s.DomainValidation {
  return jsonP.readObj({
    required: {
      "DomainName": "s",
    },
    optional: {
      "ValidationEmails": ["s"],
      "ValidationDomain": "s",
      "ValidationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatus>(x),
      "ResourceRecord": toResourceRecord,
      "ValidationMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.ValidationMethod>(x),
    },
  }, root);
}

function toResourceRecord(root: jsonP.JSONValue): s.ResourceRecord {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordType>(x),
      "Value": "s",
    },
    optional: {},
  }, root);
}

function toRenewalSummary(root: jsonP.JSONValue): s.RenewalSummary {
  return jsonP.readObj({
    required: {
      "RenewalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RenewalStatus>(x),
      "DomainValidationOptions": [toDomainValidation],
      "UpdatedAt": "d",
    },
    optional: {
      "RenewalStatusReason": (x: jsonP.JSONValue) => cmnP.readEnum<s.FailureReason>(x),
    },
  }, root);
}

function toKeyUsage(root: jsonP.JSONValue): s.KeyUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyUsageName>(x),
    },
  }, root);
}

function toExtendedKeyUsage(root: jsonP.JSONValue): s.ExtendedKeyUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExtendedKeyUsageName>(x),
      "OID": "s",
    },
  }, root);
}

function toCertificateSummary(root: jsonP.JSONValue): s.CertificateSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateArn": "s",
      "DomainName": "s",
    },
  }, root);
}
