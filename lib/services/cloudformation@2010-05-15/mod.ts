// Autogenerated API client for: AWS CloudFormation

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class CloudFormation {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFormation.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2010-05-15",
    "endpointPrefix": "cloudformation",
    "protocol": "query",
    "serviceFullName": "AWS CloudFormation",
    "serviceId": "CloudFormation",
    "signatureVersion": "v4",
    "uid": "cloudformation-2010-05-15",
    "xmlNamespace": "http://cloudformation.amazonaws.com/doc/2010-05-15/"
  };

  async cancelUpdateStack(
    {abortSignal, ...params}: RequestConfig & s.CancelUpdateStackInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelUpdateStack",
    });
  }

  async continueUpdateRollback(
    {abortSignal, ...params}: RequestConfig & s.ContinueUpdateRollbackInput,
  ): Promise<s.ContinueUpdateRollbackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["ResourcesToSkip"]) qsP.appendList(body, prefix+"ResourcesToSkip", params["ResourcesToSkip"], {"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ContinueUpdateRollback",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ContinueUpdateRollbackResult");
    return {};
  }

  async createChangeSet(
    {abortSignal, ...params}: RequestConfig & s.CreateChangeSetInput,
  ): Promise<s.CreateChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("ChangeSetType" in params) body.append(prefix+"ChangeSetType", (params["ChangeSetType"] ?? '').toString());
    if (params["ResourcesToImport"]) qsP.appendList(body, prefix+"ResourcesToImport", params["ResourcesToImport"], {"appender":ResourceToImport_Serialize,"entryPrefix":".member."})
    if ("IncludeNestedStacks" in params) body.append(prefix+"IncludeNestedStacks", (params["IncludeNestedStacks"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateChangeSetResult");
    return xml.strings({
      optional: {"Id":true,"StackId":true},
    });
  }

  async createStack(
    {abortSignal, ...params}: RequestConfig & s.CreateStackInput,
  ): Promise<s.CreateStackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if ("DisableRollback" in params) body.append(prefix+"DisableRollback", (params["DisableRollback"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if ("TimeoutInMinutes" in params) body.append(prefix+"TimeoutInMinutes", (params["TimeoutInMinutes"] ?? '').toString());
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("OnFailure" in params) body.append(prefix+"OnFailure", (params["OnFailure"] ?? '').toString());
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    if ("EnableTerminationProtection" in params) body.append(prefix+"EnableTerminationProtection", (params["EnableTerminationProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStack",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async createStackInstances(
    {abortSignal, ...params}: RequestConfig & s.CreateStackInstancesInput,
  ): Promise<s.CreateStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["ParameterOverrides"]) qsP.appendList(body, prefix+"ParameterOverrides", params["ParameterOverrides"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async createStackSet(
    {abortSignal, ...params}: RequestConfig & s.CreateStackSetInput,
  ): Promise<s.CreateStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("AdministrationRoleARN" in params) body.append(prefix+"AdministrationRoleARN", (params["AdministrationRoleARN"] ?? '').toString());
    if ("ExecutionRoleName" in params) body.append(prefix+"ExecutionRoleName", (params["ExecutionRoleName"] ?? '').toString());
    if ("PermissionModel" in params) body.append(prefix+"PermissionModel", (params["PermissionModel"] ?? '').toString());
    if (params["AutoDeployment"] != null) AutoDeployment_Serialize(body, prefix+"AutoDeployment", params["AutoDeployment"]);
    body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackSetResult");
    return xml.strings({
      optional: {"StackSetId":true},
    });
  }

  async deleteChangeSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteChangeSetInput,
  ): Promise<s.DeleteChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteChangeSetResult");
    return {};
  }

  async deleteStack(
    {abortSignal, ...params}: RequestConfig & s.DeleteStackInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["RetainResources"]) qsP.appendList(body, prefix+"RetainResources", params["RetainResources"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStack",
    });
  }

  async deleteStackInstances(
    {abortSignal, ...params}: RequestConfig & s.DeleteStackInstancesInput,
  ): Promise<s.DeleteStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"RetainStacks", (params["RetainStacks"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async deleteStackSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteStackSetInput,
  ): Promise<s.DeleteStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteStackSetResult");
    return {};
  }

  async deregisterType(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTypeInput = {},
  ): Promise<s.DeregisterTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeregisterTypeResult");
    return {};
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountLimitsInput = {},
  ): Promise<s.DescribeAccountLimitsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AccountLimits: xml.getList("AccountLimits", "member").map(AccountLimit_Parse),
    };
  }

  async describeChangeSet(
    {abortSignal, ...params}: RequestConfig & s.DescribeChangeSetInput,
  ): Promise<s.DescribeChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeChangeSetResult");
    return {
      ...xml.strings({
        optional: {"ChangeSetName":true,"ChangeSetId":true,"StackId":true,"StackName":true,"Description":true,"StatusReason":true,"NextToken":true,"ParentChangeSetId":true,"RootChangeSetId":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(Parameter_Parse),
      CreationTime: xml.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
      ExecutionStatus: xml.first("ExecutionStatus", false, x => (x.content ?? '') as s.ExecutionStatus),
      Status: xml.first("Status", false, x => (x.content ?? '') as s.ChangeSetStatus),
      NotificationARNs: xml.getList("NotificationARNs", "member").map(x => x.content ?? ''),
      RollbackConfiguration: xml.first("RollbackConfiguration", false, RollbackConfiguration_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as s.Capability),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      Changes: xml.getList("Changes", "member").map(Change_Parse),
      IncludeNestedStacks: xml.first("IncludeNestedStacks", false, x => x.content === 'true'),
    };
  }

  async describeStackDriftDetectionStatus(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackDriftDetectionStatusInput,
  ): Promise<s.DescribeStackDriftDetectionStatusOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackDriftDetectionId", (params["StackDriftDetectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackDriftDetectionStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackDriftDetectionStatusResult");
    return {
      ...xml.strings({
        required: {"StackId":true,"StackDriftDetectionId":true},
        optional: {"DetectionStatusReason":true},
      }),
      StackDriftStatus: xml.first("StackDriftStatus", false, x => (x.content ?? '') as s.StackDriftStatus),
      DetectionStatus: xml.first("DetectionStatus", true, x => (x.content ?? '') as s.StackDriftDetectionStatus),
      DriftedStackResourceCount: xml.first("DriftedStackResourceCount", false, x => parseInt(x.content ?? '0')),
      Timestamp: xml.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeStackEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackEventsInput = {},
  ): Promise<s.DescribeStackEventsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackEventsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackEvents: xml.getList("StackEvents", "member").map(StackEvent_Parse),
    };
  }

  async describeStackInstance(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackInstanceInput,
  ): Promise<s.DescribeStackInstanceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"StackInstanceAccount", (params["StackInstanceAccount"] ?? '').toString());
    body.append(prefix+"StackInstanceRegion", (params["StackInstanceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackInstanceResult");
    return {
      StackInstance: xml.first("StackInstance", false, StackInstance_Parse),
    };
  }

  async describeStackResource(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackResourceInput,
  ): Promise<s.DescribeStackResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourceResult");
    return {
      StackResourceDetail: xml.first("StackResourceDetail", false, StackResourceDetail_Parse),
    };
  }

  async describeStackResourceDrifts(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackResourceDriftsInput,
  ): Promise<s.DescribeStackResourceDriftsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["StackResourceDriftStatusFilters"]) qsP.appendList(body, prefix+"StackResourceDriftStatusFilters", params["StackResourceDriftStatusFilters"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResourceDrifts",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourceDriftsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackResourceDrifts: xml.getList("StackResourceDrifts", "member").map(StackResourceDrift_Parse),
    };
  }

  async describeStackResources(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackResourcesInput = {},
  ): Promise<s.DescribeStackResourcesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("LogicalResourceId" in params) body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    if ("PhysicalResourceId" in params) body.append(prefix+"PhysicalResourceId", (params["PhysicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResources",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourcesResult");
    return {
      StackResources: xml.getList("StackResources", "member").map(StackResource_Parse),
    };
  }

  async describeStackSet(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackSetInput,
  ): Promise<s.DescribeStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackSetResult");
    return {
      StackSet: xml.first("StackSet", false, StackSet_Parse),
    };
  }

  async describeStackSetOperation(
    {abortSignal, ...params}: RequestConfig & s.DescribeStackSetOperationInput,
  ): Promise<s.DescribeStackSetOperationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSetOperation",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackSetOperationResult");
    return {
      StackSetOperation: xml.first("StackSetOperation", false, StackSetOperation_Parse),
    };
  }

  async describeStacks(
    {abortSignal, ...params}: RequestConfig & s.DescribeStacksInput = {},
  ): Promise<s.DescribeStacksOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStacks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStacksResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Stacks: xml.getList("Stacks", "member").map(Stack_Parse),
    };
  }

  async describeType(
    {abortSignal, ...params}: RequestConfig & s.DescribeTypeInput = {},
  ): Promise<s.DescribeTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTypeResult");
    return {
      ...xml.strings({
        optional: {"Arn":true,"TypeName":true,"DefaultVersionId":true,"Description":true,"Schema":true,"ExecutionRoleArn":true,"SourceUrl":true,"DocumentationUrl":true},
      }),
      Type: xml.first("Type", false, x => (x.content ?? '') as s.RegistryType),
      IsDefaultVersion: xml.first("IsDefaultVersion", false, x => x.content === 'true'),
      ProvisioningType: xml.first("ProvisioningType", false, x => (x.content ?? '') as s.ProvisioningType),
      DeprecatedStatus: xml.first("DeprecatedStatus", false, x => (x.content ?? '') as s.DeprecatedStatus),
      LoggingConfig: xml.first("LoggingConfig", false, LoggingConfig_Parse),
      Visibility: xml.first("Visibility", false, x => (x.content ?? '') as s.Visibility),
      LastUpdated: xml.first("LastUpdated", false, x => xmlP.parseTimestamp(x.content)),
      TimeCreated: xml.first("TimeCreated", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeTypeRegistration(
    {abortSignal, ...params}: RequestConfig & s.DescribeTypeRegistrationInput,
  ): Promise<s.DescribeTypeRegistrationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RegistrationToken", (params["RegistrationToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTypeRegistration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTypeRegistrationResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"TypeArn":true,"TypeVersionArn":true},
      }),
      ProgressStatus: xml.first("ProgressStatus", false, x => (x.content ?? '') as s.RegistrationStatus),
    };
  }

  async detectStackDrift(
    {abortSignal, ...params}: RequestConfig & s.DetectStackDriftInput,
  ): Promise<s.DetectStackDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["LogicalResourceIds"]) qsP.appendList(body, prefix+"LogicalResourceIds", params["LogicalResourceIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackDriftResult");
    return xml.strings({
      required: {"StackDriftDetectionId":true},
    });
  }

  async detectStackResourceDrift(
    {abortSignal, ...params}: RequestConfig & s.DetectStackResourceDriftInput,
  ): Promise<s.DetectStackResourceDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackResourceDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackResourceDriftResult");
    return {
      StackResourceDrift: xml.first("StackResourceDrift", true, StackResourceDrift_Parse),
    };
  }

  async detectStackSetDrift(
    {abortSignal, ...params}: RequestConfig & s.DetectStackSetDriftInput,
  ): Promise<s.DetectStackSetDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackSetDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackSetDriftResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async estimateTemplateCost(
    {abortSignal, ...params}: RequestConfig & s.EstimateTemplateCostInput = {},
  ): Promise<s.EstimateTemplateCostOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EstimateTemplateCost",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EstimateTemplateCostResult");
    return xml.strings({
      optional: {"Url":true},
    });
  }

  async executeChangeSet(
    {abortSignal, ...params}: RequestConfig & s.ExecuteChangeSetInput,
  ): Promise<s.ExecuteChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ExecuteChangeSetResult");
    return {};
  }

  async getStackPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetStackPolicyInput,
  ): Promise<s.GetStackPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStackPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetStackPolicyResult");
    return xml.strings({
      optional: {"StackPolicyBody":true},
    });
  }

  async getTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetTemplateInput = {},
  ): Promise<s.GetTemplateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ChangeSetName" in params) body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("TemplateStage" in params) body.append(prefix+"TemplateStage", (params["TemplateStage"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetTemplateResult");
    return {
      ...xml.strings({
        optional: {"TemplateBody":true},
      }),
      StagesAvailable: xml.getList("StagesAvailable", "member").map(x => (x.content ?? '') as s.TemplateStage),
    };
  }

  async getTemplateSummary(
    {abortSignal, ...params}: RequestConfig & s.GetTemplateSummaryInput = {},
  ): Promise<s.GetTemplateSummaryOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("StackSetName" in params) body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplateSummary",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetTemplateSummaryResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"CapabilitiesReason":true,"Version":true,"Metadata":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(ParameterDeclaration_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as s.Capability),
      ResourceTypes: xml.getList("ResourceTypes", "member").map(x => x.content ?? ''),
      DeclaredTransforms: xml.getList("DeclaredTransforms", "member").map(x => x.content ?? ''),
      ResourceIdentifierSummaries: xml.getList("ResourceIdentifierSummaries", "member").map(ResourceIdentifierSummary_Parse),
    };
  }

  async listChangeSets(
    {abortSignal, ...params}: RequestConfig & s.ListChangeSetsInput,
  ): Promise<s.ListChangeSetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListChangeSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListChangeSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(ChangeSetSummary_Parse),
    };
  }

  async listExports(
    {abortSignal, ...params}: RequestConfig & s.ListExportsInput = {},
  ): Promise<s.ListExportsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListExports",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListExportsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Exports: xml.getList("Exports", "member").map(Export_Parse),
    };
  }

  async listImports(
    {abortSignal, ...params}: RequestConfig & s.ListImportsInput,
  ): Promise<s.ListImportsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportName", (params["ExportName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImports",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListImportsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Imports: xml.getList("Imports", "member").map(x => x.content ?? ''),
    };
  }

  async listStackInstances(
    {abortSignal, ...params}: RequestConfig & s.ListStackInstancesInput,
  ): Promise<s.ListStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":StackInstanceFilter_Serialize,"entryPrefix":".member."})
    if ("StackInstanceAccount" in params) body.append(prefix+"StackInstanceAccount", (params["StackInstanceAccount"] ?? '').toString());
    if ("StackInstanceRegion" in params) body.append(prefix+"StackInstanceRegion", (params["StackInstanceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackInstancesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackInstanceSummary_Parse),
    };
  }

  async listStackResources(
    {abortSignal, ...params}: RequestConfig & s.ListStackResourcesInput,
  ): Promise<s.ListStackResourcesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackResources",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackResourcesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackResourceSummaries: xml.getList("StackResourceSummaries", "member").map(StackResourceSummary_Parse),
    };
  }

  async listStackSetOperationResults(
    {abortSignal, ...params}: RequestConfig & s.ListStackSetOperationResultsInput,
  ): Promise<s.ListStackSetOperationResultsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSetOperationResults",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetOperationResultsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetOperationResultSummary_Parse),
    };
  }

  async listStackSetOperations(
    {abortSignal, ...params}: RequestConfig & s.ListStackSetOperationsInput,
  ): Promise<s.ListStackSetOperationsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSetOperations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetOperationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetOperationSummary_Parse),
    };
  }

  async listStackSets(
    {abortSignal, ...params}: RequestConfig & s.ListStackSetsInput = {},
  ): Promise<s.ListStackSetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("Status" in params) body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetSummary_Parse),
    };
  }

  async listStacks(
    {abortSignal, ...params}: RequestConfig & s.ListStacksInput = {},
  ): Promise<s.ListStacksOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["StackStatusFilter"]) qsP.appendList(body, prefix+"StackStatusFilter", params["StackStatusFilter"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStacks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStacksResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackSummaries: xml.getList("StackSummaries", "member").map(StackSummary_Parse),
    };
  }

  async listTypeRegistrations(
    {abortSignal, ...params}: RequestConfig & s.ListTypeRegistrationsInput = {},
  ): Promise<s.ListTypeRegistrationsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("TypeArn" in params) body.append(prefix+"TypeArn", (params["TypeArn"] ?? '').toString());
    if ("RegistrationStatusFilter" in params) body.append(prefix+"RegistrationStatusFilter", (params["RegistrationStatusFilter"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypeRegistrations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypeRegistrationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RegistrationTokenList: xml.getList("RegistrationTokenList", "member").map(x => x.content ?? ''),
    };
  }

  async listTypeVersions(
    {abortSignal, ...params}: RequestConfig & s.ListTypeVersionsInput = {},
  ): Promise<s.ListTypeVersionsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DeprecatedStatus" in params) body.append(prefix+"DeprecatedStatus", (params["DeprecatedStatus"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypeVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypeVersionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TypeVersionSummaries: xml.getList("TypeVersionSummaries", "member").map(TypeVersionSummary_Parse),
    };
  }

  async listTypes(
    {abortSignal, ...params}: RequestConfig & s.ListTypesInput = {},
  ): Promise<s.ListTypesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Visibility" in params) body.append(prefix+"Visibility", (params["Visibility"] ?? '').toString());
    if ("ProvisioningType" in params) body.append(prefix+"ProvisioningType", (params["ProvisioningType"] ?? '').toString());
    if ("DeprecatedStatus" in params) body.append(prefix+"DeprecatedStatus", (params["DeprecatedStatus"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TypeSummaries: xml.getList("TypeSummaries", "member").map(TypeSummary_Parse),
    };
  }

  async recordHandlerProgress(
    {abortSignal, ...params}: RequestConfig & s.RecordHandlerProgressInput,
  ): Promise<s.RecordHandlerProgressOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BearerToken", (params["BearerToken"] ?? '').toString());
    body.append(prefix+"OperationStatus", (params["OperationStatus"] ?? '').toString());
    if ("CurrentOperationStatus" in params) body.append(prefix+"CurrentOperationStatus", (params["CurrentOperationStatus"] ?? '').toString());
    if ("StatusMessage" in params) body.append(prefix+"StatusMessage", (params["StatusMessage"] ?? '').toString());
    if ("ErrorCode" in params) body.append(prefix+"ErrorCode", (params["ErrorCode"] ?? '').toString());
    if ("ResourceModel" in params) body.append(prefix+"ResourceModel", (params["ResourceModel"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecordHandlerProgress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RecordHandlerProgressResult");
    return {};
  }

  async registerType(
    {abortSignal, ...params}: RequestConfig & s.RegisterTypeInput,
  ): Promise<s.RegisterTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    body.append(prefix+"SchemaHandlerPackage", (params["SchemaHandlerPackage"] ?? '').toString());
    if (params["LoggingConfig"] != null) LoggingConfig_Serialize(body, prefix+"LoggingConfig", params["LoggingConfig"]);
    if ("ExecutionRoleArn" in params) body.append(prefix+"ExecutionRoleArn", (params["ExecutionRoleArn"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RegisterTypeResult");
    return xml.strings({
      optional: {"RegistrationToken":true},
    });
  }

  async setStackPolicy(
    {abortSignal, ...params}: RequestConfig & s.SetStackPolicyInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetStackPolicy",
    });
  }

  async setTypeDefaultVersion(
    {abortSignal, ...params}: RequestConfig & s.SetTypeDefaultVersionInput = {},
  ): Promise<s.SetTypeDefaultVersionOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTypeDefaultVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetTypeDefaultVersionResult");
    return {};
  }

  async signalResource(
    {abortSignal, ...params}: RequestConfig & s.SignalResourceInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    body.append(prefix+"UniqueId", (params["UniqueId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SignalResource",
    });
  }

  async stopStackSetOperation(
    {abortSignal, ...params}: RequestConfig & s.StopStackSetOperationInput,
  ): Promise<s.StopStackSetOperationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStackSetOperation",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StopStackSetOperationResult");
    return {};
  }

  async updateStack(
    {abortSignal, ...params}: RequestConfig & s.UpdateStackInput,
  ): Promise<s.UpdateStackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if ("StackPolicyDuringUpdateBody" in params) body.append(prefix+"StackPolicyDuringUpdateBody", (params["StackPolicyDuringUpdateBody"] ?? '').toString());
    if ("StackPolicyDuringUpdateURL" in params) body.append(prefix+"StackPolicyDuringUpdateURL", (params["StackPolicyDuringUpdateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStack",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async updateStackInstances(
    {abortSignal, ...params}: RequestConfig & s.UpdateStackInstancesInput,
  ): Promise<s.UpdateStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["ParameterOverrides"]) qsP.appendList(body, prefix+"ParameterOverrides", params["ParameterOverrides"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async updateStackSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateStackSetInput,
  ): Promise<s.UpdateStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    if ("AdministrationRoleARN" in params) body.append(prefix+"AdministrationRoleARN", (params["AdministrationRoleARN"] ?? '').toString());
    if ("ExecutionRoleName" in params) body.append(prefix+"ExecutionRoleName", (params["ExecutionRoleName"] ?? '').toString());
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if ("PermissionModel" in params) body.append(prefix+"PermissionModel", (params["PermissionModel"] ?? '').toString());
    if (params["AutoDeployment"] != null) AutoDeployment_Serialize(body, prefix+"AutoDeployment", params["AutoDeployment"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackSetResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async updateTerminationProtection(
    {abortSignal, ...params}: RequestConfig & s.UpdateTerminationProtectionInput,
  ): Promise<s.UpdateTerminationProtectionOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EnableTerminationProtection", (params["EnableTerminationProtection"] ?? '').toString());
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTerminationProtection",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateTerminationProtectionResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async validateTemplate(
    {abortSignal, ...params}: RequestConfig & s.ValidateTemplateInput = {},
  ): Promise<s.ValidateTemplateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ValidateTemplateResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"CapabilitiesReason":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(TemplateParameter_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as s.Capability),
      DeclaredTransforms: xml.getList("DeclaredTransforms", "member").map(x => x.content ?? ''),
    };
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForStackExists(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeStacks(params);
        return resp; // for status 200
      } catch (err) {
        if (!["ValidationError"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is CREATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackCreateComplete(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackCreateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "CREATE_COMPLETE")) return resp;
        if (field?.some(x => x === "CREATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_COMPLETE")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is DELETE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackDeleteComplete(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<Error | s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackDeleteComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "DELETE_COMPLETE")) return resp;
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "CREATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_IN_PROGRESS")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is UPDATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackUpdateComplete(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackUpdateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "UPDATE_COMPLETE")) return resp;
        // BROKEN: if (field?.some(x => x === "UPDATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is IMPORT_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackImportComplete(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackImportComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "IMPORT_COMPLETE")) return resp;
        if (field?.some(x => x === "ROLLBACK_COMPLETE")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_IN_PROGRESS")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is UPDATE_ROLLBACK_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackRollbackComplete(
    params: RequestConfig & s.DescribeStacksInput,
  ): Promise<s.DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackRollbackComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "UPDATE_ROLLBACK_COMPLETE")) return resp;
        // BROKEN: if (field?.some(x => x === "UPDATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until change set status is CREATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForChangeSetCreateComplete(
    params: RequestConfig & s.DescribeChangeSetInput,
  ): Promise<s.DescribeChangeSetOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChangeSetCreateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeChangeSet(params);
        const field = resp?.Status;
        if (field === "CREATE_COMPLETE") return resp;
        if (field === "FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until type registration is COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForTypeRegistrationComplete(
    params: RequestConfig & s.DescribeTypeRegistrationInput,
  ): Promise<s.DescribeTypeRegistrationOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TypeRegistrationComplete';
    for (let i = 0; i < 120; i++) {
      const resp = await this.describeTypeRegistration(params);
      const field = resp?.ProgressStatus;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function Parameter_Serialize(body: URLSearchParams, prefix: string, params: s.Parameter) {
    if ("ParameterKey" in params) body.append(prefix+".ParameterKey", (params["ParameterKey"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("UsePreviousValue" in params) body.append(prefix+".UsePreviousValue", (params["UsePreviousValue"] ?? '').toString());
    if ("ResolvedValue" in params) body.append(prefix+".ResolvedValue", (params["ResolvedValue"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): s.Parameter {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"ParameterValue":true,"ResolvedValue":true},
    }),
    UsePreviousValue: node.first("UsePreviousValue", false, x => x.content === 'true'),
  };
}

function RollbackConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.RollbackConfiguration) {
    if (params["RollbackTriggers"]) qsP.appendList(body, prefix+".RollbackTriggers", params["RollbackTriggers"], {"appender":RollbackTrigger_Serialize,"entryPrefix":".member."})
    if ("MonitoringTimeInMinutes" in params) body.append(prefix+".MonitoringTimeInMinutes", (params["MonitoringTimeInMinutes"] ?? '').toString());
}
function RollbackConfiguration_Parse(node: xmlP.XmlNode): s.RollbackConfiguration {
  return {
    RollbackTriggers: node.getList("RollbackTriggers", "member").map(RollbackTrigger_Parse),
    MonitoringTimeInMinutes: node.first("MonitoringTimeInMinutes", false, x => parseInt(x.content ?? '0')),
  };
}

function RollbackTrigger_Serialize(body: URLSearchParams, prefix: string, params: s.RollbackTrigger) {
    body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
}
function RollbackTrigger_Parse(node: xmlP.XmlNode): s.RollbackTrigger {
  return node.strings({
    required: {"Arn":true,"Type":true},
  });
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function ResourceToImport_Serialize(body: URLSearchParams, prefix: string, params: s.ResourceToImport) {
    body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+".LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    if (params["ResourceIdentifier"]) qsP.appendMap(body, prefix+".ResourceIdentifier", params["ResourceIdentifier"], {"entryPrefix":".entry."})
}

function DeploymentTargets_Serialize(body: URLSearchParams, prefix: string, params: s.DeploymentTargets) {
    if (params["Accounts"]) qsP.appendList(body, prefix+".Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["OrganizationalUnitIds"]) qsP.appendList(body, prefix+".OrganizationalUnitIds", params["OrganizationalUnitIds"], {"entryPrefix":".member."})
}
function DeploymentTargets_Parse(node: xmlP.XmlNode): s.DeploymentTargets {
  return {
    Accounts: node.getList("Accounts", "member").map(x => x.content ?? ''),
    OrganizationalUnitIds: node.getList("OrganizationalUnitIds", "member").map(x => x.content ?? ''),
  };
}

function StackSetOperationPreferences_Serialize(body: URLSearchParams, prefix: string, params: s.StackSetOperationPreferences) {
    if (params["RegionOrder"]) qsP.appendList(body, prefix+".RegionOrder", params["RegionOrder"], {"entryPrefix":".member."})
    if ("FailureToleranceCount" in params) body.append(prefix+".FailureToleranceCount", (params["FailureToleranceCount"] ?? '').toString());
    if ("FailureTolerancePercentage" in params) body.append(prefix+".FailureTolerancePercentage", (params["FailureTolerancePercentage"] ?? '').toString());
    if ("MaxConcurrentCount" in params) body.append(prefix+".MaxConcurrentCount", (params["MaxConcurrentCount"] ?? '').toString());
    if ("MaxConcurrentPercentage" in params) body.append(prefix+".MaxConcurrentPercentage", (params["MaxConcurrentPercentage"] ?? '').toString());
}
function StackSetOperationPreferences_Parse(node: xmlP.XmlNode): s.StackSetOperationPreferences {
  return {
    RegionOrder: node.getList("RegionOrder", "member").map(x => x.content ?? ''),
    FailureToleranceCount: node.first("FailureToleranceCount", false, x => parseInt(x.content ?? '0')),
    FailureTolerancePercentage: node.first("FailureTolerancePercentage", false, x => parseInt(x.content ?? '0')),
    MaxConcurrentCount: node.first("MaxConcurrentCount", false, x => parseInt(x.content ?? '0')),
    MaxConcurrentPercentage: node.first("MaxConcurrentPercentage", false, x => parseInt(x.content ?? '0')),
  };
}

function AutoDeployment_Serialize(body: URLSearchParams, prefix: string, params: s.AutoDeployment) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("RetainStacksOnAccountRemoval" in params) body.append(prefix+".RetainStacksOnAccountRemoval", (params["RetainStacksOnAccountRemoval"] ?? '').toString());
}
function AutoDeployment_Parse(node: xmlP.XmlNode): s.AutoDeployment {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    RetainStacksOnAccountRemoval: node.first("RetainStacksOnAccountRemoval", false, x => x.content === 'true'),
  };
}

function StackInstanceFilter_Serialize(body: URLSearchParams, prefix: string, params: s.StackInstanceFilter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Values" in params) body.append(prefix+".Values", (params["Values"] ?? '').toString());
}

function LoggingConfig_Serialize(body: URLSearchParams, prefix: string, params: s.LoggingConfig) {
    body.append(prefix+".LogRoleArn", (params["LogRoleArn"] ?? '').toString());
    body.append(prefix+".LogGroupName", (params["LogGroupName"] ?? '').toString());
}
function LoggingConfig_Parse(node: xmlP.XmlNode): s.LoggingConfig {
  return node.strings({
    required: {"LogRoleArn":true,"LogGroupName":true},
  });
}

function AccountLimit_Parse(node: xmlP.XmlNode): s.AccountLimit {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Value: node.first("Value", false, x => parseInt(x.content ?? '0')),
  };
}

function Change_Parse(node: xmlP.XmlNode): s.Change {
  return {
    Type: node.first("Type", false, x => (x.content ?? '') as s.ChangeType),
    ResourceChange: node.first("ResourceChange", false, ResourceChange_Parse),
  };
}

function ResourceChange_Parse(node: xmlP.XmlNode): s.ResourceChange {
  return {
    ...node.strings({
      optional: {"LogicalResourceId":true,"PhysicalResourceId":true,"ResourceType":true,"ChangeSetId":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as s.ChangeAction),
    Replacement: node.first("Replacement", false, x => (x.content ?? '') as s.Replacement),
    Scope: node.getList("Scope", "member").map(x => (x.content ?? '') as s.ResourceAttribute),
    Details: node.getList("Details", "member").map(ResourceChangeDetail_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

function ResourceChangeDetail_Parse(node: xmlP.XmlNode): s.ResourceChangeDetail {
  return {
    ...node.strings({
      optional: {"CausingEntity":true},
    }),
    Target: node.first("Target", false, ResourceTargetDefinition_Parse),
    Evaluation: node.first("Evaluation", false, x => (x.content ?? '') as s.EvaluationType),
    ChangeSource: node.first("ChangeSource", false, x => (x.content ?? '') as s.ChangeSource),
  };
}

function ResourceTargetDefinition_Parse(node: xmlP.XmlNode): s.ResourceTargetDefinition {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Attribute: node.first("Attribute", false, x => (x.content ?? '') as s.ResourceAttribute),
    RequiresRecreation: node.first("RequiresRecreation", false, x => (x.content ?? '') as s.RequiresRecreation),
  };
}

function ModuleInfo_Parse(node: xmlP.XmlNode): s.ModuleInfo {
  return node.strings({
    optional: {"TypeHierarchy":true,"LogicalIdHierarchy":true},
  });
}

function StackEvent_Parse(node: xmlP.XmlNode): s.StackEvent {
  return {
    ...node.strings({
      required: {"StackId":true,"EventId":true,"StackName":true},
      optional: {"LogicalResourceId":true,"PhysicalResourceId":true,"ResourceType":true,"ResourceStatusReason":true,"ResourceProperties":true,"ClientRequestToken":true},
    }),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", false, x => (x.content ?? '') as s.ResourceStatus),
  };
}

function StackInstance_Parse(node: xmlP.XmlNode): s.StackInstance {
  return {
    ...node.strings({
      optional: {"StackSetId":true,"Region":true,"Account":true,"StackId":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    ParameterOverrides: node.getList("ParameterOverrides", "member").map(Parameter_Parse),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackInstanceStatus),
    StackInstanceStatus: node.first("StackInstanceStatus", false, StackInstanceComprehensiveStatus_Parse),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as s.StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackInstanceComprehensiveStatus_Parse(node: xmlP.XmlNode): s.StackInstanceComprehensiveStatus {
  return {
    DetailedStatus: node.first("DetailedStatus", false, x => (x.content ?? '') as s.StackInstanceDetailedStatus),
  };
}

function StackResourceDetail_Parse(node: xmlP.XmlNode): s.StackResourceDetail {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"StackName":true,"StackId":true,"PhysicalResourceId":true,"ResourceStatusReason":true,"Description":true,"Metadata":true},
    }),
    LastUpdatedTimestamp: node.first("LastUpdatedTimestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as s.ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformation_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

function StackResourceDriftInformation_Parse(node: xmlP.XmlNode): s.StackResourceDriftInformation {
  return {
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as s.StackResourceDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackResourceDrift_Parse(node: xmlP.XmlNode): s.StackResourceDrift {
  return {
    ...node.strings({
      required: {"StackId":true,"LogicalResourceId":true,"ResourceType":true},
      optional: {"PhysicalResourceId":true,"ExpectedProperties":true,"ActualProperties":true},
    }),
    PhysicalResourceIdContext: node.getList("PhysicalResourceIdContext", "member").map(PhysicalResourceIdContextKeyValuePair_Parse),
    PropertyDifferences: node.getList("PropertyDifferences", "member").map(PropertyDifference_Parse),
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as s.StackResourceDriftStatus),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

function PhysicalResourceIdContextKeyValuePair_Parse(node: xmlP.XmlNode): s.PhysicalResourceIdContextKeyValuePair {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function PropertyDifference_Parse(node: xmlP.XmlNode): s.PropertyDifference {
  return {
    ...node.strings({
      required: {"PropertyPath":true,"ExpectedValue":true,"ActualValue":true},
    }),
    DifferenceType: node.first("DifferenceType", true, x => (x.content ?? '') as s.DifferenceType),
  };
}

function StackResource_Parse(node: xmlP.XmlNode): s.StackResource {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"StackName":true,"StackId":true,"PhysicalResourceId":true,"ResourceStatusReason":true,"Description":true},
    }),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as s.ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformation_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

function StackSet_Parse(node: xmlP.XmlNode): s.StackSet {
  return {
    ...node.strings({
      optional: {"StackSetName":true,"StackSetId":true,"Description":true,"TemplateBody":true,"StackSetARN":true,"AdministrationRoleARN":true,"ExecutionRoleName":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackSetStatus),
    Parameters: node.getList("Parameters", "member").map(Parameter_Parse),
    Capabilities: node.getList("Capabilities", "member").map(x => (x.content ?? '') as s.Capability),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    StackSetDriftDetectionDetails: node.first("StackSetDriftDetectionDetails", false, StackSetDriftDetectionDetails_Parse),
    AutoDeployment: node.first("AutoDeployment", false, AutoDeployment_Parse),
    PermissionModel: node.first("PermissionModel", false, x => (x.content ?? '') as s.PermissionModels),
    OrganizationalUnitIds: node.getList("OrganizationalUnitIds", "member").map(x => x.content ?? ''),
  };
}

function StackSetDriftDetectionDetails_Parse(node: xmlP.XmlNode): s.StackSetDriftDetectionDetails {
  return {
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as s.StackSetDriftStatus),
    DriftDetectionStatus: node.first("DriftDetectionStatus", false, x => (x.content ?? '') as s.StackSetDriftDetectionStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    TotalStackInstancesCount: node.first("TotalStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    DriftedStackInstancesCount: node.first("DriftedStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    InSyncStackInstancesCount: node.first("InSyncStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    InProgressStackInstancesCount: node.first("InProgressStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    FailedStackInstancesCount: node.first("FailedStackInstancesCount", false, x => parseInt(x.content ?? '0')),
  };
}

function StackSetOperation_Parse(node: xmlP.XmlNode): s.StackSetOperation {
  return {
    ...node.strings({
      optional: {"OperationId":true,"StackSetId":true,"AdministrationRoleARN":true,"ExecutionRoleName":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as s.StackSetOperationAction),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackSetOperationStatus),
    OperationPreferences: node.first("OperationPreferences", false, StackSetOperationPreferences_Parse),
    RetainStacks: node.first("RetainStacks", false, x => x.content === 'true'),
    CreationTimestamp: node.first("CreationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    EndTimestamp: node.first("EndTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    DeploymentTargets: node.first("DeploymentTargets", false, DeploymentTargets_Parse),
    StackSetDriftDetectionDetails: node.first("StackSetDriftDetectionDetails", false, StackSetDriftDetectionDetails_Parse),
  };
}

function Stack_Parse(node: xmlP.XmlNode): s.Stack {
  return {
    ...node.strings({
      required: {"StackName":true},
      optional: {"StackId":true,"ChangeSetId":true,"Description":true,"StackStatusReason":true,"RoleARN":true,"ParentId":true,"RootId":true},
    }),
    Parameters: node.getList("Parameters", "member").map(Parameter_Parse),
    CreationTime: node.first("CreationTime", true, x => xmlP.parseTimestamp(x.content)),
    DeletionTime: node.first("DeletionTime", false, x => xmlP.parseTimestamp(x.content)),
    LastUpdatedTime: node.first("LastUpdatedTime", false, x => xmlP.parseTimestamp(x.content)),
    RollbackConfiguration: node.first("RollbackConfiguration", false, RollbackConfiguration_Parse),
    StackStatus: node.first("StackStatus", true, x => (x.content ?? '') as s.StackStatus),
    DisableRollback: node.first("DisableRollback", false, x => x.content === 'true'),
    NotificationARNs: node.getList("NotificationARNs", "member").map(x => x.content ?? ''),
    TimeoutInMinutes: node.first("TimeoutInMinutes", false, x => parseInt(x.content ?? '0')),
    Capabilities: node.getList("Capabilities", "member").map(x => (x.content ?? '') as s.Capability),
    Outputs: node.getList("Outputs", "member").map(Output_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    EnableTerminationProtection: node.first("EnableTerminationProtection", false, x => x.content === 'true'),
    DriftInformation: node.first("DriftInformation", false, StackDriftInformation_Parse),
  };
}

function Output_Parse(node: xmlP.XmlNode): s.Output {
  return node.strings({
    optional: {"OutputKey":true,"OutputValue":true,"Description":true,"ExportName":true},
  });
}

function StackDriftInformation_Parse(node: xmlP.XmlNode): s.StackDriftInformation {
  return {
    StackDriftStatus: node.first("StackDriftStatus", true, x => (x.content ?? '') as s.StackDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ParameterDeclaration_Parse(node: xmlP.XmlNode): s.ParameterDeclaration {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"DefaultValue":true,"ParameterType":true,"Description":true},
    }),
    NoEcho: node.first("NoEcho", false, x => x.content === 'true'),
    ParameterConstraints: node.first("ParameterConstraints", false, ParameterConstraints_Parse),
  };
}

function ParameterConstraints_Parse(node: xmlP.XmlNode): s.ParameterConstraints {
  return {
    AllowedValues: node.getList("AllowedValues", "member").map(x => x.content ?? ''),
  };
}

function ResourceIdentifierSummary_Parse(node: xmlP.XmlNode): s.ResourceIdentifierSummary {
  return {
    ...node.strings({
      optional: {"ResourceType":true},
    }),
    LogicalResourceIds: node.getList("LogicalResourceIds", "member").map(x => x.content ?? ''),
    ResourceIdentifiers: node.getList("ResourceIdentifiers", "member").map(x => x.content ?? ''),
  };
}

function ChangeSetSummary_Parse(node: xmlP.XmlNode): s.ChangeSetSummary {
  return {
    ...node.strings({
      optional: {"StackId":true,"StackName":true,"ChangeSetId":true,"ChangeSetName":true,"StatusReason":true,"Description":true,"ParentChangeSetId":true,"RootChangeSetId":true},
    }),
    ExecutionStatus: node.first("ExecutionStatus", false, x => (x.content ?? '') as s.ExecutionStatus),
    Status: node.first("Status", false, x => (x.content ?? '') as s.ChangeSetStatus),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    IncludeNestedStacks: node.first("IncludeNestedStacks", false, x => x.content === 'true'),
  };
}

function Export_Parse(node: xmlP.XmlNode): s.Export {
  return node.strings({
    optional: {"ExportingStackId":true,"Name":true,"Value":true},
  });
}

function StackInstanceSummary_Parse(node: xmlP.XmlNode): s.StackInstanceSummary {
  return {
    ...node.strings({
      optional: {"StackSetId":true,"Region":true,"Account":true,"StackId":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackInstanceStatus),
    StackInstanceStatus: node.first("StackInstanceStatus", false, StackInstanceComprehensiveStatus_Parse),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as s.StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackResourceSummary_Parse(node: xmlP.XmlNode): s.StackResourceSummary {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"PhysicalResourceId":true,"ResourceStatusReason":true},
    }),
    LastUpdatedTimestamp: node.first("LastUpdatedTimestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as s.ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformationSummary_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

function StackResourceDriftInformationSummary_Parse(node: xmlP.XmlNode): s.StackResourceDriftInformationSummary {
  return {
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as s.StackResourceDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackSetOperationResultSummary_Parse(node: xmlP.XmlNode): s.StackSetOperationResultSummary {
  return {
    ...node.strings({
      optional: {"Account":true,"Region":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackSetOperationResultStatus),
    AccountGateResult: node.first("AccountGateResult", false, AccountGateResult_Parse),
  };
}

function AccountGateResult_Parse(node: xmlP.XmlNode): s.AccountGateResult {
  return {
    ...node.strings({
      optional: {"StatusReason":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.AccountGateStatus),
  };
}

function StackSetOperationSummary_Parse(node: xmlP.XmlNode): s.StackSetOperationSummary {
  return {
    ...node.strings({
      optional: {"OperationId":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as s.StackSetOperationAction),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackSetOperationStatus),
    CreationTimestamp: node.first("CreationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    EndTimestamp: node.first("EndTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackSetSummary_Parse(node: xmlP.XmlNode): s.StackSetSummary {
  return {
    ...node.strings({
      optional: {"StackSetName":true,"StackSetId":true,"Description":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as s.StackSetStatus),
    AutoDeployment: node.first("AutoDeployment", false, AutoDeployment_Parse),
    PermissionModel: node.first("PermissionModel", false, x => (x.content ?? '') as s.PermissionModels),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as s.StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function StackSummary_Parse(node: xmlP.XmlNode): s.StackSummary {
  return {
    ...node.strings({
      required: {"StackName":true},
      optional: {"StackId":true,"TemplateDescription":true,"StackStatusReason":true,"ParentId":true,"RootId":true},
    }),
    CreationTime: node.first("CreationTime", true, x => xmlP.parseTimestamp(x.content)),
    LastUpdatedTime: node.first("LastUpdatedTime", false, x => xmlP.parseTimestamp(x.content)),
    DeletionTime: node.first("DeletionTime", false, x => xmlP.parseTimestamp(x.content)),
    StackStatus: node.first("StackStatus", true, x => (x.content ?? '') as s.StackStatus),
    DriftInformation: node.first("DriftInformation", false, StackDriftInformationSummary_Parse),
  };
}

function StackDriftInformationSummary_Parse(node: xmlP.XmlNode): s.StackDriftInformationSummary {
  return {
    StackDriftStatus: node.first("StackDriftStatus", true, x => (x.content ?? '') as s.StackDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function TypeVersionSummary_Parse(node: xmlP.XmlNode): s.TypeVersionSummary {
  return {
    ...node.strings({
      optional: {"TypeName":true,"VersionId":true,"Arn":true,"Description":true},
    }),
    Type: node.first("Type", false, x => (x.content ?? '') as s.RegistryType),
    IsDefaultVersion: node.first("IsDefaultVersion", false, x => x.content === 'true'),
    TimeCreated: node.first("TimeCreated", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function TypeSummary_Parse(node: xmlP.XmlNode): s.TypeSummary {
  return {
    ...node.strings({
      optional: {"TypeName":true,"DefaultVersionId":true,"TypeArn":true,"Description":true},
    }),
    Type: node.first("Type", false, x => (x.content ?? '') as s.RegistryType),
    LastUpdated: node.first("LastUpdated", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function TemplateParameter_Parse(node: xmlP.XmlNode): s.TemplateParameter {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"DefaultValue":true,"Description":true},
    }),
    NoEcho: node.first("NoEcho", false, x => x.content === 'true'),
  };
}
