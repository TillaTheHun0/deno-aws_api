// Autogenerated API client for: AWS CloudFormation

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class CloudFormation {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFormation.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2010-05-15",
    "endpointPrefix": "cloudformation",
    "protocol": "query",
    "serviceFullName": "AWS CloudFormation",
    "serviceId": "CloudFormation",
    "signatureVersion": "v4",
    "uid": "cloudformation-2010-05-15",
    "xmlNamespace": "http://cloudformation.amazonaws.com/doc/2010-05-15/"
  };

  async cancelUpdateStack(
    {abortSignal, ...params}: RequestConfig & CancelUpdateStackInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelUpdateStack",
    });
  }

  async continueUpdateRollback(
    {abortSignal, ...params}: RequestConfig & ContinueUpdateRollbackInput,
  ): Promise<ContinueUpdateRollbackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["ResourcesToSkip"]) qsP.appendList(body, prefix+"ResourcesToSkip", params["ResourcesToSkip"], {"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ContinueUpdateRollback",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ContinueUpdateRollbackResult");
    return {};
  }

  async createChangeSet(
    {abortSignal, ...params}: RequestConfig & CreateChangeSetInput,
  ): Promise<CreateChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("ClientToken" in params) body.append(prefix+"ClientToken", (params["ClientToken"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("ChangeSetType" in params) body.append(prefix+"ChangeSetType", (params["ChangeSetType"] ?? '').toString());
    if (params["ResourcesToImport"]) qsP.appendList(body, prefix+"ResourcesToImport", params["ResourcesToImport"], {"appender":ResourceToImport_Serialize,"entryPrefix":".member."})
    if ("IncludeNestedStacks" in params) body.append(prefix+"IncludeNestedStacks", (params["IncludeNestedStacks"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateChangeSetResult");
    return xml.strings({
      optional: {"Id":true,"StackId":true},
    });
  }

  async createStack(
    {abortSignal, ...params}: RequestConfig & CreateStackInput,
  ): Promise<CreateStackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if ("DisableRollback" in params) body.append(prefix+"DisableRollback", (params["DisableRollback"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if ("TimeoutInMinutes" in params) body.append(prefix+"TimeoutInMinutes", (params["TimeoutInMinutes"] ?? '').toString());
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("OnFailure" in params) body.append(prefix+"OnFailure", (params["OnFailure"] ?? '').toString());
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    if ("EnableTerminationProtection" in params) body.append(prefix+"EnableTerminationProtection", (params["EnableTerminationProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStack",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async createStackInstances(
    {abortSignal, ...params}: RequestConfig & CreateStackInstancesInput,
  ): Promise<CreateStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["ParameterOverrides"]) qsP.appendList(body, prefix+"ParameterOverrides", params["ParameterOverrides"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async createStackSet(
    {abortSignal, ...params}: RequestConfig & CreateStackSetInput,
  ): Promise<CreateStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("AdministrationRoleARN" in params) body.append(prefix+"AdministrationRoleARN", (params["AdministrationRoleARN"] ?? '').toString());
    if ("ExecutionRoleName" in params) body.append(prefix+"ExecutionRoleName", (params["ExecutionRoleName"] ?? '').toString());
    if ("PermissionModel" in params) body.append(prefix+"PermissionModel", (params["PermissionModel"] ?? '').toString());
    if (params["AutoDeployment"] != null) AutoDeployment_Serialize(body, prefix+"AutoDeployment", params["AutoDeployment"]);
    body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStackSetResult");
    return xml.strings({
      optional: {"StackSetId":true},
    });
  }

  async deleteChangeSet(
    {abortSignal, ...params}: RequestConfig & DeleteChangeSetInput,
  ): Promise<DeleteChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteChangeSetResult");
    return {};
  }

  async deleteStack(
    {abortSignal, ...params}: RequestConfig & DeleteStackInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["RetainResources"]) qsP.appendList(body, prefix+"RetainResources", params["RetainResources"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStack",
    });
  }

  async deleteStackInstances(
    {abortSignal, ...params}: RequestConfig & DeleteStackInstancesInput,
  ): Promise<DeleteStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"RetainStacks", (params["RetainStacks"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async deleteStackSet(
    {abortSignal, ...params}: RequestConfig & DeleteStackSetInput,
  ): Promise<DeleteStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteStackSetResult");
    return {};
  }

  async deregisterType(
    {abortSignal, ...params}: RequestConfig & DeregisterTypeInput = {},
  ): Promise<DeregisterTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeregisterTypeResult");
    return {};
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig & DescribeAccountLimitsInput = {},
  ): Promise<DescribeAccountLimitsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AccountLimits: xml.getList("AccountLimits", "member").map(AccountLimit_Parse),
    };
  }

  async describeChangeSet(
    {abortSignal, ...params}: RequestConfig & DescribeChangeSetInput,
  ): Promise<DescribeChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeChangeSetResult");
    return {
      ...xml.strings({
        optional: {"ChangeSetName":true,"ChangeSetId":true,"StackId":true,"StackName":true,"Description":true,"StatusReason":true,"NextToken":true,"ParentChangeSetId":true,"RootChangeSetId":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(Parameter_Parse),
      CreationTime: xml.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
      ExecutionStatus: xml.first("ExecutionStatus", false, x => (x.content ?? '') as ExecutionStatus),
      Status: xml.first("Status", false, x => (x.content ?? '') as ChangeSetStatus),
      NotificationARNs: xml.getList("NotificationARNs", "member").map(x => x.content ?? ''),
      RollbackConfiguration: xml.first("RollbackConfiguration", false, RollbackConfiguration_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as Capability),
      Tags: xml.getList("Tags", "member").map(Tag_Parse),
      Changes: xml.getList("Changes", "member").map(Change_Parse),
      IncludeNestedStacks: xml.first("IncludeNestedStacks", false, x => x.content === 'true'),
    };
  }

  async describeStackDriftDetectionStatus(
    {abortSignal, ...params}: RequestConfig & DescribeStackDriftDetectionStatusInput,
  ): Promise<DescribeStackDriftDetectionStatusOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackDriftDetectionId", (params["StackDriftDetectionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackDriftDetectionStatus",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackDriftDetectionStatusResult");
    return {
      ...xml.strings({
        required: {"StackId":true,"StackDriftDetectionId":true},
        optional: {"DetectionStatusReason":true},
      }),
      StackDriftStatus: xml.first("StackDriftStatus", false, x => (x.content ?? '') as StackDriftStatus),
      DetectionStatus: xml.first("DetectionStatus", true, x => (x.content ?? '') as StackDriftDetectionStatus),
      DriftedStackResourceCount: xml.first("DriftedStackResourceCount", false, x => parseInt(x.content ?? '0')),
      Timestamp: xml.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeStackEvents(
    {abortSignal, ...params}: RequestConfig & DescribeStackEventsInput = {},
  ): Promise<DescribeStackEventsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackEventsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackEvents: xml.getList("StackEvents", "member").map(StackEvent_Parse),
    };
  }

  async describeStackInstance(
    {abortSignal, ...params}: RequestConfig & DescribeStackInstanceInput,
  ): Promise<DescribeStackInstanceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"StackInstanceAccount", (params["StackInstanceAccount"] ?? '').toString());
    body.append(prefix+"StackInstanceRegion", (params["StackInstanceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackInstanceResult");
    return {
      StackInstance: xml.first("StackInstance", false, StackInstance_Parse),
    };
  }

  async describeStackResource(
    {abortSignal, ...params}: RequestConfig & DescribeStackResourceInput,
  ): Promise<DescribeStackResourceOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourceResult");
    return {
      StackResourceDetail: xml.first("StackResourceDetail", false, StackResourceDetail_Parse),
    };
  }

  async describeStackResourceDrifts(
    {abortSignal, ...params}: RequestConfig & DescribeStackResourceDriftsInput,
  ): Promise<DescribeStackResourceDriftsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["StackResourceDriftStatusFilters"]) qsP.appendList(body, prefix+"StackResourceDriftStatusFilters", params["StackResourceDriftStatusFilters"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResourceDrifts",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourceDriftsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackResourceDrifts: xml.getList("StackResourceDrifts", "member").map(StackResourceDrift_Parse),
    };
  }

  async describeStackResources(
    {abortSignal, ...params}: RequestConfig & DescribeStackResourcesInput = {},
  ): Promise<DescribeStackResourcesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("LogicalResourceId" in params) body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    if ("PhysicalResourceId" in params) body.append(prefix+"PhysicalResourceId", (params["PhysicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackResources",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackResourcesResult");
    return {
      StackResources: xml.getList("StackResources", "member").map(StackResource_Parse),
    };
  }

  async describeStackSet(
    {abortSignal, ...params}: RequestConfig & DescribeStackSetInput,
  ): Promise<DescribeStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackSetResult");
    return {
      StackSet: xml.first("StackSet", false, StackSet_Parse),
    };
  }

  async describeStackSetOperation(
    {abortSignal, ...params}: RequestConfig & DescribeStackSetOperationInput,
  ): Promise<DescribeStackSetOperationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStackSetOperation",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStackSetOperationResult");
    return {
      StackSetOperation: xml.first("StackSetOperation", false, StackSetOperation_Parse),
    };
  }

  async describeStacks(
    {abortSignal, ...params}: RequestConfig & DescribeStacksInput = {},
  ): Promise<DescribeStacksOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStacks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeStacksResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Stacks: xml.getList("Stacks", "member").map(Stack_Parse),
    };
  }

  async describeType(
    {abortSignal, ...params}: RequestConfig & DescribeTypeInput = {},
  ): Promise<DescribeTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTypeResult");
    return {
      ...xml.strings({
        optional: {"Arn":true,"TypeName":true,"DefaultVersionId":true,"Description":true,"Schema":true,"ExecutionRoleArn":true,"SourceUrl":true,"DocumentationUrl":true},
      }),
      Type: xml.first("Type", false, x => (x.content ?? '') as RegistryType),
      IsDefaultVersion: xml.first("IsDefaultVersion", false, x => x.content === 'true'),
      ProvisioningType: xml.first("ProvisioningType", false, x => (x.content ?? '') as ProvisioningType),
      DeprecatedStatus: xml.first("DeprecatedStatus", false, x => (x.content ?? '') as DeprecatedStatus),
      LoggingConfig: xml.first("LoggingConfig", false, LoggingConfig_Parse),
      Visibility: xml.first("Visibility", false, x => (x.content ?? '') as Visibility),
      LastUpdated: xml.first("LastUpdated", false, x => xmlP.parseTimestamp(x.content)),
      TimeCreated: xml.first("TimeCreated", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeTypeRegistration(
    {abortSignal, ...params}: RequestConfig & DescribeTypeRegistrationInput,
  ): Promise<DescribeTypeRegistrationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RegistrationToken", (params["RegistrationToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTypeRegistration",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTypeRegistrationResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"TypeArn":true,"TypeVersionArn":true},
      }),
      ProgressStatus: xml.first("ProgressStatus", false, x => (x.content ?? '') as RegistrationStatus),
    };
  }

  async detectStackDrift(
    {abortSignal, ...params}: RequestConfig & DetectStackDriftInput,
  ): Promise<DetectStackDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if (params["LogicalResourceIds"]) qsP.appendList(body, prefix+"LogicalResourceIds", params["LogicalResourceIds"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackDriftResult");
    return xml.strings({
      required: {"StackDriftDetectionId":true},
    });
  }

  async detectStackResourceDrift(
    {abortSignal, ...params}: RequestConfig & DetectStackResourceDriftInput,
  ): Promise<DetectStackResourceDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackResourceDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackResourceDriftResult");
    return {
      StackResourceDrift: xml.first("StackResourceDrift", true, StackResourceDrift_Parse),
    };
  }

  async detectStackSetDrift(
    {abortSignal, ...params}: RequestConfig & DetectStackSetDriftInput,
  ): Promise<DetectStackSetDriftOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectStackSetDrift",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DetectStackSetDriftResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async estimateTemplateCost(
    {abortSignal, ...params}: RequestConfig & EstimateTemplateCostInput = {},
  ): Promise<EstimateTemplateCostOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EstimateTemplateCost",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "EstimateTemplateCostResult");
    return xml.strings({
      optional: {"Url":true},
    });
  }

  async executeChangeSet(
    {abortSignal, ...params}: RequestConfig & ExecuteChangeSetInput,
  ): Promise<ExecuteChangeSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteChangeSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ExecuteChangeSetResult");
    return {};
  }

  async getStackPolicy(
    {abortSignal, ...params}: RequestConfig & GetStackPolicyInput,
  ): Promise<GetStackPolicyOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStackPolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetStackPolicyResult");
    return xml.strings({
      optional: {"StackPolicyBody":true},
    });
  }

  async getTemplate(
    {abortSignal, ...params}: RequestConfig & GetTemplateInput = {},
  ): Promise<GetTemplateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("ChangeSetName" in params) body.append(prefix+"ChangeSetName", (params["ChangeSetName"] ?? '').toString());
    if ("TemplateStage" in params) body.append(prefix+"TemplateStage", (params["TemplateStage"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetTemplateResult");
    return {
      ...xml.strings({
        optional: {"TemplateBody":true},
      }),
      StagesAvailable: xml.getList("StagesAvailable", "member").map(x => (x.content ?? '') as TemplateStage),
    };
  }

  async getTemplateSummary(
    {abortSignal, ...params}: RequestConfig & GetTemplateSummaryInput = {},
  ): Promise<GetTemplateSummaryOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("StackName" in params) body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("StackSetName" in params) body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTemplateSummary",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "GetTemplateSummaryResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"CapabilitiesReason":true,"Version":true,"Metadata":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(ParameterDeclaration_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as Capability),
      ResourceTypes: xml.getList("ResourceTypes", "member").map(x => x.content ?? ''),
      DeclaredTransforms: xml.getList("DeclaredTransforms", "member").map(x => x.content ?? ''),
      ResourceIdentifierSummaries: xml.getList("ResourceIdentifierSummaries", "member").map(ResourceIdentifierSummary_Parse),
    };
  }

  async listChangeSets(
    {abortSignal, ...params}: RequestConfig & ListChangeSetsInput,
  ): Promise<ListChangeSetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListChangeSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListChangeSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(ChangeSetSummary_Parse),
    };
  }

  async listExports(
    {abortSignal, ...params}: RequestConfig & ListExportsInput = {},
  ): Promise<ListExportsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListExports",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListExportsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Exports: xml.getList("Exports", "member").map(Export_Parse),
    };
  }

  async listImports(
    {abortSignal, ...params}: RequestConfig & ListImportsInput,
  ): Promise<ListImportsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ExportName", (params["ExportName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImports",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListImportsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Imports: xml.getList("Imports", "member").map(x => x.content ?? ''),
    };
  }

  async listStackInstances(
    {abortSignal, ...params}: RequestConfig & ListStackInstancesInput,
  ): Promise<ListStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":StackInstanceFilter_Serialize,"entryPrefix":".member."})
    if ("StackInstanceAccount" in params) body.append(prefix+"StackInstanceAccount", (params["StackInstanceAccount"] ?? '').toString());
    if ("StackInstanceRegion" in params) body.append(prefix+"StackInstanceRegion", (params["StackInstanceRegion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackInstancesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackInstanceSummary_Parse),
    };
  }

  async listStackResources(
    {abortSignal, ...params}: RequestConfig & ListStackResourcesInput,
  ): Promise<ListStackResourcesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackResources",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackResourcesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackResourceSummaries: xml.getList("StackResourceSummaries", "member").map(StackResourceSummary_Parse),
    };
  }

  async listStackSetOperationResults(
    {abortSignal, ...params}: RequestConfig & ListStackSetOperationResultsInput,
  ): Promise<ListStackSetOperationResultsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSetOperationResults",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetOperationResultsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetOperationResultSummary_Parse),
    };
  }

  async listStackSetOperations(
    {abortSignal, ...params}: RequestConfig & ListStackSetOperationsInput,
  ): Promise<ListStackSetOperationsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSetOperations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetOperationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetOperationSummary_Parse),
    };
  }

  async listStackSets(
    {abortSignal, ...params}: RequestConfig & ListStackSetsInput = {},
  ): Promise<ListStackSetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("Status" in params) body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStackSets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStackSetsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Summaries: xml.getList("Summaries", "member").map(StackSetSummary_Parse),
    };
  }

  async listStacks(
    {abortSignal, ...params}: RequestConfig & ListStacksInput = {},
  ): Promise<ListStacksOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if (params["StackStatusFilter"]) qsP.appendList(body, prefix+"StackStatusFilter", params["StackStatusFilter"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStacks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListStacksResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StackSummaries: xml.getList("StackSummaries", "member").map(StackSummary_Parse),
    };
  }

  async listTypeRegistrations(
    {abortSignal, ...params}: RequestConfig & ListTypeRegistrationsInput = {},
  ): Promise<ListTypeRegistrationsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("TypeArn" in params) body.append(prefix+"TypeArn", (params["TypeArn"] ?? '').toString());
    if ("RegistrationStatusFilter" in params) body.append(prefix+"RegistrationStatusFilter", (params["RegistrationStatusFilter"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypeRegistrations",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypeRegistrationsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RegistrationTokenList: xml.getList("RegistrationTokenList", "member").map(x => x.content ?? ''),
    };
  }

  async listTypeVersions(
    {abortSignal, ...params}: RequestConfig & ListTypeVersionsInput = {},
  ): Promise<ListTypeVersionsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("DeprecatedStatus" in params) body.append(prefix+"DeprecatedStatus", (params["DeprecatedStatus"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypeVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypeVersionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TypeVersionSummaries: xml.getList("TypeVersionSummaries", "member").map(TypeVersionSummary_Parse),
    };
  }

  async listTypes(
    {abortSignal, ...params}: RequestConfig & ListTypesInput = {},
  ): Promise<ListTypesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Visibility" in params) body.append(prefix+"Visibility", (params["Visibility"] ?? '').toString());
    if ("ProvisioningType" in params) body.append(prefix+"ProvisioningType", (params["ProvisioningType"] ?? '').toString());
    if ("DeprecatedStatus" in params) body.append(prefix+"DeprecatedStatus", (params["DeprecatedStatus"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("MaxResults" in params) body.append(prefix+"MaxResults", (params["MaxResults"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTypes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTypesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      TypeSummaries: xml.getList("TypeSummaries", "member").map(TypeSummary_Parse),
    };
  }

  async recordHandlerProgress(
    {abortSignal, ...params}: RequestConfig & RecordHandlerProgressInput,
  ): Promise<RecordHandlerProgressOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"BearerToken", (params["BearerToken"] ?? '').toString());
    body.append(prefix+"OperationStatus", (params["OperationStatus"] ?? '').toString());
    if ("CurrentOperationStatus" in params) body.append(prefix+"CurrentOperationStatus", (params["CurrentOperationStatus"] ?? '').toString());
    if ("StatusMessage" in params) body.append(prefix+"StatusMessage", (params["StatusMessage"] ?? '').toString());
    if ("ErrorCode" in params) body.append(prefix+"ErrorCode", (params["ErrorCode"] ?? '').toString());
    if ("ResourceModel" in params) body.append(prefix+"ResourceModel", (params["ResourceModel"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecordHandlerProgress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RecordHandlerProgressResult");
    return {};
  }

  async registerType(
    {abortSignal, ...params}: RequestConfig & RegisterTypeInput,
  ): Promise<RegisterTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    body.append(prefix+"SchemaHandlerPackage", (params["SchemaHandlerPackage"] ?? '').toString());
    if (params["LoggingConfig"] != null) LoggingConfig_Serialize(body, prefix+"LoggingConfig", params["LoggingConfig"]);
    if ("ExecutionRoleArn" in params) body.append(prefix+"ExecutionRoleArn", (params["ExecutionRoleArn"] ?? '').toString());
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RegisterTypeResult");
    return xml.strings({
      optional: {"RegistrationToken":true},
    });
  }

  async setStackPolicy(
    {abortSignal, ...params}: RequestConfig & SetStackPolicyInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetStackPolicy",
    });
  }

  async setTypeDefaultVersion(
    {abortSignal, ...params}: RequestConfig & SetTypeDefaultVersionInput = {},
  ): Promise<SetTypeDefaultVersionOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Arn" in params) body.append(prefix+"Arn", (params["Arn"] ?? '').toString());
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("TypeName" in params) body.append(prefix+"TypeName", (params["TypeName"] ?? '').toString());
    if ("VersionId" in params) body.append(prefix+"VersionId", (params["VersionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTypeDefaultVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetTypeDefaultVersionResult");
    return {};
  }

  async signalResource(
    {abortSignal, ...params}: RequestConfig & SignalResourceInput,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    body.append(prefix+"LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    body.append(prefix+"UniqueId", (params["UniqueId"] ?? '').toString());
    body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SignalResource",
    });
  }

  async stopStackSetOperation(
    {abortSignal, ...params}: RequestConfig & StopStackSetOperationInput,
  ): Promise<StopStackSetOperationOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    body.append(prefix+"OperationId", (params["OperationId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStackSetOperation",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StopStackSetOperationResult");
    return {};
  }

  async updateStack(
    {abortSignal, ...params}: RequestConfig & UpdateStackInput,
  ): Promise<UpdateStackOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if ("StackPolicyDuringUpdateBody" in params) body.append(prefix+"StackPolicyDuringUpdateBody", (params["StackPolicyDuringUpdateBody"] ?? '').toString());
    if ("StackPolicyDuringUpdateURL" in params) body.append(prefix+"StackPolicyDuringUpdateURL", (params["StackPolicyDuringUpdateURL"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["ResourceTypes"]) qsP.appendList(body, prefix+"ResourceTypes", params["ResourceTypes"], {"entryPrefix":".member."})
    if ("RoleARN" in params) body.append(prefix+"RoleARN", (params["RoleARN"] ?? '').toString());
    if (params["RollbackConfiguration"] != null) RollbackConfiguration_Serialize(body, prefix+"RollbackConfiguration", params["RollbackConfiguration"]);
    if ("StackPolicyBody" in params) body.append(prefix+"StackPolicyBody", (params["StackPolicyBody"] ?? '').toString());
    if ("StackPolicyURL" in params) body.append(prefix+"StackPolicyURL", (params["StackPolicyURL"] ?? '').toString());
    if (params["NotificationARNs"]) qsP.appendList(body, prefix+"NotificationARNs", params["NotificationARNs"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("ClientRequestToken" in params) body.append(prefix+"ClientRequestToken", (params["ClientRequestToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStack",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async updateStackInstances(
    {abortSignal, ...params}: RequestConfig & UpdateStackInstancesInput,
  ): Promise<UpdateStackInstancesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    if (params["ParameterOverrides"]) qsP.appendList(body, prefix+"ParameterOverrides", params["ParameterOverrides"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStackInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackInstancesResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async updateStackSet(
    {abortSignal, ...params}: RequestConfig & UpdateStackSetInput,
  ): Promise<UpdateStackSetOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"StackSetName", (params["StackSetName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    if ("UsePreviousTemplate" in params) body.append(prefix+"UsePreviousTemplate", (params["UsePreviousTemplate"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".member."})
    if (params["Capabilities"]) qsP.appendList(body, prefix+"Capabilities", params["Capabilities"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if (params["OperationPreferences"] != null) StackSetOperationPreferences_Serialize(body, prefix+"OperationPreferences", params["OperationPreferences"]);
    if ("AdministrationRoleARN" in params) body.append(prefix+"AdministrationRoleARN", (params["AdministrationRoleARN"] ?? '').toString());
    if ("ExecutionRoleName" in params) body.append(prefix+"ExecutionRoleName", (params["ExecutionRoleName"] ?? '').toString());
    if (params["DeploymentTargets"] != null) DeploymentTargets_Serialize(body, prefix+"DeploymentTargets", params["DeploymentTargets"]);
    if ("PermissionModel" in params) body.append(prefix+"PermissionModel", (params["PermissionModel"] ?? '').toString());
    if (params["AutoDeployment"] != null) AutoDeployment_Serialize(body, prefix+"AutoDeployment", params["AutoDeployment"]);
    body.append(prefix+"OperationId", (params["OperationId"] ?? generateIdemptToken()).toString());
    if (params["Accounts"]) qsP.appendList(body, prefix+"Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["Regions"]) qsP.appendList(body, prefix+"Regions", params["Regions"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStackSet",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateStackSetResult");
    return xml.strings({
      optional: {"OperationId":true},
    });
  }

  async updateTerminationProtection(
    {abortSignal, ...params}: RequestConfig & UpdateTerminationProtectionInput,
  ): Promise<UpdateTerminationProtectionOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EnableTerminationProtection", (params["EnableTerminationProtection"] ?? '').toString());
    body.append(prefix+"StackName", (params["StackName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTerminationProtection",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateTerminationProtectionResult");
    return xml.strings({
      optional: {"StackId":true},
    });
  }

  async validateTemplate(
    {abortSignal, ...params}: RequestConfig & ValidateTemplateInput = {},
  ): Promise<ValidateTemplateOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("TemplateBody" in params) body.append(prefix+"TemplateBody", (params["TemplateBody"] ?? '').toString());
    if ("TemplateURL" in params) body.append(prefix+"TemplateURL", (params["TemplateURL"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ValidateTemplateResult");
    return {
      ...xml.strings({
        optional: {"Description":true,"CapabilitiesReason":true},
      }),
      Parameters: xml.getList("Parameters", "member").map(TemplateParameter_Parse),
      Capabilities: xml.getList("Capabilities", "member").map(x => (x.content ?? '') as Capability),
      DeclaredTransforms: xml.getList("DeclaredTransforms", "member").map(x => x.content ?? ''),
    };
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForStackExists(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeStacks(params);
        return resp; // for status 200
      } catch (err) {
        if (!["ValidationError"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is CREATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackCreateComplete(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackCreateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "CREATE_COMPLETE")) return resp;
        if (field?.some(x => x === "CREATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_COMPLETE")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is DELETE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackDeleteComplete(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<Error | DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackDeleteComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "DELETE_COMPLETE")) return resp;
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "CREATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_IN_PROGRESS")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is UPDATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackUpdateComplete(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackUpdateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "UPDATE_COMPLETE")) return resp;
        // BROKEN: if (field?.some(x => x === "UPDATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is IMPORT_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackImportComplete(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackImportComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "IMPORT_COMPLETE")) return resp;
        if (field?.some(x => x === "ROLLBACK_COMPLETE")) throw new Error(errMessage);
        if (field?.some(x => x === "ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_IN_PROGRESS")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "IMPORT_ROLLBACK_COMPLETE")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until stack status is UPDATE_ROLLBACK_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForStackRollbackComplete(
    params: RequestConfig & DescribeStacksInput,
  ): Promise<DescribeStacksOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StackRollbackComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeStacks(params);
        const field = resp?.Stacks?.flatMap(x => x?.StackStatus);
        if (field?.every(x => x === "UPDATE_ROLLBACK_COMPLETE")) return resp;
        // BROKEN: if (field?.some(x => x === "UPDATE_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "UPDATE_ROLLBACK_FAILED")) throw new Error(errMessage);
        if (field?.some(x => x === "DELETE_FAILED")) throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until change set status is CREATE_COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForChangeSetCreateComplete(
    params: RequestConfig & DescribeChangeSetInput,
  ): Promise<DescribeChangeSetOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChangeSetCreateComplete';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeChangeSet(params);
        const field = resp?.Status;
        if (field === "CREATE_COMPLETE") return resp;
        if (field === "FAILED") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationError"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until type registration is COMPLETE.
   * Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time).
   */
  async waitForTypeRegistrationComplete(
    params: RequestConfig & DescribeTypeRegistrationInput,
  ): Promise<DescribeTypeRegistrationOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TypeRegistrationComplete';
    for (let i = 0; i < 120; i++) {
      const resp = await this.describeTypeRegistration(params);
      const field = resp?.ProgressStatus;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CancelUpdateStackInput {
  StackName: string;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ContinueUpdateRollbackInput {
  StackName: string;
  RoleARN?: string | null;
  ResourcesToSkip?: string[] | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateChangeSetInput {
  StackName: string;
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  UsePreviousTemplate?: boolean | null;
  Parameters?: Parameter[] | null;
  Capabilities?: Capability[] | null;
  ResourceTypes?: string[] | null;
  RoleARN?: string | null;
  RollbackConfiguration?: RollbackConfiguration | null;
  NotificationARNs?: string[] | null;
  Tags?: Tag[] | null;
  ChangeSetName: string;
  ClientToken?: string | null;
  Description?: string | null;
  ChangeSetType?: ChangeSetType | null;
  ResourcesToImport?: ResourceToImport[] | null;
  IncludeNestedStacks?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateStackInput {
  StackName: string;
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  Parameters?: Parameter[] | null;
  DisableRollback?: boolean | null;
  RollbackConfiguration?: RollbackConfiguration | null;
  TimeoutInMinutes?: number | null;
  NotificationARNs?: string[] | null;
  Capabilities?: Capability[] | null;
  ResourceTypes?: string[] | null;
  RoleARN?: string | null;
  OnFailure?: OnFailure | null;
  StackPolicyBody?: string | null;
  StackPolicyURL?: string | null;
  Tags?: Tag[] | null;
  ClientRequestToken?: string | null;
  EnableTerminationProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateStackInstancesInput {
  StackSetName: string;
  Accounts?: string[] | null;
  DeploymentTargets?: DeploymentTargets | null;
  Regions: string[];
  ParameterOverrides?: Parameter[] | null;
  OperationPreferences?: StackSetOperationPreferences | null;
  OperationId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateStackSetInput {
  StackSetName: string;
  Description?: string | null;
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  Parameters?: Parameter[] | null;
  Capabilities?: Capability[] | null;
  Tags?: Tag[] | null;
  AdministrationRoleARN?: string | null;
  ExecutionRoleName?: string | null;
  PermissionModel?: PermissionModels | null;
  AutoDeployment?: AutoDeployment | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteChangeSetInput {
  ChangeSetName: string;
  StackName?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStackInput {
  StackName: string;
  RetainResources?: string[] | null;
  RoleARN?: string | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStackInstancesInput {
  StackSetName: string;
  Accounts?: string[] | null;
  DeploymentTargets?: DeploymentTargets | null;
  Regions: string[];
  OperationPreferences?: StackSetOperationPreferences | null;
  RetainStacks: boolean;
  OperationId?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStackSetInput {
  StackSetName: string;
}

// refs: 1 - tags: named, input
export interface DeregisterTypeInput {
  Arn?: string | null;
  Type?: RegistryType | null;
  TypeName?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeAccountLimitsInput {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeChangeSetInput {
  ChangeSetName: string;
  StackName?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStackDriftDetectionStatusInput {
  StackDriftDetectionId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStackEventsInput {
  StackName?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStackInstanceInput {
  StackSetName: string;
  StackInstanceAccount: string;
  StackInstanceRegion: string;
}

// refs: 1 - tags: named, input
export interface DescribeStackResourceInput {
  StackName: string;
  LogicalResourceId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStackResourceDriftsInput {
  StackName: string;
  StackResourceDriftStatusFilters?: StackResourceDriftStatus[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeStackResourcesInput {
  StackName?: string | null;
  LogicalResourceId?: string | null;
  PhysicalResourceId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeStackSetInput {
  StackSetName: string;
}

// refs: 1 - tags: named, input
export interface DescribeStackSetOperationInput {
  StackSetName: string;
  OperationId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStacksInput {
  StackName?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTypeInput {
  Type?: RegistryType | null;
  TypeName?: string | null;
  Arn?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeTypeRegistrationInput {
  RegistrationToken: string;
}

// refs: 1 - tags: named, input
export interface DetectStackDriftInput {
  StackName: string;
  LogicalResourceIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DetectStackResourceDriftInput {
  StackName: string;
  LogicalResourceId: string;
}

// refs: 1 - tags: named, input
export interface DetectStackSetDriftInput {
  StackSetName: string;
  OperationPreferences?: StackSetOperationPreferences | null;
  OperationId?: string | null;
}

// refs: 1 - tags: named, input
export interface EstimateTemplateCostInput {
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  Parameters?: Parameter[] | null;
}

// refs: 1 - tags: named, input
export interface ExecuteChangeSetInput {
  ChangeSetName: string;
  StackName?: string | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetStackPolicyInput {
  StackName: string;
}

// refs: 1 - tags: named, input
export interface GetTemplateInput {
  StackName?: string | null;
  ChangeSetName?: string | null;
  TemplateStage?: TemplateStage | null;
}

// refs: 1 - tags: named, input
export interface GetTemplateSummaryInput {
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  StackName?: string | null;
  StackSetName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListChangeSetsInput {
  StackName: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListExportsInput {
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListImportsInput {
  ExportName: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStackInstancesInput {
  StackSetName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: StackInstanceFilter[] | null;
  StackInstanceAccount?: string | null;
  StackInstanceRegion?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStackResourcesInput {
  StackName: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStackSetOperationResultsInput {
  StackSetName: string;
  OperationId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListStackSetOperationsInput {
  StackSetName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListStackSetsInput {
  NextToken?: string | null;
  MaxResults?: number | null;
  Status?: StackSetStatus | null;
}

// refs: 1 - tags: named, input
export interface ListStacksInput {
  NextToken?: string | null;
  StackStatusFilter?: StackStatus[] | null;
}

// refs: 1 - tags: named, input
export interface ListTypeRegistrationsInput {
  Type?: RegistryType | null;
  TypeName?: string | null;
  TypeArn?: string | null;
  RegistrationStatusFilter?: RegistrationStatus | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTypeVersionsInput {
  Type?: RegistryType | null;
  TypeName?: string | null;
  Arn?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  DeprecatedStatus?: DeprecatedStatus | null;
}

// refs: 1 - tags: named, input
export interface ListTypesInput {
  Visibility?: Visibility | null;
  ProvisioningType?: ProvisioningType | null;
  DeprecatedStatus?: DeprecatedStatus | null;
  Type?: RegistryType | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface RecordHandlerProgressInput {
  BearerToken: string;
  OperationStatus: OperationStatus;
  CurrentOperationStatus?: OperationStatus | null;
  StatusMessage?: string | null;
  ErrorCode?: HandlerErrorCode | null;
  ResourceModel?: string | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface RegisterTypeInput {
  Type?: RegistryType | null;
  TypeName: string;
  SchemaHandlerPackage: string;
  LoggingConfig?: LoggingConfig | null;
  ExecutionRoleArn?: string | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface SetStackPolicyInput {
  StackName: string;
  StackPolicyBody?: string | null;
  StackPolicyURL?: string | null;
}

// refs: 1 - tags: named, input
export interface SetTypeDefaultVersionInput {
  Arn?: string | null;
  Type?: RegistryType | null;
  TypeName?: string | null;
  VersionId?: string | null;
}

// refs: 1 - tags: named, input
export interface SignalResourceInput {
  StackName: string;
  LogicalResourceId: string;
  UniqueId: string;
  Status: ResourceSignalStatus;
}

// refs: 1 - tags: named, input
export interface StopStackSetOperationInput {
  StackSetName: string;
  OperationId: string;
}

// refs: 1 - tags: named, input
export interface UpdateStackInput {
  StackName: string;
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  UsePreviousTemplate?: boolean | null;
  StackPolicyDuringUpdateBody?: string | null;
  StackPolicyDuringUpdateURL?: string | null;
  Parameters?: Parameter[] | null;
  Capabilities?: Capability[] | null;
  ResourceTypes?: string[] | null;
  RoleARN?: string | null;
  RollbackConfiguration?: RollbackConfiguration | null;
  StackPolicyBody?: string | null;
  StackPolicyURL?: string | null;
  NotificationARNs?: string[] | null;
  Tags?: Tag[] | null;
  ClientRequestToken?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateStackInstancesInput {
  StackSetName: string;
  Accounts?: string[] | null;
  DeploymentTargets?: DeploymentTargets | null;
  Regions: string[];
  ParameterOverrides?: Parameter[] | null;
  OperationPreferences?: StackSetOperationPreferences | null;
  OperationId?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateStackSetInput {
  StackSetName: string;
  Description?: string | null;
  TemplateBody?: string | null;
  TemplateURL?: string | null;
  UsePreviousTemplate?: boolean | null;
  Parameters?: Parameter[] | null;
  Capabilities?: Capability[] | null;
  Tags?: Tag[] | null;
  OperationPreferences?: StackSetOperationPreferences | null;
  AdministrationRoleARN?: string | null;
  ExecutionRoleName?: string | null;
  DeploymentTargets?: DeploymentTargets | null;
  PermissionModel?: PermissionModels | null;
  AutoDeployment?: AutoDeployment | null;
  OperationId?: string | null;
  Accounts?: string[] | null;
  Regions?: string[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateTerminationProtectionInput {
  EnableTerminationProtection: boolean;
  StackName: string;
}

// refs: 1 - tags: named, input
export interface ValidateTemplateInput {
  TemplateBody?: string | null;
  TemplateURL?: string | null;
}

// refs: 1 - tags: named, output
export interface ContinueUpdateRollbackOutput {
}

// refs: 1 - tags: named, output
export interface CreateChangeSetOutput {
  Id?: string | null;
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStackOutput {
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStackInstancesOutput {
  OperationId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStackSetOutput {
  StackSetId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteChangeSetOutput {
}

// refs: 1 - tags: named, output
export interface DeleteStackInstancesOutput {
  OperationId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteStackSetOutput {
}

// refs: 1 - tags: named, output
export interface DeregisterTypeOutput {
}

// refs: 1 - tags: named, output
export interface DescribeAccountLimitsOutput {
  AccountLimits: AccountLimit[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeChangeSetOutput {
  ChangeSetName?: string | null;
  ChangeSetId?: string | null;
  StackId?: string | null;
  StackName?: string | null;
  Description?: string | null;
  Parameters: Parameter[];
  CreationTime?: Date | number | null;
  ExecutionStatus?: ExecutionStatus | null;
  Status?: ChangeSetStatus | null;
  StatusReason?: string | null;
  NotificationARNs: string[];
  RollbackConfiguration?: RollbackConfiguration | null;
  Capabilities: Capability[];
  Tags: Tag[];
  Changes: Change[];
  NextToken?: string | null;
  IncludeNestedStacks?: boolean | null;
  ParentChangeSetId?: string | null;
  RootChangeSetId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackDriftDetectionStatusOutput {
  StackId: string;
  StackDriftDetectionId: string;
  StackDriftStatus?: StackDriftStatus | null;
  DetectionStatus: StackDriftDetectionStatus;
  DetectionStatusReason?: string | null;
  DriftedStackResourceCount?: number | null;
  Timestamp: Date | number;
}

// refs: 1 - tags: named, output
export interface DescribeStackEventsOutput {
  StackEvents: StackEvent[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackInstanceOutput {
  StackInstance?: StackInstance | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackResourceOutput {
  StackResourceDetail?: StackResourceDetail | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackResourceDriftsOutput {
  StackResourceDrifts: StackResourceDrift[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackResourcesOutput {
  StackResources: StackResource[];
}

// refs: 1 - tags: named, output
export interface DescribeStackSetOutput {
  StackSet?: StackSet | null;
}

// refs: 1 - tags: named, output
export interface DescribeStackSetOperationOutput {
  StackSetOperation?: StackSetOperation | null;
}

// refs: 1 - tags: named, output
export interface DescribeStacksOutput {
  Stacks: Stack[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeTypeOutput {
  Arn?: string | null;
  Type?: RegistryType | null;
  TypeName?: string | null;
  DefaultVersionId?: string | null;
  IsDefaultVersion?: boolean | null;
  Description?: string | null;
  Schema?: string | null;
  ProvisioningType?: ProvisioningType | null;
  DeprecatedStatus?: DeprecatedStatus | null;
  LoggingConfig?: LoggingConfig | null;
  ExecutionRoleArn?: string | null;
  Visibility?: Visibility | null;
  SourceUrl?: string | null;
  DocumentationUrl?: string | null;
  LastUpdated?: Date | number | null;
  TimeCreated?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeTypeRegistrationOutput {
  ProgressStatus?: RegistrationStatus | null;
  Description?: string | null;
  TypeArn?: string | null;
  TypeVersionArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DetectStackDriftOutput {
  StackDriftDetectionId: string;
}

// refs: 1 - tags: named, output
export interface DetectStackResourceDriftOutput {
  StackResourceDrift: StackResourceDrift;
}

// refs: 1 - tags: named, output
export interface DetectStackSetDriftOutput {
  OperationId?: string | null;
}

// refs: 1 - tags: named, output
export interface EstimateTemplateCostOutput {
  Url?: string | null;
}

// refs: 1 - tags: named, output
export interface ExecuteChangeSetOutput {
}

// refs: 1 - tags: named, output
export interface GetStackPolicyOutput {
  StackPolicyBody?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTemplateOutput {
  TemplateBody?: string | null;
  StagesAvailable: TemplateStage[];
}

// refs: 1 - tags: named, output
export interface GetTemplateSummaryOutput {
  Parameters: ParameterDeclaration[];
  Description?: string | null;
  Capabilities: Capability[];
  CapabilitiesReason?: string | null;
  ResourceTypes: string[];
  Version?: string | null;
  Metadata?: string | null;
  DeclaredTransforms: string[];
  ResourceIdentifierSummaries: ResourceIdentifierSummary[];
}

// refs: 1 - tags: named, output
export interface ListChangeSetsOutput {
  Summaries: ChangeSetSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListExportsOutput {
  Exports: Export[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListImportsOutput {
  Imports: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStackInstancesOutput {
  Summaries: StackInstanceSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStackResourcesOutput {
  StackResourceSummaries: StackResourceSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStackSetOperationResultsOutput {
  Summaries: StackSetOperationResultSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStackSetOperationsOutput {
  Summaries: StackSetOperationSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStackSetsOutput {
  Summaries: StackSetSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStacksOutput {
  StackSummaries: StackSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTypeRegistrationsOutput {
  RegistrationTokenList: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTypeVersionsOutput {
  TypeVersionSummaries: TypeVersionSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTypesOutput {
  TypeSummaries: TypeSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface RecordHandlerProgressOutput {
}

// refs: 1 - tags: named, output
export interface RegisterTypeOutput {
  RegistrationToken?: string | null;
}

// refs: 1 - tags: named, output
export interface SetTypeDefaultVersionOutput {
}

// refs: 1 - tags: named, output
export interface StopStackSetOperationOutput {
}

// refs: 1 - tags: named, output
export interface UpdateStackOutput {
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateStackInstancesOutput {
  OperationId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateStackSetOutput {
  OperationId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateTerminationProtectionOutput {
  StackId?: string | null;
}

// refs: 1 - tags: named, output
export interface ValidateTemplateOutput {
  Parameters: TemplateParameter[];
  Description?: string | null;
  Capabilities: Capability[];
  CapabilitiesReason?: string | null;
  DeclaredTransforms: string[];
}

// refs: 12 - tags: input, named, interface, output
export interface Parameter {
  ParameterKey?: string | null;
  ParameterValue?: string | null;
  UsePreviousValue?: boolean | null;
  ResolvedValue?: string | null;
}
function Parameter_Serialize(body: URLSearchParams, prefix: string, params: Parameter) {
    if ("ParameterKey" in params) body.append(prefix+".ParameterKey", (params["ParameterKey"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("UsePreviousValue" in params) body.append(prefix+".UsePreviousValue", (params["UsePreviousValue"] ?? '').toString());
    if ("ResolvedValue" in params) body.append(prefix+".ResolvedValue", (params["ResolvedValue"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"ParameterValue":true,"ResolvedValue":true},
    }),
    UsePreviousValue: node.first("UsePreviousValue", false, x => x.content === 'true'),
  };
}

// refs: 10 - tags: input, named, enum, output
export type Capability =
| "CAPABILITY_IAM"
| "CAPABILITY_NAMED_IAM"
| "CAPABILITY_AUTO_EXPAND"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface RollbackConfiguration {
  RollbackTriggers: RollbackTrigger[];
  MonitoringTimeInMinutes?: number | null;
}
function RollbackConfiguration_Serialize(body: URLSearchParams, prefix: string, params: RollbackConfiguration) {
    if (params["RollbackTriggers"]) qsP.appendList(body, prefix+".RollbackTriggers", params["RollbackTriggers"], {"appender":RollbackTrigger_Serialize,"entryPrefix":".member."})
    if ("MonitoringTimeInMinutes" in params) body.append(prefix+".MonitoringTimeInMinutes", (params["MonitoringTimeInMinutes"] ?? '').toString());
}
function RollbackConfiguration_Parse(node: xmlP.XmlNode): RollbackConfiguration {
  return {
    RollbackTriggers: node.getList("RollbackTriggers", "member").map(RollbackTrigger_Parse),
    MonitoringTimeInMinutes: node.first("MonitoringTimeInMinutes", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 5 - tags: input, named, interface, output
export interface RollbackTrigger {
  Arn: string;
  Type: string;
}
function RollbackTrigger_Serialize(body: URLSearchParams, prefix: string, params: RollbackTrigger) {
    body.append(prefix+".Arn", (params["Arn"] ?? '').toString());
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
}
function RollbackTrigger_Parse(node: xmlP.XmlNode): RollbackTrigger {
  return node.strings({
    required: {"Arn":true,"Type":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 1 - tags: input, named, enum
export type ChangeSetType =
| "CREATE"
| "UPDATE"
| "IMPORT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ResourceToImport {
  ResourceType: string;
  LogicalResourceId: string;
  ResourceIdentifier: { [key: string]: string | null | undefined };
}
function ResourceToImport_Serialize(body: URLSearchParams, prefix: string, params: ResourceToImport) {
    body.append(prefix+".ResourceType", (params["ResourceType"] ?? '').toString());
    body.append(prefix+".LogicalResourceId", (params["LogicalResourceId"] ?? '').toString());
    if (params["ResourceIdentifier"]) qsP.appendMap(body, prefix+".ResourceIdentifier", params["ResourceIdentifier"], {"entryPrefix":".entry."})
}

// refs: 1 - tags: input, named, enum
export type OnFailure =
| "DO_NOTHING"
| "ROLLBACK"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface DeploymentTargets {
  Accounts: string[];
  OrganizationalUnitIds: string[];
}
function DeploymentTargets_Serialize(body: URLSearchParams, prefix: string, params: DeploymentTargets) {
    if (params["Accounts"]) qsP.appendList(body, prefix+".Accounts", params["Accounts"], {"entryPrefix":".member."})
    if (params["OrganizationalUnitIds"]) qsP.appendList(body, prefix+".OrganizationalUnitIds", params["OrganizationalUnitIds"], {"entryPrefix":".member."})
}
function DeploymentTargets_Parse(node: xmlP.XmlNode): DeploymentTargets {
  return {
    Accounts: node.getList("Accounts", "member").map(x => x.content ?? ''),
    OrganizationalUnitIds: node.getList("OrganizationalUnitIds", "member").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface StackSetOperationPreferences {
  RegionOrder: string[];
  FailureToleranceCount?: number | null;
  FailureTolerancePercentage?: number | null;
  MaxConcurrentCount?: number | null;
  MaxConcurrentPercentage?: number | null;
}
function StackSetOperationPreferences_Serialize(body: URLSearchParams, prefix: string, params: StackSetOperationPreferences) {
    if (params["RegionOrder"]) qsP.appendList(body, prefix+".RegionOrder", params["RegionOrder"], {"entryPrefix":".member."})
    if ("FailureToleranceCount" in params) body.append(prefix+".FailureToleranceCount", (params["FailureToleranceCount"] ?? '').toString());
    if ("FailureTolerancePercentage" in params) body.append(prefix+".FailureTolerancePercentage", (params["FailureTolerancePercentage"] ?? '').toString());
    if ("MaxConcurrentCount" in params) body.append(prefix+".MaxConcurrentCount", (params["MaxConcurrentCount"] ?? '').toString());
    if ("MaxConcurrentPercentage" in params) body.append(prefix+".MaxConcurrentPercentage", (params["MaxConcurrentPercentage"] ?? '').toString());
}
function StackSetOperationPreferences_Parse(node: xmlP.XmlNode): StackSetOperationPreferences {
  return {
    RegionOrder: node.getList("RegionOrder", "member").map(x => x.content ?? ''),
    FailureToleranceCount: node.first("FailureToleranceCount", false, x => parseInt(x.content ?? '0')),
    FailureTolerancePercentage: node.first("FailureTolerancePercentage", false, x => parseInt(x.content ?? '0')),
    MaxConcurrentCount: node.first("MaxConcurrentCount", false, x => parseInt(x.content ?? '0')),
    MaxConcurrentPercentage: node.first("MaxConcurrentPercentage", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 4 - tags: input, named, enum, output
export type PermissionModels =
| "SERVICE_MANAGED"
| "SELF_MANAGED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface AutoDeployment {
  Enabled?: boolean | null;
  RetainStacksOnAccountRemoval?: boolean | null;
}
function AutoDeployment_Serialize(body: URLSearchParams, prefix: string, params: AutoDeployment) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("RetainStacksOnAccountRemoval" in params) body.append(prefix+".RetainStacksOnAccountRemoval", (params["RetainStacksOnAccountRemoval"] ?? '').toString());
}
function AutoDeployment_Parse(node: xmlP.XmlNode): AutoDeployment {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    RetainStacksOnAccountRemoval: node.first("RetainStacksOnAccountRemoval", false, x => x.content === 'true'),
  };
}

// refs: 10 - tags: input, named, enum, output
export type RegistryType =
| "RESOURCE"
| "MODULE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type StackResourceDriftStatus =
| "IN_SYNC"
| "MODIFIED"
| "DELETED"
| "NOT_CHECKED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type TemplateStage =
| "Original"
| "Processed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface StackInstanceFilter {
  Name?: StackInstanceFilterName | null;
  Values?: string | null;
}
function StackInstanceFilter_Serialize(body: URLSearchParams, prefix: string, params: StackInstanceFilter) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Values" in params) body.append(prefix+".Values", (params["Values"] ?? '').toString());
}

// refs: 1 - tags: input, named, enum
export type StackInstanceFilterName =
| "DETAILED_STATUS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type StackSetStatus =
| "ACTIVE"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type StackStatus =
| "CREATE_IN_PROGRESS"
| "CREATE_FAILED"
| "CREATE_COMPLETE"
| "ROLLBACK_IN_PROGRESS"
| "ROLLBACK_FAILED"
| "ROLLBACK_COMPLETE"
| "DELETE_IN_PROGRESS"
| "DELETE_FAILED"
| "DELETE_COMPLETE"
| "UPDATE_IN_PROGRESS"
| "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS"
| "UPDATE_COMPLETE"
| "UPDATE_ROLLBACK_IN_PROGRESS"
| "UPDATE_ROLLBACK_FAILED"
| "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS"
| "UPDATE_ROLLBACK_COMPLETE"
| "REVIEW_IN_PROGRESS"
| "IMPORT_IN_PROGRESS"
| "IMPORT_COMPLETE"
| "IMPORT_ROLLBACK_IN_PROGRESS"
| "IMPORT_ROLLBACK_FAILED"
| "IMPORT_ROLLBACK_COMPLETE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type RegistrationStatus =
| "COMPLETE"
| "IN_PROGRESS"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type DeprecatedStatus =
| "LIVE"
| "DEPRECATED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type Visibility =
| "PUBLIC"
| "PRIVATE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ProvisioningType =
| "NON_PROVISIONABLE"
| "IMMUTABLE"
| "FULLY_MUTABLE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type OperationStatus =
| "PENDING"
| "IN_PROGRESS"
| "SUCCESS"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type HandlerErrorCode =
| "NotUpdatable"
| "InvalidRequest"
| "AccessDenied"
| "InvalidCredentials"
| "AlreadyExists"
| "NotFound"
| "ResourceConflict"
| "Throttling"
| "ServiceLimitExceeded"
| "NotStabilized"
| "GeneralServiceException"
| "ServiceInternalError"
| "NetworkFailure"
| "InternalFailure"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface LoggingConfig {
  LogRoleArn: string;
  LogGroupName: string;
}
function LoggingConfig_Serialize(body: URLSearchParams, prefix: string, params: LoggingConfig) {
    body.append(prefix+".LogRoleArn", (params["LogRoleArn"] ?? '').toString());
    body.append(prefix+".LogGroupName", (params["LogGroupName"] ?? '').toString());
}
function LoggingConfig_Parse(node: xmlP.XmlNode): LoggingConfig {
  return node.strings({
    required: {"LogRoleArn":true,"LogGroupName":true},
  });
}

// refs: 1 - tags: input, named, enum
export type ResourceSignalStatus =
| "SUCCESS"
| "FAILURE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AccountLimit {
  Name?: string | null;
  Value?: number | null;
}
function AccountLimit_Parse(node: xmlP.XmlNode): AccountLimit {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Value: node.first("Value", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, enum
export type ExecutionStatus =
| "UNAVAILABLE"
| "AVAILABLE"
| "EXECUTE_IN_PROGRESS"
| "EXECUTE_COMPLETE"
| "EXECUTE_FAILED"
| "OBSOLETE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ChangeSetStatus =
| "CREATE_PENDING"
| "CREATE_IN_PROGRESS"
| "CREATE_COMPLETE"
| "DELETE_PENDING"
| "DELETE_IN_PROGRESS"
| "DELETE_COMPLETE"
| "DELETE_FAILED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Change {
  Type?: ChangeType | null;
  ResourceChange?: ResourceChange | null;
}
function Change_Parse(node: xmlP.XmlNode): Change {
  return {
    Type: node.first("Type", false, x => (x.content ?? '') as ChangeType),
    ResourceChange: node.first("ResourceChange", false, ResourceChange_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ChangeType =
| "Resource"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ResourceChange {
  Action?: ChangeAction | null;
  LogicalResourceId?: string | null;
  PhysicalResourceId?: string | null;
  ResourceType?: string | null;
  Replacement?: Replacement | null;
  Scope: ResourceAttribute[];
  Details: ResourceChangeDetail[];
  ChangeSetId?: string | null;
  ModuleInfo?: ModuleInfo | null;
}
function ResourceChange_Parse(node: xmlP.XmlNode): ResourceChange {
  return {
    ...node.strings({
      optional: {"LogicalResourceId":true,"PhysicalResourceId":true,"ResourceType":true,"ChangeSetId":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as ChangeAction),
    Replacement: node.first("Replacement", false, x => (x.content ?? '') as Replacement),
    Scope: node.getList("Scope", "member").map(x => (x.content ?? '') as ResourceAttribute),
    Details: node.getList("Details", "member").map(ResourceChangeDetail_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type ChangeAction =
| "Add"
| "Modify"
| "Remove"
| "Import"
| "Dynamic"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type Replacement =
| "True"
| "False"
| "Conditional"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ResourceAttribute =
| "Properties"
| "Metadata"
| "CreationPolicy"
| "UpdatePolicy"
| "DeletionPolicy"
| "Tags"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ResourceChangeDetail {
  Target?: ResourceTargetDefinition | null;
  Evaluation?: EvaluationType | null;
  ChangeSource?: ChangeSource | null;
  CausingEntity?: string | null;
}
function ResourceChangeDetail_Parse(node: xmlP.XmlNode): ResourceChangeDetail {
  return {
    ...node.strings({
      optional: {"CausingEntity":true},
    }),
    Target: node.first("Target", false, ResourceTargetDefinition_Parse),
    Evaluation: node.first("Evaluation", false, x => (x.content ?? '') as EvaluationType),
    ChangeSource: node.first("ChangeSource", false, x => (x.content ?? '') as ChangeSource),
  };
}

// refs: 1 - tags: output, named, interface
export interface ResourceTargetDefinition {
  Attribute?: ResourceAttribute | null;
  Name?: string | null;
  RequiresRecreation?: RequiresRecreation | null;
}
function ResourceTargetDefinition_Parse(node: xmlP.XmlNode): ResourceTargetDefinition {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Attribute: node.first("Attribute", false, x => (x.content ?? '') as ResourceAttribute),
    RequiresRecreation: node.first("RequiresRecreation", false, x => (x.content ?? '') as RequiresRecreation),
  };
}

// refs: 1 - tags: output, named, enum
export type RequiresRecreation =
| "Never"
| "Conditionally"
| "Always"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type EvaluationType =
| "Static"
| "Dynamic"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type ChangeSource =
| "ResourceReference"
| "ParameterReference"
| "ResourceAttribute"
| "DirectModification"
| "Automatic"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface ModuleInfo {
  TypeHierarchy?: string | null;
  LogicalIdHierarchy?: string | null;
}
function ModuleInfo_Parse(node: xmlP.XmlNode): ModuleInfo {
  return node.strings({
    optional: {"TypeHierarchy":true,"LogicalIdHierarchy":true},
  });
}

// refs: 6 - tags: output, named, enum
export type StackDriftStatus =
| "DRIFTED"
| "IN_SYNC"
| "UNKNOWN"
| "NOT_CHECKED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type StackDriftDetectionStatus =
| "DETECTION_IN_PROGRESS"
| "DETECTION_FAILED"
| "DETECTION_COMPLETE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackEvent {
  StackId: string;
  EventId: string;
  StackName: string;
  LogicalResourceId?: string | null;
  PhysicalResourceId?: string | null;
  ResourceType?: string | null;
  Timestamp: Date | number;
  ResourceStatus?: ResourceStatus | null;
  ResourceStatusReason?: string | null;
  ResourceProperties?: string | null;
  ClientRequestToken?: string | null;
}
function StackEvent_Parse(node: xmlP.XmlNode): StackEvent {
  return {
    ...node.strings({
      required: {"StackId":true,"EventId":true,"StackName":true},
      optional: {"LogicalResourceId":true,"PhysicalResourceId":true,"ResourceType":true,"ResourceStatusReason":true,"ResourceProperties":true,"ClientRequestToken":true},
    }),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", false, x => (x.content ?? '') as ResourceStatus),
  };
}

// refs: 4 - tags: output, named, enum
export type ResourceStatus =
| "CREATE_IN_PROGRESS"
| "CREATE_FAILED"
| "CREATE_COMPLETE"
| "DELETE_IN_PROGRESS"
| "DELETE_FAILED"
| "DELETE_COMPLETE"
| "DELETE_SKIPPED"
| "UPDATE_IN_PROGRESS"
| "UPDATE_FAILED"
| "UPDATE_COMPLETE"
| "IMPORT_FAILED"
| "IMPORT_COMPLETE"
| "IMPORT_IN_PROGRESS"
| "IMPORT_ROLLBACK_IN_PROGRESS"
| "IMPORT_ROLLBACK_FAILED"
| "IMPORT_ROLLBACK_COMPLETE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackInstance {
  StackSetId?: string | null;
  Region?: string | null;
  Account?: string | null;
  StackId?: string | null;
  ParameterOverrides: Parameter[];
  Status?: StackInstanceStatus | null;
  StackInstanceStatus?: StackInstanceComprehensiveStatus | null;
  StatusReason?: string | null;
  OrganizationalUnitId?: string | null;
  DriftStatus?: StackDriftStatus | null;
  LastDriftCheckTimestamp?: Date | number | null;
}
function StackInstance_Parse(node: xmlP.XmlNode): StackInstance {
  return {
    ...node.strings({
      optional: {"StackSetId":true,"Region":true,"Account":true,"StackId":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    ParameterOverrides: node.getList("ParameterOverrides", "member").map(Parameter_Parse),
    Status: node.first("Status", false, x => (x.content ?? '') as StackInstanceStatus),
    StackInstanceStatus: node.first("StackInstanceStatus", false, StackInstanceComprehensiveStatus_Parse),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, enum
export type StackInstanceStatus =
| "CURRENT"
| "OUTDATED"
| "INOPERABLE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface StackInstanceComprehensiveStatus {
  DetailedStatus?: StackInstanceDetailedStatus | null;
}
function StackInstanceComprehensiveStatus_Parse(node: xmlP.XmlNode): StackInstanceComprehensiveStatus {
  return {
    DetailedStatus: node.first("DetailedStatus", false, x => (x.content ?? '') as StackInstanceDetailedStatus),
  };
}

// refs: 2 - tags: output, named, enum
export type StackInstanceDetailedStatus =
| "PENDING"
| "RUNNING"
| "SUCCEEDED"
| "FAILED"
| "CANCELLED"
| "INOPERABLE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackResourceDetail {
  StackName?: string | null;
  StackId?: string | null;
  LogicalResourceId: string;
  PhysicalResourceId?: string | null;
  ResourceType: string;
  LastUpdatedTimestamp: Date | number;
  ResourceStatus: ResourceStatus;
  ResourceStatusReason?: string | null;
  Description?: string | null;
  Metadata?: string | null;
  DriftInformation?: StackResourceDriftInformation | null;
  ModuleInfo?: ModuleInfo | null;
}
function StackResourceDetail_Parse(node: xmlP.XmlNode): StackResourceDetail {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"StackName":true,"StackId":true,"PhysicalResourceId":true,"ResourceStatusReason":true,"Description":true,"Metadata":true},
    }),
    LastUpdatedTimestamp: node.first("LastUpdatedTimestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformation_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface StackResourceDriftInformation {
  StackResourceDriftStatus: StackResourceDriftStatus;
  LastCheckTimestamp?: Date | number | null;
}
function StackResourceDriftInformation_Parse(node: xmlP.XmlNode): StackResourceDriftInformation {
  return {
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as StackResourceDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface StackResourceDrift {
  StackId: string;
  LogicalResourceId: string;
  PhysicalResourceId?: string | null;
  PhysicalResourceIdContext: PhysicalResourceIdContextKeyValuePair[];
  ResourceType: string;
  ExpectedProperties?: string | null;
  ActualProperties?: string | null;
  PropertyDifferences: PropertyDifference[];
  StackResourceDriftStatus: StackResourceDriftStatus;
  Timestamp: Date | number;
  ModuleInfo?: ModuleInfo | null;
}
function StackResourceDrift_Parse(node: xmlP.XmlNode): StackResourceDrift {
  return {
    ...node.strings({
      required: {"StackId":true,"LogicalResourceId":true,"ResourceType":true},
      optional: {"PhysicalResourceId":true,"ExpectedProperties":true,"ActualProperties":true},
    }),
    PhysicalResourceIdContext: node.getList("PhysicalResourceIdContext", "member").map(PhysicalResourceIdContextKeyValuePair_Parse),
    PropertyDifferences: node.getList("PropertyDifferences", "member").map(PropertyDifference_Parse),
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as StackResourceDriftStatus),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface PhysicalResourceIdContextKeyValuePair {
  Key: string;
  Value: string;
}
function PhysicalResourceIdContextKeyValuePair_Parse(node: xmlP.XmlNode): PhysicalResourceIdContextKeyValuePair {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface PropertyDifference {
  PropertyPath: string;
  ExpectedValue: string;
  ActualValue: string;
  DifferenceType: DifferenceType;
}
function PropertyDifference_Parse(node: xmlP.XmlNode): PropertyDifference {
  return {
    ...node.strings({
      required: {"PropertyPath":true,"ExpectedValue":true,"ActualValue":true},
    }),
    DifferenceType: node.first("DifferenceType", true, x => (x.content ?? '') as DifferenceType),
  };
}

// refs: 2 - tags: output, named, enum
export type DifferenceType =
| "ADD"
| "REMOVE"
| "NOT_EQUAL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackResource {
  StackName?: string | null;
  StackId?: string | null;
  LogicalResourceId: string;
  PhysicalResourceId?: string | null;
  ResourceType: string;
  Timestamp: Date | number;
  ResourceStatus: ResourceStatus;
  ResourceStatusReason?: string | null;
  Description?: string | null;
  DriftInformation?: StackResourceDriftInformation | null;
  ModuleInfo?: ModuleInfo | null;
}
function StackResource_Parse(node: xmlP.XmlNode): StackResource {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"StackName":true,"StackId":true,"PhysicalResourceId":true,"ResourceStatusReason":true,"Description":true},
    }),
    Timestamp: node.first("Timestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformation_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackSet {
  StackSetName?: string | null;
  StackSetId?: string | null;
  Description?: string | null;
  Status?: StackSetStatus | null;
  TemplateBody?: string | null;
  Parameters: Parameter[];
  Capabilities: Capability[];
  Tags: Tag[];
  StackSetARN?: string | null;
  AdministrationRoleARN?: string | null;
  ExecutionRoleName?: string | null;
  StackSetDriftDetectionDetails?: StackSetDriftDetectionDetails | null;
  AutoDeployment?: AutoDeployment | null;
  PermissionModel?: PermissionModels | null;
  OrganizationalUnitIds: string[];
}
function StackSet_Parse(node: xmlP.XmlNode): StackSet {
  return {
    ...node.strings({
      optional: {"StackSetName":true,"StackSetId":true,"Description":true,"TemplateBody":true,"StackSetARN":true,"AdministrationRoleARN":true,"ExecutionRoleName":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as StackSetStatus),
    Parameters: node.getList("Parameters", "member").map(Parameter_Parse),
    Capabilities: node.getList("Capabilities", "member").map(x => (x.content ?? '') as Capability),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    StackSetDriftDetectionDetails: node.first("StackSetDriftDetectionDetails", false, StackSetDriftDetectionDetails_Parse),
    AutoDeployment: node.first("AutoDeployment", false, AutoDeployment_Parse),
    PermissionModel: node.first("PermissionModel", false, x => (x.content ?? '') as PermissionModels),
    OrganizationalUnitIds: node.getList("OrganizationalUnitIds", "member").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface StackSetDriftDetectionDetails {
  DriftStatus?: StackSetDriftStatus | null;
  DriftDetectionStatus?: StackSetDriftDetectionStatus | null;
  LastDriftCheckTimestamp?: Date | number | null;
  TotalStackInstancesCount?: number | null;
  DriftedStackInstancesCount?: number | null;
  InSyncStackInstancesCount?: number | null;
  InProgressStackInstancesCount?: number | null;
  FailedStackInstancesCount?: number | null;
}
function StackSetDriftDetectionDetails_Parse(node: xmlP.XmlNode): StackSetDriftDetectionDetails {
  return {
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as StackSetDriftStatus),
    DriftDetectionStatus: node.first("DriftDetectionStatus", false, x => (x.content ?? '') as StackSetDriftDetectionStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    TotalStackInstancesCount: node.first("TotalStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    DriftedStackInstancesCount: node.first("DriftedStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    InSyncStackInstancesCount: node.first("InSyncStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    InProgressStackInstancesCount: node.first("InProgressStackInstancesCount", false, x => parseInt(x.content ?? '0')),
    FailedStackInstancesCount: node.first("FailedStackInstancesCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: output, named, enum
export type StackSetDriftStatus =
| "DRIFTED"
| "IN_SYNC"
| "NOT_CHECKED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type StackSetDriftDetectionStatus =
| "COMPLETED"
| "FAILED"
| "PARTIAL_SUCCESS"
| "IN_PROGRESS"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackSetOperation {
  OperationId?: string | null;
  StackSetId?: string | null;
  Action?: StackSetOperationAction | null;
  Status?: StackSetOperationStatus | null;
  OperationPreferences?: StackSetOperationPreferences | null;
  RetainStacks?: boolean | null;
  AdministrationRoleARN?: string | null;
  ExecutionRoleName?: string | null;
  CreationTimestamp?: Date | number | null;
  EndTimestamp?: Date | number | null;
  DeploymentTargets?: DeploymentTargets | null;
  StackSetDriftDetectionDetails?: StackSetDriftDetectionDetails | null;
}
function StackSetOperation_Parse(node: xmlP.XmlNode): StackSetOperation {
  return {
    ...node.strings({
      optional: {"OperationId":true,"StackSetId":true,"AdministrationRoleARN":true,"ExecutionRoleName":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as StackSetOperationAction),
    Status: node.first("Status", false, x => (x.content ?? '') as StackSetOperationStatus),
    OperationPreferences: node.first("OperationPreferences", false, StackSetOperationPreferences_Parse),
    RetainStacks: node.first("RetainStacks", false, x => x.content === 'true'),
    CreationTimestamp: node.first("CreationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    EndTimestamp: node.first("EndTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    DeploymentTargets: node.first("DeploymentTargets", false, DeploymentTargets_Parse),
    StackSetDriftDetectionDetails: node.first("StackSetDriftDetectionDetails", false, StackSetDriftDetectionDetails_Parse),
  };
}

// refs: 2 - tags: output, named, enum
export type StackSetOperationAction =
| "CREATE"
| "UPDATE"
| "DELETE"
| "DETECT_DRIFT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type StackSetOperationStatus =
| "RUNNING"
| "SUCCEEDED"
| "FAILED"
| "STOPPING"
| "STOPPED"
| "QUEUED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Stack {
  StackId?: string | null;
  StackName: string;
  ChangeSetId?: string | null;
  Description?: string | null;
  Parameters: Parameter[];
  CreationTime: Date | number;
  DeletionTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
  RollbackConfiguration?: RollbackConfiguration | null;
  StackStatus: StackStatus;
  StackStatusReason?: string | null;
  DisableRollback?: boolean | null;
  NotificationARNs: string[];
  TimeoutInMinutes?: number | null;
  Capabilities: Capability[];
  Outputs: Output[];
  RoleARN?: string | null;
  Tags: Tag[];
  EnableTerminationProtection?: boolean | null;
  ParentId?: string | null;
  RootId?: string | null;
  DriftInformation?: StackDriftInformation | null;
}
function Stack_Parse(node: xmlP.XmlNode): Stack {
  return {
    ...node.strings({
      required: {"StackName":true},
      optional: {"StackId":true,"ChangeSetId":true,"Description":true,"StackStatusReason":true,"RoleARN":true,"ParentId":true,"RootId":true},
    }),
    Parameters: node.getList("Parameters", "member").map(Parameter_Parse),
    CreationTime: node.first("CreationTime", true, x => xmlP.parseTimestamp(x.content)),
    DeletionTime: node.first("DeletionTime", false, x => xmlP.parseTimestamp(x.content)),
    LastUpdatedTime: node.first("LastUpdatedTime", false, x => xmlP.parseTimestamp(x.content)),
    RollbackConfiguration: node.first("RollbackConfiguration", false, RollbackConfiguration_Parse),
    StackStatus: node.first("StackStatus", true, x => (x.content ?? '') as StackStatus),
    DisableRollback: node.first("DisableRollback", false, x => x.content === 'true'),
    NotificationARNs: node.getList("NotificationARNs", "member").map(x => x.content ?? ''),
    TimeoutInMinutes: node.first("TimeoutInMinutes", false, x => parseInt(x.content ?? '0')),
    Capabilities: node.getList("Capabilities", "member").map(x => (x.content ?? '') as Capability),
    Outputs: node.getList("Outputs", "member").map(Output_Parse),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
    EnableTerminationProtection: node.first("EnableTerminationProtection", false, x => x.content === 'true'),
    DriftInformation: node.first("DriftInformation", false, StackDriftInformation_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface Output {
  OutputKey?: string | null;
  OutputValue?: string | null;
  Description?: string | null;
  ExportName?: string | null;
}
function Output_Parse(node: xmlP.XmlNode): Output {
  return node.strings({
    optional: {"OutputKey":true,"OutputValue":true,"Description":true,"ExportName":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface StackDriftInformation {
  StackDriftStatus: StackDriftStatus;
  LastCheckTimestamp?: Date | number | null;
}
function StackDriftInformation_Parse(node: xmlP.XmlNode): StackDriftInformation {
  return {
    StackDriftStatus: node.first("StackDriftStatus", true, x => (x.content ?? '') as StackDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ParameterDeclaration {
  ParameterKey?: string | null;
  DefaultValue?: string | null;
  ParameterType?: string | null;
  NoEcho?: boolean | null;
  Description?: string | null;
  ParameterConstraints?: ParameterConstraints | null;
}
function ParameterDeclaration_Parse(node: xmlP.XmlNode): ParameterDeclaration {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"DefaultValue":true,"ParameterType":true,"Description":true},
    }),
    NoEcho: node.first("NoEcho", false, x => x.content === 'true'),
    ParameterConstraints: node.first("ParameterConstraints", false, ParameterConstraints_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface ParameterConstraints {
  AllowedValues: string[];
}
function ParameterConstraints_Parse(node: xmlP.XmlNode): ParameterConstraints {
  return {
    AllowedValues: node.getList("AllowedValues", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ResourceIdentifierSummary {
  ResourceType?: string | null;
  LogicalResourceIds: string[];
  ResourceIdentifiers: string[];
}
function ResourceIdentifierSummary_Parse(node: xmlP.XmlNode): ResourceIdentifierSummary {
  return {
    ...node.strings({
      optional: {"ResourceType":true},
    }),
    LogicalResourceIds: node.getList("LogicalResourceIds", "member").map(x => x.content ?? ''),
    ResourceIdentifiers: node.getList("ResourceIdentifiers", "member").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface ChangeSetSummary {
  StackId?: string | null;
  StackName?: string | null;
  ChangeSetId?: string | null;
  ChangeSetName?: string | null;
  ExecutionStatus?: ExecutionStatus | null;
  Status?: ChangeSetStatus | null;
  StatusReason?: string | null;
  CreationTime?: Date | number | null;
  Description?: string | null;
  IncludeNestedStacks?: boolean | null;
  ParentChangeSetId?: string | null;
  RootChangeSetId?: string | null;
}
function ChangeSetSummary_Parse(node: xmlP.XmlNode): ChangeSetSummary {
  return {
    ...node.strings({
      optional: {"StackId":true,"StackName":true,"ChangeSetId":true,"ChangeSetName":true,"StatusReason":true,"Description":true,"ParentChangeSetId":true,"RootChangeSetId":true},
    }),
    ExecutionStatus: node.first("ExecutionStatus", false, x => (x.content ?? '') as ExecutionStatus),
    Status: node.first("Status", false, x => (x.content ?? '') as ChangeSetStatus),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    IncludeNestedStacks: node.first("IncludeNestedStacks", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface Export {
  ExportingStackId?: string | null;
  Name?: string | null;
  Value?: string | null;
}
function Export_Parse(node: xmlP.XmlNode): Export {
  return node.strings({
    optional: {"ExportingStackId":true,"Name":true,"Value":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface StackInstanceSummary {
  StackSetId?: string | null;
  Region?: string | null;
  Account?: string | null;
  StackId?: string | null;
  Status?: StackInstanceStatus | null;
  StatusReason?: string | null;
  StackInstanceStatus?: StackInstanceComprehensiveStatus | null;
  OrganizationalUnitId?: string | null;
  DriftStatus?: StackDriftStatus | null;
  LastDriftCheckTimestamp?: Date | number | null;
}
function StackInstanceSummary_Parse(node: xmlP.XmlNode): StackInstanceSummary {
  return {
    ...node.strings({
      optional: {"StackSetId":true,"Region":true,"Account":true,"StackId":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as StackInstanceStatus),
    StackInstanceStatus: node.first("StackInstanceStatus", false, StackInstanceComprehensiveStatus_Parse),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackResourceSummary {
  LogicalResourceId: string;
  PhysicalResourceId?: string | null;
  ResourceType: string;
  LastUpdatedTimestamp: Date | number;
  ResourceStatus: ResourceStatus;
  ResourceStatusReason?: string | null;
  DriftInformation?: StackResourceDriftInformationSummary | null;
  ModuleInfo?: ModuleInfo | null;
}
function StackResourceSummary_Parse(node: xmlP.XmlNode): StackResourceSummary {
  return {
    ...node.strings({
      required: {"LogicalResourceId":true,"ResourceType":true},
      optional: {"PhysicalResourceId":true,"ResourceStatusReason":true},
    }),
    LastUpdatedTimestamp: node.first("LastUpdatedTimestamp", true, x => xmlP.parseTimestamp(x.content)),
    ResourceStatus: node.first("ResourceStatus", true, x => (x.content ?? '') as ResourceStatus),
    DriftInformation: node.first("DriftInformation", false, StackResourceDriftInformationSummary_Parse),
    ModuleInfo: node.first("ModuleInfo", false, ModuleInfo_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackResourceDriftInformationSummary {
  StackResourceDriftStatus: StackResourceDriftStatus;
  LastCheckTimestamp?: Date | number | null;
}
function StackResourceDriftInformationSummary_Parse(node: xmlP.XmlNode): StackResourceDriftInformationSummary {
  return {
    StackResourceDriftStatus: node.first("StackResourceDriftStatus", true, x => (x.content ?? '') as StackResourceDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackSetOperationResultSummary {
  Account?: string | null;
  Region?: string | null;
  Status?: StackSetOperationResultStatus | null;
  StatusReason?: string | null;
  AccountGateResult?: AccountGateResult | null;
  OrganizationalUnitId?: string | null;
}
function StackSetOperationResultSummary_Parse(node: xmlP.XmlNode): StackSetOperationResultSummary {
  return {
    ...node.strings({
      optional: {"Account":true,"Region":true,"StatusReason":true,"OrganizationalUnitId":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as StackSetOperationResultStatus),
    AccountGateResult: node.first("AccountGateResult", false, AccountGateResult_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type StackSetOperationResultStatus =
| "PENDING"
| "RUNNING"
| "SUCCEEDED"
| "FAILED"
| "CANCELLED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AccountGateResult {
  Status?: AccountGateStatus | null;
  StatusReason?: string | null;
}
function AccountGateResult_Parse(node: xmlP.XmlNode): AccountGateResult {
  return {
    ...node.strings({
      optional: {"StatusReason":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as AccountGateStatus),
  };
}

// refs: 1 - tags: output, named, enum
export type AccountGateStatus =
| "SUCCEEDED"
| "FAILED"
| "SKIPPED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StackSetOperationSummary {
  OperationId?: string | null;
  Action?: StackSetOperationAction | null;
  Status?: StackSetOperationStatus | null;
  CreationTimestamp?: Date | number | null;
  EndTimestamp?: Date | number | null;
}
function StackSetOperationSummary_Parse(node: xmlP.XmlNode): StackSetOperationSummary {
  return {
    ...node.strings({
      optional: {"OperationId":true},
    }),
    Action: node.first("Action", false, x => (x.content ?? '') as StackSetOperationAction),
    Status: node.first("Status", false, x => (x.content ?? '') as StackSetOperationStatus),
    CreationTimestamp: node.first("CreationTimestamp", false, x => xmlP.parseTimestamp(x.content)),
    EndTimestamp: node.first("EndTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackSetSummary {
  StackSetName?: string | null;
  StackSetId?: string | null;
  Description?: string | null;
  Status?: StackSetStatus | null;
  AutoDeployment?: AutoDeployment | null;
  PermissionModel?: PermissionModels | null;
  DriftStatus?: StackDriftStatus | null;
  LastDriftCheckTimestamp?: Date | number | null;
}
function StackSetSummary_Parse(node: xmlP.XmlNode): StackSetSummary {
  return {
    ...node.strings({
      optional: {"StackSetName":true,"StackSetId":true,"Description":true},
    }),
    Status: node.first("Status", false, x => (x.content ?? '') as StackSetStatus),
    AutoDeployment: node.first("AutoDeployment", false, AutoDeployment_Parse),
    PermissionModel: node.first("PermissionModel", false, x => (x.content ?? '') as PermissionModels),
    DriftStatus: node.first("DriftStatus", false, x => (x.content ?? '') as StackDriftStatus),
    LastDriftCheckTimestamp: node.first("LastDriftCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackSummary {
  StackId?: string | null;
  StackName: string;
  TemplateDescription?: string | null;
  CreationTime: Date | number;
  LastUpdatedTime?: Date | number | null;
  DeletionTime?: Date | number | null;
  StackStatus: StackStatus;
  StackStatusReason?: string | null;
  ParentId?: string | null;
  RootId?: string | null;
  DriftInformation?: StackDriftInformationSummary | null;
}
function StackSummary_Parse(node: xmlP.XmlNode): StackSummary {
  return {
    ...node.strings({
      required: {"StackName":true},
      optional: {"StackId":true,"TemplateDescription":true,"StackStatusReason":true,"ParentId":true,"RootId":true},
    }),
    CreationTime: node.first("CreationTime", true, x => xmlP.parseTimestamp(x.content)),
    LastUpdatedTime: node.first("LastUpdatedTime", false, x => xmlP.parseTimestamp(x.content)),
    DeletionTime: node.first("DeletionTime", false, x => xmlP.parseTimestamp(x.content)),
    StackStatus: node.first("StackStatus", true, x => (x.content ?? '') as StackStatus),
    DriftInformation: node.first("DriftInformation", false, StackDriftInformationSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface StackDriftInformationSummary {
  StackDriftStatus: StackDriftStatus;
  LastCheckTimestamp?: Date | number | null;
}
function StackDriftInformationSummary_Parse(node: xmlP.XmlNode): StackDriftInformationSummary {
  return {
    StackDriftStatus: node.first("StackDriftStatus", true, x => (x.content ?? '') as StackDriftStatus),
    LastCheckTimestamp: node.first("LastCheckTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface TypeVersionSummary {
  Type?: RegistryType | null;
  TypeName?: string | null;
  VersionId?: string | null;
  IsDefaultVersion?: boolean | null;
  Arn?: string | null;
  TimeCreated?: Date | number | null;
  Description?: string | null;
}
function TypeVersionSummary_Parse(node: xmlP.XmlNode): TypeVersionSummary {
  return {
    ...node.strings({
      optional: {"TypeName":true,"VersionId":true,"Arn":true,"Description":true},
    }),
    Type: node.first("Type", false, x => (x.content ?? '') as RegistryType),
    IsDefaultVersion: node.first("IsDefaultVersion", false, x => x.content === 'true'),
    TimeCreated: node.first("TimeCreated", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface TypeSummary {
  Type?: RegistryType | null;
  TypeName?: string | null;
  DefaultVersionId?: string | null;
  TypeArn?: string | null;
  LastUpdated?: Date | number | null;
  Description?: string | null;
}
function TypeSummary_Parse(node: xmlP.XmlNode): TypeSummary {
  return {
    ...node.strings({
      optional: {"TypeName":true,"DefaultVersionId":true,"TypeArn":true,"Description":true},
    }),
    Type: node.first("Type", false, x => (x.content ?? '') as RegistryType),
    LastUpdated: node.first("LastUpdated", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface TemplateParameter {
  ParameterKey?: string | null;
  DefaultValue?: string | null;
  NoEcho?: boolean | null;
  Description?: string | null;
}
function TemplateParameter_Parse(node: xmlP.XmlNode): TemplateParameter {
  return {
    ...node.strings({
      optional: {"ParameterKey":true,"DefaultValue":true,"Description":true},
    }),
    NoEcho: node.first("NoEcho", false, x => x.content === 'true'),
  };
}
