// Autogenerated API client for: Elastic Load Balancing

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class ELBv2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ELBv2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-12-01",
    "endpointPrefix": "elasticloadbalancing",
    "protocol": "query",
    "serviceAbbreviation": "Elastic Load Balancing v2",
    "serviceFullName": "Elastic Load Balancing",
    "serviceId": "Elastic Load Balancing v2",
    "signatureVersion": "v4",
    "uid": "elasticloadbalancingv2-2015-12-01",
    "xmlNamespace": "http://elasticloadbalancing.amazonaws.com/doc/2015-12-01/"
  };

  async addListenerCertificates(
    {abortSignal, ...params}: RequestConfig & s.AddListenerCertificatesInput,
  ): Promise<s.AddListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Certificates"]) qsP.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddListenerCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddListenerCertificatesResult");
    return {
      Certificates: xml.getList("Certificates", "member").map(Certificate_Parse),
    };
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & s.AddTagsInput,
  ): Promise<s.AddTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) qsP.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddTagsResult");
    return {};
  }

  async createListener(
    {abortSignal, ...params}: RequestConfig & s.CreateListenerInput,
  ): Promise<s.CreateListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("SslPolicy" in params) body.append(prefix+"SslPolicy", (params["SslPolicy"] ?? '').toString());
    if (params["Certificates"]) qsP.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    if (params["DefaultActions"]) qsP.appendList(body, prefix+"DefaultActions", params["DefaultActions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["AlpnPolicy"]) qsP.appendList(body, prefix+"AlpnPolicy", params["AlpnPolicy"], {"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateListener",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateListenerResult");
    return {
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async createLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.CreateLoadBalancerInput,
  ): Promise<s.CreateLoadBalancerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if (params["Subnets"]) qsP.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    if (params["SubnetMappings"]) qsP.appendList(body, prefix+"SubnetMappings", params["SubnetMappings"], {"appender":SubnetMapping_Serialize,"entryPrefix":".member."})
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    if ("Scheme" in params) body.append(prefix+"Scheme", (params["Scheme"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("Type" in params) body.append(prefix+"Type", (params["Type"] ?? '').toString());
    if ("IpAddressType" in params) body.append(prefix+"IpAddressType", (params["IpAddressType"] ?? '').toString());
    if ("CustomerOwnedIpv4Pool" in params) body.append(prefix+"CustomerOwnedIpv4Pool", (params["CustomerOwnedIpv4Pool"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLoadBalancer",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateLoadBalancerResult");
    return {
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancer_Parse),
    };
  }

  async createRule(
    {abortSignal, ...params}: RequestConfig & s.CreateRuleInput,
  ): Promise<s.CreateRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Conditions"]) qsP.appendList(body, prefix+"Conditions", params["Conditions"], {"appender":RuleCondition_Serialize,"entryPrefix":".member."})
    body.append(prefix+"Priority", (params["Priority"] ?? '').toString());
    if (params["Actions"]) qsP.appendList(body, prefix+"Actions", params["Actions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateRuleResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async createTargetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateTargetGroupInput,
  ): Promise<s.CreateTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Name", (params["Name"] ?? '').toString());
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("ProtocolVersion" in params) body.append(prefix+"ProtocolVersion", (params["ProtocolVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("VpcId" in params) body.append(prefix+"VpcId", (params["VpcId"] ?? '').toString());
    if ("HealthCheckProtocol" in params) body.append(prefix+"HealthCheckProtocol", (params["HealthCheckProtocol"] ?? '').toString());
    if ("HealthCheckPort" in params) body.append(prefix+"HealthCheckPort", (params["HealthCheckPort"] ?? '').toString());
    if ("HealthCheckEnabled" in params) body.append(prefix+"HealthCheckEnabled", (params["HealthCheckEnabled"] ?? '').toString());
    if ("HealthCheckPath" in params) body.append(prefix+"HealthCheckPath", (params["HealthCheckPath"] ?? '').toString());
    if ("HealthCheckIntervalSeconds" in params) body.append(prefix+"HealthCheckIntervalSeconds", (params["HealthCheckIntervalSeconds"] ?? '').toString());
    if ("HealthCheckTimeoutSeconds" in params) body.append(prefix+"HealthCheckTimeoutSeconds", (params["HealthCheckTimeoutSeconds"] ?? '').toString());
    if ("HealthyThresholdCount" in params) body.append(prefix+"HealthyThresholdCount", (params["HealthyThresholdCount"] ?? '').toString());
    if ("UnhealthyThresholdCount" in params) body.append(prefix+"UnhealthyThresholdCount", (params["UnhealthyThresholdCount"] ?? '').toString());
    if (params["Matcher"] != null) Matcher_Serialize(body, prefix+"Matcher", params["Matcher"]);
    if ("TargetType" in params) body.append(prefix+"TargetType", (params["TargetType"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTargetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateTargetGroupResult");
    return {
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async deleteListener(
    {abortSignal, ...params}: RequestConfig & s.DeleteListenerInput,
  ): Promise<s.DeleteListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteListener",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteListenerResult");
    return {};
  }

  async deleteLoadBalancer(
    {abortSignal, ...params}: RequestConfig & s.DeleteLoadBalancerInput,
  ): Promise<s.DeleteLoadBalancerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoadBalancer",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteLoadBalancerResult");
    return {};
  }

  async deleteRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteRuleInput,
  ): Promise<s.DeleteRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleArn", (params["RuleArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteRuleResult");
    return {};
  }

  async deleteTargetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteTargetGroupInput,
  ): Promise<s.DeleteTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTargetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteTargetGroupResult");
    return {};
  }

  async deregisterTargets(
    {abortSignal, ...params}: RequestConfig & s.DeregisterTargetsInput,
  ): Promise<s.DeregisterTargetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) qsP.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterTargets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeregisterTargetsResult");
    return {};
  }

  async describeAccountLimits(
    {abortSignal, ...params}: RequestConfig & s.DescribeAccountLimitsInput = {},
  ): Promise<s.DescribeAccountLimitsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccountLimits",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountLimitsResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Limits: xml.getList("Limits", "member").map(Limit_Parse),
    };
  }

  async describeListenerCertificates(
    {abortSignal, ...params}: RequestConfig & s.DescribeListenerCertificatesInput,
  ): Promise<s.DescribeListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeListenerCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeListenerCertificatesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Certificates: xml.getList("Certificates", "member").map(Certificate_Parse),
    };
  }

  async describeListeners(
    {abortSignal, ...params}: RequestConfig & s.DescribeListenersInput = {},
  ): Promise<s.DescribeListenersOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("LoadBalancerArn" in params) body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["ListenerArns"]) qsP.appendList(body, prefix+"ListenerArns", params["ListenerArns"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeListeners",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeListenersResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async describeLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoadBalancerAttributesInput,
  ): Promise<s.DescribeLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancerAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancerAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(LoadBalancerAttribute_Parse),
    };
  }

  async describeLoadBalancers(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoadBalancersInput = {},
  ): Promise<s.DescribeLoadBalancersOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["LoadBalancerArns"]) qsP.appendList(body, prefix+"LoadBalancerArns", params["LoadBalancerArns"], {"entryPrefix":".member."})
    if (params["Names"]) qsP.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoadBalancers",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeLoadBalancersResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      LoadBalancers: xml.getList("LoadBalancers", "member").map(LoadBalancer_Parse),
    };
  }

  async describeRules(
    {abortSignal, ...params}: RequestConfig & s.DescribeRulesInput = {},
  ): Promise<s.DescribeRulesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ListenerArn" in params) body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["RuleArns"]) qsP.appendList(body, prefix+"RuleArns", params["RuleArns"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRules",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeRulesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async describeSSLPolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribeSSLPoliciesInput = {},
  ): Promise<s.DescribeSSLPoliciesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Names"]) qsP.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSSLPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSSLPoliciesResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      SslPolicies: xml.getList("SslPolicies", "member").map(SslPolicy_Parse),
    };
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsInput,
  ): Promise<s.DescribeTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) qsP.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTagsResult");
    return {
      TagDescriptions: xml.getList("TagDescriptions", "member").map(TagDescription_Parse),
    };
  }

  async describeTargetGroupAttributes(
    {abortSignal, ...params}: RequestConfig & s.DescribeTargetGroupAttributesInput,
  ): Promise<s.DescribeTargetGroupAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetGroupAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTargetGroupAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(TargetGroupAttribute_Parse),
    };
  }

  async describeTargetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeTargetGroupsInput = {},
  ): Promise<s.DescribeTargetGroupsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("LoadBalancerArn" in params) body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["TargetGroupArns"]) qsP.appendList(body, prefix+"TargetGroupArns", params["TargetGroupArns"], {"entryPrefix":".member."})
    if (params["Names"]) qsP.appendList(body, prefix+"Names", params["Names"], {"entryPrefix":".member."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("PageSize" in params) body.append(prefix+"PageSize", (params["PageSize"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTargetGroupsResult");
    return {
      ...xml.strings({
        optional: {"NextMarker":true},
      }),
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async describeTargetHealth(
    {abortSignal, ...params}: RequestConfig & s.DescribeTargetHealthInput,
  ): Promise<s.DescribeTargetHealthOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) qsP.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTargetHealth",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeTargetHealthResult");
    return {
      TargetHealthDescriptions: xml.getList("TargetHealthDescriptions", "member").map(TargetHealthDescription_Parse),
    };
  }

  async modifyListener(
    {abortSignal, ...params}: RequestConfig & s.ModifyListenerInput,
  ): Promise<s.ModifyListenerOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("Protocol" in params) body.append(prefix+"Protocol", (params["Protocol"] ?? '').toString());
    if ("SslPolicy" in params) body.append(prefix+"SslPolicy", (params["SslPolicy"] ?? '').toString());
    if (params["Certificates"]) qsP.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    if (params["DefaultActions"]) qsP.appendList(body, prefix+"DefaultActions", params["DefaultActions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    if (params["AlpnPolicy"]) qsP.appendList(body, prefix+"AlpnPolicy", params["AlpnPolicy"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyListener",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyListenerResult");
    return {
      Listeners: xml.getList("Listeners", "member").map(Listener_Parse),
    };
  }

  async modifyLoadBalancerAttributes(
    {abortSignal, ...params}: RequestConfig & s.ModifyLoadBalancerAttributesInput,
  ): Promise<s.ModifyLoadBalancerAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attributes", params["Attributes"], {"appender":LoadBalancerAttribute_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyLoadBalancerAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyLoadBalancerAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(LoadBalancerAttribute_Parse),
    };
  }

  async modifyRule(
    {abortSignal, ...params}: RequestConfig & s.ModifyRuleInput,
  ): Promise<s.ModifyRuleOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"RuleArn", (params["RuleArn"] ?? '').toString());
    if (params["Conditions"]) qsP.appendList(body, prefix+"Conditions", params["Conditions"], {"appender":RuleCondition_Serialize,"entryPrefix":".member."})
    if (params["Actions"]) qsP.appendList(body, prefix+"Actions", params["Actions"], {"appender":Action_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyRule",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyRuleResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async modifyTargetGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyTargetGroupInput,
  ): Promise<s.ModifyTargetGroupOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if ("HealthCheckProtocol" in params) body.append(prefix+"HealthCheckProtocol", (params["HealthCheckProtocol"] ?? '').toString());
    if ("HealthCheckPort" in params) body.append(prefix+"HealthCheckPort", (params["HealthCheckPort"] ?? '').toString());
    if ("HealthCheckPath" in params) body.append(prefix+"HealthCheckPath", (params["HealthCheckPath"] ?? '').toString());
    if ("HealthCheckEnabled" in params) body.append(prefix+"HealthCheckEnabled", (params["HealthCheckEnabled"] ?? '').toString());
    if ("HealthCheckIntervalSeconds" in params) body.append(prefix+"HealthCheckIntervalSeconds", (params["HealthCheckIntervalSeconds"] ?? '').toString());
    if ("HealthCheckTimeoutSeconds" in params) body.append(prefix+"HealthCheckTimeoutSeconds", (params["HealthCheckTimeoutSeconds"] ?? '').toString());
    if ("HealthyThresholdCount" in params) body.append(prefix+"HealthyThresholdCount", (params["HealthyThresholdCount"] ?? '').toString());
    if ("UnhealthyThresholdCount" in params) body.append(prefix+"UnhealthyThresholdCount", (params["UnhealthyThresholdCount"] ?? '').toString());
    if (params["Matcher"] != null) Matcher_Serialize(body, prefix+"Matcher", params["Matcher"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTargetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyTargetGroupResult");
    return {
      TargetGroups: xml.getList("TargetGroups", "member").map(TargetGroup_Parse),
    };
  }

  async modifyTargetGroupAttributes(
    {abortSignal, ...params}: RequestConfig & s.ModifyTargetGroupAttributesInput,
  ): Promise<s.ModifyTargetGroupAttributesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Attributes"]) qsP.appendList(body, prefix+"Attributes", params["Attributes"], {"appender":TargetGroupAttribute_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyTargetGroupAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyTargetGroupAttributesResult");
    return {
      Attributes: xml.getList("Attributes", "member").map(TargetGroupAttribute_Parse),
    };
  }

  async registerTargets(
    {abortSignal, ...params}: RequestConfig & s.RegisterTargetsInput,
  ): Promise<s.RegisterTargetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["Targets"]) qsP.appendList(body, prefix+"Targets", params["Targets"], {"appender":TargetDescription_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterTargets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RegisterTargetsResult");
    return {};
  }

  async removeListenerCertificates(
    {abortSignal, ...params}: RequestConfig & s.RemoveListenerCertificatesInput,
  ): Promise<s.RemoveListenerCertificatesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ListenerArn", (params["ListenerArn"] ?? '').toString());
    if (params["Certificates"]) qsP.appendList(body, prefix+"Certificates", params["Certificates"], {"appender":Certificate_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveListenerCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveListenerCertificatesResult");
    return {};
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsInput,
  ): Promise<s.RemoveTagsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ResourceArns"]) qsP.appendList(body, prefix+"ResourceArns", params["ResourceArns"], {"entryPrefix":".member."})
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveTagsResult");
    return {};
  }

  async setIpAddressType(
    {abortSignal, ...params}: RequestConfig & s.SetIpAddressTypeInput,
  ): Promise<s.SetIpAddressTypeOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    body.append(prefix+"IpAddressType", (params["IpAddressType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetIpAddressType",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetIpAddressTypeResult");
    return {
      IpAddressType: xml.first("IpAddressType", false, x => (x.content ?? '') as s.IpAddressType),
    };
  }

  async setRulePriorities(
    {abortSignal, ...params}: RequestConfig & s.SetRulePrioritiesInput,
  ): Promise<s.SetRulePrioritiesOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["RulePriorities"]) qsP.appendList(body, prefix+"RulePriorities", params["RulePriorities"], {"appender":RulePriorityPair_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetRulePriorities",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetRulePrioritiesResult");
    return {
      Rules: xml.getList("Rules", "member").map(Rule_Parse),
    };
  }

  async setSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.SetSecurityGroupsInput,
  ): Promise<s.SetSecurityGroupsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["SecurityGroups"]) qsP.appendList(body, prefix+"SecurityGroups", params["SecurityGroups"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetSecurityGroupsResult");
    return {
      SecurityGroupIds: xml.getList("SecurityGroupIds", "member").map(x => x.content ?? ''),
    };
  }

  async setSubnets(
    {abortSignal, ...params}: RequestConfig & s.SetSubnetsInput,
  ): Promise<s.SetSubnetsOutput> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"LoadBalancerArn", (params["LoadBalancerArn"] ?? '').toString());
    if (params["Subnets"]) qsP.appendList(body, prefix+"Subnets", params["Subnets"], {"entryPrefix":".member."})
    if (params["SubnetMappings"]) qsP.appendList(body, prefix+"SubnetMappings", params["SubnetMappings"], {"appender":SubnetMapping_Serialize,"entryPrefix":".member."})
    if ("IpAddressType" in params) body.append(prefix+"IpAddressType", (params["IpAddressType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetSubnets",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "SetSubnetsResult");
    return {
      AvailabilityZones: xml.getList("AvailabilityZones", "member").map(AvailabilityZone_Parse),
      IpAddressType: xml.first("IpAddressType", false, x => (x.content ?? '') as s.IpAddressType),
    };
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancerExists(
    params: RequestConfig & s.DescribeLoadBalancersInput,
  ): Promise<s.DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancerExists';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        return resp; // for status 200
      } catch (err) {
        if (!["LoadBalancerNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancerAvailable(
    params: RequestConfig & s.DescribeLoadBalancersInput,
  ): Promise<s.DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancerAvailable';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        const field = resp?.LoadBalancers?.flatMap(x => x?.State?.Code);
        if (field?.every(x => x === "active")) return resp;
        if (field?.some(x => x === "provisioning")) continue;
      } catch (err) {
        if (!["LoadBalancerNotFound"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForLoadBalancersDeleted(
    params: RequestConfig & s.DescribeLoadBalancersInput,
  ): Promise<Error | s.DescribeLoadBalancersOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LoadBalancersDeleted';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeLoadBalancers(params);
        if (resp?.LoadBalancers?.flatMap(x => x?.State?.Code)?.every(x => x === "active")) continue;
      } catch (err) {
        if (["LoadBalancerNotFound"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForTargetInService(
    params: RequestConfig & s.DescribeTargetHealthInput,
  ): Promise<s.DescribeTargetHealthOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TargetInService';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeTargetHealth(params);
        if (resp?.TargetHealthDescriptions?.flatMap(x => x?.TargetHealth?.State)?.every(x => x === "healthy")) return resp;
      } catch (err) {
        if (!["InvalidInstance"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 15 seconds apart (about 10 minutes max wait time). */
  async waitForTargetDeregistered(
    params: RequestConfig & s.DescribeTargetHealthInput,
  ): Promise<Error | s.DescribeTargetHealthOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TargetDeregistered';
    for (let i = 0; i < 40; i++) {
      try {
        const resp = await this.describeTargetHealth(params);
        if (resp?.TargetHealthDescriptions?.flatMap(x => x?.TargetHealth?.State)?.every(x => x === "unused")) return resp;
      } catch (err) {
        if (["InvalidTarget"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 15000));
    }
    throw new Error(errMessage);
  }

}

function Certificate_Serialize(body: URLSearchParams, prefix: string, params: s.Certificate) {
    if ("CertificateArn" in params) body.append(prefix+".CertificateArn", (params["CertificateArn"] ?? '').toString());
    if ("IsDefault" in params) body.append(prefix+".IsDefault", (params["IsDefault"] ?? '').toString());
}
function Certificate_Parse(node: xmlP.XmlNode): s.Certificate {
  return {
    ...node.strings({
      optional: {"CertificateArn":true},
    }),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

function Action_Serialize(body: URLSearchParams, prefix: string, params: s.Action) {
    body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("TargetGroupArn" in params) body.append(prefix+".TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if (params["AuthenticateOidcConfig"] != null) AuthenticateOidcActionConfig_Serialize(body, prefix+".AuthenticateOidcConfig", params["AuthenticateOidcConfig"]);
    if (params["AuthenticateCognitoConfig"] != null) AuthenticateCognitoActionConfig_Serialize(body, prefix+".AuthenticateCognitoConfig", params["AuthenticateCognitoConfig"]);
    if ("Order" in params) body.append(prefix+".Order", (params["Order"] ?? '').toString());
    if (params["RedirectConfig"] != null) RedirectActionConfig_Serialize(body, prefix+".RedirectConfig", params["RedirectConfig"]);
    if (params["FixedResponseConfig"] != null) FixedResponseActionConfig_Serialize(body, prefix+".FixedResponseConfig", params["FixedResponseConfig"]);
    if (params["ForwardConfig"] != null) ForwardActionConfig_Serialize(body, prefix+".ForwardConfig", params["ForwardConfig"]);
}
function Action_Parse(node: xmlP.XmlNode): s.Action {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as s.ActionTypeEnum),
    AuthenticateOidcConfig: node.first("AuthenticateOidcConfig", false, AuthenticateOidcActionConfig_Parse),
    AuthenticateCognitoConfig: node.first("AuthenticateCognitoConfig", false, AuthenticateCognitoActionConfig_Parse),
    Order: node.first("Order", false, x => parseInt(x.content ?? '0')),
    RedirectConfig: node.first("RedirectConfig", false, RedirectActionConfig_Parse),
    FixedResponseConfig: node.first("FixedResponseConfig", false, FixedResponseActionConfig_Parse),
    ForwardConfig: node.first("ForwardConfig", false, ForwardActionConfig_Parse),
  };
}

function AuthenticateOidcActionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.AuthenticateOidcActionConfig) {
    body.append(prefix+".Issuer", (params["Issuer"] ?? '').toString());
    body.append(prefix+".AuthorizationEndpoint", (params["AuthorizationEndpoint"] ?? '').toString());
    body.append(prefix+".TokenEndpoint", (params["TokenEndpoint"] ?? '').toString());
    body.append(prefix+".UserInfoEndpoint", (params["UserInfoEndpoint"] ?? '').toString());
    body.append(prefix+".ClientId", (params["ClientId"] ?? '').toString());
    if ("ClientSecret" in params) body.append(prefix+".ClientSecret", (params["ClientSecret"] ?? '').toString());
    if ("SessionCookieName" in params) body.append(prefix+".SessionCookieName", (params["SessionCookieName"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
    if ("SessionTimeout" in params) body.append(prefix+".SessionTimeout", (params["SessionTimeout"] ?? '').toString());
    if (params["AuthenticationRequestExtraParams"]) qsP.appendMap(body, prefix+".AuthenticationRequestExtraParams", params["AuthenticationRequestExtraParams"], {"entryPrefix":".entry."})
    if ("OnUnauthenticatedRequest" in params) body.append(prefix+".OnUnauthenticatedRequest", (params["OnUnauthenticatedRequest"] ?? '').toString());
    if ("UseExistingClientSecret" in params) body.append(prefix+".UseExistingClientSecret", (params["UseExistingClientSecret"] ?? '').toString());
}
function AuthenticateOidcActionConfig_Parse(node: xmlP.XmlNode): s.AuthenticateOidcActionConfig {
  return {
    ...node.strings({
      required: {"Issuer":true,"AuthorizationEndpoint":true,"TokenEndpoint":true,"UserInfoEndpoint":true,"ClientId":true},
      optional: {"ClientSecret":true,"SessionCookieName":true,"Scope":true},
    }),
    SessionTimeout: node.first("SessionTimeout", false, x => parseInt(x.content ?? '0')),
    AuthenticationRequestExtraParams: xmlP.readXmlMap(node.getList("AuthenticationRequestExtraParams", "entry"), x => x.content ?? '', {}),
    OnUnauthenticatedRequest: node.first("OnUnauthenticatedRequest", false, x => (x.content ?? '') as s.AuthenticateOidcActionConditionalBehaviorEnum),
    UseExistingClientSecret: node.first("UseExistingClientSecret", false, x => x.content === 'true'),
  };
}

function AuthenticateCognitoActionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.AuthenticateCognitoActionConfig) {
    body.append(prefix+".UserPoolArn", (params["UserPoolArn"] ?? '').toString());
    body.append(prefix+".UserPoolClientId", (params["UserPoolClientId"] ?? '').toString());
    body.append(prefix+".UserPoolDomain", (params["UserPoolDomain"] ?? '').toString());
    if ("SessionCookieName" in params) body.append(prefix+".SessionCookieName", (params["SessionCookieName"] ?? '').toString());
    if ("Scope" in params) body.append(prefix+".Scope", (params["Scope"] ?? '').toString());
    if ("SessionTimeout" in params) body.append(prefix+".SessionTimeout", (params["SessionTimeout"] ?? '').toString());
    if (params["AuthenticationRequestExtraParams"]) qsP.appendMap(body, prefix+".AuthenticationRequestExtraParams", params["AuthenticationRequestExtraParams"], {"entryPrefix":".entry."})
    if ("OnUnauthenticatedRequest" in params) body.append(prefix+".OnUnauthenticatedRequest", (params["OnUnauthenticatedRequest"] ?? '').toString());
}
function AuthenticateCognitoActionConfig_Parse(node: xmlP.XmlNode): s.AuthenticateCognitoActionConfig {
  return {
    ...node.strings({
      required: {"UserPoolArn":true,"UserPoolClientId":true,"UserPoolDomain":true},
      optional: {"SessionCookieName":true,"Scope":true},
    }),
    SessionTimeout: node.first("SessionTimeout", false, x => parseInt(x.content ?? '0')),
    AuthenticationRequestExtraParams: xmlP.readXmlMap(node.getList("AuthenticationRequestExtraParams", "entry"), x => x.content ?? '', {}),
    OnUnauthenticatedRequest: node.first("OnUnauthenticatedRequest", false, x => (x.content ?? '') as s.AuthenticateCognitoActionConditionalBehaviorEnum),
  };
}

function RedirectActionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.RedirectActionConfig) {
    if ("Protocol" in params) body.append(prefix+".Protocol", (params["Protocol"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if ("Host" in params) body.append(prefix+".Host", (params["Host"] ?? '').toString());
    if ("Path" in params) body.append(prefix+".Path", (params["Path"] ?? '').toString());
    if ("Query" in params) body.append(prefix+".Query", (params["Query"] ?? '').toString());
    body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
}
function RedirectActionConfig_Parse(node: xmlP.XmlNode): s.RedirectActionConfig {
  return {
    ...node.strings({
      optional: {"Protocol":true,"Port":true,"Host":true,"Path":true,"Query":true},
    }),
    StatusCode: node.first("StatusCode", true, x => (x.content ?? '') as s.RedirectActionStatusCodeEnum),
  };
}

function FixedResponseActionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.FixedResponseActionConfig) {
    if ("MessageBody" in params) body.append(prefix+".MessageBody", (params["MessageBody"] ?? '').toString());
    body.append(prefix+".StatusCode", (params["StatusCode"] ?? '').toString());
    if ("ContentType" in params) body.append(prefix+".ContentType", (params["ContentType"] ?? '').toString());
}
function FixedResponseActionConfig_Parse(node: xmlP.XmlNode): s.FixedResponseActionConfig {
  return node.strings({
    required: {"StatusCode":true},
    optional: {"MessageBody":true,"ContentType":true},
  });
}

function ForwardActionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.ForwardActionConfig) {
    if (params["TargetGroups"]) qsP.appendList(body, prefix+".TargetGroups", params["TargetGroups"], {"appender":TargetGroupTuple_Serialize,"entryPrefix":".member."})
    if (params["TargetGroupStickinessConfig"] != null) TargetGroupStickinessConfig_Serialize(body, prefix+".TargetGroupStickinessConfig", params["TargetGroupStickinessConfig"]);
}
function ForwardActionConfig_Parse(node: xmlP.XmlNode): s.ForwardActionConfig {
  return {
    TargetGroups: node.getList("TargetGroups", "member").map(TargetGroupTuple_Parse),
    TargetGroupStickinessConfig: node.first("TargetGroupStickinessConfig", false, TargetGroupStickinessConfig_Parse),
  };
}

function TargetGroupTuple_Serialize(body: URLSearchParams, prefix: string, params: s.TargetGroupTuple) {
    if ("TargetGroupArn" in params) body.append(prefix+".TargetGroupArn", (params["TargetGroupArn"] ?? '').toString());
    if ("Weight" in params) body.append(prefix+".Weight", (params["Weight"] ?? '').toString());
}
function TargetGroupTuple_Parse(node: xmlP.XmlNode): s.TargetGroupTuple {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true},
    }),
    Weight: node.first("Weight", false, x => parseInt(x.content ?? '0')),
  };
}

function TargetGroupStickinessConfig_Serialize(body: URLSearchParams, prefix: string, params: s.TargetGroupStickinessConfig) {
    if ("Enabled" in params) body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("DurationSeconds" in params) body.append(prefix+".DurationSeconds", (params["DurationSeconds"] ?? '').toString());
}
function TargetGroupStickinessConfig_Parse(node: xmlP.XmlNode): s.TargetGroupStickinessConfig {
  return {
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
    DurationSeconds: node.first("DurationSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

function SubnetMapping_Serialize(body: URLSearchParams, prefix: string, params: s.SubnetMapping) {
    if ("SubnetId" in params) body.append(prefix+".SubnetId", (params["SubnetId"] ?? '').toString());
    if ("AllocationId" in params) body.append(prefix+".AllocationId", (params["AllocationId"] ?? '').toString());
    if ("PrivateIPv4Address" in params) body.append(prefix+".PrivateIPv4Address", (params["PrivateIPv4Address"] ?? '').toString());
    if ("IPv6Address" in params) body.append(prefix+".IPv6Address", (params["IPv6Address"] ?? '').toString());
}

function RuleCondition_Serialize(body: URLSearchParams, prefix: string, params: s.RuleCondition) {
    if ("Field" in params) body.append(prefix+".Field", (params["Field"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
    if (params["HostHeaderConfig"] != null) HostHeaderConditionConfig_Serialize(body, prefix+".HostHeaderConfig", params["HostHeaderConfig"]);
    if (params["PathPatternConfig"] != null) PathPatternConditionConfig_Serialize(body, prefix+".PathPatternConfig", params["PathPatternConfig"]);
    if (params["HttpHeaderConfig"] != null) HttpHeaderConditionConfig_Serialize(body, prefix+".HttpHeaderConfig", params["HttpHeaderConfig"]);
    if (params["QueryStringConfig"] != null) QueryStringConditionConfig_Serialize(body, prefix+".QueryStringConfig", params["QueryStringConfig"]);
    if (params["HttpRequestMethodConfig"] != null) HttpRequestMethodConditionConfig_Serialize(body, prefix+".HttpRequestMethodConfig", params["HttpRequestMethodConfig"]);
    if (params["SourceIpConfig"] != null) SourceIpConditionConfig_Serialize(body, prefix+".SourceIpConfig", params["SourceIpConfig"]);
}
function RuleCondition_Parse(node: xmlP.XmlNode): s.RuleCondition {
  return {
    ...node.strings({
      optional: {"Field":true},
    }),
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
    HostHeaderConfig: node.first("HostHeaderConfig", false, HostHeaderConditionConfig_Parse),
    PathPatternConfig: node.first("PathPatternConfig", false, PathPatternConditionConfig_Parse),
    HttpHeaderConfig: node.first("HttpHeaderConfig", false, HttpHeaderConditionConfig_Parse),
    QueryStringConfig: node.first("QueryStringConfig", false, QueryStringConditionConfig_Parse),
    HttpRequestMethodConfig: node.first("HttpRequestMethodConfig", false, HttpRequestMethodConditionConfig_Parse),
    SourceIpConfig: node.first("SourceIpConfig", false, SourceIpConditionConfig_Parse),
  };
}

function HostHeaderConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.HostHeaderConditionConfig) {
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HostHeaderConditionConfig_Parse(node: xmlP.XmlNode): s.HostHeaderConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

function PathPatternConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.PathPatternConditionConfig) {
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function PathPatternConditionConfig_Parse(node: xmlP.XmlNode): s.PathPatternConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

function HttpHeaderConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.HttpHeaderConditionConfig) {
    if ("HttpHeaderName" in params) body.append(prefix+".HttpHeaderName", (params["HttpHeaderName"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HttpHeaderConditionConfig_Parse(node: xmlP.XmlNode): s.HttpHeaderConditionConfig {
  return {
    ...node.strings({
      optional: {"HttpHeaderName":true},
    }),
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

function QueryStringConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.QueryStringConditionConfig) {
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"appender":QueryStringKeyValuePair_Serialize,"entryPrefix":".member."})
}
function QueryStringConditionConfig_Parse(node: xmlP.XmlNode): s.QueryStringConditionConfig {
  return {
    Values: node.getList("Values", "member").map(QueryStringKeyValuePair_Parse),
  };
}

function QueryStringKeyValuePair_Serialize(body: URLSearchParams, prefix: string, params: s.QueryStringKeyValuePair) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function QueryStringKeyValuePair_Parse(node: xmlP.XmlNode): s.QueryStringKeyValuePair {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function HttpRequestMethodConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.HttpRequestMethodConditionConfig) {
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function HttpRequestMethodConditionConfig_Parse(node: xmlP.XmlNode): s.HttpRequestMethodConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

function SourceIpConditionConfig_Serialize(body: URLSearchParams, prefix: string, params: s.SourceIpConditionConfig) {
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}
function SourceIpConditionConfig_Parse(node: xmlP.XmlNode): s.SourceIpConditionConfig {
  return {
    Values: node.getList("Values", "member").map(x => x.content ?? ''),
  };
}

function Matcher_Serialize(body: URLSearchParams, prefix: string, params: s.Matcher) {
    if ("HttpCode" in params) body.append(prefix+".HttpCode", (params["HttpCode"] ?? '').toString());
    if ("GrpcCode" in params) body.append(prefix+".GrpcCode", (params["GrpcCode"] ?? '').toString());
}
function Matcher_Parse(node: xmlP.XmlNode): s.Matcher {
  return node.strings({
    optional: {"HttpCode":true,"GrpcCode":true},
  });
}

function TargetDescription_Serialize(body: URLSearchParams, prefix: string, params: s.TargetDescription) {
    body.append(prefix+".Id", (params["Id"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+".AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
}
function TargetDescription_Parse(node: xmlP.XmlNode): s.TargetDescription {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"AvailabilityZone":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

function LoadBalancerAttribute_Serialize(body: URLSearchParams, prefix: string, params: s.LoadBalancerAttribute) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function LoadBalancerAttribute_Parse(node: xmlP.XmlNode): s.LoadBalancerAttribute {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function TargetGroupAttribute_Serialize(body: URLSearchParams, prefix: string, params: s.TargetGroupAttribute) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function TargetGroupAttribute_Parse(node: xmlP.XmlNode): s.TargetGroupAttribute {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function RulePriorityPair_Serialize(body: URLSearchParams, prefix: string, params: s.RulePriorityPair) {
    if ("RuleArn" in params) body.append(prefix+".RuleArn", (params["RuleArn"] ?? '').toString());
    if ("Priority" in params) body.append(prefix+".Priority", (params["Priority"] ?? '').toString());
}

function Listener_Parse(node: xmlP.XmlNode): s.Listener {
  return {
    ...node.strings({
      optional: {"ListenerArn":true,"LoadBalancerArn":true,"SslPolicy":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as s.ProtocolEnum),
    Certificates: node.getList("Certificates", "member").map(Certificate_Parse),
    DefaultActions: node.getList("DefaultActions", "member").map(Action_Parse),
    AlpnPolicy: node.getList("AlpnPolicy", "member").map(x => x.content ?? ''),
  };
}

function LoadBalancer_Parse(node: xmlP.XmlNode): s.LoadBalancer {
  return {
    ...node.strings({
      optional: {"LoadBalancerArn":true,"DNSName":true,"CanonicalHostedZoneId":true,"LoadBalancerName":true,"VpcId":true,"CustomerOwnedIpv4Pool":true},
    }),
    CreatedTime: node.first("CreatedTime", false, x => xmlP.parseTimestamp(x.content)),
    Scheme: node.first("Scheme", false, x => (x.content ?? '') as s.LoadBalancerSchemeEnum),
    State: node.first("State", false, LoadBalancerState_Parse),
    Type: node.first("Type", false, x => (x.content ?? '') as s.LoadBalancerTypeEnum),
    AvailabilityZones: node.getList("AvailabilityZones", "member").map(AvailabilityZone_Parse),
    SecurityGroups: node.getList("SecurityGroups", "member").map(x => x.content ?? ''),
    IpAddressType: node.first("IpAddressType", false, x => (x.content ?? '') as s.IpAddressType),
  };
}

function LoadBalancerState_Parse(node: xmlP.XmlNode): s.LoadBalancerState {
  return {
    ...node.strings({
      optional: {"Reason":true},
    }),
    Code: node.first("Code", false, x => (x.content ?? '') as s.LoadBalancerStateEnum),
  };
}

function AvailabilityZone_Parse(node: xmlP.XmlNode): s.AvailabilityZone {
  return {
    ...node.strings({
      optional: {"ZoneName":true,"SubnetId":true,"OutpostId":true},
    }),
    LoadBalancerAddresses: node.getList("LoadBalancerAddresses", "member").map(LoadBalancerAddress_Parse),
  };
}

function LoadBalancerAddress_Parse(node: xmlP.XmlNode): s.LoadBalancerAddress {
  return node.strings({
    optional: {"IpAddress":true,"AllocationId":true,"PrivateIPv4Address":true,"IPv6Address":true},
  });
}

function Rule_Parse(node: xmlP.XmlNode): s.Rule {
  return {
    ...node.strings({
      optional: {"RuleArn":true,"Priority":true},
    }),
    Conditions: node.getList("Conditions", "member").map(RuleCondition_Parse),
    Actions: node.getList("Actions", "member").map(Action_Parse),
    IsDefault: node.first("IsDefault", false, x => x.content === 'true'),
  };
}

function TargetGroup_Parse(node: xmlP.XmlNode): s.TargetGroup {
  return {
    ...node.strings({
      optional: {"TargetGroupArn":true,"TargetGroupName":true,"VpcId":true,"HealthCheckPort":true,"HealthCheckPath":true,"ProtocolVersion":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as s.ProtocolEnum),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    HealthCheckProtocol: node.first("HealthCheckProtocol", false, x => (x.content ?? '') as s.ProtocolEnum),
    HealthCheckEnabled: node.first("HealthCheckEnabled", false, x => x.content === 'true'),
    HealthCheckIntervalSeconds: node.first("HealthCheckIntervalSeconds", false, x => parseInt(x.content ?? '0')),
    HealthCheckTimeoutSeconds: node.first("HealthCheckTimeoutSeconds", false, x => parseInt(x.content ?? '0')),
    HealthyThresholdCount: node.first("HealthyThresholdCount", false, x => parseInt(x.content ?? '0')),
    UnhealthyThresholdCount: node.first("UnhealthyThresholdCount", false, x => parseInt(x.content ?? '0')),
    Matcher: node.first("Matcher", false, Matcher_Parse),
    LoadBalancerArns: node.getList("LoadBalancerArns", "member").map(x => x.content ?? ''),
    TargetType: node.first("TargetType", false, x => (x.content ?? '') as s.TargetTypeEnum),
  };
}

function Limit_Parse(node: xmlP.XmlNode): s.Limit {
  return node.strings({
    optional: {"Name":true,"Max":true},
  });
}

function SslPolicy_Parse(node: xmlP.XmlNode): s.SslPolicy {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    SslProtocols: node.getList("SslProtocols", "member").map(x => x.content ?? ''),
    Ciphers: node.getList("Ciphers", "member").map(Cipher_Parse),
  };
}

function Cipher_Parse(node: xmlP.XmlNode): s.Cipher {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
  };
}

function TagDescription_Parse(node: xmlP.XmlNode): s.TagDescription {
  return {
    ...node.strings({
      optional: {"ResourceArn":true},
    }),
    Tags: node.getList("Tags", "member").map(Tag_Parse),
  };
}

function TargetHealthDescription_Parse(node: xmlP.XmlNode): s.TargetHealthDescription {
  return {
    ...node.strings({
      optional: {"HealthCheckPort":true},
    }),
    Target: node.first("Target", false, TargetDescription_Parse),
    TargetHealth: node.first("TargetHealth", false, TargetHealth_Parse),
  };
}

function TargetHealth_Parse(node: xmlP.XmlNode): s.TargetHealth {
  return {
    ...node.strings({
      optional: {"Description":true},
    }),
    State: node.first("State", false, x => (x.content ?? '') as s.TargetHealthStateEnum),
    Reason: node.first("Reason", false, x => (x.content ?? '') as s.TargetHealthReasonEnum),
  };
}
