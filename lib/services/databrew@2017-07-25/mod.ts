// Autogenerated API client for: AWS Glue DataBrew

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class DataBrew {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DataBrew.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-07-25",
    "endpointPrefix": "databrew",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS Glue DataBrew",
    "serviceId": "DataBrew",
    "signatureVersion": "v4",
    "signingName": "databrew",
    "uid": "databrew-2017-07-25"
  };

  async batchDeleteRecipeVersion(
    {abortSignal, ...params}: RequestConfig & BatchDeleteRecipeVersionRequest,
  ): Promise<BatchDeleteRecipeVersionResponse> {
    const body: jsonP.JSONObject = {
      RecipeVersions: params["RecipeVersions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteRecipeVersion",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/batchDeleteRecipeVersion`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "Errors": [toRecipeVersionErrorDetail],
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & CreateDatasetRequest,
  ): Promise<CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FormatOptions: fromFormatOptions(params["FormatOptions"]),
      Input: fromInput(params["Input"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createProfileJob(
    {abortSignal, ...params}: RequestConfig & CreateProfileJobRequest,
  ): Promise<CreateProfileJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      Name: params["Name"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      OutputLocation: fromS3Location(params["OutputLocation"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProfileJob",
      requestUri: "/profileJobs",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & CreateProjectRequest,
  ): Promise<CreateProjectResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      Name: params["Name"],
      RecipeName: params["RecipeName"],
      Sample: fromSample(params["Sample"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createRecipe(
    {abortSignal, ...params}: RequestConfig & CreateRecipeRequest,
  ): Promise<CreateRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Name: params["Name"],
      Steps: params["Steps"]?.map(x => fromRecipeStep(x)),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRecipe",
      requestUri: "/recipes",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createRecipeJob(
    {abortSignal, ...params}: RequestConfig & CreateRecipeJobRequest,
  ): Promise<CreateRecipeJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      Name: params["Name"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      Outputs: params["Outputs"]?.map(x => fromOutput(x)),
      ProjectName: params["ProjectName"],
      RecipeReference: fromRecipeReference(params["RecipeReference"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRecipeJob",
      requestUri: "/recipeJobs",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createSchedule(
    {abortSignal, ...params}: RequestConfig & CreateScheduleRequest,
  ): Promise<CreateScheduleResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
      CronExpression: params["CronExpression"],
      Tags: params["Tags"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchedule",
      requestUri: "/schedules",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetRequest,
  ): Promise<DeleteDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteJob(
    {abortSignal, ...params}: RequestConfig & DeleteJobRequest,
  ): Promise<DeleteJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & DeleteProjectRequest,
  ): Promise<DeleteProjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteRecipeVersion(
    {abortSignal, ...params}: RequestConfig & DeleteRecipeVersionRequest,
  ): Promise<DeleteRecipeVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRecipeVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/recipeVersion/${params["RecipeVersion"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "RecipeVersion": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteSchedule(
    {abortSignal, ...params}: RequestConfig & DeleteScheduleRequest,
  ): Promise<DeleteScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSchedule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetRequest,
  ): Promise<DescribeDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataset",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "Input": toInput,
      },
      optional: {
        "CreatedBy": "s",
        "CreateDate": "d",
        "FormatOptions": toFormatOptions,
        "LastModifiedDate": "d",
        "LastModifiedBy": "s",
        "Source": (x: jsonP.JSONValue) => cmnP.readEnum<Source>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "ResourceArn": "s",
      },
    }, await resp.json());
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & DescribeJobRequest,
  ): Promise<DescribeJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "DatasetName": "s",
        "EncryptionKeyArn": "s",
        "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionMode>(x),
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<JobType>(x),
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<LogSubscription>(x),
        "MaxCapacity": "n",
        "MaxRetries": "n",
        "Outputs": [toOutput],
        "ProjectName": "s",
        "RecipeReference": toRecipeReference,
        "ResourceArn": "s",
        "RoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Timeout": "n",
      },
    }, await resp.json());
  }

  async describeJobRun(
    {abortSignal, ...params}: RequestConfig & DescribeJobRunRequest,
  ): Promise<DescribeJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJobRun",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRun/${params["RunId"]}`,
    });
    return jsonP.readObj({
      required: {
        "JobName": "s",
      },
      optional: {
        "Attempt": "n",
        "CompletedOn": "d",
        "DatasetName": "s",
        "ErrorMessage": "s",
        "ExecutionTime": "n",
        "RunId": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<JobRunState>(x),
        "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<LogSubscription>(x),
        "LogGroupName": "s",
        "Outputs": [toOutput],
        "RecipeReference": toRecipeReference,
        "StartedBy": "s",
        "StartedOn": "d",
      },
    }, await resp.json());
  }

  async describeProject(
    {abortSignal, ...params}: RequestConfig & DescribeProjectRequest,
  ): Promise<DescribeProjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProject",
      method: "GET",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "DatasetName": "s",
        "LastModifiedDate": "d",
        "LastModifiedBy": "s",
        "RecipeName": "s",
        "ResourceArn": "s",
        "Sample": toSample,
        "RoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "SessionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SessionStatus>(x),
        "OpenedBy": "s",
        "OpenDate": "d",
      },
    }, await resp.json());
  }

  async describeRecipe(
    {abortSignal, ...params}: RequestConfig & DescribeRecipeRequest,
  ): Promise<DescribeRecipeResponse> {
    const query = new URLSearchParams;
    if (params["RecipeVersion"] != null) query.set("recipeVersion", params["RecipeVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRecipe",
      method: "GET",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreatedBy": "s",
        "CreateDate": "d",
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "ProjectName": "s",
        "PublishedBy": "s",
        "PublishedDate": "d",
        "Description": "s",
        "Steps": [toRecipeStep],
        "Tags": x => jsonP.readMap(String, String, x),
        "ResourceArn": "s",
        "RecipeVersion": "s",
      },
    }, await resp.json());
  }

  async describeSchedule(
    {abortSignal, ...params}: RequestConfig & DescribeScheduleRequest,
  ): Promise<DescribeScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSchedule",
      method: "GET",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "JobNames": ["s"],
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "ResourceArn": "s",
        "CronExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & ListDatasetsRequest = {},
  ): Promise<ListDatasetsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasets",
      method: "GET",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {
        "Datasets": [toDataset],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobRuns(
    {abortSignal, ...params}: RequestConfig & ListJobRunsRequest,
  ): Promise<ListJobRunsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobRuns",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRuns`,
    });
    return jsonP.readObj({
      required: {
        "JobRuns": [toJobRun],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsRequest = {},
  ): Promise<ListJobsResponse> {
    const query = new URLSearchParams;
    if (params["DatasetName"] != null) query.set("datasetName", params["DatasetName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["ProjectName"] != null) query.set("projectName", params["ProjectName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/jobs",
    });
    return jsonP.readObj({
      required: {
        "Jobs": [toJob],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & ListProjectsRequest = {},
  ): Promise<ListProjectsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProjects",
      method: "GET",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {
        "Projects": [toProject],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipeVersions(
    {abortSignal, ...params}: RequestConfig & ListRecipeVersionsRequest,
  ): Promise<ListRecipeVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    query.set("name", params["Name"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRecipeVersions",
      method: "GET",
      requestUri: "/recipeVersions",
    });
    return jsonP.readObj({
      required: {
        "Recipes": [toRecipe],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipes(
    {abortSignal, ...params}: RequestConfig & ListRecipesRequest = {},
  ): Promise<ListRecipesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["RecipeVersion"] != null) query.set("recipeVersion", params["RecipeVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRecipes",
      method: "GET",
      requestUri: "/recipes",
    });
    return jsonP.readObj({
      required: {
        "Recipes": [toRecipe],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchedules(
    {abortSignal, ...params}: RequestConfig & ListSchedulesRequest = {},
  ): Promise<ListSchedulesResponse> {
    const query = new URLSearchParams;
    if (params["JobName"] != null) query.set("jobName", params["JobName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSchedules",
      method: "GET",
      requestUri: "/schedules",
    });
    return jsonP.readObj({
      required: {
        "Schedules": [toSchedule],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async publishRecipe(
    {abortSignal, ...params}: RequestConfig & PublishRecipeRequest,
  ): Promise<PublishRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PublishRecipe",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/publishRecipe`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async sendProjectSessionAction(
    {abortSignal, ...params}: RequestConfig & SendProjectSessionActionRequest,
  ): Promise<SendProjectSessionActionResponse> {
    const body: jsonP.JSONObject = {
      Preview: params["Preview"],
      RecipeStep: fromRecipeStep(params["RecipeStep"]),
      StepIndex: params["StepIndex"],
      ClientSessionId: params["ClientSessionId"],
      ViewFrame: fromViewFrame(params["ViewFrame"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendProjectSessionAction",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}/sendProjectSessionAction`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "Result": "s",
        "ActionId": "n",
      },
    }, await resp.json());
  }

  async startJobRun(
    {abortSignal, ...params}: RequestConfig & StartJobRunRequest,
  ): Promise<StartJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartJobRun",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/startJobRun`,
    });
    return jsonP.readObj({
      required: {
        "RunId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async startProjectSession(
    {abortSignal, ...params}: RequestConfig & StartProjectSessionRequest,
  ): Promise<StartProjectSessionResponse> {
    const body: jsonP.JSONObject = {
      AssumeControl: params["AssumeControl"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartProjectSession",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}/startProjectSession`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "ClientSessionId": "s",
      },
    }, await resp.json());
  }

  async stopJobRun(
    {abortSignal, ...params}: RequestConfig & StopJobRunRequest,
  ): Promise<StopJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopJobRun",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRun/${params["RunId"]}/stopJobRun`,
    });
    return jsonP.readObj({
      required: {
        "RunId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDataset(
    {abortSignal, ...params}: RequestConfig & UpdateDatasetRequest,
  ): Promise<UpdateDatasetResponse> {
    const body: jsonP.JSONObject = {
      FormatOptions: fromFormatOptions(params["FormatOptions"]),
      Input: fromInput(params["Input"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataset",
      method: "PUT",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateProfileJob(
    {abortSignal, ...params}: RequestConfig & UpdateProfileJobRequest,
  ): Promise<UpdateProfileJobResponse> {
    const body: jsonP.JSONObject = {
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      OutputLocation: fromS3Location(params["OutputLocation"]),
      RoleArn: params["RoleArn"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProfileJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/profileJobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateProject(
    {abortSignal, ...params}: RequestConfig & UpdateProjectRequest,
  ): Promise<UpdateProjectResponse> {
    const body: jsonP.JSONObject = {
      Sample: fromSample(params["Sample"]),
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProject",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "LastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async updateRecipe(
    {abortSignal, ...params}: RequestConfig & UpdateRecipeRequest,
  ): Promise<UpdateRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Steps: params["Steps"]?.map(x => fromRecipeStep(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRecipe",
      method: "PUT",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateRecipeJob(
    {abortSignal, ...params}: RequestConfig & UpdateRecipeJobRequest,
  ): Promise<UpdateRecipeJobResponse> {
    const body: jsonP.JSONObject = {
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      Outputs: params["Outputs"]?.map(x => fromOutput(x)),
      RoleArn: params["RoleArn"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRecipeJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/recipeJobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateSchedule(
    {abortSignal, ...params}: RequestConfig & UpdateScheduleRequest,
  ): Promise<UpdateScheduleResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
      CronExpression: params["CronExpression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSchedule",
      method: "PUT",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchDeleteRecipeVersionRequest {
  Name: string;
  RecipeVersions: string[];
}

// refs: 1 - tags: named, input
export interface CreateDatasetRequest {
  Name: string;
  FormatOptions?: FormatOptions | null;
  Input: Input;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateProfileJobRequest {
  DatasetName: string;
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  OutputLocation: S3Location;
  RoleArn: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  Timeout?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateProjectRequest {
  DatasetName: string;
  Name: string;
  RecipeName: string;
  Sample?: Sample | null;
  RoleArn: string;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateRecipeRequest {
  Description?: string | null;
  Name: string;
  Steps: RecipeStep[];
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateRecipeJobRequest {
  DatasetName?: string | null;
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  Outputs: Output[];
  ProjectName?: string | null;
  RecipeReference?: RecipeReference | null;
  RoleArn: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  Timeout?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateScheduleRequest {
  JobNames?: string[] | null;
  CronExpression: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteJobRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteProjectRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteRecipeVersionRequest {
  Name: string;
  RecipeVersion: string;
}

// refs: 1 - tags: named, input
export interface DeleteScheduleRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobRunRequest {
  Name: string;
  RunId: string;
}

// refs: 1 - tags: named, input
export interface DescribeProjectRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeRecipeRequest {
  Name: string;
  RecipeVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeScheduleRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface ListDatasetsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListJobRunsRequest {
  Name: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListJobsRequest {
  DatasetName?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  ProjectName?: string | null;
}

// refs: 1 - tags: named, input
export interface ListProjectsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRecipeVersionsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  Name: string;
}

// refs: 1 - tags: named, input
export interface ListRecipesRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  RecipeVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSchedulesRequest {
  JobName?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface PublishRecipeRequest {
  Description?: string | null;
  Name: string;
}

// refs: 1 - tags: named, input
export interface SendProjectSessionActionRequest {
  Preview?: boolean | null;
  Name: string;
  RecipeStep?: RecipeStep | null;
  StepIndex?: number | null;
  ClientSessionId?: string | null;
  ViewFrame?: ViewFrame | null;
}

// refs: 1 - tags: named, input
export interface StartJobRunRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StartProjectSessionRequest {
  Name: string;
  AssumeControl?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StopJobRunRequest {
  Name: string;
  RunId: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDatasetRequest {
  Name: string;
  FormatOptions?: FormatOptions | null;
  Input: Input;
}

// refs: 1 - tags: named, input
export interface UpdateProfileJobRequest {
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  OutputLocation: S3Location;
  RoleArn: string;
  Timeout?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateProjectRequest {
  Sample?: Sample | null;
  RoleArn: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface UpdateRecipeRequest {
  Description?: string | null;
  Name: string;
  Steps?: RecipeStep[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateRecipeJobRequest {
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  Outputs: Output[];
  RoleArn: string;
  Timeout?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateScheduleRequest {
  JobNames?: string[] | null;
  CronExpression: string;
  Name: string;
}

// refs: 1 - tags: named, output
export interface BatchDeleteRecipeVersionResponse {
  Name: string;
  Errors?: RecipeVersionErrorDetail[] | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface CreateProfileJobResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface CreateProjectResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface CreateRecipeResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface CreateRecipeJobResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface CreateScheduleResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface DeleteDatasetResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface DeleteJobResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface DeleteProjectResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface DeleteRecipeVersionResponse {
  Name: string;
  RecipeVersion: string;
}

// refs: 1 - tags: named, output
export interface DeleteScheduleResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetResponse {
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  Name: string;
  FormatOptions?: FormatOptions | null;
  Input: Input;
  LastModifiedDate?: Date | number | null;
  LastModifiedBy?: string | null;
  Source?: Source | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  ResourceArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobResponse {
  CreateDate?: Date | number | null;
  CreatedBy?: string | null;
  DatasetName?: string | null;
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  Type?: JobType | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  Outputs?: Output[] | null;
  ProjectName?: string | null;
  RecipeReference?: RecipeReference | null;
  ResourceArn?: string | null;
  RoleArn?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Timeout?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobRunResponse {
  Attempt?: number | null;
  CompletedOn?: Date | number | null;
  DatasetName?: string | null;
  ErrorMessage?: string | null;
  ExecutionTime?: number | null;
  JobName: string;
  RunId?: string | null;
  State?: JobRunState | null;
  LogSubscription?: LogSubscription | null;
  LogGroupName?: string | null;
  Outputs?: Output[] | null;
  RecipeReference?: RecipeReference | null;
  StartedBy?: string | null;
  StartedOn?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeProjectResponse {
  CreateDate?: Date | number | null;
  CreatedBy?: string | null;
  DatasetName?: string | null;
  LastModifiedDate?: Date | number | null;
  LastModifiedBy?: string | null;
  Name: string;
  RecipeName?: string | null;
  ResourceArn?: string | null;
  Sample?: Sample | null;
  RoleArn?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  SessionStatus?: SessionStatus | null;
  OpenedBy?: string | null;
  OpenDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeRecipeResponse {
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  ProjectName?: string | null;
  PublishedBy?: string | null;
  PublishedDate?: Date | number | null;
  Description?: string | null;
  Name: string;
  Steps?: RecipeStep[] | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  ResourceArn?: string | null;
  RecipeVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeScheduleResponse {
  CreateDate?: Date | number | null;
  CreatedBy?: string | null;
  JobNames?: string[] | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  ResourceArn?: string | null;
  CronExpression?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Name: string;
}

// refs: 1 - tags: named, output
export interface ListDatasetsResponse {
  Datasets: Dataset[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobRunsResponse {
  JobRuns: JobRun[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsResponse {
  Jobs: Job[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListProjectsResponse {
  Projects: Project[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRecipeVersionsResponse {
  NextToken?: string | null;
  Recipes: Recipe[];
}

// refs: 1 - tags: named, output
export interface ListRecipesResponse {
  Recipes: Recipe[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSchedulesResponse {
  Schedules: Schedule[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface PublishRecipeResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface SendProjectSessionActionResponse {
  Result?: string | null;
  Name: string;
  ActionId?: number | null;
}

// refs: 1 - tags: named, output
export interface StartJobRunResponse {
  RunId: string;
}

// refs: 1 - tags: named, output
export interface StartProjectSessionResponse {
  Name: string;
  ClientSessionId?: string | null;
}

// refs: 1 - tags: named, output
export interface StopJobRunResponse {
  RunId: string;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDatasetResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface UpdateProfileJobResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface UpdateProjectResponse {
  LastModifiedDate?: Date | number | null;
  Name: string;
}

// refs: 1 - tags: named, output
export interface UpdateRecipeResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface UpdateRecipeJobResponse {
  Name: string;
}

// refs: 1 - tags: named, output
export interface UpdateScheduleResponse {
  Name: string;
}

// refs: 4 - tags: input, named, interface, output
export interface FormatOptions {
  Json?: JsonOptions | null;
  Excel?: ExcelOptions | null;
  Csv?: CsvOptions | null;
}
function fromFormatOptions(input?: FormatOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Json: fromJsonOptions(input["Json"]),
    Excel: fromExcelOptions(input["Excel"]),
    Csv: fromCsvOptions(input["Csv"]),
  }
}
function toFormatOptions(root: jsonP.JSONValue): FormatOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Json": toJsonOptions,
      "Excel": toExcelOptions,
      "Csv": toCsvOptions,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface JsonOptions {
  MultiLine?: boolean | null;
}
function fromJsonOptions(input?: JsonOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MultiLine: input["MultiLine"],
  }
}
function toJsonOptions(root: jsonP.JSONValue): JsonOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultiLine": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ExcelOptions {
  SheetNames?: string[] | null;
  SheetIndexes?: number[] | null;
}
function fromExcelOptions(input?: ExcelOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SheetNames: input["SheetNames"],
    SheetIndexes: input["SheetIndexes"],
  }
}
function toExcelOptions(root: jsonP.JSONValue): ExcelOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "SheetNames": ["s"],
      "SheetIndexes": ["n"],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface CsvOptions {
  Delimiter?: string | null;
}
function fromCsvOptions(input?: CsvOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Delimiter: input["Delimiter"],
  }
}
function toCsvOptions(root: jsonP.JSONValue): CsvOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Delimiter": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Input {
  S3InputDefinition?: S3Location | null;
  DataCatalogInputDefinition?: DataCatalogInputDefinition | null;
}
function fromInput(input?: Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3InputDefinition: fromS3Location(input["S3InputDefinition"]),
    DataCatalogInputDefinition: fromDataCatalogInputDefinition(input["DataCatalogInputDefinition"]),
  }
}
function toInput(root: jsonP.JSONValue): Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3InputDefinition": toS3Location,
      "DataCatalogInputDefinition": toDataCatalogInputDefinition,
    },
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface S3Location {
  Bucket: string;
  Key?: string | null;
}
function fromS3Location(input?: S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
  }
}
function toS3Location(root: jsonP.JSONValue): S3Location {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
    },
    optional: {
      "Key": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DataCatalogInputDefinition {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  TempDirectory?: S3Location | null;
}
function fromDataCatalogInputDefinition(input?: DataCatalogInputDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    TempDirectory: fromS3Location(input["TempDirectory"]),
  }
}
function toDataCatalogInputDefinition(root: jsonP.JSONValue): DataCatalogInputDefinition {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "TableName": "s",
    },
    optional: {
      "CatalogId": "s",
      "TempDirectory": toS3Location,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type EncryptionMode =
| "SSE-KMS"
| "SSE-S3"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, enum, output
export type LogSubscription =
| "ENABLE"
| "DISABLE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Sample {
  Size?: number | null;
  Type: SampleType;
}
function fromSample(input?: Sample | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Size: input["Size"],
    Type: input["Type"],
  }
}
function toSample(root: jsonP.JSONValue): Sample {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<SampleType>(x),
    },
    optional: {
      "Size": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type SampleType =
| "FIRST_N"
| "LAST_N"
| "RANDOM"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface RecipeStep {
  Action: RecipeAction;
  ConditionExpressions?: ConditionExpression[] | null;
}
function fromRecipeStep(input?: RecipeStep | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: fromRecipeAction(input["Action"]),
    ConditionExpressions: input["ConditionExpressions"]?.map(x => fromConditionExpression(x)),
  }
}
function toRecipeStep(root: jsonP.JSONValue): RecipeStep {
  return jsonP.readObj({
    required: {
      "Action": toRecipeAction,
    },
    optional: {
      "ConditionExpressions": [toConditionExpression],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface RecipeAction {
  Operation: string;
  Parameters?: { [key: string]: string | null | undefined } | null;
}
function fromRecipeAction(input?: RecipeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Operation: input["Operation"],
    Parameters: input["Parameters"],
  }
}
function toRecipeAction(root: jsonP.JSONValue): RecipeAction {
  return jsonP.readObj({
    required: {
      "Operation": "s",
    },
    optional: {
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ConditionExpression {
  Condition: string;
  Value?: string | null;
  TargetColumn: string;
}
function fromConditionExpression(input?: ConditionExpression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Condition: input["Condition"],
    Value: input["Value"],
    TargetColumn: input["TargetColumn"],
  }
}
function toConditionExpression(root: jsonP.JSONValue): ConditionExpression {
  return jsonP.readObj({
    required: {
      "Condition": "s",
      "TargetColumn": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Output {
  CompressionFormat?: CompressionFormat | null;
  Format?: OutputFormat | null;
  PartitionColumns?: string[] | null;
  Location: S3Location;
  Overwrite?: boolean | null;
  FormatOptions?: OutputFormatOptions | null;
}
function fromOutput(input?: Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CompressionFormat: input["CompressionFormat"],
    Format: input["Format"],
    PartitionColumns: input["PartitionColumns"],
    Location: fromS3Location(input["Location"]),
    Overwrite: input["Overwrite"],
    FormatOptions: fromOutputFormatOptions(input["FormatOptions"]),
  }
}
function toOutput(root: jsonP.JSONValue): Output {
  return jsonP.readObj({
    required: {
      "Location": toS3Location,
    },
    optional: {
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionFormat>(x),
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<OutputFormat>(x),
      "PartitionColumns": ["s"],
      "Overwrite": "b",
      "FormatOptions": toOutputFormatOptions,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type CompressionFormat =
| "GZIP"
| "LZ4"
| "SNAPPY"
| "BZIP2"
| "DEFLATE"
| "LZO"
| "BROTLI"
| "ZSTD"
| "ZLIB"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type OutputFormat =
| "CSV"
| "JSON"
| "PARQUET"
| "GLUEPARQUET"
| "AVRO"
| "ORC"
| "XML"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface OutputFormatOptions {
  Csv?: CsvOutputOptions | null;
}
function fromOutputFormatOptions(input?: OutputFormatOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Csv: fromCsvOutputOptions(input["Csv"]),
  }
}
function toOutputFormatOptions(root: jsonP.JSONValue): OutputFormatOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Csv": toCsvOutputOptions,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface CsvOutputOptions {
  Delimiter?: string | null;
}
function fromCsvOutputOptions(input?: CsvOutputOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Delimiter: input["Delimiter"],
  }
}
function toCsvOutputOptions(root: jsonP.JSONValue): CsvOutputOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Delimiter": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface RecipeReference {
  Name: string;
  RecipeVersion?: string | null;
}
function fromRecipeReference(input?: RecipeReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    RecipeVersion: input["RecipeVersion"],
  }
}
function toRecipeReference(root: jsonP.JSONValue): RecipeReference {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "RecipeVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ViewFrame {
  StartColumnIndex: number;
  ColumnRange?: number | null;
  HiddenColumns?: string[] | null;
}
function fromViewFrame(input?: ViewFrame | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartColumnIndex: input["StartColumnIndex"],
    ColumnRange: input["ColumnRange"],
    HiddenColumns: input["HiddenColumns"],
  }
}

// refs: 1 - tags: output, named, interface
export interface RecipeVersionErrorDetail {
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
  RecipeVersion?: string | null;
}
function toRecipeVersionErrorDetail(root: jsonP.JSONValue): RecipeVersionErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
      "RecipeVersion": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type Source =
| "S3"
| "DATA-CATALOG"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type JobType =
| "PROFILE"
| "RECIPE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type JobRunState =
| "STARTING"
| "RUNNING"
| "STOPPING"
| "STOPPED"
| "SUCCEEDED"
| "FAILED"
| "TIMEOUT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type SessionStatus =
| "ASSIGNED"
| "FAILED"
| "INITIALIZING"
| "PROVISIONING"
| "READY"
| "RECYCLING"
| "ROTATING"
| "TERMINATED"
| "TERMINATING"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Dataset {
  AccountId?: string | null;
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  Name: string;
  FormatOptions?: FormatOptions | null;
  Input: Input;
  LastModifiedDate?: Date | number | null;
  LastModifiedBy?: string | null;
  Source?: Source | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  ResourceArn?: string | null;
}
function toDataset(root: jsonP.JSONValue): Dataset {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Input": toInput,
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "FormatOptions": toFormatOptions,
      "LastModifiedDate": "d",
      "LastModifiedBy": "s",
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<Source>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "ResourceArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobRun {
  Attempt?: number | null;
  CompletedOn?: Date | number | null;
  DatasetName?: string | null;
  ErrorMessage?: string | null;
  ExecutionTime?: number | null;
  JobName?: string | null;
  RunId?: string | null;
  State?: JobRunState | null;
  LogSubscription?: LogSubscription | null;
  LogGroupName?: string | null;
  Outputs?: Output[] | null;
  RecipeReference?: RecipeReference | null;
  StartedBy?: string | null;
  StartedOn?: Date | number | null;
}
function toJobRun(root: jsonP.JSONValue): JobRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attempt": "n",
      "CompletedOn": "d",
      "DatasetName": "s",
      "ErrorMessage": "s",
      "ExecutionTime": "n",
      "JobName": "s",
      "RunId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<JobRunState>(x),
      "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<LogSubscription>(x),
      "LogGroupName": "s",
      "Outputs": [toOutput],
      "RecipeReference": toRecipeReference,
      "StartedBy": "s",
      "StartedOn": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Job {
  AccountId?: string | null;
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  DatasetName?: string | null;
  EncryptionKeyArn?: string | null;
  EncryptionMode?: EncryptionMode | null;
  Name: string;
  Type?: JobType | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  LogSubscription?: LogSubscription | null;
  MaxCapacity?: number | null;
  MaxRetries?: number | null;
  Outputs?: Output[] | null;
  ProjectName?: string | null;
  RecipeReference?: RecipeReference | null;
  ResourceArn?: string | null;
  RoleArn?: string | null;
  Timeout?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toJob(root: jsonP.JSONValue): Job {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "DatasetName": "s",
      "EncryptionKeyArn": "s",
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionMode>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<JobType>(x),
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<LogSubscription>(x),
      "MaxCapacity": "n",
      "MaxRetries": "n",
      "Outputs": [toOutput],
      "ProjectName": "s",
      "RecipeReference": toRecipeReference,
      "ResourceArn": "s",
      "RoleArn": "s",
      "Timeout": "n",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Project {
  AccountId?: string | null;
  CreateDate?: Date | number | null;
  CreatedBy?: string | null;
  DatasetName?: string | null;
  LastModifiedDate?: Date | number | null;
  LastModifiedBy?: string | null;
  Name: string;
  RecipeName: string;
  ResourceArn?: string | null;
  Sample?: Sample | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  RoleArn?: string | null;
  OpenedBy?: string | null;
  OpenDate?: Date | number | null;
}
function toProject(root: jsonP.JSONValue): Project {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "RecipeName": "s",
    },
    optional: {
      "AccountId": "s",
      "CreateDate": "d",
      "CreatedBy": "s",
      "DatasetName": "s",
      "LastModifiedDate": "d",
      "LastModifiedBy": "s",
      "ResourceArn": "s",
      "Sample": toSample,
      "Tags": x => jsonP.readMap(String, String, x),
      "RoleArn": "s",
      "OpenedBy": "s",
      "OpenDate": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Recipe {
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  ProjectName?: string | null;
  PublishedBy?: string | null;
  PublishedDate?: Date | number | null;
  Description?: string | null;
  Name: string;
  ResourceArn?: string | null;
  Steps?: RecipeStep[] | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  RecipeVersion?: string | null;
}
function toRecipe(root: jsonP.JSONValue): Recipe {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CreatedBy": "s",
      "CreateDate": "d",
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "ProjectName": "s",
      "PublishedBy": "s",
      "PublishedDate": "d",
      "Description": "s",
      "ResourceArn": "s",
      "Steps": [toRecipeStep],
      "Tags": x => jsonP.readMap(String, String, x),
      "RecipeVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Schedule {
  AccountId?: string | null;
  CreatedBy?: string | null;
  CreateDate?: Date | number | null;
  JobNames?: string[] | null;
  LastModifiedBy?: string | null;
  LastModifiedDate?: Date | number | null;
  ResourceArn?: string | null;
  CronExpression?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Name: string;
}
function toSchedule(root: jsonP.JSONValue): Schedule {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "JobNames": ["s"],
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "ResourceArn": "s",
      "CronExpression": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
