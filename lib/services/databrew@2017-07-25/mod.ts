// Autogenerated API client for: AWS Glue DataBrew

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class DataBrew {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DataBrew.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-07-25",
    "endpointPrefix": "databrew",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS Glue DataBrew",
    "serviceId": "DataBrew",
    "signatureVersion": "v4",
    "signingName": "databrew",
    "uid": "databrew-2017-07-25"
  };

  async batchDeleteRecipeVersion(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteRecipeVersionRequest,
  ): Promise<s.BatchDeleteRecipeVersionResponse> {
    const body: jsonP.JSONObject = {
      RecipeVersions: params["RecipeVersions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteRecipeVersion",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/batchDeleteRecipeVersion`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "Errors": [toRecipeVersionErrorDetail],
      },
    }, await resp.json());
  }

  async createDataset(
    {abortSignal, ...params}: RequestConfig & s.CreateDatasetRequest,
  ): Promise<s.CreateDatasetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FormatOptions: fromFormatOptions(params["FormatOptions"]),
      Input: fromInput(params["Input"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createProfileJob(
    {abortSignal, ...params}: RequestConfig & s.CreateProfileJobRequest,
  ): Promise<s.CreateProfileJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      Name: params["Name"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      OutputLocation: fromS3Location(params["OutputLocation"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProfileJob",
      requestUri: "/profileJobs",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectRequest,
  ): Promise<s.CreateProjectResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      Name: params["Name"],
      RecipeName: params["RecipeName"],
      Sample: fromSample(params["Sample"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createRecipe(
    {abortSignal, ...params}: RequestConfig & s.CreateRecipeRequest,
  ): Promise<s.CreateRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Name: params["Name"],
      Steps: params["Steps"]?.map(x => fromRecipeStep(x)),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRecipe",
      requestUri: "/recipes",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createRecipeJob(
    {abortSignal, ...params}: RequestConfig & s.CreateRecipeJobRequest,
  ): Promise<s.CreateRecipeJobResponse> {
    const body: jsonP.JSONObject = {
      DatasetName: params["DatasetName"],
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      Name: params["Name"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      Outputs: params["Outputs"]?.map(x => fromOutput(x)),
      ProjectName: params["ProjectName"],
      RecipeReference: fromRecipeReference(params["RecipeReference"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRecipeJob",
      requestUri: "/recipeJobs",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createSchedule(
    {abortSignal, ...params}: RequestConfig & s.CreateScheduleRequest,
  ): Promise<s.CreateScheduleResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
      CronExpression: params["CronExpression"],
      Tags: params["Tags"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchedule",
      requestUri: "/schedules",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatasetRequest,
  ): Promise<s.DeleteDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteDataset",
      method: "DELETE",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteJob(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobRequest,
  ): Promise<s.DeleteJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteJob",
      method: "DELETE",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectRequest,
  ): Promise<s.DeleteProjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteRecipeVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteRecipeVersionRequest,
  ): Promise<s.DeleteRecipeVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRecipeVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/recipeVersion/${params["RecipeVersion"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "RecipeVersion": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteSchedule(
    {abortSignal, ...params}: RequestConfig & s.DeleteScheduleRequest,
  ): Promise<s.DeleteScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSchedule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & s.DescribeDatasetRequest,
  ): Promise<s.DescribeDatasetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeDataset",
      method: "GET",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "Input": toInput,
      },
      optional: {
        "CreatedBy": "s",
        "CreateDate": "d",
        "FormatOptions": toFormatOptions,
        "LastModifiedDate": "d",
        "LastModifiedBy": "s",
        "Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.Source>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "ResourceArn": "s",
      },
    }, await resp.json());
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobRequest,
  ): Promise<s.DescribeJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "DatasetName": "s",
        "EncryptionKeyArn": "s",
        "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionMode>(x),
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobType>(x),
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogSubscription>(x),
        "MaxCapacity": "n",
        "MaxRetries": "n",
        "Outputs": [toOutput],
        "ProjectName": "s",
        "RecipeReference": toRecipeReference,
        "ResourceArn": "s",
        "RoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "Timeout": "n",
      },
    }, await resp.json());
  }

  async describeJobRun(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobRunRequest,
  ): Promise<s.DescribeJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJobRun",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRun/${params["RunId"]}`,
    });
    return jsonP.readObj({
      required: {
        "JobName": "s",
      },
      optional: {
        "Attempt": "n",
        "CompletedOn": "d",
        "DatasetName": "s",
        "ErrorMessage": "s",
        "ExecutionTime": "n",
        "RunId": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobRunState>(x),
        "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogSubscription>(x),
        "LogGroupName": "s",
        "Outputs": [toOutput],
        "RecipeReference": toRecipeReference,
        "StartedBy": "s",
        "StartedOn": "d",
      },
    }, await resp.json());
  }

  async describeProject(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectRequest,
  ): Promise<s.DescribeProjectResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProject",
      method: "GET",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "DatasetName": "s",
        "LastModifiedDate": "d",
        "LastModifiedBy": "s",
        "RecipeName": "s",
        "ResourceArn": "s",
        "Sample": toSample,
        "RoleArn": "s",
        "Tags": x => jsonP.readMap(String, String, x),
        "SessionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SessionStatus>(x),
        "OpenedBy": "s",
        "OpenDate": "d",
      },
    }, await resp.json());
  }

  async describeRecipe(
    {abortSignal, ...params}: RequestConfig & s.DescribeRecipeRequest,
  ): Promise<s.DescribeRecipeResponse> {
    const query = new URLSearchParams;
    if (params["RecipeVersion"] != null) query.set("recipeVersion", params["RecipeVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRecipe",
      method: "GET",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreatedBy": "s",
        "CreateDate": "d",
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "ProjectName": "s",
        "PublishedBy": "s",
        "PublishedDate": "d",
        "Description": "s",
        "Steps": [toRecipeStep],
        "Tags": x => jsonP.readMap(String, String, x),
        "ResourceArn": "s",
        "RecipeVersion": "s",
      },
    }, await resp.json());
  }

  async describeSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduleRequest,
  ): Promise<s.DescribeScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSchedule",
      method: "GET",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "CreateDate": "d",
        "CreatedBy": "s",
        "JobNames": ["s"],
        "LastModifiedBy": "s",
        "LastModifiedDate": "d",
        "ResourceArn": "s",
        "CronExpression": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & s.ListDatasetsRequest = {},
  ): Promise<s.ListDatasetsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDatasets",
      method: "GET",
      requestUri: "/datasets",
    });
    return jsonP.readObj({
      required: {
        "Datasets": [toDataset],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobRuns(
    {abortSignal, ...params}: RequestConfig & s.ListJobRunsRequest,
  ): Promise<s.ListJobRunsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobRuns",
      method: "GET",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRuns`,
    });
    return jsonP.readObj({
      required: {
        "JobRuns": [toJobRun],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & s.ListJobsRequest = {},
  ): Promise<s.ListJobsResponse> {
    const query = new URLSearchParams;
    if (params["DatasetName"] != null) query.set("datasetName", params["DatasetName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["ProjectName"] != null) query.set("projectName", params["ProjectName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/jobs",
    });
    return jsonP.readObj({
      required: {
        "Jobs": [toJob],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & s.ListProjectsRequest = {},
  ): Promise<s.ListProjectsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProjects",
      method: "GET",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {
        "Projects": [toProject],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipeVersions(
    {abortSignal, ...params}: RequestConfig & s.ListRecipeVersionsRequest,
  ): Promise<s.ListRecipeVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    query.set("name", params["Name"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRecipeVersions",
      method: "GET",
      requestUri: "/recipeVersions",
    });
    return jsonP.readObj({
      required: {
        "Recipes": [toRecipe],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRecipes(
    {abortSignal, ...params}: RequestConfig & s.ListRecipesRequest = {},
  ): Promise<s.ListRecipesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["RecipeVersion"] != null) query.set("recipeVersion", params["RecipeVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRecipes",
      method: "GET",
      requestUri: "/recipes",
    });
    return jsonP.readObj({
      required: {
        "Recipes": [toRecipe],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchedules(
    {abortSignal, ...params}: RequestConfig & s.ListSchedulesRequest = {},
  ): Promise<s.ListSchedulesResponse> {
    const query = new URLSearchParams;
    if (params["JobName"] != null) query.set("jobName", params["JobName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSchedules",
      method: "GET",
      requestUri: "/schedules",
    });
    return jsonP.readObj({
      required: {
        "Schedules": [toSchedule],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async publishRecipe(
    {abortSignal, ...params}: RequestConfig & s.PublishRecipeRequest,
  ): Promise<s.PublishRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PublishRecipe",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}/publishRecipe`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async sendProjectSessionAction(
    {abortSignal, ...params}: RequestConfig & s.SendProjectSessionActionRequest,
  ): Promise<s.SendProjectSessionActionResponse> {
    const body: jsonP.JSONObject = {
      Preview: params["Preview"],
      RecipeStep: fromRecipeStep(params["RecipeStep"]),
      StepIndex: params["StepIndex"],
      ClientSessionId: params["ClientSessionId"],
      ViewFrame: fromViewFrame(params["ViewFrame"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendProjectSessionAction",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}/sendProjectSessionAction`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "Result": "s",
        "ActionId": "n",
      },
    }, await resp.json());
  }

  async startJobRun(
    {abortSignal, ...params}: RequestConfig & s.StartJobRunRequest,
  ): Promise<s.StartJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartJobRun",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/startJobRun`,
    });
    return jsonP.readObj({
      required: {
        "RunId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async startProjectSession(
    {abortSignal, ...params}: RequestConfig & s.StartProjectSessionRequest,
  ): Promise<s.StartProjectSessionResponse> {
    const body: jsonP.JSONObject = {
      AssumeControl: params["AssumeControl"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartProjectSession",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}/startProjectSession`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "ClientSessionId": "s",
      },
    }, await resp.json());
  }

  async stopJobRun(
    {abortSignal, ...params}: RequestConfig & s.StopJobRunRequest,
  ): Promise<s.StopJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopJobRun",
      requestUri: cmnP.encodePath`/jobs/${params["Name"]}/jobRun/${params["RunId"]}/stopJobRun`,
    });
    return jsonP.readObj({
      required: {
        "RunId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDataset(
    {abortSignal, ...params}: RequestConfig & s.UpdateDatasetRequest,
  ): Promise<s.UpdateDatasetResponse> {
    const body: jsonP.JSONObject = {
      FormatOptions: fromFormatOptions(params["FormatOptions"]),
      Input: fromInput(params["Input"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDataset",
      method: "PUT",
      requestUri: cmnP.encodePath`/datasets/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateProfileJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateProfileJobRequest,
  ): Promise<s.UpdateProfileJobResponse> {
    const body: jsonP.JSONObject = {
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      OutputLocation: fromS3Location(params["OutputLocation"]),
      RoleArn: params["RoleArn"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProfileJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/profileJobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateProject(
    {abortSignal, ...params}: RequestConfig & s.UpdateProjectRequest,
  ): Promise<s.UpdateProjectResponse> {
    const body: jsonP.JSONObject = {
      Sample: fromSample(params["Sample"]),
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProject",
      method: "PUT",
      requestUri: cmnP.encodePath`/projects/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {
        "LastModifiedDate": "d",
      },
    }, await resp.json());
  }

  async updateRecipe(
    {abortSignal, ...params}: RequestConfig & s.UpdateRecipeRequest,
  ): Promise<s.UpdateRecipeResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Steps: params["Steps"]?.map(x => fromRecipeStep(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRecipe",
      method: "PUT",
      requestUri: cmnP.encodePath`/recipes/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateRecipeJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateRecipeJobRequest,
  ): Promise<s.UpdateRecipeJobResponse> {
    const body: jsonP.JSONObject = {
      EncryptionKeyArn: params["EncryptionKeyArn"],
      EncryptionMode: params["EncryptionMode"],
      LogSubscription: params["LogSubscription"],
      MaxCapacity: params["MaxCapacity"],
      MaxRetries: params["MaxRetries"],
      Outputs: params["Outputs"]?.map(x => fromOutput(x)),
      RoleArn: params["RoleArn"],
      Timeout: params["Timeout"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRecipeJob",
      method: "PUT",
      requestUri: cmnP.encodePath`/recipeJobs/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateSchedule(
    {abortSignal, ...params}: RequestConfig & s.UpdateScheduleRequest,
  ): Promise<s.UpdateScheduleResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
      CronExpression: params["CronExpression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSchedule",
      method: "PUT",
      requestUri: cmnP.encodePath`/schedules/${params["Name"]}`,
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
      },
      optional: {},
    }, await resp.json());
  }

}

function fromFormatOptions(input?: s.FormatOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Json: fromJsonOptions(input["Json"]),
    Excel: fromExcelOptions(input["Excel"]),
    Csv: fromCsvOptions(input["Csv"]),
  }
}
function toFormatOptions(root: jsonP.JSONValue): s.FormatOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Json": toJsonOptions,
      "Excel": toExcelOptions,
      "Csv": toCsvOptions,
    },
  }, root);
}

function fromJsonOptions(input?: s.JsonOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MultiLine: input["MultiLine"],
  }
}
function toJsonOptions(root: jsonP.JSONValue): s.JsonOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultiLine": "b",
    },
  }, root);
}

function fromExcelOptions(input?: s.ExcelOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SheetNames: input["SheetNames"],
    SheetIndexes: input["SheetIndexes"],
  }
}
function toExcelOptions(root: jsonP.JSONValue): s.ExcelOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "SheetNames": ["s"],
      "SheetIndexes": ["n"],
    },
  }, root);
}

function fromCsvOptions(input?: s.CsvOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Delimiter: input["Delimiter"],
  }
}
function toCsvOptions(root: jsonP.JSONValue): s.CsvOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Delimiter": "s",
    },
  }, root);
}

function fromInput(input?: s.Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3InputDefinition: fromS3Location(input["S3InputDefinition"]),
    DataCatalogInputDefinition: fromDataCatalogInputDefinition(input["DataCatalogInputDefinition"]),
  }
}
function toInput(root: jsonP.JSONValue): s.Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3InputDefinition": toS3Location,
      "DataCatalogInputDefinition": toDataCatalogInputDefinition,
    },
  }, root);
}

function fromS3Location(input?: s.S3Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Key: input["Key"],
  }
}
function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {
      "Bucket": "s",
    },
    optional: {
      "Key": "s",
    },
  }, root);
}

function fromDataCatalogInputDefinition(input?: s.DataCatalogInputDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    TempDirectory: fromS3Location(input["TempDirectory"]),
  }
}
function toDataCatalogInputDefinition(root: jsonP.JSONValue): s.DataCatalogInputDefinition {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "TableName": "s",
    },
    optional: {
      "CatalogId": "s",
      "TempDirectory": toS3Location,
    },
  }, root);
}

function fromSample(input?: s.Sample | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Size: input["Size"],
    Type: input["Type"],
  }
}
function toSample(root: jsonP.JSONValue): s.Sample {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SampleType>(x),
    },
    optional: {
      "Size": "n",
    },
  }, root);
}

function fromRecipeStep(input?: s.RecipeStep | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: fromRecipeAction(input["Action"]),
    ConditionExpressions: input["ConditionExpressions"]?.map(x => fromConditionExpression(x)),
  }
}
function toRecipeStep(root: jsonP.JSONValue): s.RecipeStep {
  return jsonP.readObj({
    required: {
      "Action": toRecipeAction,
    },
    optional: {
      "ConditionExpressions": [toConditionExpression],
    },
  }, root);
}

function fromRecipeAction(input?: s.RecipeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Operation: input["Operation"],
    Parameters: input["Parameters"],
  }
}
function toRecipeAction(root: jsonP.JSONValue): s.RecipeAction {
  return jsonP.readObj({
    required: {
      "Operation": "s",
    },
    optional: {
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromConditionExpression(input?: s.ConditionExpression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Condition: input["Condition"],
    Value: input["Value"],
    TargetColumn: input["TargetColumn"],
  }
}
function toConditionExpression(root: jsonP.JSONValue): s.ConditionExpression {
  return jsonP.readObj({
    required: {
      "Condition": "s",
      "TargetColumn": "s",
    },
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromOutput(input?: s.Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CompressionFormat: input["CompressionFormat"],
    Format: input["Format"],
    PartitionColumns: input["PartitionColumns"],
    Location: fromS3Location(input["Location"]),
    Overwrite: input["Overwrite"],
    FormatOptions: fromOutputFormatOptions(input["FormatOptions"]),
  }
}
function toOutput(root: jsonP.JSONValue): s.Output {
  return jsonP.readObj({
    required: {
      "Location": toS3Location,
    },
    optional: {
      "CompressionFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionFormat>(x),
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.OutputFormat>(x),
      "PartitionColumns": ["s"],
      "Overwrite": "b",
      "FormatOptions": toOutputFormatOptions,
    },
  }, root);
}

function fromOutputFormatOptions(input?: s.OutputFormatOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Csv: fromCsvOutputOptions(input["Csv"]),
  }
}
function toOutputFormatOptions(root: jsonP.JSONValue): s.OutputFormatOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Csv": toCsvOutputOptions,
    },
  }, root);
}

function fromCsvOutputOptions(input?: s.CsvOutputOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Delimiter: input["Delimiter"],
  }
}
function toCsvOutputOptions(root: jsonP.JSONValue): s.CsvOutputOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Delimiter": "s",
    },
  }, root);
}

function fromRecipeReference(input?: s.RecipeReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    RecipeVersion: input["RecipeVersion"],
  }
}
function toRecipeReference(root: jsonP.JSONValue): s.RecipeReference {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "RecipeVersion": "s",
    },
  }, root);
}

function fromViewFrame(input?: s.ViewFrame | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartColumnIndex: input["StartColumnIndex"],
    ColumnRange: input["ColumnRange"],
    HiddenColumns: input["HiddenColumns"],
  }
}

function toRecipeVersionErrorDetail(root: jsonP.JSONValue): s.RecipeVersionErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
      "RecipeVersion": "s",
    },
  }, root);
}

function toDataset(root: jsonP.JSONValue): s.Dataset {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Input": toInput,
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "FormatOptions": toFormatOptions,
      "LastModifiedDate": "d",
      "LastModifiedBy": "s",
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.Source>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "ResourceArn": "s",
    },
  }, root);
}

function toJobRun(root: jsonP.JSONValue): s.JobRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attempt": "n",
      "CompletedOn": "d",
      "DatasetName": "s",
      "ErrorMessage": "s",
      "ExecutionTime": "n",
      "JobName": "s",
      "RunId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobRunState>(x),
      "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogSubscription>(x),
      "LogGroupName": "s",
      "Outputs": [toOutput],
      "RecipeReference": toRecipeReference,
      "StartedBy": "s",
      "StartedOn": "d",
    },
  }, root);
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "DatasetName": "s",
      "EncryptionKeyArn": "s",
      "EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionMode>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobType>(x),
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "LogSubscription": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogSubscription>(x),
      "MaxCapacity": "n",
      "MaxRetries": "n",
      "Outputs": [toOutput],
      "ProjectName": "s",
      "RecipeReference": toRecipeReference,
      "ResourceArn": "s",
      "RoleArn": "s",
      "Timeout": "n",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toProject(root: jsonP.JSONValue): s.Project {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "RecipeName": "s",
    },
    optional: {
      "AccountId": "s",
      "CreateDate": "d",
      "CreatedBy": "s",
      "DatasetName": "s",
      "LastModifiedDate": "d",
      "LastModifiedBy": "s",
      "ResourceArn": "s",
      "Sample": toSample,
      "Tags": x => jsonP.readMap(String, String, x),
      "RoleArn": "s",
      "OpenedBy": "s",
      "OpenDate": "d",
    },
  }, root);
}

function toRecipe(root: jsonP.JSONValue): s.Recipe {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CreatedBy": "s",
      "CreateDate": "d",
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "ProjectName": "s",
      "PublishedBy": "s",
      "PublishedDate": "d",
      "Description": "s",
      "ResourceArn": "s",
      "Steps": [toRecipeStep],
      "Tags": x => jsonP.readMap(String, String, x),
      "RecipeVersion": "s",
    },
  }, root);
}

function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "AccountId": "s",
      "CreatedBy": "s",
      "CreateDate": "d",
      "JobNames": ["s"],
      "LastModifiedBy": "s",
      "LastModifiedDate": "d",
      "ResourceArn": "s",
      "CronExpression": "s",
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
