// Autogenerated API client for: Amazon EMR Containers

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.75.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class EMRcontainers {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EMRcontainers.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-10-01",
    "endpointPrefix": "emr-containers",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon EMR Containers",
    "serviceId": "EMR containers",
    "signatureVersion": "v4",
    "signingName": "emr-containers",
    "uid": "emr-containers-2020-10-01"
  };

  async cancelJobRun(
    {abortSignal, ...params}: RequestConfig & CancelJobRunRequest,
  ): Promise<CancelJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelJobRun",
      method: "DELETE",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/jobruns/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "virtualClusterId": "s",
      },
    }, await resp.json());
  }

  async createManagedEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateManagedEndpointRequest,
  ): Promise<CreateManagedEndpointResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      type: params["type"],
      releaseLabel: params["releaseLabel"],
      executionRoleArn: params["executionRoleArn"],
      certificateArn: params["certificateArn"],
      configurationOverrides: fromConfigurationOverrides(params["configurationOverrides"]),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateManagedEndpoint",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/endpoints`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "arn": "s",
        "virtualClusterId": "s",
      },
    }, await resp.json());
  }

  async createVirtualCluster(
    {abortSignal, ...params}: RequestConfig & CreateVirtualClusterRequest,
  ): Promise<CreateVirtualClusterResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      containerProvider: fromContainerProvider(params["containerProvider"]),
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVirtualCluster",
      requestUri: "/virtualclusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "arn": "s",
      },
    }, await resp.json());
  }

  async deleteManagedEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteManagedEndpointRequest,
  ): Promise<DeleteManagedEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteManagedEndpoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/endpoints/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "virtualClusterId": "s",
      },
    }, await resp.json());
  }

  async deleteVirtualCluster(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualClusterRequest,
  ): Promise<DeleteVirtualClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVirtualCluster",
      method: "DELETE",
      requestUri: cmnP.encodePath`/virtualclusters/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
      },
    }, await resp.json());
  }

  async describeJobRun(
    {abortSignal, ...params}: RequestConfig & DescribeJobRunRequest,
  ): Promise<DescribeJobRunResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeJobRun",
      method: "GET",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/jobruns/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobRun": toJobRun,
      },
    }, await resp.json());
  }

  async describeManagedEndpoint(
    {abortSignal, ...params}: RequestConfig & DescribeManagedEndpointRequest,
  ): Promise<DescribeManagedEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeManagedEndpoint",
      method: "GET",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/endpoints/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "endpoint": toEndpoint,
      },
    }, await resp.json());
  }

  async describeVirtualCluster(
    {abortSignal, ...params}: RequestConfig & DescribeVirtualClusterRequest,
  ): Promise<DescribeVirtualClusterResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeVirtualCluster",
      method: "GET",
      requestUri: cmnP.encodePath`/virtualclusters/${params["id"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualCluster": toVirtualCluster,
      },
    }, await resp.json());
  }

  async listJobRuns(
    {abortSignal, ...params}: RequestConfig & ListJobRunsRequest,
  ): Promise<ListJobRunsResponse> {
    const query = new URLSearchParams;
    if (params["createdBefore"] != null) query.set("createdBefore", cmnP.serializeDate_iso8601(params["createdBefore"]) ?? "");
    if (params["createdAfter"] != null) query.set("createdAfter", cmnP.serializeDate_iso8601(params["createdAfter"]) ?? "");
    if (params["name"] != null) query.set("name", params["name"]?.toString() ?? "");
    for (const item of params["states"] ?? []) {
      query.append("states", item?.toString() ?? "");
    }
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJobRuns",
      method: "GET",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/jobruns`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobRuns": [toJobRun],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listManagedEndpoints(
    {abortSignal, ...params}: RequestConfig & ListManagedEndpointsRequest,
  ): Promise<ListManagedEndpointsResponse> {
    const query = new URLSearchParams;
    if (params["createdBefore"] != null) query.set("createdBefore", cmnP.serializeDate_iso8601(params["createdBefore"]) ?? "");
    if (params["createdAfter"] != null) query.set("createdAfter", cmnP.serializeDate_iso8601(params["createdAfter"]) ?? "");
    for (const item of params["types"] ?? []) {
      query.append("types", item?.toString() ?? "");
    }
    for (const item of params["states"] ?? []) {
      query.append("states", item?.toString() ?? "");
    }
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListManagedEndpoints",
      method: "GET",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/endpoints`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "endpoints": [toEndpoint],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listVirtualClusters(
    {abortSignal, ...params}: RequestConfig & ListVirtualClustersRequest = {},
  ): Promise<ListVirtualClustersResponse> {
    const query = new URLSearchParams;
    if (params["containerProviderId"] != null) query.set("containerProviderId", params["containerProviderId"]?.toString() ?? "");
    if (params["containerProviderType"] != null) query.set("containerProviderType", params["containerProviderType"]?.toString() ?? "");
    if (params["createdAfter"] != null) query.set("createdAfter", cmnP.serializeDate_iso8601(params["createdAfter"]) ?? "");
    if (params["createdBefore"] != null) query.set("createdBefore", cmnP.serializeDate_iso8601(params["createdBefore"]) ?? "");
    for (const item of params["states"] ?? []) {
      query.append("states", item?.toString() ?? "");
    }
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualClusters",
      method: "GET",
      requestUri: "/virtualclusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualClusters": [toVirtualCluster],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async startJobRun(
    {abortSignal, ...params}: RequestConfig & StartJobRunRequest,
  ): Promise<StartJobRunResponse> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      executionRoleArn: params["executionRoleArn"],
      releaseLabel: params["releaseLabel"],
      jobDriver: fromJobDriver(params["jobDriver"]),
      configurationOverrides: fromConfigurationOverrides(params["configurationOverrides"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartJobRun",
      requestUri: cmnP.encodePath`/virtualclusters/${params["virtualClusterId"]}/jobruns`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "id": "s",
        "name": "s",
        "arn": "s",
        "virtualClusterId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CancelJobRunRequest {
  id: string;
  virtualClusterId: string;
}

// refs: 1 - tags: named, input
export interface CreateManagedEndpointRequest {
  name: string;
  virtualClusterId: string;
  type: string;
  releaseLabel: string;
  executionRoleArn: string;
  certificateArn: string;
  configurationOverrides?: ConfigurationOverrides | null;
  clientToken: string;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateVirtualClusterRequest {
  name: string;
  containerProvider: ContainerProvider;
  clientToken: string;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteManagedEndpointRequest {
  id: string;
  virtualClusterId: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualClusterRequest {
  id: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobRunRequest {
  id: string;
  virtualClusterId: string;
}

// refs: 1 - tags: named, input
export interface DescribeManagedEndpointRequest {
  id: string;
  virtualClusterId: string;
}

// refs: 1 - tags: named, input
export interface DescribeVirtualClusterRequest {
  id: string;
}

// refs: 1 - tags: named, input
export interface ListJobRunsRequest {
  virtualClusterId: string;
  createdBefore?: Date | number | null;
  createdAfter?: Date | number | null;
  name?: string | null;
  states?: JobRunState[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListManagedEndpointsRequest {
  virtualClusterId: string;
  createdBefore?: Date | number | null;
  createdAfter?: Date | number | null;
  types?: string[] | null;
  states?: EndpointState[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListVirtualClustersRequest {
  containerProviderId?: string | null;
  containerProviderType?: ContainerProviderType | null;
  createdAfter?: Date | number | null;
  createdBefore?: Date | number | null;
  states?: VirtualClusterState[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface StartJobRunRequest {
  name?: string | null;
  virtualClusterId: string;
  clientToken: string;
  executionRoleArn: string;
  releaseLabel: string;
  jobDriver: JobDriver;
  configurationOverrides?: ConfigurationOverrides | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface CancelJobRunResponse {
  id?: string | null;
  virtualClusterId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateManagedEndpointResponse {
  id?: string | null;
  name?: string | null;
  arn?: string | null;
  virtualClusterId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateVirtualClusterResponse {
  id?: string | null;
  name?: string | null;
  arn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteManagedEndpointResponse {
  id?: string | null;
  virtualClusterId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteVirtualClusterResponse {
  id?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobRunResponse {
  jobRun?: JobRun | null;
}

// refs: 1 - tags: named, output
export interface DescribeManagedEndpointResponse {
  endpoint?: Endpoint | null;
}

// refs: 1 - tags: named, output
export interface DescribeVirtualClusterResponse {
  virtualCluster?: VirtualCluster | null;
}

// refs: 1 - tags: named, output
export interface ListJobRunsResponse {
  jobRuns?: JobRun[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListManagedEndpointsResponse {
  endpoints?: Endpoint[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListVirtualClustersResponse {
  virtualClusters?: VirtualCluster[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface StartJobRunResponse {
  id?: string | null;
  name?: string | null;
  arn?: string | null;
  virtualClusterId?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 6 - tags: input, named, interface, output
export interface ConfigurationOverrides {
  applicationConfiguration?: Configuration[] | null;
  monitoringConfiguration?: MonitoringConfiguration | null;
}
function fromConfigurationOverrides(input?: ConfigurationOverrides | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    applicationConfiguration: input["applicationConfiguration"]?.map(x => fromConfiguration(x)),
    monitoringConfiguration: fromMonitoringConfiguration(input["monitoringConfiguration"]),
  }
}
function toConfigurationOverrides(root: jsonP.JSONValue): ConfigurationOverrides {
  return jsonP.readObj({
    required: {},
    optional: {
      "applicationConfiguration": [toConfiguration],
      "monitoringConfiguration": toMonitoringConfiguration,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, recursive, output
export interface Configuration {
  classification: string;
  properties?: { [key: string]: string | null | undefined } | null;
  configurations?: Configuration[] | null;
}
function fromConfiguration(input?: Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    classification: input["classification"],
    properties: input["properties"],
    configurations: input["configurations"]?.map(x => fromConfiguration(x)),
  }
}
function toConfiguration(root: jsonP.JSONValue): Configuration {
  return jsonP.readObj({
    required: {
      "classification": "s",
    },
    optional: {
      "properties": x => jsonP.readMap(String, String, x),
      "configurations": [toConfiguration],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MonitoringConfiguration {
  persistentAppUI?: PersistentAppUI | null;
  cloudWatchMonitoringConfiguration?: CloudWatchMonitoringConfiguration | null;
  s3MonitoringConfiguration?: S3MonitoringConfiguration | null;
}
function fromMonitoringConfiguration(input?: MonitoringConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    persistentAppUI: input["persistentAppUI"],
    cloudWatchMonitoringConfiguration: fromCloudWatchMonitoringConfiguration(input["cloudWatchMonitoringConfiguration"]),
    s3MonitoringConfiguration: fromS3MonitoringConfiguration(input["s3MonitoringConfiguration"]),
  }
}
function toMonitoringConfiguration(root: jsonP.JSONValue): MonitoringConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "persistentAppUI": (x: jsonP.JSONValue) => cmnP.readEnum<PersistentAppUI>(x),
      "cloudWatchMonitoringConfiguration": toCloudWatchMonitoringConfiguration,
      "s3MonitoringConfiguration": toS3MonitoringConfiguration,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type PersistentAppUI =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface CloudWatchMonitoringConfiguration {
  logGroupName: string;
  logStreamNamePrefix?: string | null;
}
function fromCloudWatchMonitoringConfiguration(input?: CloudWatchMonitoringConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logGroupName: input["logGroupName"],
    logStreamNamePrefix: input["logStreamNamePrefix"],
  }
}
function toCloudWatchMonitoringConfiguration(root: jsonP.JSONValue): CloudWatchMonitoringConfiguration {
  return jsonP.readObj({
    required: {
      "logGroupName": "s",
    },
    optional: {
      "logStreamNamePrefix": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface S3MonitoringConfiguration {
  logUri: string;
}
function fromS3MonitoringConfiguration(input?: S3MonitoringConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logUri: input["logUri"],
  }
}
function toS3MonitoringConfiguration(root: jsonP.JSONValue): S3MonitoringConfiguration {
  return jsonP.readObj({
    required: {
      "logUri": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ContainerProvider {
  type: ContainerProviderType;
  id: string;
  info?: ContainerInfo | null;
}
function fromContainerProvider(input?: ContainerProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    id: input["id"],
    info: fromContainerInfo(input["info"]),
  }
}
function toContainerProvider(root: jsonP.JSONValue): ContainerProvider {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ContainerProviderType>(x),
      "id": "s",
    },
    optional: {
      "info": toContainerInfo,
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ContainerProviderType =
| "EKS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ContainerInfo {
  eksInfo?: EksInfo | null;
}
function fromContainerInfo(input?: ContainerInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eksInfo: fromEksInfo(input["eksInfo"]),
  }
}
function toContainerInfo(root: jsonP.JSONValue): ContainerInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "eksInfo": toEksInfo,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EksInfo {
  namespace?: string | null;
}
function fromEksInfo(input?: EksInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    namespace: input["namespace"],
  }
}
function toEksInfo(root: jsonP.JSONValue): EksInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type JobRunState =
| "PENDING"
| "SUBMITTED"
| "RUNNING"
| "FAILED"
| "CANCELLED"
| "CANCEL_PENDING"
| "COMPLETED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type EndpointState =
| "CREATING"
| "ACTIVE"
| "TERMINATING"
| "TERMINATED"
| "TERMINATED_WITH_ERRORS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type VirtualClusterState =
| "RUNNING"
| "TERMINATING"
| "TERMINATED"
| "ARRESTED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface JobDriver {
  sparkSubmitJobDriver?: SparkSubmitJobDriver | null;
}
function fromJobDriver(input?: JobDriver | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sparkSubmitJobDriver: fromSparkSubmitJobDriver(input["sparkSubmitJobDriver"]),
  }
}
function toJobDriver(root: jsonP.JSONValue): JobDriver {
  return jsonP.readObj({
    required: {},
    optional: {
      "sparkSubmitJobDriver": toSparkSubmitJobDriver,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SparkSubmitJobDriver {
  entryPoint: string;
  entryPointArguments?: string[] | null;
  sparkSubmitParameters?: string | null;
}
function fromSparkSubmitJobDriver(input?: SparkSubmitJobDriver | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    entryPoint: input["entryPoint"],
    entryPointArguments: input["entryPointArguments"],
    sparkSubmitParameters: input["sparkSubmitParameters"],
  }
}
function toSparkSubmitJobDriver(root: jsonP.JSONValue): SparkSubmitJobDriver {
  return jsonP.readObj({
    required: {
      "entryPoint": "s",
    },
    optional: {
      "entryPointArguments": ["s"],
      "sparkSubmitParameters": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface JobRun {
  id?: string | null;
  name?: string | null;
  virtualClusterId?: string | null;
  arn?: string | null;
  state?: JobRunState | null;
  clientToken?: string | null;
  executionRoleArn?: string | null;
  releaseLabel?: string | null;
  configurationOverrides?: ConfigurationOverrides | null;
  jobDriver?: JobDriver | null;
  createdAt?: Date | number | null;
  createdBy?: string | null;
  finishedAt?: Date | number | null;
  stateDetails?: string | null;
  failureReason?: FailureReason | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toJobRun(root: jsonP.JSONValue): JobRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "virtualClusterId": "s",
      "arn": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<JobRunState>(x),
      "clientToken": "s",
      "executionRoleArn": "s",
      "releaseLabel": "s",
      "configurationOverrides": toConfigurationOverrides,
      "jobDriver": toJobDriver,
      "createdAt": "d",
      "createdBy": "s",
      "finishedAt": "d",
      "stateDetails": "s",
      "failureReason": (x: jsonP.JSONValue) => cmnP.readEnum<FailureReason>(x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type FailureReason =
| "INTERNAL_ERROR"
| "USER_ERROR"
| "VALIDATION_ERROR"
| "CLUSTER_UNAVAILABLE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface Endpoint {
  id?: string | null;
  name?: string | null;
  arn?: string | null;
  virtualClusterId?: string | null;
  type?: string | null;
  state?: EndpointState | null;
  releaseLabel?: string | null;
  executionRoleArn?: string | null;
  certificateArn?: string | null;
  configurationOverrides?: ConfigurationOverrides | null;
  serverUrl?: string | null;
  createdAt?: Date | number | null;
  securityGroup?: string | null;
  subnetIds?: string[] | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toEndpoint(root: jsonP.JSONValue): Endpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "arn": "s",
      "virtualClusterId": "s",
      "type": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<EndpointState>(x),
      "releaseLabel": "s",
      "executionRoleArn": "s",
      "certificateArn": "s",
      "configurationOverrides": toConfigurationOverrides,
      "serverUrl": "s",
      "createdAt": "d",
      "securityGroup": "s",
      "subnetIds": ["s"],
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface VirtualCluster {
  id?: string | null;
  name?: string | null;
  arn?: string | null;
  state?: VirtualClusterState | null;
  containerProvider?: ContainerProvider | null;
  createdAt?: Date | number | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toVirtualCluster(root: jsonP.JSONValue): VirtualCluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
      "arn": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualClusterState>(x),
      "containerProvider": toContainerProvider,
      "createdAt": "d",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
