// Autogenerated API client for: Amazon Rekognition

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.86.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Rekognition {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Rekognition.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-06-27",
    "endpointPrefix": "rekognition",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Rekognition",
    "serviceId": "Rekognition",
    "signatureVersion": "v4",
    "targetPrefix": "RekognitionService",
    "uid": "rekognition-2016-06-27"
  };

  async compareFaces(
    {abortSignal, ...params}: RequestConfig & s.CompareFacesRequest,
  ): Promise<s.CompareFacesResponse> {
    const body: jsonP.JSONObject = {
      SourceImage: fromImage(params["SourceImage"]),
      TargetImage: fromImage(params["TargetImage"]),
      SimilarityThreshold: params["SimilarityThreshold"],
      QualityFilter: params["QualityFilter"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CompareFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SourceImageFace": toComparedSourceImageFace,
        "FaceMatches": [toCompareFacesMatch],
        "UnmatchedFaces": [toComparedFace],
        "SourceImageOrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
        "TargetImageOrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
      },
    }, await resp.json());
  }

  async createCollection(
    {abortSignal, ...params}: RequestConfig & s.CreateCollectionRequest,
  ): Promise<s.CreateCollectionResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCollection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StatusCode": "n",
        "CollectionArn": "s",
        "FaceModelVersion": "s",
      },
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectRequest,
  ): Promise<s.CreateProjectResponse> {
    const body: jsonP.JSONObject = {
      ProjectName: params["ProjectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectArn": "s",
      },
    }, await resp.json());
  }

  async createProjectVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectVersionRequest,
  ): Promise<s.CreateProjectVersionResponse> {
    const body: jsonP.JSONObject = {
      ProjectArn: params["ProjectArn"],
      VersionName: params["VersionName"],
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
      TrainingData: fromTrainingData(params["TrainingData"]),
      TestingData: fromTestingData(params["TestingData"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProjectVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectVersionArn": "s",
      },
    }, await resp.json());
  }

  async createStreamProcessor(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamProcessorRequest,
  ): Promise<s.CreateStreamProcessorResponse> {
    const body: jsonP.JSONObject = {
      Input: fromStreamProcessorInput(params["Input"]),
      Output: fromStreamProcessorOutput(params["Output"]),
      Name: params["Name"],
      Settings: fromStreamProcessorSettings(params["Settings"]),
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamProcessor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamProcessorArn": "s",
      },
    }, await resp.json());
  }

  async deleteCollection(
    {abortSignal, ...params}: RequestConfig & s.DeleteCollectionRequest,
  ): Promise<s.DeleteCollectionResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCollection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StatusCode": "n",
      },
    }, await resp.json());
  }

  async deleteFaces(
    {abortSignal, ...params}: RequestConfig & s.DeleteFacesRequest,
  ): Promise<s.DeleteFacesResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
      FaceIds: params["FaceIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DeletedFaces": ["s"],
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectRequest,
  ): Promise<s.DeleteProjectResponse> {
    const body: jsonP.JSONObject = {
      ProjectArn: params["ProjectArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectStatus>(x),
      },
    }, await resp.json());
  }

  async deleteProjectVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectVersionRequest,
  ): Promise<s.DeleteProjectVersionResponse> {
    const body: jsonP.JSONObject = {
      ProjectVersionArn: params["ProjectVersionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteProjectVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectVersionStatus>(x),
      },
    }, await resp.json());
  }

  async deleteStreamProcessor(
    {abortSignal, ...params}: RequestConfig & s.DeleteStreamProcessorRequest,
  ): Promise<s.DeleteStreamProcessorResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStreamProcessor",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeCollection(
    {abortSignal, ...params}: RequestConfig & s.DescribeCollectionRequest,
  ): Promise<s.DescribeCollectionResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCollection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FaceCount": "n",
        "FaceModelVersion": "s",
        "CollectionARN": "s",
        "CreationTimestamp": "d",
      },
    }, await resp.json());
  }

  async describeProjectVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectVersionsRequest,
  ): Promise<s.DescribeProjectVersionsResponse> {
    const body: jsonP.JSONObject = {
      ProjectArn: params["ProjectArn"],
      VersionNames: params["VersionNames"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeProjectVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectVersionDescriptions": [toProjectVersionDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeProjects(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectsRequest = {},
  ): Promise<s.DescribeProjectsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProjectDescriptions": [toProjectDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeStreamProcessor(
    {abortSignal, ...params}: RequestConfig & s.DescribeStreamProcessorRequest,
  ): Promise<s.DescribeStreamProcessorResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStreamProcessor",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "StreamProcessorArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamProcessorStatus>(x),
        "StatusMessage": "s",
        "CreationTimestamp": "d",
        "LastUpdateTimestamp": "d",
        "Input": toStreamProcessorInput,
        "Output": toStreamProcessorOutput,
        "RoleArn": "s",
        "Settings": toStreamProcessorSettings,
      },
    }, await resp.json());
  }

  async detectCustomLabels(
    {abortSignal, ...params}: RequestConfig & s.DetectCustomLabelsRequest,
  ): Promise<s.DetectCustomLabelsResponse> {
    const body: jsonP.JSONObject = {
      ProjectVersionArn: params["ProjectVersionArn"],
      Image: fromImage(params["Image"]),
      MaxResults: params["MaxResults"],
      MinConfidence: params["MinConfidence"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectCustomLabels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomLabels": [toCustomLabel],
      },
    }, await resp.json());
  }

  async detectFaces(
    {abortSignal, ...params}: RequestConfig & s.DetectFacesRequest,
  ): Promise<s.DetectFacesResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
      Attributes: params["Attributes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FaceDetails": [toFaceDetail],
        "OrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
      },
    }, await resp.json());
  }

  async detectLabels(
    {abortSignal, ...params}: RequestConfig & s.DetectLabelsRequest,
  ): Promise<s.DetectLabelsResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
      MaxLabels: params["MaxLabels"],
      MinConfidence: params["MinConfidence"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectLabels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Labels": [toLabel],
        "OrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
        "LabelModelVersion": "s",
      },
    }, await resp.json());
  }

  async detectModerationLabels(
    {abortSignal, ...params}: RequestConfig & s.DetectModerationLabelsRequest,
  ): Promise<s.DetectModerationLabelsResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
      MinConfidence: params["MinConfidence"],
      HumanLoopConfig: fromHumanLoopConfig(params["HumanLoopConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectModerationLabels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ModerationLabels": [toModerationLabel],
        "ModerationModelVersion": "s",
        "HumanLoopActivationOutput": toHumanLoopActivationOutput,
      },
    }, await resp.json());
  }

  async detectProtectiveEquipment(
    {abortSignal, ...params}: RequestConfig & s.DetectProtectiveEquipmentRequest,
  ): Promise<s.DetectProtectiveEquipmentResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
      SummarizationAttributes: fromProtectiveEquipmentSummarizationAttributes(params["SummarizationAttributes"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectProtectiveEquipment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProtectiveEquipmentModelVersion": "s",
        "Persons": [toProtectiveEquipmentPerson],
        "Summary": toProtectiveEquipmentSummary,
      },
    }, await resp.json());
  }

  async detectText(
    {abortSignal, ...params}: RequestConfig & s.DetectTextRequest,
  ): Promise<s.DetectTextResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
      Filters: fromDetectTextFilters(params["Filters"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectText",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TextDetections": [toTextDetection],
        "TextModelVersion": "s",
      },
    }, await resp.json());
  }

  async getCelebrityInfo(
    {abortSignal, ...params}: RequestConfig & s.GetCelebrityInfoRequest,
  ): Promise<s.GetCelebrityInfoResponse> {
    const body: jsonP.JSONObject = {
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCelebrityInfo",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Urls": ["s"],
        "Name": "s",
      },
    }, await resp.json());
  }

  async getCelebrityRecognition(
    {abortSignal, ...params}: RequestConfig & s.GetCelebrityRecognitionRequest,
  ): Promise<s.GetCelebrityRecognitionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCelebrityRecognition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "NextToken": "s",
        "Celebrities": [toCelebrityRecognition],
      },
    }, await resp.json());
  }

  async getContentModeration(
    {abortSignal, ...params}: RequestConfig & s.GetContentModerationRequest,
  ): Promise<s.GetContentModerationResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetContentModeration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "ModerationLabels": [toContentModerationDetection],
        "NextToken": "s",
        "ModerationModelVersion": "s",
      },
    }, await resp.json());
  }

  async getFaceDetection(
    {abortSignal, ...params}: RequestConfig & s.GetFaceDetectionRequest,
  ): Promise<s.GetFaceDetectionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFaceDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "NextToken": "s",
        "Faces": [toFaceDetection],
      },
    }, await resp.json());
  }

  async getFaceSearch(
    {abortSignal, ...params}: RequestConfig & s.GetFaceSearchRequest,
  ): Promise<s.GetFaceSearchResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFaceSearch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "NextToken": "s",
        "VideoMetadata": toVideoMetadata,
        "Persons": [toPersonMatch],
      },
    }, await resp.json());
  }

  async getLabelDetection(
    {abortSignal, ...params}: RequestConfig & s.GetLabelDetectionRequest,
  ): Promise<s.GetLabelDetectionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLabelDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "NextToken": "s",
        "Labels": [toLabelDetection],
        "LabelModelVersion": "s",
      },
    }, await resp.json());
  }

  async getPersonTracking(
    {abortSignal, ...params}: RequestConfig & s.GetPersonTrackingRequest,
  ): Promise<s.GetPersonTrackingResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPersonTracking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "NextToken": "s",
        "Persons": [toPersonDetection],
      },
    }, await resp.json());
  }

  async getSegmentDetection(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentDetectionRequest,
  ): Promise<s.GetSegmentDetectionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSegmentDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": [toVideoMetadata],
        "AudioMetadata": [toAudioMetadata],
        "NextToken": "s",
        "Segments": [toSegmentDetection],
        "SelectedSegmentTypes": [toSegmentTypeInfo],
      },
    }, await resp.json());
  }

  async getTextDetection(
    {abortSignal, ...params}: RequestConfig & s.GetTextDetectionRequest,
  ): Promise<s.GetTextDetectionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTextDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoJobStatus>(x),
        "StatusMessage": "s",
        "VideoMetadata": toVideoMetadata,
        "TextDetections": [toTextDetectionResult],
        "NextToken": "s",
        "TextModelVersion": "s",
      },
    }, await resp.json());
  }

  async indexFaces(
    {abortSignal, ...params}: RequestConfig & s.IndexFacesRequest,
  ): Promise<s.IndexFacesResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
      Image: fromImage(params["Image"]),
      ExternalImageId: params["ExternalImageId"],
      DetectionAttributes: params["DetectionAttributes"],
      MaxFaces: params["MaxFaces"],
      QualityFilter: params["QualityFilter"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IndexFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FaceRecords": [toFaceRecord],
        "OrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
        "FaceModelVersion": "s",
        "UnindexedFaces": [toUnindexedFace],
      },
    }, await resp.json());
  }

  async listCollections(
    {abortSignal, ...params}: RequestConfig & s.ListCollectionsRequest = {},
  ): Promise<s.ListCollectionsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCollections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CollectionIds": ["s"],
        "NextToken": "s",
        "FaceModelVersions": ["s"],
      },
    }, await resp.json());
  }

  async listFaces(
    {abortSignal, ...params}: RequestConfig & s.ListFacesRequest,
  ): Promise<s.ListFacesResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Faces": [toFace],
        "NextToken": "s",
        "FaceModelVersion": "s",
      },
    }, await resp.json());
  }

  async listStreamProcessors(
    {abortSignal, ...params}: RequestConfig & s.ListStreamProcessorsRequest = {},
  ): Promise<s.ListStreamProcessorsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreamProcessors",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "StreamProcessors": [toStreamProcessor],
      },
    }, await resp.json());
  }

  async recognizeCelebrities(
    {abortSignal, ...params}: RequestConfig & s.RecognizeCelebritiesRequest,
  ): Promise<s.RecognizeCelebritiesResponse> {
    const body: jsonP.JSONObject = {
      Image: fromImage(params["Image"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RecognizeCelebrities",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CelebrityFaces": [toCelebrity],
        "UnrecognizedFaces": [toComparedFace],
        "OrientationCorrection": (x: jsonP.JSONValue) => cmnP.readEnum<s.OrientationCorrection>(x),
      },
    }, await resp.json());
  }

  async searchFaces(
    {abortSignal, ...params}: RequestConfig & s.SearchFacesRequest,
  ): Promise<s.SearchFacesResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
      FaceId: params["FaceId"],
      MaxFaces: params["MaxFaces"],
      FaceMatchThreshold: params["FaceMatchThreshold"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchFaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SearchedFaceId": "s",
        "FaceMatches": [toFaceMatch],
        "FaceModelVersion": "s",
      },
    }, await resp.json());
  }

  async searchFacesByImage(
    {abortSignal, ...params}: RequestConfig & s.SearchFacesByImageRequest,
  ): Promise<s.SearchFacesByImageResponse> {
    const body: jsonP.JSONObject = {
      CollectionId: params["CollectionId"],
      Image: fromImage(params["Image"]),
      MaxFaces: params["MaxFaces"],
      FaceMatchThreshold: params["FaceMatchThreshold"],
      QualityFilter: params["QualityFilter"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchFacesByImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SearchedFaceBoundingBox": toBoundingBox,
        "SearchedFaceConfidence": "n",
        "FaceMatches": [toFaceMatch],
        "FaceModelVersion": "s",
      },
    }, await resp.json());
  }

  async startCelebrityRecognition(
    {abortSignal, ...params}: RequestConfig & s.StartCelebrityRecognitionRequest,
  ): Promise<s.StartCelebrityRecognitionResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartCelebrityRecognition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startContentModeration(
    {abortSignal, ...params}: RequestConfig & s.StartContentModerationRequest,
  ): Promise<s.StartContentModerationResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      MinConfidence: params["MinConfidence"],
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartContentModeration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startFaceDetection(
    {abortSignal, ...params}: RequestConfig & s.StartFaceDetectionRequest,
  ): Promise<s.StartFaceDetectionResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      FaceAttributes: params["FaceAttributes"],
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartFaceDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startFaceSearch(
    {abortSignal, ...params}: RequestConfig & s.StartFaceSearchRequest,
  ): Promise<s.StartFaceSearchResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      FaceMatchThreshold: params["FaceMatchThreshold"],
      CollectionId: params["CollectionId"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartFaceSearch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startLabelDetection(
    {abortSignal, ...params}: RequestConfig & s.StartLabelDetectionRequest,
  ): Promise<s.StartLabelDetectionResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      MinConfidence: params["MinConfidence"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartLabelDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startPersonTracking(
    {abortSignal, ...params}: RequestConfig & s.StartPersonTrackingRequest,
  ): Promise<s.StartPersonTrackingResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPersonTracking",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startProjectVersion(
    {abortSignal, ...params}: RequestConfig & s.StartProjectVersionRequest,
  ): Promise<s.StartProjectVersionResponse> {
    const body: jsonP.JSONObject = {
      ProjectVersionArn: params["ProjectVersionArn"],
      MinInferenceUnits: params["MinInferenceUnits"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartProjectVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectVersionStatus>(x),
      },
    }, await resp.json());
  }

  async startSegmentDetection(
    {abortSignal, ...params}: RequestConfig & s.StartSegmentDetectionRequest,
  ): Promise<s.StartSegmentDetectionResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
      Filters: fromStartSegmentDetectionFilters(params["Filters"]),
      SegmentTypes: params["SegmentTypes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSegmentDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startStreamProcessor(
    {abortSignal, ...params}: RequestConfig & s.StartStreamProcessorRequest,
  ): Promise<s.StartStreamProcessorResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartStreamProcessor",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startTextDetection(
    {abortSignal, ...params}: RequestConfig & s.StartTextDetectionRequest,
  ): Promise<s.StartTextDetectionResponse> {
    const body: jsonP.JSONObject = {
      Video: fromVideo(params["Video"]),
      ClientRequestToken: params["ClientRequestToken"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      JobTag: params["JobTag"],
      Filters: fromStartTextDetectionFilters(params["Filters"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTextDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async stopProjectVersion(
    {abortSignal, ...params}: RequestConfig & s.StopProjectVersionRequest,
  ): Promise<s.StopProjectVersionResponse> {
    const body: jsonP.JSONObject = {
      ProjectVersionArn: params["ProjectVersionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopProjectVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectVersionStatus>(x),
      },
    }, await resp.json());
  }

  async stopStreamProcessor(
    {abortSignal, ...params}: RequestConfig & s.StopStreamProcessorRequest,
  ): Promise<s.StopStreamProcessorResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopStreamProcessor",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until the ProjectVersion training completes.
   * Checks state up to 360 times, 120 seconds apart (about 720 minutes max wait time).
   */
  async waitForProjectVersionTrainingCompleted(
    params: RequestConfig & s.DescribeProjectVersionsRequest,
  ): Promise<s.DescribeProjectVersionsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ProjectVersionTrainingCompleted';
    for (let i = 0; i < 360; i++) {
      const resp = await this.describeProjectVersions(params);
      const field = resp?.ProjectVersionDescriptions?.flatMap(x => x?.Status);
      if (field?.every(x => x === "TRAINING_COMPLETED")) return resp;
      if (field?.some(x => x === "TRAINING_FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 120000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until the ProjectVersion is running.
   * Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time).
   */
  async waitForProjectVersionRunning(
    params: RequestConfig & s.DescribeProjectVersionsRequest,
  ): Promise<s.DescribeProjectVersionsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ProjectVersionRunning';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeProjectVersions(params);
      const field = resp?.ProjectVersionDescriptions?.flatMap(x => x?.Status);
      if (field?.every(x => x === "RUNNING")) return resp;
      if (field?.some(x => x === "FAILED")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function fromImage(input?: s.Image | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bytes: serializeBlob(input["Bytes"]),
    S3Object: fromS3Object(input["S3Object"]),
  }
}

function fromS3Object(input?: s.S3Object | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Name: input["Name"],
    Version: input["Version"],
  }
}
function toS3Object(root: jsonP.JSONValue): s.S3Object {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

function fromOutputConfig(input?: s.OutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Bucket: input["S3Bucket"],
    S3KeyPrefix: input["S3KeyPrefix"],
  }
}
function toOutputConfig(root: jsonP.JSONValue): s.OutputConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Bucket": "s",
      "S3KeyPrefix": "s",
    },
  }, root);
}

function fromTrainingData(input?: s.TrainingData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Assets: input["Assets"]?.map(x => fromAsset(x)),
  }
}
function toTrainingData(root: jsonP.JSONValue): s.TrainingData {
  return jsonP.readObj({
    required: {},
    optional: {
      "Assets": [toAsset],
    },
  }, root);
}

function fromAsset(input?: s.Asset | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroundTruthManifest: fromGroundTruthManifest(input["GroundTruthManifest"]),
  }
}
function toAsset(root: jsonP.JSONValue): s.Asset {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroundTruthManifest": toGroundTruthManifest,
    },
  }, root);
}

function fromGroundTruthManifest(input?: s.GroundTruthManifest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Object: fromS3Object(input["S3Object"]),
  }
}
function toGroundTruthManifest(root: jsonP.JSONValue): s.GroundTruthManifest {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Object": toS3Object,
    },
  }, root);
}

function fromTestingData(input?: s.TestingData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Assets: input["Assets"]?.map(x => fromAsset(x)),
    AutoCreate: input["AutoCreate"],
  }
}
function toTestingData(root: jsonP.JSONValue): s.TestingData {
  return jsonP.readObj({
    required: {},
    optional: {
      "Assets": [toAsset],
      "AutoCreate": "b",
    },
  }, root);
}

function fromStreamProcessorInput(input?: s.StreamProcessorInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KinesisVideoStream: fromKinesisVideoStream(input["KinesisVideoStream"]),
  }
}
function toStreamProcessorInput(root: jsonP.JSONValue): s.StreamProcessorInput {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisVideoStream": toKinesisVideoStream,
    },
  }, root);
}

function fromKinesisVideoStream(input?: s.KinesisVideoStream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
  }
}
function toKinesisVideoStream(root: jsonP.JSONValue): s.KinesisVideoStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function fromStreamProcessorOutput(input?: s.StreamProcessorOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KinesisDataStream: fromKinesisDataStream(input["KinesisDataStream"]),
  }
}
function toStreamProcessorOutput(root: jsonP.JSONValue): s.StreamProcessorOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "KinesisDataStream": toKinesisDataStream,
    },
  }, root);
}

function fromKinesisDataStream(input?: s.KinesisDataStream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
  }
}
function toKinesisDataStream(root: jsonP.JSONValue): s.KinesisDataStream {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function fromStreamProcessorSettings(input?: s.StreamProcessorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FaceSearch: fromFaceSearchSettings(input["FaceSearch"]),
  }
}
function toStreamProcessorSettings(root: jsonP.JSONValue): s.StreamProcessorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FaceSearch": toFaceSearchSettings,
    },
  }, root);
}

function fromFaceSearchSettings(input?: s.FaceSearchSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CollectionId: input["CollectionId"],
    FaceMatchThreshold: input["FaceMatchThreshold"],
  }
}
function toFaceSearchSettings(root: jsonP.JSONValue): s.FaceSearchSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CollectionId": "s",
      "FaceMatchThreshold": "n",
    },
  }, root);
}

function fromHumanLoopConfig(input?: s.HumanLoopConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopName: input["HumanLoopName"],
    FlowDefinitionArn: input["FlowDefinitionArn"],
    DataAttributes: fromHumanLoopDataAttributes(input["DataAttributes"]),
  }
}

function fromHumanLoopDataAttributes(input?: s.HumanLoopDataAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentClassifiers: input["ContentClassifiers"],
  }
}

function fromProtectiveEquipmentSummarizationAttributes(input?: s.ProtectiveEquipmentSummarizationAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinConfidence: input["MinConfidence"],
    RequiredEquipmentTypes: input["RequiredEquipmentTypes"],
  }
}

function fromDetectTextFilters(input?: s.DetectTextFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WordFilter: fromDetectionFilter(input["WordFilter"]),
    RegionsOfInterest: input["RegionsOfInterest"]?.map(x => fromRegionOfInterest(x)),
  }
}

function fromDetectionFilter(input?: s.DetectionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinConfidence: input["MinConfidence"],
    MinBoundingBoxHeight: input["MinBoundingBoxHeight"],
    MinBoundingBoxWidth: input["MinBoundingBoxWidth"],
  }
}

function fromRegionOfInterest(input?: s.RegionOfInterest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BoundingBox: fromBoundingBox(input["BoundingBox"]),
  }
}

function fromBoundingBox(input?: s.BoundingBox | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Width: input["Width"],
    Height: input["Height"],
    Left: input["Left"],
    Top: input["Top"],
  }
}
function toBoundingBox(root: jsonP.JSONValue): s.BoundingBox {
  return jsonP.readObj({
    required: {},
    optional: {
      "Width": "n",
      "Height": "n",
      "Left": "n",
      "Top": "n",
    },
  }, root);
}

function fromVideo(input?: s.Video | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Object: fromS3Object(input["S3Object"]),
  }
}

function fromNotificationChannel(input?: s.NotificationChannel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SNSTopicArn: input["SNSTopicArn"],
    RoleArn: input["RoleArn"],
  }
}

function fromStartSegmentDetectionFilters(input?: s.StartSegmentDetectionFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TechnicalCueFilter: fromStartTechnicalCueDetectionFilter(input["TechnicalCueFilter"]),
    ShotFilter: fromStartShotDetectionFilter(input["ShotFilter"]),
  }
}

function fromStartTechnicalCueDetectionFilter(input?: s.StartTechnicalCueDetectionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinSegmentConfidence: input["MinSegmentConfidence"],
  }
}

function fromStartShotDetectionFilter(input?: s.StartShotDetectionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinSegmentConfidence: input["MinSegmentConfidence"],
  }
}

function fromStartTextDetectionFilters(input?: s.StartTextDetectionFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WordFilter: fromDetectionFilter(input["WordFilter"]),
    RegionsOfInterest: input["RegionsOfInterest"]?.map(x => fromRegionOfInterest(x)),
  }
}

function toComparedSourceImageFace(root: jsonP.JSONValue): s.ComparedSourceImageFace {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Confidence": "n",
    },
  }, root);
}

function toCompareFacesMatch(root: jsonP.JSONValue): s.CompareFacesMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Similarity": "n",
      "Face": toComparedFace,
    },
  }, root);
}

function toComparedFace(root: jsonP.JSONValue): s.ComparedFace {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Confidence": "n",
      "Landmarks": [toLandmark],
      "Pose": toPose,
      "Quality": toImageQuality,
    },
  }, root);
}

function toLandmark(root: jsonP.JSONValue): s.Landmark {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.LandmarkType>(x),
      "X": "n",
      "Y": "n",
    },
  }, root);
}

function toPose(root: jsonP.JSONValue): s.Pose {
  return jsonP.readObj({
    required: {},
    optional: {
      "Roll": "n",
      "Yaw": "n",
      "Pitch": "n",
    },
  }, root);
}

function toImageQuality(root: jsonP.JSONValue): s.ImageQuality {
  return jsonP.readObj({
    required: {},
    optional: {
      "Brightness": "n",
      "Sharpness": "n",
    },
  }, root);
}

function toProjectVersionDescription(root: jsonP.JSONValue): s.ProjectVersionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectVersionArn": "s",
      "CreationTimestamp": "d",
      "MinInferenceUnits": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectVersionStatus>(x),
      "StatusMessage": "s",
      "BillableTrainingTimeInSeconds": "n",
      "TrainingEndTimestamp": "d",
      "OutputConfig": toOutputConfig,
      "TrainingDataResult": toTrainingDataResult,
      "TestingDataResult": toTestingDataResult,
      "EvaluationResult": toEvaluationResult,
      "ManifestSummary": toGroundTruthManifest,
    },
  }, root);
}

function toTrainingDataResult(root: jsonP.JSONValue): s.TrainingDataResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Input": toTrainingData,
      "Output": toTrainingData,
      "Validation": toValidationData,
    },
  }, root);
}

function toValidationData(root: jsonP.JSONValue): s.ValidationData {
  return jsonP.readObj({
    required: {},
    optional: {
      "Assets": [toAsset],
    },
  }, root);
}

function toTestingDataResult(root: jsonP.JSONValue): s.TestingDataResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Input": toTestingData,
      "Output": toTestingData,
      "Validation": toValidationData,
    },
  }, root);
}

function toEvaluationResult(root: jsonP.JSONValue): s.EvaluationResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "F1Score": "n",
      "Summary": toSummary,
    },
  }, root);
}

function toSummary(root: jsonP.JSONValue): s.Summary {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Object": toS3Object,
    },
  }, root);
}

function toProjectDescription(root: jsonP.JSONValue): s.ProjectDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProjectArn": "s",
      "CreationTimestamp": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectStatus>(x),
    },
  }, root);
}

function toCustomLabel(root: jsonP.JSONValue): s.CustomLabel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Confidence": "n",
      "Geometry": toGeometry,
    },
  }, root);
}

function toGeometry(root: jsonP.JSONValue): s.Geometry {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Polygon": [toPoint],
    },
  }, root);
}

function toPoint(root: jsonP.JSONValue): s.Point {
  return jsonP.readObj({
    required: {},
    optional: {
      "X": "n",
      "Y": "n",
    },
  }, root);
}

function toFaceDetail(root: jsonP.JSONValue): s.FaceDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "AgeRange": toAgeRange,
      "Smile": toSmile,
      "Eyeglasses": toEyeglasses,
      "Sunglasses": toSunglasses,
      "Gender": toGender,
      "Beard": toBeard,
      "Mustache": toMustache,
      "EyesOpen": toEyeOpen,
      "MouthOpen": toMouthOpen,
      "Emotions": [toEmotion],
      "Landmarks": [toLandmark],
      "Pose": toPose,
      "Quality": toImageQuality,
      "Confidence": "n",
    },
  }, root);
}

function toAgeRange(root: jsonP.JSONValue): s.AgeRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "Low": "n",
      "High": "n",
    },
  }, root);
}

function toSmile(root: jsonP.JSONValue): s.Smile {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toEyeglasses(root: jsonP.JSONValue): s.Eyeglasses {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toSunglasses(root: jsonP.JSONValue): s.Sunglasses {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toGender(root: jsonP.JSONValue): s.Gender {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": (x: jsonP.JSONValue) => cmnP.readEnum<s.GenderType>(x),
      "Confidence": "n",
    },
  }, root);
}

function toBeard(root: jsonP.JSONValue): s.Beard {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toMustache(root: jsonP.JSONValue): s.Mustache {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toEyeOpen(root: jsonP.JSONValue): s.EyeOpen {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toMouthOpen(root: jsonP.JSONValue): s.MouthOpen {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "b",
      "Confidence": "n",
    },
  }, root);
}

function toEmotion(root: jsonP.JSONValue): s.Emotion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmotionName>(x),
      "Confidence": "n",
    },
  }, root);
}

function toLabel(root: jsonP.JSONValue): s.Label {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Confidence": "n",
      "Instances": [toInstance],
      "Parents": [toParent],
    },
  }, root);
}

function toInstance(root: jsonP.JSONValue): s.Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Confidence": "n",
    },
  }, root);
}

function toParent(root: jsonP.JSONValue): s.Parent {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function toModerationLabel(root: jsonP.JSONValue): s.ModerationLabel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Confidence": "n",
      "Name": "s",
      "ParentName": "s",
    },
  }, root);
}

function toHumanLoopActivationOutput(root: jsonP.JSONValue): s.HumanLoopActivationOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "HumanLoopArn": "s",
      "HumanLoopActivationReasons": ["s"],
      "HumanLoopActivationConditionsEvaluationResults": jsonP.readJsonValue,
    },
  }, root);
}

function toProtectiveEquipmentPerson(root: jsonP.JSONValue): s.ProtectiveEquipmentPerson {
  return jsonP.readObj({
    required: {},
    optional: {
      "BodyParts": [toProtectiveEquipmentBodyPart],
      "BoundingBox": toBoundingBox,
      "Confidence": "n",
      "Id": "n",
    },
  }, root);
}

function toProtectiveEquipmentBodyPart(root: jsonP.JSONValue): s.ProtectiveEquipmentBodyPart {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": (x: jsonP.JSONValue) => cmnP.readEnum<s.BodyPart>(x),
      "Confidence": "n",
      "EquipmentDetections": [toEquipmentDetection],
    },
  }, root);
}

function toEquipmentDetection(root: jsonP.JSONValue): s.EquipmentDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Confidence": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProtectiveEquipmentType>(x),
      "CoversBodyPart": toCoversBodyPart,
    },
  }, root);
}

function toCoversBodyPart(root: jsonP.JSONValue): s.CoversBodyPart {
  return jsonP.readObj({
    required: {},
    optional: {
      "Confidence": "n",
      "Value": "b",
    },
  }, root);
}

function toProtectiveEquipmentSummary(root: jsonP.JSONValue): s.ProtectiveEquipmentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PersonsWithRequiredEquipment": ["n"],
      "PersonsWithoutRequiredEquipment": ["n"],
      "PersonsIndeterminate": ["n"],
    },
  }, root);
}

function toTextDetection(root: jsonP.JSONValue): s.TextDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "DetectedText": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TextTypes>(x),
      "Id": "n",
      "ParentId": "n",
      "Confidence": "n",
      "Geometry": toGeometry,
    },
  }, root);
}

function toVideoMetadata(root: jsonP.JSONValue): s.VideoMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "DurationMillis": "n",
      "Format": "s",
      "FrameRate": "n",
      "FrameHeight": "n",
      "FrameWidth": "n",
    },
  }, root);
}

function toCelebrityRecognition(root: jsonP.JSONValue): s.CelebrityRecognition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "Celebrity": toCelebrityDetail,
    },
  }, root);
}

function toCelebrityDetail(root: jsonP.JSONValue): s.CelebrityDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Urls": ["s"],
      "Name": "s",
      "Id": "s",
      "Confidence": "n",
      "BoundingBox": toBoundingBox,
      "Face": toFaceDetail,
    },
  }, root);
}

function toContentModerationDetection(root: jsonP.JSONValue): s.ContentModerationDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "ModerationLabel": toModerationLabel,
    },
  }, root);
}

function toFaceDetection(root: jsonP.JSONValue): s.FaceDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "Face": toFaceDetail,
    },
  }, root);
}

function toPersonMatch(root: jsonP.JSONValue): s.PersonMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "Person": toPersonDetail,
      "FaceMatches": [toFaceMatch],
    },
  }, root);
}

function toPersonDetail(root: jsonP.JSONValue): s.PersonDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "BoundingBox": toBoundingBox,
      "Face": toFaceDetail,
    },
  }, root);
}

function toFaceMatch(root: jsonP.JSONValue): s.FaceMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Similarity": "n",
      "Face": toFace,
    },
  }, root);
}

function toFace(root: jsonP.JSONValue): s.Face {
  return jsonP.readObj({
    required: {},
    optional: {
      "FaceId": "s",
      "BoundingBox": toBoundingBox,
      "ImageId": "s",
      "ExternalImageId": "s",
      "Confidence": "n",
    },
  }, root);
}

function toLabelDetection(root: jsonP.JSONValue): s.LabelDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "Label": toLabel,
    },
  }, root);
}

function toPersonDetection(root: jsonP.JSONValue): s.PersonDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "Person": toPersonDetail,
    },
  }, root);
}

function toAudioMetadata(root: jsonP.JSONValue): s.AudioMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": "s",
      "DurationMillis": "n",
      "SampleRate": "n",
      "NumberOfChannels": "n",
    },
  }, root);
}

function toSegmentDetection(root: jsonP.JSONValue): s.SegmentDetection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SegmentType>(x),
      "StartTimestampMillis": "n",
      "EndTimestampMillis": "n",
      "DurationMillis": "n",
      "StartTimecodeSMPTE": "s",
      "EndTimecodeSMPTE": "s",
      "DurationSMPTE": "s",
      "TechnicalCueSegment": toTechnicalCueSegment,
      "ShotSegment": toShotSegment,
    },
  }, root);
}

function toTechnicalCueSegment(root: jsonP.JSONValue): s.TechnicalCueSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TechnicalCueType>(x),
      "Confidence": "n",
    },
  }, root);
}

function toShotSegment(root: jsonP.JSONValue): s.ShotSegment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Index": "n",
      "Confidence": "n",
    },
  }, root);
}

function toSegmentTypeInfo(root: jsonP.JSONValue): s.SegmentTypeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SegmentType>(x),
      "ModelVersion": "s",
    },
  }, root);
}

function toTextDetectionResult(root: jsonP.JSONValue): s.TextDetectionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timestamp": "n",
      "TextDetection": toTextDetection,
    },
  }, root);
}

function toFaceRecord(root: jsonP.JSONValue): s.FaceRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "Face": toFace,
      "FaceDetail": toFaceDetail,
    },
  }, root);
}

function toUnindexedFace(root: jsonP.JSONValue): s.UnindexedFace {
  return jsonP.readObj({
    required: {},
    optional: {
      "Reasons": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Reason>(x)],
      "FaceDetail": toFaceDetail,
    },
  }, root);
}

function toStreamProcessor(root: jsonP.JSONValue): s.StreamProcessor {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamProcessorStatus>(x),
    },
  }, root);
}

function toCelebrity(root: jsonP.JSONValue): s.Celebrity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Urls": ["s"],
      "Name": "s",
      "Id": "s",
      "Face": toComparedFace,
      "MatchConfidence": "n",
    },
  }, root);
}
