// Autogenerated API client for: Amazon AppStream

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class AppStream {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AppStream.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-12-01",
    "endpointPrefix": "appstream2",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon AppStream",
    "serviceId": "AppStream",
    "signatureVersion": "v4",
    "signingName": "appstream",
    "targetPrefix": "PhotonAdminProxyService",
    "uid": "appstream-2016-12-01"
  };

  async associateFleet(
    {abortSignal, ...params}: RequestConfig & s.AssociateFleetRequest,
  ): Promise<s.AssociateFleetResult> {
    const body: jsonP.JSONObject = {
      FleetName: params["FleetName"],
      StackName: params["StackName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async batchAssociateUserStack(
    {abortSignal, ...params}: RequestConfig & s.BatchAssociateUserStackRequest,
  ): Promise<s.BatchAssociateUserStackResult> {
    const body: jsonP.JSONObject = {
      UserStackAssociations: params["UserStackAssociations"]?.map(x => fromUserStackAssociation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchAssociateUserStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "errors": [toUserStackAssociationError],
      },
    }, await resp.json());
  }

  async batchDisassociateUserStack(
    {abortSignal, ...params}: RequestConfig & s.BatchDisassociateUserStackRequest,
  ): Promise<s.BatchDisassociateUserStackResult> {
    const body: jsonP.JSONObject = {
      UserStackAssociations: params["UserStackAssociations"]?.map(x => fromUserStackAssociation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisassociateUserStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "errors": [toUserStackAssociationError],
      },
    }, await resp.json());
  }

  async copyImage(
    {abortSignal, ...params}: RequestConfig & s.CopyImageRequest,
  ): Promise<s.CopyImageResponse> {
    const body: jsonP.JSONObject = {
      SourceImageName: params["SourceImageName"],
      DestinationImageName: params["DestinationImageName"],
      DestinationRegion: params["DestinationRegion"],
      DestinationImageDescription: params["DestinationImageDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DestinationImageName": "s",
      },
    }, await resp.json());
  }

  async createDirectoryConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectoryConfigRequest,
  ): Promise<s.CreateDirectoryConfigResult> {
    const body: jsonP.JSONObject = {
      DirectoryName: params["DirectoryName"],
      OrganizationalUnitDistinguishedNames: params["OrganizationalUnitDistinguishedNames"],
      ServiceAccountCredentials: fromServiceAccountCredentials(params["ServiceAccountCredentials"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDirectoryConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryConfig": toDirectoryConfig,
      },
    }, await resp.json());
  }

  async createFleet(
    {abortSignal, ...params}: RequestConfig & s.CreateFleetRequest,
  ): Promise<s.CreateFleetResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ImageName: params["ImageName"],
      ImageArn: params["ImageArn"],
      InstanceType: params["InstanceType"],
      FleetType: params["FleetType"],
      ComputeCapacity: fromComputeCapacity(params["ComputeCapacity"]),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      MaxUserDurationInSeconds: params["MaxUserDurationInSeconds"],
      DisconnectTimeoutInSeconds: params["DisconnectTimeoutInSeconds"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      EnableDefaultInternetAccess: params["EnableDefaultInternetAccess"],
      DomainJoinInfo: fromDomainJoinInfo(params["DomainJoinInfo"]),
      Tags: params["Tags"],
      IdleDisconnectTimeoutInSeconds: params["IdleDisconnectTimeoutInSeconds"],
      IamRoleArn: params["IamRoleArn"],
      StreamView: params["StreamView"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Fleet": toFleet,
      },
    }, await resp.json());
  }

  async createImageBuilder(
    {abortSignal, ...params}: RequestConfig & s.CreateImageBuilderRequest,
  ): Promise<s.CreateImageBuilderResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ImageName: params["ImageName"],
      ImageArn: params["ImageArn"],
      InstanceType: params["InstanceType"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      IamRoleArn: params["IamRoleArn"],
      EnableDefaultInternetAccess: params["EnableDefaultInternetAccess"],
      DomainJoinInfo: fromDomainJoinInfo(params["DomainJoinInfo"]),
      AppstreamAgentVersion: params["AppstreamAgentVersion"],
      Tags: params["Tags"],
      AccessEndpoints: params["AccessEndpoints"]?.map(x => fromAccessEndpoint(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImageBuilder",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageBuilder": toImageBuilder,
      },
    }, await resp.json());
  }

  async createImageBuilderStreamingURL(
    {abortSignal, ...params}: RequestConfig & s.CreateImageBuilderStreamingURLRequest,
  ): Promise<s.CreateImageBuilderStreamingURLResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Validity: params["Validity"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImageBuilderStreamingURL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamingURL": "s",
        "Expires": "d",
      },
    }, await resp.json());
  }

  async createStack(
    {abortSignal, ...params}: RequestConfig & s.CreateStackRequest,
  ): Promise<s.CreateStackResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      StorageConnectors: params["StorageConnectors"]?.map(x => fromStorageConnector(x)),
      RedirectURL: params["RedirectURL"],
      FeedbackURL: params["FeedbackURL"],
      UserSettings: params["UserSettings"]?.map(x => fromUserSetting(x)),
      ApplicationSettings: fromApplicationSettings(params["ApplicationSettings"]),
      Tags: params["Tags"],
      AccessEndpoints: params["AccessEndpoints"]?.map(x => fromAccessEndpoint(x)),
      EmbedHostDomains: params["EmbedHostDomains"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stack": toStack,
      },
    }, await resp.json());
  }

  async createStreamingURL(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamingURLRequest,
  ): Promise<s.CreateStreamingURLResult> {
    const body: jsonP.JSONObject = {
      StackName: params["StackName"],
      FleetName: params["FleetName"],
      UserId: params["UserId"],
      ApplicationId: params["ApplicationId"],
      Validity: params["Validity"],
      SessionContext: params["SessionContext"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingURL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamingURL": "s",
        "Expires": "d",
      },
    }, await resp.json());
  }

  async createUsageReportSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateUsageReportSubscriptionRequest = {},
  ): Promise<s.CreateUsageReportSubscriptionResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUsageReportSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "S3BucketName": "s",
        "Schedule": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageReportSchedule>(x),
      },
    }, await resp.json());
  }

  async createUser(
    {abortSignal, ...params}: RequestConfig & s.CreateUserRequest,
  ): Promise<s.CreateUserResult> {
    const body: jsonP.JSONObject = {
      UserName: params["UserName"],
      MessageAction: params["MessageAction"],
      FirstName: params["FirstName"],
      LastName: params["LastName"],
      AuthenticationType: params["AuthenticationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDirectoryConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectoryConfigRequest,
  ): Promise<s.DeleteDirectoryConfigResult> {
    const body: jsonP.JSONObject = {
      DirectoryName: params["DirectoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDirectoryConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteFleet(
    {abortSignal, ...params}: RequestConfig & s.DeleteFleetRequest,
  ): Promise<s.DeleteFleetResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImage(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageRequest,
  ): Promise<s.DeleteImageResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Image": toImage,
      },
    }, await resp.json());
  }

  async deleteImageBuilder(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageBuilderRequest,
  ): Promise<s.DeleteImageBuilderResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImageBuilder",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageBuilder": toImageBuilder,
      },
    }, await resp.json());
  }

  async deleteImagePermissions(
    {abortSignal, ...params}: RequestConfig & s.DeleteImagePermissionsRequest,
  ): Promise<s.DeleteImagePermissionsResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      SharedAccountId: params["SharedAccountId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImagePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteStack(
    {abortSignal, ...params}: RequestConfig & s.DeleteStackRequest,
  ): Promise<s.DeleteStackResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteUsageReportSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteUsageReportSubscriptionRequest = {},
  ): Promise<s.DeleteUsageReportSubscriptionResult> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUsageReportSubscription",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteUser(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserRequest,
  ): Promise<s.DeleteUserResult> {
    const body: jsonP.JSONObject = {
      UserName: params["UserName"],
      AuthenticationType: params["AuthenticationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeDirectoryConfigs(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectoryConfigsRequest = {},
  ): Promise<s.DescribeDirectoryConfigsResult> {
    const body: jsonP.JSONObject = {
      DirectoryNames: params["DirectoryNames"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectoryConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryConfigs": [toDirectoryConfig],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeFleets(
    {abortSignal, ...params}: RequestConfig & s.DescribeFleetsRequest = {},
  ): Promise<s.DescribeFleetsResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Fleets": [toFleet],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeImageBuilders(
    {abortSignal, ...params}: RequestConfig & s.DescribeImageBuildersRequest = {},
  ): Promise<s.DescribeImageBuildersResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageBuilders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageBuilders": [toImageBuilder],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeImagePermissions(
    {abortSignal, ...params}: RequestConfig & s.DescribeImagePermissionsRequest,
  ): Promise<s.DescribeImagePermissionsResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      MaxResults: params["MaxResults"],
      SharedAwsAccountIds: params["SharedAwsAccountIds"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImagePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "SharedImagePermissionsList": [toSharedImagePermissions],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeImages(
    {abortSignal, ...params}: RequestConfig & s.DescribeImagesRequest = {},
  ): Promise<s.DescribeImagesResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      Arns: params["Arns"],
      Type: params["Type"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Images": [toImage],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeSessions(
    {abortSignal, ...params}: RequestConfig & s.DescribeSessionsRequest,
  ): Promise<s.DescribeSessionsResult> {
    const body: jsonP.JSONObject = {
      StackName: params["StackName"],
      FleetName: params["FleetName"],
      UserId: params["UserId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
      AuthenticationType: params["AuthenticationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSessions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Sessions": [toSession],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeStacks(
    {abortSignal, ...params}: RequestConfig & s.DescribeStacksRequest = {},
  ): Promise<s.DescribeStacksResult> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStacks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stacks": [toStack],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeUsageReportSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeUsageReportSubscriptionsRequest = {},
  ): Promise<s.DescribeUsageReportSubscriptionsResult> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsageReportSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UsageReportSubscriptions": [toUsageReportSubscription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeUserStackAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserStackAssociationsRequest = {},
  ): Promise<s.DescribeUserStackAssociationsResult> {
    const body: jsonP.JSONObject = {
      StackName: params["StackName"],
      UserName: params["UserName"],
      AuthenticationType: params["AuthenticationType"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserStackAssociations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserStackAssociations": [toUserStackAssociation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeUsers(
    {abortSignal, ...params}: RequestConfig & s.DescribeUsersRequest,
  ): Promise<s.DescribeUsersResult> {
    const body: jsonP.JSONObject = {
      AuthenticationType: params["AuthenticationType"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUsers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Users": [toUser],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disableUser(
    {abortSignal, ...params}: RequestConfig & s.DisableUserRequest,
  ): Promise<s.DisableUserResult> {
    const body: jsonP.JSONObject = {
      UserName: params["UserName"],
      AuthenticationType: params["AuthenticationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disassociateFleet(
    {abortSignal, ...params}: RequestConfig & s.DisassociateFleetRequest,
  ): Promise<s.DisassociateFleetResult> {
    const body: jsonP.JSONObject = {
      FleetName: params["FleetName"],
      StackName: params["StackName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async enableUser(
    {abortSignal, ...params}: RequestConfig & s.EnableUserRequest,
  ): Promise<s.EnableUserResult> {
    const body: jsonP.JSONObject = {
      UserName: params["UserName"],
      AuthenticationType: params["AuthenticationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableUser",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async expireSession(
    {abortSignal, ...params}: RequestConfig & s.ExpireSessionRequest,
  ): Promise<s.ExpireSessionResult> {
    const body: jsonP.JSONObject = {
      SessionId: params["SessionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExpireSession",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listAssociatedFleets(
    {abortSignal, ...params}: RequestConfig & s.ListAssociatedFleetsRequest,
  ): Promise<s.ListAssociatedFleetsResult> {
    const body: jsonP.JSONObject = {
      StackName: params["StackName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociatedFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Names": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAssociatedStacks(
    {abortSignal, ...params}: RequestConfig & s.ListAssociatedStacksRequest,
  ): Promise<s.ListAssociatedStacksResult> {
    const body: jsonP.JSONObject = {
      FleetName: params["FleetName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociatedStacks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Names": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async startFleet(
    {abortSignal, ...params}: RequestConfig & s.StartFleetRequest,
  ): Promise<s.StartFleetResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startImageBuilder(
    {abortSignal, ...params}: RequestConfig & s.StartImageBuilderRequest,
  ): Promise<s.StartImageBuilderResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      AppstreamAgentVersion: params["AppstreamAgentVersion"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImageBuilder",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageBuilder": toImageBuilder,
      },
    }, await resp.json());
  }

  async stopFleet(
    {abortSignal, ...params}: RequestConfig & s.StopFleetRequest,
  ): Promise<s.StopFleetResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopImageBuilder(
    {abortSignal, ...params}: RequestConfig & s.StopImageBuilderRequest,
  ): Promise<s.StopImageBuilderResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopImageBuilder",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageBuilder": toImageBuilder,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDirectoryConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateDirectoryConfigRequest,
  ): Promise<s.UpdateDirectoryConfigResult> {
    const body: jsonP.JSONObject = {
      DirectoryName: params["DirectoryName"],
      OrganizationalUnitDistinguishedNames: params["OrganizationalUnitDistinguishedNames"],
      ServiceAccountCredentials: fromServiceAccountCredentials(params["ServiceAccountCredentials"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDirectoryConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryConfig": toDirectoryConfig,
      },
    }, await resp.json());
  }

  async updateFleet(
    {abortSignal, ...params}: RequestConfig & s.UpdateFleetRequest = {},
  ): Promise<s.UpdateFleetResult> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
      ImageArn: params["ImageArn"],
      Name: params["Name"],
      InstanceType: params["InstanceType"],
      ComputeCapacity: fromComputeCapacity(params["ComputeCapacity"]),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      MaxUserDurationInSeconds: params["MaxUserDurationInSeconds"],
      DisconnectTimeoutInSeconds: params["DisconnectTimeoutInSeconds"],
      DeleteVpcConfig: params["DeleteVpcConfig"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      EnableDefaultInternetAccess: params["EnableDefaultInternetAccess"],
      DomainJoinInfo: fromDomainJoinInfo(params["DomainJoinInfo"]),
      IdleDisconnectTimeoutInSeconds: params["IdleDisconnectTimeoutInSeconds"],
      AttributesToDelete: params["AttributesToDelete"],
      IamRoleArn: params["IamRoleArn"],
      StreamView: params["StreamView"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Fleet": toFleet,
      },
    }, await resp.json());
  }

  async updateImagePermissions(
    {abortSignal, ...params}: RequestConfig & s.UpdateImagePermissionsRequest,
  ): Promise<s.UpdateImagePermissionsResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      SharedAccountId: params["SharedAccountId"],
      ImagePermissions: fromImagePermissions(params["ImagePermissions"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateImagePermissions",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateStack(
    {abortSignal, ...params}: RequestConfig & s.UpdateStackRequest,
  ): Promise<s.UpdateStackResult> {
    const body: jsonP.JSONObject = {
      DisplayName: params["DisplayName"],
      Description: params["Description"],
      Name: params["Name"],
      StorageConnectors: params["StorageConnectors"]?.map(x => fromStorageConnector(x)),
      DeleteStorageConnectors: params["DeleteStorageConnectors"],
      RedirectURL: params["RedirectURL"],
      FeedbackURL: params["FeedbackURL"],
      AttributesToDelete: params["AttributesToDelete"],
      UserSettings: params["UserSettings"]?.map(x => fromUserSetting(x)),
      ApplicationSettings: fromApplicationSettings(params["ApplicationSettings"]),
      AccessEndpoints: params["AccessEndpoints"]?.map(x => fromAccessEndpoint(x)),
      EmbedHostDomains: params["EmbedHostDomains"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStack",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Stack": toStack,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForFleetStarted(
    params: RequestConfig & s.DescribeFleetsRequest,
  ): Promise<s.DescribeFleetsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FleetStarted';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeFleets(params);
      const field = resp?.Fleets?.flatMap(x => x?.State);
      if (field?.every(x => x === "ACTIVE")) return resp;
      if (field?.some(x => x === "PENDING_DEACTIVATE")) throw new Error(errMessage);
      if (field?.some(x => x === "INACTIVE")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 40 times, 30 seconds apart (about 20 minutes max wait time). */
  async waitForFleetStopped(
    params: RequestConfig & s.DescribeFleetsRequest,
  ): Promise<s.DescribeFleetsResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FleetStopped';
    for (let i = 0; i < 40; i++) {
      const resp = await this.describeFleets(params);
      const field = resp?.Fleets?.flatMap(x => x?.State);
      if (field?.every(x => x === "INACTIVE")) return resp;
      if (field?.some(x => x === "PENDING_ACTIVATE")) throw new Error(errMessage);
      if (field?.some(x => x === "ACTIVE")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function fromUserStackAssociation(input?: s.UserStackAssociation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StackName: input["StackName"],
    UserName: input["UserName"],
    AuthenticationType: input["AuthenticationType"],
    SendEmailNotification: input["SendEmailNotification"],
  }
}
function toUserStackAssociation(root: jsonP.JSONValue): s.UserStackAssociation {
  return jsonP.readObj({
    required: {
      "StackName": "s",
      "UserName": "s",
      "AuthenticationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationType>(x),
    },
    optional: {
      "SendEmailNotification": "b",
    },
  }, root);
}

function fromServiceAccountCredentials(input?: s.ServiceAccountCredentials | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccountName: input["AccountName"],
    AccountPassword: input["AccountPassword"],
  }
}
function toServiceAccountCredentials(root: jsonP.JSONValue): s.ServiceAccountCredentials {
  return jsonP.readObj({
    required: {
      "AccountName": "s",
      "AccountPassword": "s",
    },
    optional: {},
  }, root);
}

function fromComputeCapacity(input?: s.ComputeCapacity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DesiredInstances: input["DesiredInstances"],
  }
}

function fromVpcConfig(input?: s.VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): s.VpcConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIds": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

function fromDomainJoinInfo(input?: s.DomainJoinInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DirectoryName: input["DirectoryName"],
    OrganizationalUnitDistinguishedName: input["OrganizationalUnitDistinguishedName"],
  }
}
function toDomainJoinInfo(root: jsonP.JSONValue): s.DomainJoinInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryName": "s",
      "OrganizationalUnitDistinguishedName": "s",
    },
  }, root);
}

function fromAccessEndpoint(input?: s.AccessEndpoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointType: input["EndpointType"],
    VpceId: input["VpceId"],
  }
}
function toAccessEndpoint(root: jsonP.JSONValue): s.AccessEndpoint {
  return jsonP.readObj({
    required: {
      "EndpointType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AccessEndpointType>(x),
    },
    optional: {
      "VpceId": "s",
    },
  }, root);
}

function fromStorageConnector(input?: s.StorageConnector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectorType: input["ConnectorType"],
    ResourceIdentifier: input["ResourceIdentifier"],
    Domains: input["Domains"],
  }
}
function toStorageConnector(root: jsonP.JSONValue): s.StorageConnector {
  return jsonP.readObj({
    required: {
      "ConnectorType": (x: jsonP.JSONValue) => cmnP.readEnum<s.StorageConnectorType>(x),
    },
    optional: {
      "ResourceIdentifier": "s",
      "Domains": ["s"],
    },
  }, root);
}

function fromUserSetting(input?: s.UserSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Permission: input["Permission"],
  }
}
function toUserSetting(root: jsonP.JSONValue): s.UserSetting {
  return jsonP.readObj({
    required: {
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<s.Action>(x),
      "Permission": (x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x),
    },
    optional: {},
  }, root);
}

function fromApplicationSettings(input?: s.ApplicationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    SettingsGroup: input["SettingsGroup"],
  }
}

function fromImagePermissions(input?: s.ImagePermissions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    allowFleet: input["allowFleet"],
    allowImageBuilder: input["allowImageBuilder"],
  }
}
function toImagePermissions(root: jsonP.JSONValue): s.ImagePermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "allowFleet": "b",
      "allowImageBuilder": "b",
    },
  }, root);
}

function toUserStackAssociationError(root: jsonP.JSONValue): s.UserStackAssociationError {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserStackAssociation": toUserStackAssociation,
      "ErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserStackAssociationErrorCode>(x),
      "ErrorMessage": "s",
    },
  }, root);
}

function toDirectoryConfig(root: jsonP.JSONValue): s.DirectoryConfig {
  return jsonP.readObj({
    required: {
      "DirectoryName": "s",
    },
    optional: {
      "OrganizationalUnitDistinguishedNames": ["s"],
      "ServiceAccountCredentials": toServiceAccountCredentials,
      "CreatedTime": "d",
    },
  }, root);
}

function toFleet(root: jsonP.JSONValue): s.Fleet {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "Name": "s",
      "InstanceType": "s",
      "ComputeCapacityStatus": toComputeCapacityStatus,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetState>(x),
    },
    optional: {
      "DisplayName": "s",
      "Description": "s",
      "ImageName": "s",
      "ImageArn": "s",
      "FleetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetType>(x),
      "MaxUserDurationInSeconds": "n",
      "DisconnectTimeoutInSeconds": "n",
      "VpcConfig": toVpcConfig,
      "CreatedTime": "d",
      "FleetErrors": [toFleetError],
      "EnableDefaultInternetAccess": "b",
      "DomainJoinInfo": toDomainJoinInfo,
      "IdleDisconnectTimeoutInSeconds": "n",
      "IamRoleArn": "s",
      "StreamView": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamView>(x),
    },
  }, root);
}

function toComputeCapacityStatus(root: jsonP.JSONValue): s.ComputeCapacityStatus {
  return jsonP.readObj({
    required: {
      "Desired": "n",
    },
    optional: {
      "Running": "n",
      "InUse": "n",
      "Available": "n",
    },
  }, root);
}

function toFleetError(root: jsonP.JSONValue): s.FleetError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetErrorCode>(x),
      "ErrorMessage": "s",
    },
  }, root);
}

function toImageBuilder(root: jsonP.JSONValue): s.ImageBuilder {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Arn": "s",
      "ImageArn": "s",
      "Description": "s",
      "DisplayName": "s",
      "VpcConfig": toVpcConfig,
      "InstanceType": "s",
      "Platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x),
      "IamRoleArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageBuilderState>(x),
      "StateChangeReason": toImageBuilderStateChangeReason,
      "CreatedTime": "d",
      "EnableDefaultInternetAccess": "b",
      "DomainJoinInfo": toDomainJoinInfo,
      "NetworkAccessConfiguration": toNetworkAccessConfiguration,
      "ImageBuilderErrors": [toResourceError],
      "AppstreamAgentVersion": "s",
      "AccessEndpoints": [toAccessEndpoint],
    },
  }, root);
}

function toImageBuilderStateChangeReason(root: jsonP.JSONValue): s.ImageBuilderStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageBuilderStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toNetworkAccessConfiguration(root: jsonP.JSONValue): s.NetworkAccessConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "EniPrivateIpAddress": "s",
      "EniId": "s",
    },
  }, root);
}

function toResourceError(root: jsonP.JSONValue): s.ResourceError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FleetErrorCode>(x),
      "ErrorMessage": "s",
      "ErrorTimestamp": "d",
    },
  }, root);
}

function toStack(root: jsonP.JSONValue): s.Stack {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Arn": "s",
      "Description": "s",
      "DisplayName": "s",
      "CreatedTime": "d",
      "StorageConnectors": [toStorageConnector],
      "RedirectURL": "s",
      "FeedbackURL": "s",
      "StackErrors": [toStackError],
      "UserSettings": [toUserSetting],
      "ApplicationSettings": toApplicationSettingsResponse,
      "AccessEndpoints": [toAccessEndpoint],
      "EmbedHostDomains": ["s"],
    },
  }, root);
}

function toStackError(root: jsonP.JSONValue): s.StackError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StackErrorCode>(x),
      "ErrorMessage": "s",
    },
  }, root);
}

function toApplicationSettingsResponse(root: jsonP.JSONValue): s.ApplicationSettingsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "SettingsGroup": "s",
      "S3BucketName": "s",
    },
  }, root);
}

function toImage(root: jsonP.JSONValue): s.Image {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Arn": "s",
      "BaseImageArn": "s",
      "DisplayName": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageState>(x),
      "Visibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.VisibilityType>(x),
      "ImageBuilderSupported": "b",
      "ImageBuilderName": "s",
      "Platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x),
      "Description": "s",
      "StateChangeReason": toImageStateChangeReason,
      "Applications": [toApplication],
      "CreatedTime": "d",
      "PublicBaseImageReleasedDate": "d",
      "AppstreamAgentVersion": "s",
      "ImagePermissions": toImagePermissions,
    },
  }, root);
}

function toImageStateChangeReason(root: jsonP.JSONValue): s.ImageStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

function toApplication(root: jsonP.JSONValue): s.Application {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DisplayName": "s",
      "IconURL": "s",
      "LaunchPath": "s",
      "LaunchParameters": "s",
      "Enabled": "b",
      "Metadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toSharedImagePermissions(root: jsonP.JSONValue): s.SharedImagePermissions {
  return jsonP.readObj({
    required: {
      "sharedAccountId": "s",
      "imagePermissions": toImagePermissions,
    },
    optional: {},
  }, root);
}

function toSession(root: jsonP.JSONValue): s.Session {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "UserId": "s",
      "StackName": "s",
      "FleetName": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.SessionState>(x),
    },
    optional: {
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.SessionConnectionState>(x),
      "StartTime": "d",
      "MaxExpirationTime": "d",
      "AuthenticationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationType>(x),
      "NetworkAccessConfiguration": toNetworkAccessConfiguration,
    },
  }, root);
}

function toUsageReportSubscription(root: jsonP.JSONValue): s.UsageReportSubscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3BucketName": "s",
      "Schedule": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageReportSchedule>(x),
      "LastGeneratedReportDate": "d",
      "SubscriptionErrors": [toLastReportGenerationExecutionError],
    },
  }, root);
}

function toLastReportGenerationExecutionError(root: jsonP.JSONValue): s.LastReportGenerationExecutionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageReportExecutionErrorCode>(x),
      "ErrorMessage": "s",
    },
  }, root);
}

function toUser(root: jsonP.JSONValue): s.User {
  return jsonP.readObj({
    required: {
      "AuthenticationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationType>(x),
    },
    optional: {
      "Arn": "s",
      "UserName": "s",
      "Enabled": "b",
      "Status": "s",
      "FirstName": "s",
      "LastName": "s",
      "CreatedTime": "d",
    },
  }, root);
}
