// Autogenerated API client for: Amazon DocumentDB with MongoDB compatibility

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class DocDB {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DocDB.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2014-10-31",
    "endpointPrefix": "rds",
    "protocol": "query",
    "serviceAbbreviation": "Amazon DocDB",
    "serviceFullName": "Amazon DocumentDB with MongoDB compatibility",
    "serviceId": "DocDB",
    "signatureVersion": "v4",
    "signingName": "rds",
    "uid": "docdb-2014-10-31",
    "xmlNamespace": "http://rds.amazonaws.com/doc/2014-10-31/"
  };

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
  }

  async applyPendingMaintenanceAction(
    {abortSignal, ...params}: RequestConfig & ApplyPendingMaintenanceActionMessage,
  ): Promise<ApplyPendingMaintenanceActionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceIdentifier", (params["ResourceIdentifier"] ?? '').toString());
    body.append(prefix+"ApplyAction", (params["ApplyAction"] ?? '').toString());
    body.append(prefix+"OptInType", (params["OptInType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyPendingMaintenanceAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ApplyPendingMaintenanceActionResult");
    return {
      ResourcePendingMaintenanceActions: xml.first("ResourcePendingMaintenanceActions", false, ResourcePendingMaintenanceActions_Parse),
    };
  }

  async copyDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & CopyDBClusterParameterGroupMessage,
  ): Promise<CopyDBClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBClusterParameterGroupIdentifier", (params["SourceDBClusterParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterParameterGroupIdentifier", (params["TargetDBClusterParameterGroupIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterParameterGroupDescription", (params["TargetDBClusterParameterGroupDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyDBClusterParameterGroupResult");
    return {
      DBClusterParameterGroup: xml.first("DBClusterParameterGroup", false, DBClusterParameterGroup_Parse),
    };
  }

  async copyDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CopyDBClusterSnapshotMessage,
  ): Promise<CopyDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBClusterSnapshotIdentifier", (params["SourceDBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBClusterSnapshotIdentifier", (params["TargetDBClusterSnapshotIdentifier"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if ("CopyTags" in params) body.append(prefix+"CopyTags", (params["CopyTags"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async createDBCluster(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterMessage,
  ): Promise<CreateDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("StorageEncrypted" in params) body.append(prefix+"StorageEncrypted", (params["StorageEncrypted"] ?? '').toString());
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if ("PreSignedUrl" in params) body.append(prefix+"PreSignedUrl", (params["PreSignedUrl"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) qsP.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async createDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterParameterGroupMessage,
  ): Promise<CreateDBClusterParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBClusterParameterGroupResult");
    return {
      DBClusterParameterGroup: xml.first("DBClusterParameterGroup", false, DBClusterParameterGroup_Parse),
    };
  }

  async createDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateDBClusterSnapshotMessage,
  ): Promise<CreateDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async createDBInstance(
    {abortSignal, ...params}: RequestConfig & CreateDBInstanceMessage,
  ): Promise<CreateDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("PromotionTier" in params) body.append(prefix+"PromotionTier", (params["PromotionTier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBSubnetGroupMessage,
  ): Promise<CreateDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async deleteDBCluster(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterMessage,
  ): Promise<DeleteDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("SkipFinalSnapshot" in params) body.append(prefix+"SkipFinalSnapshot", (params["SkipFinalSnapshot"] ?? '').toString());
    if ("FinalDBSnapshotIdentifier" in params) body.append(prefix+"FinalDBSnapshotIdentifier", (params["FinalDBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async deleteDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBClusterParameterGroup",
    });
  }

  async deleteDBClusterSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteDBClusterSnapshotMessage,
  ): Promise<DeleteDBClusterSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBClusterSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBClusterSnapshotResult");
    return {
      DBClusterSnapshot: xml.first("DBClusterSnapshot", false, DBClusterSnapshot_Parse),
    };
  }

  async deleteDBInstance(
    {abortSignal, ...params}: RequestConfig & DeleteDBInstanceMessage,
  ): Promise<DeleteDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async deleteDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSubnetGroup",
    });
  }

  async describeCertificates(
    {abortSignal, ...params}: RequestConfig & DescribeCertificatesMessage = {},
  ): Promise<CertificateMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("CertificateIdentifier" in params) body.append(prefix+"CertificateIdentifier", (params["CertificateIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificates",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeCertificatesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Certificates: xml.getList("Certificates", "Certificate").map(Certificate_Parse),
    };
  }

  async describeDBClusterParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterParameterGroupsMessage = {},
  ): Promise<DBClusterParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBClusterParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterParameterGroups: xml.getList("DBClusterParameterGroups", "DBClusterParameterGroup").map(DBClusterParameterGroup_Parse),
    };
  }

  async describeDBClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterParametersMessage,
  ): Promise<DBClusterParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBClusterParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeDBClusterSnapshotAttributes(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterSnapshotAttributesMessage,
  ): Promise<DescribeDBClusterSnapshotAttributesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterSnapshotAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBClusterSnapshotAttributesResult");
    return {
      DBClusterSnapshotAttributesResult: xml.first("DBClusterSnapshotAttributesResult", false, DBClusterSnapshotAttributesResult_Parse),
    };
  }

  async describeDBClusterSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeDBClusterSnapshotsMessage = {},
  ): Promise<DBClusterSnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("DBClusterSnapshotIdentifier" in params) body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("IncludeShared" in params) body.append(prefix+"IncludeShared", (params["IncludeShared"] ?? '').toString());
    if ("IncludePublic" in params) body.append(prefix+"IncludePublic", (params["IncludePublic"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusterSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBClusterSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusterSnapshots: xml.getList("DBClusterSnapshots", "DBClusterSnapshot").map(DBClusterSnapshot_Parse),
    };
  }

  async describeDBClusters(
    {abortSignal, ...params}: RequestConfig & DescribeDBClustersMessage = {},
  ): Promise<DBClusterMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBClusters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBClustersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBClusters: xml.getList("DBClusters", "DBCluster").map(DBCluster_Parse),
    };
  }

  async describeDBEngineVersions(
    {abortSignal, ...params}: RequestConfig & DescribeDBEngineVersionsMessage = {},
  ): Promise<DBEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBParameterGroupFamily" in params) body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    if ("ListSupportedCharacterSets" in params) body.append(prefix+"ListSupportedCharacterSets", (params["ListSupportedCharacterSets"] ?? '').toString());
    if ("ListSupportedTimezones" in params) body.append(prefix+"ListSupportedTimezones", (params["ListSupportedTimezones"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBEngineVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBEngineVersions: xml.getList("DBEngineVersions", "DBEngineVersion").map(DBEngineVersion_Parse),
    };
  }

  async describeDBInstances(
    {abortSignal, ...params}: RequestConfig & DescribeDBInstancesMessage = {},
  ): Promise<DBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBInstances: xml.getList("DBInstances", "DBInstance").map(DBInstance_Parse),
    };
  }

  async describeDBSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBSubnetGroupsMessage = {},
  ): Promise<DBSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSubnetGroups: xml.getList("DBSubnetGroups", "DBSubnetGroup").map(DBSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultClusterParameters(
    {abortSignal, ...params}: RequestConfig & DescribeEngineDefaultClusterParametersMessage,
  ): Promise<DescribeEngineDefaultClusterParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultClusterParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEngineDefaultClusterParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & DescribeEventCategoriesMessage = {},
  ): Promise<EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeOrderableDBInstanceOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOrderableDBInstanceOptionsMessage,
  ): Promise<OrderableDBInstanceOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Vpc" in params) body.append(prefix+"Vpc", (params["Vpc"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableDBInstanceOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOrderableDBInstanceOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableDBInstanceOptions: xml.getList("OrderableDBInstanceOptions", "OrderableDBInstanceOption").map(OrderableDBInstanceOption_Parse),
    };
  }

  async describePendingMaintenanceActions(
    {abortSignal, ...params}: RequestConfig & DescribePendingMaintenanceActionsMessage = {},
  ): Promise<PendingMaintenanceActionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ResourceIdentifier" in params) body.append(prefix+"ResourceIdentifier", (params["ResourceIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePendingMaintenanceActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribePendingMaintenanceActionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      PendingMaintenanceActions: xml.getList("PendingMaintenanceActions", "ResourcePendingMaintenanceActions").map(ResourcePendingMaintenanceActions_Parse),
    };
  }

  async failoverDBCluster(
    {abortSignal, ...params}: RequestConfig & FailoverDBClusterMessage = {},
  ): Promise<FailoverDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBClusterIdentifier" in params) body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("TargetDBInstanceIdentifier" in params) body.append(prefix+"TargetDBInstanceIdentifier", (params["TargetDBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "FailoverDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "FailoverDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyDBCluster(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterMessage,
  ): Promise<ModifyDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    if ("NewDBClusterIdentifier" in params) body.append(prefix+"NewDBClusterIdentifier", (params["NewDBClusterIdentifier"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("DBClusterParameterGroupName" in params) body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if (params["CloudwatchLogsExportConfiguration"] != null) CloudwatchLogsExportConfiguration_Serialize(body, prefix+"CloudwatchLogsExportConfiguration", params["CloudwatchLogsExportConfiguration"]);
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async modifyDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterParameterGroupMessage,
  ): Promise<DBClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBClusterParameterGroupResult");
    return xml.strings({
      optional: {"DBClusterParameterGroupName":true},
    });
  }

  async modifyDBClusterSnapshotAttribute(
    {abortSignal, ...params}: RequestConfig & ModifyDBClusterSnapshotAttributeMessage,
  ): Promise<ModifyDBClusterSnapshotAttributeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterSnapshotIdentifier", (params["DBClusterSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"AttributeName", (params["AttributeName"] ?? '').toString());
    if (params["ValuesToAdd"]) qsP.appendList(body, prefix+"ValuesToAdd", params["ValuesToAdd"], {"entryPrefix":".AttributeValue."})
    if (params["ValuesToRemove"]) qsP.appendList(body, prefix+"ValuesToRemove", params["ValuesToRemove"], {"entryPrefix":".AttributeValue."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBClusterSnapshotAttribute",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBClusterSnapshotAttributeResult");
    return {
      DBClusterSnapshotAttributesResult: xml.first("DBClusterSnapshotAttributesResult", false, DBClusterSnapshotAttributesResult_Parse),
    };
  }

  async modifyDBInstance(
    {abortSignal, ...params}: RequestConfig & ModifyDBInstanceMessage,
  ): Promise<ModifyDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("NewDBInstanceIdentifier" in params) body.append(prefix+"NewDBInstanceIdentifier", (params["NewDBInstanceIdentifier"] ?? '').toString());
    if ("CACertificateIdentifier" in params) body.append(prefix+"CACertificateIdentifier", (params["CACertificateIdentifier"] ?? '').toString());
    if ("PromotionTier" in params) body.append(prefix+"PromotionTier", (params["PromotionTier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async modifyDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBSubnetGroupMessage,
  ): Promise<ModifyDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("DBSubnetGroupDescription" in params) body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async rebootDBInstance(
    {abortSignal, ...params}: RequestConfig & RebootDBInstanceMessage,
  ): Promise<RebootDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("ForceFailover" in params) body.append(prefix+"ForceFailover", (params["ForceFailover"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
  }

  async resetDBClusterParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetDBClusterParameterGroupMessage,
  ): Promise<DBClusterParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterParameterGroupName", (params["DBClusterParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDBClusterParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetDBClusterParameterGroupResult");
    return xml.strings({
      optional: {"DBClusterParameterGroupName":true},
    });
  }

  async restoreDBClusterFromSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreDBClusterFromSnapshotMessage,
  ): Promise<RestoreDBClusterFromSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["AvailabilityZones"]) qsP.appendList(body, prefix+"AvailabilityZones", params["AvailabilityZones"], {"entryPrefix":".AvailabilityZone."})
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SnapshotIdentifier", (params["SnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) qsP.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBClusterFromSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBClusterFromSnapshotResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async restoreDBClusterToPointInTime(
    {abortSignal, ...params}: RequestConfig & RestoreDBClusterToPointInTimeMessage,
  ): Promise<RestoreDBClusterToPointInTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDBClusterIdentifier", (params["SourceDBClusterIdentifier"] ?? '').toString());
    if ("RestoreToTime" in params) body.append(prefix+"RestoreToTime", qsP.encodeDate_iso8601(params["RestoreToTime"]));
    if ("UseLatestRestorableTime" in params) body.append(prefix+"UseLatestRestorableTime", (params["UseLatestRestorableTime"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("KmsKeyId" in params) body.append(prefix+"KmsKeyId", (params["KmsKeyId"] ?? '').toString());
    if (params["EnableCloudwatchLogsExports"]) qsP.appendList(body, prefix+"EnableCloudwatchLogsExports", params["EnableCloudwatchLogsExports"], {"entryPrefix":".member."})
    if ("DeletionProtection" in params) body.append(prefix+"DeletionProtection", (params["DeletionProtection"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBClusterToPointInTime",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBClusterToPointInTimeResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async startDBCluster(
    {abortSignal, ...params}: RequestConfig & StartDBClusterMessage,
  ): Promise<StartDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StartDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  async stopDBCluster(
    {abortSignal, ...params}: RequestConfig & StopDBClusterMessage,
  ): Promise<StopDBClusterResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBClusterIdentifier", (params["DBClusterIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopDBCluster",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "StopDBClusterResult");
    return {
      DBCluster: xml.first("DBCluster", false, DBCluster_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceAvailable(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceDeleted(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<Error | DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeDBInstances(params);
        const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
        if (field?.every(x => x === "deleted")) return resp;
        if (field?.some(x => x === "creating")) throw new Error(errMessage);
        if (field?.some(x => x === "modifying")) throw new Error(errMessage);
        if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
        if (field?.some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      } catch (err) {
        if (["DBInstanceNotFound"].includes(err.code)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsToResourceMessage {
  ResourceName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface ApplyPendingMaintenanceActionMessage {
  ResourceIdentifier: string;
  ApplyAction: string;
  OptInType: string;
}

// refs: 1 - tags: named, input
export interface CopyDBClusterParameterGroupMessage {
  SourceDBClusterParameterGroupIdentifier: string;
  TargetDBClusterParameterGroupIdentifier: string;
  TargetDBClusterParameterGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CopyDBClusterSnapshotMessage {
  SourceDBClusterSnapshotIdentifier: string;
  TargetDBClusterSnapshotIdentifier: string;
  KmsKeyId?: string | null;
  PreSignedUrl?: string | null;
  CopyTags?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterMessage {
  AvailabilityZones?: string[] | null;
  BackupRetentionPeriod?: number | null;
  DBClusterIdentifier: string;
  DBClusterParameterGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  DBSubnetGroupName?: string | null;
  Engine: string;
  EngineVersion?: string | null;
  Port?: number | null;
  MasterUsername: string;
  MasterUserPassword: string;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  Tags?: Tag[] | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  PreSignedUrl?: string | null;
  EnableCloudwatchLogsExports?: string[] | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  DBParameterGroupFamily: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBClusterSnapshotMessage {
  DBClusterSnapshotIdentifier: string;
  DBClusterIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBInstanceMessage {
  DBInstanceIdentifier: string;
  DBInstanceClass: string;
  Engine: string;
  AvailabilityZone?: string | null;
  PreferredMaintenanceWindow?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  Tags?: Tag[] | null;
  DBClusterIdentifier: string;
  PromotionTier?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription: string;
  SubnetIds: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterMessage {
  DBClusterIdentifier: string;
  SkipFinalSnapshot?: boolean | null;
  FinalDBSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBClusterSnapshotMessage {
  DBClusterSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBInstanceMessage {
  DBInstanceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSubnetGroupMessage {
  DBSubnetGroupName: string;
}

// refs: 1 - tags: named, input
export interface DescribeCertificatesMessage {
  CertificateIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterParameterGroupsMessage {
  DBClusterParameterGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterParametersMessage {
  DBClusterParameterGroupName: string;
  Source?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterSnapshotAttributesMessage {
  DBClusterSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DescribeDBClusterSnapshotsMessage {
  DBClusterIdentifier?: string | null;
  DBClusterSnapshotIdentifier?: string | null;
  SnapshotType?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  IncludeShared?: boolean | null;
  IncludePublic?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBClustersMessage {
  DBClusterIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBEngineVersionsMessage {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  DefaultOnly?: boolean | null;
  ListSupportedCharacterSets?: boolean | null;
  ListSupportedTimezones?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBInstancesMessage {
  DBInstanceIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSubnetGroupsMessage {
  DBSubnetGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEngineDefaultClusterParametersMessage {
  DBParameterGroupFamily: string;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventCategoriesMessage {
  SourceType?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  EventCategories?: string[] | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOrderableDBInstanceOptionsMessage {
  Engine: string;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  Vpc?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePendingMaintenanceActionsMessage {
  ResourceIdentifier?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
}

// refs: 1 - tags: named, input
export interface FailoverDBClusterMessage {
  DBClusterIdentifier?: string | null;
  TargetDBInstanceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceMessage {
  ResourceName: string;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterMessage {
  DBClusterIdentifier: string;
  NewDBClusterIdentifier?: string | null;
  ApplyImmediately?: boolean | null;
  BackupRetentionPeriod?: number | null;
  DBClusterParameterGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Port?: number | null;
  MasterUserPassword?: string | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  CloudwatchLogsExportConfiguration?: CloudwatchLogsExportConfiguration | null;
  EngineVersion?: string | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  Parameters: Parameter[];
}

// refs: 1 - tags: named, input
export interface ModifyDBClusterSnapshotAttributeMessage {
  DBClusterSnapshotIdentifier: string;
  AttributeName: string;
  ValuesToAdd?: string[] | null;
  ValuesToRemove?: string[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBInstanceMessage {
  DBInstanceIdentifier: string;
  DBInstanceClass?: string | null;
  ApplyImmediately?: boolean | null;
  PreferredMaintenanceWindow?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  NewDBInstanceIdentifier?: string | null;
  CACertificateIdentifier?: string | null;
  PromotionTier?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription?: string | null;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface RebootDBInstanceMessage {
  DBInstanceIdentifier: string;
  ForceFailover?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceMessage {
  ResourceName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface ResetDBClusterParameterGroupMessage {
  DBClusterParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  Parameters?: Parameter[] | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBClusterFromSnapshotMessage {
  AvailabilityZones?: string[] | null;
  DBClusterIdentifier: string;
  SnapshotIdentifier: string;
  Engine: string;
  EngineVersion?: string | null;
  Port?: number | null;
  DBSubnetGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  EnableCloudwatchLogsExports?: string[] | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBClusterToPointInTimeMessage {
  DBClusterIdentifier: string;
  SourceDBClusterIdentifier: string;
  RestoreToTime?: Date | number | null;
  UseLatestRestorableTime?: boolean | null;
  Port?: number | null;
  DBSubnetGroupName?: string | null;
  VpcSecurityGroupIds?: string[] | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
  EnableCloudwatchLogsExports?: string[] | null;
  DeletionProtection?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartDBClusterMessage {
  DBClusterIdentifier: string;
}

// refs: 1 - tags: named, input
export interface StopDBClusterMessage {
  DBClusterIdentifier: string;
}

// refs: 1 - tags: named, output
export interface ApplyPendingMaintenanceActionResult {
  ResourcePendingMaintenanceActions?: ResourcePendingMaintenanceActions | null;
}

// refs: 1 - tags: named, output
export interface CopyDBClusterParameterGroupResult {
  DBClusterParameterGroup?: DBClusterParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CopyDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface CreateDBClusterParameterGroupResult {
  DBClusterParameterGroup?: DBClusterParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBClusterSnapshotResult {
  DBClusterSnapshot?: DBClusterSnapshot | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CertificateMessage {
  Certificates: Certificate[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupsMessage {
  Marker?: string | null;
  DBClusterParameterGroups: DBClusterParameterGroup[];
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupDetails {
  Parameters: Parameter[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDBClusterSnapshotAttributesResult {
  DBClusterSnapshotAttributesResult?: DBClusterSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface DBClusterSnapshotMessage {
  Marker?: string | null;
  DBClusterSnapshots: DBClusterSnapshot[];
}

// refs: 1 - tags: named, output
export interface DBClusterMessage {
  Marker?: string | null;
  DBClusters: DBCluster[];
}

// refs: 1 - tags: named, output
export interface DBEngineVersionMessage {
  Marker?: string | null;
  DBEngineVersions: DBEngineVersion[];
}

// refs: 1 - tags: named, output
export interface DBInstanceMessage {
  Marker?: string | null;
  DBInstances: DBInstance[];
}

// refs: 1 - tags: named, output
export interface DBSubnetGroupMessage {
  Marker?: string | null;
  DBSubnetGroups: DBSubnetGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeEngineDefaultClusterParametersResult {
  EngineDefaults?: EngineDefaults | null;
}

// refs: 1 - tags: named, output
export interface EventCategoriesMessage {
  EventCategoriesMapList: EventCategoriesMap[];
}

// refs: 1 - tags: named, output
export interface EventsMessage {
  Marker?: string | null;
  Events: Event[];
}

// refs: 1 - tags: named, output
export interface OrderableDBInstanceOptionsMessage {
  OrderableDBInstanceOptions: OrderableDBInstanceOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface PendingMaintenanceActionsMessage {
  PendingMaintenanceActions: ResourcePendingMaintenanceActions[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface FailoverDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface TagListMessage {
  TagList: Tag[];
}

// refs: 1 - tags: named, output
export interface ModifyDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface DBClusterParameterGroupNameMessage {
  DBClusterParameterGroupName?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBClusterSnapshotAttributeResult {
  DBClusterSnapshotAttributesResult?: DBClusterSnapshotAttributesResult | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface RebootDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBClusterFromSnapshotResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBClusterToPointInTimeResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface StartDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 1 - tags: named, output
export interface StopDBClusterResult {
  DBCluster?: DBCluster | null;
}

// refs: 11 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 14 - tags: input, named, interface
export interface Filter {
  Name: string;
  Values: string[];
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".Value."})
}

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "db-instance"
| "db-parameter-group"
| "db-security-group"
| "db-snapshot"
| "db-cluster"
| "db-cluster-snapshot"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CloudwatchLogsExportConfiguration {
  EnableLogTypes?: string[] | null;
  DisableLogTypes?: string[] | null;
}
function CloudwatchLogsExportConfiguration_Serialize(body: URLSearchParams, prefix: string, params: CloudwatchLogsExportConfiguration) {
    if (params["EnableLogTypes"]) qsP.appendList(body, prefix+".EnableLogTypes", params["EnableLogTypes"], {"entryPrefix":".member."})
    if (params["DisableLogTypes"]) qsP.appendList(body, prefix+".DisableLogTypes", params["DisableLogTypes"], {"entryPrefix":".member."})
}

// refs: 4 - tags: input, named, interface, output
export interface Parameter {
  ParameterName?: string | null;
  ParameterValue?: string | null;
  Description?: string | null;
  Source?: string | null;
  ApplyType?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
  ApplyMethod?: ApplyMethod | null;
}
function Parameter_Serialize(body: URLSearchParams, prefix: string, params: Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
    if ("ApplyMethod" in params) body.append(prefix+".ApplyMethod", (params["ApplyMethod"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"ApplyType":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ApplyMethod: node.first("ApplyMethod", false, x => (x.content ?? '') as ApplyMethod),
  };
}

// refs: 4 - tags: input, named, enum, output
export type ApplyMethod =
| "immediate"
| "pending-reboot"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ResourcePendingMaintenanceActions {
  ResourceIdentifier?: string | null;
  PendingMaintenanceActionDetails: PendingMaintenanceAction[];
}
function ResourcePendingMaintenanceActions_Parse(node: xmlP.XmlNode): ResourcePendingMaintenanceActions {
  return {
    ...node.strings({
      optional: {"ResourceIdentifier":true},
    }),
    PendingMaintenanceActionDetails: node.getList("PendingMaintenanceActionDetails", "PendingMaintenanceAction").map(PendingMaintenanceAction_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface PendingMaintenanceAction {
  Action?: string | null;
  AutoAppliedAfterDate?: Date | number | null;
  ForcedApplyDate?: Date | number | null;
  OptInStatus?: string | null;
  CurrentApplyDate?: Date | number | null;
  Description?: string | null;
}
function PendingMaintenanceAction_Parse(node: xmlP.XmlNode): PendingMaintenanceAction {
  return {
    ...node.strings({
      optional: {"Action":true,"OptInStatus":true,"Description":true},
    }),
    AutoAppliedAfterDate: node.first("AutoAppliedAfterDate", false, x => xmlP.parseTimestamp(x.content)),
    ForcedApplyDate: node.first("ForcedApplyDate", false, x => xmlP.parseTimestamp(x.content)),
    CurrentApplyDate: node.first("CurrentApplyDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 3 - tags: output, named, interface
export interface DBClusterParameterGroup {
  DBClusterParameterGroupName?: string | null;
  DBParameterGroupFamily?: string | null;
  Description?: string | null;
  DBClusterParameterGroupArn?: string | null;
}
function DBClusterParameterGroup_Parse(node: xmlP.XmlNode): DBClusterParameterGroup {
  return node.strings({
    optional: {"DBClusterParameterGroupName":true,"DBParameterGroupFamily":true,"Description":true,"DBClusterParameterGroupArn":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface DBClusterSnapshot {
  AvailabilityZones: string[];
  DBClusterSnapshotIdentifier?: string | null;
  DBClusterIdentifier?: string | null;
  SnapshotCreateTime?: Date | number | null;
  Engine?: string | null;
  Status?: string | null;
  Port?: number | null;
  VpcId?: string | null;
  ClusterCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  EngineVersion?: string | null;
  SnapshotType?: string | null;
  PercentProgress?: number | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DBClusterSnapshotArn?: string | null;
  SourceDBClusterSnapshotArn?: string | null;
}
function DBClusterSnapshot_Parse(node: xmlP.XmlNode): DBClusterSnapshot {
  return {
    ...node.strings({
      optional: {"DBClusterSnapshotIdentifier":true,"DBClusterIdentifier":true,"Engine":true,"Status":true,"VpcId":true,"MasterUsername":true,"EngineVersion":true,"SnapshotType":true,"KmsKeyId":true,"DBClusterSnapshotArn":true,"SourceDBClusterSnapshotArn":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
  };
}

// refs: 9 - tags: output, named, interface
export interface DBCluster {
  AvailabilityZones: string[];
  BackupRetentionPeriod?: number | null;
  DBClusterIdentifier?: string | null;
  DBClusterParameterGroup?: string | null;
  DBSubnetGroup?: string | null;
  Status?: string | null;
  PercentProgress?: string | null;
  EarliestRestorableTime?: Date | number | null;
  Endpoint?: string | null;
  ReaderEndpoint?: string | null;
  MultiAZ?: boolean | null;
  Engine?: string | null;
  EngineVersion?: string | null;
  LatestRestorableTime?: Date | number | null;
  Port?: number | null;
  MasterUsername?: string | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  DBClusterMembers: DBClusterMember[];
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  HostedZoneId?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DbClusterResourceId?: string | null;
  DBClusterArn?: string | null;
  AssociatedRoles: DBClusterRole[];
  ClusterCreateTime?: Date | number | null;
  EnabledCloudwatchLogsExports: string[];
  DeletionProtection?: boolean | null;
}
function DBCluster_Parse(node: xmlP.XmlNode): DBCluster {
  return {
    ...node.strings({
      optional: {"DBClusterIdentifier":true,"DBClusterParameterGroup":true,"DBSubnetGroup":true,"Status":true,"PercentProgress":true,"Endpoint":true,"ReaderEndpoint":true,"Engine":true,"EngineVersion":true,"MasterUsername":true,"PreferredBackupWindow":true,"PreferredMaintenanceWindow":true,"HostedZoneId":true,"KmsKeyId":true,"DbClusterResourceId":true,"DBClusterArn":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(x => x.content ?? ''),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    EarliestRestorableTime: node.first("EarliestRestorableTime", false, x => xmlP.parseTimestamp(x.content)),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => xmlP.parseTimestamp(x.content)),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    DBClusterMembers: node.getList("DBClusterMembers", "DBClusterMember").map(DBClusterMember_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    AssociatedRoles: node.getList("AssociatedRoles", "DBClusterRole").map(DBClusterRole_Parse),
    ClusterCreateTime: node.first("ClusterCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    EnabledCloudwatchLogsExports: node.getList("EnabledCloudwatchLogsExports", "member").map(x => x.content ?? ''),
    DeletionProtection: node.first("DeletionProtection", false, x => x.content === 'true'),
  };
}

// refs: 9 - tags: output, named, interface
export interface DBClusterMember {
  DBInstanceIdentifier?: string | null;
  IsClusterWriter?: boolean | null;
  DBClusterParameterGroupStatus?: string | null;
  PromotionTier?: number | null;
}
function DBClusterMember_Parse(node: xmlP.XmlNode): DBClusterMember {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBClusterParameterGroupStatus":true},
    }),
    IsClusterWriter: node.first("IsClusterWriter", false, x => x.content === 'true'),
    PromotionTier: node.first("PromotionTier", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 14 - tags: output, named, interface
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string | null;
  Status?: string | null;
}
function VpcSecurityGroupMembership_Parse(node: xmlP.XmlNode): VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

// refs: 9 - tags: output, named, interface
export interface DBClusterRole {
  RoleArn?: string | null;
  Status?: string | null;
}
function DBClusterRole_Parse(node: xmlP.XmlNode): DBClusterRole {
  return node.strings({
    optional: {"RoleArn":true,"Status":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface DBInstance {
  DBInstanceIdentifier?: string | null;
  DBInstanceClass?: string | null;
  Engine?: string | null;
  DBInstanceStatus?: string | null;
  Endpoint?: Endpoint | null;
  InstanceCreateTime?: Date | number | null;
  PreferredBackupWindow?: string | null;
  BackupRetentionPeriod?: number | null;
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  AvailabilityZone?: string | null;
  DBSubnetGroup?: DBSubnetGroup | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: PendingModifiedValues | null;
  LatestRestorableTime?: Date | number | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  PubliclyAccessible?: boolean | null;
  StatusInfos: DBInstanceStatusInfo[];
  DBClusterIdentifier?: string | null;
  StorageEncrypted?: boolean | null;
  KmsKeyId?: string | null;
  DbiResourceId?: string | null;
  CACertificateIdentifier?: string | null;
  PromotionTier?: number | null;
  DBInstanceArn?: string | null;
  EnabledCloudwatchLogsExports: string[];
}
function DBInstance_Parse(node: xmlP.XmlNode): DBInstance {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBInstanceClass":true,"Engine":true,"DBInstanceStatus":true,"PreferredBackupWindow":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"EngineVersion":true,"DBClusterIdentifier":true,"KmsKeyId":true,"DbiResourceId":true,"CACertificateIdentifier":true,"DBInstanceArn":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    DBSubnetGroup: node.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => xmlP.parseTimestamp(x.content)),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    StatusInfos: node.getList("StatusInfos", "DBInstanceStatusInfo").map(DBInstanceStatusInfo_Parse),
    StorageEncrypted: node.first("StorageEncrypted", false, x => x.content === 'true'),
    PromotionTier: node.first("PromotionTier", false, x => parseInt(x.content ?? '0')),
    EnabledCloudwatchLogsExports: node.getList("EnabledCloudwatchLogsExports", "member").map(x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, interface
export interface Endpoint {
  Address?: string | null;
  Port?: number | null;
  HostedZoneId?: string | null;
}
function Endpoint_Parse(node: xmlP.XmlNode): Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true,"HostedZoneId":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 8 - tags: output, named, interface
export interface DBSubnetGroup {
  DBSubnetGroupName?: string | null;
  DBSubnetGroupDescription?: string | null;
  VpcId?: string | null;
  SubnetGroupStatus?: string | null;
  Subnets: Subnet[];
  DBSubnetGroupArn?: string | null;
}
function DBSubnetGroup_Parse(node: xmlP.XmlNode): DBSubnetGroup {
  return {
    ...node.strings({
      optional: {"DBSubnetGroupName":true,"DBSubnetGroupDescription":true,"VpcId":true,"SubnetGroupStatus":true,"DBSubnetGroupArn":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetStatus?: string | null;
}
function Subnet_Parse(node: xmlP.XmlNode): Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
  };
}

// refs: 9 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
}
function AvailabilityZone_Parse(node: xmlP.XmlNode): AvailabilityZone {
  return node.strings({
    optional: {"Name":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface PendingModifiedValues {
  DBInstanceClass?: string | null;
  AllocatedStorage?: number | null;
  MasterUserPassword?: string | null;
  Port?: number | null;
  BackupRetentionPeriod?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  DBInstanceIdentifier?: string | null;
  StorageType?: string | null;
  CACertificateIdentifier?: string | null;
  DBSubnetGroupName?: string | null;
  PendingCloudwatchLogsExports?: PendingCloudwatchLogsExports | null;
}
function PendingModifiedValues_Parse(node: xmlP.XmlNode): PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"DBInstanceClass":true,"MasterUserPassword":true,"EngineVersion":true,"LicenseModel":true,"DBInstanceIdentifier":true,"StorageType":true,"CACertificateIdentifier":true,"DBSubnetGroupName":true},
    }),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    PendingCloudwatchLogsExports: node.first("PendingCloudwatchLogsExports", false, PendingCloudwatchLogsExports_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface PendingCloudwatchLogsExports {
  LogTypesToEnable: string[];
  LogTypesToDisable: string[];
}
function PendingCloudwatchLogsExports_Parse(node: xmlP.XmlNode): PendingCloudwatchLogsExports {
  return {
    LogTypesToEnable: node.getList("LogTypesToEnable", "member").map(x => x.content ?? ''),
    LogTypesToDisable: node.getList("LogTypesToDisable", "member").map(x => x.content ?? ''),
  };
}

// refs: 5 - tags: output, named, interface
export interface DBInstanceStatusInfo {
  StatusType?: string | null;
  Normal?: boolean | null;
  Status?: string | null;
  Message?: string | null;
}
function DBInstanceStatusInfo_Parse(node: xmlP.XmlNode): DBInstanceStatusInfo {
  return {
    ...node.strings({
      optional: {"StatusType":true,"Status":true,"Message":true},
    }),
    Normal: node.first("Normal", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface Certificate {
  CertificateIdentifier?: string | null;
  CertificateType?: string | null;
  Thumbprint?: string | null;
  ValidFrom?: Date | number | null;
  ValidTill?: Date | number | null;
  CertificateArn?: string | null;
}
function Certificate_Parse(node: xmlP.XmlNode): Certificate {
  return {
    ...node.strings({
      optional: {"CertificateIdentifier":true,"CertificateType":true,"Thumbprint":true,"CertificateArn":true},
    }),
    ValidFrom: node.first("ValidFrom", false, x => xmlP.parseTimestamp(x.content)),
    ValidTill: node.first("ValidTill", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBClusterSnapshotAttributesResult {
  DBClusterSnapshotIdentifier?: string | null;
  DBClusterSnapshotAttributes: DBClusterSnapshotAttribute[];
}
function DBClusterSnapshotAttributesResult_Parse(node: xmlP.XmlNode): DBClusterSnapshotAttributesResult {
  return {
    ...node.strings({
      optional: {"DBClusterSnapshotIdentifier":true},
    }),
    DBClusterSnapshotAttributes: node.getList("DBClusterSnapshotAttributes", "DBClusterSnapshotAttribute").map(DBClusterSnapshotAttribute_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBClusterSnapshotAttribute {
  AttributeName?: string | null;
  AttributeValues: string[];
}
function DBClusterSnapshotAttribute_Parse(node: xmlP.XmlNode): DBClusterSnapshotAttribute {
  return {
    ...node.strings({
      optional: {"AttributeName":true},
    }),
    AttributeValues: node.getList("AttributeValues", "AttributeValue").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface DBEngineVersion {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  DBEngineDescription?: string | null;
  DBEngineVersionDescription?: string | null;
  ValidUpgradeTarget: UpgradeTarget[];
  ExportableLogTypes: string[];
  SupportsLogExportsToCloudwatchLogs?: boolean | null;
}
function DBEngineVersion_Parse(node: xmlP.XmlNode): DBEngineVersion {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBParameterGroupFamily":true,"DBEngineDescription":true,"DBEngineVersionDescription":true},
    }),
    ValidUpgradeTarget: node.getList("ValidUpgradeTarget", "UpgradeTarget").map(UpgradeTarget_Parse),
    ExportableLogTypes: node.getList("ExportableLogTypes", "member").map(x => x.content ?? ''),
    SupportsLogExportsToCloudwatchLogs: node.first("SupportsLogExportsToCloudwatchLogs", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface UpgradeTarget {
  Engine?: string | null;
  EngineVersion?: string | null;
  Description?: string | null;
  AutoUpgrade?: boolean | null;
  IsMajorVersionUpgrade?: boolean | null;
}
function UpgradeTarget_Parse(node: xmlP.XmlNode): UpgradeTarget {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"Description":true},
    }),
    AutoUpgrade: node.first("AutoUpgrade", false, x => x.content === 'true'),
    IsMajorVersionUpgrade: node.first("IsMajorVersionUpgrade", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface EngineDefaults {
  DBParameterGroupFamily?: string | null;
  Marker?: string | null;
  Parameters: Parameter[];
}
function EngineDefaults_Parse(node: xmlP.XmlNode): EngineDefaults {
  return {
    ...node.strings({
      optional: {"DBParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EventCategoriesMap {
  SourceType?: string | null;
  EventCategories: string[];
}
function EventCategoriesMap_Parse(node: xmlP.XmlNode): EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  EventCategories: string[];
  Date?: Date | number | null;
  SourceArn?: string | null;
}
function Event_Parse(node: xmlP.XmlNode): Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true,"SourceArn":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface OrderableDBInstanceOption {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  AvailabilityZones: AvailabilityZone[];
  Vpc?: boolean | null;
}
function OrderableDBInstanceOption_Parse(node: xmlP.XmlNode): OrderableDBInstanceOption {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBInstanceClass":true,"LicenseModel":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
    Vpc: node.first("Vpc", false, x => x.content === 'true'),
  };
}
