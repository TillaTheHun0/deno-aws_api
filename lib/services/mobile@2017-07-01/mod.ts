// Autogenerated API client for: AWS Mobile

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class Mobile {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Mobile.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-07-01",
    "endpointPrefix": "mobile",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS Mobile",
    "serviceId": "Mobile",
    "signatureVersion": "v4",
    "signingName": "AWSMobileHubService",
    "uid": "mobile-2017-07-01"
  };

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectRequest = {},
  ): Promise<s.CreateProjectResult> {
    const body = typeof params["contents"] === 'string' ? new TextEncoder().encode(params["contents"]) : params["contents"];
    const query = new URLSearchParams;
    if (params["name"] != null) query.set("name", params["name"]?.toString() ?? "");
    if (params["region"] != null) query.set("region", params["region"]?.toString() ?? "");
    if (params["snapshotId"] != null) query.set("snapshotId", params["snapshotId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateProject",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "details": toProjectDetails,
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectRequest,
  ): Promise<s.DeleteProjectResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/projects/${params["projectId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "deletedResources": [toResource],
        "orphanedResources": [toResource],
      },
    }, await resp.json());
  }

  async describeBundle(
    {abortSignal, ...params}: RequestConfig & s.DescribeBundleRequest,
  ): Promise<s.DescribeBundleResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBundle",
      method: "GET",
      requestUri: cmnP.encodePath`/bundles/${params["bundleId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "details": toBundleDetails,
      },
    }, await resp.json());
  }

  async describeProject(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectRequest,
  ): Promise<s.DescribeProjectResult> {
    const query = new URLSearchParams;
    query.set("projectId", params["projectId"]?.toString() ?? "");
    if (params["syncFromResources"] != null) query.set("syncFromResources", params["syncFromResources"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeProject",
      method: "GET",
      requestUri: "/project",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "details": toProjectDetails,
      },
    }, await resp.json());
  }

  async exportBundle(
    {abortSignal, ...params}: RequestConfig & s.ExportBundleRequest,
  ): Promise<s.ExportBundleResult> {
    const query = new URLSearchParams;
    if (params["projectId"] != null) query.set("projectId", params["projectId"]?.toString() ?? "");
    if (params["platform"] != null) query.set("platform", params["platform"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ExportBundle",
      requestUri: cmnP.encodePath`/bundles/${params["bundleId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "downloadUrl": "s",
      },
    }, await resp.json());
  }

  async exportProject(
    {abortSignal, ...params}: RequestConfig & s.ExportProjectRequest,
  ): Promise<s.ExportProjectResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ExportProject",
      requestUri: cmnP.encodePath`/exports/${params["projectId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "downloadUrl": "s",
        "shareUrl": "s",
        "snapshotId": "s",
      },
    }, await resp.json());
  }

  async listBundles(
    {abortSignal, ...params}: RequestConfig & s.ListBundlesRequest = {},
  ): Promise<s.ListBundlesResult> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListBundles",
      method: "GET",
      requestUri: "/bundles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bundleList": [toBundleDetails],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & s.ListProjectsRequest = {},
  ): Promise<s.ListProjectsResult> {
    const query = new URLSearchParams;
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProjects",
      method: "GET",
      requestUri: "/projects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "projects": [toProjectSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async updateProject(
    {abortSignal, ...params}: RequestConfig & s.UpdateProjectRequest,
  ): Promise<s.UpdateProjectResult> {
    const body = typeof params["contents"] === 'string' ? new TextEncoder().encode(params["contents"]) : params["contents"];
    const query = new URLSearchParams;
    query.set("projectId", params["projectId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateProject",
      requestUri: "/update",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "details": toProjectDetails,
      },
    }, await resp.json());
  }

}

function toProjectDetails(root: jsonP.JSONValue): s.ProjectDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "projectId": "s",
      "region": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectState>(x),
      "createdDate": "d",
      "lastUpdatedDate": "d",
      "consoleUrl": "s",
      "resources": [toResource],
    },
  }, root);
}

function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": "s",
      "name": "s",
      "arn": "s",
      "feature": "s",
      "attributes": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toBundleDetails(root: jsonP.JSONValue): s.BundleDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "bundleId": "s",
      "title": "s",
      "version": "s",
      "description": "s",
      "iconUrl": "s",
      "availablePlatforms": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Platform>(x)],
    },
  }, root);
}

function toProjectSummary(root: jsonP.JSONValue): s.ProjectSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "projectId": "s",
    },
  }, root);
}
