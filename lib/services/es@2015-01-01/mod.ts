// Autogenerated API client for: Amazon Elasticsearch Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ES {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ES.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-01-01",
    "endpointPrefix": "es",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Elasticsearch Service",
    "serviceId": "Elasticsearch Service",
    "signatureVersion": "v4",
    "uid": "es-2015-01-01"
  };

  async acceptInboundCrossClusterSearchConnection(
    {abortSignal, ...params}: RequestConfig & AcceptInboundCrossClusterSearchConnectionRequest,
  ): Promise<AcceptInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AcceptInboundCrossClusterSearchConnection",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}/accept`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ARN: params["ARN"],
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
      requestUri: "/2015-01-01/tags",
    });
  }

  async associatePackage(
    {abortSignal, ...params}: RequestConfig & AssociatePackageRequest,
  ): Promise<AssociatePackageResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AssociatePackage",
      requestUri: cmnP.encodePath`/2015-01-01/packages/associate/${params["PackageID"]}/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetails": toDomainPackageDetails,
      },
    }, await resp.json());
  }

  async cancelElasticsearchServiceSoftwareUpdate(
    {abortSignal, ...params}: RequestConfig & CancelElasticsearchServiceSoftwareUpdateRequest,
  ): Promise<CancelElasticsearchServiceSoftwareUpdateResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelElasticsearchServiceSoftwareUpdate",
      requestUri: "/2015-01-01/es/serviceSoftwareUpdate/cancel",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSoftwareOptions": toServiceSoftwareOptions,
      },
    }, await resp.json());
  }

  async createElasticsearchDomain(
    {abortSignal, ...params}: RequestConfig & CreateElasticsearchDomainRequest,
  ): Promise<CreateElasticsearchDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      ElasticsearchVersion: params["ElasticsearchVersion"],
      ElasticsearchClusterConfig: fromElasticsearchClusterConfig(params["ElasticsearchClusterConfig"]),
      EBSOptions: fromEBSOptions(params["EBSOptions"]),
      AccessPolicies: params["AccessPolicies"],
      SnapshotOptions: fromSnapshotOptions(params["SnapshotOptions"]),
      VPCOptions: fromVPCOptions(params["VPCOptions"]),
      CognitoOptions: fromCognitoOptions(params["CognitoOptions"]),
      EncryptionAtRestOptions: fromEncryptionAtRestOptions(params["EncryptionAtRestOptions"]),
      NodeToNodeEncryptionOptions: fromNodeToNodeEncryptionOptions(params["NodeToNodeEncryptionOptions"]),
      AdvancedOptions: params["AdvancedOptions"],
      LogPublishingOptions: jsonP.serializeMap(params["LogPublishingOptions"], x => fromLogPublishingOption(x)),
      DomainEndpointOptions: fromDomainEndpointOptions(params["DomainEndpointOptions"]),
      AdvancedSecurityOptions: fromAdvancedSecurityOptionsInput(params["AdvancedSecurityOptions"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateElasticsearchDomain",
      requestUri: "/2015-01-01/es/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
    }, await resp.json());
  }

  async createOutboundCrossClusterSearchConnection(
    {abortSignal, ...params}: RequestConfig & CreateOutboundCrossClusterSearchConnectionRequest,
  ): Promise<CreateOutboundCrossClusterSearchConnectionResponse> {
    const body: jsonP.JSONObject = {
      SourceDomainInfo: fromDomainInformation(params["SourceDomainInfo"]),
      DestinationDomainInfo: fromDomainInformation(params["DestinationDomainInfo"]),
      ConnectionAlias: params["ConnectionAlias"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOutboundCrossClusterSearchConnection",
      requestUri: "/2015-01-01/es/ccs/outboundConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SourceDomainInfo": toDomainInformation,
        "DestinationDomainInfo": toDomainInformation,
        "ConnectionAlias": "s",
        "ConnectionStatus": toOutboundCrossClusterSearchConnectionStatus,
        "CrossClusterSearchConnectionId": "s",
      },
    }, await resp.json());
  }

  async createPackage(
    {abortSignal, ...params}: RequestConfig & CreatePackageRequest,
  ): Promise<CreatePackageResponse> {
    const body: jsonP.JSONObject = {
      PackageName: params["PackageName"],
      PackageType: params["PackageType"],
      PackageDescription: params["PackageDescription"],
      PackageSource: fromPackageSource(params["PackageSource"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePackage",
      requestUri: "/2015-01-01/packages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async deleteElasticsearchDomain(
    {abortSignal, ...params}: RequestConfig & DeleteElasticsearchDomainRequest,
  ): Promise<DeleteElasticsearchDomainResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteElasticsearchDomain",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
    }, await resp.json());
  }

  async deleteElasticsearchServiceRole(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<void> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteElasticsearchServiceRole",
      method: "DELETE",
      requestUri: "/2015-01-01/es/role",
    });
  }

  async deleteInboundCrossClusterSearchConnection(
    {abortSignal, ...params}: RequestConfig & DeleteInboundCrossClusterSearchConnectionRequest,
  ): Promise<DeleteInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInboundCrossClusterSearchConnection",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async deleteOutboundCrossClusterSearchConnection(
    {abortSignal, ...params}: RequestConfig & DeleteOutboundCrossClusterSearchConnectionRequest,
  ): Promise<DeleteOutboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteOutboundCrossClusterSearchConnection",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/outboundConnection/${params["CrossClusterSearchConnectionId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toOutboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async deletePackage(
    {abortSignal, ...params}: RequestConfig & DeletePackageRequest,
  ): Promise<DeletePackageResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeletePackage",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async describeElasticsearchDomain(
    {abortSignal, ...params}: RequestConfig & DescribeElasticsearchDomainRequest,
  ): Promise<DescribeElasticsearchDomainResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeElasticsearchDomain",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {
        "DomainStatus": toElasticsearchDomainStatus,
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchDomainConfig(
    {abortSignal, ...params}: RequestConfig & DescribeElasticsearchDomainConfigRequest,
  ): Promise<DescribeElasticsearchDomainConfigResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeElasticsearchDomainConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}/config`,
    });
    return jsonP.readObj({
      required: {
        "DomainConfig": toElasticsearchDomainConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchDomains(
    {abortSignal, ...params}: RequestConfig & DescribeElasticsearchDomainsRequest,
  ): Promise<DescribeElasticsearchDomainsResponse> {
    const body: jsonP.JSONObject = {
      DomainNames: params["DomainNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeElasticsearchDomains",
      requestUri: "/2015-01-01/es/domain-info",
    });
    return jsonP.readObj({
      required: {
        "DomainStatusList": [toElasticsearchDomainStatus],
      },
      optional: {},
    }, await resp.json());
  }

  async describeElasticsearchInstanceTypeLimits(
    {abortSignal, ...params}: RequestConfig & DescribeElasticsearchInstanceTypeLimitsRequest,
  ): Promise<DescribeElasticsearchInstanceTypeLimitsResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeElasticsearchInstanceTypeLimits",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/instanceTypeLimits/${params["ElasticsearchVersion"]}/${params["InstanceType"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LimitsByRole": x => jsonP.readMap(String, toLimits, x),
      },
    }, await resp.json());
  }

  async describeInboundCrossClusterSearchConnections(
    {abortSignal, ...params}: RequestConfig & DescribeInboundCrossClusterSearchConnectionsRequest = {},
  ): Promise<DescribeInboundCrossClusterSearchConnectionsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInboundCrossClusterSearchConnections",
      requestUri: "/2015-01-01/es/ccs/inboundConnection/search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnections": [toInboundCrossClusterSearchConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeOutboundCrossClusterSearchConnections(
    {abortSignal, ...params}: RequestConfig & DescribeOutboundCrossClusterSearchConnectionsRequest = {},
  ): Promise<DescribeOutboundCrossClusterSearchConnectionsResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOutboundCrossClusterSearchConnections",
      requestUri: "/2015-01-01/es/ccs/outboundConnection/search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnections": [toOutboundCrossClusterSearchConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describePackages(
    {abortSignal, ...params}: RequestConfig & DescribePackagesRequest = {},
  ): Promise<DescribePackagesResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"]?.map(x => fromDescribePackagesFilter(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePackages",
      requestUri: "/2015-01-01/packages/describe",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetailsList": [toPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeReservedElasticsearchInstanceOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedElasticsearchInstanceOfferingsRequest = {},
  ): Promise<DescribeReservedElasticsearchInstanceOfferingsResponse> {
    const query = new URLSearchParams;
    if (params["ReservedElasticsearchInstanceOfferingId"] != null) query.set("offeringId", params["ReservedElasticsearchInstanceOfferingId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeReservedElasticsearchInstanceOfferings",
      method: "GET",
      requestUri: "/2015-01-01/es/reservedInstanceOfferings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ReservedElasticsearchInstanceOfferings": [toReservedElasticsearchInstanceOffering],
      },
    }, await resp.json());
  }

  async describeReservedElasticsearchInstances(
    {abortSignal, ...params}: RequestConfig & DescribeReservedElasticsearchInstancesRequest = {},
  ): Promise<DescribeReservedElasticsearchInstancesResponse> {
    const query = new URLSearchParams;
    if (params["ReservedElasticsearchInstanceId"] != null) query.set("reservationId", params["ReservedElasticsearchInstanceId"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeReservedElasticsearchInstances",
      method: "GET",
      requestUri: "/2015-01-01/es/reservedInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ReservedElasticsearchInstances": [toReservedElasticsearchInstance],
      },
    }, await resp.json());
  }

  async dissociatePackage(
    {abortSignal, ...params}: RequestConfig & DissociatePackageRequest,
  ): Promise<DissociatePackageResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DissociatePackage",
      requestUri: cmnP.encodePath`/2015-01-01/packages/dissociate/${params["PackageID"]}/${params["DomainName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetails": toDomainPackageDetails,
      },
    }, await resp.json());
  }

  async getCompatibleElasticsearchVersions(
    {abortSignal, ...params}: RequestConfig & GetCompatibleElasticsearchVersionsRequest = {},
  ): Promise<GetCompatibleElasticsearchVersionsResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCompatibleElasticsearchVersions",
      method: "GET",
      requestUri: "/2015-01-01/es/compatibleVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CompatibleElasticsearchVersions": [toCompatibleVersionsMap],
      },
    }, await resp.json());
  }

  async getPackageVersionHistory(
    {abortSignal, ...params}: RequestConfig & GetPackageVersionHistoryRequest,
  ): Promise<GetPackageVersionHistoryResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPackageVersionHistory",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}/history`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageID": "s",
        "PackageVersionHistoryList": [toPackageVersionHistory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUpgradeHistory(
    {abortSignal, ...params}: RequestConfig & GetUpgradeHistoryRequest,
  ): Promise<GetUpgradeHistoryResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUpgradeHistory",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/upgradeDomain/${params["DomainName"]}/history`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradeHistories": [toUpgradeHistory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUpgradeStatus(
    {abortSignal, ...params}: RequestConfig & GetUpgradeStatusRequest,
  ): Promise<GetUpgradeStatusResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUpgradeStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/upgradeDomain/${params["DomainName"]}/status`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UpgradeStep": (x: jsonP.JSONValue) => cmnP.readEnum<UpgradeStep>(x),
        "StepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<UpgradeStatus>(x),
        "UpgradeName": "s",
      },
    }, await resp.json());
  }

  async listDomainNames(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<ListDomainNamesResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListDomainNames",
      method: "GET",
      requestUri: "/2015-01-01/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainNames": [toDomainInfo],
      },
    }, await resp.json());
  }

  async listDomainsForPackage(
    {abortSignal, ...params}: RequestConfig & ListDomainsForPackageRequest,
  ): Promise<ListDomainsForPackageResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDomainsForPackage",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/packages/${params["PackageID"]}/domains`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetailsList": [toDomainPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listElasticsearchInstanceTypes(
    {abortSignal, ...params}: RequestConfig & ListElasticsearchInstanceTypesRequest,
  ): Promise<ListElasticsearchInstanceTypesResponse> {
    const query = new URLSearchParams;
    if (params["DomainName"] != null) query.set("domainName", params["DomainName"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListElasticsearchInstanceTypes",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/es/instanceTypes/${params["ElasticsearchVersion"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticsearchInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<ESPartitionInstanceType>(x)],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listElasticsearchVersions(
    {abortSignal, ...params}: RequestConfig & ListElasticsearchVersionsRequest = {},
  ): Promise<ListElasticsearchVersionsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListElasticsearchVersions",
      method: "GET",
      requestUri: "/2015-01-01/es/versions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ElasticsearchVersions": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPackagesForDomain(
    {abortSignal, ...params}: RequestConfig & ListPackagesForDomainRequest,
  ): Promise<ListPackagesForDomainResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackagesForDomain",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-01-01/domain/${params["DomainName"]}/packages`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainPackageDetailsList": [toDomainPackageDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & ListTagsRequest,
  ): Promise<ListTagsResponse> {
    const query = new URLSearchParams;
    query.set("arn", params["ARN"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTags",
      method: "GET",
      requestUri: "/2015-01-01/tags/",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TagList": [toTag],
      },
    }, await resp.json());
  }

  async purchaseReservedElasticsearchInstanceOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedElasticsearchInstanceOfferingRequest,
  ): Promise<PurchaseReservedElasticsearchInstanceOfferingResponse> {
    const body: jsonP.JSONObject = {
      ReservedElasticsearchInstanceOfferingId: params["ReservedElasticsearchInstanceOfferingId"],
      ReservationName: params["ReservationName"],
      InstanceCount: params["InstanceCount"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedElasticsearchInstanceOffering",
      requestUri: "/2015-01-01/es/purchaseReservedInstanceOffering",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedElasticsearchInstanceId": "s",
        "ReservationName": "s",
      },
    }, await resp.json());
  }

  async rejectInboundCrossClusterSearchConnection(
    {abortSignal, ...params}: RequestConfig & RejectInboundCrossClusterSearchConnectionRequest,
  ): Promise<RejectInboundCrossClusterSearchConnectionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RejectInboundCrossClusterSearchConnection",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-01-01/es/ccs/inboundConnection/${params["CrossClusterSearchConnectionId"]}/reject`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrossClusterSearchConnection": toInboundCrossClusterSearchConnection,
      },
    }, await resp.json());
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & RemoveTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ARN: params["ARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
      requestUri: "/2015-01-01/tags-removal",
    });
  }

  async startElasticsearchServiceSoftwareUpdate(
    {abortSignal, ...params}: RequestConfig & StartElasticsearchServiceSoftwareUpdateRequest,
  ): Promise<StartElasticsearchServiceSoftwareUpdateResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartElasticsearchServiceSoftwareUpdate",
      requestUri: "/2015-01-01/es/serviceSoftwareUpdate/start",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ServiceSoftwareOptions": toServiceSoftwareOptions,
      },
    }, await resp.json());
  }

  async updateElasticsearchDomainConfig(
    {abortSignal, ...params}: RequestConfig & UpdateElasticsearchDomainConfigRequest,
  ): Promise<UpdateElasticsearchDomainConfigResponse> {
    const body: jsonP.JSONObject = {
      ElasticsearchClusterConfig: fromElasticsearchClusterConfig(params["ElasticsearchClusterConfig"]),
      EBSOptions: fromEBSOptions(params["EBSOptions"]),
      SnapshotOptions: fromSnapshotOptions(params["SnapshotOptions"]),
      VPCOptions: fromVPCOptions(params["VPCOptions"]),
      CognitoOptions: fromCognitoOptions(params["CognitoOptions"]),
      AdvancedOptions: params["AdvancedOptions"],
      AccessPolicies: params["AccessPolicies"],
      LogPublishingOptions: jsonP.serializeMap(params["LogPublishingOptions"], x => fromLogPublishingOption(x)),
      DomainEndpointOptions: fromDomainEndpointOptions(params["DomainEndpointOptions"]),
      AdvancedSecurityOptions: fromAdvancedSecurityOptionsInput(params["AdvancedSecurityOptions"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateElasticsearchDomainConfig",
      requestUri: cmnP.encodePath`/2015-01-01/es/domain/${params["DomainName"]}/config`,
    });
    return jsonP.readObj({
      required: {
        "DomainConfig": toElasticsearchDomainConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async updatePackage(
    {abortSignal, ...params}: RequestConfig & UpdatePackageRequest,
  ): Promise<UpdatePackageResponse> {
    const body: jsonP.JSONObject = {
      PackageID: params["PackageID"],
      PackageSource: fromPackageSource(params["PackageSource"]),
      PackageDescription: params["PackageDescription"],
      CommitMessage: params["CommitMessage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePackage",
      requestUri: "/2015-01-01/packages/update",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PackageDetails": toPackageDetails,
      },
    }, await resp.json());
  }

  async upgradeElasticsearchDomain(
    {abortSignal, ...params}: RequestConfig & UpgradeElasticsearchDomainRequest,
  ): Promise<UpgradeElasticsearchDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      TargetVersion: params["TargetVersion"],
      PerformCheckOnly: params["PerformCheckOnly"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpgradeElasticsearchDomain",
      requestUri: "/2015-01-01/es/upgradeDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainName": "s",
        "TargetVersion": "s",
        "PerformCheckOnly": "b",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AcceptInboundCrossClusterSearchConnectionRequest {
  CrossClusterSearchConnectionId: string;
}

// refs: 1 - tags: named, input
export interface AddTagsRequest {
  ARN: string;
  TagList: Tag[];
}

// refs: 1 - tags: named, input
export interface AssociatePackageRequest {
  PackageID: string;
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface CancelElasticsearchServiceSoftwareUpdateRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface CreateElasticsearchDomainRequest {
  DomainName: string;
  ElasticsearchVersion?: string | null;
  ElasticsearchClusterConfig?: ElasticsearchClusterConfig | null;
  EBSOptions?: EBSOptions | null;
  AccessPolicies?: string | null;
  SnapshotOptions?: SnapshotOptions | null;
  VPCOptions?: VPCOptions | null;
  CognitoOptions?: CognitoOptions | null;
  EncryptionAtRestOptions?: EncryptionAtRestOptions | null;
  NodeToNodeEncryptionOptions?: NodeToNodeEncryptionOptions | null;
  AdvancedOptions?: { [key: string]: string | null | undefined } | null;
  LogPublishingOptions?: { [key in LogType]: LogPublishingOption | null | undefined } | null;
  DomainEndpointOptions?: DomainEndpointOptions | null;
  AdvancedSecurityOptions?: AdvancedSecurityOptionsInput | null;
}

// refs: 1 - tags: named, input
export interface CreateOutboundCrossClusterSearchConnectionRequest {
  SourceDomainInfo: DomainInformation;
  DestinationDomainInfo: DomainInformation;
  ConnectionAlias: string;
}

// refs: 1 - tags: named, input
export interface CreatePackageRequest {
  PackageName: string;
  PackageType: PackageType;
  PackageDescription?: string | null;
  PackageSource: PackageSource;
}

// refs: 1 - tags: named, input
export interface DeleteElasticsearchDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DeleteInboundCrossClusterSearchConnectionRequest {
  CrossClusterSearchConnectionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteOutboundCrossClusterSearchConnectionRequest {
  CrossClusterSearchConnectionId: string;
}

// refs: 1 - tags: named, input
export interface DeletePackageRequest {
  PackageID: string;
}

// refs: 1 - tags: named, input
export interface DescribeElasticsearchDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeElasticsearchDomainConfigRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeElasticsearchDomainsRequest {
  DomainNames: string[];
}

// refs: 1 - tags: named, input
export interface DescribeElasticsearchInstanceTypeLimitsRequest {
  DomainName?: string | null;
  InstanceType: ESPartitionInstanceType;
  ElasticsearchVersion: string;
}

// refs: 1 - tags: named, input
export interface DescribeInboundCrossClusterSearchConnectionsRequest {
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOutboundCrossClusterSearchConnectionsRequest {
  Filters?: Filter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePackagesRequest {
  Filters?: DescribePackagesFilter[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedElasticsearchInstanceOfferingsRequest {
  ReservedElasticsearchInstanceOfferingId?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedElasticsearchInstancesRequest {
  ReservedElasticsearchInstanceId?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DissociatePackageRequest {
  PackageID: string;
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface GetCompatibleElasticsearchVersionsRequest {
  DomainName?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPackageVersionHistoryRequest {
  PackageID: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUpgradeHistoryRequest {
  DomainName: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetUpgradeStatusRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface ListDomainsForPackageRequest {
  PackageID: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListElasticsearchInstanceTypesRequest {
  ElasticsearchVersion: string;
  DomainName?: string | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListElasticsearchVersionsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPackagesForDomainRequest {
  DomainName: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsRequest {
  ARN: string;
}

// refs: 1 - tags: named, input
export interface PurchaseReservedElasticsearchInstanceOfferingRequest {
  ReservedElasticsearchInstanceOfferingId: string;
  ReservationName: string;
  InstanceCount?: number | null;
}

// refs: 1 - tags: named, input
export interface RejectInboundCrossClusterSearchConnectionRequest {
  CrossClusterSearchConnectionId: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsRequest {
  ARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface StartElasticsearchServiceSoftwareUpdateRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface UpdateElasticsearchDomainConfigRequest {
  DomainName: string;
  ElasticsearchClusterConfig?: ElasticsearchClusterConfig | null;
  EBSOptions?: EBSOptions | null;
  SnapshotOptions?: SnapshotOptions | null;
  VPCOptions?: VPCOptions | null;
  CognitoOptions?: CognitoOptions | null;
  AdvancedOptions?: { [key: string]: string | null | undefined } | null;
  AccessPolicies?: string | null;
  LogPublishingOptions?: { [key in LogType]: LogPublishingOption | null | undefined } | null;
  DomainEndpointOptions?: DomainEndpointOptions | null;
  AdvancedSecurityOptions?: AdvancedSecurityOptionsInput | null;
}

// refs: 1 - tags: named, input
export interface UpdatePackageRequest {
  PackageID: string;
  PackageSource: PackageSource;
  PackageDescription?: string | null;
  CommitMessage?: string | null;
}

// refs: 1 - tags: named, input
export interface UpgradeElasticsearchDomainRequest {
  DomainName: string;
  TargetVersion: string;
  PerformCheckOnly?: boolean | null;
}

// refs: 1 - tags: named, output
export interface AcceptInboundCrossClusterSearchConnectionResponse {
  CrossClusterSearchConnection?: InboundCrossClusterSearchConnection | null;
}

// refs: 1 - tags: named, output
export interface AssociatePackageResponse {
  DomainPackageDetails?: DomainPackageDetails | null;
}

// refs: 1 - tags: named, output
export interface CancelElasticsearchServiceSoftwareUpdateResponse {
  ServiceSoftwareOptions?: ServiceSoftwareOptions | null;
}

// refs: 1 - tags: named, output
export interface CreateElasticsearchDomainResponse {
  DomainStatus?: ElasticsearchDomainStatus | null;
}

// refs: 1 - tags: named, output
export interface CreateOutboundCrossClusterSearchConnectionResponse {
  SourceDomainInfo?: DomainInformation | null;
  DestinationDomainInfo?: DomainInformation | null;
  ConnectionAlias?: string | null;
  ConnectionStatus?: OutboundCrossClusterSearchConnectionStatus | null;
  CrossClusterSearchConnectionId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePackageResponse {
  PackageDetails?: PackageDetails | null;
}

// refs: 1 - tags: named, output
export interface DeleteElasticsearchDomainResponse {
  DomainStatus?: ElasticsearchDomainStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteInboundCrossClusterSearchConnectionResponse {
  CrossClusterSearchConnection?: InboundCrossClusterSearchConnection | null;
}

// refs: 1 - tags: named, output
export interface DeleteOutboundCrossClusterSearchConnectionResponse {
  CrossClusterSearchConnection?: OutboundCrossClusterSearchConnection | null;
}

// refs: 1 - tags: named, output
export interface DeletePackageResponse {
  PackageDetails?: PackageDetails | null;
}

// refs: 1 - tags: named, output
export interface DescribeElasticsearchDomainResponse {
  DomainStatus: ElasticsearchDomainStatus;
}

// refs: 1 - tags: named, output
export interface DescribeElasticsearchDomainConfigResponse {
  DomainConfig: ElasticsearchDomainConfig;
}

// refs: 1 - tags: named, output
export interface DescribeElasticsearchDomainsResponse {
  DomainStatusList: ElasticsearchDomainStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeElasticsearchInstanceTypeLimitsResponse {
  LimitsByRole?: { [key: string]: Limits | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DescribeInboundCrossClusterSearchConnectionsResponse {
  CrossClusterSearchConnections?: InboundCrossClusterSearchConnection[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeOutboundCrossClusterSearchConnectionsResponse {
  CrossClusterSearchConnections?: OutboundCrossClusterSearchConnection[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribePackagesResponse {
  PackageDetailsList?: PackageDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeReservedElasticsearchInstanceOfferingsResponse {
  NextToken?: string | null;
  ReservedElasticsearchInstanceOfferings?: ReservedElasticsearchInstanceOffering[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeReservedElasticsearchInstancesResponse {
  NextToken?: string | null;
  ReservedElasticsearchInstances?: ReservedElasticsearchInstance[] | null;
}

// refs: 1 - tags: named, output
export interface DissociatePackageResponse {
  DomainPackageDetails?: DomainPackageDetails | null;
}

// refs: 1 - tags: named, output
export interface GetCompatibleElasticsearchVersionsResponse {
  CompatibleElasticsearchVersions?: CompatibleVersionsMap[] | null;
}

// refs: 1 - tags: named, output
export interface GetPackageVersionHistoryResponse {
  PackageID?: string | null;
  PackageVersionHistoryList?: PackageVersionHistory[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetUpgradeHistoryResponse {
  UpgradeHistories?: UpgradeHistory[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetUpgradeStatusResponse {
  UpgradeStep?: UpgradeStep | null;
  StepStatus?: UpgradeStatus | null;
  UpgradeName?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDomainNamesResponse {
  DomainNames?: DomainInfo[] | null;
}

// refs: 1 - tags: named, output
export interface ListDomainsForPackageResponse {
  DomainPackageDetailsList?: DomainPackageDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListElasticsearchInstanceTypesResponse {
  ElasticsearchInstanceTypes?: ESPartitionInstanceType[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListElasticsearchVersionsResponse {
  ElasticsearchVersions?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPackagesForDomainResponse {
  DomainPackageDetailsList?: DomainPackageDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsResponse {
  TagList?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedElasticsearchInstanceOfferingResponse {
  ReservedElasticsearchInstanceId?: string | null;
  ReservationName?: string | null;
}

// refs: 1 - tags: named, output
export interface RejectInboundCrossClusterSearchConnectionResponse {
  CrossClusterSearchConnection?: InboundCrossClusterSearchConnection | null;
}

// refs: 1 - tags: named, output
export interface StartElasticsearchServiceSoftwareUpdateResponse {
  ServiceSoftwareOptions?: ServiceSoftwareOptions | null;
}

// refs: 1 - tags: named, output
export interface UpdateElasticsearchDomainConfigResponse {
  DomainConfig: ElasticsearchDomainConfig;
}

// refs: 1 - tags: named, output
export interface UpdatePackageResponse {
  PackageDetails?: PackageDetails | null;
}

// refs: 1 - tags: named, output
export interface UpgradeElasticsearchDomainResponse {
  DomainName?: string | null;
  TargetVersion?: string | null;
  PerformCheckOnly?: boolean | null;
}

// refs: 2 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface ElasticsearchClusterConfig {
  InstanceType?: ESPartitionInstanceType | null;
  InstanceCount?: number | null;
  DedicatedMasterEnabled?: boolean | null;
  ZoneAwarenessEnabled?: boolean | null;
  ZoneAwarenessConfig?: ZoneAwarenessConfig | null;
  DedicatedMasterType?: ESPartitionInstanceType | null;
  DedicatedMasterCount?: number | null;
  WarmEnabled?: boolean | null;
  WarmType?: ESWarmPartitionInstanceType | null;
  WarmCount?: number | null;
}
function fromElasticsearchClusterConfig(input?: ElasticsearchClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    DedicatedMasterEnabled: input["DedicatedMasterEnabled"],
    ZoneAwarenessEnabled: input["ZoneAwarenessEnabled"],
    ZoneAwarenessConfig: fromZoneAwarenessConfig(input["ZoneAwarenessConfig"]),
    DedicatedMasterType: input["DedicatedMasterType"],
    DedicatedMasterCount: input["DedicatedMasterCount"],
    WarmEnabled: input["WarmEnabled"],
    WarmType: input["WarmType"],
    WarmCount: input["WarmCount"],
  }
}
function toElasticsearchClusterConfig(root: jsonP.JSONValue): ElasticsearchClusterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ESPartitionInstanceType>(x),
      "InstanceCount": "n",
      "DedicatedMasterEnabled": "b",
      "ZoneAwarenessEnabled": "b",
      "ZoneAwarenessConfig": toZoneAwarenessConfig,
      "DedicatedMasterType": (x: jsonP.JSONValue) => cmnP.readEnum<ESPartitionInstanceType>(x),
      "DedicatedMasterCount": "n",
      "WarmEnabled": "b",
      "WarmType": (x: jsonP.JSONValue) => cmnP.readEnum<ESWarmPartitionInstanceType>(x),
      "WarmCount": "n",
    },
  }, root);
}

// refs: 20 - tags: input, named, enum, output
export type ESPartitionInstanceType =
| "m3.medium.elasticsearch"
| "m3.large.elasticsearch"
| "m3.xlarge.elasticsearch"
| "m3.2xlarge.elasticsearch"
| "m4.large.elasticsearch"
| "m4.xlarge.elasticsearch"
| "m4.2xlarge.elasticsearch"
| "m4.4xlarge.elasticsearch"
| "m4.10xlarge.elasticsearch"
| "m5.large.elasticsearch"
| "m5.xlarge.elasticsearch"
| "m5.2xlarge.elasticsearch"
| "m5.4xlarge.elasticsearch"
| "m5.12xlarge.elasticsearch"
| "r5.large.elasticsearch"
| "r5.xlarge.elasticsearch"
| "r5.2xlarge.elasticsearch"
| "r5.4xlarge.elasticsearch"
| "r5.12xlarge.elasticsearch"
| "c5.large.elasticsearch"
| "c5.xlarge.elasticsearch"
| "c5.2xlarge.elasticsearch"
| "c5.4xlarge.elasticsearch"
| "c5.9xlarge.elasticsearch"
| "c5.18xlarge.elasticsearch"
| "ultrawarm1.medium.elasticsearch"
| "ultrawarm1.large.elasticsearch"
| "t2.micro.elasticsearch"
| "t2.small.elasticsearch"
| "t2.medium.elasticsearch"
| "r3.large.elasticsearch"
| "r3.xlarge.elasticsearch"
| "r3.2xlarge.elasticsearch"
| "r3.4xlarge.elasticsearch"
| "r3.8xlarge.elasticsearch"
| "i2.xlarge.elasticsearch"
| "i2.2xlarge.elasticsearch"
| "d2.xlarge.elasticsearch"
| "d2.2xlarge.elasticsearch"
| "d2.4xlarge.elasticsearch"
| "d2.8xlarge.elasticsearch"
| "c4.large.elasticsearch"
| "c4.xlarge.elasticsearch"
| "c4.2xlarge.elasticsearch"
| "c4.4xlarge.elasticsearch"
| "c4.8xlarge.elasticsearch"
| "r4.large.elasticsearch"
| "r4.xlarge.elasticsearch"
| "r4.2xlarge.elasticsearch"
| "r4.4xlarge.elasticsearch"
| "r4.8xlarge.elasticsearch"
| "r4.16xlarge.elasticsearch"
| "i3.large.elasticsearch"
| "i3.xlarge.elasticsearch"
| "i3.2xlarge.elasticsearch"
| "i3.4xlarge.elasticsearch"
| "i3.8xlarge.elasticsearch"
| "i3.16xlarge.elasticsearch"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface ZoneAwarenessConfig {
  AvailabilityZoneCount?: number | null;
}
function fromZoneAwarenessConfig(input?: ZoneAwarenessConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZoneCount: input["AvailabilityZoneCount"],
  }
}
function toZoneAwarenessConfig(root: jsonP.JSONValue): ZoneAwarenessConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZoneCount": "n",
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type ESWarmPartitionInstanceType =
| "ultrawarm1.medium.elasticsearch"
| "ultrawarm1.large.elasticsearch"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface EBSOptions {
  EBSEnabled?: boolean | null;
  VolumeType?: VolumeType | null;
  VolumeSize?: number | null;
  Iops?: number | null;
}
function fromEBSOptions(input?: EBSOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EBSEnabled: input["EBSEnabled"],
    VolumeType: input["VolumeType"],
    VolumeSize: input["VolumeSize"],
    Iops: input["Iops"],
  }
}
function toEBSOptions(root: jsonP.JSONValue): EBSOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "EBSEnabled": "b",
      "VolumeType": (x: jsonP.JSONValue) => cmnP.readEnum<VolumeType>(x),
      "VolumeSize": "n",
      "Iops": "n",
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type VolumeType =
| "standard"
| "gp2"
| "io1"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface SnapshotOptions {
  AutomatedSnapshotStartHour?: number | null;
}
function fromSnapshotOptions(input?: SnapshotOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomatedSnapshotStartHour: input["AutomatedSnapshotStartHour"],
  }
}
function toSnapshotOptions(root: jsonP.JSONValue): SnapshotOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomatedSnapshotStartHour": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface VPCOptions {
  SubnetIds?: string[] | null;
  SecurityGroupIds?: string[] | null;
}
function fromVPCOptions(input?: VPCOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

// refs: 8 - tags: input, named, interface, output
export interface CognitoOptions {
  Enabled?: boolean | null;
  UserPoolId?: string | null;
  IdentityPoolId?: string | null;
  RoleArn?: string | null;
}
function fromCognitoOptions(input?: CognitoOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    UserPoolId: input["UserPoolId"],
    IdentityPoolId: input["IdentityPoolId"],
    RoleArn: input["RoleArn"],
  }
}
function toCognitoOptions(root: jsonP.JSONValue): CognitoOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "UserPoolId": "s",
      "IdentityPoolId": "s",
      "RoleArn": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface EncryptionAtRestOptions {
  Enabled?: boolean | null;
  KmsKeyId?: string | null;
}
function fromEncryptionAtRestOptions(input?: EncryptionAtRestOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toEncryptionAtRestOptions(root: jsonP.JSONValue): EncryptionAtRestOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface NodeToNodeEncryptionOptions {
  Enabled?: boolean | null;
}
function fromNodeToNodeEncryptionOptions(input?: NodeToNodeEncryptionOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toNodeToNodeEncryptionOptions(root: jsonP.JSONValue): NodeToNodeEncryptionOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type LogType =
| "INDEX_SLOW_LOGS"
| "SEARCH_SLOW_LOGS"
| "ES_APPLICATION_LOGS"
| "AUDIT_LOGS"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface LogPublishingOption {
  CloudWatchLogsLogGroupArn?: string | null;
  Enabled?: boolean | null;
}
function fromLogPublishingOption(input?: LogPublishingOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchLogsLogGroupArn: input["CloudWatchLogsLogGroupArn"],
    Enabled: input["Enabled"],
  }
}
function toLogPublishingOption(root: jsonP.JSONValue): LogPublishingOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogsLogGroupArn": "s",
      "Enabled": "b",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface DomainEndpointOptions {
  EnforceHTTPS?: boolean | null;
  TLSSecurityPolicy?: TLSSecurityPolicy | null;
  CustomEndpointEnabled?: boolean | null;
  CustomEndpoint?: string | null;
  CustomEndpointCertificateArn?: string | null;
}
function fromDomainEndpointOptions(input?: DomainEndpointOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnforceHTTPS: input["EnforceHTTPS"],
    TLSSecurityPolicy: input["TLSSecurityPolicy"],
    CustomEndpointEnabled: input["CustomEndpointEnabled"],
    CustomEndpoint: input["CustomEndpoint"],
    CustomEndpointCertificateArn: input["CustomEndpointCertificateArn"],
  }
}
function toDomainEndpointOptions(root: jsonP.JSONValue): DomainEndpointOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnforceHTTPS": "b",
      "TLSSecurityPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<TLSSecurityPolicy>(x),
      "CustomEndpointEnabled": "b",
      "CustomEndpoint": "s",
      "CustomEndpointCertificateArn": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type TLSSecurityPolicy =
| "Policy-Min-TLS-1-0-2019-07"
| "Policy-Min-TLS-1-2-2019-07"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface AdvancedSecurityOptionsInput {
  Enabled?: boolean | null;
  InternalUserDatabaseEnabled?: boolean | null;
  MasterUserOptions?: MasterUserOptions | null;
  SAMLOptions?: SAMLOptionsInput | null;
}
function fromAdvancedSecurityOptionsInput(input?: AdvancedSecurityOptionsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    InternalUserDatabaseEnabled: input["InternalUserDatabaseEnabled"],
    MasterUserOptions: fromMasterUserOptions(input["MasterUserOptions"]),
    SAMLOptions: fromSAMLOptionsInput(input["SAMLOptions"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface MasterUserOptions {
  MasterUserARN?: string | null;
  MasterUserName?: string | null;
  MasterUserPassword?: string | null;
}
function fromMasterUserOptions(input?: MasterUserOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MasterUserARN: input["MasterUserARN"],
    MasterUserName: input["MasterUserName"],
    MasterUserPassword: input["MasterUserPassword"],
  }
}

// refs: 2 - tags: input, named, interface
export interface SAMLOptionsInput {
  Enabled?: boolean | null;
  Idp?: SAMLIdp | null;
  MasterUserName?: string | null;
  MasterBackendRole?: string | null;
  SubjectKey?: string | null;
  RolesKey?: string | null;
  SessionTimeoutMinutes?: number | null;
}
function fromSAMLOptionsInput(input?: SAMLOptionsInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    Idp: fromSAMLIdp(input["Idp"]),
    MasterUserName: input["MasterUserName"],
    MasterBackendRole: input["MasterBackendRole"],
    SubjectKey: input["SubjectKey"],
    RolesKey: input["RolesKey"],
    SessionTimeoutMinutes: input["SessionTimeoutMinutes"],
  }
}

// refs: 8 - tags: input, named, interface, output
export interface SAMLIdp {
  MetadataContent: string;
  EntityId: string;
}
function fromSAMLIdp(input?: SAMLIdp | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetadataContent: input["MetadataContent"],
    EntityId: input["EntityId"],
  }
}
function toSAMLIdp(root: jsonP.JSONValue): SAMLIdp {
  return jsonP.readObj({
    required: {
      "MetadataContent": "s",
      "EntityId": "s",
    },
    optional: {},
  }, root);
}

// refs: 16 - tags: input, named, interface, output
export interface DomainInformation {
  OwnerId?: string | null;
  DomainName: string;
  Region?: string | null;
}
function fromDomainInformation(input?: DomainInformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OwnerId: input["OwnerId"],
    DomainName: input["DomainName"],
    Region: input["Region"],
  }
}
function toDomainInformation(root: jsonP.JSONValue): DomainInformation {
  return jsonP.readObj({
    required: {
      "DomainName": "s",
    },
    optional: {
      "OwnerId": "s",
      "Region": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type PackageType =
| "TXT-DICTIONARY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface PackageSource {
  S3BucketName?: string | null;
  S3Key?: string | null;
}
function fromPackageSource(input?: PackageSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3BucketName: input["S3BucketName"],
    S3Key: input["S3Key"],
  }
}

// refs: 2 - tags: input, named, interface
export interface Filter {
  Name?: string | null;
  Values?: string[] | null;
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}

// refs: 1 - tags: input, named, interface
export interface DescribePackagesFilter {
  Name?: DescribePackagesFilterName | null;
  Value?: string[] | null;
}
function fromDescribePackagesFilter(input?: DescribePackagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}

// refs: 1 - tags: input, named, enum
export type DescribePackagesFilterName =
| "PackageID"
| "PackageName"
| "PackageStatus"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface InboundCrossClusterSearchConnection {
  SourceDomainInfo?: DomainInformation | null;
  DestinationDomainInfo?: DomainInformation | null;
  CrossClusterSearchConnectionId?: string | null;
  ConnectionStatus?: InboundCrossClusterSearchConnectionStatus | null;
}
function toInboundCrossClusterSearchConnection(root: jsonP.JSONValue): InboundCrossClusterSearchConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceDomainInfo": toDomainInformation,
      "DestinationDomainInfo": toDomainInformation,
      "CrossClusterSearchConnectionId": "s",
      "ConnectionStatus": toInboundCrossClusterSearchConnectionStatus,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface InboundCrossClusterSearchConnectionStatus {
  StatusCode?: InboundCrossClusterSearchConnectionStatusCode | null;
  Message?: string | null;
}
function toInboundCrossClusterSearchConnectionStatus(root: jsonP.JSONValue): InboundCrossClusterSearchConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<InboundCrossClusterSearchConnectionStatusCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type InboundCrossClusterSearchConnectionStatusCode =
| "PENDING_ACCEPTANCE"
| "APPROVED"
| "REJECTING"
| "REJECTED"
| "DELETING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface DomainPackageDetails {
  PackageID?: string | null;
  PackageName?: string | null;
  PackageType?: PackageType | null;
  LastUpdated?: Date | number | null;
  DomainName?: string | null;
  DomainPackageStatus?: DomainPackageStatus | null;
  PackageVersion?: string | null;
  ReferencePath?: string | null;
  ErrorDetails?: ErrorDetails | null;
}
function toDomainPackageDetails(root: jsonP.JSONValue): DomainPackageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageID": "s",
      "PackageName": "s",
      "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<PackageType>(x),
      "LastUpdated": "d",
      "DomainName": "s",
      "DomainPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DomainPackageStatus>(x),
      "PackageVersion": "s",
      "ReferencePath": "s",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type DomainPackageStatus =
| "ASSOCIATING"
| "ASSOCIATION_FAILED"
| "ACTIVE"
| "DISSOCIATING"
| "DISSOCIATION_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: output, named, interface
export interface ErrorDetails {
  ErrorType?: string | null;
  ErrorMessage?: string | null;
}
function toErrorDetails(root: jsonP.JSONValue): ErrorDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorType": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface ServiceSoftwareOptions {
  CurrentVersion?: string | null;
  NewVersion?: string | null;
  UpdateAvailable?: boolean | null;
  Cancellable?: boolean | null;
  UpdateStatus?: DeploymentStatus | null;
  Description?: string | null;
  AutomatedUpdateDate?: Date | number | null;
  OptionalDeployment?: boolean | null;
}
function toServiceSoftwareOptions(root: jsonP.JSONValue): ServiceSoftwareOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "CurrentVersion": "s",
      "NewVersion": "s",
      "UpdateAvailable": "b",
      "Cancellable": "b",
      "UpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeploymentStatus>(x),
      "Description": "s",
      "AutomatedUpdateDate": "d",
      "OptionalDeployment": "b",
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type DeploymentStatus =
| "PENDING_UPDATE"
| "IN_PROGRESS"
| "COMPLETED"
| "NOT_ELIGIBLE"
| "ELIGIBLE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface ElasticsearchDomainStatus {
  DomainId: string;
  DomainName: string;
  ARN: string;
  Created?: boolean | null;
  Deleted?: boolean | null;
  Endpoint?: string | null;
  Endpoints?: { [key: string]: string | null | undefined } | null;
  Processing?: boolean | null;
  UpgradeProcessing?: boolean | null;
  ElasticsearchVersion?: string | null;
  ElasticsearchClusterConfig: ElasticsearchClusterConfig;
  EBSOptions?: EBSOptions | null;
  AccessPolicies?: string | null;
  SnapshotOptions?: SnapshotOptions | null;
  VPCOptions?: VPCDerivedInfo | null;
  CognitoOptions?: CognitoOptions | null;
  EncryptionAtRestOptions?: EncryptionAtRestOptions | null;
  NodeToNodeEncryptionOptions?: NodeToNodeEncryptionOptions | null;
  AdvancedOptions?: { [key: string]: string | null | undefined } | null;
  LogPublishingOptions?: { [key in LogType]: LogPublishingOption | null | undefined } | null;
  ServiceSoftwareOptions?: ServiceSoftwareOptions | null;
  DomainEndpointOptions?: DomainEndpointOptions | null;
  AdvancedSecurityOptions?: AdvancedSecurityOptions | null;
}
function toElasticsearchDomainStatus(root: jsonP.JSONValue): ElasticsearchDomainStatus {
  return jsonP.readObj({
    required: {
      "DomainId": "s",
      "DomainName": "s",
      "ARN": "s",
      "ElasticsearchClusterConfig": toElasticsearchClusterConfig,
    },
    optional: {
      "Created": "b",
      "Deleted": "b",
      "Endpoint": "s",
      "Endpoints": x => jsonP.readMap(String, String, x),
      "Processing": "b",
      "UpgradeProcessing": "b",
      "ElasticsearchVersion": "s",
      "EBSOptions": toEBSOptions,
      "AccessPolicies": "s",
      "SnapshotOptions": toSnapshotOptions,
      "VPCOptions": toVPCDerivedInfo,
      "CognitoOptions": toCognitoOptions,
      "EncryptionAtRestOptions": toEncryptionAtRestOptions,
      "NodeToNodeEncryptionOptions": toNodeToNodeEncryptionOptions,
      "AdvancedOptions": x => jsonP.readMap(String, String, x),
      "LogPublishingOptions": x => jsonP.readMap(x => cmnP.readEnumReq<LogType>(x), toLogPublishingOption, x),
      "ServiceSoftwareOptions": toServiceSoftwareOptions,
      "DomainEndpointOptions": toDomainEndpointOptions,
      "AdvancedSecurityOptions": toAdvancedSecurityOptions,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface VPCDerivedInfo {
  VPCId?: string | null;
  SubnetIds?: string[] | null;
  AvailabilityZones?: string[] | null;
  SecurityGroupIds?: string[] | null;
}
function toVPCDerivedInfo(root: jsonP.JSONValue): VPCDerivedInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "VPCId": "s",
      "SubnetIds": ["s"],
      "AvailabilityZones": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface AdvancedSecurityOptions {
  Enabled?: boolean | null;
  InternalUserDatabaseEnabled?: boolean | null;
  SAMLOptions?: SAMLOptionsOutput | null;
}
function toAdvancedSecurityOptions(root: jsonP.JSONValue): AdvancedSecurityOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "InternalUserDatabaseEnabled": "b",
      "SAMLOptions": toSAMLOptionsOutput,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface SAMLOptionsOutput {
  Enabled?: boolean | null;
  Idp?: SAMLIdp | null;
  SubjectKey?: string | null;
  RolesKey?: string | null;
  SessionTimeoutMinutes?: number | null;
}
function toSAMLOptionsOutput(root: jsonP.JSONValue): SAMLOptionsOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "Idp": toSAMLIdp,
      "SubjectKey": "s",
      "RolesKey": "s",
      "SessionTimeoutMinutes": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface OutboundCrossClusterSearchConnectionStatus {
  StatusCode?: OutboundCrossClusterSearchConnectionStatusCode | null;
  Message?: string | null;
}
function toOutboundCrossClusterSearchConnectionStatus(root: jsonP.JSONValue): OutboundCrossClusterSearchConnectionStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusCode": (x: jsonP.JSONValue) => cmnP.readEnum<OutboundCrossClusterSearchConnectionStatusCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type OutboundCrossClusterSearchConnectionStatusCode =
| "PENDING_ACCEPTANCE"
| "VALIDATING"
| "VALIDATION_FAILED"
| "PROVISIONING"
| "ACTIVE"
| "REJECTED"
| "DELETING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface PackageDetails {
  PackageID?: string | null;
  PackageName?: string | null;
  PackageType?: PackageType | null;
  PackageDescription?: string | null;
  PackageStatus?: PackageStatus | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  AvailablePackageVersion?: string | null;
  ErrorDetails?: ErrorDetails | null;
}
function toPackageDetails(root: jsonP.JSONValue): PackageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageID": "s",
      "PackageName": "s",
      "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<PackageType>(x),
      "PackageDescription": "s",
      "PackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PackageStatus>(x),
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "AvailablePackageVersion": "s",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type PackageStatus =
| "COPYING"
| "COPY_FAILED"
| "VALIDATING"
| "VALIDATION_FAILED"
| "AVAILABLE"
| "DELETING"
| "DELETED"
| "DELETE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface OutboundCrossClusterSearchConnection {
  SourceDomainInfo?: DomainInformation | null;
  DestinationDomainInfo?: DomainInformation | null;
  CrossClusterSearchConnectionId?: string | null;
  ConnectionAlias?: string | null;
  ConnectionStatus?: OutboundCrossClusterSearchConnectionStatus | null;
}
function toOutboundCrossClusterSearchConnection(root: jsonP.JSONValue): OutboundCrossClusterSearchConnection {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceDomainInfo": toDomainInformation,
      "DestinationDomainInfo": toDomainInformation,
      "CrossClusterSearchConnectionId": "s",
      "ConnectionAlias": "s",
      "ConnectionStatus": toOutboundCrossClusterSearchConnectionStatus,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ElasticsearchDomainConfig {
  ElasticsearchVersion?: ElasticsearchVersionStatus | null;
  ElasticsearchClusterConfig?: ElasticsearchClusterConfigStatus | null;
  EBSOptions?: EBSOptionsStatus | null;
  AccessPolicies?: AccessPoliciesStatus | null;
  SnapshotOptions?: SnapshotOptionsStatus | null;
  VPCOptions?: VPCDerivedInfoStatus | null;
  CognitoOptions?: CognitoOptionsStatus | null;
  EncryptionAtRestOptions?: EncryptionAtRestOptionsStatus | null;
  NodeToNodeEncryptionOptions?: NodeToNodeEncryptionOptionsStatus | null;
  AdvancedOptions?: AdvancedOptionsStatus | null;
  LogPublishingOptions?: LogPublishingOptionsStatus | null;
  DomainEndpointOptions?: DomainEndpointOptionsStatus | null;
  AdvancedSecurityOptions?: AdvancedSecurityOptionsStatus | null;
}
function toElasticsearchDomainConfig(root: jsonP.JSONValue): ElasticsearchDomainConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ElasticsearchVersion": toElasticsearchVersionStatus,
      "ElasticsearchClusterConfig": toElasticsearchClusterConfigStatus,
      "EBSOptions": toEBSOptionsStatus,
      "AccessPolicies": toAccessPoliciesStatus,
      "SnapshotOptions": toSnapshotOptionsStatus,
      "VPCOptions": toVPCDerivedInfoStatus,
      "CognitoOptions": toCognitoOptionsStatus,
      "EncryptionAtRestOptions": toEncryptionAtRestOptionsStatus,
      "NodeToNodeEncryptionOptions": toNodeToNodeEncryptionOptionsStatus,
      "AdvancedOptions": toAdvancedOptionsStatus,
      "LogPublishingOptions": toLogPublishingOptionsStatus,
      "DomainEndpointOptions": toDomainEndpointOptionsStatus,
      "AdvancedSecurityOptions": toAdvancedSecurityOptionsStatus,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ElasticsearchVersionStatus {
  Options: string;
  Status: OptionStatus;
}
function toElasticsearchVersionStatus(root: jsonP.JSONValue): ElasticsearchVersionStatus {
  return jsonP.readObj({
    required: {
      "Options": "s",
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 26 - tags: output, named, interface
export interface OptionStatus {
  CreationDate: Date | number;
  UpdateDate: Date | number;
  UpdateVersion?: number | null;
  State: OptionState;
  PendingDeletion?: boolean | null;
}
function toOptionStatus(root: jsonP.JSONValue): OptionStatus {
  return jsonP.readObj({
    required: {
      "CreationDate": "d",
      "UpdateDate": "d",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<OptionState>(x),
    },
    optional: {
      "UpdateVersion": "n",
      "PendingDeletion": "b",
    },
  }, root);
}

// refs: 26 - tags: output, named, enum
export type OptionState =
| "RequiresIndexDocuments"
| "Processing"
| "Active"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ElasticsearchClusterConfigStatus {
  Options: ElasticsearchClusterConfig;
  Status: OptionStatus;
}
function toElasticsearchClusterConfigStatus(root: jsonP.JSONValue): ElasticsearchClusterConfigStatus {
  return jsonP.readObj({
    required: {
      "Options": toElasticsearchClusterConfig,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EBSOptionsStatus {
  Options: EBSOptions;
  Status: OptionStatus;
}
function toEBSOptionsStatus(root: jsonP.JSONValue): EBSOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toEBSOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AccessPoliciesStatus {
  Options: string;
  Status: OptionStatus;
}
function toAccessPoliciesStatus(root: jsonP.JSONValue): AccessPoliciesStatus {
  return jsonP.readObj({
    required: {
      "Options": "s",
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SnapshotOptionsStatus {
  Options: SnapshotOptions;
  Status: OptionStatus;
}
function toSnapshotOptionsStatus(root: jsonP.JSONValue): SnapshotOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toSnapshotOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface VPCDerivedInfoStatus {
  Options: VPCDerivedInfo;
  Status: OptionStatus;
}
function toVPCDerivedInfoStatus(root: jsonP.JSONValue): VPCDerivedInfoStatus {
  return jsonP.readObj({
    required: {
      "Options": toVPCDerivedInfo,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface CognitoOptionsStatus {
  Options: CognitoOptions;
  Status: OptionStatus;
}
function toCognitoOptionsStatus(root: jsonP.JSONValue): CognitoOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toCognitoOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EncryptionAtRestOptionsStatus {
  Options: EncryptionAtRestOptions;
  Status: OptionStatus;
}
function toEncryptionAtRestOptionsStatus(root: jsonP.JSONValue): EncryptionAtRestOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toEncryptionAtRestOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface NodeToNodeEncryptionOptionsStatus {
  Options: NodeToNodeEncryptionOptions;
  Status: OptionStatus;
}
function toNodeToNodeEncryptionOptionsStatus(root: jsonP.JSONValue): NodeToNodeEncryptionOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toNodeToNodeEncryptionOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AdvancedOptionsStatus {
  Options: { [key: string]: string | null | undefined };
  Status: OptionStatus;
}
function toAdvancedOptionsStatus(root: jsonP.JSONValue): AdvancedOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": x => jsonP.readMap(String, String, x),
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LogPublishingOptionsStatus {
  Options?: { [key in LogType]: LogPublishingOption | null | undefined } | null;
  Status?: OptionStatus | null;
}
function toLogPublishingOptionsStatus(root: jsonP.JSONValue): LogPublishingOptionsStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "Options": x => jsonP.readMap(x => cmnP.readEnumReq<LogType>(x), toLogPublishingOption, x),
      "Status": toOptionStatus,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface DomainEndpointOptionsStatus {
  Options: DomainEndpointOptions;
  Status: OptionStatus;
}
function toDomainEndpointOptionsStatus(root: jsonP.JSONValue): DomainEndpointOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toDomainEndpointOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AdvancedSecurityOptionsStatus {
  Options: AdvancedSecurityOptions;
  Status: OptionStatus;
}
function toAdvancedSecurityOptionsStatus(root: jsonP.JSONValue): AdvancedSecurityOptionsStatus {
  return jsonP.readObj({
    required: {
      "Options": toAdvancedSecurityOptions,
      "Status": toOptionStatus,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Limits {
  StorageTypes?: StorageType[] | null;
  InstanceLimits?: InstanceLimits | null;
  AdditionalLimits?: AdditionalLimit[] | null;
}
function toLimits(root: jsonP.JSONValue): Limits {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageTypes": [toStorageType],
      "InstanceLimits": toInstanceLimits,
      "AdditionalLimits": [toAdditionalLimit],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StorageType {
  StorageTypeName?: string | null;
  StorageSubTypeName?: string | null;
  StorageTypeLimits?: StorageTypeLimit[] | null;
}
function toStorageType(root: jsonP.JSONValue): StorageType {
  return jsonP.readObj({
    required: {},
    optional: {
      "StorageTypeName": "s",
      "StorageSubTypeName": "s",
      "StorageTypeLimits": [toStorageTypeLimit],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StorageTypeLimit {
  LimitName?: string | null;
  LimitValues?: string[] | null;
}
function toStorageTypeLimit(root: jsonP.JSONValue): StorageTypeLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "LimitName": "s",
      "LimitValues": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceLimits {
  InstanceCountLimits?: InstanceCountLimits | null;
}
function toInstanceLimits(root: jsonP.JSONValue): InstanceLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceCountLimits": toInstanceCountLimits,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceCountLimits {
  MinimumInstanceCount?: number | null;
  MaximumInstanceCount?: number | null;
}
function toInstanceCountLimits(root: jsonP.JSONValue): InstanceCountLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "MinimumInstanceCount": "n",
      "MaximumInstanceCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AdditionalLimit {
  LimitName?: string | null;
  LimitValues?: string[] | null;
}
function toAdditionalLimit(root: jsonP.JSONValue): AdditionalLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "LimitName": "s",
      "LimitValues": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservedElasticsearchInstanceOffering {
  ReservedElasticsearchInstanceOfferingId?: string | null;
  ElasticsearchInstanceType?: ESPartitionInstanceType | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  PaymentOption?: ReservedElasticsearchInstancePaymentOption | null;
  RecurringCharges?: RecurringCharge[] | null;
}
function toReservedElasticsearchInstanceOffering(root: jsonP.JSONValue): ReservedElasticsearchInstanceOffering {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservedElasticsearchInstanceOfferingId": "s",
      "ElasticsearchInstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ESPartitionInstanceType>(x),
      "Duration": "n",
      "FixedPrice": "n",
      "UsagePrice": "n",
      "CurrencyCode": "s",
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<ReservedElasticsearchInstancePaymentOption>(x),
      "RecurringCharges": [toRecurringCharge],
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ReservedElasticsearchInstancePaymentOption =
| "ALL_UPFRONT"
| "PARTIAL_UPFRONT"
| "NO_UPFRONT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface RecurringCharge {
  RecurringChargeAmount?: number | null;
  RecurringChargeFrequency?: string | null;
}
function toRecurringCharge(root: jsonP.JSONValue): RecurringCharge {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecurringChargeAmount": "n",
      "RecurringChargeFrequency": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReservedElasticsearchInstance {
  ReservationName?: string | null;
  ReservedElasticsearchInstanceId?: string | null;
  ReservedElasticsearchInstanceOfferingId?: string | null;
  ElasticsearchInstanceType?: ESPartitionInstanceType | null;
  StartTime?: Date | number | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  ElasticsearchInstanceCount?: number | null;
  State?: string | null;
  PaymentOption?: ReservedElasticsearchInstancePaymentOption | null;
  RecurringCharges?: RecurringCharge[] | null;
}
function toReservedElasticsearchInstance(root: jsonP.JSONValue): ReservedElasticsearchInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservationName": "s",
      "ReservedElasticsearchInstanceId": "s",
      "ReservedElasticsearchInstanceOfferingId": "s",
      "ElasticsearchInstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ESPartitionInstanceType>(x),
      "StartTime": "d",
      "Duration": "n",
      "FixedPrice": "n",
      "UsagePrice": "n",
      "CurrencyCode": "s",
      "ElasticsearchInstanceCount": "n",
      "State": "s",
      "PaymentOption": (x: jsonP.JSONValue) => cmnP.readEnum<ReservedElasticsearchInstancePaymentOption>(x),
      "RecurringCharges": [toRecurringCharge],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CompatibleVersionsMap {
  SourceVersion?: string | null;
  TargetVersions?: string[] | null;
}
function toCompatibleVersionsMap(root: jsonP.JSONValue): CompatibleVersionsMap {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceVersion": "s",
      "TargetVersions": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PackageVersionHistory {
  PackageVersion?: string | null;
  CommitMessage?: string | null;
  CreatedAt?: Date | number | null;
}
function toPackageVersionHistory(root: jsonP.JSONValue): PackageVersionHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "PackageVersion": "s",
      "CommitMessage": "s",
      "CreatedAt": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UpgradeHistory {
  UpgradeName?: string | null;
  StartTimestamp?: Date | number | null;
  UpgradeStatus?: UpgradeStatus | null;
  StepsList?: UpgradeStepItem[] | null;
}
function toUpgradeHistory(root: jsonP.JSONValue): UpgradeHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpgradeName": "s",
      "StartTimestamp": "d",
      "UpgradeStatus": (x: jsonP.JSONValue) => cmnP.readEnum<UpgradeStatus>(x),
      "StepsList": [toUpgradeStepItem],
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type UpgradeStatus =
| "IN_PROGRESS"
| "SUCCEEDED"
| "SUCCEEDED_WITH_ISSUES"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface UpgradeStepItem {
  UpgradeStep?: UpgradeStep | null;
  UpgradeStepStatus?: UpgradeStatus | null;
  Issues?: string[] | null;
  ProgressPercent?: number | null;
}
function toUpgradeStepItem(root: jsonP.JSONValue): UpgradeStepItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpgradeStep": (x: jsonP.JSONValue) => cmnP.readEnum<UpgradeStep>(x),
      "UpgradeStepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<UpgradeStatus>(x),
      "Issues": ["s"],
      "ProgressPercent": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type UpgradeStep =
| "PRE_UPGRADE_CHECK"
| "SNAPSHOT"
| "UPGRADE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface DomainInfo {
  DomainName?: string | null;
}
function toDomainInfo(root: jsonP.JSONValue): DomainInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainName": "s",
    },
  }, root);
}
