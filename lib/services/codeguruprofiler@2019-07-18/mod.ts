// Autogenerated API client for: Amazon CodeGuru Profiler

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CodeGuruProfiler {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeGuruProfiler.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-07-18",
    "endpointPrefix": "codeguru-profiler",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon CodeGuru Profiler",
    "serviceId": "CodeGuruProfiler",
    "signatureVersion": "v4",
    "signingName": "codeguru-profiler",
    "uid": "codeguruprofiler-2019-07-18"
  };

  async addNotificationChannels(
    {abortSignal, ...params}: RequestConfig & s.AddNotificationChannelsRequest,
  ): Promise<s.AddNotificationChannelsResponse> {
    const body: jsonP.JSONObject = {
      channels: params["channels"]?.map(x => fromChannel(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddNotificationChannels",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/notificationConfiguration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "notificationConfiguration": toNotificationConfiguration,
      },
    }, await resp.json());
  }

  async batchGetFrameMetricData(
    {abortSignal, ...params}: RequestConfig & s.BatchGetFrameMetricDataRequest,
  ): Promise<s.BatchGetFrameMetricDataResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      frameMetrics: params["frameMetrics"]?.map(x => fromFrameMetric(x)),
    };
    if (params["endTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["period"] != null) query.set("period", params["period"]?.toString() ?? "");
    if (params["startTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    if (params["targetResolution"] != null) query.set("targetResolution", params["targetResolution"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "BatchGetFrameMetricData",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/frames/-/metrics`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "endTime": "d",
        "endTimes": [toTimestampStructure],
        "frameMetricData": [toFrameMetricDatum],
        "resolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.AggregationPeriod>(x),
        "startTime": "d",
        "unprocessedEndTimes": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(toTimestampStructure) : [], x),
      },
      optional: {},
    }, await resp.json());
  }

  async configureAgent(
    {abortSignal, ...params}: RequestConfig & s.ConfigureAgentRequest,
  ): Promise<s.ConfigureAgentResponse> {
    const body: jsonP.JSONObject = {
      fleetInstanceId: params["fleetInstanceId"],
      metadata: params["metadata"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfigureAgent",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/configureAgent`,
      responseCode: 200,
    });
  return {
    configuration: jsonP.readObj({
        required: {
          "periodInSeconds": "n",
          "shouldProfile": "b",
        },
        optional: {
          "agentParameters": x => jsonP.readMap(x => cmnP.readEnumReq<s.AgentParameterField>(x), String, x),
        },
      }, await resp.json()),
  };
  }

  async createProfilingGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateProfilingGroupRequest,
  ): Promise<s.CreateProfilingGroupResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      agentOrchestrationConfig: fromAgentOrchestrationConfig(params["agentOrchestrationConfig"]),
      computePlatform: params["computePlatform"],
      profilingGroupName: params["profilingGroupName"],
      tags: params["tags"],
    };
    query.set("clientToken", params["clientToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateProfilingGroup",
      requestUri: "/profilingGroups",
      responseCode: 201,
    });
  return {
    profilingGroup: toProfilingGroupDescription(await resp.json()),
  };
  }

  async deleteProfilingGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteProfilingGroupRequest,
  ): Promise<s.DeleteProfilingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteProfilingGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeProfilingGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeProfilingGroupRequest,
  ): Promise<s.DescribeProfilingGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeProfilingGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}`,
      responseCode: 200,
    });
  return {
    profilingGroup: toProfilingGroupDescription(await resp.json()),
  };
  }

  async getFindingsReportAccountSummary(
    {abortSignal, ...params}: RequestConfig & s.GetFindingsReportAccountSummaryRequest = {},
  ): Promise<s.GetFindingsReportAccountSummaryResponse> {
    const query = new URLSearchParams;
    if (params["dailyReportsOnly"] != null) query.set("dailyReportsOnly", params["dailyReportsOnly"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFindingsReportAccountSummary",
      method: "GET",
      requestUri: "/internal/findingsReports",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "reportSummaries": [toFindingsReportSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getNotificationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetNotificationConfigurationRequest,
  ): Promise<s.GetNotificationConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetNotificationConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/notificationConfiguration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "notificationConfiguration": toNotificationConfiguration,
      },
      optional: {},
    }, await resp.json());
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetPolicyRequest,
  ): Promise<s.GetPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/policy`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "policy": "s",
        "revisionId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getProfile(
    {abortSignal, ...params}: RequestConfig & s.GetProfileRequest,
  ): Promise<s.GetProfileResponse> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["accept"] != null) headers.append("Accept", params["accept"]);
    if (params["endTime"] != null) query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["maxDepth"] != null) query.set("maxDepth", params["maxDepth"]?.toString() ?? "");
    if (params["period"] != null) query.set("period", params["period"]?.toString() ?? "");
    if (params["startTime"] != null) query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "GetProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/profile`,
      responseCode: 200,
    });
  return {
    contentEncoding: resp.headers.get("Content-Encoding"),
    contentType: resp.headers.get("Content-Type") ?? "",
    profile: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getRecommendations(
    {abortSignal, ...params}: RequestConfig & s.GetRecommendationsRequest,
  ): Promise<s.GetRecommendationsResponse> {
    const query = new URLSearchParams;
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["locale"] != null) query.set("locale", params["locale"]?.toString() ?? "");
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRecommendations",
      method: "GET",
      requestUri: cmnP.encodePath`/internal/profilingGroups/${params["profilingGroupName"]}/recommendations`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "anomalies": [toAnomaly],
        "profileEndTime": "d",
        "profileStartTime": "d",
        "profilingGroupName": "s",
        "recommendations": [toRecommendation],
      },
      optional: {},
    }, await resp.json());
  }

  async listFindingsReports(
    {abortSignal, ...params}: RequestConfig & s.ListFindingsReportsRequest,
  ): Promise<s.ListFindingsReportsResponse> {
    const query = new URLSearchParams;
    if (params["dailyReportsOnly"] != null) query.set("dailyReportsOnly", params["dailyReportsOnly"]?.toString() ?? "");
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFindingsReports",
      method: "GET",
      requestUri: cmnP.encodePath`/internal/profilingGroups/${params["profilingGroupName"]}/findingsReports`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "findingsReportSummaries": [toFindingsReportSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listProfileTimes(
    {abortSignal, ...params}: RequestConfig & s.ListProfileTimesRequest,
  ): Promise<s.ListProfileTimesResponse> {
    const query = new URLSearchParams;
    query.set("endTime", cmnP.serializeDate_iso8601(params["endTime"]) ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["orderBy"] != null) query.set("orderBy", params["orderBy"]?.toString() ?? "");
    query.set("period", params["period"]?.toString() ?? "");
    query.set("startTime", cmnP.serializeDate_iso8601(params["startTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProfileTimes",
      method: "GET",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/profileTimes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "profileTimes": [toProfileTime],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listProfilingGroups(
    {abortSignal, ...params}: RequestConfig & s.ListProfilingGroupsRequest = {},
  ): Promise<s.ListProfilingGroupsResponse> {
    const query = new URLSearchParams;
    if (params["includeDescription"] != null) query.set("includeDescription", params["includeDescription"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProfilingGroups",
      method: "GET",
      requestUri: "/profilingGroups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "profilingGroupNames": ["s"],
      },
      optional: {
        "nextToken": "s",
        "profilingGroups": [toProfilingGroupDescription],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async postAgentProfile(
    {abortSignal, ...params}: RequestConfig & s.PostAgentProfileRequest,
  ): Promise<s.PostAgentProfileResponse> {
    const body = typeof params["agentProfile"] === 'string' ? new TextEncoder().encode(params["agentProfile"]) : params["agentProfile"];
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("Content-Type", params["contentType"]);
    if (params["profileToken"] != null) query.set("profileToken", params["profileToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "PostAgentProfile",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/agentProfile`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putPermission(
    {abortSignal, ...params}: RequestConfig & s.PutPermissionRequest,
  ): Promise<s.PutPermissionResponse> {
    const body: jsonP.JSONObject = {
      principals: params["principals"],
      revisionId: params["revisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPermission",
      method: "PUT",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/policy/${params["actionGroup"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "policy": "s",
        "revisionId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async removeNotificationChannel(
    {abortSignal, ...params}: RequestConfig & s.RemoveNotificationChannelRequest,
  ): Promise<s.RemoveNotificationChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RemoveNotificationChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/notificationConfiguration/${params["channelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "notificationConfiguration": toNotificationConfiguration,
      },
    }, await resp.json());
  }

  async removePermission(
    {abortSignal, ...params}: RequestConfig & s.RemovePermissionRequest,
  ): Promise<s.RemovePermissionResponse> {
    const query = new URLSearchParams;
    query.set("revisionId", params["revisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "RemovePermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}/policy/${params["actionGroup"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "policy": "s",
        "revisionId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async submitFeedback(
    {abortSignal, ...params}: RequestConfig & s.SubmitFeedbackRequest,
  ): Promise<s.SubmitFeedbackResponse> {
    const body: jsonP.JSONObject = {
      comment: params["comment"],
      type: params["type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitFeedback",
      requestUri: cmnP.encodePath`/internal/profilingGroups/${params["profilingGroupName"]}/anomalies/${params["anomalyInstanceId"]}/feedback`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateProfilingGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateProfilingGroupRequest,
  ): Promise<s.UpdateProfilingGroupResponse> {
    const body: jsonP.JSONObject = {
      agentOrchestrationConfig: fromAgentOrchestrationConfig(params["agentOrchestrationConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProfilingGroup",
      method: "PUT",
      requestUri: cmnP.encodePath`/profilingGroups/${params["profilingGroupName"]}`,
      responseCode: 200,
    });
  return {
    profilingGroup: toProfilingGroupDescription(await resp.json()),
  };
  }

}

function fromChannel(input?: s.Channel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventPublishers: input["eventPublishers"],
    id: input["id"],
    uri: input["uri"],
  }
}
function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {
      "eventPublishers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.EventPublisher>(x)],
      "uri": "s",
    },
    optional: {
      "id": "s",
    },
  }, root);
}

function fromFrameMetric(input?: s.FrameMetric | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    frameName: input["frameName"],
    threadStates: input["threadStates"],
    type: input["type"],
  }
}
function toFrameMetric(root: jsonP.JSONValue): s.FrameMetric {
  return jsonP.readObj({
    required: {
      "frameName": "s",
      "threadStates": ["s"],
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricType>(x),
    },
    optional: {},
  }, root);
}

function fromAgentOrchestrationConfig(input?: s.AgentOrchestrationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    profilingEnabled: input["profilingEnabled"],
  }
}
function toAgentOrchestrationConfig(root: jsonP.JSONValue): s.AgentOrchestrationConfig {
  return jsonP.readObj({
    required: {
      "profilingEnabled": "b",
    },
    optional: {},
  }, root);
}

function toNotificationConfiguration(root: jsonP.JSONValue): s.NotificationConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "channels": [toChannel],
    },
  }, root);
}

function toTimestampStructure(root: jsonP.JSONValue): s.TimestampStructure {
  return jsonP.readObj({
    required: {
      "value": "d",
    },
    optional: {},
  }, root);
}

function toFrameMetricDatum(root: jsonP.JSONValue): s.FrameMetricDatum {
  return jsonP.readObj({
    required: {
      "frameMetric": toFrameMetric,
      "values": ["n"],
    },
    optional: {},
  }, root);
}

function toAgentConfiguration(root: jsonP.JSONValue): s.AgentConfiguration {
  return jsonP.readObj({
    required: {
      "periodInSeconds": "n",
      "shouldProfile": "b",
    },
    optional: {
      "agentParameters": x => jsonP.readMap(x => cmnP.readEnumReq<s.AgentParameterField>(x), String, x),
    },
  }, root);
}

function toProfilingGroupDescription(root: jsonP.JSONValue): s.ProfilingGroupDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "agentOrchestrationConfig": toAgentOrchestrationConfig,
      "arn": "s",
      "computePlatform": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputePlatform>(x),
      "createdAt": "d",
      "name": "s",
      "profilingStatus": toProfilingStatus,
      "tags": x => jsonP.readMap(String, String, x),
      "updatedAt": "d",
    },
  }, root);
}

function toProfilingStatus(root: jsonP.JSONValue): s.ProfilingStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "latestAgentOrchestratedAt": "d",
      "latestAgentProfileReportedAt": "d",
      "latestAggregatedProfile": toAggregatedProfileTime,
    },
  }, root);
}

function toAggregatedProfileTime(root: jsonP.JSONValue): s.AggregatedProfileTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "period": (x: jsonP.JSONValue) => cmnP.readEnum<s.AggregationPeriod>(x),
      "start": "d",
    },
  }, root);
}

function toFindingsReportSummary(root: jsonP.JSONValue): s.FindingsReportSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "profileEndTime": "d",
      "profileStartTime": "d",
      "profilingGroupName": "s",
      "totalNumberOfFindings": "n",
    },
  }, root);
}

function toAnomaly(root: jsonP.JSONValue): s.Anomaly {
  return jsonP.readObj({
    required: {
      "instances": [toAnomalyInstance],
      "metric": toMetric,
      "reason": "s",
    },
    optional: {},
  }, root);
}

function toAnomalyInstance(root: jsonP.JSONValue): s.AnomalyInstance {
  return jsonP.readObj({
    required: {
      "id": "s",
      "startTime": "d",
    },
    optional: {
      "endTime": "d",
      "userFeedback": toUserFeedback,
    },
  }, root);
}

function toUserFeedback(root: jsonP.JSONValue): s.UserFeedback {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeedbackType>(x),
    },
    optional: {},
  }, root);
}

function toMetric(root: jsonP.JSONValue): s.Metric {
  return jsonP.readObj({
    required: {
      "frameName": "s",
      "threadStates": ["s"],
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MetricType>(x),
    },
    optional: {},
  }, root);
}

function toRecommendation(root: jsonP.JSONValue): s.Recommendation {
  return jsonP.readObj({
    required: {
      "allMatchesCount": "n",
      "allMatchesSum": "n",
      "endTime": "d",
      "pattern": toPattern,
      "startTime": "d",
      "topMatches": [toMatch],
    },
    optional: {},
  }, root);
}

function toPattern(root: jsonP.JSONValue): s.Pattern {
  return jsonP.readObj({
    required: {},
    optional: {
      "countersToAggregate": ["s"],
      "description": "s",
      "id": "s",
      "name": "s",
      "resolutionSteps": "s",
      "targetFrames": [x => jsonP.readList(String, x)],
      "thresholdPercent": "n",
    },
  }, root);
}

function toMatch(root: jsonP.JSONValue): s.Match {
  return jsonP.readObj({
    required: {},
    optional: {
      "frameAddress": "s",
      "targetFramesIndex": "n",
      "thresholdBreachValue": "n",
    },
  }, root);
}

function toProfileTime(root: jsonP.JSONValue): s.ProfileTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "start": "d",
    },
  }, root);
}
