// Autogenerated API client for: Amazon Relational Database Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";

export default class RDS {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(RDS.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-09-09",
    "endpointPrefix": "rds",
    "protocol": "query",
    "serviceAbbreviation": "Amazon RDS",
    "serviceFullName": "Amazon Relational Database Service",
    "serviceId": "RDS",
    "signatureVersion": "v4",
    "uid": "rds-2013-09-09",
    "xmlNamespace": "http://rds.amazonaws.com/doc/2013-09-09/"
  };

  async addSourceIdentifierToSubscription(
    {abortSignal, ...params}: RequestConfig & AddSourceIdentifierToSubscriptionMessage,
  ): Promise<AddSourceIdentifierToSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddSourceIdentifierToSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddSourceIdentifierToSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & AddTagsToResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
  }

  async authorizeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & AuthorizeDBSecurityGroupIngressMessage,
  ): Promise<AuthorizeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeDBSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async copyDBSnapshot(
    {abortSignal, ...params}: RequestConfig & CopyDBSnapshotMessage,
  ): Promise<CopyDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBSnapshotIdentifier", (params["SourceDBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBSnapshotIdentifier", (params["TargetDBSnapshotIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async createDBInstance(
    {abortSignal, ...params}: RequestConfig & CreateDBInstanceMessage,
  ): Promise<CreateDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["DBSecurityGroups"]) qsP.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("CharacterSetName" in params) body.append(prefix+"CharacterSetName", (params["CharacterSetName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBInstanceReadReplica(
    {abortSignal, ...params}: RequestConfig & CreateDBInstanceReadReplicaMessage,
  ): Promise<CreateDBInstanceReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstanceReadReplica",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBInstanceReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBParameterGroupMessage,
  ): Promise<CreateDBParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBParameterGroupResult");
    return {
      DBParameterGroup: xml.first("DBParameterGroup", false, DBParameterGroup_Parse),
    };
  }

  async createDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBSecurityGroupMessage,
  ): Promise<CreateDBSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    body.append(prefix+"DBSecurityGroupDescription", (params["DBSecurityGroupDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSecurityGroupResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async createDBSnapshot(
    {abortSignal, ...params}: RequestConfig & CreateDBSnapshotMessage,
  ): Promise<CreateDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async createDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDBSubnetGroupMessage,
  ): Promise<CreateDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & CreateEventSubscriptionMessage,
  ): Promise<CreateEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async createOptionGroup(
    {abortSignal, ...params}: RequestConfig & CreateOptionGroupMessage,
  ): Promise<CreateOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    body.append(prefix+"OptionGroupDescription", (params["OptionGroupDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOptionGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async deleteDBInstance(
    {abortSignal, ...params}: RequestConfig & DeleteDBInstanceMessage,
  ): Promise<DeleteDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("SkipFinalSnapshot" in params) body.append(prefix+"SkipFinalSnapshot", (params["SkipFinalSnapshot"] ?? '').toString());
    if ("FinalDBSnapshotIdentifier" in params) body.append(prefix+"FinalDBSnapshotIdentifier", (params["FinalDBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async deleteDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBParameterGroup",
    });
  }

  async deleteDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSecurityGroup",
    });
  }

  async deleteDBSnapshot(
    {abortSignal, ...params}: RequestConfig & DeleteDBSnapshotMessage,
  ): Promise<DeleteDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async deleteDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDBSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSubnetGroup",
    });
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & DeleteEventSubscriptionMessage,
  ): Promise<DeleteEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async deleteOptionGroup(
    {abortSignal, ...params}: RequestConfig & DeleteOptionGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOptionGroup",
    });
  }

  async describeDBEngineVersions(
    {abortSignal, ...params}: RequestConfig & DescribeDBEngineVersionsMessage = {},
  ): Promise<DBEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBParameterGroupFamily" in params) body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    if ("ListSupportedCharacterSets" in params) body.append(prefix+"ListSupportedCharacterSets", (params["ListSupportedCharacterSets"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBEngineVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBEngineVersions: xml.getList("DBEngineVersions", "DBEngineVersion").map(DBEngineVersion_Parse),
    };
  }

  async describeDBInstances(
    {abortSignal, ...params}: RequestConfig & DescribeDBInstancesMessage = {},
  ): Promise<DBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBInstances: xml.getList("DBInstances", "DBInstance").map(DBInstance_Parse),
    };
  }

  async describeDBLogFiles(
    {abortSignal, ...params}: RequestConfig & DescribeDBLogFilesMessage,
  ): Promise<DescribeDBLogFilesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("FilenameContains" in params) body.append(prefix+"FilenameContains", (params["FilenameContains"] ?? '').toString());
    if ("FileLastWritten" in params) body.append(prefix+"FileLastWritten", (params["FileLastWritten"] ?? '').toString());
    if ("FileSize" in params) body.append(prefix+"FileSize", (params["FileSize"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBLogFiles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBLogFilesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DescribeDBLogFiles: xml.getList("DescribeDBLogFiles", "DescribeDBLogFilesDetails").map(DescribeDBLogFilesDetails_Parse),
    };
  }

  async describeDBParameterGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBParameterGroupsMessage = {},
  ): Promise<DBParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBParameterGroups: xml.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroup_Parse),
    };
  }

  async describeDBParameters(
    {abortSignal, ...params}: RequestConfig & DescribeDBParametersMessage,
  ): Promise<DBParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeDBSecurityGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBSecurityGroupsMessage = {},
  ): Promise<DBSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSecurityGroupName" in params) body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSecurityGroups: xml.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroup_Parse),
    };
  }

  async describeDBSnapshots(
    {abortSignal, ...params}: RequestConfig & DescribeDBSnapshotsMessage = {},
  ): Promise<DBSnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("DBSnapshotIdentifier" in params) body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSnapshots: xml.getList("DBSnapshots", "DBSnapshot").map(DBSnapshot_Parse),
    };
  }

  async describeDBSubnetGroups(
    {abortSignal, ...params}: RequestConfig & DescribeDBSubnetGroupsMessage = {},
  ): Promise<DBSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSubnetGroups: xml.getList("DBSubnetGroups", "DBSubnetGroup").map(DBSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultParameters(
    {abortSignal, ...params}: RequestConfig & DescribeEngineDefaultParametersMessage,
  ): Promise<DescribeEngineDefaultParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEngineDefaultParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & DescribeEventCategoriesMessage = {},
  ): Promise<EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & DescribeEventSubscriptionsMessage = {},
  ): Promise<EventSubscriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SubscriptionName" in params) body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventSubscriptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EventSubscriptionsList: xml.getList("EventSubscriptionsList", "EventSubscription").map(EventSubscription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & DescribeEventsMessage = {},
  ): Promise<EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeOptionGroupOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOptionGroupOptionsMessage,
  ): Promise<OptionGroupOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroupOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOptionGroupOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupOptions: xml.getList("OptionGroupOptions", "OptionGroupOption").map(OptionGroupOption_Parse),
    };
  }

  async describeOptionGroups(
    {abortSignal, ...params}: RequestConfig & DescribeOptionGroupsMessage = {},
  ): Promise<OptionGroups> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("EngineName" in params) body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOptionGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupsList: xml.getList("OptionGroupsList", "OptionGroup").map(OptionGroup_Parse),
    };
  }

  async describeOrderableDBInstanceOptions(
    {abortSignal, ...params}: RequestConfig & DescribeOrderableDBInstanceOptionsMessage,
  ): Promise<OrderableDBInstanceOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Vpc" in params) body.append(prefix+"Vpc", (params["Vpc"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableDBInstanceOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOrderableDBInstanceOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableDBInstanceOptions: xml.getList("OrderableDBInstanceOptions", "OrderableDBInstanceOption").map(OrderableDBInstanceOption_Parse),
    };
  }

  async describeReservedDBInstances(
    {abortSignal, ...params}: RequestConfig & DescribeReservedDBInstancesMessage = {},
  ): Promise<ReservedDBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstances: xml.getList("ReservedDBInstances", "ReservedDBInstance").map(ReservedDBInstance_Parse),
    };
  }

  async describeReservedDBInstancesOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeReservedDBInstancesOfferingsMessage = {},
  ): Promise<ReservedDBInstancesOfferingMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstancesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedDBInstancesOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstancesOfferings: xml.getList("ReservedDBInstancesOfferings", "ReservedDBInstancesOffering").map(ReservedDBInstancesOffering_Parse),
    };
  }

  async downloadDBLogFilePortion(
    {abortSignal, ...params}: RequestConfig & DownloadDBLogFilePortionMessage,
  ): Promise<DownloadDBLogFilePortionDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"LogFileName", (params["LogFileName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("NumberOfLines" in params) body.append(prefix+"NumberOfLines", (params["NumberOfLines"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DownloadDBLogFilePortion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DownloadDBLogFilePortionResult");
    return {
      ...xml.strings({
        optional: {"LogFileData":true,"Marker":true},
      }),
      AdditionalDataPending: xml.first("AdditionalDataPending", false, x => x.content === 'true'),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceMessage,
  ): Promise<TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyDBInstance(
    {abortSignal, ...params}: RequestConfig & ModifyDBInstanceMessage,
  ): Promise<ModifyDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("AllocatedStorage" in params) body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if (params["DBSecurityGroups"]) qsP.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AllowMajorVersionUpgrade" in params) body.append(prefix+"AllowMajorVersionUpgrade", (params["AllowMajorVersionUpgrade"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("NewDBInstanceIdentifier" in params) body.append(prefix+"NewDBInstanceIdentifier", (params["NewDBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async modifyDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBParameterGroupMessage,
  ): Promise<DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async modifyDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & ModifyDBSubnetGroupMessage,
  ): Promise<ModifyDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("DBSubnetGroupDescription" in params) body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & ModifyEventSubscriptionMessage,
  ): Promise<ModifyEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("SnsTopicArn" in params) body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async modifyOptionGroup(
    {abortSignal, ...params}: RequestConfig & ModifyOptionGroupMessage,
  ): Promise<ModifyOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["OptionsToInclude"]) qsP.appendList(body, prefix+"OptionsToInclude", params["OptionsToInclude"], {"appender":OptionConfiguration_Serialize,"entryPrefix":".OptionConfiguration."})
    if (params["OptionsToRemove"]) qsP.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"entryPrefix":".member."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyOptionGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async promoteReadReplica(
    {abortSignal, ...params}: RequestConfig & PromoteReadReplicaMessage,
  ): Promise<PromoteReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PromoteReadReplica",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PromoteReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async purchaseReservedDBInstancesOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseReservedDBInstancesOfferingMessage,
  ): Promise<PurchaseReservedDBInstancesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("DBInstanceCount" in params) body.append(prefix+"DBInstanceCount", (params["DBInstanceCount"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedDBInstancesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedDBInstancesOfferingResult");
    return {
      ReservedDBInstance: xml.first("ReservedDBInstance", false, ReservedDBInstance_Parse),
    };
  }

  async rebootDBInstance(
    {abortSignal, ...params}: RequestConfig & RebootDBInstanceMessage,
  ): Promise<RebootDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("ForceFailover" in params) body.append(prefix+"ForceFailover", (params["ForceFailover"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async removeSourceIdentifierFromSubscription(
    {abortSignal, ...params}: RequestConfig & RemoveSourceIdentifierFromSubscriptionMessage,
  ): Promise<RemoveSourceIdentifierFromSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveSourceIdentifierFromSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveSourceIdentifierFromSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & RemoveTagsFromResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
  }

  async resetDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & ResetDBParameterGroupMessage,
  ): Promise<DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async restoreDBInstanceFromDBSnapshot(
    {abortSignal, ...params}: RequestConfig & RestoreDBInstanceFromDBSnapshotMessage,
  ): Promise<RestoreDBInstanceFromDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceFromDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBInstanceFromDBSnapshotResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async restoreDBInstanceToPointInTime(
    {abortSignal, ...params}: RequestConfig & RestoreDBInstanceToPointInTimeMessage,
  ): Promise<RestoreDBInstanceToPointInTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBInstanceIdentifier", (params["TargetDBInstanceIdentifier"] ?? '').toString());
    if ("RestoreTime" in params) body.append(prefix+"RestoreTime", qsP.encodeDate_iso8601(params["RestoreTime"]));
    if ("UseLatestRestorableTime" in params) body.append(prefix+"UseLatestRestorableTime", (params["UseLatestRestorableTime"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceToPointInTime",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBInstanceToPointInTimeResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async revokeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & RevokeDBSecurityGroupIngressMessage,
  ): Promise<RevokeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeDBSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceAvailable(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceDeleted(
    params: RequestConfig & DescribeDBInstancesMessage,
  ): Promise<DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
      if (field?.every(x => x === "deleted")) return resp;
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
      if (field?.some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddSourceIdentifierToSubscriptionMessage {
  SubscriptionName: string;
  SourceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface AddTagsToResourceMessage {
  ResourceName: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface AuthorizeDBSecurityGroupIngressMessage {
  DBSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, input
export interface CopyDBSnapshotMessage {
  SourceDBSnapshotIdentifier: string;
  TargetDBSnapshotIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBInstanceMessage {
  DBName?: string | null;
  DBInstanceIdentifier: string;
  AllocatedStorage: number;
  DBInstanceClass: string;
  Engine: string;
  MasterUsername: string;
  MasterUserPassword: string;
  DBSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  PreferredMaintenanceWindow?: string | null;
  DBParameterGroupName?: string | null;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
  Port?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  CharacterSetName?: string | null;
  PubliclyAccessible?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBInstanceReadReplicaMessage {
  DBInstanceIdentifier: string;
  SourceDBInstanceIdentifier: string;
  DBInstanceClass?: string | null;
  AvailabilityZone?: string | null;
  Port?: number | null;
  AutoMinorVersionUpgrade?: boolean | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  PubliclyAccessible?: boolean | null;
  Tags?: Tag[] | null;
  DBSubnetGroupName?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateDBParameterGroupMessage {
  DBParameterGroupName: string;
  DBParameterGroupFamily: string;
  Description: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSecurityGroupMessage {
  DBSecurityGroupName: string;
  DBSecurityGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSnapshotMessage {
  DBSnapshotIdentifier: string;
  DBInstanceIdentifier: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription: string;
  SubnetIds: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn: string;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  SourceIds?: string[] | null;
  Enabled?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateOptionGroupMessage {
  OptionGroupName: string;
  EngineName: string;
  MajorEngineVersion: string;
  OptionGroupDescription: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBInstanceMessage {
  DBInstanceIdentifier: string;
  SkipFinalSnapshot?: boolean | null;
  FinalDBSnapshotIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDBParameterGroupMessage {
  DBParameterGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSecurityGroupMessage {
  DBSecurityGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSnapshotMessage {
  DBSnapshotIdentifier: string;
}

// refs: 1 - tags: named, input
export interface DeleteDBSubnetGroupMessage {
  DBSubnetGroupName: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventSubscriptionMessage {
  SubscriptionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteOptionGroupMessage {
  OptionGroupName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDBEngineVersionsMessage {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
  DefaultOnly?: boolean | null;
  ListSupportedCharacterSets?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBInstancesMessage {
  DBInstanceIdentifier?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBLogFilesMessage {
  DBInstanceIdentifier: string;
  FilenameContains?: string | null;
  FileLastWritten?: number | null;
  FileSize?: number | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBParameterGroupsMessage {
  DBParameterGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBParametersMessage {
  DBParameterGroupName: string;
  Source?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSecurityGroupsMessage {
  DBSecurityGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSnapshotsMessage {
  DBInstanceIdentifier?: string | null;
  DBSnapshotIdentifier?: string | null;
  SnapshotType?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDBSubnetGroupsMessage {
  DBSubnetGroupName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEngineDefaultParametersMessage {
  DBParameterGroupFamily: string;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventCategoriesMessage {
  SourceType?: string | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventSubscriptionsMessage {
  SubscriptionName?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeEventsMessage {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Duration?: number | null;
  EventCategories?: string[] | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOptionGroupOptionsMessage {
  EngineName: string;
  MajorEngineVersion?: string | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOptionGroupsMessage {
  OptionGroupName?: string | null;
  Filters?: Filter[] | null;
  Marker?: string | null;
  MaxRecords?: number | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeOrderableDBInstanceOptionsMessage {
  Engine: string;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  Vpc?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedDBInstancesMessage {
  ReservedDBInstanceId?: string | null;
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeReservedDBInstancesOfferingsMessage {
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  Filters?: Filter[] | null;
  MaxRecords?: number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface DownloadDBLogFilePortionMessage {
  DBInstanceIdentifier: string;
  LogFileName: string;
  Marker?: string | null;
  NumberOfLines?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceMessage {
  ResourceName: string;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBInstanceMessage {
  DBInstanceIdentifier: string;
  AllocatedStorage?: number | null;
  DBInstanceClass?: string | null;
  DBSecurityGroups?: string[] | null;
  VpcSecurityGroupIds?: string[] | null;
  ApplyImmediately?: boolean | null;
  MasterUserPassword?: string | null;
  DBParameterGroupName?: string | null;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
  PreferredMaintenanceWindow?: string | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AllowMajorVersionUpgrade?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  NewDBInstanceIdentifier?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyDBParameterGroupMessage {
  DBParameterGroupName: string;
  Parameters: Parameter[];
}

// refs: 1 - tags: named, input
export interface ModifyDBSubnetGroupMessage {
  DBSubnetGroupName: string;
  DBSubnetGroupDescription?: string | null;
  SubnetIds: string[];
}

// refs: 1 - tags: named, input
export interface ModifyEventSubscriptionMessage {
  SubscriptionName: string;
  SnsTopicArn?: string | null;
  SourceType?: string | null;
  EventCategories?: string[] | null;
  Enabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface ModifyOptionGroupMessage {
  OptionGroupName: string;
  OptionsToInclude?: OptionConfiguration[] | null;
  OptionsToRemove?: string[] | null;
  ApplyImmediately?: boolean | null;
}

// refs: 1 - tags: named, input
export interface PromoteReadReplicaMessage {
  DBInstanceIdentifier: string;
  BackupRetentionPeriod?: number | null;
  PreferredBackupWindow?: string | null;
}

// refs: 1 - tags: named, input
export interface PurchaseReservedDBInstancesOfferingMessage {
  ReservedDBInstancesOfferingId: string;
  ReservedDBInstanceId?: string | null;
  DBInstanceCount?: number | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface RebootDBInstanceMessage {
  DBInstanceIdentifier: string;
  ForceFailover?: boolean | null;
}

// refs: 1 - tags: named, input
export interface RemoveSourceIdentifierFromSubscriptionMessage {
  SubscriptionName: string;
  SourceIdentifier: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsFromResourceMessage {
  ResourceName: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface ResetDBParameterGroupMessage {
  DBParameterGroupName: string;
  ResetAllParameters?: boolean | null;
  Parameters?: Parameter[] | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBInstanceFromDBSnapshotMessage {
  DBInstanceIdentifier: string;
  DBSnapshotIdentifier: string;
  DBInstanceClass?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  MultiAZ?: boolean | null;
  PubliclyAccessible?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  DBName?: string | null;
  Engine?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface RestoreDBInstanceToPointInTimeMessage {
  SourceDBInstanceIdentifier: string;
  TargetDBInstanceIdentifier: string;
  RestoreTime?: Date | number | null;
  UseLatestRestorableTime?: boolean | null;
  DBInstanceClass?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  DBSubnetGroupName?: string | null;
  MultiAZ?: boolean | null;
  PubliclyAccessible?: boolean | null;
  AutoMinorVersionUpgrade?: boolean | null;
  LicenseModel?: string | null;
  DBName?: string | null;
  Engine?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface RevokeDBSecurityGroupIngressMessage {
  DBSecurityGroupName: string;
  CIDRIP?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}

// refs: 1 - tags: named, output
export interface AddSourceIdentifierToSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface AuthorizeDBSecurityGroupIngressResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CopyDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateDBInstanceReadReplicaResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface CreateDBParameterGroupResult {
  DBParameterGroup?: DBParameterGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSecurityGroupResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface CreateDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateOptionGroupResult {
  OptionGroup?: OptionGroup | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface DeleteDBSnapshotResult {
  DBSnapshot?: DBSnapshot | null;
}

// refs: 1 - tags: named, output
export interface DeleteEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface DBEngineVersionMessage {
  Marker?: string | null;
  DBEngineVersions: DBEngineVersion[];
}

// refs: 1 - tags: named, output
export interface DBInstanceMessage {
  Marker?: string | null;
  DBInstances: DBInstance[];
}

// refs: 1 - tags: named, output
export interface DescribeDBLogFilesResponse {
  DescribeDBLogFiles: DescribeDBLogFilesDetails[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DBParameterGroupsMessage {
  Marker?: string | null;
  DBParameterGroups: DBParameterGroup[];
}

// refs: 1 - tags: named, output
export interface DBParameterGroupDetails {
  Parameters: Parameter[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface DBSecurityGroupMessage {
  Marker?: string | null;
  DBSecurityGroups: DBSecurityGroup[];
}

// refs: 1 - tags: named, output
export interface DBSnapshotMessage {
  Marker?: string | null;
  DBSnapshots: DBSnapshot[];
}

// refs: 1 - tags: named, output
export interface DBSubnetGroupMessage {
  Marker?: string | null;
  DBSubnetGroups: DBSubnetGroup[];
}

// refs: 1 - tags: named, output
export interface DescribeEngineDefaultParametersResult {
  EngineDefaults?: EngineDefaults | null;
}

// refs: 1 - tags: named, output
export interface EventCategoriesMessage {
  EventCategoriesMapList: EventCategoriesMap[];
}

// refs: 1 - tags: named, output
export interface EventSubscriptionsMessage {
  Marker?: string | null;
  EventSubscriptionsList: EventSubscription[];
}

// refs: 1 - tags: named, output
export interface EventsMessage {
  Marker?: string | null;
  Events: Event[];
}

// refs: 1 - tags: named, output
export interface OptionGroupOptionsMessage {
  OptionGroupOptions: OptionGroupOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface OptionGroups {
  OptionGroupsList: OptionGroup[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface OrderableDBInstanceOptionsMessage {
  OrderableDBInstanceOptions: OrderableDBInstanceOption[];
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ReservedDBInstanceMessage {
  Marker?: string | null;
  ReservedDBInstances: ReservedDBInstance[];
}

// refs: 1 - tags: named, output
export interface ReservedDBInstancesOfferingMessage {
  Marker?: string | null;
  ReservedDBInstancesOfferings: ReservedDBInstancesOffering[];
}

// refs: 1 - tags: named, output
export interface DownloadDBLogFilePortionDetails {
  LogFileData?: string | null;
  Marker?: string | null;
  AdditionalDataPending?: boolean | null;
}

// refs: 1 - tags: named, output
export interface TagListMessage {
  TagList: Tag[];
}

// refs: 1 - tags: named, output
export interface ModifyDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface DBParameterGroupNameMessage {
  DBParameterGroupName?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyDBSubnetGroupResult {
  DBSubnetGroup?: DBSubnetGroup | null;
}

// refs: 1 - tags: named, output
export interface ModifyEventSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface ModifyOptionGroupResult {
  OptionGroup?: OptionGroup | null;
}

// refs: 1 - tags: named, output
export interface PromoteReadReplicaResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface PurchaseReservedDBInstancesOfferingResult {
  ReservedDBInstance?: ReservedDBInstance | null;
}

// refs: 1 - tags: named, output
export interface RebootDBInstanceResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RemoveSourceIdentifierFromSubscriptionResult {
  EventSubscription?: EventSubscription | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBInstanceFromDBSnapshotResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RestoreDBInstanceToPointInTimeResult {
  DBInstance?: DBInstance | null;
}

// refs: 1 - tags: named, output
export interface RevokeDBSecurityGroupIngressResult {
  DBSecurityGroup?: DBSecurityGroup | null;
}

// refs: 14 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(body: URLSearchParams, prefix: string, params: Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 18 - tags: input, named, interface
export interface Filter {
  Name: string;
  Values: string[];
}
function Filter_Serialize(body: URLSearchParams, prefix: string, params: Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".Value."})
}

// refs: 2 - tags: input, named, enum, output
export type SourceType =
| "db-instance"
| "db-parameter-group"
| "db-security-group"
| "db-snapshot"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Parameter {
  ParameterName?: string | null;
  ParameterValue?: string | null;
  Description?: string | null;
  Source?: string | null;
  ApplyType?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  MinimumEngineVersion?: string | null;
  ApplyMethod?: ApplyMethod | null;
}
function Parameter_Serialize(body: URLSearchParams, prefix: string, params: Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
    if ("ApplyMethod" in params) body.append(prefix+".ApplyMethod", (params["ApplyMethod"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"ApplyType":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ApplyMethod: node.first("ApplyMethod", false, x => (x.content ?? '') as ApplyMethod),
  };
}

// refs: 4 - tags: input, named, enum, output
export type ApplyMethod =
| "immediate"
| "pending-reboot"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface OptionConfiguration {
  OptionName: string;
  Port?: number | null;
  DBSecurityGroupMemberships?: string[] | null;
  VpcSecurityGroupMemberships?: string[] | null;
  OptionSettings?: OptionSetting[] | null;
}
function OptionConfiguration_Serialize(body: URLSearchParams, prefix: string, params: OptionConfiguration) {
    body.append(prefix+".OptionName", (params["OptionName"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if (params["DBSecurityGroupMemberships"]) qsP.appendList(body, prefix+".DBSecurityGroupMemberships", params["DBSecurityGroupMemberships"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupMemberships"]) qsP.appendList(body, prefix+".VpcSecurityGroupMemberships", params["VpcSecurityGroupMemberships"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["OptionSettings"]) qsP.appendList(body, prefix+".OptionSettings", params["OptionSettings"], {"appender":OptionSetting_Serialize,"entryPrefix":".OptionSetting."})
}

// refs: 4 - tags: input, named, interface, output
export interface OptionSetting {
  Name?: string | null;
  Value?: string | null;
  DefaultValue?: string | null;
  Description?: string | null;
  ApplyType?: string | null;
  DataType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
  IsCollection?: boolean | null;
}
function OptionSetting_Serialize(body: URLSearchParams, prefix: string, params: OptionSetting) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("IsCollection" in params) body.append(prefix+".IsCollection", (params["IsCollection"] ?? '').toString());
}
function OptionSetting_Parse(node: xmlP.XmlNode): OptionSetting {
  return {
    ...node.strings({
      optional: {"Name":true,"Value":true,"DefaultValue":true,"Description":true,"ApplyType":true,"DataType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    IsCollection: node.first("IsCollection", false, x => x.content === 'true'),
  };
}

// refs: 6 - tags: output, named, interface
export interface EventSubscription {
  CustomerAwsId?: string | null;
  CustSubscriptionId?: string | null;
  SnsTopicArn?: string | null;
  Status?: string | null;
  SubscriptionCreationTime?: string | null;
  SourceType?: string | null;
  SourceIdsList: string[];
  EventCategoriesList: string[];
  Enabled?: boolean | null;
}
function EventSubscription_Parse(node: xmlP.XmlNode): EventSubscription {
  return {
    ...node.strings({
      optional: {"CustomerAwsId":true,"CustSubscriptionId":true,"SnsTopicArn":true,"Status":true,"SubscriptionCreationTime":true,"SourceType":true},
    }),
    SourceIdsList: node.getList("SourceIdsList", "SourceId").map(x => x.content ?? ''),
    EventCategoriesList: node.getList("EventCategoriesList", "EventCategory").map(x => x.content ?? ''),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: output, named, interface
export interface DBSecurityGroup {
  OwnerId?: string | null;
  DBSecurityGroupName?: string | null;
  DBSecurityGroupDescription?: string | null;
  VpcId?: string | null;
  EC2SecurityGroups: EC2SecurityGroup[];
  IPRanges: IPRange[];
}
function DBSecurityGroup_Parse(node: xmlP.XmlNode): DBSecurityGroup {
  return {
    ...node.strings({
      optional: {"OwnerId":true,"DBSecurityGroupName":true,"DBSecurityGroupDescription":true,"VpcId":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
    IPRanges: node.getList("IPRanges", "IPRange").map(IPRange_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface EC2SecurityGroup {
  Status?: string | null;
  EC2SecurityGroupName?: string | null;
  EC2SecurityGroupId?: string | null;
  EC2SecurityGroupOwnerId?: string | null;
}
function EC2SecurityGroup_Parse(node: xmlP.XmlNode): EC2SecurityGroup {
  return node.strings({
    optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupId":true,"EC2SecurityGroupOwnerId":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface IPRange {
  Status?: string | null;
  CIDRIP?: string | null;
}
function IPRange_Parse(node: xmlP.XmlNode): IPRange {
  return node.strings({
    optional: {"Status":true,"CIDRIP":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface DBSnapshot {
  DBSnapshotIdentifier?: string | null;
  DBInstanceIdentifier?: string | null;
  SnapshotCreateTime?: Date | number | null;
  Engine?: string | null;
  AllocatedStorage?: number | null;
  Status?: string | null;
  Port?: number | null;
  AvailabilityZone?: string | null;
  VpcId?: string | null;
  InstanceCreateTime?: Date | number | null;
  MasterUsername?: string | null;
  EngineVersion?: string | null;
  LicenseModel?: string | null;
  SnapshotType?: string | null;
  Iops?: number | null;
  OptionGroupName?: string | null;
  PercentProgress?: number | null;
  SourceRegion?: string | null;
}
function DBSnapshot_Parse(node: xmlP.XmlNode): DBSnapshot {
  return {
    ...node.strings({
      optional: {"DBSnapshotIdentifier":true,"DBInstanceIdentifier":true,"Engine":true,"Status":true,"AvailabilityZone":true,"VpcId":true,"MasterUsername":true,"EngineVersion":true,"LicenseModel":true,"SnapshotType":true,"OptionGroupName":true,"SourceRegion":true},
    }),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 9 - tags: output, named, interface
export interface DBInstance {
  DBInstanceIdentifier?: string | null;
  DBInstanceClass?: string | null;
  Engine?: string | null;
  DBInstanceStatus?: string | null;
  MasterUsername?: string | null;
  DBName?: string | null;
  Endpoint?: Endpoint | null;
  AllocatedStorage?: number | null;
  InstanceCreateTime?: Date | number | null;
  PreferredBackupWindow?: string | null;
  BackupRetentionPeriod?: number | null;
  DBSecurityGroups: DBSecurityGroupMembership[];
  VpcSecurityGroups: VpcSecurityGroupMembership[];
  DBParameterGroups: DBParameterGroupStatus[];
  AvailabilityZone?: string | null;
  DBSubnetGroup?: DBSubnetGroup | null;
  PreferredMaintenanceWindow?: string | null;
  PendingModifiedValues?: PendingModifiedValues | null;
  LatestRestorableTime?: Date | number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  AutoMinorVersionUpgrade?: boolean | null;
  ReadReplicaSourceDBInstanceIdentifier?: string | null;
  ReadReplicaDBInstanceIdentifiers: string[];
  LicenseModel?: string | null;
  Iops?: number | null;
  OptionGroupMemberships: OptionGroupMembership[];
  CharacterSetName?: string | null;
  SecondaryAvailabilityZone?: string | null;
  PubliclyAccessible?: boolean | null;
  StatusInfos: DBInstanceStatusInfo[];
}
function DBInstance_Parse(node: xmlP.XmlNode): DBInstance {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBInstanceClass":true,"Engine":true,"DBInstanceStatus":true,"MasterUsername":true,"DBName":true,"PreferredBackupWindow":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"EngineVersion":true,"ReadReplicaSourceDBInstanceIdentifier":true,"LicenseModel":true,"CharacterSetName":true,"SecondaryAvailabilityZone":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    DBSecurityGroups: node.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    DBParameterGroups: node.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroupStatus_Parse),
    DBSubnetGroup: node.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => xmlP.parseTimestamp(x.content)),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    ReadReplicaDBInstanceIdentifiers: node.getList("ReadReplicaDBInstanceIdentifiers", "ReadReplicaDBInstanceIdentifier").map(x => x.content ?? ''),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    OptionGroupMemberships: node.getList("OptionGroupMemberships", "OptionGroupMembership").map(OptionGroupMembership_Parse),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    StatusInfos: node.getList("StatusInfos", "DBInstanceStatusInfo").map(DBInstanceStatusInfo_Parse),
  };
}

// refs: 9 - tags: output, named, interface
export interface Endpoint {
  Address?: string | null;
  Port?: number | null;
}
function Endpoint_Parse(node: xmlP.XmlNode): Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 12 - tags: output, named, interface
export interface DBSecurityGroupMembership {
  DBSecurityGroupName?: string | null;
  Status?: string | null;
}
function DBSecurityGroupMembership_Parse(node: xmlP.XmlNode): DBSecurityGroupMembership {
  return node.strings({
    optional: {"DBSecurityGroupName":true,"Status":true},
  });
}

// refs: 12 - tags: output, named, interface
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string | null;
  Status?: string | null;
}
function VpcSecurityGroupMembership_Parse(node: xmlP.XmlNode): VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

// refs: 9 - tags: output, named, interface
export interface DBParameterGroupStatus {
  DBParameterGroupName?: string | null;
  ParameterApplyStatus?: string | null;
}
function DBParameterGroupStatus_Parse(node: xmlP.XmlNode): DBParameterGroupStatus {
  return node.strings({
    optional: {"DBParameterGroupName":true,"ParameterApplyStatus":true},
  });
}

// refs: 12 - tags: output, named, interface
export interface DBSubnetGroup {
  DBSubnetGroupName?: string | null;
  DBSubnetGroupDescription?: string | null;
  VpcId?: string | null;
  SubnetGroupStatus?: string | null;
  Subnets: Subnet[];
}
function DBSubnetGroup_Parse(node: xmlP.XmlNode): DBSubnetGroup {
  return {
    ...node.strings({
      optional: {"DBSubnetGroupName":true,"DBSubnetGroupDescription":true,"VpcId":true,"SubnetGroupStatus":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

// refs: 12 - tags: output, named, interface
export interface Subnet {
  SubnetIdentifier?: string | null;
  SubnetAvailabilityZone?: AvailabilityZone | null;
  SubnetStatus?: string | null;
}
function Subnet_Parse(node: xmlP.XmlNode): Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
  };
}

// refs: 13 - tags: output, named, interface
export interface AvailabilityZone {
  Name?: string | null;
  ProvisionedIopsCapable?: boolean | null;
}
function AvailabilityZone_Parse(node: xmlP.XmlNode): AvailabilityZone {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    ProvisionedIopsCapable: node.first("ProvisionedIopsCapable", false, x => x.content === 'true'),
  };
}

// refs: 9 - tags: output, named, interface
export interface PendingModifiedValues {
  DBInstanceClass?: string | null;
  AllocatedStorage?: number | null;
  MasterUserPassword?: string | null;
  Port?: number | null;
  BackupRetentionPeriod?: number | null;
  MultiAZ?: boolean | null;
  EngineVersion?: string | null;
  Iops?: number | null;
  DBInstanceIdentifier?: string | null;
}
function PendingModifiedValues_Parse(node: xmlP.XmlNode): PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"DBInstanceClass":true,"MasterUserPassword":true,"EngineVersion":true,"DBInstanceIdentifier":true},
    }),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 9 - tags: output, named, interface
export interface OptionGroupMembership {
  OptionGroupName?: string | null;
  Status?: string | null;
}
function OptionGroupMembership_Parse(node: xmlP.XmlNode): OptionGroupMembership {
  return node.strings({
    optional: {"OptionGroupName":true,"Status":true},
  });
}

// refs: 9 - tags: output, named, interface
export interface DBInstanceStatusInfo {
  StatusType?: string | null;
  Normal?: boolean | null;
  Status?: string | null;
  Message?: string | null;
}
function DBInstanceStatusInfo_Parse(node: xmlP.XmlNode): DBInstanceStatusInfo {
  return {
    ...node.strings({
      optional: {"StatusType":true,"Status":true,"Message":true},
    }),
    Normal: node.first("Normal", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface DBParameterGroup {
  DBParameterGroupName?: string | null;
  DBParameterGroupFamily?: string | null;
  Description?: string | null;
}
function DBParameterGroup_Parse(node: xmlP.XmlNode): DBParameterGroup {
  return node.strings({
    optional: {"DBParameterGroupName":true,"DBParameterGroupFamily":true,"Description":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface OptionGroup {
  OptionGroupName?: string | null;
  OptionGroupDescription?: string | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
  Options: Option[];
  AllowsVpcAndNonVpcInstanceMemberships?: boolean | null;
  VpcId?: string | null;
}
function OptionGroup_Parse(node: xmlP.XmlNode): OptionGroup {
  return {
    ...node.strings({
      optional: {"OptionGroupName":true,"OptionGroupDescription":true,"EngineName":true,"MajorEngineVersion":true,"VpcId":true},
    }),
    Options: node.getList("Options", "Option").map(Option_Parse),
    AllowsVpcAndNonVpcInstanceMemberships: node.first("AllowsVpcAndNonVpcInstanceMemberships", false, x => x.content === 'true'),
  };
}

// refs: 3 - tags: output, named, interface
export interface Option {
  OptionName?: string | null;
  OptionDescription?: string | null;
  Persistent?: boolean | null;
  Permanent?: boolean | null;
  Port?: number | null;
  OptionSettings: OptionSetting[];
  DBSecurityGroupMemberships: DBSecurityGroupMembership[];
  VpcSecurityGroupMemberships: VpcSecurityGroupMembership[];
}
function Option_Parse(node: xmlP.XmlNode): Option {
  return {
    ...node.strings({
      optional: {"OptionName":true,"OptionDescription":true},
    }),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    OptionSettings: node.getList("OptionSettings", "OptionSetting").map(OptionSetting_Parse),
    DBSecurityGroupMemberships: node.getList("DBSecurityGroupMemberships", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroupMemberships: node.getList("VpcSecurityGroupMemberships", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface DBEngineVersion {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBParameterGroupFamily?: string | null;
  DBEngineDescription?: string | null;
  DBEngineVersionDescription?: string | null;
  DefaultCharacterSet?: CharacterSet | null;
  SupportedCharacterSets: CharacterSet[];
}
function DBEngineVersion_Parse(node: xmlP.XmlNode): DBEngineVersion {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBParameterGroupFamily":true,"DBEngineDescription":true,"DBEngineVersionDescription":true},
    }),
    DefaultCharacterSet: node.first("DefaultCharacterSet", false, CharacterSet_Parse),
    SupportedCharacterSets: node.getList("SupportedCharacterSets", "CharacterSet").map(CharacterSet_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface CharacterSet {
  CharacterSetName?: string | null;
  CharacterSetDescription?: string | null;
}
function CharacterSet_Parse(node: xmlP.XmlNode): CharacterSet {
  return node.strings({
    optional: {"CharacterSetName":true,"CharacterSetDescription":true},
  });
}

// refs: 1 - tags: output, named, interface
export interface DescribeDBLogFilesDetails {
  LogFileName?: string | null;
  LastWritten?: number | null;
  Size?: number | null;
}
function DescribeDBLogFilesDetails_Parse(node: xmlP.XmlNode): DescribeDBLogFilesDetails {
  return {
    ...node.strings({
      optional: {"LogFileName":true},
    }),
    LastWritten: node.first("LastWritten", false, x => parseInt(x.content ?? '0')),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface EngineDefaults {
  DBParameterGroupFamily?: string | null;
  Marker?: string | null;
  Parameters: Parameter[];
}
function EngineDefaults_Parse(node: xmlP.XmlNode): EngineDefaults {
  return {
    ...node.strings({
      optional: {"DBParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface EventCategoriesMap {
  SourceType?: string | null;
  EventCategories: string[];
}
function EventCategoriesMap_Parse(node: xmlP.XmlNode): EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface Event {
  SourceIdentifier?: string | null;
  SourceType?: SourceType | null;
  Message?: string | null;
  EventCategories: string[];
  Date?: Date | number | null;
}
function Event_Parse(node: xmlP.XmlNode): Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface OptionGroupOption {
  Name?: string | null;
  Description?: string | null;
  EngineName?: string | null;
  MajorEngineVersion?: string | null;
  MinimumRequiredMinorEngineVersion?: string | null;
  PortRequired?: boolean | null;
  DefaultPort?: number | null;
  OptionsDependedOn: string[];
  Persistent?: boolean | null;
  Permanent?: boolean | null;
  OptionGroupOptionSettings: OptionGroupOptionSetting[];
}
function OptionGroupOption_Parse(node: xmlP.XmlNode): OptionGroupOption {
  return {
    ...node.strings({
      optional: {"Name":true,"Description":true,"EngineName":true,"MajorEngineVersion":true,"MinimumRequiredMinorEngineVersion":true},
    }),
    PortRequired: node.first("PortRequired", false, x => x.content === 'true'),
    DefaultPort: node.first("DefaultPort", false, x => parseInt(x.content ?? '0')),
    OptionsDependedOn: node.getList("OptionsDependedOn", "OptionName").map(x => x.content ?? ''),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    OptionGroupOptionSettings: node.getList("OptionGroupOptionSettings", "OptionGroupOptionSetting").map(OptionGroupOptionSetting_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface OptionGroupOptionSetting {
  SettingName?: string | null;
  SettingDescription?: string | null;
  DefaultValue?: string | null;
  ApplyType?: string | null;
  AllowedValues?: string | null;
  IsModifiable?: boolean | null;
}
function OptionGroupOptionSetting_Parse(node: xmlP.XmlNode): OptionGroupOptionSetting {
  return {
    ...node.strings({
      optional: {"SettingName":true,"SettingDescription":true,"DefaultValue":true,"ApplyType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface OrderableDBInstanceOption {
  Engine?: string | null;
  EngineVersion?: string | null;
  DBInstanceClass?: string | null;
  LicenseModel?: string | null;
  AvailabilityZones: AvailabilityZone[];
  MultiAZCapable?: boolean | null;
  ReadReplicaCapable?: boolean | null;
  Vpc?: boolean | null;
}
function OrderableDBInstanceOption_Parse(node: xmlP.XmlNode): OrderableDBInstanceOption {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBInstanceClass":true,"LicenseModel":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
    MultiAZCapable: node.first("MultiAZCapable", false, x => x.content === 'true'),
    ReadReplicaCapable: node.first("ReadReplicaCapable", false, x => x.content === 'true'),
    Vpc: node.first("Vpc", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: output, named, interface
export interface ReservedDBInstance {
  ReservedDBInstanceId?: string | null;
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  StartTime?: Date | number | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  DBInstanceCount?: number | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  State?: string | null;
  RecurringCharges: RecurringCharge[];
}
function ReservedDBInstance_Parse(node: xmlP.XmlNode): ReservedDBInstance {
  return {
    ...node.strings({
      optional: {"ReservedDBInstanceId":true,"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true,"State":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    DBInstanceCount: node.first("DBInstanceCount", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface RecurringCharge {
  RecurringChargeAmount?: number | null;
  RecurringChargeFrequency?: string | null;
}
function RecurringCharge_Parse(node: xmlP.XmlNode): RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReservedDBInstancesOffering {
  ReservedDBInstancesOfferingId?: string | null;
  DBInstanceClass?: string | null;
  Duration?: number | null;
  FixedPrice?: number | null;
  UsagePrice?: number | null;
  CurrencyCode?: string | null;
  ProductDescription?: string | null;
  OfferingType?: string | null;
  MultiAZ?: boolean | null;
  RecurringCharges: RecurringCharge[];
}
function ReservedDBInstancesOffering_Parse(node: xmlP.XmlNode): ReservedDBInstancesOffering {
  return {
    ...node.strings({
      optional: {"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}
