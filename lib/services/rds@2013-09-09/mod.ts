// Autogenerated API client for: Amazon Relational Database Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";

export default class RDS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(RDS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-09-09",
    "endpointPrefix": "rds",
    "protocol": "query",
    "serviceAbbreviation": "Amazon RDS",
    "serviceFullName": "Amazon Relational Database Service",
    "serviceId": "RDS",
    "signatureVersion": "v4",
    "uid": "rds-2013-09-09",
    "xmlNamespace": "http://rds.amazonaws.com/doc/2013-09-09/"
  };

  async addSourceIdentifierToSubscription(
    {abortSignal, ...params}: RequestConfig & s.AddSourceIdentifierToSubscriptionMessage,
  ): Promise<s.AddSourceIdentifierToSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddSourceIdentifierToSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AddSourceIdentifierToSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
  }

  async authorizeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.AuthorizeDBSecurityGroupIngressMessage,
  ): Promise<s.AuthorizeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AuthorizeDBSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "AuthorizeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async copyDBSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CopyDBSnapshotMessage,
  ): Promise<s.CopyDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBSnapshotIdentifier", (params["SourceDBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBSnapshotIdentifier", (params["TargetDBSnapshotIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CopyDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async createDBInstance(
    {abortSignal, ...params}: RequestConfig & s.CreateDBInstanceMessage,
  ): Promise<s.CreateDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    body.append(prefix+"MasterUsername", (params["MasterUsername"] ?? '').toString());
    body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if (params["DBSecurityGroups"]) qsP.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("CharacterSetName" in params) body.append(prefix+"CharacterSetName", (params["CharacterSetName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBInstanceReadReplica(
    {abortSignal, ...params}: RequestConfig & s.CreateDBInstanceReadReplicaMessage,
  ): Promise<s.CreateDBInstanceReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBInstanceReadReplica",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBInstanceReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async createDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDBParameterGroupMessage,
  ): Promise<s.CreateDBParameterGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBParameterGroupResult");
    return {
      DBParameterGroup: xml.first("DBParameterGroup", false, DBParameterGroup_Parse),
    };
  }

  async createDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDBSecurityGroupMessage,
  ): Promise<s.CreateDBSecurityGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    body.append(prefix+"DBSecurityGroupDescription", (params["DBSecurityGroupDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSecurityGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSecurityGroupResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  async createDBSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateDBSnapshotMessage,
  ): Promise<s.CreateDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async createDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateDBSubnetGroupMessage,
  ): Promise<s.CreateDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async createEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateEventSubscriptionMessage,
  ): Promise<s.CreateEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["SourceIds"]) qsP.appendList(body, prefix+"SourceIds", params["SourceIds"], {"entryPrefix":".SourceId."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async createOptionGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateOptionGroupMessage,
  ): Promise<s.CreateOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    body.append(prefix+"OptionGroupDescription", (params["OptionGroupDescription"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOptionGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async deleteDBInstance(
    {abortSignal, ...params}: RequestConfig & s.DeleteDBInstanceMessage,
  ): Promise<s.DeleteDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("SkipFinalSnapshot" in params) body.append(prefix+"SkipFinalSnapshot", (params["SkipFinalSnapshot"] ?? '').toString());
    if ("FinalDBSnapshotIdentifier" in params) body.append(prefix+"FinalDBSnapshotIdentifier", (params["FinalDBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async deleteDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDBParameterGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBParameterGroup",
    });
  }

  async deleteDBSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDBSecurityGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSecurityGroup",
    });
  }

  async deleteDBSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteDBSnapshotMessage,
  ): Promise<s.DeleteDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDBSnapshotResult");
    return {
      DBSnapshot: xml.first("DBSnapshot", false, DBSnapshot_Parse),
    };
  }

  async deleteDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteDBSubnetGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDBSubnetGroup",
    });
  }

  async deleteEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventSubscriptionMessage,
  ): Promise<s.DeleteEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async deleteOptionGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteOptionGroupMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOptionGroup",
    });
  }

  async describeDBEngineVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBEngineVersionsMessage = {},
  ): Promise<s.DBEngineVersionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBParameterGroupFamily" in params) body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("DefaultOnly" in params) body.append(prefix+"DefaultOnly", (params["DefaultOnly"] ?? '').toString());
    if ("ListSupportedCharacterSets" in params) body.append(prefix+"ListSupportedCharacterSets", (params["ListSupportedCharacterSets"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBEngineVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBEngineVersionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBEngineVersions: xml.getList("DBEngineVersions", "DBEngineVersion").map(DBEngineVersion_Parse),
    };
  }

  async describeDBInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBInstancesMessage = {},
  ): Promise<s.DBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBInstances: xml.getList("DBInstances", "DBInstance").map(DBInstance_Parse),
    };
  }

  async describeDBLogFiles(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBLogFilesMessage,
  ): Promise<s.DescribeDBLogFilesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("FilenameContains" in params) body.append(prefix+"FilenameContains", (params["FilenameContains"] ?? '').toString());
    if ("FileLastWritten" in params) body.append(prefix+"FileLastWritten", (params["FileLastWritten"] ?? '').toString());
    if ("FileSize" in params) body.append(prefix+"FileSize", (params["FileSize"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBLogFiles",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBLogFilesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DescribeDBLogFiles: xml.getList("DescribeDBLogFiles", "DescribeDBLogFilesDetails").map(DescribeDBLogFilesDetails_Parse),
    };
  }

  async describeDBParameterGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBParameterGroupsMessage = {},
  ): Promise<s.DBParameterGroupsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameterGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBParameterGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBParameterGroups: xml.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroup_Parse),
    };
  }

  async describeDBParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBParametersMessage,
  ): Promise<s.DBParameterGroupDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("Source" in params) body.append(prefix+"Source", (params["Source"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBParametersResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Parameters: xml.getList("Parameters", "Parameter").map(Parameter_Parse),
    };
  }

  async describeDBSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBSecurityGroupsMessage = {},
  ): Promise<s.DBSecurityGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSecurityGroupName" in params) body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSecurityGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSecurityGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSecurityGroups: xml.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroup_Parse),
    };
  }

  async describeDBSnapshots(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBSnapshotsMessage = {},
  ): Promise<s.DBSnapshotMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBInstanceIdentifier" in params) body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("DBSnapshotIdentifier" in params) body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("SnapshotType" in params) body.append(prefix+"SnapshotType", (params["SnapshotType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSnapshots",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSnapshotsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSnapshots: xml.getList("DBSnapshots", "DBSnapshot").map(DBSnapshot_Parse),
    };
  }

  async describeDBSubnetGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeDBSubnetGroupsMessage = {},
  ): Promise<s.DBSubnetGroupMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDBSubnetGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDBSubnetGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      DBSubnetGroups: xml.getList("DBSubnetGroups", "DBSubnetGroup").map(DBSubnetGroup_Parse),
    };
  }

  async describeEngineDefaultParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeEngineDefaultParametersMessage,
  ): Promise<s.DescribeEngineDefaultParametersResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupFamily", (params["DBParameterGroupFamily"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEngineDefaultParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEngineDefaultParametersResult");
    return {
      EngineDefaults: xml.first("EngineDefaults", false, EngineDefaults_Parse),
    };
  }

  async describeEventCategories(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventCategoriesMessage = {},
  ): Promise<s.EventCategoriesMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventCategories",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventCategoriesResult");
    return {
      EventCategoriesMapList: xml.getList("EventCategoriesMapList", "EventCategoriesMap").map(EventCategoriesMap_Parse),
    };
  }

  async describeEventSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventSubscriptionsMessage = {},
  ): Promise<s.EventSubscriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SubscriptionName" in params) body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventSubscriptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventSubscriptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      EventSubscriptionsList: xml.getList("EventSubscriptionsList", "EventSubscription").map(EventSubscription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsMessage = {},
  ): Promise<s.EventsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceIdentifier" in params) body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      Events: xml.getList("Events", "Event").map(Event_Parse),
    };
  }

  async describeOptionGroupOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeOptionGroupOptionsMessage,
  ): Promise<s.OptionGroupOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroupOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOptionGroupOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupOptions: xml.getList("OptionGroupOptions", "OptionGroupOption").map(OptionGroupOption_Parse),
    };
  }

  async describeOptionGroups(
    {abortSignal, ...params}: RequestConfig & s.DescribeOptionGroupsMessage = {},
  ): Promise<s.OptionGroups> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("EngineName" in params) body.append(prefix+"EngineName", (params["EngineName"] ?? '').toString());
    if ("MajorEngineVersion" in params) body.append(prefix+"MajorEngineVersion", (params["MajorEngineVersion"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOptionGroups",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOptionGroupsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OptionGroupsList: xml.getList("OptionGroupsList", "OptionGroup").map(OptionGroup_Parse),
    };
  }

  async describeOrderableDBInstanceOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeOrderableDBInstanceOptionsMessage,
  ): Promise<s.OrderableDBInstanceOptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("Vpc" in params) body.append(prefix+"Vpc", (params["Vpc"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeOrderableDBInstanceOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeOrderableDBInstanceOptionsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      OrderableDBInstanceOptions: xml.getList("OrderableDBInstanceOptions", "OrderableDBInstanceOption").map(OrderableDBInstanceOption_Parse),
    };
  }

  async describeReservedDBInstances(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedDBInstancesMessage = {},
  ): Promise<s.ReservedDBInstanceMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstances",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedDBInstancesResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstances: xml.getList("ReservedDBInstances", "ReservedDBInstance").map(ReservedDBInstance_Parse),
    };
  }

  async describeReservedDBInstancesOfferings(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservedDBInstancesOfferingsMessage = {},
  ): Promise<s.ReservedDBInstancesOfferingMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ReservedDBInstancesOfferingId" in params) body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Duration" in params) body.append(prefix+"Duration", (params["Duration"] ?? '').toString());
    if ("ProductDescription" in params) body.append(prefix+"ProductDescription", (params["ProductDescription"] ?? '').toString());
    if ("OfferingType" in params) body.append(prefix+"OfferingType", (params["OfferingType"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeReservedDBInstancesOfferings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeReservedDBInstancesOfferingsResult");
    return {
      ...xml.strings({
        optional: {"Marker":true},
      }),
      ReservedDBInstancesOfferings: xml.getList("ReservedDBInstancesOfferings", "ReservedDBInstancesOffering").map(ReservedDBInstancesOffering_Parse),
    };
  }

  async downloadDBLogFilePortion(
    {abortSignal, ...params}: RequestConfig & s.DownloadDBLogFilePortionMessage,
  ): Promise<s.DownloadDBLogFilePortionDetails> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"LogFileName", (params["LogFileName"] ?? '').toString());
    if ("Marker" in params) body.append(prefix+"Marker", (params["Marker"] ?? '').toString());
    if ("NumberOfLines" in params) body.append(prefix+"NumberOfLines", (params["NumberOfLines"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DownloadDBLogFilePortion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DownloadDBLogFilePortionResult");
    return {
      ...xml.strings({
        optional: {"LogFileData":true,"Marker":true},
      }),
      AdditionalDataPending: xml.first("AdditionalDataPending", false, x => x.content === 'true'),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceMessage,
  ): Promise<s.TagListMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":Filter_Serialize,"entryPrefix":".Filter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      TagList: xml.getList("TagList", "Tag").map(Tag_Parse),
    };
  }

  async modifyDBInstance(
    {abortSignal, ...params}: RequestConfig & s.ModifyDBInstanceMessage,
  ): Promise<s.ModifyDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("AllocatedStorage" in params) body.append(prefix+"AllocatedStorage", (params["AllocatedStorage"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if (params["DBSecurityGroups"]) qsP.appendList(body, prefix+"DBSecurityGroups", params["DBSecurityGroups"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupIds"]) qsP.appendList(body, prefix+"VpcSecurityGroupIds", params["VpcSecurityGroupIds"], {"entryPrefix":".VpcSecurityGroupId."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    if ("MasterUserPassword" in params) body.append(prefix+"MasterUserPassword", (params["MasterUserPassword"] ?? '').toString());
    if ("DBParameterGroupName" in params) body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    if ("PreferredMaintenanceWindow" in params) body.append(prefix+"PreferredMaintenanceWindow", (params["PreferredMaintenanceWindow"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("EngineVersion" in params) body.append(prefix+"EngineVersion", (params["EngineVersion"] ?? '').toString());
    if ("AllowMajorVersionUpgrade" in params) body.append(prefix+"AllowMajorVersionUpgrade", (params["AllowMajorVersionUpgrade"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if ("NewDBInstanceIdentifier" in params) body.append(prefix+"NewDBInstanceIdentifier", (params["NewDBInstanceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async modifyDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyDBParameterGroupMessage,
  ): Promise<s.DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async modifyDBSubnetGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyDBSubnetGroupMessage,
  ): Promise<s.ModifyDBSubnetGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("DBSubnetGroupDescription" in params) body.append(prefix+"DBSubnetGroupDescription", (params["DBSubnetGroupDescription"] ?? '').toString());
    if (params["SubnetIds"]) qsP.appendList(body, prefix+"SubnetIds", params["SubnetIds"], {"entryPrefix":".SubnetIdentifier."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyDBSubnetGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyDBSubnetGroupResult");
    return {
      DBSubnetGroup: xml.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    };
  }

  async modifyEventSubscription(
    {abortSignal, ...params}: RequestConfig & s.ModifyEventSubscriptionMessage,
  ): Promise<s.ModifyEventSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    if ("SnsTopicArn" in params) body.append(prefix+"SnsTopicArn", (params["SnsTopicArn"] ?? '').toString());
    if ("SourceType" in params) body.append(prefix+"SourceType", (params["SourceType"] ?? '').toString());
    if (params["EventCategories"]) qsP.appendList(body, prefix+"EventCategories", params["EventCategories"], {"entryPrefix":".EventCategory."})
    if ("Enabled" in params) body.append(prefix+"Enabled", (params["Enabled"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyEventSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyEventSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async modifyOptionGroup(
    {abortSignal, ...params}: RequestConfig & s.ModifyOptionGroupMessage,
  ): Promise<s.ModifyOptionGroupResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["OptionsToInclude"]) qsP.appendList(body, prefix+"OptionsToInclude", params["OptionsToInclude"], {"appender":OptionConfiguration_Serialize,"entryPrefix":".OptionConfiguration."})
    if (params["OptionsToRemove"]) qsP.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"entryPrefix":".member."})
    if ("ApplyImmediately" in params) body.append(prefix+"ApplyImmediately", (params["ApplyImmediately"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyOptionGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ModifyOptionGroupResult");
    return {
      OptionGroup: xml.first("OptionGroup", false, OptionGroup_Parse),
    };
  }

  async promoteReadReplica(
    {abortSignal, ...params}: RequestConfig & s.PromoteReadReplicaMessage,
  ): Promise<s.PromoteReadReplicaResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("BackupRetentionPeriod" in params) body.append(prefix+"BackupRetentionPeriod", (params["BackupRetentionPeriod"] ?? '').toString());
    if ("PreferredBackupWindow" in params) body.append(prefix+"PreferredBackupWindow", (params["PreferredBackupWindow"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PromoteReadReplica",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PromoteReadReplicaResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async purchaseReservedDBInstancesOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseReservedDBInstancesOfferingMessage,
  ): Promise<s.PurchaseReservedDBInstancesOfferingResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ReservedDBInstancesOfferingId", (params["ReservedDBInstancesOfferingId"] ?? '').toString());
    if ("ReservedDBInstanceId" in params) body.append(prefix+"ReservedDBInstanceId", (params["ReservedDBInstanceId"] ?? '').toString());
    if ("DBInstanceCount" in params) body.append(prefix+"DBInstanceCount", (params["DBInstanceCount"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseReservedDBInstancesOffering",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "PurchaseReservedDBInstancesOfferingResult");
    return {
      ReservedDBInstance: xml.first("ReservedDBInstance", false, ReservedDBInstance_Parse),
    };
  }

  async rebootDBInstance(
    {abortSignal, ...params}: RequestConfig & s.RebootDBInstanceMessage,
  ): Promise<s.RebootDBInstanceResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    if ("ForceFailover" in params) body.append(prefix+"ForceFailover", (params["ForceFailover"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebootDBInstance",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RebootDBInstanceResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async removeSourceIdentifierFromSubscription(
    {abortSignal, ...params}: RequestConfig & s.RemoveSourceIdentifierFromSubscriptionMessage,
  ): Promise<s.RemoveSourceIdentifierFromSubscriptionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SubscriptionName", (params["SubscriptionName"] ?? '').toString());
    body.append(prefix+"SourceIdentifier", (params["SourceIdentifier"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveSourceIdentifierFromSubscription",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RemoveSourceIdentifierFromSubscriptionResult");
    return {
      EventSubscription: xml.first("EventSubscription", false, EventSubscription_Parse),
    };
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceName", (params["ResourceName"] ?? '').toString());
    if (params["TagKeys"]) qsP.appendList(body, prefix+"TagKeys", params["TagKeys"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
  }

  async resetDBParameterGroup(
    {abortSignal, ...params}: RequestConfig & s.ResetDBParameterGroupMessage,
  ): Promise<s.DBParameterGroupNameMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBParameterGroupName", (params["DBParameterGroupName"] ?? '').toString());
    if ("ResetAllParameters" in params) body.append(prefix+"ResetAllParameters", (params["ResetAllParameters"] ?? '').toString());
    if (params["Parameters"]) qsP.appendList(body, prefix+"Parameters", params["Parameters"], {"appender":Parameter_Serialize,"entryPrefix":".Parameter."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetDBParameterGroup",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ResetDBParameterGroupResult");
    return xml.strings({
      optional: {"DBParameterGroupName":true},
    });
  }

  async restoreDBInstanceFromDBSnapshot(
    {abortSignal, ...params}: RequestConfig & s.RestoreDBInstanceFromDBSnapshotMessage,
  ): Promise<s.RestoreDBInstanceFromDBSnapshotResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBInstanceIdentifier", (params["DBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"DBSnapshotIdentifier", (params["DBSnapshotIdentifier"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceFromDBSnapshot",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBInstanceFromDBSnapshotResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async restoreDBInstanceToPointInTime(
    {abortSignal, ...params}: RequestConfig & s.RestoreDBInstanceToPointInTimeMessage,
  ): Promise<s.RestoreDBInstanceToPointInTimeResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"SourceDBInstanceIdentifier", (params["SourceDBInstanceIdentifier"] ?? '').toString());
    body.append(prefix+"TargetDBInstanceIdentifier", (params["TargetDBInstanceIdentifier"] ?? '').toString());
    if ("RestoreTime" in params) body.append(prefix+"RestoreTime", qsP.encodeDate_iso8601(params["RestoreTime"]));
    if ("UseLatestRestorableTime" in params) body.append(prefix+"UseLatestRestorableTime", (params["UseLatestRestorableTime"] ?? '').toString());
    if ("DBInstanceClass" in params) body.append(prefix+"DBInstanceClass", (params["DBInstanceClass"] ?? '').toString());
    if ("Port" in params) body.append(prefix+"Port", (params["Port"] ?? '').toString());
    if ("AvailabilityZone" in params) body.append(prefix+"AvailabilityZone", (params["AvailabilityZone"] ?? '').toString());
    if ("DBSubnetGroupName" in params) body.append(prefix+"DBSubnetGroupName", (params["DBSubnetGroupName"] ?? '').toString());
    if ("MultiAZ" in params) body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    if ("PubliclyAccessible" in params) body.append(prefix+"PubliclyAccessible", (params["PubliclyAccessible"] ?? '').toString());
    if ("AutoMinorVersionUpgrade" in params) body.append(prefix+"AutoMinorVersionUpgrade", (params["AutoMinorVersionUpgrade"] ?? '').toString());
    if ("LicenseModel" in params) body.append(prefix+"LicenseModel", (params["LicenseModel"] ?? '').toString());
    if ("DBName" in params) body.append(prefix+"DBName", (params["DBName"] ?? '').toString());
    if ("Engine" in params) body.append(prefix+"Engine", (params["Engine"] ?? '').toString());
    if ("Iops" in params) body.append(prefix+"Iops", (params["Iops"] ?? '').toString());
    if ("OptionGroupName" in params) body.append(prefix+"OptionGroupName", (params["OptionGroupName"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".Tag."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreDBInstanceToPointInTime",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RestoreDBInstanceToPointInTimeResult");
    return {
      DBInstance: xml.first("DBInstance", false, DBInstance_Parse),
    };
  }

  async revokeDBSecurityGroupIngress(
    {abortSignal, ...params}: RequestConfig & s.RevokeDBSecurityGroupIngressMessage,
  ): Promise<s.RevokeDBSecurityGroupIngressResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DBSecurityGroupName", (params["DBSecurityGroupName"] ?? '').toString());
    if ("CIDRIP" in params) body.append(prefix+"CIDRIP", (params["CIDRIP"] ?? '').toString());
    if ("EC2SecurityGroupName" in params) body.append(prefix+"EC2SecurityGroupName", (params["EC2SecurityGroupName"] ?? '').toString());
    if ("EC2SecurityGroupId" in params) body.append(prefix+"EC2SecurityGroupId", (params["EC2SecurityGroupId"] ?? '').toString());
    if ("EC2SecurityGroupOwnerId" in params) body.append(prefix+"EC2SecurityGroupOwnerId", (params["EC2SecurityGroupOwnerId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RevokeDBSecurityGroupIngress",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RevokeDBSecurityGroupIngressResult");
    return {
      DBSecurityGroup: xml.first("DBSecurityGroup", false, DBSecurityGroup_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceAvailable(
    params: RequestConfig & s.DescribeDBInstancesMessage,
  ): Promise<s.DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceAvailable';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
      if (field?.every(x => x === "available")) return resp;
      if (field?.some(x => x === "deleted")) throw new Error(errMessage);
      if (field?.some(x => x === "deleting")) throw new Error(errMessage);
      if (field?.some(x => x === "failed")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-parameters")) throw new Error(errMessage);
      if (field?.some(x => x === "incompatible-restore")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForDBInstanceDeleted(
    params: RequestConfig & s.DescribeDBInstancesMessage,
  ): Promise<s.DBInstanceMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DBInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeDBInstances(params);
      const field = resp?.DBInstances?.flatMap(x => x?.DBInstanceStatus);
      if (field?.every(x => x === "deleted")) return resp;
      if (field?.some(x => x === "creating")) throw new Error(errMessage);
      if (field?.some(x => x === "modifying")) throw new Error(errMessage);
      if (field?.some(x => x === "rebooting")) throw new Error(errMessage);
      if (field?.some(x => x === "resetting-master-credentials")) throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function Filter_Serialize(body: URLSearchParams, prefix: string, params: s.Filter) {
    body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".Value."})
}

function Parameter_Serialize(body: URLSearchParams, prefix: string, params: s.Parameter) {
    if ("ParameterName" in params) body.append(prefix+".ParameterName", (params["ParameterName"] ?? '').toString());
    if ("ParameterValue" in params) body.append(prefix+".ParameterValue", (params["ParameterValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("Source" in params) body.append(prefix+".Source", (params["Source"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("MinimumEngineVersion" in params) body.append(prefix+".MinimumEngineVersion", (params["MinimumEngineVersion"] ?? '').toString());
    if ("ApplyMethod" in params) body.append(prefix+".ApplyMethod", (params["ApplyMethod"] ?? '').toString());
}
function Parameter_Parse(node: xmlP.XmlNode): s.Parameter {
  return {
    ...node.strings({
      optional: {"ParameterName":true,"ParameterValue":true,"Description":true,"Source":true,"ApplyType":true,"DataType":true,"AllowedValues":true,"MinimumEngineVersion":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    ApplyMethod: node.first("ApplyMethod", false, x => (x.content ?? '') as s.ApplyMethod),
  };
}

function OptionConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.OptionConfiguration) {
    body.append(prefix+".OptionName", (params["OptionName"] ?? '').toString());
    if ("Port" in params) body.append(prefix+".Port", (params["Port"] ?? '').toString());
    if (params["DBSecurityGroupMemberships"]) qsP.appendList(body, prefix+".DBSecurityGroupMemberships", params["DBSecurityGroupMemberships"], {"entryPrefix":".DBSecurityGroupName."})
    if (params["VpcSecurityGroupMemberships"]) qsP.appendList(body, prefix+".VpcSecurityGroupMemberships", params["VpcSecurityGroupMemberships"], {"entryPrefix":".VpcSecurityGroupId."})
    if (params["OptionSettings"]) qsP.appendList(body, prefix+".OptionSettings", params["OptionSettings"], {"appender":OptionSetting_Serialize,"entryPrefix":".OptionSetting."})
}

function OptionSetting_Serialize(body: URLSearchParams, prefix: string, params: s.OptionSetting) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("Description" in params) body.append(prefix+".Description", (params["Description"] ?? '').toString());
    if ("ApplyType" in params) body.append(prefix+".ApplyType", (params["ApplyType"] ?? '').toString());
    if ("DataType" in params) body.append(prefix+".DataType", (params["DataType"] ?? '').toString());
    if ("AllowedValues" in params) body.append(prefix+".AllowedValues", (params["AllowedValues"] ?? '').toString());
    if ("IsModifiable" in params) body.append(prefix+".IsModifiable", (params["IsModifiable"] ?? '').toString());
    if ("IsCollection" in params) body.append(prefix+".IsCollection", (params["IsCollection"] ?? '').toString());
}
function OptionSetting_Parse(node: xmlP.XmlNode): s.OptionSetting {
  return {
    ...node.strings({
      optional: {"Name":true,"Value":true,"DefaultValue":true,"Description":true,"ApplyType":true,"DataType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
    IsCollection: node.first("IsCollection", false, x => x.content === 'true'),
  };
}

function EventSubscription_Parse(node: xmlP.XmlNode): s.EventSubscription {
  return {
    ...node.strings({
      optional: {"CustomerAwsId":true,"CustSubscriptionId":true,"SnsTopicArn":true,"Status":true,"SubscriptionCreationTime":true,"SourceType":true},
    }),
    SourceIdsList: node.getList("SourceIdsList", "SourceId").map(x => x.content ?? ''),
    EventCategoriesList: node.getList("EventCategoriesList", "EventCategory").map(x => x.content ?? ''),
    Enabled: node.first("Enabled", false, x => x.content === 'true'),
  };
}

function DBSecurityGroup_Parse(node: xmlP.XmlNode): s.DBSecurityGroup {
  return {
    ...node.strings({
      optional: {"OwnerId":true,"DBSecurityGroupName":true,"DBSecurityGroupDescription":true,"VpcId":true},
    }),
    EC2SecurityGroups: node.getList("EC2SecurityGroups", "EC2SecurityGroup").map(EC2SecurityGroup_Parse),
    IPRanges: node.getList("IPRanges", "IPRange").map(IPRange_Parse),
  };
}

function EC2SecurityGroup_Parse(node: xmlP.XmlNode): s.EC2SecurityGroup {
  return node.strings({
    optional: {"Status":true,"EC2SecurityGroupName":true,"EC2SecurityGroupId":true,"EC2SecurityGroupOwnerId":true},
  });
}

function IPRange_Parse(node: xmlP.XmlNode): s.IPRange {
  return node.strings({
    optional: {"Status":true,"CIDRIP":true},
  });
}

function DBSnapshot_Parse(node: xmlP.XmlNode): s.DBSnapshot {
  return {
    ...node.strings({
      optional: {"DBSnapshotIdentifier":true,"DBInstanceIdentifier":true,"Engine":true,"Status":true,"AvailabilityZone":true,"VpcId":true,"MasterUsername":true,"EngineVersion":true,"LicenseModel":true,"SnapshotType":true,"OptionGroupName":true,"SourceRegion":true},
    }),
    SnapshotCreateTime: node.first("SnapshotCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    PercentProgress: node.first("PercentProgress", false, x => parseInt(x.content ?? '0')),
  };
}

function DBInstance_Parse(node: xmlP.XmlNode): s.DBInstance {
  return {
    ...node.strings({
      optional: {"DBInstanceIdentifier":true,"DBInstanceClass":true,"Engine":true,"DBInstanceStatus":true,"MasterUsername":true,"DBName":true,"PreferredBackupWindow":true,"AvailabilityZone":true,"PreferredMaintenanceWindow":true,"EngineVersion":true,"ReadReplicaSourceDBInstanceIdentifier":true,"LicenseModel":true,"CharacterSetName":true,"SecondaryAvailabilityZone":true},
    }),
    Endpoint: node.first("Endpoint", false, Endpoint_Parse),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    InstanceCreateTime: node.first("InstanceCreateTime", false, x => xmlP.parseTimestamp(x.content)),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    DBSecurityGroups: node.getList("DBSecurityGroups", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroups: node.getList("VpcSecurityGroups", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
    DBParameterGroups: node.getList("DBParameterGroups", "DBParameterGroup").map(DBParameterGroupStatus_Parse),
    DBSubnetGroup: node.first("DBSubnetGroup", false, DBSubnetGroup_Parse),
    PendingModifiedValues: node.first("PendingModifiedValues", false, PendingModifiedValues_Parse),
    LatestRestorableTime: node.first("LatestRestorableTime", false, x => xmlP.parseTimestamp(x.content)),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    AutoMinorVersionUpgrade: node.first("AutoMinorVersionUpgrade", false, x => x.content === 'true'),
    ReadReplicaDBInstanceIdentifiers: node.getList("ReadReplicaDBInstanceIdentifiers", "ReadReplicaDBInstanceIdentifier").map(x => x.content ?? ''),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
    OptionGroupMemberships: node.getList("OptionGroupMemberships", "OptionGroupMembership").map(OptionGroupMembership_Parse),
    PubliclyAccessible: node.first("PubliclyAccessible", false, x => x.content === 'true'),
    StatusInfos: node.getList("StatusInfos", "DBInstanceStatusInfo").map(DBInstanceStatusInfo_Parse),
  };
}

function Endpoint_Parse(node: xmlP.XmlNode): s.Endpoint {
  return {
    ...node.strings({
      optional: {"Address":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

function DBSecurityGroupMembership_Parse(node: xmlP.XmlNode): s.DBSecurityGroupMembership {
  return node.strings({
    optional: {"DBSecurityGroupName":true,"Status":true},
  });
}

function VpcSecurityGroupMembership_Parse(node: xmlP.XmlNode): s.VpcSecurityGroupMembership {
  return node.strings({
    optional: {"VpcSecurityGroupId":true,"Status":true},
  });
}

function DBParameterGroupStatus_Parse(node: xmlP.XmlNode): s.DBParameterGroupStatus {
  return node.strings({
    optional: {"DBParameterGroupName":true,"ParameterApplyStatus":true},
  });
}

function DBSubnetGroup_Parse(node: xmlP.XmlNode): s.DBSubnetGroup {
  return {
    ...node.strings({
      optional: {"DBSubnetGroupName":true,"DBSubnetGroupDescription":true,"VpcId":true,"SubnetGroupStatus":true},
    }),
    Subnets: node.getList("Subnets", "Subnet").map(Subnet_Parse),
  };
}

function Subnet_Parse(node: xmlP.XmlNode): s.Subnet {
  return {
    ...node.strings({
      optional: {"SubnetIdentifier":true,"SubnetStatus":true},
    }),
    SubnetAvailabilityZone: node.first("SubnetAvailabilityZone", false, AvailabilityZone_Parse),
  };
}

function AvailabilityZone_Parse(node: xmlP.XmlNode): s.AvailabilityZone {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    ProvisionedIopsCapable: node.first("ProvisionedIopsCapable", false, x => x.content === 'true'),
  };
}

function PendingModifiedValues_Parse(node: xmlP.XmlNode): s.PendingModifiedValues {
  return {
    ...node.strings({
      optional: {"DBInstanceClass":true,"MasterUserPassword":true,"EngineVersion":true,"DBInstanceIdentifier":true},
    }),
    AllocatedStorage: node.first("AllocatedStorage", false, x => parseInt(x.content ?? '0')),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    BackupRetentionPeriod: node.first("BackupRetentionPeriod", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    Iops: node.first("Iops", false, x => parseInt(x.content ?? '0')),
  };
}

function OptionGroupMembership_Parse(node: xmlP.XmlNode): s.OptionGroupMembership {
  return node.strings({
    optional: {"OptionGroupName":true,"Status":true},
  });
}

function DBInstanceStatusInfo_Parse(node: xmlP.XmlNode): s.DBInstanceStatusInfo {
  return {
    ...node.strings({
      optional: {"StatusType":true,"Status":true,"Message":true},
    }),
    Normal: node.first("Normal", false, x => x.content === 'true'),
  };
}

function DBParameterGroup_Parse(node: xmlP.XmlNode): s.DBParameterGroup {
  return node.strings({
    optional: {"DBParameterGroupName":true,"DBParameterGroupFamily":true,"Description":true},
  });
}

function OptionGroup_Parse(node: xmlP.XmlNode): s.OptionGroup {
  return {
    ...node.strings({
      optional: {"OptionGroupName":true,"OptionGroupDescription":true,"EngineName":true,"MajorEngineVersion":true,"VpcId":true},
    }),
    Options: node.getList("Options", "Option").map(Option_Parse),
    AllowsVpcAndNonVpcInstanceMemberships: node.first("AllowsVpcAndNonVpcInstanceMemberships", false, x => x.content === 'true'),
  };
}

function Option_Parse(node: xmlP.XmlNode): s.Option {
  return {
    ...node.strings({
      optional: {"OptionName":true,"OptionDescription":true},
    }),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    OptionSettings: node.getList("OptionSettings", "OptionSetting").map(OptionSetting_Parse),
    DBSecurityGroupMemberships: node.getList("DBSecurityGroupMemberships", "DBSecurityGroup").map(DBSecurityGroupMembership_Parse),
    VpcSecurityGroupMemberships: node.getList("VpcSecurityGroupMemberships", "VpcSecurityGroupMembership").map(VpcSecurityGroupMembership_Parse),
  };
}

function DBEngineVersion_Parse(node: xmlP.XmlNode): s.DBEngineVersion {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBParameterGroupFamily":true,"DBEngineDescription":true,"DBEngineVersionDescription":true},
    }),
    DefaultCharacterSet: node.first("DefaultCharacterSet", false, CharacterSet_Parse),
    SupportedCharacterSets: node.getList("SupportedCharacterSets", "CharacterSet").map(CharacterSet_Parse),
  };
}

function CharacterSet_Parse(node: xmlP.XmlNode): s.CharacterSet {
  return node.strings({
    optional: {"CharacterSetName":true,"CharacterSetDescription":true},
  });
}

function DescribeDBLogFilesDetails_Parse(node: xmlP.XmlNode): s.DescribeDBLogFilesDetails {
  return {
    ...node.strings({
      optional: {"LogFileName":true},
    }),
    LastWritten: node.first("LastWritten", false, x => parseInt(x.content ?? '0')),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

function EngineDefaults_Parse(node: xmlP.XmlNode): s.EngineDefaults {
  return {
    ...node.strings({
      optional: {"DBParameterGroupFamily":true,"Marker":true},
    }),
    Parameters: node.getList("Parameters", "Parameter").map(Parameter_Parse),
  };
}

function EventCategoriesMap_Parse(node: xmlP.XmlNode): s.EventCategoriesMap {
  return {
    ...node.strings({
      optional: {"SourceType":true},
    }),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
  };
}

function Event_Parse(node: xmlP.XmlNode): s.Event {
  return {
    ...node.strings({
      optional: {"SourceIdentifier":true,"Message":true},
    }),
    SourceType: node.first("SourceType", false, x => (x.content ?? '') as s.SourceType),
    EventCategories: node.getList("EventCategories", "EventCategory").map(x => x.content ?? ''),
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function OptionGroupOption_Parse(node: xmlP.XmlNode): s.OptionGroupOption {
  return {
    ...node.strings({
      optional: {"Name":true,"Description":true,"EngineName":true,"MajorEngineVersion":true,"MinimumRequiredMinorEngineVersion":true},
    }),
    PortRequired: node.first("PortRequired", false, x => x.content === 'true'),
    DefaultPort: node.first("DefaultPort", false, x => parseInt(x.content ?? '0')),
    OptionsDependedOn: node.getList("OptionsDependedOn", "OptionName").map(x => x.content ?? ''),
    Persistent: node.first("Persistent", false, x => x.content === 'true'),
    Permanent: node.first("Permanent", false, x => x.content === 'true'),
    OptionGroupOptionSettings: node.getList("OptionGroupOptionSettings", "OptionGroupOptionSetting").map(OptionGroupOptionSetting_Parse),
  };
}

function OptionGroupOptionSetting_Parse(node: xmlP.XmlNode): s.OptionGroupOptionSetting {
  return {
    ...node.strings({
      optional: {"SettingName":true,"SettingDescription":true,"DefaultValue":true,"ApplyType":true,"AllowedValues":true},
    }),
    IsModifiable: node.first("IsModifiable", false, x => x.content === 'true'),
  };
}

function OrderableDBInstanceOption_Parse(node: xmlP.XmlNode): s.OrderableDBInstanceOption {
  return {
    ...node.strings({
      optional: {"Engine":true,"EngineVersion":true,"DBInstanceClass":true,"LicenseModel":true},
    }),
    AvailabilityZones: node.getList("AvailabilityZones", "AvailabilityZone").map(AvailabilityZone_Parse),
    MultiAZCapable: node.first("MultiAZCapable", false, x => x.content === 'true'),
    ReadReplicaCapable: node.first("ReadReplicaCapable", false, x => x.content === 'true'),
    Vpc: node.first("Vpc", false, x => x.content === 'true'),
  };
}

function ReservedDBInstance_Parse(node: xmlP.XmlNode): s.ReservedDBInstance {
  return {
    ...node.strings({
      optional: {"ReservedDBInstanceId":true,"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true,"State":true},
    }),
    StartTime: node.first("StartTime", false, x => xmlP.parseTimestamp(x.content)),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    DBInstanceCount: node.first("DBInstanceCount", false, x => parseInt(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}

function RecurringCharge_Parse(node: xmlP.XmlNode): s.RecurringCharge {
  return {
    ...node.strings({
      optional: {"RecurringChargeFrequency":true},
    }),
    RecurringChargeAmount: node.first("RecurringChargeAmount", false, x => parseFloat(x.content ?? '0')),
  };
}

function ReservedDBInstancesOffering_Parse(node: xmlP.XmlNode): s.ReservedDBInstancesOffering {
  return {
    ...node.strings({
      optional: {"ReservedDBInstancesOfferingId":true,"DBInstanceClass":true,"CurrencyCode":true,"ProductDescription":true,"OfferingType":true},
    }),
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    FixedPrice: node.first("FixedPrice", false, x => parseFloat(x.content ?? '0')),
    UsagePrice: node.first("UsagePrice", false, x => parseFloat(x.content ?? '0')),
    MultiAZ: node.first("MultiAZ", false, x => x.content === 'true'),
    RecurringCharges: node.getList("RecurringCharges", "RecurringCharge").map(RecurringCharge_Parse),
  };
}
