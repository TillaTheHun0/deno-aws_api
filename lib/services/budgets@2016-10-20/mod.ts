// Autogenerated API client for: AWS Budgets

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class Budgets {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Budgets.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-10-20",
    "endpointPrefix": "budgets",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWSBudgets",
    "serviceFullName": "AWS Budgets",
    "serviceId": "Budgets",
    "signatureVersion": "v4",
    "targetPrefix": "AWSBudgetServiceGateway",
    "uid": "budgets-2016-10-20"
  };

  async createBudget(
    {abortSignal, ...params}: RequestConfig & s.CreateBudgetRequest,
  ): Promise<s.CreateBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      Budget: fromBudget(params["Budget"]),
      NotificationsWithSubscribers: params["NotificationsWithSubscribers"]?.map(x => fromNotificationWithSubscribers(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBudget",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createBudgetAction(
    {abortSignal, ...params}: RequestConfig & s.CreateBudgetActionRequest,
  ): Promise<s.CreateBudgetActionResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      NotificationType: params["NotificationType"],
      ActionType: params["ActionType"],
      ActionThreshold: fromActionThreshold(params["ActionThreshold"]),
      Definition: fromDefinition(params["Definition"]),
      ExecutionRoleArn: params["ExecutionRoleArn"],
      ApprovalModel: params["ApprovalModel"],
      Subscribers: params["Subscribers"]?.map(x => fromSubscriber(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBudgetAction",
    });
    return jsonP.readObj({
      required: {
        "AccountId": "s",
        "BudgetName": "s",
        "ActionId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createNotification(
    {abortSignal, ...params}: RequestConfig & s.CreateNotificationRequest,
  ): Promise<s.CreateNotificationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
      Subscribers: params["Subscribers"]?.map(x => fromSubscriber(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotification",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createSubscriber(
    {abortSignal, ...params}: RequestConfig & s.CreateSubscriberRequest,
  ): Promise<s.CreateSubscriberResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
      Subscriber: fromSubscriber(params["Subscriber"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSubscriber",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteBudget(
    {abortSignal, ...params}: RequestConfig & s.DeleteBudgetRequest,
  ): Promise<s.DeleteBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBudget",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteBudgetAction(
    {abortSignal, ...params}: RequestConfig & s.DeleteBudgetActionRequest,
  ): Promise<s.DeleteBudgetActionResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      ActionId: params["ActionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBudgetAction",
    });
    return jsonP.readObj({
      required: {
        "AccountId": "s",
        "BudgetName": "s",
        "Action": toAction,
      },
      optional: {},
    }, await resp.json());
  }

  async deleteNotification(
    {abortSignal, ...params}: RequestConfig & s.DeleteNotificationRequest,
  ): Promise<s.DeleteNotificationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotification",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSubscriber(
    {abortSignal, ...params}: RequestConfig & s.DeleteSubscriberRequest,
  ): Promise<s.DeleteSubscriberResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
      Subscriber: fromSubscriber(params["Subscriber"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSubscriber",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeBudget(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetRequest,
  ): Promise<s.DescribeBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Budget": toBudget,
      },
    }, await resp.json());
  }

  async describeBudgetAction(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetActionRequest,
  ): Promise<s.DescribeBudgetActionResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      ActionId: params["ActionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgetAction",
    });
    return jsonP.readObj({
      required: {
        "AccountId": "s",
        "BudgetName": "s",
        "Action": toAction,
      },
      optional: {},
    }, await resp.json());
  }

  async describeBudgetActionHistories(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetActionHistoriesRequest,
  ): Promise<s.DescribeBudgetActionHistoriesResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      ActionId: params["ActionId"],
      TimePeriod: fromTimePeriod(params["TimePeriod"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgetActionHistories",
    });
    return jsonP.readObj({
      required: {
        "ActionHistories": [toActionHistory],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeBudgetActionsForAccount(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetActionsForAccountRequest,
  ): Promise<s.DescribeBudgetActionsForAccountResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgetActionsForAccount",
    });
    return jsonP.readObj({
      required: {
        "Actions": [toAction],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeBudgetActionsForBudget(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetActionsForBudgetRequest,
  ): Promise<s.DescribeBudgetActionsForBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgetActionsForBudget",
    });
    return jsonP.readObj({
      required: {
        "Actions": [toAction],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeBudgetPerformanceHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetPerformanceHistoryRequest,
  ): Promise<s.DescribeBudgetPerformanceHistoryResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      TimePeriod: fromTimePeriod(params["TimePeriod"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgetPerformanceHistory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BudgetPerformanceHistory": toBudgetPerformanceHistory,
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeBudgets(
    {abortSignal, ...params}: RequestConfig & s.DescribeBudgetsRequest,
  ): Promise<s.DescribeBudgetsResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBudgets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Budgets": [toBudget],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeNotificationsForBudget(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotificationsForBudgetRequest,
  ): Promise<s.DescribeNotificationsForBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotificationsForBudget",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Notifications": [toNotification],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeSubscribersForNotification(
    {abortSignal, ...params}: RequestConfig & s.DescribeSubscribersForNotificationRequest,
  ): Promise<s.DescribeSubscribersForNotificationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubscribersForNotification",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Subscribers": [toSubscriber],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async executeBudgetAction(
    {abortSignal, ...params}: RequestConfig & s.ExecuteBudgetActionRequest,
  ): Promise<s.ExecuteBudgetActionResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      ActionId: params["ActionId"],
      ExecutionType: params["ExecutionType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteBudgetAction",
    });
    return jsonP.readObj({
      required: {
        "AccountId": "s",
        "BudgetName": "s",
        "ActionId": "s",
        "ExecutionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionType>(x),
      },
      optional: {},
    }, await resp.json());
  }

  async updateBudget(
    {abortSignal, ...params}: RequestConfig & s.UpdateBudgetRequest,
  ): Promise<s.UpdateBudgetResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      NewBudget: fromBudget(params["NewBudget"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBudget",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateBudgetAction(
    {abortSignal, ...params}: RequestConfig & s.UpdateBudgetActionRequest,
  ): Promise<s.UpdateBudgetActionResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      ActionId: params["ActionId"],
      NotificationType: params["NotificationType"],
      ActionThreshold: fromActionThreshold(params["ActionThreshold"]),
      Definition: fromDefinition(params["Definition"]),
      ExecutionRoleArn: params["ExecutionRoleArn"],
      ApprovalModel: params["ApprovalModel"],
      Subscribers: params["Subscribers"]?.map(x => fromSubscriber(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBudgetAction",
    });
    return jsonP.readObj({
      required: {
        "AccountId": "s",
        "BudgetName": "s",
        "OldAction": toAction,
        "NewAction": toAction,
      },
      optional: {},
    }, await resp.json());
  }

  async updateNotification(
    {abortSignal, ...params}: RequestConfig & s.UpdateNotificationRequest,
  ): Promise<s.UpdateNotificationResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      OldNotification: fromNotification(params["OldNotification"]),
      NewNotification: fromNotification(params["NewNotification"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotification",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateSubscriber(
    {abortSignal, ...params}: RequestConfig & s.UpdateSubscriberRequest,
  ): Promise<s.UpdateSubscriberResponse> {
    const body: jsonP.JSONObject = {
      AccountId: params["AccountId"],
      BudgetName: params["BudgetName"],
      Notification: fromNotification(params["Notification"]),
      OldSubscriber: fromSubscriber(params["OldSubscriber"]),
      NewSubscriber: fromSubscriber(params["NewSubscriber"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSubscriber",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromBudget(input?: s.Budget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BudgetName: input["BudgetName"],
    BudgetLimit: fromSpend(input["BudgetLimit"]),
    PlannedBudgetLimits: jsonP.serializeMap(input["PlannedBudgetLimits"], x => fromSpend(x)),
    CostFilters: input["CostFilters"],
    CostTypes: fromCostTypes(input["CostTypes"]),
    TimeUnit: input["TimeUnit"],
    TimePeriod: fromTimePeriod(input["TimePeriod"]),
    CalculatedSpend: fromCalculatedSpend(input["CalculatedSpend"]),
    BudgetType: input["BudgetType"],
    LastUpdatedTime: jsonP.serializeDate_unixTimestamp(input["LastUpdatedTime"]),
  }
}
function toBudget(root: jsonP.JSONValue): s.Budget {
  return jsonP.readObj({
    required: {
      "BudgetName": "s",
      "TimeUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnit>(x),
      "BudgetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BudgetType>(x),
    },
    optional: {
      "BudgetLimit": toSpend,
      "PlannedBudgetLimits": x => jsonP.readMap(String, toSpend, x),
      "CostFilters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "CostTypes": toCostTypes,
      "TimePeriod": toTimePeriod,
      "CalculatedSpend": toCalculatedSpend,
      "LastUpdatedTime": "d",
    },
  }, root);
}

function fromSpend(input?: s.Spend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Amount: input["Amount"],
    Unit: input["Unit"],
  }
}
function toSpend(root: jsonP.JSONValue): s.Spend {
  return jsonP.readObj({
    required: {
      "Amount": "s",
      "Unit": "s",
    },
    optional: {},
  }, root);
}

function fromCostTypes(input?: s.CostTypes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IncludeTax: input["IncludeTax"],
    IncludeSubscription: input["IncludeSubscription"],
    UseBlended: input["UseBlended"],
    IncludeRefund: input["IncludeRefund"],
    IncludeCredit: input["IncludeCredit"],
    IncludeUpfront: input["IncludeUpfront"],
    IncludeRecurring: input["IncludeRecurring"],
    IncludeOtherSubscription: input["IncludeOtherSubscription"],
    IncludeSupport: input["IncludeSupport"],
    IncludeDiscount: input["IncludeDiscount"],
    UseAmortized: input["UseAmortized"],
  }
}
function toCostTypes(root: jsonP.JSONValue): s.CostTypes {
  return jsonP.readObj({
    required: {},
    optional: {
      "IncludeTax": "b",
      "IncludeSubscription": "b",
      "UseBlended": "b",
      "IncludeRefund": "b",
      "IncludeCredit": "b",
      "IncludeUpfront": "b",
      "IncludeRecurring": "b",
      "IncludeOtherSubscription": "b",
      "IncludeSupport": "b",
      "IncludeDiscount": "b",
      "UseAmortized": "b",
    },
  }, root);
}

function fromTimePeriod(input?: s.TimePeriod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Start: jsonP.serializeDate_unixTimestamp(input["Start"]),
    End: jsonP.serializeDate_unixTimestamp(input["End"]),
  }
}
function toTimePeriod(root: jsonP.JSONValue): s.TimePeriod {
  return jsonP.readObj({
    required: {},
    optional: {
      "Start": "d",
      "End": "d",
    },
  }, root);
}

function fromCalculatedSpend(input?: s.CalculatedSpend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ActualSpend: fromSpend(input["ActualSpend"]),
    ForecastedSpend: fromSpend(input["ForecastedSpend"]),
  }
}
function toCalculatedSpend(root: jsonP.JSONValue): s.CalculatedSpend {
  return jsonP.readObj({
    required: {
      "ActualSpend": toSpend,
    },
    optional: {
      "ForecastedSpend": toSpend,
    },
  }, root);
}

function fromNotificationWithSubscribers(input?: s.NotificationWithSubscribers | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Notification: fromNotification(input["Notification"]),
    Subscribers: input["Subscribers"]?.map(x => fromSubscriber(x)),
  }
}

function fromNotification(input?: s.Notification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotificationType: input["NotificationType"],
    ComparisonOperator: input["ComparisonOperator"],
    Threshold: input["Threshold"],
    ThresholdType: input["ThresholdType"],
    NotificationState: input["NotificationState"],
  }
}
function toNotification(root: jsonP.JSONValue): s.Notification {
  return jsonP.readObj({
    required: {
      "NotificationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotificationType>(x),
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperator>(x),
      "Threshold": "n",
    },
    optional: {
      "ThresholdType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThresholdType>(x),
      "NotificationState": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotificationState>(x),
    },
  }, root);
}

function fromSubscriber(input?: s.Subscriber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubscriptionType: input["SubscriptionType"],
    Address: input["Address"],
  }
}
function toSubscriber(root: jsonP.JSONValue): s.Subscriber {
  return jsonP.readObj({
    required: {
      "SubscriptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SubscriptionType>(x),
      "Address": "s",
    },
    optional: {},
  }, root);
}

function fromActionThreshold(input?: s.ActionThreshold | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ActionThresholdValue: input["ActionThresholdValue"],
    ActionThresholdType: input["ActionThresholdType"],
  }
}
function toActionThreshold(root: jsonP.JSONValue): s.ActionThreshold {
  return jsonP.readObj({
    required: {
      "ActionThresholdValue": "n",
      "ActionThresholdType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThresholdType>(x),
    },
    optional: {},
  }, root);
}

function fromDefinition(input?: s.Definition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IamActionDefinition: fromIamActionDefinition(input["IamActionDefinition"]),
    ScpActionDefinition: fromScpActionDefinition(input["ScpActionDefinition"]),
    SsmActionDefinition: fromSsmActionDefinition(input["SsmActionDefinition"]),
  }
}
function toDefinition(root: jsonP.JSONValue): s.Definition {
  return jsonP.readObj({
    required: {},
    optional: {
      "IamActionDefinition": toIamActionDefinition,
      "ScpActionDefinition": toScpActionDefinition,
      "SsmActionDefinition": toSsmActionDefinition,
    },
  }, root);
}

function fromIamActionDefinition(input?: s.IamActionDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyArn: input["PolicyArn"],
    Roles: input["Roles"],
    Groups: input["Groups"],
    Users: input["Users"],
  }
}
function toIamActionDefinition(root: jsonP.JSONValue): s.IamActionDefinition {
  return jsonP.readObj({
    required: {
      "PolicyArn": "s",
    },
    optional: {
      "Roles": ["s"],
      "Groups": ["s"],
      "Users": ["s"],
    },
  }, root);
}

function fromScpActionDefinition(input?: s.ScpActionDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyId: input["PolicyId"],
    TargetIds: input["TargetIds"],
  }
}
function toScpActionDefinition(root: jsonP.JSONValue): s.ScpActionDefinition {
  return jsonP.readObj({
    required: {
      "PolicyId": "s",
      "TargetIds": ["s"],
    },
    optional: {},
  }, root);
}

function fromSsmActionDefinition(input?: s.SsmActionDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ActionSubType: input["ActionSubType"],
    Region: input["Region"],
    InstanceIds: input["InstanceIds"],
  }
}
function toSsmActionDefinition(root: jsonP.JSONValue): s.SsmActionDefinition {
  return jsonP.readObj({
    required: {
      "ActionSubType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionSubType>(x),
      "Region": "s",
      "InstanceIds": ["s"],
    },
    optional: {},
  }, root);
}

function toAction(root: jsonP.JSONValue): s.Action {
  return jsonP.readObj({
    required: {
      "ActionId": "s",
      "BudgetName": "s",
      "NotificationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotificationType>(x),
      "ActionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionType>(x),
      "ActionThreshold": toActionThreshold,
      "Definition": toDefinition,
      "ExecutionRoleArn": "s",
      "ApprovalModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.ApprovalModel>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionStatus>(x),
      "Subscribers": [toSubscriber],
    },
    optional: {},
  }, root);
}

function toActionHistory(root: jsonP.JSONValue): s.ActionHistory {
  return jsonP.readObj({
    required: {
      "Timestamp": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionStatus>(x),
      "EventType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventType>(x),
      "ActionHistoryDetails": toActionHistoryDetails,
    },
    optional: {},
  }, root);
}

function toActionHistoryDetails(root: jsonP.JSONValue): s.ActionHistoryDetails {
  return jsonP.readObj({
    required: {
      "Message": "s",
      "Action": toAction,
    },
    optional: {},
  }, root);
}

function toBudgetPerformanceHistory(root: jsonP.JSONValue): s.BudgetPerformanceHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "BudgetName": "s",
      "BudgetType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BudgetType>(x),
      "CostFilters": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "CostTypes": toCostTypes,
      "TimeUnit": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimeUnit>(x),
      "BudgetedAndActualAmountsList": [toBudgetedAndActualAmounts],
    },
  }, root);
}

function toBudgetedAndActualAmounts(root: jsonP.JSONValue): s.BudgetedAndActualAmounts {
  return jsonP.readObj({
    required: {},
    optional: {
      "BudgetedAmount": toSpend,
      "ActualAmount": toSpend,
      "TimePeriod": toTimePeriod,
    },
  }, root);
}
