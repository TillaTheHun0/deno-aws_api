// Autogenerated API client for: Amazon Lex Model Building Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class LexModelBuildingService {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexModelBuildingService.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-04-19",
    "endpointPrefix": "models.lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Lex Model Building Service",
    "serviceId": "Lex Model Building Service",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "lex-models-2017-04-19"
  };

  async createBotVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateBotVersionRequest,
  ): Promise<s.CreateBotVersionResponse> {
    const body: jsonP.JSONObject = {
      checksum: params["checksum"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBotVersion",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "intents": [toIntent],
        "clarificationPrompt": toPrompt,
        "abortStatement": toStatement,
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
        "failureReason": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "idleSessionTTLInSeconds": "n",
        "voiceId": "s",
        "checksum": "s",
        "version": "s",
        "locale": (x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x),
        "childDirected": "b",
        "enableModelImprovements": "b",
        "detectSentiment": "b",
      },
    }, await resp.json());
  }

  async createIntentVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateIntentVersionRequest,
  ): Promise<s.CreateIntentVersionResponse> {
    const body: jsonP.JSONObject = {
      checksum: params["checksum"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIntentVersion",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "slots": [toSlot],
        "sampleUtterances": ["s"],
        "confirmationPrompt": toPrompt,
        "rejectionStatement": toStatement,
        "followUpPrompt": toFollowUpPrompt,
        "conclusionStatement": toStatement,
        "dialogCodeHook": toCodeHook,
        "fulfillmentActivity": toFulfillmentActivity,
        "parentIntentSignature": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "kendraConfiguration": toKendraConfiguration,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
      },
    }, await resp.json());
  }

  async createSlotTypeVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateSlotTypeVersionRequest,
  ): Promise<s.CreateSlotTypeVersionResponse> {
    const body: jsonP.JSONObject = {
      checksum: params["checksum"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSlotTypeVersion",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "enumerationValues": [toEnumerationValue],
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotValueSelectionStrategy>(x),
        "parentSlotTypeSignature": "s",
        "slotTypeConfigurations": [toSlotTypeConfiguration],
      },
    }, await resp.json());
  }

  async deleteBot(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBot",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotAliasRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotChannelAssociation(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotChannelAssociationRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotChannelAssociation",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteBotVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteIntent(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntent",
      method: "DELETE",
      requestUri: cmnP.encodePath`/intents/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteIntentVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntentVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntentVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteSlotType(
    {abortSignal, ...params}: RequestConfig & s.DeleteSlotTypeRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSlotType",
      method: "DELETE",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}`,
      responseCode: 204,
    });
  }

  async deleteSlotTypeVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteSlotTypeVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSlotTypeVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/version/${params["version"]}`,
      responseCode: 204,
    });
  }

  async deleteUtterances(
    {abortSignal, ...params}: RequestConfig & s.DeleteUtterancesRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUtterances",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/utterances/${params["userId"]}`,
      responseCode: 204,
    });
  }

  async getBot(
    {abortSignal, ...params}: RequestConfig & s.GetBotRequest,
  ): Promise<s.GetBotResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBot",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/${params["versionOrAlias"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "intents": [toIntent],
        "enableModelImprovements": "b",
        "nluIntentConfidenceThreshold": "n",
        "clarificationPrompt": toPrompt,
        "abortStatement": toStatement,
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
        "failureReason": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "idleSessionTTLInSeconds": "n",
        "voiceId": "s",
        "checksum": "s",
        "version": "s",
        "locale": (x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x),
        "childDirected": "b",
        "detectSentiment": "b",
      },
    }, await resp.json());
  }

  async getBotAlias(
    {abortSignal, ...params}: RequestConfig & s.GetBotAliasRequest,
  ): Promise<s.GetBotAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBotAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "botVersion": "s",
        "botName": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "checksum": "s",
        "conversationLogs": toConversationLogsResponse,
      },
    }, await resp.json());
  }

  async getBotAliases(
    {abortSignal, ...params}: RequestConfig & s.GetBotAliasesRequest,
  ): Promise<s.GetBotAliasesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BotAliases": [toBotAliasMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getBotChannelAssociation(
    {abortSignal, ...params}: RequestConfig & s.GetBotChannelAssociationRequest,
  ): Promise<s.GetBotChannelAssociationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBotChannelAssociation",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/${params["name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "botAlias": "s",
        "botName": "s",
        "createdDate": "d",
        "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelType>(x),
        "botConfiguration": x => jsonP.readMap(String, String, x),
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelStatus>(x),
        "failureReason": "s",
      },
    }, await resp.json());
  }

  async getBotChannelAssociations(
    {abortSignal, ...params}: RequestConfig & s.GetBotChannelAssociationsRequest,
  ): Promise<s.GetBotChannelAssociationsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotChannelAssociations",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["botAlias"]}/channels/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botChannelAssociations": [toBotChannelAssociation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getBotVersions(
    {abortSignal, ...params}: RequestConfig & s.GetBotVersionsRequest,
  ): Promise<s.GetBotVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBotVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bots": [toBotMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getBots(
    {abortSignal, ...params}: RequestConfig & s.GetBotsRequest = {},
  ): Promise<s.GetBotsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBots",
      method: "GET",
      requestUri: "/bots/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "bots": [toBotMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getBuiltinIntent(
    {abortSignal, ...params}: RequestConfig & s.GetBuiltinIntentRequest,
  ): Promise<s.GetBuiltinIntentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBuiltinIntent",
      method: "GET",
      requestUri: cmnP.encodePath`/builtins/intents/${params["signature"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "signature": "s",
        "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x)],
        "slots": [toBuiltinIntentSlot],
      },
    }, await resp.json());
  }

  async getBuiltinIntents(
    {abortSignal, ...params}: RequestConfig & s.GetBuiltinIntentsRequest = {},
  ): Promise<s.GetBuiltinIntentsResponse> {
    const query = new URLSearchParams;
    if (params["locale"] != null) query.set("locale", params["locale"]?.toString() ?? "");
    if (params["signatureContains"] != null) query.set("signatureContains", params["signatureContains"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBuiltinIntents",
      method: "GET",
      requestUri: "/builtins/intents/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intents": [toBuiltinIntentMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getBuiltinSlotTypes(
    {abortSignal, ...params}: RequestConfig & s.GetBuiltinSlotTypesRequest = {},
  ): Promise<s.GetBuiltinSlotTypesResponse> {
    const query = new URLSearchParams;
    if (params["locale"] != null) query.set("locale", params["locale"]?.toString() ?? "");
    if (params["signatureContains"] != null) query.set("signatureContains", params["signatureContains"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetBuiltinSlotTypes",
      method: "GET",
      requestUri: "/builtins/slottypes/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypes": [toBuiltinSlotTypeMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getExport(
    {abortSignal, ...params}: RequestConfig & s.GetExportRequest,
  ): Promise<s.GetExportResponse> {
    const query = new URLSearchParams;
    query.set("name", params["name"]?.toString() ?? "");
    query.set("version", params["version"]?.toString() ?? "");
    query.set("resourceType", params["resourceType"]?.toString() ?? "");
    query.set("exportType", params["exportType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetExport",
      method: "GET",
      requestUri: "/exports/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "version": "s",
        "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
        "exportType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportType>(x),
        "exportStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExportStatus>(x),
        "failureReason": "s",
        "url": "s",
      },
    }, await resp.json());
  }

  async getImport(
    {abortSignal, ...params}: RequestConfig & s.GetImportRequest,
  ): Promise<s.GetImportResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetImport",
      method: "GET",
      requestUri: cmnP.encodePath`/imports/${params["importId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
        "mergeStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.MergeStrategy>(x),
        "importId": "s",
        "importStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImportStatus>(x),
        "failureReason": ["s"],
        "createdDate": "d",
      },
    }, await resp.json());
  }

  async getIntent(
    {abortSignal, ...params}: RequestConfig & s.GetIntentRequest,
  ): Promise<s.GetIntentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetIntent",
      method: "GET",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/${params["version"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "slots": [toSlot],
        "sampleUtterances": ["s"],
        "confirmationPrompt": toPrompt,
        "rejectionStatement": toStatement,
        "followUpPrompt": toFollowUpPrompt,
        "conclusionStatement": toStatement,
        "dialogCodeHook": toCodeHook,
        "fulfillmentActivity": toFulfillmentActivity,
        "parentIntentSignature": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "kendraConfiguration": toKendraConfiguration,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
      },
    }, await resp.json());
  }

  async getIntentVersions(
    {abortSignal, ...params}: RequestConfig & s.GetIntentVersionsRequest,
  ): Promise<s.GetIntentVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntentVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intents": [toIntentMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getIntents(
    {abortSignal, ...params}: RequestConfig & s.GetIntentsRequest = {},
  ): Promise<s.GetIntentsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetIntents",
      method: "GET",
      requestUri: "/intents/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intents": [toIntentMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getSlotType(
    {abortSignal, ...params}: RequestConfig & s.GetSlotTypeRequest,
  ): Promise<s.GetSlotTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSlotType",
      method: "GET",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/${params["version"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "enumerationValues": [toEnumerationValue],
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotValueSelectionStrategy>(x),
        "parentSlotTypeSignature": "s",
        "slotTypeConfigurations": [toSlotTypeConfiguration],
      },
    }, await resp.json());
  }

  async getSlotTypeVersions(
    {abortSignal, ...params}: RequestConfig & s.GetSlotTypeVersionsRequest,
  ): Promise<s.GetSlotTypeVersionsResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSlotTypeVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypes": [toSlotTypeMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getSlotTypes(
    {abortSignal, ...params}: RequestConfig & s.GetSlotTypesRequest = {},
  ): Promise<s.GetSlotTypesResponse> {
    const query = new URLSearchParams;
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nameContains"] != null) query.set("nameContains", params["nameContains"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSlotTypes",
      method: "GET",
      requestUri: "/slottypes/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypes": [toSlotTypeMetadata],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getUtterancesView(
    {abortSignal, ...params}: RequestConfig & s.GetUtterancesViewRequest,
  ): Promise<s.GetUtterancesViewResponse> {
    const query = new URLSearchParams;
    for (const item of params["botVersions"]) {
      query.append("bot_versions", item?.toString() ?? "");
    }
    query.set("status_type", params["statusType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetUtterancesView",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/utterances?view=aggregation`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botName": "s",
        "utterances": [toUtteranceList],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putBot(
    {abortSignal, ...params}: RequestConfig & s.PutBotRequest,
  ): Promise<s.PutBotResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      intents: params["intents"]?.map(x => fromIntent(x)),
      enableModelImprovements: params["enableModelImprovements"],
      nluIntentConfidenceThreshold: params["nluIntentConfidenceThreshold"],
      clarificationPrompt: fromPrompt(params["clarificationPrompt"]),
      abortStatement: fromStatement(params["abortStatement"]),
      idleSessionTTLInSeconds: params["idleSessionTTLInSeconds"],
      voiceId: params["voiceId"],
      checksum: params["checksum"],
      processBehavior: params["processBehavior"],
      locale: params["locale"],
      childDirected: params["childDirected"],
      detectSentiment: params["detectSentiment"],
      createVersion: params["createVersion"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBot",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "intents": [toIntent],
        "enableModelImprovements": "b",
        "nluIntentConfidenceThreshold": "n",
        "clarificationPrompt": toPrompt,
        "abortStatement": toStatement,
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
        "failureReason": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "idleSessionTTLInSeconds": "n",
        "voiceId": "s",
        "checksum": "s",
        "version": "s",
        "locale": (x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x),
        "childDirected": "b",
        "createVersion": "b",
        "detectSentiment": "b",
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putBotAlias(
    {abortSignal, ...params}: RequestConfig & s.PutBotAliasRequest,
  ): Promise<s.PutBotAliasResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      botVersion: params["botVersion"],
      checksum: params["checksum"],
      conversationLogs: fromConversationLogsRequest(params["conversationLogs"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBotAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botName"]}/aliases/${params["name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "botVersion": "s",
        "botName": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "checksum": "s",
        "conversationLogs": toConversationLogsResponse,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putIntent(
    {abortSignal, ...params}: RequestConfig & s.PutIntentRequest,
  ): Promise<s.PutIntentResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      slots: params["slots"]?.map(x => fromSlot(x)),
      sampleUtterances: params["sampleUtterances"],
      confirmationPrompt: fromPrompt(params["confirmationPrompt"]),
      rejectionStatement: fromStatement(params["rejectionStatement"]),
      followUpPrompt: fromFollowUpPrompt(params["followUpPrompt"]),
      conclusionStatement: fromStatement(params["conclusionStatement"]),
      dialogCodeHook: fromCodeHook(params["dialogCodeHook"]),
      fulfillmentActivity: fromFulfillmentActivity(params["fulfillmentActivity"]),
      parentIntentSignature: params["parentIntentSignature"],
      checksum: params["checksum"],
      createVersion: params["createVersion"],
      kendraConfiguration: fromKendraConfiguration(params["kendraConfiguration"]),
      inputContexts: params["inputContexts"]?.map(x => fromInputContext(x)),
      outputContexts: params["outputContexts"]?.map(x => fromOutputContext(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutIntent",
      method: "PUT",
      requestUri: cmnP.encodePath`/intents/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "slots": [toSlot],
        "sampleUtterances": ["s"],
        "confirmationPrompt": toPrompt,
        "rejectionStatement": toStatement,
        "followUpPrompt": toFollowUpPrompt,
        "conclusionStatement": toStatement,
        "dialogCodeHook": toCodeHook,
        "fulfillmentActivity": toFulfillmentActivity,
        "parentIntentSignature": "s",
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "createVersion": "b",
        "kendraConfiguration": toKendraConfiguration,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
      },
    }, await resp.json());
  }

  async putSlotType(
    {abortSignal, ...params}: RequestConfig & s.PutSlotTypeRequest,
  ): Promise<s.PutSlotTypeResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      enumerationValues: params["enumerationValues"]?.map(x => fromEnumerationValue(x)),
      checksum: params["checksum"],
      valueSelectionStrategy: params["valueSelectionStrategy"],
      createVersion: params["createVersion"],
      parentSlotTypeSignature: params["parentSlotTypeSignature"],
      slotTypeConfigurations: params["slotTypeConfigurations"]?.map(x => fromSlotTypeConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSlotType",
      method: "PUT",
      requestUri: cmnP.encodePath`/slottypes/${params["name"]}/versions/$LATEST`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "description": "s",
        "enumerationValues": [toEnumerationValue],
        "lastUpdatedDate": "d",
        "createdDate": "d",
        "version": "s",
        "checksum": "s",
        "valueSelectionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotValueSelectionStrategy>(x),
        "createVersion": "b",
        "parentSlotTypeSignature": "s",
        "slotTypeConfigurations": [toSlotTypeConfiguration],
      },
    }, await resp.json());
  }

  async startImport(
    {abortSignal, ...params}: RequestConfig & s.StartImportRequest,
  ): Promise<s.StartImportResponse> {
    const body: jsonP.JSONObject = {
      payload: jsonP.serializeBlob(params["payload"]),
      resourceType: params["resourceType"],
      mergeStrategy: params["mergeStrategy"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImport",
      requestUri: "/imports/",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "name": "s",
        "resourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
        "mergeStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.MergeStrategy>(x),
        "importId": "s",
        "importStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImportStatus>(x),
        "tags": [toTag],
        "createdDate": "d",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
      responseCode: 204,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromIntent(input?: s.Intent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    intentName: input["intentName"],
    intentVersion: input["intentVersion"],
  }
}
function toIntent(root: jsonP.JSONValue): s.Intent {
  return jsonP.readObj({
    required: {
      "intentName": "s",
      "intentVersion": "s",
    },
    optional: {},
  }, root);
}

function fromPrompt(input?: s.Prompt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messages: input["messages"]?.map(x => fromMessage(x)),
    maxAttempts: input["maxAttempts"],
    responseCard: input["responseCard"],
  }
}
function toPrompt(root: jsonP.JSONValue): s.Prompt {
  return jsonP.readObj({
    required: {
      "messages": [toMessage],
      "maxAttempts": "n",
    },
    optional: {
      "responseCard": "s",
    },
  }, root);
}

function fromMessage(input?: s.Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    contentType: input["contentType"],
    content: input["content"],
    groupNumber: input["groupNumber"],
  }
}
function toMessage(root: jsonP.JSONValue): s.Message {
  return jsonP.readObj({
    required: {
      "contentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentType>(x),
      "content": "s",
    },
    optional: {
      "groupNumber": "n",
    },
  }, root);
}

function fromStatement(input?: s.Statement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messages: input["messages"]?.map(x => fromMessage(x)),
    responseCard: input["responseCard"],
  }
}
function toStatement(root: jsonP.JSONValue): s.Statement {
  return jsonP.readObj({
    required: {
      "messages": [toMessage],
    },
    optional: {
      "responseCard": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromConversationLogsRequest(input?: s.ConversationLogsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logSettings: input["logSettings"]?.map(x => fromLogSettingsRequest(x)),
    iamRoleArn: input["iamRoleArn"],
  }
}

function fromLogSettingsRequest(input?: s.LogSettingsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logType: input["logType"],
    destination: input["destination"],
    kmsKeyArn: input["kmsKeyArn"],
    resourceArn: input["resourceArn"],
  }
}

function fromSlot(input?: s.Slot | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    description: input["description"],
    slotConstraint: input["slotConstraint"],
    slotType: input["slotType"],
    slotTypeVersion: input["slotTypeVersion"],
    valueElicitationPrompt: fromPrompt(input["valueElicitationPrompt"]),
    priority: input["priority"],
    sampleUtterances: input["sampleUtterances"],
    responseCard: input["responseCard"],
    obfuscationSetting: input["obfuscationSetting"],
    defaultValueSpec: fromSlotDefaultValueSpec(input["defaultValueSpec"]),
  }
}
function toSlot(root: jsonP.JSONValue): s.Slot {
  return jsonP.readObj({
    required: {
      "name": "s",
      "slotConstraint": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotConstraint>(x),
    },
    optional: {
      "description": "s",
      "slotType": "s",
      "slotTypeVersion": "s",
      "valueElicitationPrompt": toPrompt,
      "priority": "n",
      "sampleUtterances": ["s"],
      "responseCard": "s",
      "obfuscationSetting": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObfuscationSetting>(x),
      "defaultValueSpec": toSlotDefaultValueSpec,
    },
  }, root);
}

function fromSlotDefaultValueSpec(input?: s.SlotDefaultValueSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultValueList: input["defaultValueList"]?.map(x => fromSlotDefaultValue(x)),
  }
}
function toSlotDefaultValueSpec(root: jsonP.JSONValue): s.SlotDefaultValueSpec {
  return jsonP.readObj({
    required: {
      "defaultValueList": [toSlotDefaultValue],
    },
    optional: {},
  }, root);
}

function fromSlotDefaultValue(input?: s.SlotDefaultValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultValue: input["defaultValue"],
  }
}
function toSlotDefaultValue(root: jsonP.JSONValue): s.SlotDefaultValue {
  return jsonP.readObj({
    required: {
      "defaultValue": "s",
    },
    optional: {},
  }, root);
}

function fromFollowUpPrompt(input?: s.FollowUpPrompt | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prompt: fromPrompt(input["prompt"]),
    rejectionStatement: fromStatement(input["rejectionStatement"]),
  }
}
function toFollowUpPrompt(root: jsonP.JSONValue): s.FollowUpPrompt {
  return jsonP.readObj({
    required: {
      "prompt": toPrompt,
      "rejectionStatement": toStatement,
    },
    optional: {},
  }, root);
}

function fromCodeHook(input?: s.CodeHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    uri: input["uri"],
    messageVersion: input["messageVersion"],
  }
}
function toCodeHook(root: jsonP.JSONValue): s.CodeHook {
  return jsonP.readObj({
    required: {
      "uri": "s",
      "messageVersion": "s",
    },
    optional: {},
  }, root);
}

function fromFulfillmentActivity(input?: s.FulfillmentActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    codeHook: fromCodeHook(input["codeHook"]),
  }
}
function toFulfillmentActivity(root: jsonP.JSONValue): s.FulfillmentActivity {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FulfillmentActivityType>(x),
    },
    optional: {
      "codeHook": toCodeHook,
    },
  }, root);
}

function fromKendraConfiguration(input?: s.KendraConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kendraIndex: input["kendraIndex"],
    queryFilterString: input["queryFilterString"],
    role: input["role"],
  }
}
function toKendraConfiguration(root: jsonP.JSONValue): s.KendraConfiguration {
  return jsonP.readObj({
    required: {
      "kendraIndex": "s",
      "role": "s",
    },
    optional: {
      "queryFilterString": "s",
    },
  }, root);
}

function fromInputContext(input?: s.InputContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toInputContext(root: jsonP.JSONValue): s.InputContext {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromOutputContext(input?: s.OutputContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    timeToLiveInSeconds: input["timeToLiveInSeconds"],
    turnsToLive: input["turnsToLive"],
  }
}
function toOutputContext(root: jsonP.JSONValue): s.OutputContext {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timeToLiveInSeconds": "n",
      "turnsToLive": "n",
    },
    optional: {},
  }, root);
}

function fromEnumerationValue(input?: s.EnumerationValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    synonyms: input["synonyms"],
  }
}
function toEnumerationValue(root: jsonP.JSONValue): s.EnumerationValue {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {
      "synonyms": ["s"],
    },
  }, root);
}

function fromSlotTypeConfiguration(input?: s.SlotTypeConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    regexConfiguration: fromSlotTypeRegexConfiguration(input["regexConfiguration"]),
  }
}
function toSlotTypeConfiguration(root: jsonP.JSONValue): s.SlotTypeConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "regexConfiguration": toSlotTypeRegexConfiguration,
    },
  }, root);
}

function fromSlotTypeRegexConfiguration(input?: s.SlotTypeRegexConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pattern: input["pattern"],
  }
}
function toSlotTypeRegexConfiguration(root: jsonP.JSONValue): s.SlotTypeRegexConfiguration {
  return jsonP.readObj({
    required: {
      "pattern": "s",
    },
    optional: {},
  }, root);
}

function toConversationLogsResponse(root: jsonP.JSONValue): s.ConversationLogsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "logSettings": [toLogSettingsResponse],
      "iamRoleArn": "s",
    },
  }, root);
}

function toLogSettingsResponse(root: jsonP.JSONValue): s.LogSettingsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "logType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogType>(x),
      "destination": (x: jsonP.JSONValue) => cmnP.readEnum<s.Destination>(x),
      "kmsKeyArn": "s",
      "resourceArn": "s",
      "resourcePrefix": "s",
    },
  }, root);
}

function toBotAliasMetadata(root: jsonP.JSONValue): s.BotAliasMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "botVersion": "s",
      "botName": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "checksum": "s",
      "conversationLogs": toConversationLogsResponse,
    },
  }, root);
}

function toBotChannelAssociation(root: jsonP.JSONValue): s.BotChannelAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "botAlias": "s",
      "botName": "s",
      "createdDate": "d",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelType>(x),
      "botConfiguration": x => jsonP.readMap(String, String, x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelStatus>(x),
      "failureReason": "s",
    },
  }, root);
}

function toBotMetadata(root: jsonP.JSONValue): s.BotMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.Status>(x),
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

function toBuiltinIntentSlot(root: jsonP.JSONValue): s.BuiltinIntentSlot {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function toBuiltinIntentMetadata(root: jsonP.JSONValue): s.BuiltinIntentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "signature": "s",
      "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x)],
    },
  }, root);
}

function toBuiltinSlotTypeMetadata(root: jsonP.JSONValue): s.BuiltinSlotTypeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "signature": "s",
      "supportedLocales": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Locale>(x)],
    },
  }, root);
}

function toIntentMetadata(root: jsonP.JSONValue): s.IntentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

function toSlotTypeMetadata(root: jsonP.JSONValue): s.SlotTypeMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedDate": "d",
      "createdDate": "d",
      "version": "s",
    },
  }, root);
}

function toUtteranceList(root: jsonP.JSONValue): s.UtteranceList {
  return jsonP.readObj({
    required: {},
    optional: {
      "botVersion": "s",
      "utterances": [toUtteranceData],
    },
  }, root);
}

function toUtteranceData(root: jsonP.JSONValue): s.UtteranceData {
  return jsonP.readObj({
    required: {},
    optional: {
      "utteranceString": "s",
      "count": "n",
      "distinctUsers": "n",
      "firstUtteredDate": "d",
      "lastUtteredDate": "d",
    },
  }, root);
}
