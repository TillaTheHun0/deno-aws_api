// Autogenerated API client for: Amazon Forecast Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class ForecastService {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ForecastService.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-06-26",
    "endpointPrefix": "forecast",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Forecast Service",
    "serviceId": "forecast",
    "signatureVersion": "v4",
    "signingName": "forecast",
    "targetPrefix": "AmazonForecast",
    "uid": "forecast-2018-06-26"
  };

  async createDataset(
    {abortSignal, ...params}: RequestConfig & CreateDatasetRequest,
  ): Promise<CreateDatasetResponse> {
    const body: JSONObject = {...params,
    Schema: fromSchema(params["Schema"]),
    EncryptionConfig: fromEncryptionConfig(params["EncryptionConfig"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataset",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetGroup(
    {abortSignal, ...params}: RequestConfig & CreateDatasetGroupRequest,
  ): Promise<CreateDatasetGroupResponse> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetGroupArn": "s",
      },
    }, await resp.json());
  }

  async createDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & CreateDatasetImportJobRequest,
  ): Promise<CreateDatasetImportJobResponse> {
    const body: JSONObject = {...params,
    DataSource: fromDataSource(params["DataSource"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatasetImportJob",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetImportJobArn": "s",
      },
    }, await resp.json());
  }

  async createForecast(
    {abortSignal, ...params}: RequestConfig & CreateForecastRequest,
  ): Promise<CreateForecastResponse> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateForecast",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ForecastArn": "s",
      },
    }, await resp.json());
  }

  async createForecastExportJob(
    {abortSignal, ...params}: RequestConfig & CreateForecastExportJobRequest,
  ): Promise<CreateForecastExportJobResponse> {
    const body: JSONObject = {...params,
    Destination: fromDataDestination(params["Destination"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateForecastExportJob",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ForecastExportJobArn": "s",
      },
    }, await resp.json());
  }

  async createPredictor(
    {abortSignal, ...params}: RequestConfig & CreatePredictorRequest,
  ): Promise<CreatePredictorResponse> {
    const body: JSONObject = {...params,
    EvaluationParameters: fromEvaluationParameters(params["EvaluationParameters"]),
    HPOConfig: fromHyperParameterTuningJobConfig(params["HPOConfig"]),
    InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
    FeaturizationConfig: fromFeaturizationConfig(params["FeaturizationConfig"]),
    EncryptionConfig: fromEncryptionConfig(params["EncryptionConfig"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePredictor",
    });
    return prt.readObj({
      required: {},
      optional: {
        "PredictorArn": "s",
      },
    }, await resp.json());
  }

  async deleteDataset(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataset",
    });
  }

  async deleteDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetGroupRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetGroup",
    });
  }

  async deleteDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & DeleteDatasetImportJobRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatasetImportJob",
    });
  }

  async deleteForecast(
    {abortSignal, ...params}: RequestConfig & DeleteForecastRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteForecast",
    });
  }

  async deleteForecastExportJob(
    {abortSignal, ...params}: RequestConfig & DeleteForecastExportJobRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteForecastExportJob",
    });
  }

  async deletePredictor(
    {abortSignal, ...params}: RequestConfig & DeletePredictorRequest,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePredictor",
    });
  }

  async describeDataset(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetRequest,
  ): Promise<DescribeDatasetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataset",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetArn": "s",
        "DatasetName": "s",
        "Domain": toDomain,
        "DatasetType": toDatasetType,
        "DataFrequency": "s",
        "Schema": toSchema,
        "EncryptionConfig": toEncryptionConfig,
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeDatasetGroup(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetGroupRequest,
  ): Promise<DescribeDatasetGroupResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetGroupName": "s",
        "DatasetGroupArn": "s",
        "DatasetArns": ["s"],
        "Domain": toDomain,
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeDatasetImportJob(
    {abortSignal, ...params}: RequestConfig & DescribeDatasetImportJobRequest,
  ): Promise<DescribeDatasetImportJobResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatasetImportJob",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetImportJobName": "s",
        "DatasetImportJobArn": "s",
        "DatasetArn": "s",
        "TimestampFormat": "s",
        "DataSource": toDataSource,
        "FieldStatistics": x => prt.readMap(String, toStatistics, x),
        "DataSize": "n",
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeForecast(
    {abortSignal, ...params}: RequestConfig & DescribeForecastRequest,
  ): Promise<DescribeForecastResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeForecast",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ForecastArn": "s",
        "ForecastName": "s",
        "ForecastTypes": ["s"],
        "PredictorArn": "s",
        "DatasetGroupArn": "s",
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describeForecastExportJob(
    {abortSignal, ...params}: RequestConfig & DescribeForecastExportJobRequest,
  ): Promise<DescribeForecastExportJobResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeForecastExportJob",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ForecastExportJobArn": "s",
        "ForecastExportJobName": "s",
        "ForecastArn": "s",
        "Destination": toDataDestination,
        "Message": "s",
        "Status": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async describePredictor(
    {abortSignal, ...params}: RequestConfig & DescribePredictorRequest,
  ): Promise<DescribePredictorResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePredictor",
    });
    return prt.readObj({
      required: {},
      optional: {
        "PredictorArn": "s",
        "PredictorName": "s",
        "AlgorithmArn": "s",
        "ForecastHorizon": "n",
        "PerformAutoML": "b",
        "PerformHPO": "b",
        "TrainingParameters": x => prt.readMap(String, String, x),
        "EvaluationParameters": toEvaluationParameters,
        "HPOConfig": toHyperParameterTuningJobConfig,
        "InputDataConfig": toInputDataConfig,
        "FeaturizationConfig": toFeaturizationConfig,
        "EncryptionConfig": toEncryptionConfig,
        "PredictorExecutionDetails": toPredictorExecutionDetails,
        "DatasetImportJobArns": ["s"],
        "AutoMLAlgorithmArns": ["s"],
        "Status": "s",
        "Message": "s",
        "CreationTime": "d",
        "LastModificationTime": "d",
      },
    }, await resp.json());
  }

  async getAccuracyMetrics(
    {abortSignal, ...params}: RequestConfig & GetAccuracyMetricsRequest,
  ): Promise<GetAccuracyMetricsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetAccuracyMetrics",
    });
    return prt.readObj({
      required: {},
      optional: {
        "PredictorEvaluationResults": [toEvaluationResult],
      },
    }, await resp.json());
  }

  async listDatasetGroups(
    {abortSignal, ...params}: RequestConfig & ListDatasetGroupsRequest = {},
  ): Promise<ListDatasetGroupsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetGroups": [toDatasetGroupSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasetImportJobs(
    {abortSignal, ...params}: RequestConfig & ListDatasetImportJobsRequest = {},
  ): Promise<ListDatasetImportJobsResponse> {
    const body: JSONObject = {...params,
    Filters: params["Filters"]?.map(x => fromFilter(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasetImportJobs",
    });
    return prt.readObj({
      required: {},
      optional: {
        "DatasetImportJobs": [toDatasetImportJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDatasets(
    {abortSignal, ...params}: RequestConfig & ListDatasetsRequest = {},
  ): Promise<ListDatasetsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatasets",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Datasets": [toDatasetSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listForecastExportJobs(
    {abortSignal, ...params}: RequestConfig & ListForecastExportJobsRequest = {},
  ): Promise<ListForecastExportJobsResponse> {
    const body: JSONObject = {...params,
    Filters: params["Filters"]?.map(x => fromFilter(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListForecastExportJobs",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ForecastExportJobs": [toForecastExportJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listForecasts(
    {abortSignal, ...params}: RequestConfig & ListForecastsRequest = {},
  ): Promise<ListForecastsResponse> {
    const body: JSONObject = {...params,
    Filters: params["Filters"]?.map(x => fromFilter(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListForecasts",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Forecasts": [toForecastSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPredictors(
    {abortSignal, ...params}: RequestConfig & ListPredictorsRequest = {},
  ): Promise<ListPredictorsResponse> {
    const body: JSONObject = {...params,
    Filters: params["Filters"]?.map(x => fromFilter(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPredictors",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Predictors": [toPredictorSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDatasetGroup(
    {abortSignal, ...params}: RequestConfig & UpdateDatasetGroupRequest,
  ): Promise<UpdateDatasetGroupResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatasetGroup",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateDatasetRequest {
  DatasetName: string;
  Domain: Domain;
  DatasetType: DatasetType;
  DataFrequency?: string | null;
  Schema: Schema;
  EncryptionConfig?: EncryptionConfig | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetGroupRequest {
  DatasetGroupName: string;
  Domain: Domain;
  DatasetArns?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDatasetImportJobRequest {
  DatasetImportJobName: string;
  DatasetArn: string;
  DataSource: DataSource;
  TimestampFormat?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateForecastRequest {
  ForecastName: string;
  PredictorArn: string;
  ForecastTypes?: string[] | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateForecastExportJobRequest {
  ForecastExportJobName: string;
  ForecastArn: string;
  Destination: DataDestination;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePredictorRequest {
  PredictorName: string;
  AlgorithmArn?: string | null;
  ForecastHorizon: number;
  PerformAutoML?: boolean | null;
  PerformHPO?: boolean | null;
  TrainingParameters?: { [key: string]: string } | null;
  EvaluationParameters?: EvaluationParameters | null;
  HPOConfig?: HyperParameterTuningJobConfig | null;
  InputDataConfig: InputDataConfig;
  FeaturizationConfig: FeaturizationConfig;
  EncryptionConfig?: EncryptionConfig | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetRequest {
  DatasetArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetGroupRequest {
  DatasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatasetImportJobRequest {
  DatasetImportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteForecastRequest {
  ForecastArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteForecastExportJobRequest {
  ForecastExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePredictorRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetRequest {
  DatasetArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetGroupRequest {
  DatasetGroupArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatasetImportJobRequest {
  DatasetImportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeForecastRequest {
  ForecastArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeForecastExportJobRequest {
  ForecastExportJobArn: string;
}

// refs: 1 - tags: named, input
export interface DescribePredictorRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface GetAccuracyMetricsRequest {
  PredictorArn: string;
}

// refs: 1 - tags: named, input
export interface ListDatasetGroupsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetImportJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListDatasetsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListForecastExportJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListForecastsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListPredictorsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filters?: Filter[] | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDatasetGroupRequest {
  DatasetGroupArn: string;
  DatasetArns: string[];
}

// refs: 1 - tags: named, output
export interface CreateDatasetResponse {
  DatasetArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetGroupResponse {
  DatasetGroupArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDatasetImportJobResponse {
  DatasetImportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateForecastResponse {
  ForecastArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateForecastExportJobResponse {
  ForecastExportJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePredictorResponse {
  PredictorArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetResponse {
  DatasetArn?: string | null;
  DatasetName?: string | null;
  Domain?: Domain | null;
  DatasetType?: DatasetType | null;
  DataFrequency?: string | null;
  Schema?: Schema | null;
  EncryptionConfig?: EncryptionConfig | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetGroupResponse {
  DatasetGroupName?: string | null;
  DatasetGroupArn?: string | null;
  DatasetArns?: string[] | null;
  Domain?: Domain | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatasetImportJobResponse {
  DatasetImportJobName?: string | null;
  DatasetImportJobArn?: string | null;
  DatasetArn?: string | null;
  TimestampFormat?: string | null;
  DataSource?: DataSource | null;
  FieldStatistics?: { [key: string]: Statistics } | null;
  DataSize?: number | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeForecastResponse {
  ForecastArn?: string | null;
  ForecastName?: string | null;
  ForecastTypes?: string[] | null;
  PredictorArn?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeForecastExportJobResponse {
  ForecastExportJobArn?: string | null;
  ForecastExportJobName?: string | null;
  ForecastArn?: string | null;
  Destination?: DataDestination | null;
  Message?: string | null;
  Status?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribePredictorResponse {
  PredictorArn?: string | null;
  PredictorName?: string | null;
  AlgorithmArn?: string | null;
  ForecastHorizon?: number | null;
  PerformAutoML?: boolean | null;
  PerformHPO?: boolean | null;
  TrainingParameters?: { [key: string]: string } | null;
  EvaluationParameters?: EvaluationParameters | null;
  HPOConfig?: HyperParameterTuningJobConfig | null;
  InputDataConfig?: InputDataConfig | null;
  FeaturizationConfig?: FeaturizationConfig | null;
  EncryptionConfig?: EncryptionConfig | null;
  PredictorExecutionDetails?: PredictorExecutionDetails | null;
  DatasetImportJobArns?: string[] | null;
  AutoMLAlgorithmArns?: string[] | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetAccuracyMetricsResponse {
  PredictorEvaluationResults?: EvaluationResult[] | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetGroupsResponse {
  DatasetGroups?: DatasetGroupSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetImportJobsResponse {
  DatasetImportJobs?: DatasetImportJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDatasetsResponse {
  Datasets?: DatasetSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListForecastExportJobsResponse {
  ForecastExportJobs?: ForecastExportJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListForecastsResponse {
  Forecasts?: ForecastSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPredictorsResponse {
  Predictors?: PredictorSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDatasetGroupResponse {
}

// refs: 5 - tags: input, named, enum, output
export type Domain =
| "RETAIL"
| "CUSTOM"
| "INVENTORY_PLANNING"
| "EC2_CAPACITY"
| "WORK_FORCE"
| "WEB_TRAFFIC"
| "METRICS"
;

function toDomain(root: JSONValue): Domain | null {
  return ( false
    || root == "RETAIL"
    || root == "CUSTOM"
    || root == "INVENTORY_PLANNING"
    || root == "EC2_CAPACITY"
    || root == "WORK_FORCE"
    || root == "WEB_TRAFFIC"
    || root == "METRICS"
  ) ? root : null;
}

// refs: 3 - tags: input, named, enum, output
export type DatasetType =
| "TARGET_TIME_SERIES"
| "RELATED_TIME_SERIES"
| "ITEM_METADATA"
;

function toDatasetType(root: JSONValue): DatasetType | null {
  return ( false
    || root == "TARGET_TIME_SERIES"
    || root == "RELATED_TIME_SERIES"
    || root == "ITEM_METADATA"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface, output
export interface Schema {
  Attributes?: SchemaAttribute[] | null;
}
function fromSchema(input?: Schema | null): JSONValue {
  if (!input) return input;
  return {...input,
    Attributes: input["Attributes"]?.map(x => fromSchemaAttribute(x)),
  }
}
function toSchema(root: JSONValue): Schema {
  return prt.readObj({
    required: {},
    optional: {
      "Attributes": [toSchemaAttribute],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SchemaAttribute {
  AttributeName?: string | null;
  AttributeType?: AttributeType | null;
}
function fromSchemaAttribute(input?: SchemaAttribute | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSchemaAttribute(root: JSONValue): SchemaAttribute {
  return prt.readObj({
    required: {},
    optional: {
      "AttributeName": "s",
      "AttributeType": toAttributeType,
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type AttributeType =
| "string"
| "integer"
| "float"
| "timestamp"
;

function toAttributeType(root: JSONValue): AttributeType | null {
  return ( false
    || root == "string"
    || root == "integer"
    || root == "float"
    || root == "timestamp"
  ) ? root : null;
}

// refs: 4 - tags: input, named, interface, output
export interface EncryptionConfig {
  RoleArn: string;
  KMSKeyArn: string;
}
function fromEncryptionConfig(input?: EncryptionConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toEncryptionConfig(root: JSONValue): EncryptionConfig {
  return prt.readObj({
    required: {
      "RoleArn": "s",
      "KMSKeyArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTag(root: JSONValue): Tag {
  return prt.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DataSource {
  S3Config: S3Config;
}
function fromDataSource(input?: DataSource | null): JSONValue {
  if (!input) return input;
  return {...input,
    S3Config: fromS3Config(input["S3Config"]),
  }
}
function toDataSource(root: JSONValue): DataSource {
  return prt.readObj({
    required: {
      "S3Config": toS3Config,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface S3Config {
  Path: string;
  RoleArn: string;
  KMSKeyArn?: string | null;
}
function fromS3Config(input?: S3Config | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toS3Config(root: JSONValue): S3Config {
  return prt.readObj({
    required: {
      "Path": "s",
      "RoleArn": "s",
    },
    optional: {
      "KMSKeyArn": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DataDestination {
  S3Config: S3Config;
}
function fromDataDestination(input?: DataDestination | null): JSONValue {
  if (!input) return input;
  return {...input,
    S3Config: fromS3Config(input["S3Config"]),
  }
}
function toDataDestination(root: JSONValue): DataDestination {
  return prt.readObj({
    required: {
      "S3Config": toS3Config,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface EvaluationParameters {
  NumberOfBacktestWindows?: number | null;
  BackTestWindowOffset?: number | null;
}
function fromEvaluationParameters(input?: EvaluationParameters | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toEvaluationParameters(root: JSONValue): EvaluationParameters {
  return prt.readObj({
    required: {},
    optional: {
      "NumberOfBacktestWindows": "n",
      "BackTestWindowOffset": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HyperParameterTuningJobConfig {
  ParameterRanges?: ParameterRanges | null;
}
function fromHyperParameterTuningJobConfig(input?: HyperParameterTuningJobConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    ParameterRanges: fromParameterRanges(input["ParameterRanges"]),
  }
}
function toHyperParameterTuningJobConfig(root: JSONValue): HyperParameterTuningJobConfig {
  return prt.readObj({
    required: {},
    optional: {
      "ParameterRanges": toParameterRanges,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ParameterRanges {
  CategoricalParameterRanges?: CategoricalParameterRange[] | null;
  ContinuousParameterRanges?: ContinuousParameterRange[] | null;
  IntegerParameterRanges?: IntegerParameterRange[] | null;
}
function fromParameterRanges(input?: ParameterRanges | null): JSONValue {
  if (!input) return input;
  return {...input,
    CategoricalParameterRanges: input["CategoricalParameterRanges"]?.map(x => fromCategoricalParameterRange(x)),
    ContinuousParameterRanges: input["ContinuousParameterRanges"]?.map(x => fromContinuousParameterRange(x)),
    IntegerParameterRanges: input["IntegerParameterRanges"]?.map(x => fromIntegerParameterRange(x)),
  }
}
function toParameterRanges(root: JSONValue): ParameterRanges {
  return prt.readObj({
    required: {},
    optional: {
      "CategoricalParameterRanges": [toCategoricalParameterRange],
      "ContinuousParameterRanges": [toContinuousParameterRange],
      "IntegerParameterRanges": [toIntegerParameterRange],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface CategoricalParameterRange {
  Name: string;
  Values: string[];
}
function fromCategoricalParameterRange(input?: CategoricalParameterRange | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toCategoricalParameterRange(root: JSONValue): CategoricalParameterRange {
  return prt.readObj({
    required: {
      "Name": "s",
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ContinuousParameterRange {
  Name: string;
  MaxValue: number;
  MinValue: number;
  ScalingType?: ScalingType | null;
}
function fromContinuousParameterRange(input?: ContinuousParameterRange | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toContinuousParameterRange(root: JSONValue): ContinuousParameterRange {
  return prt.readObj({
    required: {
      "Name": "s",
      "MaxValue": "n",
      "MinValue": "n",
    },
    optional: {
      "ScalingType": toScalingType,
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ScalingType =
| "Auto"
| "Linear"
| "Logarithmic"
| "ReverseLogarithmic"
;

function toScalingType(root: JSONValue): ScalingType | null {
  return ( false
    || root == "Auto"
    || root == "Linear"
    || root == "Logarithmic"
    || root == "ReverseLogarithmic"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface, output
export interface IntegerParameterRange {
  Name: string;
  MaxValue: number;
  MinValue: number;
  ScalingType?: ScalingType | null;
}
function fromIntegerParameterRange(input?: IntegerParameterRange | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toIntegerParameterRange(root: JSONValue): IntegerParameterRange {
  return prt.readObj({
    required: {
      "Name": "s",
      "MaxValue": "n",
      "MinValue": "n",
    },
    optional: {
      "ScalingType": toScalingType,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface InputDataConfig {
  DatasetGroupArn: string;
  SupplementaryFeatures?: SupplementaryFeature[] | null;
}
function fromInputDataConfig(input?: InputDataConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    SupplementaryFeatures: input["SupplementaryFeatures"]?.map(x => fromSupplementaryFeature(x)),
  }
}
function toInputDataConfig(root: JSONValue): InputDataConfig {
  return prt.readObj({
    required: {
      "DatasetGroupArn": "s",
    },
    optional: {
      "SupplementaryFeatures": [toSupplementaryFeature],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SupplementaryFeature {
  Name: string;
  Value: string;
}
function fromSupplementaryFeature(input?: SupplementaryFeature | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSupplementaryFeature(root: JSONValue): SupplementaryFeature {
  return prt.readObj({
    required: {
      "Name": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface FeaturizationConfig {
  ForecastFrequency: string;
  ForecastDimensions?: string[] | null;
  Featurizations?: Featurization[] | null;
}
function fromFeaturizationConfig(input?: FeaturizationConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    Featurizations: input["Featurizations"]?.map(x => fromFeaturization(x)),
  }
}
function toFeaturizationConfig(root: JSONValue): FeaturizationConfig {
  return prt.readObj({
    required: {
      "ForecastFrequency": "s",
    },
    optional: {
      "ForecastDimensions": ["s"],
      "Featurizations": [toFeaturization],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface Featurization {
  AttributeName: string;
  FeaturizationPipeline?: FeaturizationMethod[] | null;
}
function fromFeaturization(input?: Featurization | null): JSONValue {
  if (!input) return input;
  return {...input,
    FeaturizationPipeline: input["FeaturizationPipeline"]?.map(x => fromFeaturizationMethod(x)),
  }
}
function toFeaturization(root: JSONValue): Featurization {
  return prt.readObj({
    required: {
      "AttributeName": "s",
    },
    optional: {
      "FeaturizationPipeline": [toFeaturizationMethod],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface FeaturizationMethod {
  FeaturizationMethodName: FeaturizationMethodName;
  FeaturizationMethodParameters?: { [key: string]: string } | null;
}
function fromFeaturizationMethod(input?: FeaturizationMethod | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toFeaturizationMethod(root: JSONValue): FeaturizationMethod {
  return prt.readObj({
    required: {
      "FeaturizationMethodName": toFeaturizationMethodName,
    },
    optional: {
      "FeaturizationMethodParameters": x => prt.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type FeaturizationMethodName =
| "filling"
;

function toFeaturizationMethodName(root: JSONValue): FeaturizationMethodName | null {
  return ( false
    || root == "filling"
  ) ? root : null;
}

// refs: 4 - tags: input, named, interface
export interface Filter {
  Key: string;
  Value: string;
  Condition: FilterConditionString;
}
function fromFilter(input?: Filter | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}

// refs: 4 - tags: input, named, enum
export type FilterConditionString =
| "IS"
| "IS_NOT"
;


// refs: 1 - tags: output, named, interface
export interface Statistics {
  Count?: number | null;
  CountDistinct?: number | null;
  CountNull?: number | null;
  CountNan?: number | null;
  Min?: string | null;
  Max?: string | null;
  Avg?: number | null;
  Stddev?: number | null;
}
function toStatistics(root: JSONValue): Statistics {
  return prt.readObj({
    required: {},
    optional: {
      "Count": "n",
      "CountDistinct": "n",
      "CountNull": "n",
      "CountNan": "n",
      "Min": "s",
      "Max": "s",
      "Avg": "n",
      "Stddev": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorExecutionDetails {
  PredictorExecutions?: PredictorExecution[] | null;
}
function toPredictorExecutionDetails(root: JSONValue): PredictorExecutionDetails {
  return prt.readObj({
    required: {},
    optional: {
      "PredictorExecutions": [toPredictorExecution],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorExecution {
  AlgorithmArn?: string | null;
  TestWindows?: TestWindowSummary[] | null;
}
function toPredictorExecution(root: JSONValue): PredictorExecution {
  return prt.readObj({
    required: {},
    optional: {
      "AlgorithmArn": "s",
      "TestWindows": [toTestWindowSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TestWindowSummary {
  TestWindowStart?: Date | number | null;
  TestWindowEnd?: Date | number | null;
  Status?: string | null;
  Message?: string | null;
}
function toTestWindowSummary(root: JSONValue): TestWindowSummary {
  return prt.readObj({
    required: {},
    optional: {
      "TestWindowStart": "d",
      "TestWindowEnd": "d",
      "Status": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EvaluationResult {
  AlgorithmArn?: string | null;
  TestWindows?: WindowSummary[] | null;
}
function toEvaluationResult(root: JSONValue): EvaluationResult {
  return prt.readObj({
    required: {},
    optional: {
      "AlgorithmArn": "s",
      "TestWindows": [toWindowSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface WindowSummary {
  TestWindowStart?: Date | number | null;
  TestWindowEnd?: Date | number | null;
  ItemCount?: number | null;
  EvaluationType?: EvaluationType | null;
  Metrics?: Metrics | null;
}
function toWindowSummary(root: JSONValue): WindowSummary {
  return prt.readObj({
    required: {},
    optional: {
      "TestWindowStart": "d",
      "TestWindowEnd": "d",
      "ItemCount": "n",
      "EvaluationType": toEvaluationType,
      "Metrics": toMetrics,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type EvaluationType =
| "SUMMARY"
| "COMPUTED"
;
function toEvaluationType(root: JSONValue): EvaluationType | null {
  return ( false
    || root == "SUMMARY"
    || root == "COMPUTED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface Metrics {
  RMSE?: number | null;
  WeightedQuantileLosses?: WeightedQuantileLoss[] | null;
}
function toMetrics(root: JSONValue): Metrics {
  return prt.readObj({
    required: {},
    optional: {
      "RMSE": "n",
      "WeightedQuantileLosses": [toWeightedQuantileLoss],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface WeightedQuantileLoss {
  Quantile?: number | null;
  LossValue?: number | null;
}
function toWeightedQuantileLoss(root: JSONValue): WeightedQuantileLoss {
  return prt.readObj({
    required: {},
    optional: {
      "Quantile": "n",
      "LossValue": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetGroupSummary {
  DatasetGroupArn?: string | null;
  DatasetGroupName?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetGroupSummary(root: JSONValue): DatasetGroupSummary {
  return prt.readObj({
    required: {},
    optional: {
      "DatasetGroupArn": "s",
      "DatasetGroupName": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetImportJobSummary {
  DatasetImportJobArn?: string | null;
  DatasetImportJobName?: string | null;
  DataSource?: DataSource | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetImportJobSummary(root: JSONValue): DatasetImportJobSummary {
  return prt.readObj({
    required: {},
    optional: {
      "DatasetImportJobArn": "s",
      "DatasetImportJobName": "s",
      "DataSource": toDataSource,
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DatasetSummary {
  DatasetArn?: string | null;
  DatasetName?: string | null;
  DatasetType?: DatasetType | null;
  Domain?: Domain | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toDatasetSummary(root: JSONValue): DatasetSummary {
  return prt.readObj({
    required: {},
    optional: {
      "DatasetArn": "s",
      "DatasetName": "s",
      "DatasetType": toDatasetType,
      "Domain": toDomain,
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ForecastExportJobSummary {
  ForecastExportJobArn?: string | null;
  ForecastExportJobName?: string | null;
  Destination?: DataDestination | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toForecastExportJobSummary(root: JSONValue): ForecastExportJobSummary {
  return prt.readObj({
    required: {},
    optional: {
      "ForecastExportJobArn": "s",
      "ForecastExportJobName": "s",
      "Destination": toDataDestination,
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ForecastSummary {
  ForecastArn?: string | null;
  ForecastName?: string | null;
  PredictorArn?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toForecastSummary(root: JSONValue): ForecastSummary {
  return prt.readObj({
    required: {},
    optional: {
      "ForecastArn": "s",
      "ForecastName": "s",
      "PredictorArn": "s",
      "DatasetGroupArn": "s",
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PredictorSummary {
  PredictorArn?: string | null;
  PredictorName?: string | null;
  DatasetGroupArn?: string | null;
  Status?: string | null;
  Message?: string | null;
  CreationTime?: Date | number | null;
  LastModificationTime?: Date | number | null;
}
function toPredictorSummary(root: JSONValue): PredictorSummary {
  return prt.readObj({
    required: {},
    optional: {
      "PredictorArn": "s",
      "PredictorName": "s",
      "DatasetGroupArn": "s",
      "Status": "s",
      "Message": "s",
      "CreationTime": "d",
      "LastModificationTime": "d",
    },
  }, root);
}
