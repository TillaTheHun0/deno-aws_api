// Autogenerated API client for: Amazon DynamoDB Streams

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class DynamoDBStreams {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DynamoDBStreams.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-08-10",
    "endpointPrefix": "streams.dynamodb",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceFullName": "Amazon DynamoDB Streams",
    "serviceId": "DynamoDB Streams",
    "signatureVersion": "v4",
    "signingName": "dynamodb",
    "targetPrefix": "DynamoDBStreams_20120810",
    "uid": "streams-dynamodb-2012-08-10"
  };

  async describeStream(
    {abortSignal, ...params}: RequestConfig & s.DescribeStreamInput,
  ): Promise<s.DescribeStreamOutput> {
    const body: jsonP.JSONObject = {
      StreamArn: params["StreamArn"],
      Limit: params["Limit"],
      ExclusiveStartShardId: params["ExclusiveStartShardId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStream",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StreamDescription": toStreamDescription,
      },
    }, await resp.json());
  }

  async getRecords(
    {abortSignal, ...params}: RequestConfig & s.GetRecordsInput,
  ): Promise<s.GetRecordsOutput> {
    const body: jsonP.JSONObject = {
      ShardIterator: params["ShardIterator"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRecords",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Records": [toRecord],
        "NextShardIterator": "s",
      },
    }, await resp.json());
  }

  async getShardIterator(
    {abortSignal, ...params}: RequestConfig & s.GetShardIteratorInput,
  ): Promise<s.GetShardIteratorOutput> {
    const body: jsonP.JSONObject = {
      StreamArn: params["StreamArn"],
      ShardId: params["ShardId"],
      ShardIteratorType: params["ShardIteratorType"],
      SequenceNumber: params["SequenceNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetShardIterator",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ShardIterator": "s",
      },
    }, await resp.json());
  }

  async listStreams(
    {abortSignal, ...params}: RequestConfig & s.ListStreamsInput = {},
  ): Promise<s.ListStreamsOutput> {
    const body: jsonP.JSONObject = {
      TableName: params["TableName"],
      Limit: params["Limit"],
      ExclusiveStartStreamArn: params["ExclusiveStartStreamArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStreams",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Streams": [toStream],
        "LastEvaluatedStreamArn": "s",
      },
    }, await resp.json());
  }

}

function toStreamDescription(root: jsonP.JSONValue): s.StreamDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamArn": "s",
      "StreamLabel": "s",
      "StreamStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamStatus>(x),
      "StreamViewType": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamViewType>(x),
      "CreationRequestDateTime": "d",
      "TableName": "s",
      "KeySchema": [toKeySchemaElement],
      "Shards": [toShard],
      "LastEvaluatedShardId": "s",
    },
  }, root);
}

function toKeySchemaElement(root: jsonP.JSONValue): s.KeySchemaElement {
  return jsonP.readObj({
    required: {
      "AttributeName": "s",
      "KeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.KeyType>(x),
    },
    optional: {},
  }, root);
}

function toShard(root: jsonP.JSONValue): s.Shard {
  return jsonP.readObj({
    required: {},
    optional: {
      "ShardId": "s",
      "SequenceNumberRange": toSequenceNumberRange,
      "ParentShardId": "s",
    },
  }, root);
}

function toSequenceNumberRange(root: jsonP.JSONValue): s.SequenceNumberRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "StartingSequenceNumber": "s",
      "EndingSequenceNumber": "s",
    },
  }, root);
}

function toRecord(root: jsonP.JSONValue): s.Record {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventID": "s",
      "eventName": (x: jsonP.JSONValue) => cmnP.readEnum<s.OperationType>(x),
      "eventVersion": "s",
      "eventSource": "s",
      "awsRegion": "s",
      "dynamodb": toStreamRecord,
      "userIdentity": toIdentity,
    },
  }, root);
}

function toStreamRecord(root: jsonP.JSONValue): s.StreamRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApproximateCreationDateTime": "d",
      "Keys": x => jsonP.readMap(String, toAttributeValue, x),
      "NewImage": x => jsonP.readMap(String, toAttributeValue, x),
      "OldImage": x => jsonP.readMap(String, toAttributeValue, x),
      "SequenceNumber": "s",
      "SizeBytes": "n",
      "StreamViewType": (x: jsonP.JSONValue) => cmnP.readEnum<s.StreamViewType>(x),
    },
  }, root);
}

function toAttributeValue(root: jsonP.JSONValue): s.AttributeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "S": "s",
      "N": "s",
      "B": "a",
      "SS": ["s"],
      "NS": ["s"],
      "BS": ["a"],
      "M": x => jsonP.readMap(String, toAttributeValue, x),
      "L": [toAttributeValue],
      "NULL": "b",
      "BOOL": "b",
    },
  }, root);
}

function toIdentity(root: jsonP.JSONValue): s.Identity {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrincipalId": "s",
      "Type": "s",
    },
  }, root);
}

function toStream(root: jsonP.JSONValue): s.Stream {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamArn": "s",
      "TableName": "s",
      "StreamLabel": "s",
    },
  }, root);
}
