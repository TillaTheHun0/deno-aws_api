// Autogenerated API client for: AWS Batch

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Batch {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Batch.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-08-10",
    "endpointPrefix": "batch",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "AWS Batch",
    "serviceFullName": "AWS Batch",
    "serviceId": "Batch",
    "signatureVersion": "v4",
    "uid": "batch-2016-08-10"
  };

  async cancelJob(
    {abortSignal, ...params}: RequestConfig & CancelJobRequest,
  ): Promise<CancelJobResponse> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelJob",
      requestUri: "/v1/canceljob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createComputeEnvironment(
    {abortSignal, ...params}: RequestConfig & CreateComputeEnvironmentRequest,
  ): Promise<CreateComputeEnvironmentResponse> {
    const body: jsonP.JSONObject = {
      computeEnvironmentName: params["computeEnvironmentName"],
      type: params["type"],
      state: params["state"],
      computeResources: fromComputeResource(params["computeResources"]),
      serviceRole: params["serviceRole"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateComputeEnvironment",
      requestUri: "/v1/createcomputeenvironment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "computeEnvironmentName": "s",
        "computeEnvironmentArn": "s",
      },
    }, await resp.json());
  }

  async createJobQueue(
    {abortSignal, ...params}: RequestConfig & CreateJobQueueRequest,
  ): Promise<CreateJobQueueResponse> {
    const body: jsonP.JSONObject = {
      jobQueueName: params["jobQueueName"],
      state: params["state"],
      priority: params["priority"],
      computeEnvironmentOrder: params["computeEnvironmentOrder"]?.map(x => fromComputeEnvironmentOrder(x)),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJobQueue",
      requestUri: "/v1/createjobqueue",
    });
    return jsonP.readObj({
      required: {
        "jobQueueName": "s",
        "jobQueueArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteComputeEnvironment(
    {abortSignal, ...params}: RequestConfig & DeleteComputeEnvironmentRequest,
  ): Promise<DeleteComputeEnvironmentResponse> {
    const body: jsonP.JSONObject = {
      computeEnvironment: params["computeEnvironment"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteComputeEnvironment",
      requestUri: "/v1/deletecomputeenvironment",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteJobQueue(
    {abortSignal, ...params}: RequestConfig & DeleteJobQueueRequest,
  ): Promise<DeleteJobQueueResponse> {
    const body: jsonP.JSONObject = {
      jobQueue: params["jobQueue"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteJobQueue",
      requestUri: "/v1/deletejobqueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterJobDefinition(
    {abortSignal, ...params}: RequestConfig & DeregisterJobDefinitionRequest,
  ): Promise<DeregisterJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      jobDefinition: params["jobDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterJobDefinition",
      requestUri: "/v1/deregisterjobdefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeComputeEnvironments(
    {abortSignal, ...params}: RequestConfig & DescribeComputeEnvironmentsRequest = {},
  ): Promise<DescribeComputeEnvironmentsResponse> {
    const body: jsonP.JSONObject = {
      computeEnvironments: params["computeEnvironments"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeComputeEnvironments",
      requestUri: "/v1/describecomputeenvironments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "computeEnvironments": [toComputeEnvironmentDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeJobDefinitions(
    {abortSignal, ...params}: RequestConfig & DescribeJobDefinitionsRequest = {},
  ): Promise<DescribeJobDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      jobDefinitions: params["jobDefinitions"],
      maxResults: params["maxResults"],
      jobDefinitionName: params["jobDefinitionName"],
      status: params["status"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobDefinitions",
      requestUri: "/v1/describejobdefinitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobDefinitions": [toJobDefinition],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeJobQueues(
    {abortSignal, ...params}: RequestConfig & DescribeJobQueuesRequest = {},
  ): Promise<DescribeJobQueuesResponse> {
    const body: jsonP.JSONObject = {
      jobQueues: params["jobQueues"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobQueues",
      requestUri: "/v1/describejobqueues",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobQueues": [toJobQueueDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeJobs(
    {abortSignal, ...params}: RequestConfig & DescribeJobsRequest,
  ): Promise<DescribeJobsResponse> {
    const body: jsonP.JSONObject = {
      jobs: params["jobs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobs",
      requestUri: "/v1/describejobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toJobDetail],
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsRequest = {},
  ): Promise<ListJobsResponse> {
    const body: jsonP.JSONObject = {
      jobQueue: params["jobQueue"],
      arrayJobId: params["arrayJobId"],
      multiNodeJobId: params["multiNodeJobId"],
      jobStatus: params["jobStatus"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListJobs",
      requestUri: "/v1/listjobs",
    });
    return jsonP.readObj({
      required: {
        "jobSummaryList": [toJobSummary],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async registerJobDefinition(
    {abortSignal, ...params}: RequestConfig & RegisterJobDefinitionRequest,
  ): Promise<RegisterJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      jobDefinitionName: params["jobDefinitionName"],
      type: params["type"],
      parameters: params["parameters"],
      containerProperties: fromContainerProperties(params["containerProperties"]),
      nodeProperties: fromNodeProperties(params["nodeProperties"]),
      retryStrategy: fromRetryStrategy(params["retryStrategy"]),
      timeout: fromJobTimeout(params["timeout"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterJobDefinition",
      requestUri: "/v1/registerjobdefinition",
    });
    return jsonP.readObj({
      required: {
        "jobDefinitionName": "s",
        "jobDefinitionArn": "s",
        "revision": "n",
      },
      optional: {},
    }, await resp.json());
  }

  async submitJob(
    {abortSignal, ...params}: RequestConfig & SubmitJobRequest,
  ): Promise<SubmitJobResponse> {
    const body: jsonP.JSONObject = {
      jobName: params["jobName"],
      jobQueue: params["jobQueue"],
      arrayProperties: fromArrayProperties(params["arrayProperties"]),
      dependsOn: params["dependsOn"]?.map(x => fromJobDependency(x)),
      jobDefinition: params["jobDefinition"],
      parameters: params["parameters"],
      containerOverrides: fromContainerOverrides(params["containerOverrides"]),
      nodeOverrides: fromNodeOverrides(params["nodeOverrides"]),
      retryStrategy: fromRetryStrategy(params["retryStrategy"]),
      timeout: fromJobTimeout(params["timeout"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SubmitJob",
      requestUri: "/v1/submitjob",
    });
    return jsonP.readObj({
      required: {
        "jobName": "s",
        "jobId": "s",
      },
      optional: {
        "jobArn": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async terminateJob(
    {abortSignal, ...params}: RequestConfig & TerminateJobRequest,
  ): Promise<TerminateJobResponse> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateJob",
      requestUri: "/v1/terminatejob",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateComputeEnvironment(
    {abortSignal, ...params}: RequestConfig & UpdateComputeEnvironmentRequest,
  ): Promise<UpdateComputeEnvironmentResponse> {
    const body: jsonP.JSONObject = {
      computeEnvironment: params["computeEnvironment"],
      state: params["state"],
      computeResources: fromComputeResourceUpdate(params["computeResources"]),
      serviceRole: params["serviceRole"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateComputeEnvironment",
      requestUri: "/v1/updatecomputeenvironment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "computeEnvironmentName": "s",
        "computeEnvironmentArn": "s",
      },
    }, await resp.json());
  }

  async updateJobQueue(
    {abortSignal, ...params}: RequestConfig & UpdateJobQueueRequest,
  ): Promise<UpdateJobQueueResponse> {
    const body: jsonP.JSONObject = {
      jobQueue: params["jobQueue"],
      state: params["state"],
      priority: params["priority"],
      computeEnvironmentOrder: params["computeEnvironmentOrder"]?.map(x => fromComputeEnvironmentOrder(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJobQueue",
      requestUri: "/v1/updatejobqueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobQueueName": "s",
        "jobQueueArn": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CancelJobRequest {
  jobId: string;
  reason: string;
}

// refs: 1 - tags: named, input
export interface CreateComputeEnvironmentRequest {
  computeEnvironmentName: string;
  type: CEType;
  state?: CEState | null;
  computeResources?: ComputeResource | null;
  serviceRole: string;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateJobQueueRequest {
  jobQueueName: string;
  state?: JQState | null;
  priority: number;
  computeEnvironmentOrder: ComputeEnvironmentOrder[];
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteComputeEnvironmentRequest {
  computeEnvironment: string;
}

// refs: 1 - tags: named, input
export interface DeleteJobQueueRequest {
  jobQueue: string;
}

// refs: 1 - tags: named, input
export interface DeregisterJobDefinitionRequest {
  jobDefinition: string;
}

// refs: 1 - tags: named, input
export interface DescribeComputeEnvironmentsRequest {
  computeEnvironments?: string[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeJobDefinitionsRequest {
  jobDefinitions?: string[] | null;
  maxResults?: number | null;
  jobDefinitionName?: string | null;
  status?: string | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeJobQueuesRequest {
  jobQueues?: string[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeJobsRequest {
  jobs: string[];
}

// refs: 1 - tags: named, input
export interface ListJobsRequest {
  jobQueue?: string | null;
  arrayJobId?: string | null;
  multiNodeJobId?: string | null;
  jobStatus?: JobStatus | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface RegisterJobDefinitionRequest {
  jobDefinitionName: string;
  type: JobDefinitionType;
  parameters?: { [key: string]: string | null | undefined } | null;
  containerProperties?: ContainerProperties | null;
  nodeProperties?: NodeProperties | null;
  retryStrategy?: RetryStrategy | null;
  timeout?: JobTimeout | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface SubmitJobRequest {
  jobName: string;
  jobQueue: string;
  arrayProperties?: ArrayProperties | null;
  dependsOn?: JobDependency[] | null;
  jobDefinition: string;
  parameters?: { [key: string]: string | null | undefined } | null;
  containerOverrides?: ContainerOverrides | null;
  nodeOverrides?: NodeOverrides | null;
  retryStrategy?: RetryStrategy | null;
  timeout?: JobTimeout | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface TerminateJobRequest {
  jobId: string;
  reason: string;
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateComputeEnvironmentRequest {
  computeEnvironment: string;
  state?: CEState | null;
  computeResources?: ComputeResourceUpdate | null;
  serviceRole?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateJobQueueRequest {
  jobQueue: string;
  state?: JQState | null;
  priority?: number | null;
  computeEnvironmentOrder?: ComputeEnvironmentOrder[] | null;
}

// refs: 1 - tags: named, output
export interface CancelJobResponse {
}

// refs: 1 - tags: named, output
export interface CreateComputeEnvironmentResponse {
  computeEnvironmentName?: string | null;
  computeEnvironmentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateJobQueueResponse {
  jobQueueName: string;
  jobQueueArn: string;
}

// refs: 1 - tags: named, output
export interface DeleteComputeEnvironmentResponse {
}

// refs: 1 - tags: named, output
export interface DeleteJobQueueResponse {
}

// refs: 1 - tags: named, output
export interface DeregisterJobDefinitionResponse {
}

// refs: 1 - tags: named, output
export interface DescribeComputeEnvironmentsResponse {
  computeEnvironments?: ComputeEnvironmentDetail[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobDefinitionsResponse {
  jobDefinitions?: JobDefinition[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobQueuesResponse {
  jobQueues?: JobQueueDetail[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobsResponse {
  jobs?: JobDetail[] | null;
}

// refs: 1 - tags: named, output
export interface ListJobsResponse {
  jobSummaryList: JobSummary[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface RegisterJobDefinitionResponse {
  jobDefinitionName: string;
  jobDefinitionArn: string;
  revision: number;
}

// refs: 1 - tags: named, output
export interface SubmitJobResponse {
  jobArn?: string | null;
  jobName: string;
  jobId: string;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface TerminateJobResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateComputeEnvironmentResponse {
  computeEnvironmentName?: string | null;
  computeEnvironmentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateJobQueueResponse {
  jobQueueName?: string | null;
  jobQueueArn?: string | null;
}

// refs: 2 - tags: input, named, enum, output
export type CEType =
| "MANAGED"
| "UNMANAGED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CEState =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ComputeResource {
  type: CRType;
  allocationStrategy?: CRAllocationStrategy | null;
  minvCpus: number;
  maxvCpus: number;
  desiredvCpus?: number | null;
  instanceTypes: string[];
  imageId?: string | null;
  subnets: string[];
  securityGroupIds?: string[] | null;
  ec2KeyPair?: string | null;
  instanceRole: string;
  tags?: { [key: string]: string | null | undefined } | null;
  placementGroup?: string | null;
  bidPercentage?: number | null;
  spotIamFleetRole?: string | null;
  launchTemplate?: LaunchTemplateSpecification | null;
}
function fromComputeResource(input?: ComputeResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    allocationStrategy: input["allocationStrategy"],
    minvCpus: input["minvCpus"],
    maxvCpus: input["maxvCpus"],
    desiredvCpus: input["desiredvCpus"],
    instanceTypes: input["instanceTypes"],
    imageId: input["imageId"],
    subnets: input["subnets"],
    securityGroupIds: input["securityGroupIds"],
    ec2KeyPair: input["ec2KeyPair"],
    instanceRole: input["instanceRole"],
    tags: input["tags"],
    placementGroup: input["placementGroup"],
    bidPercentage: input["bidPercentage"],
    spotIamFleetRole: input["spotIamFleetRole"],
    launchTemplate: fromLaunchTemplateSpecification(input["launchTemplate"]),
  }
}
function toComputeResource(root: jsonP.JSONValue): ComputeResource {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<CRType>(x),
      "minvCpus": "n",
      "maxvCpus": "n",
      "instanceTypes": ["s"],
      "subnets": ["s"],
      "instanceRole": "s",
    },
    optional: {
      "allocationStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<CRAllocationStrategy>(x),
      "desiredvCpus": "n",
      "imageId": "s",
      "securityGroupIds": ["s"],
      "ec2KeyPair": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "placementGroup": "s",
      "bidPercentage": "n",
      "spotIamFleetRole": "s",
      "launchTemplate": toLaunchTemplateSpecification,
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type CRType =
| "EC2"
| "SPOT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type CRAllocationStrategy =
| "BEST_FIT"
| "BEST_FIT_PROGRESSIVE"
| "SPOT_CAPACITY_OPTIMIZED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface LaunchTemplateSpecification {
  launchTemplateId?: string | null;
  launchTemplateName?: string | null;
  version?: string | null;
}
function fromLaunchTemplateSpecification(input?: LaunchTemplateSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    launchTemplateId: input["launchTemplateId"],
    launchTemplateName: input["launchTemplateName"],
    version: input["version"],
  }
}
function toLaunchTemplateSpecification(root: jsonP.JSONValue): LaunchTemplateSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "launchTemplateId": "s",
      "launchTemplateName": "s",
      "version": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type JQState =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ComputeEnvironmentOrder {
  order: number;
  computeEnvironment: string;
}
function fromComputeEnvironmentOrder(input?: ComputeEnvironmentOrder | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    order: input["order"],
    computeEnvironment: input["computeEnvironment"],
  }
}
function toComputeEnvironmentOrder(root: jsonP.JSONValue): ComputeEnvironmentOrder {
  return jsonP.readObj({
    required: {
      "order": "n",
      "computeEnvironment": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type JobStatus =
| "SUBMITTED"
| "PENDING"
| "RUNNABLE"
| "STARTING"
| "RUNNING"
| "SUCCEEDED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type JobDefinitionType =
| "container"
| "multinode"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface ContainerProperties {
  image?: string | null;
  vcpus?: number | null;
  memory?: number | null;
  command?: string[] | null;
  jobRoleArn?: string | null;
  executionRoleArn?: string | null;
  volumes?: Volume[] | null;
  environment?: KeyValuePair[] | null;
  mountPoints?: MountPoint[] | null;
  readonlyRootFilesystem?: boolean | null;
  privileged?: boolean | null;
  ulimits?: Ulimit[] | null;
  user?: string | null;
  instanceType?: string | null;
  resourceRequirements?: ResourceRequirement[] | null;
  linuxParameters?: LinuxParameters | null;
  logConfiguration?: LogConfiguration | null;
  secrets?: Secret[] | null;
}
function fromContainerProperties(input?: ContainerProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    image: input["image"],
    vcpus: input["vcpus"],
    memory: input["memory"],
    command: input["command"],
    jobRoleArn: input["jobRoleArn"],
    executionRoleArn: input["executionRoleArn"],
    volumes: input["volumes"]?.map(x => fromVolume(x)),
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    mountPoints: input["mountPoints"]?.map(x => fromMountPoint(x)),
    readonlyRootFilesystem: input["readonlyRootFilesystem"],
    privileged: input["privileged"],
    ulimits: input["ulimits"]?.map(x => fromUlimit(x)),
    user: input["user"],
    instanceType: input["instanceType"],
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
    linuxParameters: fromLinuxParameters(input["linuxParameters"]),
    logConfiguration: fromLogConfiguration(input["logConfiguration"]),
    secrets: input["secrets"]?.map(x => fromSecret(x)),
  }
}
function toContainerProperties(root: jsonP.JSONValue): ContainerProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "image": "s",
      "vcpus": "n",
      "memory": "n",
      "command": ["s"],
      "jobRoleArn": "s",
      "executionRoleArn": "s",
      "volumes": [toVolume],
      "environment": [toKeyValuePair],
      "mountPoints": [toMountPoint],
      "readonlyRootFilesystem": "b",
      "privileged": "b",
      "ulimits": [toUlimit],
      "user": "s",
      "instanceType": "s",
      "resourceRequirements": [toResourceRequirement],
      "linuxParameters": toLinuxParameters,
      "logConfiguration": toLogConfiguration,
      "secrets": [toSecret],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Volume {
  host?: Host | null;
  name?: string | null;
}
function fromVolume(input?: Volume | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    host: fromHost(input["host"]),
    name: input["name"],
  }
}
function toVolume(root: jsonP.JSONValue): Volume {
  return jsonP.readObj({
    required: {},
    optional: {
      "host": toHost,
      "name": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Host {
  sourcePath?: string | null;
}
function fromHost(input?: Host | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourcePath: input["sourcePath"],
  }
}
function toHost(root: jsonP.JSONValue): Host {
  return jsonP.readObj({
    required: {},
    optional: {
      "sourcePath": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface KeyValuePair {
  name?: string | null;
  value?: string | null;
}
function fromKeyValuePair(input?: KeyValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
  }
}
function toKeyValuePair(root: jsonP.JSONValue): KeyValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "value": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MountPoint {
  containerPath?: string | null;
  readOnly?: boolean | null;
  sourceVolume?: string | null;
}
function fromMountPoint(input?: MountPoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPath: input["containerPath"],
    readOnly: input["readOnly"],
    sourceVolume: input["sourceVolume"],
  }
}
function toMountPoint(root: jsonP.JSONValue): MountPoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerPath": "s",
      "readOnly": "b",
      "sourceVolume": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Ulimit {
  hardLimit: number;
  name: string;
  softLimit: number;
}
function fromUlimit(input?: Ulimit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hardLimit: input["hardLimit"],
    name: input["name"],
    softLimit: input["softLimit"],
  }
}
function toUlimit(root: jsonP.JSONValue): Ulimit {
  return jsonP.readObj({
    required: {
      "hardLimit": "n",
      "name": "s",
      "softLimit": "n",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface ResourceRequirement {
  value: string;
  type: ResourceType;
}
function fromResourceRequirement(input?: ResourceRequirement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
    type: input["type"],
  }
}
function toResourceRequirement(root: jsonP.JSONValue): ResourceRequirement {
  return jsonP.readObj({
    required: {
      "value": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type ResourceType =
| "GPU"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface LinuxParameters {
  devices?: Device[] | null;
  initProcessEnabled?: boolean | null;
  sharedMemorySize?: number | null;
  tmpfs?: Tmpfs[] | null;
  maxSwap?: number | null;
  swappiness?: number | null;
}
function fromLinuxParameters(input?: LinuxParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    devices: input["devices"]?.map(x => fromDevice(x)),
    initProcessEnabled: input["initProcessEnabled"],
    sharedMemorySize: input["sharedMemorySize"],
    tmpfs: input["tmpfs"]?.map(x => fromTmpfs(x)),
    maxSwap: input["maxSwap"],
    swappiness: input["swappiness"],
  }
}
function toLinuxParameters(root: jsonP.JSONValue): LinuxParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "devices": [toDevice],
      "initProcessEnabled": "b",
      "sharedMemorySize": "n",
      "tmpfs": [toTmpfs],
      "maxSwap": "n",
      "swappiness": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Device {
  hostPath: string;
  containerPath?: string | null;
  permissions?: DeviceCgroupPermission[] | null;
}
function fromDevice(input?: Device | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostPath: input["hostPath"],
    containerPath: input["containerPath"],
    permissions: input["permissions"],
  }
}
function toDevice(root: jsonP.JSONValue): Device {
  return jsonP.readObj({
    required: {
      "hostPath": "s",
    },
    optional: {
      "containerPath": "s",
      "permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<DeviceCgroupPermission>(x)],
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type DeviceCgroupPermission =
| "READ"
| "WRITE"
| "MKNOD"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Tmpfs {
  containerPath: string;
  size: number;
  mountOptions?: string[] | null;
}
function fromTmpfs(input?: Tmpfs | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerPath: input["containerPath"],
    size: input["size"],
    mountOptions: input["mountOptions"],
  }
}
function toTmpfs(root: jsonP.JSONValue): Tmpfs {
  return jsonP.readObj({
    required: {
      "containerPath": "s",
      "size": "n",
    },
    optional: {
      "mountOptions": ["s"],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface LogConfiguration {
  logDriver: LogDriver;
  options?: { [key: string]: string | null | undefined } | null;
  secretOptions?: Secret[] | null;
}
function fromLogConfiguration(input?: LogConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    logDriver: input["logDriver"],
    options: input["options"],
    secretOptions: input["secretOptions"]?.map(x => fromSecret(x)),
  }
}
function toLogConfiguration(root: jsonP.JSONValue): LogConfiguration {
  return jsonP.readObj({
    required: {
      "logDriver": (x: jsonP.JSONValue) => cmnP.readEnum<LogDriver>(x),
    },
    optional: {
      "options": x => jsonP.readMap(String, String, x),
      "secretOptions": [toSecret],
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type LogDriver =
| "json-file"
| "syslog"
| "journald"
| "gelf"
| "fluentd"
| "awslogs"
| "splunk"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface Secret {
  name: string;
  valueFrom: string;
}
function fromSecret(input?: Secret | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    valueFrom: input["valueFrom"],
  }
}
function toSecret(root: jsonP.JSONValue): Secret {
  return jsonP.readObj({
    required: {
      "name": "s",
      "valueFrom": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface NodeProperties {
  numNodes: number;
  mainNode: number;
  nodeRangeProperties: NodeRangeProperty[];
}
function fromNodeProperties(input?: NodeProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    numNodes: input["numNodes"],
    mainNode: input["mainNode"],
    nodeRangeProperties: input["nodeRangeProperties"]?.map(x => fromNodeRangeProperty(x)),
  }
}
function toNodeProperties(root: jsonP.JSONValue): NodeProperties {
  return jsonP.readObj({
    required: {
      "numNodes": "n",
      "mainNode": "n",
      "nodeRangeProperties": [toNodeRangeProperty],
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface NodeRangeProperty {
  targetNodes: string;
  container?: ContainerProperties | null;
}
function fromNodeRangeProperty(input?: NodeRangeProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetNodes: input["targetNodes"],
    container: fromContainerProperties(input["container"]),
  }
}
function toNodeRangeProperty(root: jsonP.JSONValue): NodeRangeProperty {
  return jsonP.readObj({
    required: {
      "targetNodes": "s",
    },
    optional: {
      "container": toContainerProperties,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface RetryStrategy {
  attempts?: number | null;
  evaluateOnExit?: EvaluateOnExit[] | null;
}
function fromRetryStrategy(input?: RetryStrategy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attempts: input["attempts"],
    evaluateOnExit: input["evaluateOnExit"]?.map(x => fromEvaluateOnExit(x)),
  }
}
function toRetryStrategy(root: jsonP.JSONValue): RetryStrategy {
  return jsonP.readObj({
    required: {},
    optional: {
      "attempts": "n",
      "evaluateOnExit": [toEvaluateOnExit],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface EvaluateOnExit {
  onStatusReason?: string | null;
  onReason?: string | null;
  onExitCode?: string | null;
  action: RetryAction;
}
function fromEvaluateOnExit(input?: EvaluateOnExit | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    onStatusReason: input["onStatusReason"],
    onReason: input["onReason"],
    onExitCode: input["onExitCode"],
    action: input["action"],
  }
}
function toEvaluateOnExit(root: jsonP.JSONValue): EvaluateOnExit {
  return jsonP.readObj({
    required: {
      "action": (x: jsonP.JSONValue) => cmnP.readEnum<RetryAction>(x),
    },
    optional: {
      "onStatusReason": "s",
      "onReason": "s",
      "onExitCode": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type RetryAction =
| "RETRY"
| "EXIT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface JobTimeout {
  attemptDurationSeconds?: number | null;
}
function fromJobTimeout(input?: JobTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attemptDurationSeconds: input["attemptDurationSeconds"],
  }
}
function toJobTimeout(root: jsonP.JSONValue): JobTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "attemptDurationSeconds": "n",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ArrayProperties {
  size?: number | null;
}
function fromArrayProperties(input?: ArrayProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    size: input["size"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface JobDependency {
  jobId?: string | null;
  type?: ArrayJobDependency | null;
}
function fromJobDependency(input?: JobDependency | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jobId: input["jobId"],
    type: input["type"],
  }
}
function toJobDependency(root: jsonP.JSONValue): JobDependency {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobId": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ArrayJobDependency>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ArrayJobDependency =
| "N_TO_N"
| "SEQUENTIAL"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ContainerOverrides {
  vcpus?: number | null;
  memory?: number | null;
  command?: string[] | null;
  instanceType?: string | null;
  environment?: KeyValuePair[] | null;
  resourceRequirements?: ResourceRequirement[] | null;
}
function fromContainerOverrides(input?: ContainerOverrides | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    vcpus: input["vcpus"],
    memory: input["memory"],
    command: input["command"],
    instanceType: input["instanceType"],
    environment: input["environment"]?.map(x => fromKeyValuePair(x)),
    resourceRequirements: input["resourceRequirements"]?.map(x => fromResourceRequirement(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface NodeOverrides {
  numNodes?: number | null;
  nodePropertyOverrides?: NodePropertyOverride[] | null;
}
function fromNodeOverrides(input?: NodeOverrides | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    numNodes: input["numNodes"],
    nodePropertyOverrides: input["nodePropertyOverrides"]?.map(x => fromNodePropertyOverride(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface NodePropertyOverride {
  targetNodes: string;
  containerOverrides?: ContainerOverrides | null;
}
function fromNodePropertyOverride(input?: NodePropertyOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    targetNodes: input["targetNodes"],
    containerOverrides: fromContainerOverrides(input["containerOverrides"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface ComputeResourceUpdate {
  minvCpus?: number | null;
  maxvCpus?: number | null;
  desiredvCpus?: number | null;
}
function fromComputeResourceUpdate(input?: ComputeResourceUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    minvCpus: input["minvCpus"],
    maxvCpus: input["maxvCpus"],
    desiredvCpus: input["desiredvCpus"],
  }
}

// refs: 1 - tags: output, named, interface
export interface ComputeEnvironmentDetail {
  computeEnvironmentName: string;
  computeEnvironmentArn: string;
  ecsClusterArn: string;
  tags?: { [key: string]: string | null | undefined } | null;
  type?: CEType | null;
  state?: CEState | null;
  status?: CEStatus | null;
  statusReason?: string | null;
  computeResources?: ComputeResource | null;
  serviceRole?: string | null;
}
function toComputeEnvironmentDetail(root: jsonP.JSONValue): ComputeEnvironmentDetail {
  return jsonP.readObj({
    required: {
      "computeEnvironmentName": "s",
      "computeEnvironmentArn": "s",
      "ecsClusterArn": "s",
    },
    optional: {
      "tags": x => jsonP.readMap(String, String, x),
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<CEType>(x),
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<CEState>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<CEStatus>(x),
      "statusReason": "s",
      "computeResources": toComputeResource,
      "serviceRole": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type CEStatus =
| "CREATING"
| "UPDATING"
| "DELETING"
| "DELETED"
| "VALID"
| "INVALID"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface JobDefinition {
  jobDefinitionName: string;
  jobDefinitionArn: string;
  revision: number;
  status?: string | null;
  type: string;
  parameters?: { [key: string]: string | null | undefined } | null;
  retryStrategy?: RetryStrategy | null;
  containerProperties?: ContainerProperties | null;
  timeout?: JobTimeout | null;
  nodeProperties?: NodeProperties | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toJobDefinition(root: jsonP.JSONValue): JobDefinition {
  return jsonP.readObj({
    required: {
      "jobDefinitionName": "s",
      "jobDefinitionArn": "s",
      "revision": "n",
      "type": "s",
    },
    optional: {
      "status": "s",
      "parameters": x => jsonP.readMap(String, String, x),
      "retryStrategy": toRetryStrategy,
      "containerProperties": toContainerProperties,
      "timeout": toJobTimeout,
      "nodeProperties": toNodeProperties,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobQueueDetail {
  jobQueueName: string;
  jobQueueArn: string;
  state: JQState;
  status?: JQStatus | null;
  statusReason?: string | null;
  priority: number;
  computeEnvironmentOrder: ComputeEnvironmentOrder[];
  tags?: { [key: string]: string | null | undefined } | null;
}
function toJobQueueDetail(root: jsonP.JSONValue): JobQueueDetail {
  return jsonP.readObj({
    required: {
      "jobQueueName": "s",
      "jobQueueArn": "s",
      "state": (x: jsonP.JSONValue) => cmnP.readEnum<JQState>(x),
      "priority": "n",
      "computeEnvironmentOrder": [toComputeEnvironmentOrder],
    },
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<JQStatus>(x),
      "statusReason": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type JQStatus =
| "CREATING"
| "UPDATING"
| "DELETING"
| "DELETED"
| "VALID"
| "INVALID"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface JobDetail {
  jobArn?: string | null;
  jobName: string;
  jobId: string;
  jobQueue: string;
  status: JobStatus;
  attempts?: AttemptDetail[] | null;
  statusReason?: string | null;
  createdAt?: number | null;
  retryStrategy?: RetryStrategy | null;
  startedAt: number;
  stoppedAt?: number | null;
  dependsOn?: JobDependency[] | null;
  jobDefinition: string;
  parameters?: { [key: string]: string | null | undefined } | null;
  container?: ContainerDetail | null;
  nodeDetails?: NodeDetails | null;
  nodeProperties?: NodeProperties | null;
  arrayProperties?: ArrayPropertiesDetail | null;
  timeout?: JobTimeout | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toJobDetail(root: jsonP.JSONValue): JobDetail {
  return jsonP.readObj({
    required: {
      "jobName": "s",
      "jobId": "s",
      "jobQueue": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      "startedAt": "n",
      "jobDefinition": "s",
    },
    optional: {
      "jobArn": "s",
      "attempts": [toAttemptDetail],
      "statusReason": "s",
      "createdAt": "n",
      "retryStrategy": toRetryStrategy,
      "stoppedAt": "n",
      "dependsOn": [toJobDependency],
      "parameters": x => jsonP.readMap(String, String, x),
      "container": toContainerDetail,
      "nodeDetails": toNodeDetails,
      "nodeProperties": toNodeProperties,
      "arrayProperties": toArrayPropertiesDetail,
      "timeout": toJobTimeout,
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AttemptDetail {
  container?: AttemptContainerDetail | null;
  startedAt?: number | null;
  stoppedAt?: number | null;
  statusReason?: string | null;
}
function toAttemptDetail(root: jsonP.JSONValue): AttemptDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "container": toAttemptContainerDetail,
      "startedAt": "n",
      "stoppedAt": "n",
      "statusReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AttemptContainerDetail {
  containerInstanceArn?: string | null;
  taskArn?: string | null;
  exitCode?: number | null;
  reason?: string | null;
  logStreamName?: string | null;
  networkInterfaces?: NetworkInterface[] | null;
}
function toAttemptContainerDetail(root: jsonP.JSONValue): AttemptContainerDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "containerInstanceArn": "s",
      "taskArn": "s",
      "exitCode": "n",
      "reason": "s",
      "logStreamName": "s",
      "networkInterfaces": [toNetworkInterface],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface NetworkInterface {
  attachmentId?: string | null;
  ipv6Address?: string | null;
  privateIpv4Address?: string | null;
}
function toNetworkInterface(root: jsonP.JSONValue): NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "attachmentId": "s",
      "ipv6Address": "s",
      "privateIpv4Address": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ContainerDetail {
  image?: string | null;
  vcpus?: number | null;
  memory?: number | null;
  command?: string[] | null;
  jobRoleArn?: string | null;
  executionRoleArn?: string | null;
  volumes?: Volume[] | null;
  environment?: KeyValuePair[] | null;
  mountPoints?: MountPoint[] | null;
  readonlyRootFilesystem?: boolean | null;
  ulimits?: Ulimit[] | null;
  privileged?: boolean | null;
  user?: string | null;
  exitCode?: number | null;
  reason?: string | null;
  containerInstanceArn?: string | null;
  taskArn?: string | null;
  logStreamName?: string | null;
  instanceType?: string | null;
  networkInterfaces?: NetworkInterface[] | null;
  resourceRequirements?: ResourceRequirement[] | null;
  linuxParameters?: LinuxParameters | null;
  logConfiguration?: LogConfiguration | null;
  secrets?: Secret[] | null;
}
function toContainerDetail(root: jsonP.JSONValue): ContainerDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "image": "s",
      "vcpus": "n",
      "memory": "n",
      "command": ["s"],
      "jobRoleArn": "s",
      "executionRoleArn": "s",
      "volumes": [toVolume],
      "environment": [toKeyValuePair],
      "mountPoints": [toMountPoint],
      "readonlyRootFilesystem": "b",
      "ulimits": [toUlimit],
      "privileged": "b",
      "user": "s",
      "exitCode": "n",
      "reason": "s",
      "containerInstanceArn": "s",
      "taskArn": "s",
      "logStreamName": "s",
      "instanceType": "s",
      "networkInterfaces": [toNetworkInterface],
      "resourceRequirements": [toResourceRequirement],
      "linuxParameters": toLinuxParameters,
      "logConfiguration": toLogConfiguration,
      "secrets": [toSecret],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NodeDetails {
  nodeIndex?: number | null;
  isMainNode?: boolean | null;
}
function toNodeDetails(root: jsonP.JSONValue): NodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "nodeIndex": "n",
      "isMainNode": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ArrayPropertiesDetail {
  statusSummary?: { [key: string]: number | null | undefined } | null;
  size?: number | null;
  index?: number | null;
}
function toArrayPropertiesDetail(root: jsonP.JSONValue): ArrayPropertiesDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusSummary": x => jsonP.readMap(String, Number, x),
      "size": "n",
      "index": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobSummary {
  jobArn?: string | null;
  jobId: string;
  jobName: string;
  createdAt?: number | null;
  status?: JobStatus | null;
  statusReason?: string | null;
  startedAt?: number | null;
  stoppedAt?: number | null;
  container?: ContainerSummary | null;
  arrayProperties?: ArrayPropertiesSummary | null;
  nodeProperties?: NodePropertiesSummary | null;
}
function toJobSummary(root: jsonP.JSONValue): JobSummary {
  return jsonP.readObj({
    required: {
      "jobId": "s",
      "jobName": "s",
    },
    optional: {
      "jobArn": "s",
      "createdAt": "n",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      "statusReason": "s",
      "startedAt": "n",
      "stoppedAt": "n",
      "container": toContainerSummary,
      "arrayProperties": toArrayPropertiesSummary,
      "nodeProperties": toNodePropertiesSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ContainerSummary {
  exitCode?: number | null;
  reason?: string | null;
}
function toContainerSummary(root: jsonP.JSONValue): ContainerSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "exitCode": "n",
      "reason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ArrayPropertiesSummary {
  size?: number | null;
  index?: number | null;
}
function toArrayPropertiesSummary(root: jsonP.JSONValue): ArrayPropertiesSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "size": "n",
      "index": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NodePropertiesSummary {
  isMainNode?: boolean | null;
  numNodes?: number | null;
  nodeIndex?: number | null;
}
function toNodePropertiesSummary(root: jsonP.JSONValue): NodePropertiesSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "isMainNode": "b",
      "numNodes": "n",
      "nodeIndex": "n",
    },
  }, root);
}
