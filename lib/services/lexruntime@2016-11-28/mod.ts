// Autogenerated API client for: Amazon Lex Runtime Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class LexRuntime {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexRuntime.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-11-28",
    "endpointPrefix": "runtime.lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon Lex Runtime Service",
    "serviceId": "Lex Runtime Service",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "runtime.lex-2016-11-28"
  };

  async deleteSession(
    {abortSignal, ...params}: RequestConfig & s.DeleteSessionRequest,
  ): Promise<s.DeleteSessionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSession",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bot/${params["botName"]}/alias/${params["botAlias"]}/user/${params["userId"]}/session`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botName": "s",
        "botAlias": "s",
        "userId": "s",
        "sessionId": "s",
      },
    }, await resp.json());
  }

  async getSession(
    {abortSignal, ...params}: RequestConfig & s.GetSessionRequest,
  ): Promise<s.GetSessionResponse> {
    const query = new URLSearchParams;
    if (params["checkpointLabelFilter"] != null) query.set("checkpointLabelFilter", params["checkpointLabelFilter"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSession",
      method: "GET",
      requestUri: cmnP.encodePath`/bot/${params["botName"]}/alias/${params["botAlias"]}/user/${params["userId"]}/session/`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "recentIntentSummaryView": [toIntentSummary],
        "sessionAttributes": x => jsonP.readMap(String, String, x),
        "sessionId": "s",
        "dialogAction": toDialogAction,
        "activeContexts": [toActiveContext],
      },
    }, await resp.json());
  }

  async postContent(
    {abortSignal, ...params}: RequestConfig & s.PostContentRequest,
  ): Promise<s.PostContentResponse> {
    const body = typeof params["inputStream"] === 'string' ? new TextEncoder().encode(params["inputStream"]) : params["inputStream"];
    const headers = new Headers;
    if (params["sessionAttributes"] != null) headers.append("x-amz-lex-session-attributes", btoa(jsonP.serializeJsonValue(params["sessionAttributes"]) ?? ''));
    if (params["requestAttributes"] != null) headers.append("x-amz-lex-request-attributes", btoa(jsonP.serializeJsonValue(params["requestAttributes"]) ?? ''));
    headers.append("Content-Type", params["contentType"]);
    if (params["accept"] != null) headers.append("Accept", params["accept"]);
    if (params["activeContexts"] != null) headers.append("x-amz-lex-active-contexts", btoa(jsonP.serializeJsonValue(params["activeContexts"]) ?? ''));
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PostContent",
      requestUri: cmnP.encodePath`/bot/${params["botName"]}/alias/${params["botAlias"]}/user/${params["userId"]}/content`,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    intentName: resp.headers.get("x-amz-lex-intent-name"),
    nluIntentConfidence: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-nlu-intent-confidence")),
    alternativeIntents: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-alternative-intents")),
    slots: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-slots")),
    sessionAttributes: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-session-attributes")),
    sentimentResponse: resp.headers.get("x-amz-lex-sentiment"),
    message: resp.headers.get("x-amz-lex-message"),
    messageFormat: cmnP.readEnum<s.MessageFormatType>(resp.headers.get("x-amz-lex-message-format")),
    dialogState: cmnP.readEnum<s.DialogState>(resp.headers.get("x-amz-lex-dialog-state")),
    slotToElicit: resp.headers.get("x-amz-lex-slot-to-elicit"),
    inputTranscript: resp.headers.get("x-amz-lex-input-transcript"),
    botVersion: resp.headers.get("x-amz-lex-bot-version"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    activeContexts: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-active-contexts")),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async postText(
    {abortSignal, ...params}: RequestConfig & s.PostTextRequest,
  ): Promise<s.PostTextResponse> {
    const body: jsonP.JSONObject = {
      sessionAttributes: params["sessionAttributes"],
      requestAttributes: params["requestAttributes"],
      inputText: params["inputText"],
      activeContexts: params["activeContexts"]?.map(x => fromActiveContext(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PostText",
      requestUri: cmnP.encodePath`/bot/${params["botName"]}/alias/${params["botAlias"]}/user/${params["userId"]}/text`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intentName": "s",
        "nluIntentConfidence": toIntentConfidence,
        "alternativeIntents": [toPredictedIntent],
        "slots": x => jsonP.readMap(String, String, x),
        "sessionAttributes": x => jsonP.readMap(String, String, x),
        "message": "s",
        "sentimentResponse": toSentimentResponse,
        "messageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageFormatType>(x),
        "dialogState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DialogState>(x),
        "slotToElicit": "s",
        "responseCard": toResponseCard,
        "sessionId": "s",
        "botVersion": "s",
        "activeContexts": [toActiveContext],
      },
    }, await resp.json());
  }

  async putSession(
    {abortSignal, ...params}: RequestConfig & s.PutSessionRequest,
  ): Promise<s.PutSessionResponse> {
    const headers = new Headers;
    const body: jsonP.JSONObject = {
      sessionAttributes: params["sessionAttributes"],
      dialogAction: fromDialogAction(params["dialogAction"]),
      recentIntentSummaryView: params["recentIntentSummaryView"]?.map(x => fromIntentSummary(x)),
      activeContexts: params["activeContexts"]?.map(x => fromActiveContext(x)),
    };
    if (params["accept"] != null) headers.append("Accept", params["accept"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutSession",
      requestUri: cmnP.encodePath`/bot/${params["botName"]}/alias/${params["botAlias"]}/user/${params["userId"]}/session`,
    });
  return {
    contentType: resp.headers.get("Content-Type"),
    intentName: resp.headers.get("x-amz-lex-intent-name"),
    slots: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-slots")),
    sessionAttributes: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-session-attributes")),
    message: resp.headers.get("x-amz-lex-message"),
    messageFormat: cmnP.readEnum<s.MessageFormatType>(resp.headers.get("x-amz-lex-message-format")),
    dialogState: cmnP.readEnum<s.DialogState>(resp.headers.get("x-amz-lex-dialog-state")),
    slotToElicit: resp.headers.get("x-amz-lex-slot-to-elicit"),
    sessionId: resp.headers.get("x-amz-lex-session-id"),
    activeContexts: jsonP.readJsonValueBase64(resp.headers.get("x-amz-lex-active-contexts")),
    audioStream: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

}

function fromActiveContext(input?: s.ActiveContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    timeToLive: fromActiveContextTimeToLive(input["timeToLive"]),
    parameters: input["parameters"],
  }
}
function toActiveContext(root: jsonP.JSONValue): s.ActiveContext {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timeToLive": toActiveContextTimeToLive,
      "parameters": x => jsonP.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

function fromActiveContextTimeToLive(input?: s.ActiveContextTimeToLive | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timeToLiveInSeconds: input["timeToLiveInSeconds"],
    turnsToLive: input["turnsToLive"],
  }
}
function toActiveContextTimeToLive(root: jsonP.JSONValue): s.ActiveContextTimeToLive {
  return jsonP.readObj({
    required: {},
    optional: {
      "timeToLiveInSeconds": "n",
      "turnsToLive": "n",
    },
  }, root);
}

function fromDialogAction(input?: s.DialogAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    intentName: input["intentName"],
    slots: input["slots"],
    slotToElicit: input["slotToElicit"],
    fulfillmentState: input["fulfillmentState"],
    message: input["message"],
    messageFormat: input["messageFormat"],
  }
}
function toDialogAction(root: jsonP.JSONValue): s.DialogAction {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DialogActionType>(x),
    },
    optional: {
      "intentName": "s",
      "slots": x => jsonP.readMap(String, String, x),
      "slotToElicit": "s",
      "fulfillmentState": (x: jsonP.JSONValue) => cmnP.readEnum<s.FulfillmentState>(x),
      "message": "s",
      "messageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageFormatType>(x),
    },
  }, root);
}

function fromIntentSummary(input?: s.IntentSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    intentName: input["intentName"],
    checkpointLabel: input["checkpointLabel"],
    slots: input["slots"],
    confirmationStatus: input["confirmationStatus"],
    dialogActionType: input["dialogActionType"],
    fulfillmentState: input["fulfillmentState"],
    slotToElicit: input["slotToElicit"],
  }
}
function toIntentSummary(root: jsonP.JSONValue): s.IntentSummary {
  return jsonP.readObj({
    required: {
      "dialogActionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DialogActionType>(x),
    },
    optional: {
      "intentName": "s",
      "checkpointLabel": "s",
      "slots": x => jsonP.readMap(String, String, x),
      "confirmationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConfirmationStatus>(x),
      "fulfillmentState": (x: jsonP.JSONValue) => cmnP.readEnum<s.FulfillmentState>(x),
      "slotToElicit": "s",
    },
  }, root);
}

function toIntentConfidence(root: jsonP.JSONValue): s.IntentConfidence {
  return jsonP.readObj({
    required: {},
    optional: {
      "score": "n",
    },
  }, root);
}

function toPredictedIntent(root: jsonP.JSONValue): s.PredictedIntent {
  return jsonP.readObj({
    required: {},
    optional: {
      "intentName": "s",
      "nluIntentConfidence": toIntentConfidence,
      "slots": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toSentimentResponse(root: jsonP.JSONValue): s.SentimentResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "sentimentLabel": "s",
      "sentimentScore": "s",
    },
  }, root);
}

function toResponseCard(root: jsonP.JSONValue): s.ResponseCard {
  return jsonP.readObj({
    required: {},
    optional: {
      "version": "s",
      "contentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContentType>(x),
      "genericAttachments": [toGenericAttachment],
    },
  }, root);
}

function toGenericAttachment(root: jsonP.JSONValue): s.GenericAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "title": "s",
      "subTitle": "s",
      "attachmentLinkUrl": "s",
      "imageUrl": "s",
      "buttons": [toButton],
    },
  }, root);
}

function toButton(root: jsonP.JSONValue): s.Button {
  return jsonP.readObj({
    required: {
      "text": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}
