// Autogenerated API client for: Amazon Lex Model Building V2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class LexModelsV2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(LexModelsV2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-08-07",
    "endpointPrefix": "models-v2-lex",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Lex Models V2",
    "serviceFullName": "Amazon Lex Model Building V2",
    "serviceId": "Lex Models V2",
    "signatureVersion": "v4",
    "signingName": "lex",
    "uid": "models.lex.v2-2020-08-07"
  };

  async buildBotLocale(
    {abortSignal, ...params}: RequestConfig & s.BuildBotLocaleRequest,
  ): Promise<s.BuildBotLocaleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "BuildBotLocale",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
        "lastBuildSubmittedDateTime": "d",
      },
    }, await resp.json());
  }

  async createBot(
    {abortSignal, ...params}: RequestConfig & s.CreateBotRequest,
  ): Promise<s.CreateBotResponse> {
    const body: jsonP.JSONObject = {
      botName: params["botName"],
      description: params["description"],
      roleArn: params["roleArn"],
      dataPrivacy: fromDataPrivacy(params["dataPrivacy"]),
      idleSessionTTLInSeconds: params["idleSessionTTLInSeconds"],
      botTags: params["botTags"],
      testBotAliasTags: params["testBotAliasTags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBot",
      method: "PUT",
      requestUri: "/bots/",
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botName": "s",
        "description": "s",
        "roleArn": "s",
        "dataPrivacy": toDataPrivacy,
        "idleSessionTTLInSeconds": "n",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
        "creationDateTime": "d",
        "botTags": x => jsonP.readMap(String, String, x),
        "testBotAliasTags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createBotAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateBotAliasRequest,
  ): Promise<s.CreateBotAliasResponse> {
    const body: jsonP.JSONObject = {
      botAliasName: params["botAliasName"],
      description: params["description"],
      botVersion: params["botVersion"],
      botAliasLocaleSettings: jsonP.serializeMap(params["botAliasLocaleSettings"], x => fromBotAliasLocaleSettings(x)),
      conversationLogSettings: fromConversationLogSettings(params["conversationLogSettings"]),
      sentimentAnalysisSettings: fromSentimentAnalysisSettings(params["sentimentAnalysisSettings"]),
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBotAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botaliases/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botAliasId": "s",
        "botAliasName": "s",
        "description": "s",
        "botVersion": "s",
        "botAliasLocaleSettings": x => jsonP.readMap(String, toBotAliasLocaleSettings, x),
        "conversationLogSettings": toConversationLogSettings,
        "sentimentAnalysisSettings": toSentimentAnalysisSettings,
        "botAliasStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotAliasStatus>(x),
        "botId": "s",
        "creationDateTime": "d",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createBotLocale(
    {abortSignal, ...params}: RequestConfig & s.CreateBotLocaleRequest,
  ): Promise<s.CreateBotLocaleResponse> {
    const body: jsonP.JSONObject = {
      localeId: params["localeId"],
      description: params["description"],
      nluIntentConfidenceThreshold: params["nluIntentConfidenceThreshold"],
      voiceSettings: fromVoiceSettings(params["voiceSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBotLocale",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeName": "s",
        "localeId": "s",
        "description": "s",
        "nluIntentConfidenceThreshold": "n",
        "voiceSettings": toVoiceSettings,
        "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async createBotVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateBotVersionRequest,
  ): Promise<s.CreateBotVersionResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      botVersionLocaleSpecification: jsonP.serializeMap(params["botVersionLocaleSpecification"], x => fromBotVersionLocaleDetails(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBotVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "description": "s",
        "botVersion": "s",
        "botVersionLocaleSpecification": x => jsonP.readMap(String, toBotVersionLocaleDetails, x),
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async createIntent(
    {abortSignal, ...params}: RequestConfig & s.CreateIntentRequest,
  ): Promise<s.CreateIntentResponse> {
    const body: jsonP.JSONObject = {
      intentName: params["intentName"],
      description: params["description"],
      parentIntentSignature: params["parentIntentSignature"],
      sampleUtterances: params["sampleUtterances"]?.map(x => fromSampleUtterance(x)),
      dialogCodeHook: fromDialogCodeHookSettings(params["dialogCodeHook"]),
      fulfillmentCodeHook: fromFulfillmentCodeHookSettings(params["fulfillmentCodeHook"]),
      intentConfirmationSetting: fromIntentConfirmationSetting(params["intentConfirmationSetting"]),
      intentClosingSetting: fromIntentClosingSetting(params["intentClosingSetting"]),
      inputContexts: params["inputContexts"]?.map(x => fromInputContext(x)),
      outputContexts: params["outputContexts"]?.map(x => fromOutputContext(x)),
      kendraConfiguration: fromKendraConfiguration(params["kendraConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIntent",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intentId": "s",
        "intentName": "s",
        "description": "s",
        "parentIntentSignature": "s",
        "sampleUtterances": [toSampleUtterance],
        "dialogCodeHook": toDialogCodeHookSettings,
        "fulfillmentCodeHook": toFulfillmentCodeHookSettings,
        "intentConfirmationSetting": toIntentConfirmationSetting,
        "intentClosingSetting": toIntentClosingSetting,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
        "kendraConfiguration": toKendraConfiguration,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async createSlot(
    {abortSignal, ...params}: RequestConfig & s.CreateSlotRequest,
  ): Promise<s.CreateSlotResponse> {
    const body: jsonP.JSONObject = {
      slotName: params["slotName"],
      description: params["description"],
      slotTypeId: params["slotTypeId"],
      valueElicitationSetting: fromSlotValueElicitationSetting(params["valueElicitationSetting"]),
      obfuscationSetting: fromObfuscationSetting(params["obfuscationSetting"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSlot",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/slots/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotId": "s",
        "slotName": "s",
        "description": "s",
        "slotTypeId": "s",
        "valueElicitationSetting": toSlotValueElicitationSetting,
        "obfuscationSetting": toObfuscationSetting,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "intentId": "s",
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async createSlotType(
    {abortSignal, ...params}: RequestConfig & s.CreateSlotTypeRequest,
  ): Promise<s.CreateSlotTypeResponse> {
    const body: jsonP.JSONObject = {
      slotTypeName: params["slotTypeName"],
      description: params["description"],
      slotTypeValues: params["slotTypeValues"]?.map(x => fromSlotTypeValue(x)),
      valueSelectionSetting: fromSlotValueSelectionSetting(params["valueSelectionSetting"]),
      parentSlotTypeSignature: params["parentSlotTypeSignature"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSlotType",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/slottypes/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypeId": "s",
        "slotTypeName": "s",
        "description": "s",
        "slotTypeValues": [toSlotTypeValue],
        "valueSelectionSetting": toSlotValueSelectionSetting,
        "parentSlotTypeSignature": "s",
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async deleteBot(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotRequest,
  ): Promise<s.DeleteBotResponse> {
    const query = new URLSearchParams;
    if (params["skipResourceInUseCheck"] != null) query.set("skipResourceInUseCheck", params["skipResourceInUseCheck"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteBot",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
      },
    }, await resp.json());
  }

  async deleteBotAlias(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotAliasRequest,
  ): Promise<s.DeleteBotAliasResponse> {
    const query = new URLSearchParams;
    if (params["skipResourceInUseCheck"] != null) query.set("skipResourceInUseCheck", params["skipResourceInUseCheck"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteBotAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botaliases/${params["botAliasId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botAliasId": "s",
        "botId": "s",
        "botAliasStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotAliasStatus>(x),
      },
    }, await resp.json());
  }

  async deleteBotLocale(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotLocaleRequest,
  ): Promise<s.DeleteBotLocaleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBotLocale",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
      },
    }, await resp.json());
  }

  async deleteBotVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteBotVersionRequest,
  ): Promise<s.DeleteBotVersionResponse> {
    const query = new URLSearchParams;
    if (params["skipResourceInUseCheck"] != null) query.set("skipResourceInUseCheck", params["skipResourceInUseCheck"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteBotVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
      },
    }, await resp.json());
  }

  async deleteIntent(
    {abortSignal, ...params}: RequestConfig & s.DeleteIntentRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteIntent",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/`,
      responseCode: 204,
    });
    await resp.text();
  }

  async deleteSlot(
    {abortSignal, ...params}: RequestConfig & s.DeleteSlotRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSlot",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/slots/${params["slotId"]}/`,
      responseCode: 204,
    });
    await resp.text();
  }

  async deleteSlotType(
    {abortSignal, ...params}: RequestConfig & s.DeleteSlotTypeRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["skipResourceInUseCheck"] != null) query.set("skipResourceInUseCheck", params["skipResourceInUseCheck"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteSlotType",
      method: "DELETE",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/slottypes/${params["slotTypeId"]}/`,
      responseCode: 204,
    });
    await resp.text();
  }

  async describeBot(
    {abortSignal, ...params}: RequestConfig & s.DescribeBotRequest,
  ): Promise<s.DescribeBotResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBot",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botName": "s",
        "description": "s",
        "roleArn": "s",
        "dataPrivacy": toDataPrivacy,
        "idleSessionTTLInSeconds": "n",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async describeBotAlias(
    {abortSignal, ...params}: RequestConfig & s.DescribeBotAliasRequest,
  ): Promise<s.DescribeBotAliasResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBotAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botaliases/${params["botAliasId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botAliasId": "s",
        "botAliasName": "s",
        "description": "s",
        "botVersion": "s",
        "botAliasLocaleSettings": x => jsonP.readMap(String, toBotAliasLocaleSettings, x),
        "conversationLogSettings": toConversationLogSettings,
        "sentimentAnalysisSettings": toSentimentAnalysisSettings,
        "botAliasHistoryEvents": [toBotAliasHistoryEvent],
        "botAliasStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotAliasStatus>(x),
        "botId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async describeBotLocale(
    {abortSignal, ...params}: RequestConfig & s.DescribeBotLocaleRequest,
  ): Promise<s.DescribeBotLocaleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBotLocale",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "localeName": "s",
        "description": "s",
        "nluIntentConfidenceThreshold": "n",
        "voiceSettings": toVoiceSettings,
        "intentsCount": "n",
        "slotTypesCount": "n",
        "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
        "failureReasons": ["s"],
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
        "lastBuildSubmittedDateTime": "d",
        "botLocaleHistoryEvents": [toBotLocaleHistoryEvent],
      },
    }, await resp.json());
  }

  async describeBotVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribeBotVersionRequest,
  ): Promise<s.DescribeBotVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeBotVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botName": "s",
        "botVersion": "s",
        "description": "s",
        "roleArn": "s",
        "dataPrivacy": toDataPrivacy,
        "idleSessionTTLInSeconds": "n",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
        "failureReasons": ["s"],
        "creationDateTime": "d",
      },
    }, await resp.json());
  }

  async describeIntent(
    {abortSignal, ...params}: RequestConfig & s.DescribeIntentRequest,
  ): Promise<s.DescribeIntentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeIntent",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intentId": "s",
        "intentName": "s",
        "description": "s",
        "parentIntentSignature": "s",
        "sampleUtterances": [toSampleUtterance],
        "dialogCodeHook": toDialogCodeHookSettings,
        "fulfillmentCodeHook": toFulfillmentCodeHookSettings,
        "slotPriorities": [toSlotPriority],
        "intentConfirmationSetting": toIntentConfirmationSetting,
        "intentClosingSetting": toIntentClosingSetting,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
        "kendraConfiguration": toKendraConfiguration,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async describeSlot(
    {abortSignal, ...params}: RequestConfig & s.DescribeSlotRequest,
  ): Promise<s.DescribeSlotResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSlot",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/slots/${params["slotId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotId": "s",
        "slotName": "s",
        "description": "s",
        "slotTypeId": "s",
        "valueElicitationSetting": toSlotValueElicitationSetting,
        "obfuscationSetting": toObfuscationSetting,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "intentId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async describeSlotType(
    {abortSignal, ...params}: RequestConfig & s.DescribeSlotTypeRequest,
  ): Promise<s.DescribeSlotTypeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSlotType",
      method: "GET",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/slottypes/${params["slotTypeId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypeId": "s",
        "slotTypeName": "s",
        "description": "s",
        "slotTypeValues": [toSlotTypeValue],
        "valueSelectionSetting": toSlotValueSelectionSetting,
        "parentSlotTypeSignature": "s",
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async listBotAliases(
    {abortSignal, ...params}: RequestConfig & s.ListBotAliasesRequest,
  ): Promise<s.ListBotAliasesResponse> {
    const body: jsonP.JSONObject = {
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBotAliases",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botaliases/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botAliasSummaries": [toBotAliasSummary],
        "nextToken": "s",
        "botId": "s",
      },
    }, await resp.json());
  }

  async listBotLocales(
    {abortSignal, ...params}: RequestConfig & s.ListBotLocalesRequest,
  ): Promise<s.ListBotLocalesResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromBotLocaleSortBy(params["sortBy"]),
      filters: params["filters"]?.map(x => fromBotLocaleFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBotLocales",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "nextToken": "s",
        "botLocaleSummaries": [toBotLocaleSummary],
      },
    }, await resp.json());
  }

  async listBotVersions(
    {abortSignal, ...params}: RequestConfig & s.ListBotVersionsRequest,
  ): Promise<s.ListBotVersionsResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromBotVersionSortBy(params["sortBy"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBotVersions",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersionSummaries": [toBotVersionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBots(
    {abortSignal, ...params}: RequestConfig & s.ListBotsRequest = {},
  ): Promise<s.ListBotsResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromBotSortBy(params["sortBy"]),
      filters: params["filters"]?.map(x => fromBotFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBots",
      requestUri: "/bots/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botSummaries": [toBotSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuiltInIntents(
    {abortSignal, ...params}: RequestConfig & s.ListBuiltInIntentsRequest,
  ): Promise<s.ListBuiltInIntentsResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromBuiltInIntentSortBy(params["sortBy"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuiltInIntents",
      requestUri: cmnP.encodePath`/builtins/locales/${params["localeId"]}/intents/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "builtInIntentSummaries": [toBuiltInIntentSummary],
        "nextToken": "s",
        "localeId": "s",
      },
    }, await resp.json());
  }

  async listBuiltInSlotTypes(
    {abortSignal, ...params}: RequestConfig & s.ListBuiltInSlotTypesRequest,
  ): Promise<s.ListBuiltInSlotTypesResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromBuiltInSlotTypeSortBy(params["sortBy"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuiltInSlotTypes",
      requestUri: cmnP.encodePath`/builtins/locales/${params["localeId"]}/slottypes/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "builtInSlotTypeSummaries": [toBuiltInSlotTypeSummary],
        "nextToken": "s",
        "localeId": "s",
      },
    }, await resp.json());
  }

  async listIntents(
    {abortSignal, ...params}: RequestConfig & s.ListIntentsRequest,
  ): Promise<s.ListIntentsResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromIntentSortBy(params["sortBy"]),
      filters: params["filters"]?.map(x => fromIntentFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIntents",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "intentSummaries": [toIntentSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSlotTypes(
    {abortSignal, ...params}: RequestConfig & s.ListSlotTypesRequest,
  ): Promise<s.ListSlotTypesResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromSlotTypeSortBy(params["sortBy"]),
      filters: params["filters"]?.map(x => fromSlotTypeFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSlotTypes",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/slottypes/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "slotTypeSummaries": [toSlotTypeSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSlots(
    {abortSignal, ...params}: RequestConfig & s.ListSlotsRequest,
  ): Promise<s.ListSlotsResponse> {
    const body: jsonP.JSONObject = {
      sortBy: fromSlotSortBy(params["sortBy"]),
      filters: params["filters"]?.map(x => fromSlotFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSlots",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/slots/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "intentId": "s",
        "slotSummaries": [toSlotSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceARN"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceARN"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceARN"]}`,
      responseCode: 200,
    });
    await resp.text();
  }

  async updateBot(
    {abortSignal, ...params}: RequestConfig & s.UpdateBotRequest,
  ): Promise<s.UpdateBotResponse> {
    const body: jsonP.JSONObject = {
      botName: params["botName"],
      description: params["description"],
      roleArn: params["roleArn"],
      dataPrivacy: fromDataPrivacy(params["dataPrivacy"]),
      idleSessionTTLInSeconds: params["idleSessionTTLInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBot",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botName": "s",
        "description": "s",
        "roleArn": "s",
        "dataPrivacy": toDataPrivacy,
        "idleSessionTTLInSeconds": "n",
        "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async updateBotAlias(
    {abortSignal, ...params}: RequestConfig & s.UpdateBotAliasRequest,
  ): Promise<s.UpdateBotAliasResponse> {
    const body: jsonP.JSONObject = {
      botAliasName: params["botAliasName"],
      description: params["description"],
      botVersion: params["botVersion"],
      botAliasLocaleSettings: jsonP.serializeMap(params["botAliasLocaleSettings"], x => fromBotAliasLocaleSettings(x)),
      conversationLogSettings: fromConversationLogSettings(params["conversationLogSettings"]),
      sentimentAnalysisSettings: fromSentimentAnalysisSettings(params["sentimentAnalysisSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBotAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botaliases/${params["botAliasId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botAliasId": "s",
        "botAliasName": "s",
        "description": "s",
        "botVersion": "s",
        "botAliasLocaleSettings": x => jsonP.readMap(String, toBotAliasLocaleSettings, x),
        "conversationLogSettings": toConversationLogSettings,
        "sentimentAnalysisSettings": toSentimentAnalysisSettings,
        "botAliasStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotAliasStatus>(x),
        "botId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async updateBotLocale(
    {abortSignal, ...params}: RequestConfig & s.UpdateBotLocaleRequest,
  ): Promise<s.UpdateBotLocaleResponse> {
    const body: jsonP.JSONObject = {
      description: params["description"],
      nluIntentConfidenceThreshold: params["nluIntentConfidenceThreshold"],
      voiceSettings: fromVoiceSettings(params["voiceSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBotLocale",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "localeName": "s",
        "description": "s",
        "nluIntentConfidenceThreshold": "n",
        "voiceSettings": toVoiceSettings,
        "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
        "failureReasons": ["s"],
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async updateIntent(
    {abortSignal, ...params}: RequestConfig & s.UpdateIntentRequest,
  ): Promise<s.UpdateIntentResponse> {
    const body: jsonP.JSONObject = {
      intentName: params["intentName"],
      description: params["description"],
      parentIntentSignature: params["parentIntentSignature"],
      sampleUtterances: params["sampleUtterances"]?.map(x => fromSampleUtterance(x)),
      dialogCodeHook: fromDialogCodeHookSettings(params["dialogCodeHook"]),
      fulfillmentCodeHook: fromFulfillmentCodeHookSettings(params["fulfillmentCodeHook"]),
      slotPriorities: params["slotPriorities"]?.map(x => fromSlotPriority(x)),
      intentConfirmationSetting: fromIntentConfirmationSetting(params["intentConfirmationSetting"]),
      intentClosingSetting: fromIntentClosingSetting(params["intentClosingSetting"]),
      inputContexts: params["inputContexts"]?.map(x => fromInputContext(x)),
      outputContexts: params["outputContexts"]?.map(x => fromOutputContext(x)),
      kendraConfiguration: fromKendraConfiguration(params["kendraConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIntent",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "intentId": "s",
        "intentName": "s",
        "description": "s",
        "parentIntentSignature": "s",
        "sampleUtterances": [toSampleUtterance],
        "dialogCodeHook": toDialogCodeHookSettings,
        "fulfillmentCodeHook": toFulfillmentCodeHookSettings,
        "slotPriorities": [toSlotPriority],
        "intentConfirmationSetting": toIntentConfirmationSetting,
        "intentClosingSetting": toIntentClosingSetting,
        "inputContexts": [toInputContext],
        "outputContexts": [toOutputContext],
        "kendraConfiguration": toKendraConfiguration,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async updateSlot(
    {abortSignal, ...params}: RequestConfig & s.UpdateSlotRequest,
  ): Promise<s.UpdateSlotResponse> {
    const body: jsonP.JSONObject = {
      slotName: params["slotName"],
      description: params["description"],
      slotTypeId: params["slotTypeId"],
      valueElicitationSetting: fromSlotValueElicitationSetting(params["valueElicitationSetting"]),
      obfuscationSetting: fromObfuscationSetting(params["obfuscationSetting"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSlot",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/intents/${params["intentId"]}/slots/${params["slotId"]}/`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotId": "s",
        "slotName": "s",
        "description": "s",
        "slotTypeId": "s",
        "valueElicitationSetting": toSlotValueElicitationSetting,
        "obfuscationSetting": toObfuscationSetting,
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "intentId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

  async updateSlotType(
    {abortSignal, ...params}: RequestConfig & s.UpdateSlotTypeRequest,
  ): Promise<s.UpdateSlotTypeResponse> {
    const body: jsonP.JSONObject = {
      slotTypeName: params["slotTypeName"],
      description: params["description"],
      slotTypeValues: params["slotTypeValues"]?.map(x => fromSlotTypeValue(x)),
      valueSelectionSetting: fromSlotValueSelectionSetting(params["valueSelectionSetting"]),
      parentSlotTypeSignature: params["parentSlotTypeSignature"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSlotType",
      method: "PUT",
      requestUri: cmnP.encodePath`/bots/${params["botId"]}/botversions/${params["botVersion"]}/botlocales/${params["localeId"]}/slottypes/${params["slotTypeId"]}/`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "slotTypeId": "s",
        "slotTypeName": "s",
        "description": "s",
        "slotTypeValues": [toSlotTypeValue],
        "valueSelectionSetting": toSlotValueSelectionSetting,
        "parentSlotTypeSignature": "s",
        "botId": "s",
        "botVersion": "s",
        "localeId": "s",
        "creationDateTime": "d",
        "lastUpdatedDateTime": "d",
      },
    }, await resp.json());
  }

}

function fromDataPrivacy(input?: s.DataPrivacy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    childDirected: input["childDirected"],
  }
}
function toDataPrivacy(root: jsonP.JSONValue): s.DataPrivacy {
  return jsonP.readObj({
    required: {
      "childDirected": "b",
    },
    optional: {},
  }, root);
}

function fromBotAliasLocaleSettings(input?: s.BotAliasLocaleSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    codeHookSpecification: fromCodeHookSpecification(input["codeHookSpecification"]),
  }
}
function toBotAliasLocaleSettings(root: jsonP.JSONValue): s.BotAliasLocaleSettings {
  return jsonP.readObj({
    required: {
      "enabled": "b",
    },
    optional: {
      "codeHookSpecification": toCodeHookSpecification,
    },
  }, root);
}

function fromCodeHookSpecification(input?: s.CodeHookSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lambdaCodeHook: fromLambdaCodeHook(input["lambdaCodeHook"]),
  }
}
function toCodeHookSpecification(root: jsonP.JSONValue): s.CodeHookSpecification {
  return jsonP.readObj({
    required: {
      "lambdaCodeHook": toLambdaCodeHook,
    },
    optional: {},
  }, root);
}

function fromLambdaCodeHook(input?: s.LambdaCodeHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lambdaARN: input["lambdaARN"],
    codeHookInterfaceVersion: input["codeHookInterfaceVersion"],
  }
}
function toLambdaCodeHook(root: jsonP.JSONValue): s.LambdaCodeHook {
  return jsonP.readObj({
    required: {
      "lambdaARN": "s",
      "codeHookInterfaceVersion": "s",
    },
    optional: {},
  }, root);
}

function fromConversationLogSettings(input?: s.ConversationLogSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    textLogSettings: input["textLogSettings"]?.map(x => fromTextLogSetting(x)),
    audioLogSettings: input["audioLogSettings"]?.map(x => fromAudioLogSetting(x)),
  }
}
function toConversationLogSettings(root: jsonP.JSONValue): s.ConversationLogSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "textLogSettings": [toTextLogSetting],
      "audioLogSettings": [toAudioLogSetting],
    },
  }, root);
}

function fromTextLogSetting(input?: s.TextLogSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    destination: fromTextLogDestination(input["destination"]),
  }
}
function toTextLogSetting(root: jsonP.JSONValue): s.TextLogSetting {
  return jsonP.readObj({
    required: {
      "enabled": "b",
      "destination": toTextLogDestination,
    },
    optional: {},
  }, root);
}

function fromTextLogDestination(input?: s.TextLogDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatch: fromCloudWatchLogGroupLogDestination(input["cloudWatch"]),
  }
}
function toTextLogDestination(root: jsonP.JSONValue): s.TextLogDestination {
  return jsonP.readObj({
    required: {
      "cloudWatch": toCloudWatchLogGroupLogDestination,
    },
    optional: {},
  }, root);
}

function fromCloudWatchLogGroupLogDestination(input?: s.CloudWatchLogGroupLogDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatchLogGroupArn: input["cloudWatchLogGroupArn"],
    logPrefix: input["logPrefix"],
  }
}
function toCloudWatchLogGroupLogDestination(root: jsonP.JSONValue): s.CloudWatchLogGroupLogDestination {
  return jsonP.readObj({
    required: {
      "cloudWatchLogGroupArn": "s",
      "logPrefix": "s",
    },
    optional: {},
  }, root);
}

function fromAudioLogSetting(input?: s.AudioLogSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
    destination: fromAudioLogDestination(input["destination"]),
  }
}
function toAudioLogSetting(root: jsonP.JSONValue): s.AudioLogSetting {
  return jsonP.readObj({
    required: {
      "enabled": "b",
      "destination": toAudioLogDestination,
    },
    optional: {},
  }, root);
}

function fromAudioLogDestination(input?: s.AudioLogDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3Bucket: fromS3BucketLogDestination(input["s3Bucket"]),
  }
}
function toAudioLogDestination(root: jsonP.JSONValue): s.AudioLogDestination {
  return jsonP.readObj({
    required: {
      "s3Bucket": toS3BucketLogDestination,
    },
    optional: {},
  }, root);
}

function fromS3BucketLogDestination(input?: s.S3BucketLogDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kmsKeyArn: input["kmsKeyArn"],
    s3BucketArn: input["s3BucketArn"],
    logPrefix: input["logPrefix"],
  }
}
function toS3BucketLogDestination(root: jsonP.JSONValue): s.S3BucketLogDestination {
  return jsonP.readObj({
    required: {
      "s3BucketArn": "s",
      "logPrefix": "s",
    },
    optional: {
      "kmsKeyArn": "s",
    },
  }, root);
}

function fromSentimentAnalysisSettings(input?: s.SentimentAnalysisSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    detectSentiment: input["detectSentiment"],
  }
}
function toSentimentAnalysisSettings(root: jsonP.JSONValue): s.SentimentAnalysisSettings {
  return jsonP.readObj({
    required: {
      "detectSentiment": "b",
    },
    optional: {},
  }, root);
}

function fromVoiceSettings(input?: s.VoiceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    voiceId: input["voiceId"],
  }
}
function toVoiceSettings(root: jsonP.JSONValue): s.VoiceSettings {
  return jsonP.readObj({
    required: {
      "voiceId": "s",
    },
    optional: {},
  }, root);
}

function fromBotVersionLocaleDetails(input?: s.BotVersionLocaleDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceBotVersion: input["sourceBotVersion"],
  }
}
function toBotVersionLocaleDetails(root: jsonP.JSONValue): s.BotVersionLocaleDetails {
  return jsonP.readObj({
    required: {
      "sourceBotVersion": "s",
    },
    optional: {},
  }, root);
}

function fromSampleUtterance(input?: s.SampleUtterance | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    utterance: input["utterance"],
  }
}
function toSampleUtterance(root: jsonP.JSONValue): s.SampleUtterance {
  return jsonP.readObj({
    required: {
      "utterance": "s",
    },
    optional: {},
  }, root);
}

function fromDialogCodeHookSettings(input?: s.DialogCodeHookSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
  }
}
function toDialogCodeHookSettings(root: jsonP.JSONValue): s.DialogCodeHookSettings {
  return jsonP.readObj({
    required: {
      "enabled": "b",
    },
    optional: {},
  }, root);
}

function fromFulfillmentCodeHookSettings(input?: s.FulfillmentCodeHookSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enabled: input["enabled"],
  }
}
function toFulfillmentCodeHookSettings(root: jsonP.JSONValue): s.FulfillmentCodeHookSettings {
  return jsonP.readObj({
    required: {
      "enabled": "b",
    },
    optional: {},
  }, root);
}

function fromIntentConfirmationSetting(input?: s.IntentConfirmationSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    promptSpecification: fromPromptSpecification(input["promptSpecification"]),
    declinationResponse: fromResponseSpecification(input["declinationResponse"]),
  }
}
function toIntentConfirmationSetting(root: jsonP.JSONValue): s.IntentConfirmationSetting {
  return jsonP.readObj({
    required: {
      "promptSpecification": toPromptSpecification,
      "declinationResponse": toResponseSpecification,
    },
    optional: {},
  }, root);
}

function fromPromptSpecification(input?: s.PromptSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageGroups: input["messageGroups"]?.map(x => fromMessageGroup(x)),
    maxRetries: input["maxRetries"],
    allowInterrupt: input["allowInterrupt"],
  }
}
function toPromptSpecification(root: jsonP.JSONValue): s.PromptSpecification {
  return jsonP.readObj({
    required: {
      "messageGroups": [toMessageGroup],
      "maxRetries": "n",
    },
    optional: {
      "allowInterrupt": "b",
    },
  }, root);
}

function fromMessageGroup(input?: s.MessageGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    message: fromMessage(input["message"]),
    variations: input["variations"]?.map(x => fromMessage(x)),
  }
}
function toMessageGroup(root: jsonP.JSONValue): s.MessageGroup {
  return jsonP.readObj({
    required: {
      "message": toMessage,
    },
    optional: {
      "variations": [toMessage],
    },
  }, root);
}

function fromMessage(input?: s.Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    plainTextMessage: fromPlainTextMessage(input["plainTextMessage"]),
    customPayload: fromCustomPayload(input["customPayload"]),
    ssmlMessage: fromSSMLMessage(input["ssmlMessage"]),
    imageResponseCard: fromImageResponseCard(input["imageResponseCard"]),
  }
}
function toMessage(root: jsonP.JSONValue): s.Message {
  return jsonP.readObj({
    required: {},
    optional: {
      "plainTextMessage": toPlainTextMessage,
      "customPayload": toCustomPayload,
      "ssmlMessage": toSSMLMessage,
      "imageResponseCard": toImageResponseCard,
    },
  }, root);
}

function fromPlainTextMessage(input?: s.PlainTextMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
  }
}
function toPlainTextMessage(root: jsonP.JSONValue): s.PlainTextMessage {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromCustomPayload(input?: s.CustomPayload | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
  }
}
function toCustomPayload(root: jsonP.JSONValue): s.CustomPayload {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromSSMLMessage(input?: s.SSMLMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
  }
}
function toSSMLMessage(root: jsonP.JSONValue): s.SSMLMessage {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromImageResponseCard(input?: s.ImageResponseCard | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    title: input["title"],
    subtitle: input["subtitle"],
    imageUrl: input["imageUrl"],
    buttons: input["buttons"]?.map(x => fromButton(x)),
  }
}
function toImageResponseCard(root: jsonP.JSONValue): s.ImageResponseCard {
  return jsonP.readObj({
    required: {
      "title": "s",
    },
    optional: {
      "subtitle": "s",
      "imageUrl": "s",
      "buttons": [toButton],
    },
  }, root);
}

function fromButton(input?: s.Button | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    text: input["text"],
    value: input["value"],
  }
}
function toButton(root: jsonP.JSONValue): s.Button {
  return jsonP.readObj({
    required: {
      "text": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromResponseSpecification(input?: s.ResponseSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageGroups: input["messageGroups"]?.map(x => fromMessageGroup(x)),
    allowInterrupt: input["allowInterrupt"],
  }
}
function toResponseSpecification(root: jsonP.JSONValue): s.ResponseSpecification {
  return jsonP.readObj({
    required: {
      "messageGroups": [toMessageGroup],
    },
    optional: {
      "allowInterrupt": "b",
    },
  }, root);
}

function fromIntentClosingSetting(input?: s.IntentClosingSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    closingResponse: fromResponseSpecification(input["closingResponse"]),
  }
}
function toIntentClosingSetting(root: jsonP.JSONValue): s.IntentClosingSetting {
  return jsonP.readObj({
    required: {
      "closingResponse": toResponseSpecification,
    },
    optional: {},
  }, root);
}

function fromInputContext(input?: s.InputContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toInputContext(root: jsonP.JSONValue): s.InputContext {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromOutputContext(input?: s.OutputContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    timeToLiveInSeconds: input["timeToLiveInSeconds"],
    turnsToLive: input["turnsToLive"],
  }
}
function toOutputContext(root: jsonP.JSONValue): s.OutputContext {
  return jsonP.readObj({
    required: {
      "name": "s",
      "timeToLiveInSeconds": "n",
      "turnsToLive": "n",
    },
    optional: {},
  }, root);
}

function fromKendraConfiguration(input?: s.KendraConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    kendraIndex: input["kendraIndex"],
    queryFilterStringEnabled: input["queryFilterStringEnabled"],
    queryFilterString: input["queryFilterString"],
  }
}
function toKendraConfiguration(root: jsonP.JSONValue): s.KendraConfiguration {
  return jsonP.readObj({
    required: {
      "kendraIndex": "s",
    },
    optional: {
      "queryFilterStringEnabled": "b",
      "queryFilterString": "s",
    },
  }, root);
}

function fromSlotValueElicitationSetting(input?: s.SlotValueElicitationSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultValueSpecification: fromSlotDefaultValueSpecification(input["defaultValueSpecification"]),
    slotConstraint: input["slotConstraint"],
    promptSpecification: fromPromptSpecification(input["promptSpecification"]),
    sampleUtterances: input["sampleUtterances"]?.map(x => fromSampleUtterance(x)),
    waitAndContinueSpecification: fromWaitAndContinueSpecification(input["waitAndContinueSpecification"]),
  }
}
function toSlotValueElicitationSetting(root: jsonP.JSONValue): s.SlotValueElicitationSetting {
  return jsonP.readObj({
    required: {
      "slotConstraint": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotConstraint>(x),
    },
    optional: {
      "defaultValueSpecification": toSlotDefaultValueSpecification,
      "promptSpecification": toPromptSpecification,
      "sampleUtterances": [toSampleUtterance],
      "waitAndContinueSpecification": toWaitAndContinueSpecification,
    },
  }, root);
}

function fromSlotDefaultValueSpecification(input?: s.SlotDefaultValueSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultValueList: input["defaultValueList"]?.map(x => fromSlotDefaultValue(x)),
  }
}
function toSlotDefaultValueSpecification(root: jsonP.JSONValue): s.SlotDefaultValueSpecification {
  return jsonP.readObj({
    required: {
      "defaultValueList": [toSlotDefaultValue],
    },
    optional: {},
  }, root);
}

function fromSlotDefaultValue(input?: s.SlotDefaultValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    defaultValue: input["defaultValue"],
  }
}
function toSlotDefaultValue(root: jsonP.JSONValue): s.SlotDefaultValue {
  return jsonP.readObj({
    required: {
      "defaultValue": "s",
    },
    optional: {},
  }, root);
}

function fromWaitAndContinueSpecification(input?: s.WaitAndContinueSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    waitingResponse: fromResponseSpecification(input["waitingResponse"]),
    continueResponse: fromResponseSpecification(input["continueResponse"]),
    stillWaitingResponse: fromStillWaitingResponseSpecification(input["stillWaitingResponse"]),
  }
}
function toWaitAndContinueSpecification(root: jsonP.JSONValue): s.WaitAndContinueSpecification {
  return jsonP.readObj({
    required: {
      "waitingResponse": toResponseSpecification,
      "continueResponse": toResponseSpecification,
    },
    optional: {
      "stillWaitingResponse": toStillWaitingResponseSpecification,
    },
  }, root);
}

function fromStillWaitingResponseSpecification(input?: s.StillWaitingResponseSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    messageGroups: input["messageGroups"]?.map(x => fromMessageGroup(x)),
    frequencyInSeconds: input["frequencyInSeconds"],
    timeoutInSeconds: input["timeoutInSeconds"],
    allowInterrupt: input["allowInterrupt"],
  }
}
function toStillWaitingResponseSpecification(root: jsonP.JSONValue): s.StillWaitingResponseSpecification {
  return jsonP.readObj({
    required: {
      "messageGroups": [toMessageGroup],
      "frequencyInSeconds": "n",
      "timeoutInSeconds": "n",
    },
    optional: {
      "allowInterrupt": "b",
    },
  }, root);
}

function fromObfuscationSetting(input?: s.ObfuscationSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    obfuscationSettingType: input["obfuscationSettingType"],
  }
}
function toObfuscationSetting(root: jsonP.JSONValue): s.ObfuscationSetting {
  return jsonP.readObj({
    required: {
      "obfuscationSettingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObfuscationSettingType>(x),
    },
    optional: {},
  }, root);
}

function fromSlotTypeValue(input?: s.SlotTypeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sampleValue: fromSampleValue(input["sampleValue"]),
    synonyms: input["synonyms"]?.map(x => fromSampleValue(x)),
  }
}
function toSlotTypeValue(root: jsonP.JSONValue): s.SlotTypeValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "sampleValue": toSampleValue,
      "synonyms": [toSampleValue],
    },
  }, root);
}

function fromSampleValue(input?: s.SampleValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    value: input["value"],
  }
}
function toSampleValue(root: jsonP.JSONValue): s.SampleValue {
  return jsonP.readObj({
    required: {
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromSlotValueSelectionSetting(input?: s.SlotValueSelectionSetting | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    resolutionStrategy: input["resolutionStrategy"],
    regexFilter: fromSlotValueRegexFilter(input["regexFilter"]),
  }
}
function toSlotValueSelectionSetting(root: jsonP.JSONValue): s.SlotValueSelectionSetting {
  return jsonP.readObj({
    required: {
      "resolutionStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotValueResolutionStrategy>(x),
    },
    optional: {
      "regexFilter": toSlotValueRegexFilter,
    },
  }, root);
}

function fromSlotValueRegexFilter(input?: s.SlotValueRegexFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pattern: input["pattern"],
  }
}
function toSlotValueRegexFilter(root: jsonP.JSONValue): s.SlotValueRegexFilter {
  return jsonP.readObj({
    required: {
      "pattern": "s",
    },
    optional: {},
  }, root);
}

function fromBotLocaleSortBy(input?: s.BotLocaleSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromBotLocaleFilter(input?: s.BotLocaleFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    operator: input["operator"],
  }
}

function fromBotVersionSortBy(input?: s.BotVersionSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromBotSortBy(input?: s.BotSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromBotFilter(input?: s.BotFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    operator: input["operator"],
  }
}

function fromBuiltInIntentSortBy(input?: s.BuiltInIntentSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromBuiltInSlotTypeSortBy(input?: s.BuiltInSlotTypeSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromIntentSortBy(input?: s.IntentSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromIntentFilter(input?: s.IntentFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    operator: input["operator"],
  }
}

function fromSlotTypeSortBy(input?: s.SlotTypeSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromSlotTypeFilter(input?: s.SlotTypeFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    operator: input["operator"],
  }
}

function fromSlotSortBy(input?: s.SlotSortBy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attribute: input["attribute"],
    order: input["order"],
  }
}

function fromSlotFilter(input?: s.SlotFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
    operator: input["operator"],
  }
}

function fromSlotPriority(input?: s.SlotPriority | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    priority: input["priority"],
    slotId: input["slotId"],
  }
}
function toSlotPriority(root: jsonP.JSONValue): s.SlotPriority {
  return jsonP.readObj({
    required: {
      "priority": "n",
      "slotId": "s",
    },
    optional: {},
  }, root);
}

function toBotAliasHistoryEvent(root: jsonP.JSONValue): s.BotAliasHistoryEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "botVersion": "s",
      "startDate": "d",
      "endDate": "d",
    },
  }, root);
}

function toBotLocaleHistoryEvent(root: jsonP.JSONValue): s.BotLocaleHistoryEvent {
  return jsonP.readObj({
    required: {
      "event": "s",
      "eventDate": "d",
    },
    optional: {},
  }, root);
}

function toBotAliasSummary(root: jsonP.JSONValue): s.BotAliasSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "botAliasId": "s",
      "botAliasName": "s",
      "description": "s",
      "botVersion": "s",
      "botAliasStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotAliasStatus>(x),
      "creationDateTime": "d",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toBotLocaleSummary(root: jsonP.JSONValue): s.BotLocaleSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "localeId": "s",
      "localeName": "s",
      "description": "s",
      "botLocaleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotLocaleStatus>(x),
      "lastUpdatedDateTime": "d",
      "lastBuildSubmittedDateTime": "d",
    },
  }, root);
}

function toBotVersionSummary(root: jsonP.JSONValue): s.BotVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "botName": "s",
      "botVersion": "s",
      "description": "s",
      "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
      "creationDateTime": "d",
    },
  }, root);
}

function toBotSummary(root: jsonP.JSONValue): s.BotSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "botId": "s",
      "botName": "s",
      "description": "s",
      "botStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BotStatus>(x),
      "latestBotVersion": "s",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toBuiltInIntentSummary(root: jsonP.JSONValue): s.BuiltInIntentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "intentSignature": "s",
      "description": "s",
    },
  }, root);
}

function toBuiltInSlotTypeSummary(root: jsonP.JSONValue): s.BuiltInSlotTypeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "slotTypeSignature": "s",
      "description": "s",
    },
  }, root);
}

function toIntentSummary(root: jsonP.JSONValue): s.IntentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "intentId": "s",
      "intentName": "s",
      "description": "s",
      "parentIntentSignature": "s",
      "inputContexts": [toInputContext],
      "outputContexts": [toOutputContext],
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toSlotTypeSummary(root: jsonP.JSONValue): s.SlotTypeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "slotTypeId": "s",
      "slotTypeName": "s",
      "description": "s",
      "parentSlotTypeSignature": "s",
      "lastUpdatedDateTime": "d",
    },
  }, root);
}

function toSlotSummary(root: jsonP.JSONValue): s.SlotSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "slotId": "s",
      "slotName": "s",
      "description": "s",
      "slotConstraint": (x: jsonP.JSONValue) => cmnP.readEnum<s.SlotConstraint>(x),
      "slotTypeId": "s",
      "valueElicitationPromptSpecification": toPromptSpecification,
      "lastUpdatedDateTime": "d",
    },
  }, root);
}
