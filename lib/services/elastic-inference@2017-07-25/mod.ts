// Autogenerated API client for: Amazon Elastic  Inference

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class ElasticInference {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElasticInference.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-07-25",
    "endpointPrefix": "api.elastic-inference",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "Amazon Elastic Inference",
    "serviceFullName": "Amazon Elastic  Inference",
    "serviceId": "Elastic Inference",
    "signatureVersion": "v4",
    "signingName": "elastic-inference",
    "uid": "elastic-inference-2017-07-25"
  };

  async describeAcceleratorOfferings(
    {abortSignal, ...params}: RequestConfig & DescribeAcceleratorOfferingsRequest,
  ): Promise<DescribeAcceleratorOfferingsResponse> {
    const body: jsonP.JSONObject = {
      locationType: params["locationType"],
      acceleratorTypes: params["acceleratorTypes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAcceleratorOfferings",
      requestUri: "/describe-accelerator-offerings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acceleratorTypeOfferings": [toAcceleratorTypeOffering],
      },
    }, await resp.json());
  }

  async describeAcceleratorTypes(
    {abortSignal, ...params}: RequestConfig & DescribeAcceleratorTypesRequest = {},
  ): Promise<DescribeAcceleratorTypesResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAcceleratorTypes",
      method: "GET",
      requestUri: "/describe-accelerator-types",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acceleratorTypes": [toAcceleratorType],
      },
    }, await resp.json());
  }

  async describeAccelerators(
    {abortSignal, ...params}: RequestConfig & DescribeAcceleratorsRequest = {},
  ): Promise<DescribeAcceleratorsResponse> {
    const body: jsonP.JSONObject = {
      acceleratorIds: params["acceleratorIds"],
      filters: params["filters"]?.map(x => fromFilter(x)),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAccelerators",
      requestUri: "/describe-accelerators",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "acceleratorSet": [toElasticInferenceAccelerator],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResult> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResult> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface DescribeAcceleratorOfferingsRequest {
  locationType: LocationType;
  acceleratorTypes?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeAcceleratorTypesRequest {
}

// refs: 1 - tags: named, input
export interface DescribeAcceleratorsRequest {
  acceleratorIds?: string[] | null;
  filters?: Filter[] | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface DescribeAcceleratorOfferingsResponse {
  acceleratorTypeOfferings?: AcceleratorTypeOffering[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeAcceleratorTypesResponse {
  acceleratorTypes?: AcceleratorType[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeAcceleratorsResponse {
  acceleratorSet?: ElasticInferenceAccelerator[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResult {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResult {
}

// refs: 1 - tags: named, output
export interface UntagResourceResult {
}

// refs: 2 - tags: input, named, enum, output
export type LocationType =
| "region"
| "availability-zone"
| "availability-zone-id"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface Filter {
  name?: string | null;
  values?: string[] | null;
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    values: input["values"],
  }
}

// refs: 1 - tags: output, named, interface
export interface AcceleratorTypeOffering {
  acceleratorType?: string | null;
  locationType?: LocationType | null;
  location?: string | null;
}
function toAcceleratorTypeOffering(root: jsonP.JSONValue): AcceleratorTypeOffering {
  return jsonP.readObj({
    required: {},
    optional: {
      "acceleratorType": "s",
      "locationType": (x: jsonP.JSONValue) => cmnP.readEnum<LocationType>(x),
      "location": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AcceleratorType {
  acceleratorTypeName?: string | null;
  memoryInfo?: MemoryInfo | null;
  throughputInfo?: KeyValuePair[] | null;
}
function toAcceleratorType(root: jsonP.JSONValue): AcceleratorType {
  return jsonP.readObj({
    required: {},
    optional: {
      "acceleratorTypeName": "s",
      "memoryInfo": toMemoryInfo,
      "throughputInfo": [toKeyValuePair],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MemoryInfo {
  sizeInMiB?: number | null;
}
function toMemoryInfo(root: jsonP.JSONValue): MemoryInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "sizeInMiB": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface KeyValuePair {
  key?: string | null;
  value?: number | null;
}
function toKeyValuePair(root: jsonP.JSONValue): KeyValuePair {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElasticInferenceAccelerator {
  acceleratorHealth?: ElasticInferenceAcceleratorHealth | null;
  acceleratorType?: string | null;
  acceleratorId?: string | null;
  availabilityZone?: string | null;
  attachedResource?: string | null;
}
function toElasticInferenceAccelerator(root: jsonP.JSONValue): ElasticInferenceAccelerator {
  return jsonP.readObj({
    required: {},
    optional: {
      "acceleratorHealth": toElasticInferenceAcceleratorHealth,
      "acceleratorType": "s",
      "acceleratorId": "s",
      "availabilityZone": "s",
      "attachedResource": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ElasticInferenceAcceleratorHealth {
  status?: string | null;
}
function toElasticInferenceAcceleratorHealth(root: jsonP.JSONValue): ElasticInferenceAcceleratorHealth {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": "s",
    },
  }, root);
}
