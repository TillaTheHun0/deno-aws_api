// Autogenerated API client for: AWS App Mesh

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class AppMesh {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AppMesh.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-01-25",
    "endpointPrefix": "appmesh",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS App Mesh",
    "serviceId": "App Mesh",
    "signatureVersion": "v4",
    "signingName": "appmesh",
    "uid": "appmesh-2019-01-25"
  };

  async createGatewayRoute(
    {abortSignal, ...params}: RequestConfig & CreateGatewayRouteInput,
  ): Promise<CreateGatewayRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      gatewayRouteName: params["gatewayRouteName"],
      spec: fromGatewayRouteSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateGatewayRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async createMesh(
    {abortSignal, ...params}: RequestConfig & CreateMeshInput,
  ): Promise<CreateMeshOutput> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      meshName: params["meshName"],
      spec: fromMeshSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMesh",
      method: "PUT",
      requestUri: "/v20190125/meshes",
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async createRoute(
    {abortSignal, ...params}: RequestConfig & CreateRouteInput,
  ): Promise<CreateRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      routeName: params["routeName"],
      spec: fromRouteSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async createVirtualGateway(
    {abortSignal, ...params}: RequestConfig & CreateVirtualGatewayInput,
  ): Promise<CreateVirtualGatewayOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualGatewaySpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualGatewayName: params["virtualGatewayName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualGateway",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async createVirtualNode(
    {abortSignal, ...params}: RequestConfig & CreateVirtualNodeInput,
  ): Promise<CreateVirtualNodeOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualNodeSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualNodeName: params["virtualNodeName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualNode",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async createVirtualRouter(
    {abortSignal, ...params}: RequestConfig & CreateVirtualRouterInput,
  ): Promise<CreateVirtualRouterOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualRouterSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualRouterName: params["virtualRouterName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualRouter",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async createVirtualService(
    {abortSignal, ...params}: RequestConfig & CreateVirtualServiceInput,
  ): Promise<CreateVirtualServiceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualServiceSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualServiceName: params["virtualServiceName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualService",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async deleteGatewayRoute(
    {abortSignal, ...params}: RequestConfig & DeleteGatewayRouteInput,
  ): Promise<DeleteGatewayRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteGatewayRoute",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async deleteMesh(
    {abortSignal, ...params}: RequestConfig & DeleteMeshInput,
  ): Promise<DeleteMeshOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMesh",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async deleteRoute(
    {abortSignal, ...params}: RequestConfig & DeleteRouteInput,
  ): Promise<DeleteRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRoute",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async deleteVirtualGateway(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualGatewayInput,
  ): Promise<DeleteVirtualGatewayOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualGateway",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async deleteVirtualNode(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualNodeInput,
  ): Promise<DeleteVirtualNodeOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualNode",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async deleteVirtualRouter(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualRouterInput,
  ): Promise<DeleteVirtualRouterOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualRouter",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async deleteVirtualService(
    {abortSignal, ...params}: RequestConfig & DeleteVirtualServiceInput,
  ): Promise<DeleteVirtualServiceOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualService",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async describeGatewayRoute(
    {abortSignal, ...params}: RequestConfig & DescribeGatewayRouteInput,
  ): Promise<DescribeGatewayRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeGatewayRoute",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async describeMesh(
    {abortSignal, ...params}: RequestConfig & DescribeMeshInput,
  ): Promise<DescribeMeshOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeMesh",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async describeRoute(
    {abortSignal, ...params}: RequestConfig & DescribeRouteInput,
  ): Promise<DescribeRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRoute",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async describeVirtualGateway(
    {abortSignal, ...params}: RequestConfig & DescribeVirtualGatewayInput,
  ): Promise<DescribeVirtualGatewayOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualGateway",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async describeVirtualNode(
    {abortSignal, ...params}: RequestConfig & DescribeVirtualNodeInput,
  ): Promise<DescribeVirtualNodeOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualNode",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async describeVirtualRouter(
    {abortSignal, ...params}: RequestConfig & DescribeVirtualRouterInput,
  ): Promise<DescribeVirtualRouterOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualRouter",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async describeVirtualService(
    {abortSignal, ...params}: RequestConfig & DescribeVirtualServiceInput,
  ): Promise<DescribeVirtualServiceOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualService",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async listGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & ListGatewayRoutesInput,
  ): Promise<ListGatewayRoutesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGatewayRoutes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "gatewayRoutes": [toGatewayRouteRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listMeshes(
    {abortSignal, ...params}: RequestConfig & ListMeshesInput = {},
  ): Promise<ListMeshesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMeshes",
      method: "GET",
      requestUri: "/v20190125/meshes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "meshes": [toMeshRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRoutes(
    {abortSignal, ...params}: RequestConfig & ListRoutesInput,
  ): Promise<ListRoutesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRoutes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "routes": [toRouteRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceInput,
  ): Promise<ListTagsForResourceOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: "/v20190125/tags",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "tags": [toTagRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualGateways(
    {abortSignal, ...params}: RequestConfig & ListVirtualGatewaysInput,
  ): Promise<ListVirtualGatewaysOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualGateways",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualGateways": [toVirtualGatewayRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualNodes(
    {abortSignal, ...params}: RequestConfig & ListVirtualNodesInput,
  ): Promise<ListVirtualNodesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualNodes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualNodes": [toVirtualNodeRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualRouters(
    {abortSignal, ...params}: RequestConfig & ListVirtualRoutersInput,
  ): Promise<ListVirtualRoutersOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualRouters",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualRouters": [toVirtualRouterRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualServices(
    {abortSignal, ...params}: RequestConfig & ListVirtualServicesInput,
  ): Promise<ListVirtualServicesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualServices",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualServices": [toVirtualServiceRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceInput,
  ): Promise<TagResourceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource",
      method: "PUT",
      requestUri: "/v20190125/tag",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceInput,
  ): Promise<UntagResourceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tagKeys: params["tagKeys"],
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: "/v20190125/untag",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateGatewayRoute(
    {abortSignal, ...params}: RequestConfig & UpdateGatewayRouteInput,
  ): Promise<UpdateGatewayRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromGatewayRouteSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateGatewayRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async updateMesh(
    {abortSignal, ...params}: RequestConfig & UpdateMeshInput,
  ): Promise<UpdateMeshOutput> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromMeshSpec(params["spec"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMesh",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async updateRoute(
    {abortSignal, ...params}: RequestConfig & UpdateRouteInput,
  ): Promise<UpdateRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromRouteSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async updateVirtualGateway(
    {abortSignal, ...params}: RequestConfig & UpdateVirtualGatewayInput,
  ): Promise<UpdateVirtualGatewayOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualGatewaySpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualGateway",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async updateVirtualNode(
    {abortSignal, ...params}: RequestConfig & UpdateVirtualNodeInput,
  ): Promise<UpdateVirtualNodeOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualNodeSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualNode",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async updateVirtualRouter(
    {abortSignal, ...params}: RequestConfig & UpdateVirtualRouterInput,
  ): Promise<UpdateVirtualRouterOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualRouterSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualRouter",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async updateVirtualService(
    {abortSignal, ...params}: RequestConfig & UpdateVirtualServiceInput,
  ): Promise<UpdateVirtualServiceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualServiceSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualService",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface CreateGatewayRouteInput {
  clientToken?: string | null;
  gatewayRouteName: string;
  meshName: string;
  meshOwner?: string | null;
  spec: GatewayRouteSpec;
  tags?: TagRef[] | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface CreateMeshInput {
  clientToken?: string | null;
  meshName: string;
  spec?: MeshSpec | null;
  tags?: TagRef[] | null;
}

// refs: 1 - tags: named, input
export interface CreateRouteInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  routeName: string;
  spec: RouteSpec;
  tags?: TagRef[] | null;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface CreateVirtualGatewayInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualGatewaySpec;
  tags?: TagRef[] | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface CreateVirtualNodeInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualNodeSpec;
  tags?: TagRef[] | null;
  virtualNodeName: string;
}

// refs: 1 - tags: named, input
export interface CreateVirtualRouterInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualRouterSpec;
  tags?: TagRef[] | null;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface CreateVirtualServiceInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualServiceSpec;
  tags?: TagRef[] | null;
  virtualServiceName: string;
}

// refs: 1 - tags: named, input
export interface DeleteGatewayRouteInput {
  gatewayRouteName: string;
  meshName: string;
  meshOwner?: string | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface DeleteMeshInput {
  meshName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRouteInput {
  meshName: string;
  meshOwner?: string | null;
  routeName: string;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualGatewayInput {
  meshName: string;
  meshOwner?: string | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualNodeInput {
  meshName: string;
  meshOwner?: string | null;
  virtualNodeName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualRouterInput {
  meshName: string;
  meshOwner?: string | null;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface DeleteVirtualServiceInput {
  meshName: string;
  meshOwner?: string | null;
  virtualServiceName: string;
}

// refs: 1 - tags: named, input
export interface DescribeGatewayRouteInput {
  gatewayRouteName: string;
  meshName: string;
  meshOwner?: string | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface DescribeMeshInput {
  meshName: string;
  meshOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeRouteInput {
  meshName: string;
  meshOwner?: string | null;
  routeName: string;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface DescribeVirtualGatewayInput {
  meshName: string;
  meshOwner?: string | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface DescribeVirtualNodeInput {
  meshName: string;
  meshOwner?: string | null;
  virtualNodeName: string;
}

// refs: 1 - tags: named, input
export interface DescribeVirtualRouterInput {
  meshName: string;
  meshOwner?: string | null;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface DescribeVirtualServiceInput {
  meshName: string;
  meshOwner?: string | null;
  virtualServiceName: string;
}

// refs: 1 - tags: named, input
export interface ListGatewayRoutesInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface ListMeshesInput {
  limit?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListRoutesInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceInput {
  limit?: number | null;
  nextToken?: string | null;
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListVirtualGatewaysInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListVirtualNodesInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListVirtualRoutersInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListVirtualServicesInput {
  limit?: number | null;
  meshName: string;
  meshOwner?: string | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceInput {
  resourceArn: string;
  tags: TagRef[];
}

// refs: 1 - tags: named, input
export interface UntagResourceInput {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateGatewayRouteInput {
  clientToken?: string | null;
  gatewayRouteName: string;
  meshName: string;
  meshOwner?: string | null;
  spec: GatewayRouteSpec;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface UpdateMeshInput {
  clientToken?: string | null;
  meshName: string;
  spec?: MeshSpec | null;
}

// refs: 1 - tags: named, input
export interface UpdateRouteInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  routeName: string;
  spec: RouteSpec;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface UpdateVirtualGatewayInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualGatewaySpec;
  virtualGatewayName: string;
}

// refs: 1 - tags: named, input
export interface UpdateVirtualNodeInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualNodeSpec;
  virtualNodeName: string;
}

// refs: 1 - tags: named, input
export interface UpdateVirtualRouterInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualRouterSpec;
  virtualRouterName: string;
}

// refs: 1 - tags: named, input
export interface UpdateVirtualServiceInput {
  clientToken?: string | null;
  meshName: string;
  meshOwner?: string | null;
  spec: VirtualServiceSpec;
  virtualServiceName: string;
}

// refs: 1 - tags: named, output
export interface CreateGatewayRouteOutput {
  gatewayRoute: GatewayRouteData;
}

// refs: 1 - tags: named, output
export interface CreateMeshOutput {
  mesh: MeshData;
}

// refs: 1 - tags: named, output
export interface CreateRouteOutput {
  route: RouteData;
}

// refs: 1 - tags: named, output
export interface CreateVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData;
}

// refs: 1 - tags: named, output
export interface CreateVirtualNodeOutput {
  virtualNode: VirtualNodeData;
}

// refs: 1 - tags: named, output
export interface CreateVirtualRouterOutput {
  virtualRouter: VirtualRouterData;
}

// refs: 1 - tags: named, output
export interface CreateVirtualServiceOutput {
  virtualService: VirtualServiceData;
}

// refs: 1 - tags: named, output
export interface DeleteGatewayRouteOutput {
  gatewayRoute: GatewayRouteData;
}

// refs: 1 - tags: named, output
export interface DeleteMeshOutput {
  mesh: MeshData;
}

// refs: 1 - tags: named, output
export interface DeleteRouteOutput {
  route: RouteData;
}

// refs: 1 - tags: named, output
export interface DeleteVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData;
}

// refs: 1 - tags: named, output
export interface DeleteVirtualNodeOutput {
  virtualNode: VirtualNodeData;
}

// refs: 1 - tags: named, output
export interface DeleteVirtualRouterOutput {
  virtualRouter: VirtualRouterData;
}

// refs: 1 - tags: named, output
export interface DeleteVirtualServiceOutput {
  virtualService: VirtualServiceData;
}

// refs: 1 - tags: named, output
export interface DescribeGatewayRouteOutput {
  gatewayRoute: GatewayRouteData;
}

// refs: 1 - tags: named, output
export interface DescribeMeshOutput {
  mesh: MeshData;
}

// refs: 1 - tags: named, output
export interface DescribeRouteOutput {
  route: RouteData;
}

// refs: 1 - tags: named, output
export interface DescribeVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData;
}

// refs: 1 - tags: named, output
export interface DescribeVirtualNodeOutput {
  virtualNode: VirtualNodeData;
}

// refs: 1 - tags: named, output
export interface DescribeVirtualRouterOutput {
  virtualRouter: VirtualRouterData;
}

// refs: 1 - tags: named, output
export interface DescribeVirtualServiceOutput {
  virtualService: VirtualServiceData;
}

// refs: 1 - tags: named, output
export interface ListGatewayRoutesOutput {
  gatewayRoutes: GatewayRouteRef[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMeshesOutput {
  meshes: MeshRef[];
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRoutesOutput {
  nextToken?: string | null;
  routes: RouteRef[];
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceOutput {
  nextToken?: string | null;
  tags: TagRef[];
}

// refs: 1 - tags: named, output
export interface ListVirtualGatewaysOutput {
  nextToken?: string | null;
  virtualGateways: VirtualGatewayRef[];
}

// refs: 1 - tags: named, output
export interface ListVirtualNodesOutput {
  nextToken?: string | null;
  virtualNodes: VirtualNodeRef[];
}

// refs: 1 - tags: named, output
export interface ListVirtualRoutersOutput {
  nextToken?: string | null;
  virtualRouters: VirtualRouterRef[];
}

// refs: 1 - tags: named, output
export interface ListVirtualServicesOutput {
  nextToken?: string | null;
  virtualServices: VirtualServiceRef[];
}

// refs: 1 - tags: named, output
export interface TagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UntagResourceOutput {
}

// refs: 1 - tags: named, output
export interface UpdateGatewayRouteOutput {
  gatewayRoute: GatewayRouteData;
}

// refs: 1 - tags: named, output
export interface UpdateMeshOutput {
  mesh: MeshData;
}

// refs: 1 - tags: named, output
export interface UpdateRouteOutput {
  route: RouteData;
}

// refs: 1 - tags: named, output
export interface UpdateVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData;
}

// refs: 1 - tags: named, output
export interface UpdateVirtualNodeOutput {
  virtualNode: VirtualNodeData;
}

// refs: 1 - tags: named, output
export interface UpdateVirtualRouterOutput {
  virtualRouter: VirtualRouterData;
}

// refs: 1 - tags: named, output
export interface UpdateVirtualServiceOutput {
  virtualService: VirtualServiceData;
}

// refs: 6 - tags: input, named, interface, output
export interface GatewayRouteSpec {
  grpcRoute?: GrpcGatewayRoute | null;
  http2Route?: HttpGatewayRoute | null;
  httpRoute?: HttpGatewayRoute | null;
}
function fromGatewayRouteSpec(input?: GatewayRouteSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRoute: fromGrpcGatewayRoute(input["grpcRoute"]),
    http2Route: fromHttpGatewayRoute(input["http2Route"]),
    httpRoute: fromHttpGatewayRoute(input["httpRoute"]),
  }
}
function toGatewayRouteSpec(root: jsonP.JSONValue): GatewayRouteSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpcRoute": toGrpcGatewayRoute,
      "http2Route": toHttpGatewayRoute,
      "httpRoute": toHttpGatewayRoute,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcGatewayRoute {
  action: GrpcGatewayRouteAction;
  match: GrpcGatewayRouteMatch;
}
function fromGrpcGatewayRoute(input?: GrpcGatewayRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromGrpcGatewayRouteAction(input["action"]),
    match: fromGrpcGatewayRouteMatch(input["match"]),
  }
}
function toGrpcGatewayRoute(root: jsonP.JSONValue): GrpcGatewayRoute {
  return jsonP.readObj({
    required: {
      "action": toGrpcGatewayRouteAction,
      "match": toGrpcGatewayRouteMatch,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcGatewayRouteAction {
  target: GatewayRouteTarget;
}
function fromGrpcGatewayRouteAction(input?: GrpcGatewayRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    target: fromGatewayRouteTarget(input["target"]),
  }
}
function toGrpcGatewayRouteAction(root: jsonP.JSONValue): GrpcGatewayRouteAction {
  return jsonP.readObj({
    required: {
      "target": toGatewayRouteTarget,
    },
    optional: {},
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface GatewayRouteTarget {
  virtualService: GatewayRouteVirtualService;
}
function fromGatewayRouteTarget(input?: GatewayRouteTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualService: fromGatewayRouteVirtualService(input["virtualService"]),
  }
}
function toGatewayRouteTarget(root: jsonP.JSONValue): GatewayRouteTarget {
  return jsonP.readObj({
    required: {
      "virtualService": toGatewayRouteVirtualService,
    },
    optional: {},
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface GatewayRouteVirtualService {
  virtualServiceName: string;
}
function fromGatewayRouteVirtualService(input?: GatewayRouteVirtualService | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualServiceName: input["virtualServiceName"],
  }
}
function toGatewayRouteVirtualService(root: jsonP.JSONValue): GatewayRouteVirtualService {
  return jsonP.readObj({
    required: {
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcGatewayRouteMatch {
  serviceName?: string | null;
}
function fromGrpcGatewayRouteMatch(input?: GrpcGatewayRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceName: input["serviceName"],
  }
}
function toGrpcGatewayRouteMatch(root: jsonP.JSONValue): GrpcGatewayRouteMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceName": "s",
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpGatewayRoute {
  action: HttpGatewayRouteAction;
  match: HttpGatewayRouteMatch;
}
function fromHttpGatewayRoute(input?: HttpGatewayRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromHttpGatewayRouteAction(input["action"]),
    match: fromHttpGatewayRouteMatch(input["match"]),
  }
}
function toHttpGatewayRoute(root: jsonP.JSONValue): HttpGatewayRoute {
  return jsonP.readObj({
    required: {
      "action": toHttpGatewayRouteAction,
      "match": toHttpGatewayRouteMatch,
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpGatewayRouteAction {
  target: GatewayRouteTarget;
}
function fromHttpGatewayRouteAction(input?: HttpGatewayRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    target: fromGatewayRouteTarget(input["target"]),
  }
}
function toHttpGatewayRouteAction(root: jsonP.JSONValue): HttpGatewayRouteAction {
  return jsonP.readObj({
    required: {
      "target": toGatewayRouteTarget,
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpGatewayRouteMatch {
  prefix: string;
}
function fromHttpGatewayRouteMatch(input?: HttpGatewayRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prefix: input["prefix"],
  }
}
function toHttpGatewayRouteMatch(root: jsonP.JSONValue): HttpGatewayRouteMatch {
  return jsonP.readObj({
    required: {
      "prefix": "s",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface TagRef {
  key: string;
  value?: string | null;
}
function fromTagRef(input?: TagRef | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTagRef(root: jsonP.JSONValue): TagRef {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "value": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MeshSpec {
  egressFilter?: EgressFilter | null;
}
function fromMeshSpec(input?: MeshSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    egressFilter: fromEgressFilter(input["egressFilter"]),
  }
}
function toMeshSpec(root: jsonP.JSONValue): MeshSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "egressFilter": toEgressFilter,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface EgressFilter {
  type: EgressFilterType;
}
function fromEgressFilter(input?: EgressFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
  }
}
function toEgressFilter(root: jsonP.JSONValue): EgressFilter {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<EgressFilterType>(x),
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type EgressFilterType =
| "ALLOW_ALL"
| "DROP_ALL"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface RouteSpec {
  grpcRoute?: GrpcRoute | null;
  http2Route?: HttpRoute | null;
  httpRoute?: HttpRoute | null;
  priority?: number | null;
  tcpRoute?: TcpRoute | null;
}
function fromRouteSpec(input?: RouteSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRoute: fromGrpcRoute(input["grpcRoute"]),
    http2Route: fromHttpRoute(input["http2Route"]),
    httpRoute: fromHttpRoute(input["httpRoute"]),
    priority: input["priority"],
    tcpRoute: fromTcpRoute(input["tcpRoute"]),
  }
}
function toRouteSpec(root: jsonP.JSONValue): RouteSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpcRoute": toGrpcRoute,
      "http2Route": toHttpRoute,
      "httpRoute": toHttpRoute,
      "priority": "n",
      "tcpRoute": toTcpRoute,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRoute {
  action: GrpcRouteAction;
  match: GrpcRouteMatch;
  retryPolicy?: GrpcRetryPolicy | null;
  timeout?: GrpcTimeout | null;
}
function fromGrpcRoute(input?: GrpcRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromGrpcRouteAction(input["action"]),
    match: fromGrpcRouteMatch(input["match"]),
    retryPolicy: fromGrpcRetryPolicy(input["retryPolicy"]),
    timeout: fromGrpcTimeout(input["timeout"]),
  }
}
function toGrpcRoute(root: jsonP.JSONValue): GrpcRoute {
  return jsonP.readObj({
    required: {
      "action": toGrpcRouteAction,
      "match": toGrpcRouteMatch,
    },
    optional: {
      "retryPolicy": toGrpcRetryPolicy,
      "timeout": toGrpcTimeout,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRouteAction {
  weightedTargets: WeightedTarget[];
}
function fromGrpcRouteAction(input?: GrpcRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toGrpcRouteAction(root: jsonP.JSONValue): GrpcRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

// refs: 24 - tags: input, named, interface, output
export interface WeightedTarget {
  virtualNode: string;
  weight: number;
}
function fromWeightedTarget(input?: WeightedTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNode: input["virtualNode"],
    weight: input["weight"],
  }
}
function toWeightedTarget(root: jsonP.JSONValue): WeightedTarget {
  return jsonP.readObj({
    required: {
      "virtualNode": "s",
      "weight": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRouteMatch {
  metadata?: GrpcRouteMetadata[] | null;
  methodName?: string | null;
  serviceName?: string | null;
}
function fromGrpcRouteMatch(input?: GrpcRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metadata: input["metadata"]?.map(x => fromGrpcRouteMetadata(x)),
    methodName: input["methodName"],
    serviceName: input["serviceName"],
  }
}
function toGrpcRouteMatch(root: jsonP.JSONValue): GrpcRouteMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "metadata": [toGrpcRouteMetadata],
      "methodName": "s",
      "serviceName": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRouteMetadata {
  invert?: boolean | null;
  match?: GrpcRouteMetadataMatchMethod | null;
  name: string;
}
function fromGrpcRouteMetadata(input?: GrpcRouteMetadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    invert: input["invert"],
    match: fromGrpcRouteMetadataMatchMethod(input["match"]),
    name: input["name"],
  }
}
function toGrpcRouteMetadata(root: jsonP.JSONValue): GrpcRouteMetadata {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "invert": "b",
      "match": toGrpcRouteMetadataMatchMethod,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRouteMetadataMatchMethod {
  exact?: string | null;
  prefix?: string | null;
  range?: MatchRange | null;
  regex?: string | null;
  suffix?: string | null;
}
function fromGrpcRouteMetadataMatchMethod(input?: GrpcRouteMetadataMatchMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exact: input["exact"],
    prefix: input["prefix"],
    range: fromMatchRange(input["range"]),
    regex: input["regex"],
    suffix: input["suffix"],
  }
}
function toGrpcRouteMetadataMatchMethod(root: jsonP.JSONValue): GrpcRouteMetadataMatchMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "exact": "s",
      "prefix": "s",
      "range": toMatchRange,
      "regex": "s",
      "suffix": "s",
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface MatchRange {
  end: number;
  start: number;
}
function fromMatchRange(input?: MatchRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    end: input["end"],
    start: input["start"],
  }
}
function toMatchRange(root: jsonP.JSONValue): MatchRange {
  return jsonP.readObj({
    required: {
      "end": "n",
      "start": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface GrpcRetryPolicy {
  grpcRetryEvents?: GrpcRetryPolicyEvent[] | null;
  httpRetryEvents?: string[] | null;
  maxRetries: number;
  perRetryTimeout: Duration;
  tcpRetryEvents?: TcpRetryPolicyEvent[] | null;
}
function fromGrpcRetryPolicy(input?: GrpcRetryPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRetryEvents: input["grpcRetryEvents"],
    httpRetryEvents: input["httpRetryEvents"],
    maxRetries: input["maxRetries"],
    perRetryTimeout: fromDuration(input["perRetryTimeout"]),
    tcpRetryEvents: input["tcpRetryEvents"],
  }
}
function toGrpcRetryPolicy(root: jsonP.JSONValue): GrpcRetryPolicy {
  return jsonP.readObj({
    required: {
      "maxRetries": "n",
      "perRetryTimeout": toDuration,
    },
    optional: {
      "grpcRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<GrpcRetryPolicyEvent>(x)],
      "httpRetryEvents": ["s"],
      "tcpRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<TcpRetryPolicyEvent>(x)],
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type GrpcRetryPolicyEvent =
| "cancelled"
| "deadline-exceeded"
| "internal"
| "resource-exhausted"
| "unavailable"
| cmnP.UnexpectedEnumValue;

// refs: 102 - tags: input, named, interface, output
export interface Duration {
  unit?: DurationUnit | null;
  value?: number | null;
}
function fromDuration(input?: Duration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unit: input["unit"],
    value: input["value"],
  }
}
function toDuration(root: jsonP.JSONValue): Duration {
  return jsonP.readObj({
    required: {},
    optional: {
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<DurationUnit>(x),
      "value": "n",
    },
  }, root);
}

// refs: 102 - tags: input, named, enum, output
export type DurationUnit =
| "ms"
| "s"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type TcpRetryPolicyEvent =
| "connection-error"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface GrpcTimeout {
  idle?: Duration | null;
  perRequest?: Duration | null;
}
function fromGrpcTimeout(input?: GrpcTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
    perRequest: fromDuration(input["perRequest"]),
  }
}
function toGrpcTimeout(root: jsonP.JSONValue): GrpcTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
      "perRequest": toDuration,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpRoute {
  action: HttpRouteAction;
  match: HttpRouteMatch;
  retryPolicy?: HttpRetryPolicy | null;
  timeout?: HttpTimeout | null;
}
function fromHttpRoute(input?: HttpRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromHttpRouteAction(input["action"]),
    match: fromHttpRouteMatch(input["match"]),
    retryPolicy: fromHttpRetryPolicy(input["retryPolicy"]),
    timeout: fromHttpTimeout(input["timeout"]),
  }
}
function toHttpRoute(root: jsonP.JSONValue): HttpRoute {
  return jsonP.readObj({
    required: {
      "action": toHttpRouteAction,
      "match": toHttpRouteMatch,
    },
    optional: {
      "retryPolicy": toHttpRetryPolicy,
      "timeout": toHttpTimeout,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpRouteAction {
  weightedTargets: WeightedTarget[];
}
function fromHttpRouteAction(input?: HttpRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toHttpRouteAction(root: jsonP.JSONValue): HttpRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpRouteMatch {
  headers?: HttpRouteHeader[] | null;
  method?: HttpMethod | null;
  prefix: string;
  scheme?: HttpScheme | null;
}
function fromHttpRouteMatch(input?: HttpRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    headers: input["headers"]?.map(x => fromHttpRouteHeader(x)),
    method: input["method"],
    prefix: input["prefix"],
    scheme: input["scheme"],
  }
}
function toHttpRouteMatch(root: jsonP.JSONValue): HttpRouteMatch {
  return jsonP.readObj({
    required: {
      "prefix": "s",
    },
    optional: {
      "headers": [toHttpRouteHeader],
      "method": (x: jsonP.JSONValue) => cmnP.readEnum<HttpMethod>(x),
      "scheme": (x: jsonP.JSONValue) => cmnP.readEnum<HttpScheme>(x),
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HttpRouteHeader {
  invert?: boolean | null;
  match?: HeaderMatchMethod | null;
  name: string;
}
function fromHttpRouteHeader(input?: HttpRouteHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    invert: input["invert"],
    match: fromHeaderMatchMethod(input["match"]),
    name: input["name"],
  }
}
function toHttpRouteHeader(root: jsonP.JSONValue): HttpRouteHeader {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "invert": "b",
      "match": toHeaderMatchMethod,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface HeaderMatchMethod {
  exact?: string | null;
  prefix?: string | null;
  range?: MatchRange | null;
  regex?: string | null;
  suffix?: string | null;
}
function fromHeaderMatchMethod(input?: HeaderMatchMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exact: input["exact"],
    prefix: input["prefix"],
    range: fromMatchRange(input["range"]),
    regex: input["regex"],
    suffix: input["suffix"],
  }
}
function toHeaderMatchMethod(root: jsonP.JSONValue): HeaderMatchMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "exact": "s",
      "prefix": "s",
      "range": toMatchRange,
      "regex": "s",
      "suffix": "s",
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type HttpMethod =
| "CONNECT"
| "DELETE"
| "GET"
| "HEAD"
| "OPTIONS"
| "PATCH"
| "POST"
| "PUT"
| "TRACE"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, enum, output
export type HttpScheme =
| "http"
| "https"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface HttpRetryPolicy {
  httpRetryEvents?: string[] | null;
  maxRetries: number;
  perRetryTimeout: Duration;
  tcpRetryEvents?: TcpRetryPolicyEvent[] | null;
}
function fromHttpRetryPolicy(input?: HttpRetryPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    httpRetryEvents: input["httpRetryEvents"],
    maxRetries: input["maxRetries"],
    perRetryTimeout: fromDuration(input["perRetryTimeout"]),
    tcpRetryEvents: input["tcpRetryEvents"],
  }
}
function toHttpRetryPolicy(root: jsonP.JSONValue): HttpRetryPolicy {
  return jsonP.readObj({
    required: {
      "maxRetries": "n",
      "perRetryTimeout": toDuration,
    },
    optional: {
      "httpRetryEvents": ["s"],
      "tcpRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<TcpRetryPolicyEvent>(x)],
    },
  }, root);
}

// refs: 24 - tags: input, named, interface, output
export interface HttpTimeout {
  idle?: Duration | null;
  perRequest?: Duration | null;
}
function fromHttpTimeout(input?: HttpTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
    perRequest: fromDuration(input["perRequest"]),
  }
}
function toHttpTimeout(root: jsonP.JSONValue): HttpTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
      "perRequest": toDuration,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface TcpRoute {
  action: TcpRouteAction;
  timeout?: TcpTimeout | null;
}
function fromTcpRoute(input?: TcpRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromTcpRouteAction(input["action"]),
    timeout: fromTcpTimeout(input["timeout"]),
  }
}
function toTcpRoute(root: jsonP.JSONValue): TcpRoute {
  return jsonP.readObj({
    required: {
      "action": toTcpRouteAction,
    },
    optional: {
      "timeout": toTcpTimeout,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface TcpRouteAction {
  weightedTargets: WeightedTarget[];
}
function fromTcpRouteAction(input?: TcpRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toTcpRouteAction(root: jsonP.JSONValue): TcpRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TcpTimeout {
  idle?: Duration | null;
}
function fromTcpTimeout(input?: TcpTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
  }
}
function toTcpTimeout(root: jsonP.JSONValue): TcpTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewaySpec {
  backendDefaults?: VirtualGatewayBackendDefaults | null;
  listeners: VirtualGatewayListener[];
  logging?: VirtualGatewayLogging | null;
}
function fromVirtualGatewaySpec(input?: VirtualGatewaySpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    backendDefaults: fromVirtualGatewayBackendDefaults(input["backendDefaults"]),
    listeners: input["listeners"]?.map(x => fromVirtualGatewayListener(x)),
    logging: fromVirtualGatewayLogging(input["logging"]),
  }
}
function toVirtualGatewaySpec(root: jsonP.JSONValue): VirtualGatewaySpec {
  return jsonP.readObj({
    required: {
      "listeners": [toVirtualGatewayListener],
    },
    optional: {
      "backendDefaults": toVirtualGatewayBackendDefaults,
      "logging": toVirtualGatewayLogging,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayBackendDefaults {
  clientPolicy?: VirtualGatewayClientPolicy | null;
}
function fromVirtualGatewayBackendDefaults(input?: VirtualGatewayBackendDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromVirtualGatewayClientPolicy(input["clientPolicy"]),
  }
}
function toVirtualGatewayBackendDefaults(root: jsonP.JSONValue): VirtualGatewayBackendDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientPolicy": toVirtualGatewayClientPolicy,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayClientPolicy {
  tls?: VirtualGatewayClientPolicyTls | null;
}
function fromVirtualGatewayClientPolicy(input?: VirtualGatewayClientPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tls: fromVirtualGatewayClientPolicyTls(input["tls"]),
  }
}
function toVirtualGatewayClientPolicy(root: jsonP.JSONValue): VirtualGatewayClientPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "tls": toVirtualGatewayClientPolicyTls,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayClientPolicyTls {
  enforce?: boolean | null;
  ports?: number[] | null;
  validation: VirtualGatewayTlsValidationContext;
}
function fromVirtualGatewayClientPolicyTls(input?: VirtualGatewayClientPolicyTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enforce: input["enforce"],
    ports: input["ports"],
    validation: fromVirtualGatewayTlsValidationContext(input["validation"]),
  }
}
function toVirtualGatewayClientPolicyTls(root: jsonP.JSONValue): VirtualGatewayClientPolicyTls {
  return jsonP.readObj({
    required: {
      "validation": toVirtualGatewayTlsValidationContext,
    },
    optional: {
      "enforce": "b",
      "ports": ["n"],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayTlsValidationContext {
  trust: VirtualGatewayTlsValidationContextTrust;
}
function fromVirtualGatewayTlsValidationContext(input?: VirtualGatewayTlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    trust: fromVirtualGatewayTlsValidationContextTrust(input["trust"]),
  }
}
function toVirtualGatewayTlsValidationContext(root: jsonP.JSONValue): VirtualGatewayTlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toVirtualGatewayTlsValidationContextTrust,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayTlsValidationContextTrust {
  acm?: VirtualGatewayTlsValidationContextAcmTrust | null;
  file?: VirtualGatewayTlsValidationContextFileTrust | null;
}
function fromVirtualGatewayTlsValidationContextTrust(input?: VirtualGatewayTlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromVirtualGatewayTlsValidationContextAcmTrust(input["acm"]),
    file: fromVirtualGatewayTlsValidationContextFileTrust(input["file"]),
  }
}
function toVirtualGatewayTlsValidationContextTrust(root: jsonP.JSONValue): VirtualGatewayTlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toVirtualGatewayTlsValidationContextAcmTrust,
      "file": toVirtualGatewayTlsValidationContextFileTrust,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayTlsValidationContextAcmTrust {
  certificateAuthorityArns: string[];
}
function fromVirtualGatewayTlsValidationContextAcmTrust(input?: VirtualGatewayTlsValidationContextAcmTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArns: input["certificateAuthorityArns"],
  }
}
function toVirtualGatewayTlsValidationContextAcmTrust(root: jsonP.JSONValue): VirtualGatewayTlsValidationContextAcmTrust {
  return jsonP.readObj({
    required: {
      "certificateAuthorityArns": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayTlsValidationContextFileTrust {
  certificateChain: string;
}
function fromVirtualGatewayTlsValidationContextFileTrust(input?: VirtualGatewayTlsValidationContextFileTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
  }
}
function toVirtualGatewayTlsValidationContextFileTrust(root: jsonP.JSONValue): VirtualGatewayTlsValidationContextFileTrust {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayListener {
  healthCheck?: VirtualGatewayHealthCheckPolicy | null;
  portMapping: VirtualGatewayPortMapping;
  tls?: VirtualGatewayListenerTls | null;
}
function fromVirtualGatewayListener(input?: VirtualGatewayListener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthCheck: fromVirtualGatewayHealthCheckPolicy(input["healthCheck"]),
    portMapping: fromVirtualGatewayPortMapping(input["portMapping"]),
    tls: fromVirtualGatewayListenerTls(input["tls"]),
  }
}
function toVirtualGatewayListener(root: jsonP.JSONValue): VirtualGatewayListener {
  return jsonP.readObj({
    required: {
      "portMapping": toVirtualGatewayPortMapping,
    },
    optional: {
      "healthCheck": toVirtualGatewayHealthCheckPolicy,
      "tls": toVirtualGatewayListenerTls,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayHealthCheckPolicy {
  healthyThreshold: number;
  intervalMillis: number;
  path?: string | null;
  port?: number | null;
  protocol: VirtualGatewayPortProtocol;
  timeoutMillis: number;
  unhealthyThreshold: number;
}
function fromVirtualGatewayHealthCheckPolicy(input?: VirtualGatewayHealthCheckPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthyThreshold: input["healthyThreshold"],
    intervalMillis: input["intervalMillis"],
    path: input["path"],
    port: input["port"],
    protocol: input["protocol"],
    timeoutMillis: input["timeoutMillis"],
    unhealthyThreshold: input["unhealthyThreshold"],
  }
}
function toVirtualGatewayHealthCheckPolicy(root: jsonP.JSONValue): VirtualGatewayHealthCheckPolicy {
  return jsonP.readObj({
    required: {
      "healthyThreshold": "n",
      "intervalMillis": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualGatewayPortProtocol>(x),
      "timeoutMillis": "n",
      "unhealthyThreshold": "n",
    },
    optional: {
      "path": "s",
      "port": "n",
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type VirtualGatewayPortProtocol =
| "grpc"
| "http"
| "http2"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayPortMapping {
  port: number;
  protocol: VirtualGatewayPortProtocol;
}
function fromVirtualGatewayPortMapping(input?: VirtualGatewayPortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    port: input["port"],
    protocol: input["protocol"],
  }
}
function toVirtualGatewayPortMapping(root: jsonP.JSONValue): VirtualGatewayPortMapping {
  return jsonP.readObj({
    required: {
      "port": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualGatewayPortProtocol>(x),
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayListenerTls {
  certificate: VirtualGatewayListenerTlsCertificate;
  mode: VirtualGatewayListenerTlsMode;
}
function fromVirtualGatewayListenerTls(input?: VirtualGatewayListenerTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromVirtualGatewayListenerTlsCertificate(input["certificate"]),
    mode: input["mode"],
  }
}
function toVirtualGatewayListenerTls(root: jsonP.JSONValue): VirtualGatewayListenerTls {
  return jsonP.readObj({
    required: {
      "certificate": toVirtualGatewayListenerTlsCertificate,
      "mode": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualGatewayListenerTlsMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayListenerTlsCertificate {
  acm?: VirtualGatewayListenerTlsAcmCertificate | null;
  file?: VirtualGatewayListenerTlsFileCertificate | null;
}
function fromVirtualGatewayListenerTlsCertificate(input?: VirtualGatewayListenerTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromVirtualGatewayListenerTlsAcmCertificate(input["acm"]),
    file: fromVirtualGatewayListenerTlsFileCertificate(input["file"]),
  }
}
function toVirtualGatewayListenerTlsCertificate(root: jsonP.JSONValue): VirtualGatewayListenerTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toVirtualGatewayListenerTlsAcmCertificate,
      "file": toVirtualGatewayListenerTlsFileCertificate,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayListenerTlsAcmCertificate {
  certificateArn: string;
}
function fromVirtualGatewayListenerTlsAcmCertificate(input?: VirtualGatewayListenerTlsAcmCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
  }
}
function toVirtualGatewayListenerTlsAcmCertificate(root: jsonP.JSONValue): VirtualGatewayListenerTlsAcmCertificate {
  return jsonP.readObj({
    required: {
      "certificateArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayListenerTlsFileCertificate {
  certificateChain: string;
  privateKey: string;
}
function fromVirtualGatewayListenerTlsFileCertificate(input?: VirtualGatewayListenerTlsFileCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
    privateKey: input["privateKey"],
  }
}
function toVirtualGatewayListenerTlsFileCertificate(root: jsonP.JSONValue): VirtualGatewayListenerTlsFileCertificate {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
      "privateKey": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type VirtualGatewayListenerTlsMode =
| "DISABLED"
| "PERMISSIVE"
| "STRICT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayLogging {
  accessLog?: VirtualGatewayAccessLog | null;
}
function fromVirtualGatewayLogging(input?: VirtualGatewayLogging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessLog: fromVirtualGatewayAccessLog(input["accessLog"]),
  }
}
function toVirtualGatewayLogging(root: jsonP.JSONValue): VirtualGatewayLogging {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessLog": toVirtualGatewayAccessLog,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayAccessLog {
  file?: VirtualGatewayFileAccessLog | null;
}
function fromVirtualGatewayAccessLog(input?: VirtualGatewayAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromVirtualGatewayFileAccessLog(input["file"]),
  }
}
function toVirtualGatewayAccessLog(root: jsonP.JSONValue): VirtualGatewayAccessLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toVirtualGatewayFileAccessLog,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualGatewayFileAccessLog {
  path: string;
}
function fromVirtualGatewayFileAccessLog(input?: VirtualGatewayFileAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
  }
}
function toVirtualGatewayFileAccessLog(root: jsonP.JSONValue): VirtualGatewayFileAccessLog {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualNodeSpec {
  backendDefaults?: BackendDefaults | null;
  backends?: Backend[] | null;
  listeners?: Listener[] | null;
  logging?: Logging | null;
  serviceDiscovery?: ServiceDiscovery | null;
}
function fromVirtualNodeSpec(input?: VirtualNodeSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    backendDefaults: fromBackendDefaults(input["backendDefaults"]),
    backends: input["backends"]?.map(x => fromBackend(x)),
    listeners: input["listeners"]?.map(x => fromListener(x)),
    logging: fromLogging(input["logging"]),
    serviceDiscovery: fromServiceDiscovery(input["serviceDiscovery"]),
  }
}
function toVirtualNodeSpec(root: jsonP.JSONValue): VirtualNodeSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "backendDefaults": toBackendDefaults,
      "backends": [toBackend],
      "listeners": [toListener],
      "logging": toLogging,
      "serviceDiscovery": toServiceDiscovery,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface BackendDefaults {
  clientPolicy?: ClientPolicy | null;
}
function fromBackendDefaults(input?: BackendDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromClientPolicy(input["clientPolicy"]),
  }
}
function toBackendDefaults(root: jsonP.JSONValue): BackendDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientPolicy": toClientPolicy,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface ClientPolicy {
  tls?: ClientPolicyTls | null;
}
function fromClientPolicy(input?: ClientPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tls: fromClientPolicyTls(input["tls"]),
  }
}
function toClientPolicy(root: jsonP.JSONValue): ClientPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "tls": toClientPolicyTls,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface ClientPolicyTls {
  enforce?: boolean | null;
  ports?: number[] | null;
  validation: TlsValidationContext;
}
function fromClientPolicyTls(input?: ClientPolicyTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    enforce: input["enforce"],
    ports: input["ports"],
    validation: fromTlsValidationContext(input["validation"]),
  }
}
function toClientPolicyTls(root: jsonP.JSONValue): ClientPolicyTls {
  return jsonP.readObj({
    required: {
      "validation": toTlsValidationContext,
    },
    optional: {
      "enforce": "b",
      "ports": ["n"],
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TlsValidationContext {
  trust: TlsValidationContextTrust;
}
function fromTlsValidationContext(input?: TlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    trust: fromTlsValidationContextTrust(input["trust"]),
  }
}
function toTlsValidationContext(root: jsonP.JSONValue): TlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toTlsValidationContextTrust,
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TlsValidationContextTrust {
  acm?: TlsValidationContextAcmTrust | null;
  file?: TlsValidationContextFileTrust | null;
}
function fromTlsValidationContextTrust(input?: TlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromTlsValidationContextAcmTrust(input["acm"]),
    file: fromTlsValidationContextFileTrust(input["file"]),
  }
}
function toTlsValidationContextTrust(root: jsonP.JSONValue): TlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toTlsValidationContextAcmTrust,
      "file": toTlsValidationContextFileTrust,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TlsValidationContextAcmTrust {
  certificateAuthorityArns: string[];
}
function fromTlsValidationContextAcmTrust(input?: TlsValidationContextAcmTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArns: input["certificateAuthorityArns"],
  }
}
function toTlsValidationContextAcmTrust(root: jsonP.JSONValue): TlsValidationContextAcmTrust {
  return jsonP.readObj({
    required: {
      "certificateAuthorityArns": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface TlsValidationContextFileTrust {
  certificateChain: string;
}
function fromTlsValidationContextFileTrust(input?: TlsValidationContextFileTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
  }
}
function toTlsValidationContextFileTrust(root: jsonP.JSONValue): TlsValidationContextFileTrust {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Backend {
  virtualService?: VirtualServiceBackend | null;
}
function fromBackend(input?: Backend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualService: fromVirtualServiceBackend(input["virtualService"]),
  }
}
function toBackend(root: jsonP.JSONValue): Backend {
  return jsonP.readObj({
    required: {},
    optional: {
      "virtualService": toVirtualServiceBackend,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualServiceBackend {
  clientPolicy?: ClientPolicy | null;
  virtualServiceName: string;
}
function fromVirtualServiceBackend(input?: VirtualServiceBackend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromClientPolicy(input["clientPolicy"]),
    virtualServiceName: input["virtualServiceName"],
  }
}
function toVirtualServiceBackend(root: jsonP.JSONValue): VirtualServiceBackend {
  return jsonP.readObj({
    required: {
      "virtualServiceName": "s",
    },
    optional: {
      "clientPolicy": toClientPolicy,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface Listener {
  healthCheck?: HealthCheckPolicy | null;
  portMapping: PortMapping;
  timeout?: ListenerTimeout | null;
  tls?: ListenerTls | null;
}
function fromListener(input?: Listener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthCheck: fromHealthCheckPolicy(input["healthCheck"]),
    portMapping: fromPortMapping(input["portMapping"]),
    timeout: fromListenerTimeout(input["timeout"]),
    tls: fromListenerTls(input["tls"]),
  }
}
function toListener(root: jsonP.JSONValue): Listener {
  return jsonP.readObj({
    required: {
      "portMapping": toPortMapping,
    },
    optional: {
      "healthCheck": toHealthCheckPolicy,
      "timeout": toListenerTimeout,
      "tls": toListenerTls,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface HealthCheckPolicy {
  healthyThreshold: number;
  intervalMillis: number;
  path?: string | null;
  port?: number | null;
  protocol: PortProtocol;
  timeoutMillis: number;
  unhealthyThreshold: number;
}
function fromHealthCheckPolicy(input?: HealthCheckPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthyThreshold: input["healthyThreshold"],
    intervalMillis: input["intervalMillis"],
    path: input["path"],
    port: input["port"],
    protocol: input["protocol"],
    timeoutMillis: input["timeoutMillis"],
    unhealthyThreshold: input["unhealthyThreshold"],
  }
}
function toHealthCheckPolicy(root: jsonP.JSONValue): HealthCheckPolicy {
  return jsonP.readObj({
    required: {
      "healthyThreshold": "n",
      "intervalMillis": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<PortProtocol>(x),
      "timeoutMillis": "n",
      "unhealthyThreshold": "n",
    },
    optional: {
      "path": "s",
      "port": "n",
    },
  }, root);
}

// refs: 18 - tags: input, named, enum, output
export type PortProtocol =
| "grpc"
| "http"
| "http2"
| "tcp"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface PortMapping {
  port: number;
  protocol: PortProtocol;
}
function fromPortMapping(input?: PortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    port: input["port"],
    protocol: input["protocol"],
  }
}
function toPortMapping(root: jsonP.JSONValue): PortMapping {
  return jsonP.readObj({
    required: {
      "port": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<PortProtocol>(x),
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ListenerTimeout {
  grpc?: GrpcTimeout | null;
  http?: HttpTimeout | null;
  http2?: HttpTimeout | null;
  tcp?: TcpTimeout | null;
}
function fromListenerTimeout(input?: ListenerTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpc: fromGrpcTimeout(input["grpc"]),
    http: fromHttpTimeout(input["http"]),
    http2: fromHttpTimeout(input["http2"]),
    tcp: fromTcpTimeout(input["tcp"]),
  }
}
function toListenerTimeout(root: jsonP.JSONValue): ListenerTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpc": toGrpcTimeout,
      "http": toHttpTimeout,
      "http2": toHttpTimeout,
      "tcp": toTcpTimeout,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ListenerTls {
  certificate: ListenerTlsCertificate;
  mode: ListenerTlsMode;
}
function fromListenerTls(input?: ListenerTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromListenerTlsCertificate(input["certificate"]),
    mode: input["mode"],
  }
}
function toListenerTls(root: jsonP.JSONValue): ListenerTls {
  return jsonP.readObj({
    required: {
      "certificate": toListenerTlsCertificate,
      "mode": (x: jsonP.JSONValue) => cmnP.readEnum<ListenerTlsMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ListenerTlsCertificate {
  acm?: ListenerTlsAcmCertificate | null;
  file?: ListenerTlsFileCertificate | null;
}
function fromListenerTlsCertificate(input?: ListenerTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromListenerTlsAcmCertificate(input["acm"]),
    file: fromListenerTlsFileCertificate(input["file"]),
  }
}
function toListenerTlsCertificate(root: jsonP.JSONValue): ListenerTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toListenerTlsAcmCertificate,
      "file": toListenerTlsFileCertificate,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ListenerTlsAcmCertificate {
  certificateArn: string;
}
function fromListenerTlsAcmCertificate(input?: ListenerTlsAcmCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
  }
}
function toListenerTlsAcmCertificate(root: jsonP.JSONValue): ListenerTlsAcmCertificate {
  return jsonP.readObj({
    required: {
      "certificateArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ListenerTlsFileCertificate {
  certificateChain: string;
  privateKey: string;
}
function fromListenerTlsFileCertificate(input?: ListenerTlsFileCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
    privateKey: input["privateKey"],
  }
}
function toListenerTlsFileCertificate(root: jsonP.JSONValue): ListenerTlsFileCertificate {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
      "privateKey": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ListenerTlsMode =
| "DISABLED"
| "PERMISSIVE"
| "STRICT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface Logging {
  accessLog?: AccessLog | null;
}
function fromLogging(input?: Logging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessLog: fromAccessLog(input["accessLog"]),
  }
}
function toLogging(root: jsonP.JSONValue): Logging {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessLog": toAccessLog,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface AccessLog {
  file?: FileAccessLog | null;
}
function fromAccessLog(input?: AccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromFileAccessLog(input["file"]),
  }
}
function toAccessLog(root: jsonP.JSONValue): AccessLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toFileAccessLog,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface FileAccessLog {
  path: string;
}
function fromFileAccessLog(input?: FileAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
  }
}
function toFileAccessLog(root: jsonP.JSONValue): FileAccessLog {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ServiceDiscovery {
  awsCloudMap?: AwsCloudMapServiceDiscovery | null;
  dns?: DnsServiceDiscovery | null;
}
function fromServiceDiscovery(input?: ServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsCloudMap: fromAwsCloudMapServiceDiscovery(input["awsCloudMap"]),
    dns: fromDnsServiceDiscovery(input["dns"]),
  }
}
function toServiceDiscovery(root: jsonP.JSONValue): ServiceDiscovery {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsCloudMap": toAwsCloudMapServiceDiscovery,
      "dns": toDnsServiceDiscovery,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface AwsCloudMapServiceDiscovery {
  attributes?: AwsCloudMapInstanceAttribute[] | null;
  namespaceName: string;
  serviceName: string;
}
function fromAwsCloudMapServiceDiscovery(input?: AwsCloudMapServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributes: input["attributes"]?.map(x => fromAwsCloudMapInstanceAttribute(x)),
    namespaceName: input["namespaceName"],
    serviceName: input["serviceName"],
  }
}
function toAwsCloudMapServiceDiscovery(root: jsonP.JSONValue): AwsCloudMapServiceDiscovery {
  return jsonP.readObj({
    required: {
      "namespaceName": "s",
      "serviceName": "s",
    },
    optional: {
      "attributes": [toAwsCloudMapInstanceAttribute],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface AwsCloudMapInstanceAttribute {
  key: string;
  value: string;
}
function fromAwsCloudMapInstanceAttribute(input?: AwsCloudMapInstanceAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toAwsCloudMapInstanceAttribute(root: jsonP.JSONValue): AwsCloudMapInstanceAttribute {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DnsServiceDiscovery {
  hostname: string;
}
function fromDnsServiceDiscovery(input?: DnsServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostname: input["hostname"],
  }
}
function toDnsServiceDiscovery(root: jsonP.JSONValue): DnsServiceDiscovery {
  return jsonP.readObj({
    required: {
      "hostname": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualRouterSpec {
  listeners?: VirtualRouterListener[] | null;
}
function fromVirtualRouterSpec(input?: VirtualRouterSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    listeners: input["listeners"]?.map(x => fromVirtualRouterListener(x)),
  }
}
function toVirtualRouterSpec(root: jsonP.JSONValue): VirtualRouterSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "listeners": [toVirtualRouterListener],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualRouterListener {
  portMapping: PortMapping;
}
function fromVirtualRouterListener(input?: VirtualRouterListener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    portMapping: fromPortMapping(input["portMapping"]),
  }
}
function toVirtualRouterListener(root: jsonP.JSONValue): VirtualRouterListener {
  return jsonP.readObj({
    required: {
      "portMapping": toPortMapping,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualServiceSpec {
  provider?: VirtualServiceProvider | null;
}
function fromVirtualServiceSpec(input?: VirtualServiceSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    provider: fromVirtualServiceProvider(input["provider"]),
  }
}
function toVirtualServiceSpec(root: jsonP.JSONValue): VirtualServiceSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "provider": toVirtualServiceProvider,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualServiceProvider {
  virtualNode?: VirtualNodeServiceProvider | null;
  virtualRouter?: VirtualRouterServiceProvider | null;
}
function fromVirtualServiceProvider(input?: VirtualServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNode: fromVirtualNodeServiceProvider(input["virtualNode"]),
    virtualRouter: fromVirtualRouterServiceProvider(input["virtualRouter"]),
  }
}
function toVirtualServiceProvider(root: jsonP.JSONValue): VirtualServiceProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "virtualNode": toVirtualNodeServiceProvider,
      "virtualRouter": toVirtualRouterServiceProvider,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualNodeServiceProvider {
  virtualNodeName: string;
}
function fromVirtualNodeServiceProvider(input?: VirtualNodeServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNodeName: input["virtualNodeName"],
  }
}
function toVirtualNodeServiceProvider(root: jsonP.JSONValue): VirtualNodeServiceProvider {
  return jsonP.readObj({
    required: {
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface VirtualRouterServiceProvider {
  virtualRouterName: string;
}
function fromVirtualRouterServiceProvider(input?: VirtualRouterServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualRouterName: input["virtualRouterName"],
  }
}
function toVirtualRouterServiceProvider(root: jsonP.JSONValue): VirtualRouterServiceProvider {
  return jsonP.readObj({
    required: {
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface GatewayRouteData {
  gatewayRouteName: string;
  meshName: string;
  metadata: ResourceMetadata;
  spec: GatewayRouteSpec;
  status: GatewayRouteStatus;
  virtualGatewayName: string;
}
function toGatewayRouteData(root: jsonP.JSONValue): GatewayRouteData {
  return jsonP.readObj({
    required: {
      "gatewayRouteName": "s",
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toGatewayRouteSpec,
      "status": toGatewayRouteStatus,
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

// refs: 28 - tags: output, named, interface
export interface ResourceMetadata {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshOwner: string;
  resourceOwner: string;
  uid: string;
  version: number;
}
function toResourceMetadata(root: jsonP.JSONValue): ResourceMetadata {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshOwner": "s",
      "resourceOwner": "s",
      "uid": "s",
      "version": "n",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface GatewayRouteStatus {
  status: GatewayRouteStatusCode;
}
function toGatewayRouteStatus(root: jsonP.JSONValue): GatewayRouteStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<GatewayRouteStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type GatewayRouteStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface MeshData {
  meshName: string;
  metadata: ResourceMetadata;
  spec: MeshSpec;
  status: MeshStatus;
}
function toMeshData(root: jsonP.JSONValue): MeshData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toMeshSpec,
      "status": toMeshStatus,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface MeshStatus {
  status?: MeshStatusCode | null;
}
function toMeshStatus(root: jsonP.JSONValue): MeshStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<MeshStatusCode>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type MeshStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface RouteData {
  meshName: string;
  metadata: ResourceMetadata;
  routeName: string;
  spec: RouteSpec;
  status: RouteStatus;
  virtualRouterName: string;
}
function toRouteData(root: jsonP.JSONValue): RouteData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "routeName": "s",
      "spec": toRouteSpec,
      "status": toRouteStatus,
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface RouteStatus {
  status: RouteStatusCode;
}
function toRouteStatus(root: jsonP.JSONValue): RouteStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<RouteStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type RouteStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface VirtualGatewayData {
  meshName: string;
  metadata: ResourceMetadata;
  spec: VirtualGatewaySpec;
  status: VirtualGatewayStatus;
  virtualGatewayName: string;
}
function toVirtualGatewayData(root: jsonP.JSONValue): VirtualGatewayData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualGatewaySpec,
      "status": toVirtualGatewayStatus,
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface VirtualGatewayStatus {
  status: VirtualGatewayStatusCode;
}
function toVirtualGatewayStatus(root: jsonP.JSONValue): VirtualGatewayStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualGatewayStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type VirtualGatewayStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface VirtualNodeData {
  meshName: string;
  metadata: ResourceMetadata;
  spec: VirtualNodeSpec;
  status: VirtualNodeStatus;
  virtualNodeName: string;
}
function toVirtualNodeData(root: jsonP.JSONValue): VirtualNodeData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualNodeSpec,
      "status": toVirtualNodeStatus,
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface VirtualNodeStatus {
  status: VirtualNodeStatusCode;
}
function toVirtualNodeStatus(root: jsonP.JSONValue): VirtualNodeStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualNodeStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type VirtualNodeStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface VirtualRouterData {
  meshName: string;
  metadata: ResourceMetadata;
  spec: VirtualRouterSpec;
  status: VirtualRouterStatus;
  virtualRouterName: string;
}
function toVirtualRouterData(root: jsonP.JSONValue): VirtualRouterData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualRouterSpec,
      "status": toVirtualRouterStatus,
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface VirtualRouterStatus {
  status: VirtualRouterStatusCode;
}
function toVirtualRouterStatus(root: jsonP.JSONValue): VirtualRouterStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualRouterStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type VirtualRouterStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface VirtualServiceData {
  meshName: string;
  metadata: ResourceMetadata;
  spec: VirtualServiceSpec;
  status: VirtualServiceStatus;
  virtualServiceName: string;
}
function toVirtualServiceData(root: jsonP.JSONValue): VirtualServiceData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualServiceSpec,
      "status": toVirtualServiceStatus,
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface VirtualServiceStatus {
  status: VirtualServiceStatusCode;
}
function toVirtualServiceStatus(root: jsonP.JSONValue): VirtualServiceStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<VirtualServiceStatusCode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, enum
export type VirtualServiceStatusCode =
| "ACTIVE"
| "DELETED"
| "INACTIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GatewayRouteRef {
  arn: string;
  createdAt: Date | number;
  gatewayRouteName: string;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
  virtualGatewayName: string;
}
function toGatewayRouteRef(root: jsonP.JSONValue): GatewayRouteRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "gatewayRouteName": "s",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MeshRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
}
function toMeshRef(root: jsonP.JSONValue): MeshRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RouteRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  routeName: string;
  version: number;
  virtualRouterName: string;
}
function toRouteRef(root: jsonP.JSONValue): RouteRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "routeName": "s",
      "version": "n",
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VirtualGatewayRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
  virtualGatewayName: string;
}
function toVirtualGatewayRef(root: jsonP.JSONValue): VirtualGatewayRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VirtualNodeRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
  virtualNodeName: string;
}
function toVirtualNodeRef(root: jsonP.JSONValue): VirtualNodeRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VirtualRouterRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
  virtualRouterName: string;
}
function toVirtualRouterRef(root: jsonP.JSONValue): VirtualRouterRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface VirtualServiceRef {
  arn: string;
  createdAt: Date | number;
  lastUpdatedAt: Date | number;
  meshName: string;
  meshOwner: string;
  resourceOwner: string;
  version: number;
  virtualServiceName: string;
}
function toVirtualServiceRef(root: jsonP.JSONValue): VirtualServiceRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}
