// Autogenerated API client for: AWS App Mesh

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class AppMesh {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(AppMesh.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-01-25",
    "endpointPrefix": "appmesh",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS App Mesh",
    "serviceId": "App Mesh",
    "signatureVersion": "v4",
    "signingName": "appmesh",
    "uid": "appmesh-2019-01-25"
  };

  async createGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateGatewayRouteInput,
  ): Promise<s.CreateGatewayRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      gatewayRouteName: params["gatewayRouteName"],
      spec: fromGatewayRouteSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateGatewayRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async createMesh(
    {abortSignal, ...params}: RequestConfig & s.CreateMeshInput,
  ): Promise<s.CreateMeshOutput> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      meshName: params["meshName"],
      spec: fromMeshSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMesh",
      method: "PUT",
      requestUri: "/v20190125/meshes",
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async createRoute(
    {abortSignal, ...params}: RequestConfig & s.CreateRouteInput,
  ): Promise<s.CreateRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      routeName: params["routeName"],
      spec: fromRouteSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async createVirtualGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateVirtualGatewayInput,
  ): Promise<s.CreateVirtualGatewayOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualGatewaySpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualGatewayName: params["virtualGatewayName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualGateway",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async createVirtualNode(
    {abortSignal, ...params}: RequestConfig & s.CreateVirtualNodeInput,
  ): Promise<s.CreateVirtualNodeOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualNodeSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualNodeName: params["virtualNodeName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualNode",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async createVirtualRouter(
    {abortSignal, ...params}: RequestConfig & s.CreateVirtualRouterInput,
  ): Promise<s.CreateVirtualRouterOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualRouterSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualRouterName: params["virtualRouterName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualRouter",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async createVirtualService(
    {abortSignal, ...params}: RequestConfig & s.CreateVirtualServiceInput,
  ): Promise<s.CreateVirtualServiceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualServiceSpec(params["spec"]),
      tags: params["tags"]?.map(x => fromTagRef(x)),
      virtualServiceName: params["virtualServiceName"],
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateVirtualService",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async deleteGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteGatewayRouteInput,
  ): Promise<s.DeleteGatewayRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteGatewayRoute",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async deleteMesh(
    {abortSignal, ...params}: RequestConfig & s.DeleteMeshInput,
  ): Promise<s.DeleteMeshOutput> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMesh",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async deleteRoute(
    {abortSignal, ...params}: RequestConfig & s.DeleteRouteInput,
  ): Promise<s.DeleteRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRoute",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async deleteVirtualGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualGatewayInput,
  ): Promise<s.DeleteVirtualGatewayOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualGateway",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async deleteVirtualNode(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualNodeInput,
  ): Promise<s.DeleteVirtualNodeOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualNode",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async deleteVirtualRouter(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualRouterInput,
  ): Promise<s.DeleteVirtualRouterOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualRouter",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async deleteVirtualService(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualServiceInput,
  ): Promise<s.DeleteVirtualServiceOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVirtualService",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async describeGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.DescribeGatewayRouteInput,
  ): Promise<s.DescribeGatewayRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeGatewayRoute",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async describeMesh(
    {abortSignal, ...params}: RequestConfig & s.DescribeMeshInput,
  ): Promise<s.DescribeMeshOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeMesh",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async describeRoute(
    {abortSignal, ...params}: RequestConfig & s.DescribeRouteInput,
  ): Promise<s.DescribeRouteOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRoute",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async describeVirtualGateway(
    {abortSignal, ...params}: RequestConfig & s.DescribeVirtualGatewayInput,
  ): Promise<s.DescribeVirtualGatewayOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualGateway",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async describeVirtualNode(
    {abortSignal, ...params}: RequestConfig & s.DescribeVirtualNodeInput,
  ): Promise<s.DescribeVirtualNodeOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualNode",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async describeVirtualRouter(
    {abortSignal, ...params}: RequestConfig & s.DescribeVirtualRouterInput,
  ): Promise<s.DescribeVirtualRouterOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualRouter",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async describeVirtualService(
    {abortSignal, ...params}: RequestConfig & s.DescribeVirtualServiceInput,
  ): Promise<s.DescribeVirtualServiceOutput> {
    const query = new URLSearchParams;
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeVirtualService",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

  async listGatewayRoutes(
    {abortSignal, ...params}: RequestConfig & s.ListGatewayRoutesInput,
  ): Promise<s.ListGatewayRoutesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGatewayRoutes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "gatewayRoutes": [toGatewayRouteRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listMeshes(
    {abortSignal, ...params}: RequestConfig & s.ListMeshesInput = {},
  ): Promise<s.ListMeshesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMeshes",
      method: "GET",
      requestUri: "/v20190125/meshes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "meshes": [toMeshRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRoutes(
    {abortSignal, ...params}: RequestConfig & s.ListRoutesInput,
  ): Promise<s.ListRoutesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRoutes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "routes": [toRouteRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: "/v20190125/tags",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "tags": [toTagRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualGateways(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualGatewaysInput,
  ): Promise<s.ListVirtualGatewaysOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualGateways",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualGateways": [toVirtualGatewayRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualNodes(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualNodesInput,
  ): Promise<s.ListVirtualNodesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualNodes",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualNodes": [toVirtualNodeRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualRouters(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualRoutersInput,
  ): Promise<s.ListVirtualRoutersOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualRouters",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualRouters": [toVirtualRouterRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listVirtualServices(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualServicesInput,
  ): Promise<s.ListVirtualServicesOutput> {
    const query = new URLSearchParams;
    if (params["limit"] != null) query.set("limit", params["limit"]?.toString() ?? "");
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVirtualServices",
      method: "GET",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "virtualServices": [toVirtualServiceRef],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<s.TagResourceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTagRef(x)),
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource",
      method: "PUT",
      requestUri: "/v20190125/tag",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<s.UntagResourceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tagKeys: params["tagKeys"],
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource",
      method: "PUT",
      requestUri: "/v20190125/untag",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateGatewayRoute(
    {abortSignal, ...params}: RequestConfig & s.UpdateGatewayRouteInput,
  ): Promise<s.UpdateGatewayRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromGatewayRouteSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateGatewayRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateway/${params["virtualGatewayName"]}/gatewayRoutes/${params["gatewayRouteName"]}`,
      responseCode: 200,
    });
  return {
    gatewayRoute: toGatewayRouteData(await resp.json()),
  };
  }

  async updateMesh(
    {abortSignal, ...params}: RequestConfig & s.UpdateMeshInput,
  ): Promise<s.UpdateMeshOutput> {
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromMeshSpec(params["spec"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMesh",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}`,
      responseCode: 200,
    });
  return {
    mesh: toMeshData(await resp.json()),
  };
  }

  async updateRoute(
    {abortSignal, ...params}: RequestConfig & s.UpdateRouteInput,
  ): Promise<s.UpdateRouteOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromRouteSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateRoute",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouter/${params["virtualRouterName"]}/routes/${params["routeName"]}`,
      responseCode: 200,
    });
  return {
    route: toRouteData(await resp.json()),
  };
  }

  async updateVirtualGateway(
    {abortSignal, ...params}: RequestConfig & s.UpdateVirtualGatewayInput,
  ): Promise<s.UpdateVirtualGatewayOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualGatewaySpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualGateway",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualGateways/${params["virtualGatewayName"]}`,
      responseCode: 200,
    });
  return {
    virtualGateway: toVirtualGatewayData(await resp.json()),
  };
  }

  async updateVirtualNode(
    {abortSignal, ...params}: RequestConfig & s.UpdateVirtualNodeInput,
  ): Promise<s.UpdateVirtualNodeOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualNodeSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualNode",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualNodes/${params["virtualNodeName"]}`,
      responseCode: 200,
    });
  return {
    virtualNode: toVirtualNodeData(await resp.json()),
  };
  }

  async updateVirtualRouter(
    {abortSignal, ...params}: RequestConfig & s.UpdateVirtualRouterInput,
  ): Promise<s.UpdateVirtualRouterOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualRouterSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualRouter",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualRouters/${params["virtualRouterName"]}`,
      responseCode: 200,
    });
  return {
    virtualRouter: toVirtualRouterData(await resp.json()),
  };
  }

  async updateVirtualService(
    {abortSignal, ...params}: RequestConfig & s.UpdateVirtualServiceInput,
  ): Promise<s.UpdateVirtualServiceOutput> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      clientToken: params["clientToken"] ?? generateIdemptToken(),
      spec: fromVirtualServiceSpec(params["spec"]),
    };
    if (params["meshOwner"] != null) query.set("meshOwner", params["meshOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVirtualService",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20190125/meshes/${params["meshName"]}/virtualServices/${params["virtualServiceName"]}`,
      responseCode: 200,
    });
  return {
    virtualService: toVirtualServiceData(await resp.json()),
  };
  }

}

function fromGatewayRouteSpec(input?: s.GatewayRouteSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRoute: fromGrpcGatewayRoute(input["grpcRoute"]),
    http2Route: fromHttpGatewayRoute(input["http2Route"]),
    httpRoute: fromHttpGatewayRoute(input["httpRoute"]),
  }
}
function toGatewayRouteSpec(root: jsonP.JSONValue): s.GatewayRouteSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpcRoute": toGrpcGatewayRoute,
      "http2Route": toHttpGatewayRoute,
      "httpRoute": toHttpGatewayRoute,
    },
  }, root);
}

function fromGrpcGatewayRoute(input?: s.GrpcGatewayRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromGrpcGatewayRouteAction(input["action"]),
    match: fromGrpcGatewayRouteMatch(input["match"]),
  }
}
function toGrpcGatewayRoute(root: jsonP.JSONValue): s.GrpcGatewayRoute {
  return jsonP.readObj({
    required: {
      "action": toGrpcGatewayRouteAction,
      "match": toGrpcGatewayRouteMatch,
    },
    optional: {},
  }, root);
}

function fromGrpcGatewayRouteAction(input?: s.GrpcGatewayRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    target: fromGatewayRouteTarget(input["target"]),
  }
}
function toGrpcGatewayRouteAction(root: jsonP.JSONValue): s.GrpcGatewayRouteAction {
  return jsonP.readObj({
    required: {
      "target": toGatewayRouteTarget,
    },
    optional: {},
  }, root);
}

function fromGatewayRouteTarget(input?: s.GatewayRouteTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualService: fromGatewayRouteVirtualService(input["virtualService"]),
  }
}
function toGatewayRouteTarget(root: jsonP.JSONValue): s.GatewayRouteTarget {
  return jsonP.readObj({
    required: {
      "virtualService": toGatewayRouteVirtualService,
    },
    optional: {},
  }, root);
}

function fromGatewayRouteVirtualService(input?: s.GatewayRouteVirtualService | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualServiceName: input["virtualServiceName"],
  }
}
function toGatewayRouteVirtualService(root: jsonP.JSONValue): s.GatewayRouteVirtualService {
  return jsonP.readObj({
    required: {
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}

function fromGrpcGatewayRouteMatch(input?: s.GrpcGatewayRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceName: input["serviceName"],
  }
}
function toGrpcGatewayRouteMatch(root: jsonP.JSONValue): s.GrpcGatewayRouteMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceName": "s",
    },
  }, root);
}

function fromHttpGatewayRoute(input?: s.HttpGatewayRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromHttpGatewayRouteAction(input["action"]),
    match: fromHttpGatewayRouteMatch(input["match"]),
  }
}
function toHttpGatewayRoute(root: jsonP.JSONValue): s.HttpGatewayRoute {
  return jsonP.readObj({
    required: {
      "action": toHttpGatewayRouteAction,
      "match": toHttpGatewayRouteMatch,
    },
    optional: {},
  }, root);
}

function fromHttpGatewayRouteAction(input?: s.HttpGatewayRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    target: fromGatewayRouteTarget(input["target"]),
  }
}
function toHttpGatewayRouteAction(root: jsonP.JSONValue): s.HttpGatewayRouteAction {
  return jsonP.readObj({
    required: {
      "target": toGatewayRouteTarget,
    },
    optional: {},
  }, root);
}

function fromHttpGatewayRouteMatch(input?: s.HttpGatewayRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    prefix: input["prefix"],
  }
}
function toHttpGatewayRouteMatch(root: jsonP.JSONValue): s.HttpGatewayRouteMatch {
  return jsonP.readObj({
    required: {
      "prefix": "s",
    },
    optional: {},
  }, root);
}

function fromTagRef(input?: s.TagRef | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTagRef(root: jsonP.JSONValue): s.TagRef {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromMeshSpec(input?: s.MeshSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    egressFilter: fromEgressFilter(input["egressFilter"]),
  }
}
function toMeshSpec(root: jsonP.JSONValue): s.MeshSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "egressFilter": toEgressFilter,
    },
  }, root);
}

function fromEgressFilter(input?: s.EgressFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
  }
}
function toEgressFilter(root: jsonP.JSONValue): s.EgressFilter {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EgressFilterType>(x),
    },
    optional: {},
  }, root);
}

function fromRouteSpec(input?: s.RouteSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRoute: fromGrpcRoute(input["grpcRoute"]),
    http2Route: fromHttpRoute(input["http2Route"]),
    httpRoute: fromHttpRoute(input["httpRoute"]),
    priority: input["priority"],
    tcpRoute: fromTcpRoute(input["tcpRoute"]),
  }
}
function toRouteSpec(root: jsonP.JSONValue): s.RouteSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpcRoute": toGrpcRoute,
      "http2Route": toHttpRoute,
      "httpRoute": toHttpRoute,
      "priority": "n",
      "tcpRoute": toTcpRoute,
    },
  }, root);
}

function fromGrpcRoute(input?: s.GrpcRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromGrpcRouteAction(input["action"]),
    match: fromGrpcRouteMatch(input["match"]),
    retryPolicy: fromGrpcRetryPolicy(input["retryPolicy"]),
    timeout: fromGrpcTimeout(input["timeout"]),
  }
}
function toGrpcRoute(root: jsonP.JSONValue): s.GrpcRoute {
  return jsonP.readObj({
    required: {
      "action": toGrpcRouteAction,
      "match": toGrpcRouteMatch,
    },
    optional: {
      "retryPolicy": toGrpcRetryPolicy,
      "timeout": toGrpcTimeout,
    },
  }, root);
}

function fromGrpcRouteAction(input?: s.GrpcRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toGrpcRouteAction(root: jsonP.JSONValue): s.GrpcRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

function fromWeightedTarget(input?: s.WeightedTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNode: input["virtualNode"],
    weight: input["weight"],
  }
}
function toWeightedTarget(root: jsonP.JSONValue): s.WeightedTarget {
  return jsonP.readObj({
    required: {
      "virtualNode": "s",
      "weight": "n",
    },
    optional: {},
  }, root);
}

function fromGrpcRouteMatch(input?: s.GrpcRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    metadata: input["metadata"]?.map(x => fromGrpcRouteMetadata(x)),
    methodName: input["methodName"],
    serviceName: input["serviceName"],
  }
}
function toGrpcRouteMatch(root: jsonP.JSONValue): s.GrpcRouteMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "metadata": [toGrpcRouteMetadata],
      "methodName": "s",
      "serviceName": "s",
    },
  }, root);
}

function fromGrpcRouteMetadata(input?: s.GrpcRouteMetadata | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    invert: input["invert"],
    match: fromGrpcRouteMetadataMatchMethod(input["match"]),
    name: input["name"],
  }
}
function toGrpcRouteMetadata(root: jsonP.JSONValue): s.GrpcRouteMetadata {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "invert": "b",
      "match": toGrpcRouteMetadataMatchMethod,
    },
  }, root);
}

function fromGrpcRouteMetadataMatchMethod(input?: s.GrpcRouteMetadataMatchMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exact: input["exact"],
    prefix: input["prefix"],
    range: fromMatchRange(input["range"]),
    regex: input["regex"],
    suffix: input["suffix"],
  }
}
function toGrpcRouteMetadataMatchMethod(root: jsonP.JSONValue): s.GrpcRouteMetadataMatchMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "exact": "s",
      "prefix": "s",
      "range": toMatchRange,
      "regex": "s",
      "suffix": "s",
    },
  }, root);
}

function fromMatchRange(input?: s.MatchRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    end: input["end"],
    start: input["start"],
  }
}
function toMatchRange(root: jsonP.JSONValue): s.MatchRange {
  return jsonP.readObj({
    required: {
      "end": "n",
      "start": "n",
    },
    optional: {},
  }, root);
}

function fromGrpcRetryPolicy(input?: s.GrpcRetryPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpcRetryEvents: input["grpcRetryEvents"],
    httpRetryEvents: input["httpRetryEvents"],
    maxRetries: input["maxRetries"],
    perRetryTimeout: fromDuration(input["perRetryTimeout"]),
    tcpRetryEvents: input["tcpRetryEvents"],
  }
}
function toGrpcRetryPolicy(root: jsonP.JSONValue): s.GrpcRetryPolicy {
  return jsonP.readObj({
    required: {
      "maxRetries": "n",
      "perRetryTimeout": toDuration,
    },
    optional: {
      "grpcRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<s.GrpcRetryPolicyEvent>(x)],
      "httpRetryEvents": ["s"],
      "tcpRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TcpRetryPolicyEvent>(x)],
    },
  }, root);
}

function fromDuration(input?: s.Duration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    unit: input["unit"],
    value: input["value"],
  }
}
function toDuration(root: jsonP.JSONValue): s.Duration {
  return jsonP.readObj({
    required: {},
    optional: {
      "unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.DurationUnit>(x),
      "value": "n",
    },
  }, root);
}

function fromGrpcTimeout(input?: s.GrpcTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
    perRequest: fromDuration(input["perRequest"]),
  }
}
function toGrpcTimeout(root: jsonP.JSONValue): s.GrpcTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
      "perRequest": toDuration,
    },
  }, root);
}

function fromHttpRoute(input?: s.HttpRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromHttpRouteAction(input["action"]),
    match: fromHttpRouteMatch(input["match"]),
    retryPolicy: fromHttpRetryPolicy(input["retryPolicy"]),
    timeout: fromHttpTimeout(input["timeout"]),
  }
}
function toHttpRoute(root: jsonP.JSONValue): s.HttpRoute {
  return jsonP.readObj({
    required: {
      "action": toHttpRouteAction,
      "match": toHttpRouteMatch,
    },
    optional: {
      "retryPolicy": toHttpRetryPolicy,
      "timeout": toHttpTimeout,
    },
  }, root);
}

function fromHttpRouteAction(input?: s.HttpRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toHttpRouteAction(root: jsonP.JSONValue): s.HttpRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

function fromHttpRouteMatch(input?: s.HttpRouteMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    headers: input["headers"]?.map(x => fromHttpRouteHeader(x)),
    method: input["method"],
    prefix: input["prefix"],
    scheme: input["scheme"],
  }
}
function toHttpRouteMatch(root: jsonP.JSONValue): s.HttpRouteMatch {
  return jsonP.readObj({
    required: {
      "prefix": "s",
    },
    optional: {
      "headers": [toHttpRouteHeader],
      "method": (x: jsonP.JSONValue) => cmnP.readEnum<s.HttpMethod>(x),
      "scheme": (x: jsonP.JSONValue) => cmnP.readEnum<s.HttpScheme>(x),
    },
  }, root);
}

function fromHttpRouteHeader(input?: s.HttpRouteHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    invert: input["invert"],
    match: fromHeaderMatchMethod(input["match"]),
    name: input["name"],
  }
}
function toHttpRouteHeader(root: jsonP.JSONValue): s.HttpRouteHeader {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "invert": "b",
      "match": toHeaderMatchMethod,
    },
  }, root);
}

function fromHeaderMatchMethod(input?: s.HeaderMatchMethod | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exact: input["exact"],
    prefix: input["prefix"],
    range: fromMatchRange(input["range"]),
    regex: input["regex"],
    suffix: input["suffix"],
  }
}
function toHeaderMatchMethod(root: jsonP.JSONValue): s.HeaderMatchMethod {
  return jsonP.readObj({
    required: {},
    optional: {
      "exact": "s",
      "prefix": "s",
      "range": toMatchRange,
      "regex": "s",
      "suffix": "s",
    },
  }, root);
}

function fromHttpRetryPolicy(input?: s.HttpRetryPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    httpRetryEvents: input["httpRetryEvents"],
    maxRetries: input["maxRetries"],
    perRetryTimeout: fromDuration(input["perRetryTimeout"]),
    tcpRetryEvents: input["tcpRetryEvents"],
  }
}
function toHttpRetryPolicy(root: jsonP.JSONValue): s.HttpRetryPolicy {
  return jsonP.readObj({
    required: {
      "maxRetries": "n",
      "perRetryTimeout": toDuration,
    },
    optional: {
      "httpRetryEvents": ["s"],
      "tcpRetryEvents": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TcpRetryPolicyEvent>(x)],
    },
  }, root);
}

function fromHttpTimeout(input?: s.HttpTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
    perRequest: fromDuration(input["perRequest"]),
  }
}
function toHttpTimeout(root: jsonP.JSONValue): s.HttpTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
      "perRequest": toDuration,
    },
  }, root);
}

function fromTcpRoute(input?: s.TcpRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    action: fromTcpRouteAction(input["action"]),
    timeout: fromTcpTimeout(input["timeout"]),
  }
}
function toTcpRoute(root: jsonP.JSONValue): s.TcpRoute {
  return jsonP.readObj({
    required: {
      "action": toTcpRouteAction,
    },
    optional: {
      "timeout": toTcpTimeout,
    },
  }, root);
}

function fromTcpRouteAction(input?: s.TcpRouteAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    weightedTargets: input["weightedTargets"]?.map(x => fromWeightedTarget(x)),
  }
}
function toTcpRouteAction(root: jsonP.JSONValue): s.TcpRouteAction {
  return jsonP.readObj({
    required: {
      "weightedTargets": [toWeightedTarget],
    },
    optional: {},
  }, root);
}

function fromTcpTimeout(input?: s.TcpTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    idle: fromDuration(input["idle"]),
  }
}
function toTcpTimeout(root: jsonP.JSONValue): s.TcpTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "idle": toDuration,
    },
  }, root);
}

function fromVirtualGatewaySpec(input?: s.VirtualGatewaySpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    backendDefaults: fromVirtualGatewayBackendDefaults(input["backendDefaults"]),
    listeners: input["listeners"]?.map(x => fromVirtualGatewayListener(x)),
    logging: fromVirtualGatewayLogging(input["logging"]),
  }
}
function toVirtualGatewaySpec(root: jsonP.JSONValue): s.VirtualGatewaySpec {
  return jsonP.readObj({
    required: {
      "listeners": [toVirtualGatewayListener],
    },
    optional: {
      "backendDefaults": toVirtualGatewayBackendDefaults,
      "logging": toVirtualGatewayLogging,
    },
  }, root);
}

function fromVirtualGatewayBackendDefaults(input?: s.VirtualGatewayBackendDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromVirtualGatewayClientPolicy(input["clientPolicy"]),
  }
}
function toVirtualGatewayBackendDefaults(root: jsonP.JSONValue): s.VirtualGatewayBackendDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientPolicy": toVirtualGatewayClientPolicy,
    },
  }, root);
}

function fromVirtualGatewayClientPolicy(input?: s.VirtualGatewayClientPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tls: fromVirtualGatewayClientPolicyTls(input["tls"]),
  }
}
function toVirtualGatewayClientPolicy(root: jsonP.JSONValue): s.VirtualGatewayClientPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "tls": toVirtualGatewayClientPolicyTls,
    },
  }, root);
}

function fromVirtualGatewayClientPolicyTls(input?: s.VirtualGatewayClientPolicyTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromVirtualGatewayClientTlsCertificate(input["certificate"]),
    enforce: input["enforce"],
    ports: input["ports"],
    validation: fromVirtualGatewayTlsValidationContext(input["validation"]),
  }
}
function toVirtualGatewayClientPolicyTls(root: jsonP.JSONValue): s.VirtualGatewayClientPolicyTls {
  return jsonP.readObj({
    required: {
      "validation": toVirtualGatewayTlsValidationContext,
    },
    optional: {
      "certificate": toVirtualGatewayClientTlsCertificate,
      "enforce": "b",
      "ports": ["n"],
    },
  }, root);
}

function fromVirtualGatewayClientTlsCertificate(input?: s.VirtualGatewayClientTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromVirtualGatewayListenerTlsFileCertificate(input["file"]),
    sds: fromVirtualGatewayListenerTlsSdsCertificate(input["sds"]),
  }
}
function toVirtualGatewayClientTlsCertificate(root: jsonP.JSONValue): s.VirtualGatewayClientTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toVirtualGatewayListenerTlsFileCertificate,
      "sds": toVirtualGatewayListenerTlsSdsCertificate,
    },
  }, root);
}

function fromVirtualGatewayListenerTlsFileCertificate(input?: s.VirtualGatewayListenerTlsFileCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
    privateKey: input["privateKey"],
  }
}
function toVirtualGatewayListenerTlsFileCertificate(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsFileCertificate {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
      "privateKey": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayListenerTlsSdsCertificate(input?: s.VirtualGatewayListenerTlsSdsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    secretName: input["secretName"],
  }
}
function toVirtualGatewayListenerTlsSdsCertificate(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsSdsCertificate {
  return jsonP.readObj({
    required: {
      "secretName": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayTlsValidationContext(input?: s.VirtualGatewayTlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subjectAlternativeNames: fromSubjectAlternativeNames(input["subjectAlternativeNames"]),
    trust: fromVirtualGatewayTlsValidationContextTrust(input["trust"]),
  }
}
function toVirtualGatewayTlsValidationContext(root: jsonP.JSONValue): s.VirtualGatewayTlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toVirtualGatewayTlsValidationContextTrust,
    },
    optional: {
      "subjectAlternativeNames": toSubjectAlternativeNames,
    },
  }, root);
}

function fromSubjectAlternativeNames(input?: s.SubjectAlternativeNames | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    match: fromSubjectAlternativeNameMatchers(input["match"]),
  }
}
function toSubjectAlternativeNames(root: jsonP.JSONValue): s.SubjectAlternativeNames {
  return jsonP.readObj({
    required: {
      "match": toSubjectAlternativeNameMatchers,
    },
    optional: {},
  }, root);
}

function fromSubjectAlternativeNameMatchers(input?: s.SubjectAlternativeNameMatchers | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exact: input["exact"],
  }
}
function toSubjectAlternativeNameMatchers(root: jsonP.JSONValue): s.SubjectAlternativeNameMatchers {
  return jsonP.readObj({
    required: {
      "exact": ["s"],
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayTlsValidationContextTrust(input?: s.VirtualGatewayTlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromVirtualGatewayTlsValidationContextAcmTrust(input["acm"]),
    file: fromVirtualGatewayTlsValidationContextFileTrust(input["file"]),
    sds: fromVirtualGatewayTlsValidationContextSdsTrust(input["sds"]),
  }
}
function toVirtualGatewayTlsValidationContextTrust(root: jsonP.JSONValue): s.VirtualGatewayTlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toVirtualGatewayTlsValidationContextAcmTrust,
      "file": toVirtualGatewayTlsValidationContextFileTrust,
      "sds": toVirtualGatewayTlsValidationContextSdsTrust,
    },
  }, root);
}

function fromVirtualGatewayTlsValidationContextAcmTrust(input?: s.VirtualGatewayTlsValidationContextAcmTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArns: input["certificateAuthorityArns"],
  }
}
function toVirtualGatewayTlsValidationContextAcmTrust(root: jsonP.JSONValue): s.VirtualGatewayTlsValidationContextAcmTrust {
  return jsonP.readObj({
    required: {
      "certificateAuthorityArns": ["s"],
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayTlsValidationContextFileTrust(input?: s.VirtualGatewayTlsValidationContextFileTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
  }
}
function toVirtualGatewayTlsValidationContextFileTrust(root: jsonP.JSONValue): s.VirtualGatewayTlsValidationContextFileTrust {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayTlsValidationContextSdsTrust(input?: s.VirtualGatewayTlsValidationContextSdsTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    secretName: input["secretName"],
  }
}
function toVirtualGatewayTlsValidationContextSdsTrust(root: jsonP.JSONValue): s.VirtualGatewayTlsValidationContextSdsTrust {
  return jsonP.readObj({
    required: {
      "secretName": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayListener(input?: s.VirtualGatewayListener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionPool: fromVirtualGatewayConnectionPool(input["connectionPool"]),
    healthCheck: fromVirtualGatewayHealthCheckPolicy(input["healthCheck"]),
    portMapping: fromVirtualGatewayPortMapping(input["portMapping"]),
    tls: fromVirtualGatewayListenerTls(input["tls"]),
  }
}
function toVirtualGatewayListener(root: jsonP.JSONValue): s.VirtualGatewayListener {
  return jsonP.readObj({
    required: {
      "portMapping": toVirtualGatewayPortMapping,
    },
    optional: {
      "connectionPool": toVirtualGatewayConnectionPool,
      "healthCheck": toVirtualGatewayHealthCheckPolicy,
      "tls": toVirtualGatewayListenerTls,
    },
  }, root);
}

function fromVirtualGatewayConnectionPool(input?: s.VirtualGatewayConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpc: fromVirtualGatewayGrpcConnectionPool(input["grpc"]),
    http: fromVirtualGatewayHttpConnectionPool(input["http"]),
    http2: fromVirtualGatewayHttp2ConnectionPool(input["http2"]),
  }
}
function toVirtualGatewayConnectionPool(root: jsonP.JSONValue): s.VirtualGatewayConnectionPool {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpc": toVirtualGatewayGrpcConnectionPool,
      "http": toVirtualGatewayHttpConnectionPool,
      "http2": toVirtualGatewayHttp2ConnectionPool,
    },
  }, root);
}

function fromVirtualGatewayGrpcConnectionPool(input?: s.VirtualGatewayGrpcConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxRequests: input["maxRequests"],
  }
}
function toVirtualGatewayGrpcConnectionPool(root: jsonP.JSONValue): s.VirtualGatewayGrpcConnectionPool {
  return jsonP.readObj({
    required: {
      "maxRequests": "n",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayHttpConnectionPool(input?: s.VirtualGatewayHttpConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxConnections: input["maxConnections"],
    maxPendingRequests: input["maxPendingRequests"],
  }
}
function toVirtualGatewayHttpConnectionPool(root: jsonP.JSONValue): s.VirtualGatewayHttpConnectionPool {
  return jsonP.readObj({
    required: {
      "maxConnections": "n",
    },
    optional: {
      "maxPendingRequests": "n",
    },
  }, root);
}

function fromVirtualGatewayHttp2ConnectionPool(input?: s.VirtualGatewayHttp2ConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxRequests: input["maxRequests"],
  }
}
function toVirtualGatewayHttp2ConnectionPool(root: jsonP.JSONValue): s.VirtualGatewayHttp2ConnectionPool {
  return jsonP.readObj({
    required: {
      "maxRequests": "n",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayHealthCheckPolicy(input?: s.VirtualGatewayHealthCheckPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthyThreshold: input["healthyThreshold"],
    intervalMillis: input["intervalMillis"],
    path: input["path"],
    port: input["port"],
    protocol: input["protocol"],
    timeoutMillis: input["timeoutMillis"],
    unhealthyThreshold: input["unhealthyThreshold"],
  }
}
function toVirtualGatewayHealthCheckPolicy(root: jsonP.JSONValue): s.VirtualGatewayHealthCheckPolicy {
  return jsonP.readObj({
    required: {
      "healthyThreshold": "n",
      "intervalMillis": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualGatewayPortProtocol>(x),
      "timeoutMillis": "n",
      "unhealthyThreshold": "n",
    },
    optional: {
      "path": "s",
      "port": "n",
    },
  }, root);
}

function fromVirtualGatewayPortMapping(input?: s.VirtualGatewayPortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    port: input["port"],
    protocol: input["protocol"],
  }
}
function toVirtualGatewayPortMapping(root: jsonP.JSONValue): s.VirtualGatewayPortMapping {
  return jsonP.readObj({
    required: {
      "port": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualGatewayPortProtocol>(x),
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayListenerTls(input?: s.VirtualGatewayListenerTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromVirtualGatewayListenerTlsCertificate(input["certificate"]),
    mode: input["mode"],
    validation: fromVirtualGatewayListenerTlsValidationContext(input["validation"]),
  }
}
function toVirtualGatewayListenerTls(root: jsonP.JSONValue): s.VirtualGatewayListenerTls {
  return jsonP.readObj({
    required: {
      "certificate": toVirtualGatewayListenerTlsCertificate,
      "mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualGatewayListenerTlsMode>(x),
    },
    optional: {
      "validation": toVirtualGatewayListenerTlsValidationContext,
    },
  }, root);
}

function fromVirtualGatewayListenerTlsCertificate(input?: s.VirtualGatewayListenerTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromVirtualGatewayListenerTlsAcmCertificate(input["acm"]),
    file: fromVirtualGatewayListenerTlsFileCertificate(input["file"]),
    sds: fromVirtualGatewayListenerTlsSdsCertificate(input["sds"]),
  }
}
function toVirtualGatewayListenerTlsCertificate(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toVirtualGatewayListenerTlsAcmCertificate,
      "file": toVirtualGatewayListenerTlsFileCertificate,
      "sds": toVirtualGatewayListenerTlsSdsCertificate,
    },
  }, root);
}

function fromVirtualGatewayListenerTlsAcmCertificate(input?: s.VirtualGatewayListenerTlsAcmCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
  }
}
function toVirtualGatewayListenerTlsAcmCertificate(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsAcmCertificate {
  return jsonP.readObj({
    required: {
      "certificateArn": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualGatewayListenerTlsValidationContext(input?: s.VirtualGatewayListenerTlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subjectAlternativeNames: fromSubjectAlternativeNames(input["subjectAlternativeNames"]),
    trust: fromVirtualGatewayListenerTlsValidationContextTrust(input["trust"]),
  }
}
function toVirtualGatewayListenerTlsValidationContext(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toVirtualGatewayListenerTlsValidationContextTrust,
    },
    optional: {
      "subjectAlternativeNames": toSubjectAlternativeNames,
    },
  }, root);
}

function fromVirtualGatewayListenerTlsValidationContextTrust(input?: s.VirtualGatewayListenerTlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromVirtualGatewayTlsValidationContextFileTrust(input["file"]),
    sds: fromVirtualGatewayTlsValidationContextSdsTrust(input["sds"]),
  }
}
function toVirtualGatewayListenerTlsValidationContextTrust(root: jsonP.JSONValue): s.VirtualGatewayListenerTlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toVirtualGatewayTlsValidationContextFileTrust,
      "sds": toVirtualGatewayTlsValidationContextSdsTrust,
    },
  }, root);
}

function fromVirtualGatewayLogging(input?: s.VirtualGatewayLogging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessLog: fromVirtualGatewayAccessLog(input["accessLog"]),
  }
}
function toVirtualGatewayLogging(root: jsonP.JSONValue): s.VirtualGatewayLogging {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessLog": toVirtualGatewayAccessLog,
    },
  }, root);
}

function fromVirtualGatewayAccessLog(input?: s.VirtualGatewayAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromVirtualGatewayFileAccessLog(input["file"]),
  }
}
function toVirtualGatewayAccessLog(root: jsonP.JSONValue): s.VirtualGatewayAccessLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toVirtualGatewayFileAccessLog,
    },
  }, root);
}

function fromVirtualGatewayFileAccessLog(input?: s.VirtualGatewayFileAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
  }
}
function toVirtualGatewayFileAccessLog(root: jsonP.JSONValue): s.VirtualGatewayFileAccessLog {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualNodeSpec(input?: s.VirtualNodeSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    backendDefaults: fromBackendDefaults(input["backendDefaults"]),
    backends: input["backends"]?.map(x => fromBackend(x)),
    listeners: input["listeners"]?.map(x => fromListener(x)),
    logging: fromLogging(input["logging"]),
    serviceDiscovery: fromServiceDiscovery(input["serviceDiscovery"]),
  }
}
function toVirtualNodeSpec(root: jsonP.JSONValue): s.VirtualNodeSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "backendDefaults": toBackendDefaults,
      "backends": [toBackend],
      "listeners": [toListener],
      "logging": toLogging,
      "serviceDiscovery": toServiceDiscovery,
    },
  }, root);
}

function fromBackendDefaults(input?: s.BackendDefaults | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromClientPolicy(input["clientPolicy"]),
  }
}
function toBackendDefaults(root: jsonP.JSONValue): s.BackendDefaults {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientPolicy": toClientPolicy,
    },
  }, root);
}

function fromClientPolicy(input?: s.ClientPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tls: fromClientPolicyTls(input["tls"]),
  }
}
function toClientPolicy(root: jsonP.JSONValue): s.ClientPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "tls": toClientPolicyTls,
    },
  }, root);
}

function fromClientPolicyTls(input?: s.ClientPolicyTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromClientTlsCertificate(input["certificate"]),
    enforce: input["enforce"],
    ports: input["ports"],
    validation: fromTlsValidationContext(input["validation"]),
  }
}
function toClientPolicyTls(root: jsonP.JSONValue): s.ClientPolicyTls {
  return jsonP.readObj({
    required: {
      "validation": toTlsValidationContext,
    },
    optional: {
      "certificate": toClientTlsCertificate,
      "enforce": "b",
      "ports": ["n"],
    },
  }, root);
}

function fromClientTlsCertificate(input?: s.ClientTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromListenerTlsFileCertificate(input["file"]),
    sds: fromListenerTlsSdsCertificate(input["sds"]),
  }
}
function toClientTlsCertificate(root: jsonP.JSONValue): s.ClientTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toListenerTlsFileCertificate,
      "sds": toListenerTlsSdsCertificate,
    },
  }, root);
}

function fromListenerTlsFileCertificate(input?: s.ListenerTlsFileCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
    privateKey: input["privateKey"],
  }
}
function toListenerTlsFileCertificate(root: jsonP.JSONValue): s.ListenerTlsFileCertificate {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
      "privateKey": "s",
    },
    optional: {},
  }, root);
}

function fromListenerTlsSdsCertificate(input?: s.ListenerTlsSdsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    secretName: input["secretName"],
  }
}
function toListenerTlsSdsCertificate(root: jsonP.JSONValue): s.ListenerTlsSdsCertificate {
  return jsonP.readObj({
    required: {
      "secretName": "s",
    },
    optional: {},
  }, root);
}

function fromTlsValidationContext(input?: s.TlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subjectAlternativeNames: fromSubjectAlternativeNames(input["subjectAlternativeNames"]),
    trust: fromTlsValidationContextTrust(input["trust"]),
  }
}
function toTlsValidationContext(root: jsonP.JSONValue): s.TlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toTlsValidationContextTrust,
    },
    optional: {
      "subjectAlternativeNames": toSubjectAlternativeNames,
    },
  }, root);
}

function fromTlsValidationContextTrust(input?: s.TlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromTlsValidationContextAcmTrust(input["acm"]),
    file: fromTlsValidationContextFileTrust(input["file"]),
    sds: fromTlsValidationContextSdsTrust(input["sds"]),
  }
}
function toTlsValidationContextTrust(root: jsonP.JSONValue): s.TlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toTlsValidationContextAcmTrust,
      "file": toTlsValidationContextFileTrust,
      "sds": toTlsValidationContextSdsTrust,
    },
  }, root);
}

function fromTlsValidationContextAcmTrust(input?: s.TlsValidationContextAcmTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateAuthorityArns: input["certificateAuthorityArns"],
  }
}
function toTlsValidationContextAcmTrust(root: jsonP.JSONValue): s.TlsValidationContextAcmTrust {
  return jsonP.readObj({
    required: {
      "certificateAuthorityArns": ["s"],
    },
    optional: {},
  }, root);
}

function fromTlsValidationContextFileTrust(input?: s.TlsValidationContextFileTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateChain: input["certificateChain"],
  }
}
function toTlsValidationContextFileTrust(root: jsonP.JSONValue): s.TlsValidationContextFileTrust {
  return jsonP.readObj({
    required: {
      "certificateChain": "s",
    },
    optional: {},
  }, root);
}

function fromTlsValidationContextSdsTrust(input?: s.TlsValidationContextSdsTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    secretName: input["secretName"],
  }
}
function toTlsValidationContextSdsTrust(root: jsonP.JSONValue): s.TlsValidationContextSdsTrust {
  return jsonP.readObj({
    required: {
      "secretName": "s",
    },
    optional: {},
  }, root);
}

function fromBackend(input?: s.Backend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualService: fromVirtualServiceBackend(input["virtualService"]),
  }
}
function toBackend(root: jsonP.JSONValue): s.Backend {
  return jsonP.readObj({
    required: {},
    optional: {
      "virtualService": toVirtualServiceBackend,
    },
  }, root);
}

function fromVirtualServiceBackend(input?: s.VirtualServiceBackend | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    clientPolicy: fromClientPolicy(input["clientPolicy"]),
    virtualServiceName: input["virtualServiceName"],
  }
}
function toVirtualServiceBackend(root: jsonP.JSONValue): s.VirtualServiceBackend {
  return jsonP.readObj({
    required: {
      "virtualServiceName": "s",
    },
    optional: {
      "clientPolicy": toClientPolicy,
    },
  }, root);
}

function fromListener(input?: s.Listener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionPool: fromVirtualNodeConnectionPool(input["connectionPool"]),
    healthCheck: fromHealthCheckPolicy(input["healthCheck"]),
    outlierDetection: fromOutlierDetection(input["outlierDetection"]),
    portMapping: fromPortMapping(input["portMapping"]),
    timeout: fromListenerTimeout(input["timeout"]),
    tls: fromListenerTls(input["tls"]),
  }
}
function toListener(root: jsonP.JSONValue): s.Listener {
  return jsonP.readObj({
    required: {
      "portMapping": toPortMapping,
    },
    optional: {
      "connectionPool": toVirtualNodeConnectionPool,
      "healthCheck": toHealthCheckPolicy,
      "outlierDetection": toOutlierDetection,
      "timeout": toListenerTimeout,
      "tls": toListenerTls,
    },
  }, root);
}

function fromVirtualNodeConnectionPool(input?: s.VirtualNodeConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpc: fromVirtualNodeGrpcConnectionPool(input["grpc"]),
    http: fromVirtualNodeHttpConnectionPool(input["http"]),
    http2: fromVirtualNodeHttp2ConnectionPool(input["http2"]),
    tcp: fromVirtualNodeTcpConnectionPool(input["tcp"]),
  }
}
function toVirtualNodeConnectionPool(root: jsonP.JSONValue): s.VirtualNodeConnectionPool {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpc": toVirtualNodeGrpcConnectionPool,
      "http": toVirtualNodeHttpConnectionPool,
      "http2": toVirtualNodeHttp2ConnectionPool,
      "tcp": toVirtualNodeTcpConnectionPool,
    },
  }, root);
}

function fromVirtualNodeGrpcConnectionPool(input?: s.VirtualNodeGrpcConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxRequests: input["maxRequests"],
  }
}
function toVirtualNodeGrpcConnectionPool(root: jsonP.JSONValue): s.VirtualNodeGrpcConnectionPool {
  return jsonP.readObj({
    required: {
      "maxRequests": "n",
    },
    optional: {},
  }, root);
}

function fromVirtualNodeHttpConnectionPool(input?: s.VirtualNodeHttpConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxConnections: input["maxConnections"],
    maxPendingRequests: input["maxPendingRequests"],
  }
}
function toVirtualNodeHttpConnectionPool(root: jsonP.JSONValue): s.VirtualNodeHttpConnectionPool {
  return jsonP.readObj({
    required: {
      "maxConnections": "n",
    },
    optional: {
      "maxPendingRequests": "n",
    },
  }, root);
}

function fromVirtualNodeHttp2ConnectionPool(input?: s.VirtualNodeHttp2ConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxRequests: input["maxRequests"],
  }
}
function toVirtualNodeHttp2ConnectionPool(root: jsonP.JSONValue): s.VirtualNodeHttp2ConnectionPool {
  return jsonP.readObj({
    required: {
      "maxRequests": "n",
    },
    optional: {},
  }, root);
}

function fromVirtualNodeTcpConnectionPool(input?: s.VirtualNodeTcpConnectionPool | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxConnections: input["maxConnections"],
  }
}
function toVirtualNodeTcpConnectionPool(root: jsonP.JSONValue): s.VirtualNodeTcpConnectionPool {
  return jsonP.readObj({
    required: {
      "maxConnections": "n",
    },
    optional: {},
  }, root);
}

function fromHealthCheckPolicy(input?: s.HealthCheckPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    healthyThreshold: input["healthyThreshold"],
    intervalMillis: input["intervalMillis"],
    path: input["path"],
    port: input["port"],
    protocol: input["protocol"],
    timeoutMillis: input["timeoutMillis"],
    unhealthyThreshold: input["unhealthyThreshold"],
  }
}
function toHealthCheckPolicy(root: jsonP.JSONValue): s.HealthCheckPolicy {
  return jsonP.readObj({
    required: {
      "healthyThreshold": "n",
      "intervalMillis": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.PortProtocol>(x),
      "timeoutMillis": "n",
      "unhealthyThreshold": "n",
    },
    optional: {
      "path": "s",
      "port": "n",
    },
  }, root);
}

function fromOutlierDetection(input?: s.OutlierDetection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    baseEjectionDuration: fromDuration(input["baseEjectionDuration"]),
    interval: fromDuration(input["interval"]),
    maxEjectionPercent: input["maxEjectionPercent"],
    maxServerErrors: input["maxServerErrors"],
  }
}
function toOutlierDetection(root: jsonP.JSONValue): s.OutlierDetection {
  return jsonP.readObj({
    required: {
      "baseEjectionDuration": toDuration,
      "interval": toDuration,
      "maxEjectionPercent": "n",
      "maxServerErrors": "n",
    },
    optional: {},
  }, root);
}

function fromPortMapping(input?: s.PortMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    port: input["port"],
    protocol: input["protocol"],
  }
}
function toPortMapping(root: jsonP.JSONValue): s.PortMapping {
  return jsonP.readObj({
    required: {
      "port": "n",
      "protocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.PortProtocol>(x),
    },
    optional: {},
  }, root);
}

function fromListenerTimeout(input?: s.ListenerTimeout | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    grpc: fromGrpcTimeout(input["grpc"]),
    http: fromHttpTimeout(input["http"]),
    http2: fromHttpTimeout(input["http2"]),
    tcp: fromTcpTimeout(input["tcp"]),
  }
}
function toListenerTimeout(root: jsonP.JSONValue): s.ListenerTimeout {
  return jsonP.readObj({
    required: {},
    optional: {
      "grpc": toGrpcTimeout,
      "http": toHttpTimeout,
      "http2": toHttpTimeout,
      "tcp": toTcpTimeout,
    },
  }, root);
}

function fromListenerTls(input?: s.ListenerTls | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificate: fromListenerTlsCertificate(input["certificate"]),
    mode: input["mode"],
    validation: fromListenerTlsValidationContext(input["validation"]),
  }
}
function toListenerTls(root: jsonP.JSONValue): s.ListenerTls {
  return jsonP.readObj({
    required: {
      "certificate": toListenerTlsCertificate,
      "mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ListenerTlsMode>(x),
    },
    optional: {
      "validation": toListenerTlsValidationContext,
    },
  }, root);
}

function fromListenerTlsCertificate(input?: s.ListenerTlsCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acm: fromListenerTlsAcmCertificate(input["acm"]),
    file: fromListenerTlsFileCertificate(input["file"]),
    sds: fromListenerTlsSdsCertificate(input["sds"]),
  }
}
function toListenerTlsCertificate(root: jsonP.JSONValue): s.ListenerTlsCertificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "acm": toListenerTlsAcmCertificate,
      "file": toListenerTlsFileCertificate,
      "sds": toListenerTlsSdsCertificate,
    },
  }, root);
}

function fromListenerTlsAcmCertificate(input?: s.ListenerTlsAcmCertificate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
  }
}
function toListenerTlsAcmCertificate(root: jsonP.JSONValue): s.ListenerTlsAcmCertificate {
  return jsonP.readObj({
    required: {
      "certificateArn": "s",
    },
    optional: {},
  }, root);
}

function fromListenerTlsValidationContext(input?: s.ListenerTlsValidationContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    subjectAlternativeNames: fromSubjectAlternativeNames(input["subjectAlternativeNames"]),
    trust: fromListenerTlsValidationContextTrust(input["trust"]),
  }
}
function toListenerTlsValidationContext(root: jsonP.JSONValue): s.ListenerTlsValidationContext {
  return jsonP.readObj({
    required: {
      "trust": toListenerTlsValidationContextTrust,
    },
    optional: {
      "subjectAlternativeNames": toSubjectAlternativeNames,
    },
  }, root);
}

function fromListenerTlsValidationContextTrust(input?: s.ListenerTlsValidationContextTrust | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromTlsValidationContextFileTrust(input["file"]),
    sds: fromTlsValidationContextSdsTrust(input["sds"]),
  }
}
function toListenerTlsValidationContextTrust(root: jsonP.JSONValue): s.ListenerTlsValidationContextTrust {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toTlsValidationContextFileTrust,
      "sds": toTlsValidationContextSdsTrust,
    },
  }, root);
}

function fromLogging(input?: s.Logging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    accessLog: fromAccessLog(input["accessLog"]),
  }
}
function toLogging(root: jsonP.JSONValue): s.Logging {
  return jsonP.readObj({
    required: {},
    optional: {
      "accessLog": toAccessLog,
    },
  }, root);
}

function fromAccessLog(input?: s.AccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    file: fromFileAccessLog(input["file"]),
  }
}
function toAccessLog(root: jsonP.JSONValue): s.AccessLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "file": toFileAccessLog,
    },
  }, root);
}

function fromFileAccessLog(input?: s.FileAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    path: input["path"],
  }
}
function toFileAccessLog(root: jsonP.JSONValue): s.FileAccessLog {
  return jsonP.readObj({
    required: {
      "path": "s",
    },
    optional: {},
  }, root);
}

function fromServiceDiscovery(input?: s.ServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    awsCloudMap: fromAwsCloudMapServiceDiscovery(input["awsCloudMap"]),
    dns: fromDnsServiceDiscovery(input["dns"]),
  }
}
function toServiceDiscovery(root: jsonP.JSONValue): s.ServiceDiscovery {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsCloudMap": toAwsCloudMapServiceDiscovery,
      "dns": toDnsServiceDiscovery,
    },
  }, root);
}

function fromAwsCloudMapServiceDiscovery(input?: s.AwsCloudMapServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attributes: input["attributes"]?.map(x => fromAwsCloudMapInstanceAttribute(x)),
    namespaceName: input["namespaceName"],
    serviceName: input["serviceName"],
  }
}
function toAwsCloudMapServiceDiscovery(root: jsonP.JSONValue): s.AwsCloudMapServiceDiscovery {
  return jsonP.readObj({
    required: {
      "namespaceName": "s",
      "serviceName": "s",
    },
    optional: {
      "attributes": [toAwsCloudMapInstanceAttribute],
    },
  }, root);
}

function fromAwsCloudMapInstanceAttribute(input?: s.AwsCloudMapInstanceAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toAwsCloudMapInstanceAttribute(root: jsonP.JSONValue): s.AwsCloudMapInstanceAttribute {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromDnsServiceDiscovery(input?: s.DnsServiceDiscovery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hostname: input["hostname"],
  }
}
function toDnsServiceDiscovery(root: jsonP.JSONValue): s.DnsServiceDiscovery {
  return jsonP.readObj({
    required: {
      "hostname": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualRouterSpec(input?: s.VirtualRouterSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    listeners: input["listeners"]?.map(x => fromVirtualRouterListener(x)),
  }
}
function toVirtualRouterSpec(root: jsonP.JSONValue): s.VirtualRouterSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "listeners": [toVirtualRouterListener],
    },
  }, root);
}

function fromVirtualRouterListener(input?: s.VirtualRouterListener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    portMapping: fromPortMapping(input["portMapping"]),
  }
}
function toVirtualRouterListener(root: jsonP.JSONValue): s.VirtualRouterListener {
  return jsonP.readObj({
    required: {
      "portMapping": toPortMapping,
    },
    optional: {},
  }, root);
}

function fromVirtualServiceSpec(input?: s.VirtualServiceSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    provider: fromVirtualServiceProvider(input["provider"]),
  }
}
function toVirtualServiceSpec(root: jsonP.JSONValue): s.VirtualServiceSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "provider": toVirtualServiceProvider,
    },
  }, root);
}

function fromVirtualServiceProvider(input?: s.VirtualServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNode: fromVirtualNodeServiceProvider(input["virtualNode"]),
    virtualRouter: fromVirtualRouterServiceProvider(input["virtualRouter"]),
  }
}
function toVirtualServiceProvider(root: jsonP.JSONValue): s.VirtualServiceProvider {
  return jsonP.readObj({
    required: {},
    optional: {
      "virtualNode": toVirtualNodeServiceProvider,
      "virtualRouter": toVirtualRouterServiceProvider,
    },
  }, root);
}

function fromVirtualNodeServiceProvider(input?: s.VirtualNodeServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualNodeName: input["virtualNodeName"],
  }
}
function toVirtualNodeServiceProvider(root: jsonP.JSONValue): s.VirtualNodeServiceProvider {
  return jsonP.readObj({
    required: {
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

function fromVirtualRouterServiceProvider(input?: s.VirtualRouterServiceProvider | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualRouterName: input["virtualRouterName"],
  }
}
function toVirtualRouterServiceProvider(root: jsonP.JSONValue): s.VirtualRouterServiceProvider {
  return jsonP.readObj({
    required: {
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

function toGatewayRouteData(root: jsonP.JSONValue): s.GatewayRouteData {
  return jsonP.readObj({
    required: {
      "gatewayRouteName": "s",
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toGatewayRouteSpec,
      "status": toGatewayRouteStatus,
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

function toResourceMetadata(root: jsonP.JSONValue): s.ResourceMetadata {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshOwner": "s",
      "resourceOwner": "s",
      "uid": "s",
      "version": "n",
    },
    optional: {},
  }, root);
}

function toGatewayRouteStatus(root: jsonP.JSONValue): s.GatewayRouteStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayRouteStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toMeshData(root: jsonP.JSONValue): s.MeshData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toMeshSpec,
      "status": toMeshStatus,
    },
    optional: {},
  }, root);
}

function toMeshStatus(root: jsonP.JSONValue): s.MeshStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.MeshStatusCode>(x),
    },
  }, root);
}

function toRouteData(root: jsonP.JSONValue): s.RouteData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "routeName": "s",
      "spec": toRouteSpec,
      "status": toRouteStatus,
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

function toRouteStatus(root: jsonP.JSONValue): s.RouteStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RouteStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toVirtualGatewayData(root: jsonP.JSONValue): s.VirtualGatewayData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualGatewaySpec,
      "status": toVirtualGatewayStatus,
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualGatewayStatus(root: jsonP.JSONValue): s.VirtualGatewayStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualGatewayStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toVirtualNodeData(root: jsonP.JSONValue): s.VirtualNodeData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualNodeSpec,
      "status": toVirtualNodeStatus,
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualNodeStatus(root: jsonP.JSONValue): s.VirtualNodeStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualNodeStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toVirtualRouterData(root: jsonP.JSONValue): s.VirtualRouterData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualRouterSpec,
      "status": toVirtualRouterStatus,
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualRouterStatus(root: jsonP.JSONValue): s.VirtualRouterStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualRouterStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toVirtualServiceData(root: jsonP.JSONValue): s.VirtualServiceData {
  return jsonP.readObj({
    required: {
      "meshName": "s",
      "metadata": toResourceMetadata,
      "spec": toVirtualServiceSpec,
      "status": toVirtualServiceStatus,
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualServiceStatus(root: jsonP.JSONValue): s.VirtualServiceStatus {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualServiceStatusCode>(x),
    },
    optional: {},
  }, root);
}

function toGatewayRouteRef(root: jsonP.JSONValue): s.GatewayRouteRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "gatewayRouteName": "s",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

function toMeshRef(root: jsonP.JSONValue): s.MeshRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
    },
    optional: {},
  }, root);
}

function toRouteRef(root: jsonP.JSONValue): s.RouteRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "routeName": "s",
      "version": "n",
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualGatewayRef(root: jsonP.JSONValue): s.VirtualGatewayRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualGatewayName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualNodeRef(root: jsonP.JSONValue): s.VirtualNodeRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualNodeName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualRouterRef(root: jsonP.JSONValue): s.VirtualRouterRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualRouterName": "s",
    },
    optional: {},
  }, root);
}

function toVirtualServiceRef(root: jsonP.JSONValue): s.VirtualServiceRef {
  return jsonP.readObj({
    required: {
      "arn": "s",
      "createdAt": "d",
      "lastUpdatedAt": "d",
      "meshName": "s",
      "meshOwner": "s",
      "resourceOwner": "s",
      "version": "n",
      "virtualServiceName": "s",
    },
    optional: {},
  }, root);
}
