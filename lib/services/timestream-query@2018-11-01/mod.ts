// Autogenerated API client for: Amazon Timestream Query

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class TimestreamQuery {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(TimestreamQuery.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-11-01",
    "endpointPrefix": "query.timestream",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "Timestream Query",
    "serviceFullName": "Amazon Timestream Query",
    "serviceId": "Timestream Query",
    "signatureVersion": "v4",
    "signingName": "timestream",
    "targetPrefix": "Timestream_20181101",
    "uid": "timestream-query-2018-11-01"
  };

  async cancelQuery(
    {abortSignal, ...params}: RequestConfig & CancelQueryRequest,
  ): Promise<CancelQueryResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelQuery",
    });
    return prt.readObj({
      required: {},
      optional: {
        "CancellationMessage": "s",
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointsRequest = {},
  ): Promise<DescribeEndpointsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return prt.readObj({
      required: {
        "Endpoints": [toEndpoint],
      },
      optional: {},
    }, await resp.json());
  }

  async query(
    {abortSignal, ...params}: RequestConfig & QueryRequest,
  ): Promise<QueryResponse> {
    const body: JSONObject = {...params,
    ClientToken: params["ClientToken"] ?? generateIdemptToken(),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Query",
    });
    return prt.readObj({
      required: {
        "QueryId": "s",
        "Rows": [toRow],
        "ColumnInfo": [toColumnInfo],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CancelQueryRequest {
  QueryId: string;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointsRequest {
}

// refs: 1 - tags: named, input
export interface QueryRequest {
  QueryString: string;
  ClientToken?: string | null;
  NextToken?: string | null;
  MaxRows?: number | null;
}

// refs: 1 - tags: named, output
export interface CancelQueryResponse {
  CancellationMessage?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointsResponse {
  Endpoints: Endpoint[];
}

// refs: 1 - tags: named, output
export interface QueryResponse {
  QueryId: string;
  NextToken?: string | null;
  Rows: Row[];
  ColumnInfo: ColumnInfo[];
}

// refs: 1 - tags: output, named, interface
export interface Endpoint {
  Address: string;
  CachePeriodInMinutes: number;
}
function toEndpoint(root: JSONValue): Endpoint {
  return prt.readObj({
    required: {
      "Address": "s",
      "CachePeriodInMinutes": "n",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface, recursed
export interface Row {
  Data: Datum[];
}
function toRow(root: JSONValue): Row {
  return prt.readObj({
    required: {
      "Data": [toDatum],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface, recursed, recursive
export interface Datum {
  ScalarValue?: string | null;
  TimeSeriesValue?: TimeSeriesDataPoint[] | null;
  ArrayValue?: Datum[] | null;
  RowValue?: Row | null;
  NullValue?: boolean | null;
}
function toDatum(root: JSONValue): Datum {
  return prt.readObj({
    required: {},
    optional: {
      "ScalarValue": "s",
      "TimeSeriesValue": [toTimeSeriesDataPoint],
      "ArrayValue": [toDatum],
      "RowValue": toRow,
      "NullValue": "b",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface, recursive
export interface TimeSeriesDataPoint {
  Time: string;
  Value: Datum;
}
function toTimeSeriesDataPoint(root: JSONValue): TimeSeriesDataPoint {
  return prt.readObj({
    required: {
      "Time": "s",
      "Value": toDatum,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: output, named, interface, recursed
export interface ColumnInfo {
  Name?: string | null;
  Type: Type;
}
function toColumnInfo(root: JSONValue): ColumnInfo {
  return prt.readObj({
    required: {
      "Type": toType,
    },
    optional: {
      "Name": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface, recursive
export interface Type {
  ScalarType?: ScalarType | null;
  ArrayColumnInfo?: ColumnInfo | null;
  TimeSeriesMeasureValueColumnInfo?: ColumnInfo | null;
  RowColumnInfo?: ColumnInfo[] | null;
}
function toType(root: JSONValue): Type {
  return prt.readObj({
    required: {},
    optional: {
      "ScalarType": toScalarType,
      "ArrayColumnInfo": toColumnInfo,
      "TimeSeriesMeasureValueColumnInfo": toColumnInfo,
      "RowColumnInfo": [toColumnInfo],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ScalarType =
| "VARCHAR"
| "BOOLEAN"
| "BIGINT"
| "DOUBLE"
| "TIMESTAMP"
| "DATE"
| "TIME"
| "INTERVAL_DAY_TO_SECOND"
| "INTERVAL_YEAR_TO_MONTH"
| "UNKNOWN"
| "INTEGER"
;
function toScalarType(root: JSONValue): ScalarType | null {
  return ( false
    || root == "VARCHAR"
    || root == "BOOLEAN"
    || root == "BIGINT"
    || root == "DOUBLE"
    || root == "TIMESTAMP"
    || root == "DATE"
    || root == "TIME"
    || root == "INTERVAL_DAY_TO_SECOND"
    || root == "INTERVAL_YEAR_TO_MONTH"
    || root == "UNKNOWN"
    || root == "INTEGER"
  ) ? root : null;
}
