// Autogenerated API client for: AWS S3 Control

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.75.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class S3Control {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(S3Control.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-08-20",
    "endpointPrefix": "s3-control",
    "protocol": "rest-xml",
    "serviceFullName": "AWS S3 Control",
    "serviceId": "S3 Control",
    "signatureVersion": "s3v4",
    "signingName": "s3",
    "uid": "s3control-2018-08-20"
  };

  async createAccessPoint(
    {abortSignal, ...params}: RequestConfig & CreateAccessPointRequest,
  ): Promise<CreateAccessPointResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "CreateAccessPointRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Bucket", content: params["Bucket"]?.toString()},
        {name: "VpcConfiguration", ...VpcConfiguration_Serialize(params["VpcConfiguration"])},
        {name: "PublicAccessBlockConfiguration", ...PublicAccessBlockConfiguration_Serialize(params["PublicAccessBlockConfiguration"])},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateAccessPoint",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"AccessPointArn":true},
    });
  }

  async createBucket(
    {abortSignal, ...params}: RequestConfig & CreateBucketRequest,
  ): Promise<CreateBucketResult> {
    const inner = params["CreateBucketConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CreateBucketConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "LocationConstraint", content: inner["LocationConstraint"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ObjectLockEnabledForBucket"] != null) headers.append("x-amz-bucket-object-lock-enabled", params["ObjectLockEnabledForBucket"]?.toString() ?? '');
    if (params["OutpostId"] != null) headers.append("x-amz-outpost-id", params["OutpostId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateBucket",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location"),
      ...xml.strings({
        optional: {"BucketArn":true},
      }),
    };
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & CreateJobRequest,
  ): Promise<CreateJobResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "CreateJobRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "ConfirmationRequired", content: params["ConfirmationRequired"]?.toString()},
        {name: "Operation", ...JobOperation_Serialize(params["Operation"])},
        {name: "Report", ...JobReport_Serialize(params["Report"])},
        {name: "ClientRequestToken", content: (params["ClientRequestToken"] ?? generateIdemptToken()).toString()},
        {name: "Manifest", ...JobManifest_Serialize(params["Manifest"])},
        {name: "Description", content: params["Description"]?.toString()},
        {name: "Priority", content: params["Priority"]?.toString()},
        {name: "RoleArn", content: params["RoleArn"]?.toString()},
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateJob",
      requestUri: "/v20180820/jobs",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async deleteAccessPoint(
    {abortSignal, ...params}: RequestConfig & DeleteAccessPointRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteAccessPoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteAccessPointPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteAccessPointPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucket(
    {abortSignal, ...params}: RequestConfig & DeleteBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucket",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketLifecycleConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketTagging(
    {abortSignal, ...params}: RequestConfig & DeleteBucketTaggingRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      responseCode: 204,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteJobTagging(
    {abortSignal, ...params}: RequestConfig & DeleteJobTaggingRequest,
  ): Promise<DeleteJobTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteJobTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async deletePublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & DeletePublicAccessBlockRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeletePublicAccessBlock",
      method: "DELETE",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteStorageLensConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStorageLensConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & DeleteStorageLensConfigurationTaggingRequest,
  ): Promise<DeleteStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStorageLensConfigurationTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & DescribeJobRequest,
  ): Promise<DescribeJobResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Job: xml.first("Job", false, JobDescriptor_Parse),
    };
  }

  async getAccessPoint(
    {abortSignal, ...params}: RequestConfig & GetAccessPointRequest,
  ): Promise<GetAccessPointResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPoint",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Name":true,"Bucket":true},
      }),
      NetworkOrigin: xml.first("NetworkOrigin", false, x => (x.content ?? '') as NetworkOrigin),
      VpcConfiguration: xml.first("VpcConfiguration", false, VpcConfiguration_Parse),
      PublicAccessBlockConfiguration: xml.first("PublicAccessBlockConfiguration", false, PublicAccessBlockConfiguration_Parse),
      CreationDate: xml.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & GetAccessPointPolicyRequest,
  ): Promise<GetAccessPointPolicyResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPointPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"Policy":true},
    });
  }

  async getAccessPointPolicyStatus(
    {abortSignal, ...params}: RequestConfig & GetAccessPointPolicyStatusRequest,
  ): Promise<GetAccessPointPolicyStatusResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPointPolicyStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policyStatus`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PolicyStatus: xml.first("PolicyStatus", false, PolicyStatus_Parse),
    };
  }

  async getBucket(
    {abortSignal, ...params}: RequestConfig & GetBucketRequest,
  ): Promise<GetBucketResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucket",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Bucket":true},
      }),
      PublicAccessBlockEnabled: xml.first("PublicAccessBlockEnabled", false, x => x.content === 'true'),
      CreationDate: xml.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBucketLifecycleConfigurationRequest,
  ): Promise<GetBucketLifecycleConfigurationResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLifecycleConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rules", "Rule").map(LifecycleRule_Parse),
    };
  }

  async getBucketPolicy(
    {abortSignal, ...params}: RequestConfig & GetBucketPolicyRequest,
  ): Promise<GetBucketPolicyResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"Policy":true},
    });
  }

  async getBucketTagging(
    {abortSignal, ...params}: RequestConfig & GetBucketTaggingRequest,
  ): Promise<GetBucketTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TagSet: xml.getList("TagSet", "member").map(S3Tag_Parse),
    };
  }

  async getJobTagging(
    {abortSignal, ...params}: RequestConfig & GetJobTaggingRequest,
  ): Promise<GetJobTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetJobTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Tags: xml.getList("Tags", "member").map(S3Tag_Parse),
    };
  }

  async getPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & GetPublicAccessBlockRequest,
  ): Promise<GetPublicAccessBlockOutput> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetPublicAccessBlock",
      method: "GET",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PublicAccessBlockConfiguration: PublicAccessBlockConfiguration_Parse(xml),
  };
  }

  async getStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & GetStorageLensConfigurationRequest,
  ): Promise<GetStorageLensConfigurationResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetStorageLensConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StorageLensConfiguration: StorageLensConfiguration_Parse(xml),
  };
  }

  async getStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & GetStorageLensConfigurationTaggingRequest,
  ): Promise<GetStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetStorageLensConfigurationTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Tags: xml.getList("Tags", "Tag").map(StorageLensTag_Parse),
    };
  }

  async listAccessPoints(
    {abortSignal, ...params}: RequestConfig & ListAccessPointsRequest,
  ): Promise<ListAccessPointsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["Bucket"] != null) query.set("bucket", params["Bucket"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListAccessPoints",
      method: "GET",
      requestUri: "/v20180820/accesspoint",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AccessPointList: xml.getList("AccessPointList", "AccessPoint").map(AccessPoint_Parse),
    };
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsRequest,
  ): Promise<ListJobsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    for (const item of params["JobStatuses"] ?? []) {
      query.append("jobStatuses", item?.toString() ?? "");
    }
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/v20180820/jobs",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Jobs: xml.getList("Jobs", "member").map(JobListDescriptor_Parse),
    };
  }

  async listRegionalBuckets(
    {abortSignal, ...params}: RequestConfig & ListRegionalBucketsRequest,
  ): Promise<ListRegionalBucketsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["OutpostId"] != null) headers.append("x-amz-outpost-id", params["OutpostId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListRegionalBuckets",
      method: "GET",
      requestUri: "/v20180820/bucket",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RegionalBucketList: xml.getList("RegionalBucketList", "RegionalBucket").map(RegionalBucket_Parse),
    };
  }

  async listStorageLensConfigurations(
    {abortSignal, ...params}: RequestConfig & ListStorageLensConfigurationsRequest,
  ): Promise<ListStorageLensConfigurationsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListStorageLensConfigurations",
      method: "GET",
      requestUri: "/v20180820/storagelens",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StorageLensConfigurationList: xml.getList("StorageLensConfiguration").map(ListStorageLensConfigurationEntry_Parse),
    };
  }

  async putAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & PutAccessPointPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutAccessPointPolicyRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Policy", content: params["Policy"]?.toString()},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutAccessPointPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Rules", children: inner["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketLifecycleConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketPolicy(
    {abortSignal, ...params}: RequestConfig & PutBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutBucketPolicyRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Policy", content: params["Policy"]?.toString()},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["ConfirmRemoveSelfBucketAccess"] != null) headers.append("x-amz-confirm-remove-self-bucket-access", params["ConfirmRemoveSelfBucketAccess"]?.toString() ?? '');
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketTagging(
    {abortSignal, ...params}: RequestConfig & PutBucketTaggingRequest,
  ): Promise<void> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putJobTagging(
    {abortSignal, ...params}: RequestConfig & PutJobTaggingRequest,
  ): Promise<PutJobTaggingResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutJobTaggingRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutJobTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async putPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & PutPublicAccessBlockRequest,
  ): Promise<void> {
    const inner = params["PublicAccessBlockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "PublicAccessBlockConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "BlockPublicAcls", content: inner["BlockPublicAcls"]?.toString()},
        {name: "IgnorePublicAcls", content: inner["IgnorePublicAcls"]?.toString()},
        {name: "BlockPublicPolicy", content: inner["BlockPublicPolicy"]?.toString()},
        {name: "RestrictPublicBuckets", content: inner["RestrictPublicBuckets"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutPublicAccessBlock",
      method: "PUT",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & PutStorageLensConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutStorageLensConfigurationRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "StorageLensConfiguration", ...StorageLensConfiguration_Serialize(params["StorageLensConfiguration"])},
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "Tag", ...StorageLensTag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutStorageLensConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & PutStorageLensConfigurationTaggingRequest,
  ): Promise<PutStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutStorageLensConfigurationTaggingRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "Tag", ...StorageLensTag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutStorageLensConfigurationTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async updateJobPriority(
    {abortSignal, ...params}: RequestConfig & UpdateJobPriorityRequest,
  ): Promise<UpdateJobPriorityResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    query.set("priority", params["Priority"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "UpdateJobPriority",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/priority`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"JobId":true},
      }),
      Priority: xml.first("Priority", true, x => parseInt(x.content ?? '0')),
    };
  }

  async updateJobStatus(
    {abortSignal, ...params}: RequestConfig & UpdateJobStatusRequest,
  ): Promise<UpdateJobStatusResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    query.set("requestedJobStatus", params["RequestedJobStatus"]?.toString() ?? "");
    if (params["StatusUpdateReason"] != null) query.set("statusUpdateReason", params["StatusUpdateReason"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "UpdateJobStatus",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/status`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"JobId":true,"StatusUpdateReason":true},
      }),
      Status: xml.first("Status", false, x => (x.content ?? '') as JobStatus),
    };
  }

}

// refs: 1 - tags: named, input
export interface CreateAccessPointRequest {
  AccountId: string;
  Name: string;
  Bucket: string;
  VpcConfiguration?: VpcConfiguration | null;
  PublicAccessBlockConfiguration?: PublicAccessBlockConfiguration | null;
}

// refs: 1 - tags: named, input
export interface CreateBucketRequest {
  ACL?: BucketCannedACL | null;
  Bucket: string;
  CreateBucketConfiguration?: CreateBucketConfiguration | null;
  GrantFullControl?: string | null;
  GrantRead?: string | null;
  GrantReadACP?: string | null;
  GrantWrite?: string | null;
  GrantWriteACP?: string | null;
  ObjectLockEnabledForBucket?: boolean | null;
  OutpostId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateJobRequest {
  AccountId: string;
  ConfirmationRequired?: boolean | null;
  Operation: JobOperation;
  Report: JobReport;
  ClientRequestToken: string;
  Manifest: JobManifest;
  Description?: string | null;
  Priority: number;
  RoleArn: string;
  Tags?: S3Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAccessPointRequest {
  AccountId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteAccessPointPolicyRequest {
  AccountId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteBucketRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface DeleteBucketLifecycleConfigurationRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface DeleteBucketPolicyRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface DeleteBucketTaggingRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface DeleteJobTaggingRequest {
  AccountId: string;
  JobId: string;
}

// refs: 1 - tags: named, input
export interface DeletePublicAccessBlockRequest {
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface DeleteStorageLensConfigurationRequest {
  ConfigId: string;
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface DeleteStorageLensConfigurationTaggingRequest {
  ConfigId: string;
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobRequest {
  AccountId: string;
  JobId: string;
}

// refs: 1 - tags: named, input
export interface GetAccessPointRequest {
  AccountId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetAccessPointPolicyRequest {
  AccountId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetAccessPointPolicyStatusRequest {
  AccountId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetBucketRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface GetBucketLifecycleConfigurationRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface GetBucketPolicyRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface GetBucketTaggingRequest {
  AccountId: string;
  Bucket: string;
}

// refs: 1 - tags: named, input
export interface GetJobTaggingRequest {
  AccountId: string;
  JobId: string;
}

// refs: 1 - tags: named, input
export interface GetPublicAccessBlockRequest {
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface GetStorageLensConfigurationRequest {
  ConfigId: string;
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface GetStorageLensConfigurationTaggingRequest {
  ConfigId: string;
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface ListAccessPointsRequest {
  AccountId: string;
  Bucket?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListJobsRequest {
  AccountId: string;
  JobStatuses?: JobStatus[] | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRegionalBucketsRequest {
  AccountId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  OutpostId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStorageLensConfigurationsRequest {
  AccountId: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutAccessPointPolicyRequest {
  AccountId: string;
  Name: string;
  Policy: string;
}

// refs: 1 - tags: named, input
export interface PutBucketLifecycleConfigurationRequest {
  AccountId: string;
  Bucket: string;
  LifecycleConfiguration?: LifecycleConfiguration | null;
}

// refs: 1 - tags: named, input
export interface PutBucketPolicyRequest {
  AccountId: string;
  Bucket: string;
  ConfirmRemoveSelfBucketAccess?: boolean | null;
  Policy: string;
}

// refs: 1 - tags: named, input
export interface PutBucketTaggingRequest {
  AccountId: string;
  Bucket: string;
  Tagging: Tagging;
}

// refs: 1 - tags: named, input
export interface PutJobTaggingRequest {
  AccountId: string;
  JobId: string;
  Tags: S3Tag[];
}

// refs: 1 - tags: named, input
export interface PutPublicAccessBlockRequest {
  PublicAccessBlockConfiguration: PublicAccessBlockConfiguration;
  AccountId: string;
}

// refs: 1 - tags: named, input
export interface PutStorageLensConfigurationRequest {
  ConfigId: string;
  AccountId: string;
  StorageLensConfiguration: StorageLensConfiguration;
  Tags?: StorageLensTag[] | null;
}

// refs: 1 - tags: named, input
export interface PutStorageLensConfigurationTaggingRequest {
  ConfigId: string;
  AccountId: string;
  Tags: StorageLensTag[];
}

// refs: 1 - tags: named, input
export interface UpdateJobPriorityRequest {
  AccountId: string;
  JobId: string;
  Priority: number;
}

// refs: 1 - tags: named, input
export interface UpdateJobStatusRequest {
  AccountId: string;
  JobId: string;
  RequestedJobStatus: RequestedJobStatus;
  StatusUpdateReason?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAccessPointResult {
  AccessPointArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateBucketResult {
  Location?: string | null;
  BucketArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateJobResult {
  JobId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteJobTaggingResult {
}

// refs: 1 - tags: named, output
export interface DeleteStorageLensConfigurationTaggingResult {
}

// refs: 1 - tags: named, output
export interface DescribeJobResult {
  Job?: JobDescriptor | null;
}

// refs: 1 - tags: named, output
export interface GetAccessPointResult {
  Name?: string | null;
  Bucket?: string | null;
  NetworkOrigin?: NetworkOrigin | null;
  VpcConfiguration?: VpcConfiguration | null;
  PublicAccessBlockConfiguration?: PublicAccessBlockConfiguration | null;
  CreationDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetAccessPointPolicyResult {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetAccessPointPolicyStatusResult {
  PolicyStatus?: PolicyStatus | null;
}

// refs: 1 - tags: named, output
export interface GetBucketResult {
  Bucket?: string | null;
  PublicAccessBlockEnabled?: boolean | null;
  CreationDate?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetBucketLifecycleConfigurationResult {
  Rules: LifecycleRule[];
}

// refs: 1 - tags: named, output
export interface GetBucketPolicyResult {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetBucketTaggingResult {
  TagSet: S3Tag[];
}

// refs: 1 - tags: named, output
export interface GetJobTaggingResult {
  Tags: S3Tag[];
}

// refs: 1 - tags: named, output
export interface GetPublicAccessBlockOutput {
  PublicAccessBlockConfiguration?: PublicAccessBlockConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetStorageLensConfigurationResult {
  StorageLensConfiguration?: StorageLensConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetStorageLensConfigurationTaggingResult {
  Tags: StorageLensTag[];
}

// refs: 1 - tags: named, output
export interface ListAccessPointsResult {
  AccessPointList: AccessPoint[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsResult {
  NextToken?: string | null;
  Jobs: JobListDescriptor[];
}

// refs: 1 - tags: named, output
export interface ListRegionalBucketsResult {
  RegionalBucketList: RegionalBucket[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStorageLensConfigurationsResult {
  NextToken?: string | null;
  StorageLensConfigurationList: ListStorageLensConfigurationEntry[];
}

// refs: 1 - tags: named, output
export interface PutJobTaggingResult {
}

// refs: 1 - tags: named, output
export interface PutStorageLensConfigurationTaggingResult {
}

// refs: 1 - tags: named, output
export interface UpdateJobPriorityResult {
  JobId: string;
  Priority: number;
}

// refs: 1 - tags: named, output
export interface UpdateJobStatusResult {
  JobId?: string | null;
  Status?: JobStatus | null;
  StatusUpdateReason?: string | null;
}

// refs: 3 - tags: input, named, interface, output
export interface VpcConfiguration {
  VpcId: string;
}
function VpcConfiguration_Serialize(data: VpcConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "VpcId", content: data["VpcId"]?.toString()},
  ]};
}
function VpcConfiguration_Parse(node: xmlP.XmlNode): VpcConfiguration {
  return node.strings({
    required: {"VpcId":true},
  });
}

// refs: 4 - tags: input, named, interface, output
export interface PublicAccessBlockConfiguration {
  BlockPublicAcls?: boolean | null;
  IgnorePublicAcls?: boolean | null;
  BlockPublicPolicy?: boolean | null;
  RestrictPublicBuckets?: boolean | null;
}
function PublicAccessBlockConfiguration_Serialize(data: PublicAccessBlockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BlockPublicAcls", content: data["BlockPublicAcls"]?.toString()},
    {name: "IgnorePublicAcls", content: data["IgnorePublicAcls"]?.toString()},
    {name: "BlockPublicPolicy", content: data["BlockPublicPolicy"]?.toString()},
    {name: "RestrictPublicBuckets", content: data["RestrictPublicBuckets"]?.toString()},
  ]};
}
function PublicAccessBlockConfiguration_Parse(node: xmlP.XmlNode): PublicAccessBlockConfiguration {
  return {
    BlockPublicAcls: node.first("BlockPublicAcls", false, x => x.content === 'true'),
    IgnorePublicAcls: node.first("IgnorePublicAcls", false, x => x.content === 'true'),
    BlockPublicPolicy: node.first("BlockPublicPolicy", false, x => x.content === 'true'),
    RestrictPublicBuckets: node.first("RestrictPublicBuckets", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, enum
export type BucketCannedACL =
| "private"
| "public-read"
| "public-read-write"
| "authenticated-read"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CreateBucketConfiguration {
  LocationConstraint?: BucketLocationConstraint | null;
}
function CreateBucketConfiguration_Serialize(data: CreateBucketConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LocationConstraint", content: data["LocationConstraint"]?.toString()},
  ]};
}

// refs: 1 - tags: input, named, enum
export type BucketLocationConstraint =
| "EU"
| "eu-west-1"
| "us-west-1"
| "us-west-2"
| "ap-south-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-northeast-1"
| "sa-east-1"
| "cn-north-1"
| "eu-central-1"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface JobOperation {
  LambdaInvoke?: LambdaInvokeOperation | null;
  S3PutObjectCopy?: S3CopyObjectOperation | null;
  S3PutObjectAcl?: S3SetObjectAclOperation | null;
  S3PutObjectTagging?: S3SetObjectTaggingOperation | null;
  S3InitiateRestoreObject?: S3InitiateRestoreObjectOperation | null;
  S3PutObjectLegalHold?: S3SetObjectLegalHoldOperation | null;
  S3PutObjectRetention?: S3SetObjectRetentionOperation | null;
}
function JobOperation_Serialize(data: JobOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaInvoke", ...LambdaInvokeOperation_Serialize(data["LambdaInvoke"])},
    {name: "S3PutObjectCopy", ...S3CopyObjectOperation_Serialize(data["S3PutObjectCopy"])},
    {name: "S3PutObjectAcl", ...S3SetObjectAclOperation_Serialize(data["S3PutObjectAcl"])},
    {name: "S3PutObjectTagging", ...S3SetObjectTaggingOperation_Serialize(data["S3PutObjectTagging"])},
    {name: "S3InitiateRestoreObject", ...S3InitiateRestoreObjectOperation_Serialize(data["S3InitiateRestoreObject"])},
    {name: "S3PutObjectLegalHold", ...S3SetObjectLegalHoldOperation_Serialize(data["S3PutObjectLegalHold"])},
    {name: "S3PutObjectRetention", ...S3SetObjectRetentionOperation_Serialize(data["S3PutObjectRetention"])},
  ]};
}
function JobOperation_Parse(node: xmlP.XmlNode): JobOperation {
  return {
    LambdaInvoke: node.first("LambdaInvoke", false, LambdaInvokeOperation_Parse),
    S3PutObjectCopy: node.first("S3PutObjectCopy", false, S3CopyObjectOperation_Parse),
    S3PutObjectAcl: node.first("S3PutObjectAcl", false, S3SetObjectAclOperation_Parse),
    S3PutObjectTagging: node.first("S3PutObjectTagging", false, S3SetObjectTaggingOperation_Parse),
    S3InitiateRestoreObject: node.first("S3InitiateRestoreObject", false, S3InitiateRestoreObjectOperation_Parse),
    S3PutObjectLegalHold: node.first("S3PutObjectLegalHold", false, S3SetObjectLegalHoldOperation_Parse),
    S3PutObjectRetention: node.first("S3PutObjectRetention", false, S3SetObjectRetentionOperation_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LambdaInvokeOperation {
  FunctionArn?: string | null;
}
function LambdaInvokeOperation_Serialize(data: LambdaInvokeOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "FunctionArn", content: data["FunctionArn"]?.toString()},
  ]};
}
function LambdaInvokeOperation_Parse(node: xmlP.XmlNode): LambdaInvokeOperation {
  return node.strings({
    optional: {"FunctionArn":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface S3CopyObjectOperation {
  TargetResource?: string | null;
  CannedAccessControlList?: S3CannedAccessControlList | null;
  AccessControlGrants: S3Grant[];
  MetadataDirective?: S3MetadataDirective | null;
  ModifiedSinceConstraint?: Date | number | null;
  NewObjectMetadata?: S3ObjectMetadata | null;
  NewObjectTagging: S3Tag[];
  RedirectLocation?: string | null;
  RequesterPays?: boolean | null;
  StorageClass?: S3StorageClass | null;
  UnModifiedSinceConstraint?: Date | number | null;
  SSEAwsKmsKeyId?: string | null;
  TargetKeyPrefix?: string | null;
  ObjectLockLegalHoldStatus?: S3ObjectLockLegalHoldStatus | null;
  ObjectLockMode?: S3ObjectLockMode | null;
  ObjectLockRetainUntilDate?: Date | number | null;
}
function S3CopyObjectOperation_Serialize(data: S3CopyObjectOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetResource", content: data["TargetResource"]?.toString()},
    {name: "CannedAccessControlList", content: data["CannedAccessControlList"]?.toString()},
    {name: "AccessControlGrants", children: data["AccessControlGrants"]?.map(x => ({name: "member", ...S3Grant_Serialize(x)}))},
    {name: "MetadataDirective", content: data["MetadataDirective"]?.toString()},
    {name: "ModifiedSinceConstraint", content: cmnP.serializeDate_iso8601(data["ModifiedSinceConstraint"])},
    {name: "NewObjectMetadata", ...S3ObjectMetadata_Serialize(data["NewObjectMetadata"])},
    {name: "NewObjectTagging", children: data["NewObjectTagging"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
    {name: "RedirectLocation", content: data["RedirectLocation"]?.toString()},
    {name: "RequesterPays", content: data["RequesterPays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
    {name: "UnModifiedSinceConstraint", content: cmnP.serializeDate_iso8601(data["UnModifiedSinceConstraint"])},
    {name: "SSEAwsKmsKeyId", content: data["SSEAwsKmsKeyId"]?.toString()},
    {name: "TargetKeyPrefix", content: data["TargetKeyPrefix"]?.toString()},
    {name: "ObjectLockLegalHoldStatus", content: data["ObjectLockLegalHoldStatus"]?.toString()},
    {name: "ObjectLockMode", content: data["ObjectLockMode"]?.toString()},
    {name: "ObjectLockRetainUntilDate", content: cmnP.serializeDate_iso8601(data["ObjectLockRetainUntilDate"])},
  ]};
}
function S3CopyObjectOperation_Parse(node: xmlP.XmlNode): S3CopyObjectOperation {
  return {
    ...node.strings({
      optional: {"TargetResource":true,"RedirectLocation":true,"SSEAwsKmsKeyId":true,"TargetKeyPrefix":true},
    }),
    CannedAccessControlList: node.first("CannedAccessControlList", false, x => (x.content ?? '') as S3CannedAccessControlList),
    AccessControlGrants: node.getList("AccessControlGrants", "member").map(S3Grant_Parse),
    MetadataDirective: node.first("MetadataDirective", false, x => (x.content ?? '') as S3MetadataDirective),
    ModifiedSinceConstraint: node.first("ModifiedSinceConstraint", false, x => xmlP.parseTimestamp(x.content)),
    NewObjectMetadata: node.first("NewObjectMetadata", false, S3ObjectMetadata_Parse),
    NewObjectTagging: node.getList("NewObjectTagging", "member").map(S3Tag_Parse),
    RequesterPays: node.first("RequesterPays", false, x => x.content === 'true'),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as S3StorageClass),
    UnModifiedSinceConstraint: node.first("UnModifiedSinceConstraint", false, x => xmlP.parseTimestamp(x.content)),
    ObjectLockLegalHoldStatus: node.first("ObjectLockLegalHoldStatus", false, x => (x.content ?? '') as S3ObjectLockLegalHoldStatus),
    ObjectLockMode: node.first("ObjectLockMode", false, x => (x.content ?? '') as S3ObjectLockMode),
    ObjectLockRetainUntilDate: node.first("ObjectLockRetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 4 - tags: input, named, enum, output
export type S3CannedAccessControlList =
| "private"
| "public-read"
| "public-read-write"
| "aws-exec-read"
| "authenticated-read"
| "bucket-owner-read"
| "bucket-owner-full-control"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface S3Grant {
  Grantee?: S3Grantee | null;
  Permission?: S3Permission | null;
}
function S3Grant_Serialize(data: S3Grant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...S3Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function S3Grant_Parse(node: xmlP.XmlNode): S3Grant {
  return {
    Grantee: node.first("Grantee", false, S3Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as S3Permission),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface S3Grantee {
  TypeIdentifier?: S3GranteeTypeIdentifier | null;
  Identifier?: string | null;
  DisplayName?: string | null;
}
function S3Grantee_Serialize(data: S3Grantee | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TypeIdentifier", content: data["TypeIdentifier"]?.toString()},
    {name: "Identifier", content: data["Identifier"]?.toString()},
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
  ]};
}
function S3Grantee_Parse(node: xmlP.XmlNode): S3Grantee {
  return {
    ...node.strings({
      optional: {"Identifier":true,"DisplayName":true},
    }),
    TypeIdentifier: node.first("TypeIdentifier", false, x => (x.content ?? '') as S3GranteeTypeIdentifier),
  };
}

// refs: 4 - tags: input, named, enum, output
export type S3GranteeTypeIdentifier =
| "id"
| "emailAddress"
| "uri"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type S3Permission =
| "FULL_CONTROL"
| "READ"
| "WRITE"
| "READ_ACP"
| "WRITE_ACP"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type S3MetadataDirective =
| "COPY"
| "REPLACE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface S3ObjectMetadata {
  CacheControl?: string | null;
  ContentDisposition?: string | null;
  ContentEncoding?: string | null;
  ContentLanguage?: string | null;
  UserMetadata: { [key: string]: string | null | undefined };
  ContentLength?: number | null;
  ContentMD5?: string | null;
  ContentType?: string | null;
  HttpExpiresDate?: Date | number | null;
  RequesterCharged?: boolean | null;
  SSEAlgorithm?: S3SSEAlgorithm | null;
}
function S3ObjectMetadata_Serialize(data: S3ObjectMetadata | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CacheControl", content: data["CacheControl"]?.toString()},
    {name: "ContentDisposition", content: data["ContentDisposition"]?.toString()},
    {name: "ContentEncoding", content: data["ContentEncoding"]?.toString()},
    {name: "ContentLanguage", content: data["ContentLanguage"]?.toString()},
    {name: "UserMetadata", ...xmlP.emitMap(data["UserMetadata"], "entry", "key", x => ({name: "value", contents: x}))},
    {name: "ContentLength", content: data["ContentLength"]?.toString()},
    {name: "ContentMD5", content: data["ContentMD5"]?.toString()},
    {name: "ContentType", content: data["ContentType"]?.toString()},
    {name: "HttpExpiresDate", content: cmnP.serializeDate_iso8601(data["HttpExpiresDate"])},
    {name: "RequesterCharged", content: data["RequesterCharged"]?.toString()},
    {name: "SSEAlgorithm", content: data["SSEAlgorithm"]?.toString()},
  ]};
}
function S3ObjectMetadata_Parse(node: xmlP.XmlNode): S3ObjectMetadata {
  return {
    ...node.strings({
      optional: {"CacheControl":true,"ContentDisposition":true,"ContentEncoding":true,"ContentLanguage":true,"ContentMD5":true,"ContentType":true},
    }),
    UserMetadata: xmlP.readXmlMap(node.getList("UserMetadata", "entry"), x => x.content ?? '', {}),
    ContentLength: node.first("ContentLength", false, x => parseInt(x.content ?? '0')),
    HttpExpiresDate: node.first("HttpExpiresDate", false, x => xmlP.parseTimestamp(x.content)),
    RequesterCharged: node.first("RequesterCharged", false, x => x.content === 'true'),
    SSEAlgorithm: node.first("SSEAlgorithm", false, x => (x.content ?? '') as S3SSEAlgorithm),
  };
}

// refs: 2 - tags: input, named, enum, output
export type S3SSEAlgorithm =
| "AES256"
| "KMS"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, interface, output
export interface S3Tag {
  Key: string;
  Value: string;
}
function S3Tag_Serialize(data: S3Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function S3Tag_Parse(node: xmlP.XmlNode): S3Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 2 - tags: input, named, enum, output
export type S3StorageClass =
| "STANDARD"
| "STANDARD_IA"
| "ONEZONE_IA"
| "GLACIER"
| "INTELLIGENT_TIERING"
| "DEEP_ARCHIVE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type S3ObjectLockLegalHoldStatus =
| "OFF"
| "ON"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type S3ObjectLockMode =
| "COMPLIANCE"
| "GOVERNANCE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface S3SetObjectAclOperation {
  AccessControlPolicy?: S3AccessControlPolicy | null;
}
function S3SetObjectAclOperation_Serialize(data: S3SetObjectAclOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlPolicy", ...S3AccessControlPolicy_Serialize(data["AccessControlPolicy"])},
  ]};
}
function S3SetObjectAclOperation_Parse(node: xmlP.XmlNode): S3SetObjectAclOperation {
  return {
    AccessControlPolicy: node.first("AccessControlPolicy", false, S3AccessControlPolicy_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3AccessControlPolicy {
  AccessControlList?: S3AccessControlList | null;
  CannedAccessControlList?: S3CannedAccessControlList | null;
}
function S3AccessControlPolicy_Serialize(data: S3AccessControlPolicy | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlList", ...S3AccessControlList_Serialize(data["AccessControlList"])},
    {name: "CannedAccessControlList", content: data["CannedAccessControlList"]?.toString()},
  ]};
}
function S3AccessControlPolicy_Parse(node: xmlP.XmlNode): S3AccessControlPolicy {
  return {
    AccessControlList: node.first("AccessControlList", false, S3AccessControlList_Parse),
    CannedAccessControlList: node.first("CannedAccessControlList", false, x => (x.content ?? '') as S3CannedAccessControlList),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3AccessControlList {
  Owner: S3ObjectOwner;
  Grants: S3Grant[];
}
function S3AccessControlList_Serialize(data: S3AccessControlList | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Owner", ...S3ObjectOwner_Serialize(data["Owner"])},
    {name: "Grants", children: data["Grants"]?.map(x => ({name: "member", ...S3Grant_Serialize(x)}))},
  ]};
}
function S3AccessControlList_Parse(node: xmlP.XmlNode): S3AccessControlList {
  return {
    Owner: node.first("Owner", true, S3ObjectOwner_Parse),
    Grants: node.getList("Grants", "member").map(S3Grant_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3ObjectOwner {
  ID?: string | null;
  DisplayName?: string | null;
}
function S3ObjectOwner_Serialize(data: S3ObjectOwner | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ID", content: data["ID"]?.toString()},
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
  ]};
}
function S3ObjectOwner_Parse(node: xmlP.XmlNode): S3ObjectOwner {
  return node.strings({
    optional: {"ID":true,"DisplayName":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface S3SetObjectTaggingOperation {
  TagSet: S3Tag[];
}
function S3SetObjectTaggingOperation_Serialize(data: S3SetObjectTaggingOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}
function S3SetObjectTaggingOperation_Parse(node: xmlP.XmlNode): S3SetObjectTaggingOperation {
  return {
    TagSet: node.getList("TagSet", "member").map(S3Tag_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3InitiateRestoreObjectOperation {
  ExpirationInDays?: number | null;
  GlacierJobTier?: S3GlacierJobTier | null;
}
function S3InitiateRestoreObjectOperation_Serialize(data: S3InitiateRestoreObjectOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ExpirationInDays", content: data["ExpirationInDays"]?.toString()},
    {name: "GlacierJobTier", content: data["GlacierJobTier"]?.toString()},
  ]};
}
function S3InitiateRestoreObjectOperation_Parse(node: xmlP.XmlNode): S3InitiateRestoreObjectOperation {
  return {
    ExpirationInDays: node.first("ExpirationInDays", false, x => parseInt(x.content ?? '0')),
    GlacierJobTier: node.first("GlacierJobTier", false, x => (x.content ?? '') as S3GlacierJobTier),
  };
}

// refs: 2 - tags: input, named, enum, output
export type S3GlacierJobTier =
| "BULK"
| "STANDARD"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface S3SetObjectLegalHoldOperation {
  LegalHold: S3ObjectLockLegalHold;
}
function S3SetObjectLegalHoldOperation_Serialize(data: S3SetObjectLegalHoldOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LegalHold", ...S3ObjectLockLegalHold_Serialize(data["LegalHold"])},
  ]};
}
function S3SetObjectLegalHoldOperation_Parse(node: xmlP.XmlNode): S3SetObjectLegalHoldOperation {
  return {
    LegalHold: node.first("LegalHold", true, S3ObjectLockLegalHold_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3ObjectLockLegalHold {
  Status: S3ObjectLockLegalHoldStatus;
}
function S3ObjectLockLegalHold_Serialize(data: S3ObjectLockLegalHold | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function S3ObjectLockLegalHold_Parse(node: xmlP.XmlNode): S3ObjectLockLegalHold {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as S3ObjectLockLegalHoldStatus),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3SetObjectRetentionOperation {
  BypassGovernanceRetention?: boolean | null;
  Retention: S3Retention;
}
function S3SetObjectRetentionOperation_Serialize(data: S3SetObjectRetentionOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BypassGovernanceRetention", content: data["BypassGovernanceRetention"]?.toString()},
    {name: "Retention", ...S3Retention_Serialize(data["Retention"])},
  ]};
}
function S3SetObjectRetentionOperation_Parse(node: xmlP.XmlNode): S3SetObjectRetentionOperation {
  return {
    BypassGovernanceRetention: node.first("BypassGovernanceRetention", false, x => x.content === 'true'),
    Retention: node.first("Retention", true, S3Retention_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3Retention {
  RetainUntilDate?: Date | number | null;
  Mode?: S3ObjectLockRetentionMode | null;
}
function S3Retention_Serialize(data: S3Retention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(data["RetainUntilDate"])},
    {name: "Mode", content: data["Mode"]?.toString()},
  ]};
}
function S3Retention_Parse(node: xmlP.XmlNode): S3Retention {
  return {
    RetainUntilDate: node.first("RetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
    Mode: node.first("Mode", false, x => (x.content ?? '') as S3ObjectLockRetentionMode),
  };
}

// refs: 2 - tags: input, named, enum, output
export type S3ObjectLockRetentionMode =
| "COMPLIANCE"
| "GOVERNANCE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface JobReport {
  Bucket?: string | null;
  Format?: JobReportFormat | null;
  Enabled: boolean;
  Prefix?: string | null;
  ReportScope?: JobReportScope | null;
}
function JobReport_Serialize(data: JobReport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "ReportScope", content: data["ReportScope"]?.toString()},
  ]};
}
function JobReport_Parse(node: xmlP.XmlNode): JobReport {
  return {
    ...node.strings({
      optional: {"Bucket":true,"Prefix":true},
    }),
    Format: node.first("Format", false, x => (x.content ?? '') as JobReportFormat),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ReportScope: node.first("ReportScope", false, x => (x.content ?? '') as JobReportScope),
  };
}

// refs: 2 - tags: input, named, enum, output
export type JobReportFormat =
| "Report_CSV_20180820"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type JobReportScope =
| "AllTasks"
| "FailedTasksOnly"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface JobManifest {
  Spec: JobManifestSpec;
  Location: JobManifestLocation;
}
function JobManifest_Serialize(data: JobManifest | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Spec", ...JobManifestSpec_Serialize(data["Spec"])},
    {name: "Location", ...JobManifestLocation_Serialize(data["Location"])},
  ]};
}
function JobManifest_Parse(node: xmlP.XmlNode): JobManifest {
  return {
    Spec: node.first("Spec", true, JobManifestSpec_Parse),
    Location: node.first("Location", true, JobManifestLocation_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface JobManifestSpec {
  Format: JobManifestFormat;
  Fields: JobManifestFieldName[];
}
function JobManifestSpec_Serialize(data: JobManifestSpec | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Fields", children: data["Fields"]?.map(x => ({name: "member", content: x}))},
  ]};
}
function JobManifestSpec_Parse(node: xmlP.XmlNode): JobManifestSpec {
  return {
    Format: node.first("Format", true, x => (x.content ?? '') as JobManifestFormat),
    Fields: node.getList("Fields", "member").map(x => (x.content ?? '') as JobManifestFieldName),
  };
}

// refs: 2 - tags: input, named, enum, output
export type JobManifestFormat =
| "S3BatchOperations_CSV_20180820"
| "S3InventoryReport_CSV_20161130"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type JobManifestFieldName =
| "Ignore"
| "Bucket"
| "Key"
| "VersionId"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface JobManifestLocation {
  ObjectArn: string;
  ObjectVersionId?: string | null;
  ETag: string;
}
function JobManifestLocation_Serialize(data: JobManifestLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectArn", content: data["ObjectArn"]?.toString()},
    {name: "ObjectVersionId", content: data["ObjectVersionId"]?.toString()},
    {name: "ETag", content: data["ETag"]?.toString()},
  ]};
}
function JobManifestLocation_Parse(node: xmlP.XmlNode): JobManifestLocation {
  return node.strings({
    required: {"ObjectArn":true,"ETag":true},
    optional: {"ObjectVersionId":true},
  });
}

// refs: 4 - tags: input, named, enum, output
export type JobStatus =
| "Active"
| "Cancelled"
| "Cancelling"
| "Complete"
| "Completing"
| "Failed"
| "Failing"
| "New"
| "Paused"
| "Pausing"
| "Preparing"
| "Ready"
| "Suspended"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LifecycleConfiguration {
  Rules?: LifecycleRule[] | null;
}
function LifecycleConfiguration_Serialize(data: LifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Rules", children: data["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)}))},
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRule {
  Expiration?: LifecycleExpiration | null;
  ID?: string | null;
  Filter?: LifecycleRuleFilter | null;
  Status: ExpirationStatus;
  Transitions: Transition[];
  NoncurrentVersionTransitions: NoncurrentVersionTransition[];
  NoncurrentVersionExpiration?: NoncurrentVersionExpiration | null;
  AbortIncompleteMultipartUpload?: AbortIncompleteMultipartUpload | null;
}
function LifecycleRule_Serialize(data: LifecycleRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Filter", ...LifecycleRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Transitions", children: data["Transitions"]?.map(x => ({name: "Transition", ...Transition_Serialize(x)}))},
    {name: "NoncurrentVersionTransitions", children: data["NoncurrentVersionTransitions"]?.map(x => ({name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(x)}))},
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function LifecycleRule_Parse(node: xmlP.XmlNode): LifecycleRule {
  return {
    ...node.strings({
      optional: {"ID":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Filter: node.first("Filter", false, LifecycleRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as ExpirationStatus),
    Transitions: node.getList("Transitions", "Transition").map(Transition_Parse),
    NoncurrentVersionTransitions: node.getList("NoncurrentVersionTransitions", "NoncurrentVersionTransition").map(NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleExpiration {
  Date?: Date | number | null;
  Days?: number | null;
  ExpiredObjectDeleteMarker?: boolean | null;
}
function LifecycleExpiration_Serialize(data: LifecycleExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "ExpiredObjectDeleteMarker", content: data["ExpiredObjectDeleteMarker"]?.toString()},
  ]};
}
function LifecycleExpiration_Parse(node: xmlP.XmlNode): LifecycleExpiration {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    ExpiredObjectDeleteMarker: node.first("ExpiredObjectDeleteMarker", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRuleFilter {
  Prefix?: string | null;
  Tag?: S3Tag | null;
  And?: LifecycleRuleAndOperator | null;
}
function LifecycleRuleFilter_Serialize(data: LifecycleRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...S3Tag_Serialize(data["Tag"])},
    {name: "And", ...LifecycleRuleAndOperator_Serialize(data["And"])},
  ]};
}
function LifecycleRuleFilter_Parse(node: xmlP.XmlNode): LifecycleRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, S3Tag_Parse),
    And: node.first("And", false, LifecycleRuleAndOperator_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface LifecycleRuleAndOperator {
  Prefix?: string | null;
  Tags: S3Tag[];
}
function LifecycleRuleAndOperator_Serialize(data: LifecycleRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tags", children: data["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}
function LifecycleRuleAndOperator_Parse(node: xmlP.XmlNode): LifecycleRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tags", "member").map(S3Tag_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type ExpirationStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface Transition {
  Date?: Date | number | null;
  Days?: number | null;
  StorageClass?: TransitionStorageClass | null;
}
function Transition_Serialize(data: Transition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function Transition_Parse(node: xmlP.XmlNode): Transition {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as TransitionStorageClass),
  };
}

// refs: 4 - tags: input, named, enum, output
export type TransitionStorageClass =
| "GLACIER"
| "STANDARD_IA"
| "ONEZONE_IA"
| "INTELLIGENT_TIERING"
| "DEEP_ARCHIVE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface NoncurrentVersionTransition {
  NoncurrentDays?: number | null;
  StorageClass?: TransitionStorageClass | null;
}
function NoncurrentVersionTransition_Serialize(data: NoncurrentVersionTransition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function NoncurrentVersionTransition_Parse(node: xmlP.XmlNode): NoncurrentVersionTransition {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as TransitionStorageClass),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface NoncurrentVersionExpiration {
  NoncurrentDays?: number | null;
}
function NoncurrentVersionExpiration_Serialize(data: NoncurrentVersionExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
  ]};
}
function NoncurrentVersionExpiration_Parse(node: xmlP.XmlNode): NoncurrentVersionExpiration {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface AbortIncompleteMultipartUpload {
  DaysAfterInitiation?: number | null;
}
function AbortIncompleteMultipartUpload_Serialize(data: AbortIncompleteMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DaysAfterInitiation", content: data["DaysAfterInitiation"]?.toString()},
  ]};
}
function AbortIncompleteMultipartUpload_Parse(node: xmlP.XmlNode): AbortIncompleteMultipartUpload {
  return {
    DaysAfterInitiation: node.first("DaysAfterInitiation", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: input, named, interface
export interface Tagging {
  TagSet: S3Tag[];
}
function Tagging_Serialize(data: Tagging | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}

// refs: 2 - tags: input, named, interface, output
export interface StorageLensConfiguration {
  Id: string;
  AccountLevel: AccountLevel;
  Include?: Include | null;
  Exclude?: Exclude | null;
  DataExport?: StorageLensDataExport | null;
  IsEnabled: boolean;
  AwsOrg?: StorageLensAwsOrg | null;
  StorageLensArn?: string | null;
}
function StorageLensConfiguration_Serialize(data: StorageLensConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "AccountLevel", ...AccountLevel_Serialize(data["AccountLevel"])},
    {name: "Include", ...Include_Serialize(data["Include"])},
    {name: "Exclude", ...Exclude_Serialize(data["Exclude"])},
    {name: "DataExport", ...StorageLensDataExport_Serialize(data["DataExport"])},
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "AwsOrg", ...StorageLensAwsOrg_Serialize(data["AwsOrg"])},
    {name: "StorageLensArn", content: data["StorageLensArn"]?.toString()},
  ]};
}
function StorageLensConfiguration_Parse(node: xmlP.XmlNode): StorageLensConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"StorageLensArn":true},
    }),
    AccountLevel: node.first("AccountLevel", true, AccountLevel_Parse),
    Include: node.first("Include", false, Include_Parse),
    Exclude: node.first("Exclude", false, Exclude_Parse),
    DataExport: node.first("DataExport", false, StorageLensDataExport_Parse),
    IsEnabled: node.first("IsEnabled", true, x => x.content === 'true'),
    AwsOrg: node.first("AwsOrg", false, StorageLensAwsOrg_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface AccountLevel {
  ActivityMetrics?: ActivityMetrics | null;
  BucketLevel: BucketLevel;
}
function AccountLevel_Serialize(data: AccountLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ActivityMetrics", ...ActivityMetrics_Serialize(data["ActivityMetrics"])},
    {name: "BucketLevel", ...BucketLevel_Serialize(data["BucketLevel"])},
  ]};
}
function AccountLevel_Parse(node: xmlP.XmlNode): AccountLevel {
  return {
    ActivityMetrics: node.first("ActivityMetrics", false, ActivityMetrics_Parse),
    BucketLevel: node.first("BucketLevel", true, BucketLevel_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface ActivityMetrics {
  IsEnabled?: boolean | null;
}
function ActivityMetrics_Serialize(data: ActivityMetrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
  ]};
}
function ActivityMetrics_Parse(node: xmlP.XmlNode): ActivityMetrics {
  return {
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface BucketLevel {
  ActivityMetrics?: ActivityMetrics | null;
  PrefixLevel?: PrefixLevel | null;
}
function BucketLevel_Serialize(data: BucketLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ActivityMetrics", ...ActivityMetrics_Serialize(data["ActivityMetrics"])},
    {name: "PrefixLevel", ...PrefixLevel_Serialize(data["PrefixLevel"])},
  ]};
}
function BucketLevel_Parse(node: xmlP.XmlNode): BucketLevel {
  return {
    ActivityMetrics: node.first("ActivityMetrics", false, ActivityMetrics_Parse),
    PrefixLevel: node.first("PrefixLevel", false, PrefixLevel_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface PrefixLevel {
  StorageMetrics: PrefixLevelStorageMetrics;
}
function PrefixLevel_Serialize(data: PrefixLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StorageMetrics", ...PrefixLevelStorageMetrics_Serialize(data["StorageMetrics"])},
  ]};
}
function PrefixLevel_Parse(node: xmlP.XmlNode): PrefixLevel {
  return {
    StorageMetrics: node.first("StorageMetrics", true, PrefixLevelStorageMetrics_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface PrefixLevelStorageMetrics {
  IsEnabled?: boolean | null;
  SelectionCriteria?: SelectionCriteria | null;
}
function PrefixLevelStorageMetrics_Serialize(data: PrefixLevelStorageMetrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "SelectionCriteria", ...SelectionCriteria_Serialize(data["SelectionCriteria"])},
  ]};
}
function PrefixLevelStorageMetrics_Parse(node: xmlP.XmlNode): PrefixLevelStorageMetrics {
  return {
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
    SelectionCriteria: node.first("SelectionCriteria", false, SelectionCriteria_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface SelectionCriteria {
  Delimiter?: string | null;
  MaxDepth?: number | null;
  MinStorageBytesPercentage?: number | null;
}
function SelectionCriteria_Serialize(data: SelectionCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Delimiter", content: data["Delimiter"]?.toString()},
    {name: "MaxDepth", content: data["MaxDepth"]?.toString()},
    {name: "MinStorageBytesPercentage", content: data["MinStorageBytesPercentage"]?.toString()},
  ]};
}
function SelectionCriteria_Parse(node: xmlP.XmlNode): SelectionCriteria {
  return {
    ...node.strings({
      optional: {"Delimiter":true},
    }),
    MaxDepth: node.first("MaxDepth", false, x => parseInt(x.content ?? '0')),
    MinStorageBytesPercentage: node.first("MinStorageBytesPercentage", false, x => parseFloat(x.content ?? '0')),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Include {
  Buckets: string[];
  Regions: string[];
}
function Include_Serialize(data: Include | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Buckets", children: data["Buckets"]?.map(x => ({name: "Arn", content: x}))},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
  ]};
}
function Include_Parse(node: xmlP.XmlNode): Include {
  return {
    Buckets: node.getList("Buckets", "Arn").map(x => x.content ?? ''),
    Regions: node.getList("Regions", "Region").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface Exclude {
  Buckets: string[];
  Regions: string[];
}
function Exclude_Serialize(data: Exclude | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Buckets", children: data["Buckets"]?.map(x => ({name: "Arn", content: x}))},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
  ]};
}
function Exclude_Parse(node: xmlP.XmlNode): Exclude {
  return {
    Buckets: node.getList("Buckets", "Arn").map(x => x.content ?? ''),
    Regions: node.getList("Regions", "Region").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface StorageLensDataExport {
  S3BucketDestination: S3BucketDestination;
}
function StorageLensDataExport_Serialize(data: StorageLensDataExport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...S3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function StorageLensDataExport_Parse(node: xmlP.XmlNode): StorageLensDataExport {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, S3BucketDestination_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface S3BucketDestination {
  Format: Format;
  OutputSchemaVersion: OutputSchemaVersion;
  AccountId: string;
  Arn: string;
  Prefix?: string | null;
  Encryption?: StorageLensDataExportEncryption | null;
}
function S3BucketDestination_Serialize(data: S3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "OutputSchemaVersion", content: data["OutputSchemaVersion"]?.toString()},
    {name: "AccountId", content: data["AccountId"]?.toString()},
    {name: "Arn", content: data["Arn"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...StorageLensDataExportEncryption_Serialize(data["Encryption"])},
  ]};
}
function S3BucketDestination_Parse(node: xmlP.XmlNode): S3BucketDestination {
  return {
    ...node.strings({
      required: {"AccountId":true,"Arn":true},
      optional: {"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as Format),
    OutputSchemaVersion: node.first("OutputSchemaVersion", true, x => (x.content ?? '') as OutputSchemaVersion),
    Encryption: node.first("Encryption", false, StorageLensDataExportEncryption_Parse),
  };
}

// refs: 2 - tags: input, named, enum, output
export type Format =
| "CSV"
| "Parquet"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type OutputSchemaVersion =
| "V_1"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface StorageLensDataExportEncryption {
  SSES3?: SSES3 | null;
  SSEKMS?: SSEKMS | null;
}
function StorageLensDataExportEncryption_Serialize(data: StorageLensDataExportEncryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSE-S3", ...SSES3_Serialize(data["SSES3"])},
    {name: "SSE-KMS", ...SSEKMS_Serialize(data["SSEKMS"])},
  ]};
}
function StorageLensDataExportEncryption_Parse(node: xmlP.XmlNode): StorageLensDataExportEncryption {
  return {
    SSES3: node.first("SSE-S3", false, SSES3_Parse),
    SSEKMS: node.first("SSE-KMS", false, SSEKMS_Parse),
  };
}

// refs: 2 - tags: input, named, interface, output
export interface SSES3 {
}
function SSES3_Serialize(data: SSES3 | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}
function SSES3_Parse(node: xmlP.XmlNode): SSES3 {
  return {};
}

// refs: 2 - tags: input, named, interface, output
export interface SSEKMS {
  KeyId: string;
}
function SSEKMS_Serialize(data: SSEKMS | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "KeyId", content: data["KeyId"]?.toString()},
  ]};
}
function SSEKMS_Parse(node: xmlP.XmlNode): SSEKMS {
  return node.strings({
    required: {"KeyId":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface StorageLensAwsOrg {
  Arn: string;
}
function StorageLensAwsOrg_Serialize(data: StorageLensAwsOrg | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Arn", content: data["Arn"]?.toString()},
  ]};
}
function StorageLensAwsOrg_Parse(node: xmlP.XmlNode): StorageLensAwsOrg {
  return node.strings({
    required: {"Arn":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface StorageLensTag {
  Key: string;
  Value: string;
}
function StorageLensTag_Serialize(data: StorageLensTag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function StorageLensTag_Parse(node: xmlP.XmlNode): StorageLensTag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

// refs: 1 - tags: input, named, enum
export type RequestedJobStatus =
| "Cancelled"
| "Ready"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface JobDescriptor {
  JobId?: string | null;
  ConfirmationRequired?: boolean | null;
  Description?: string | null;
  JobArn?: string | null;
  Status?: JobStatus | null;
  Manifest?: JobManifest | null;
  Operation?: JobOperation | null;
  Priority?: number | null;
  ProgressSummary?: JobProgressSummary | null;
  StatusUpdateReason?: string | null;
  FailureReasons: JobFailure[];
  Report?: JobReport | null;
  CreationTime?: Date | number | null;
  TerminationDate?: Date | number | null;
  RoleArn?: string | null;
  SuspendedDate?: Date | number | null;
  SuspendedCause?: string | null;
}
function JobDescriptor_Parse(node: xmlP.XmlNode): JobDescriptor {
  return {
    ...node.strings({
      optional: {"JobId":true,"Description":true,"JobArn":true,"StatusUpdateReason":true,"RoleArn":true,"SuspendedCause":true},
    }),
    ConfirmationRequired: node.first("ConfirmationRequired", false, x => x.content === 'true'),
    Status: node.first("Status", false, x => (x.content ?? '') as JobStatus),
    Manifest: node.first("Manifest", false, JobManifest_Parse),
    Operation: node.first("Operation", false, JobOperation_Parse),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    ProgressSummary: node.first("ProgressSummary", false, JobProgressSummary_Parse),
    FailureReasons: node.getList("FailureReasons", "member").map(JobFailure_Parse),
    Report: node.first("Report", false, JobReport_Parse),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    TerminationDate: node.first("TerminationDate", false, x => xmlP.parseTimestamp(x.content)),
    SuspendedDate: node.first("SuspendedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 2 - tags: output, named, interface
export interface JobProgressSummary {
  TotalNumberOfTasks?: number | null;
  NumberOfTasksSucceeded?: number | null;
  NumberOfTasksFailed?: number | null;
}
function JobProgressSummary_Parse(node: xmlP.XmlNode): JobProgressSummary {
  return {
    TotalNumberOfTasks: node.first("TotalNumberOfTasks", false, x => parseInt(x.content ?? '0')),
    NumberOfTasksSucceeded: node.first("NumberOfTasksSucceeded", false, x => parseInt(x.content ?? '0')),
    NumberOfTasksFailed: node.first("NumberOfTasksFailed", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface JobFailure {
  FailureCode?: string | null;
  FailureReason?: string | null;
}
function JobFailure_Parse(node: xmlP.XmlNode): JobFailure {
  return node.strings({
    optional: {"FailureCode":true,"FailureReason":true},
  });
}

// refs: 2 - tags: output, named, enum
export type NetworkOrigin =
| "Internet"
| "VPC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface PolicyStatus {
  IsPublic?: boolean | null;
}
function PolicyStatus_Parse(node: xmlP.XmlNode): PolicyStatus {
  return {
    IsPublic: node.first("IsPublic", false, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccessPoint {
  Name: string;
  NetworkOrigin: NetworkOrigin;
  VpcConfiguration?: VpcConfiguration | null;
  Bucket: string;
  AccessPointArn?: string | null;
}
function AccessPoint_Parse(node: xmlP.XmlNode): AccessPoint {
  return {
    ...node.strings({
      required: {"Name":true,"Bucket":true},
      optional: {"AccessPointArn":true},
    }),
    NetworkOrigin: node.first("NetworkOrigin", true, x => (x.content ?? '') as NetworkOrigin),
    VpcConfiguration: node.first("VpcConfiguration", false, VpcConfiguration_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface JobListDescriptor {
  JobId?: string | null;
  Description?: string | null;
  Operation?: OperationName | null;
  Priority?: number | null;
  Status?: JobStatus | null;
  CreationTime?: Date | number | null;
  TerminationDate?: Date | number | null;
  ProgressSummary?: JobProgressSummary | null;
}
function JobListDescriptor_Parse(node: xmlP.XmlNode): JobListDescriptor {
  return {
    ...node.strings({
      optional: {"JobId":true,"Description":true},
    }),
    Operation: node.first("Operation", false, x => (x.content ?? '') as OperationName),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    Status: node.first("Status", false, x => (x.content ?? '') as JobStatus),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    TerminationDate: node.first("TerminationDate", false, x => xmlP.parseTimestamp(x.content)),
    ProgressSummary: node.first("ProgressSummary", false, JobProgressSummary_Parse),
  };
}

// refs: 1 - tags: output, named, enum
export type OperationName =
| "LambdaInvoke"
| "S3PutObjectCopy"
| "S3PutObjectAcl"
| "S3PutObjectTagging"
| "S3InitiateRestoreObject"
| "S3PutObjectLegalHold"
| "S3PutObjectRetention"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface RegionalBucket {
  Bucket: string;
  BucketArn?: string | null;
  PublicAccessBlockEnabled: boolean;
  CreationDate: Date | number;
  OutpostId?: string | null;
}
function RegionalBucket_Parse(node: xmlP.XmlNode): RegionalBucket {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"BucketArn":true,"OutpostId":true},
    }),
    PublicAccessBlockEnabled: node.first("PublicAccessBlockEnabled", true, x => x.content === 'true'),
    CreationDate: node.first("CreationDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface ListStorageLensConfigurationEntry {
  Id: string;
  StorageLensArn: string;
  HomeRegion: string;
  IsEnabled?: boolean | null;
}
function ListStorageLensConfigurationEntry_Parse(node: xmlP.XmlNode): ListStorageLensConfigurationEntry {
  return {
    ...node.strings({
      required: {"Id":true,"StorageLensArn":true,"HomeRegion":true},
    }),
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
  };
}
