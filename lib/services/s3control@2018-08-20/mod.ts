// Autogenerated API client for: AWS S3 Control

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class S3Control {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(S3Control.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-08-20",
    "endpointPrefix": "s3-control",
    "protocol": "rest-xml",
    "serviceFullName": "AWS S3 Control",
    "serviceId": "S3 Control",
    "signatureVersion": "s3v4",
    "signingName": "s3",
    "uid": "s3control-2018-08-20"
  };

  async createAccessPoint(
    {abortSignal, ...params}: RequestConfig & s.CreateAccessPointRequest,
  ): Promise<s.CreateAccessPointResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "CreateAccessPointRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Bucket", content: params["Bucket"]?.toString()},
        {name: "VpcConfiguration", ...VpcConfiguration_Serialize(params["VpcConfiguration"])},
        {name: "PublicAccessBlockConfiguration", ...PublicAccessBlockConfiguration_Serialize(params["PublicAccessBlockConfiguration"])},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateAccessPoint",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"AccessPointArn":true},
    });
  }

  async createBucket(
    {abortSignal, ...params}: RequestConfig & s.CreateBucketRequest,
  ): Promise<s.CreateBucketResult> {
    const inner = params["CreateBucketConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CreateBucketConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "LocationConstraint", content: inner["LocationConstraint"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ObjectLockEnabledForBucket"] != null) headers.append("x-amz-bucket-object-lock-enabled", params["ObjectLockEnabledForBucket"]?.toString() ?? '');
    if (params["OutpostId"] != null) headers.append("x-amz-outpost-id", params["OutpostId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateBucket",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location"),
      ...xml.strings({
        optional: {"BucketArn":true},
      }),
    };
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & s.CreateJobRequest,
  ): Promise<s.CreateJobResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "CreateJobRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "ConfirmationRequired", content: params["ConfirmationRequired"]?.toString()},
        {name: "Operation", ...JobOperation_Serialize(params["Operation"])},
        {name: "Report", ...JobReport_Serialize(params["Report"])},
        {name: "ClientRequestToken", content: (params["ClientRequestToken"] ?? generateIdemptToken()).toString()},
        {name: "Manifest", ...JobManifest_Serialize(params["Manifest"])},
        {name: "Description", content: params["Description"]?.toString()},
        {name: "Priority", content: params["Priority"]?.toString()},
        {name: "RoleArn", content: params["RoleArn"]?.toString()},
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "CreateJob",
      requestUri: "/v20180820/jobs",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"JobId":true},
    });
  }

  async deleteAccessPoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccessPointRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteAccessPoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteAccessPointPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteAccessPointPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucket(
    {abortSignal, ...params}: RequestConfig & s.DeleteBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucket",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketLifecycleConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteBucketTagging(
    {abortSignal, ...params}: RequestConfig & s.DeleteBucketTaggingRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteBucketTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      responseCode: 204,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteJobTagging(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobTaggingRequest,
  ): Promise<s.DeleteJobTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteJobTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async deletePublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & s.DeletePublicAccessBlockRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeletePublicAccessBlock",
      method: "DELETE",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteStorageLensConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStorageLensConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async deleteStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & s.DeleteStorageLensConfigurationTaggingRequest,
  ): Promise<s.DeleteStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStorageLensConfigurationTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async describeJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeJobRequest,
  ): Promise<s.DescribeJobResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DescribeJob",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Job: xml.first("Job", false, JobDescriptor_Parse),
    };
  }

  async getAccessPoint(
    {abortSignal, ...params}: RequestConfig & s.GetAccessPointRequest,
  ): Promise<s.GetAccessPointResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPoint",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Name":true,"Bucket":true},
      }),
      NetworkOrigin: xml.first("NetworkOrigin", false, x => (x.content ?? '') as s.NetworkOrigin),
      VpcConfiguration: xml.first("VpcConfiguration", false, VpcConfiguration_Parse),
      PublicAccessBlockConfiguration: xml.first("PublicAccessBlockConfiguration", false, PublicAccessBlockConfiguration_Parse),
      CreationDate: xml.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetAccessPointPolicyRequest,
  ): Promise<s.GetAccessPointPolicyResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPointPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"Policy":true},
    });
  }

  async getAccessPointPolicyStatus(
    {abortSignal, ...params}: RequestConfig & s.GetAccessPointPolicyStatusRequest,
  ): Promise<s.GetAccessPointPolicyStatusResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetAccessPointPolicyStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policyStatus`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PolicyStatus: xml.first("PolicyStatus", false, PolicyStatus_Parse),
    };
  }

  async getBucket(
    {abortSignal, ...params}: RequestConfig & s.GetBucketRequest,
  ): Promise<s.GetBucketResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucket",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Bucket":true},
      }),
      PublicAccessBlockEnabled: xml.first("PublicAccessBlockEnabled", false, x => x.content === 'true'),
      CreationDate: xml.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async getBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetBucketLifecycleConfigurationRequest,
  ): Promise<s.GetBucketLifecycleConfigurationResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketLifecycleConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rules", "Rule").map(LifecycleRule_Parse),
    };
  }

  async getBucketPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetBucketPolicyRequest,
  ): Promise<s.GetBucketPolicyResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return xml.strings({
      optional: {"Policy":true},
    });
  }

  async getBucketTagging(
    {abortSignal, ...params}: RequestConfig & s.GetBucketTaggingRequest,
  ): Promise<s.GetBucketTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetBucketTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TagSet: xml.getList("TagSet", "member").map(S3Tag_Parse),
    };
  }

  async getJobTagging(
    {abortSignal, ...params}: RequestConfig & s.GetJobTaggingRequest,
  ): Promise<s.GetJobTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetJobTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Tags: xml.getList("Tags", "member").map(S3Tag_Parse),
    };
  }

  async getPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & s.GetPublicAccessBlockRequest,
  ): Promise<s.GetPublicAccessBlockOutput> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetPublicAccessBlock",
      method: "GET",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PublicAccessBlockConfiguration: PublicAccessBlockConfiguration_Parse(xml),
  };
  }

  async getStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetStorageLensConfigurationRequest,
  ): Promise<s.GetStorageLensConfigurationResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetStorageLensConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StorageLensConfiguration: StorageLensConfiguration_Parse(xml),
  };
  }

  async getStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & s.GetStorageLensConfigurationTaggingRequest,
  ): Promise<s.GetStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "GetStorageLensConfigurationTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Tags: xml.getList("Tags", "Tag").map(StorageLensTag_Parse),
    };
  }

  async listAccessPoints(
    {abortSignal, ...params}: RequestConfig & s.ListAccessPointsRequest,
  ): Promise<s.ListAccessPointsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["Bucket"] != null) query.set("bucket", params["Bucket"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListAccessPoints",
      method: "GET",
      requestUri: "/v20180820/accesspoint",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      AccessPointList: xml.getList("AccessPointList", "AccessPoint").map(AccessPoint_Parse),
    };
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & s.ListJobsRequest,
  ): Promise<s.ListJobsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    for (const item of params["JobStatuses"] ?? []) {
      query.append("jobStatuses", item?.toString() ?? "");
    }
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListJobs",
      method: "GET",
      requestUri: "/v20180820/jobs",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Jobs: xml.getList("Jobs", "member").map(JobListDescriptor_Parse),
    };
  }

  async listRegionalBuckets(
    {abortSignal, ...params}: RequestConfig & s.ListRegionalBucketsRequest,
  ): Promise<s.ListRegionalBucketsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["OutpostId"] != null) headers.append("x-amz-outpost-id", params["OutpostId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListRegionalBuckets",
      method: "GET",
      requestUri: "/v20180820/bucket",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      RegionalBucketList: xml.getList("RegionalBucketList", "RegionalBucket").map(RegionalBucket_Parse),
    };
  }

  async listStorageLensConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListStorageLensConfigurationsRequest,
  ): Promise<s.ListStorageLensConfigurationsResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "ListStorageLensConfigurations",
      method: "GET",
      requestUri: "/v20180820/storagelens",
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      StorageLensConfigurationList: xml.getList("StorageLensConfiguration").map(ListStorageLensConfigurationEntry_Parse),
    };
  }

  async putAccessPointPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutAccessPointPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutAccessPointPolicyRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Policy", content: params["Policy"]?.toString()},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutAccessPointPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/accesspoint/${params["Name"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketLifecycleConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Rules", children: inner["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketLifecycleConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/lifecycleconfiguration`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutBucketPolicyRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Policy", content: params["Policy"]?.toString()},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    if (params["ConfirmRemoveSelfBucketAccess"] != null) headers.append("x-amz-confirm-remove-self-bucket-access", params["ConfirmRemoveSelfBucketAccess"]?.toString() ?? '');
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/policy`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putBucketTagging(
    {abortSignal, ...params}: RequestConfig & s.PutBucketTaggingRequest,
  ): Promise<void> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutBucketTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/bucket/${params["Bucket"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putJobTagging(
    {abortSignal, ...params}: RequestConfig & s.PutJobTaggingRequest,
  ): Promise<s.PutJobTaggingResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutJobTaggingRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutJobTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async putPublicAccessBlock(
    {abortSignal, ...params}: RequestConfig & s.PutPublicAccessBlockRequest,
  ): Promise<void> {
    const inner = params["PublicAccessBlockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "PublicAccessBlockConfiguration",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "BlockPublicAcls", content: inner["BlockPublicAcls"]?.toString()},
        {name: "IgnorePublicAcls", content: inner["IgnorePublicAcls"]?.toString()},
        {name: "BlockPublicPolicy", content: inner["BlockPublicPolicy"]?.toString()},
        {name: "RestrictPublicBuckets", content: inner["RestrictPublicBuckets"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutPublicAccessBlock",
      method: "PUT",
      requestUri: "/v20180820/configuration/publicAccessBlock",
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putStorageLensConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutStorageLensConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutStorageLensConfigurationRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "StorageLensConfiguration", ...StorageLensConfiguration_Serialize(params["StorageLensConfiguration"])},
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "Tag", ...StorageLensTag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutStorageLensConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}`,
      hostPrefix: `${params.AccountId}.`,
    });
  }

  async putStorageLensConfigurationTagging(
    {abortSignal, ...params}: RequestConfig & s.PutStorageLensConfigurationTaggingRequest,
  ): Promise<s.PutStorageLensConfigurationTaggingResult> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "PutStorageLensConfigurationTaggingRequest",
      attributes: {"xmlns":"http://awss3control.amazonaws.com/doc/2018-08-20/"},
      children: [
        {name: "Tags", children: params["Tags"]?.map(x => ({name: "Tag", ...StorageLensTag_Serialize(x)}))},
      ]});
    headers.append("x-amz-account-id", params["AccountId"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "PutStorageLensConfigurationTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/v20180820/storagelens/${params["ConfigId"]}/tagging`,
      hostPrefix: `${params.AccountId}.`,
    });
    return {
    };
  }

  async updateJobPriority(
    {abortSignal, ...params}: RequestConfig & s.UpdateJobPriorityRequest,
  ): Promise<s.UpdateJobPriorityResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    query.set("priority", params["Priority"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "UpdateJobPriority",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/priority`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"JobId":true},
      }),
      Priority: xml.first("Priority", true, x => parseInt(x.content ?? '0')),
    };
  }

  async updateJobStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdateJobStatusRequest,
  ): Promise<s.UpdateJobStatusResult> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-account-id", params["AccountId"]);
    query.set("requestedJobStatus", params["RequestedJobStatus"]?.toString() ?? "");
    if (params["StatusUpdateReason"] != null) query.set("statusUpdateReason", params["StatusUpdateReason"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query,
      action: "UpdateJobStatus",
      requestUri: cmnP.encodePath`/v20180820/jobs/${params["JobId"]}/status`,
      hostPrefix: `${params.AccountId}.`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"JobId":true,"StatusUpdateReason":true},
      }),
      Status: xml.first("Status", false, x => (x.content ?? '') as s.JobStatus),
    };
  }

}

function VpcConfiguration_Serialize(data: s.VpcConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "VpcId", content: data["VpcId"]?.toString()},
  ]};
}
function VpcConfiguration_Parse(node: xmlP.XmlNode): s.VpcConfiguration {
  return node.strings({
    required: {"VpcId":true},
  });
}

function PublicAccessBlockConfiguration_Serialize(data: s.PublicAccessBlockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BlockPublicAcls", content: data["BlockPublicAcls"]?.toString()},
    {name: "IgnorePublicAcls", content: data["IgnorePublicAcls"]?.toString()},
    {name: "BlockPublicPolicy", content: data["BlockPublicPolicy"]?.toString()},
    {name: "RestrictPublicBuckets", content: data["RestrictPublicBuckets"]?.toString()},
  ]};
}
function PublicAccessBlockConfiguration_Parse(node: xmlP.XmlNode): s.PublicAccessBlockConfiguration {
  return {
    BlockPublicAcls: node.first("BlockPublicAcls", false, x => x.content === 'true'),
    IgnorePublicAcls: node.first("IgnorePublicAcls", false, x => x.content === 'true'),
    BlockPublicPolicy: node.first("BlockPublicPolicy", false, x => x.content === 'true'),
    RestrictPublicBuckets: node.first("RestrictPublicBuckets", false, x => x.content === 'true'),
  };
}

function CreateBucketConfiguration_Serialize(data: s.CreateBucketConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LocationConstraint", content: data["LocationConstraint"]?.toString()},
  ]};
}

function JobOperation_Serialize(data: s.JobOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaInvoke", ...LambdaInvokeOperation_Serialize(data["LambdaInvoke"])},
    {name: "S3PutObjectCopy", ...S3CopyObjectOperation_Serialize(data["S3PutObjectCopy"])},
    {name: "S3PutObjectAcl", ...S3SetObjectAclOperation_Serialize(data["S3PutObjectAcl"])},
    {name: "S3PutObjectTagging", ...S3SetObjectTaggingOperation_Serialize(data["S3PutObjectTagging"])},
    {name: "S3DeleteObjectTagging", ...S3DeleteObjectTaggingOperation_Serialize(data["S3DeleteObjectTagging"])},
    {name: "S3InitiateRestoreObject", ...S3InitiateRestoreObjectOperation_Serialize(data["S3InitiateRestoreObject"])},
    {name: "S3PutObjectLegalHold", ...S3SetObjectLegalHoldOperation_Serialize(data["S3PutObjectLegalHold"])},
    {name: "S3PutObjectRetention", ...S3SetObjectRetentionOperation_Serialize(data["S3PutObjectRetention"])},
  ]};
}
function JobOperation_Parse(node: xmlP.XmlNode): s.JobOperation {
  return {
    LambdaInvoke: node.first("LambdaInvoke", false, LambdaInvokeOperation_Parse),
    S3PutObjectCopy: node.first("S3PutObjectCopy", false, S3CopyObjectOperation_Parse),
    S3PutObjectAcl: node.first("S3PutObjectAcl", false, S3SetObjectAclOperation_Parse),
    S3PutObjectTagging: node.first("S3PutObjectTagging", false, S3SetObjectTaggingOperation_Parse),
    S3DeleteObjectTagging: node.first("S3DeleteObjectTagging", false, S3DeleteObjectTaggingOperation_Parse),
    S3InitiateRestoreObject: node.first("S3InitiateRestoreObject", false, S3InitiateRestoreObjectOperation_Parse),
    S3PutObjectLegalHold: node.first("S3PutObjectLegalHold", false, S3SetObjectLegalHoldOperation_Parse),
    S3PutObjectRetention: node.first("S3PutObjectRetention", false, S3SetObjectRetentionOperation_Parse),
  };
}

function LambdaInvokeOperation_Serialize(data: s.LambdaInvokeOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "FunctionArn", content: data["FunctionArn"]?.toString()},
  ]};
}
function LambdaInvokeOperation_Parse(node: xmlP.XmlNode): s.LambdaInvokeOperation {
  return node.strings({
    optional: {"FunctionArn":true},
  });
}

function S3CopyObjectOperation_Serialize(data: s.S3CopyObjectOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetResource", content: data["TargetResource"]?.toString()},
    {name: "CannedAccessControlList", content: data["CannedAccessControlList"]?.toString()},
    {name: "AccessControlGrants", children: data["AccessControlGrants"]?.map(x => ({name: "member", ...S3Grant_Serialize(x)}))},
    {name: "MetadataDirective", content: data["MetadataDirective"]?.toString()},
    {name: "ModifiedSinceConstraint", content: cmnP.serializeDate_iso8601(data["ModifiedSinceConstraint"])},
    {name: "NewObjectMetadata", ...S3ObjectMetadata_Serialize(data["NewObjectMetadata"])},
    {name: "NewObjectTagging", children: data["NewObjectTagging"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
    {name: "RedirectLocation", content: data["RedirectLocation"]?.toString()},
    {name: "RequesterPays", content: data["RequesterPays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
    {name: "UnModifiedSinceConstraint", content: cmnP.serializeDate_iso8601(data["UnModifiedSinceConstraint"])},
    {name: "SSEAwsKmsKeyId", content: data["SSEAwsKmsKeyId"]?.toString()},
    {name: "TargetKeyPrefix", content: data["TargetKeyPrefix"]?.toString()},
    {name: "ObjectLockLegalHoldStatus", content: data["ObjectLockLegalHoldStatus"]?.toString()},
    {name: "ObjectLockMode", content: data["ObjectLockMode"]?.toString()},
    {name: "ObjectLockRetainUntilDate", content: cmnP.serializeDate_iso8601(data["ObjectLockRetainUntilDate"])},
  ]};
}
function S3CopyObjectOperation_Parse(node: xmlP.XmlNode): s.S3CopyObjectOperation {
  return {
    ...node.strings({
      optional: {"TargetResource":true,"RedirectLocation":true,"SSEAwsKmsKeyId":true,"TargetKeyPrefix":true},
    }),
    CannedAccessControlList: node.first("CannedAccessControlList", false, x => (x.content ?? '') as s.S3CannedAccessControlList),
    AccessControlGrants: node.getList("AccessControlGrants", "member").map(S3Grant_Parse),
    MetadataDirective: node.first("MetadataDirective", false, x => (x.content ?? '') as s.S3MetadataDirective),
    ModifiedSinceConstraint: node.first("ModifiedSinceConstraint", false, x => xmlP.parseTimestamp(x.content)),
    NewObjectMetadata: node.first("NewObjectMetadata", false, S3ObjectMetadata_Parse),
    NewObjectTagging: node.getList("NewObjectTagging", "member").map(S3Tag_Parse),
    RequesterPays: node.first("RequesterPays", false, x => x.content === 'true'),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.S3StorageClass),
    UnModifiedSinceConstraint: node.first("UnModifiedSinceConstraint", false, x => xmlP.parseTimestamp(x.content)),
    ObjectLockLegalHoldStatus: node.first("ObjectLockLegalHoldStatus", false, x => (x.content ?? '') as s.S3ObjectLockLegalHoldStatus),
    ObjectLockMode: node.first("ObjectLockMode", false, x => (x.content ?? '') as s.S3ObjectLockMode),
    ObjectLockRetainUntilDate: node.first("ObjectLockRetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function S3Grant_Serialize(data: s.S3Grant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...S3Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function S3Grant_Parse(node: xmlP.XmlNode): s.S3Grant {
  return {
    Grantee: node.first("Grantee", false, S3Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as s.S3Permission),
  };
}

function S3Grantee_Serialize(data: s.S3Grantee | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TypeIdentifier", content: data["TypeIdentifier"]?.toString()},
    {name: "Identifier", content: data["Identifier"]?.toString()},
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
  ]};
}
function S3Grantee_Parse(node: xmlP.XmlNode): s.S3Grantee {
  return {
    ...node.strings({
      optional: {"Identifier":true,"DisplayName":true},
    }),
    TypeIdentifier: node.first("TypeIdentifier", false, x => (x.content ?? '') as s.S3GranteeTypeIdentifier),
  };
}

function S3ObjectMetadata_Serialize(data: s.S3ObjectMetadata | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CacheControl", content: data["CacheControl"]?.toString()},
    {name: "ContentDisposition", content: data["ContentDisposition"]?.toString()},
    {name: "ContentEncoding", content: data["ContentEncoding"]?.toString()},
    {name: "ContentLanguage", content: data["ContentLanguage"]?.toString()},
    {name: "UserMetadata", ...xmlP.emitMap(data["UserMetadata"], "entry", "key", x => ({name: "value", contents: x}))},
    {name: "ContentLength", content: data["ContentLength"]?.toString()},
    {name: "ContentMD5", content: data["ContentMD5"]?.toString()},
    {name: "ContentType", content: data["ContentType"]?.toString()},
    {name: "HttpExpiresDate", content: cmnP.serializeDate_iso8601(data["HttpExpiresDate"])},
    {name: "RequesterCharged", content: data["RequesterCharged"]?.toString()},
    {name: "SSEAlgorithm", content: data["SSEAlgorithm"]?.toString()},
  ]};
}
function S3ObjectMetadata_Parse(node: xmlP.XmlNode): s.S3ObjectMetadata {
  return {
    ...node.strings({
      optional: {"CacheControl":true,"ContentDisposition":true,"ContentEncoding":true,"ContentLanguage":true,"ContentMD5":true,"ContentType":true},
    }),
    UserMetadata: xmlP.readXmlMap(node.getList("UserMetadata", "entry"), x => x.content ?? '', {}),
    ContentLength: node.first("ContentLength", false, x => parseInt(x.content ?? '0')),
    HttpExpiresDate: node.first("HttpExpiresDate", false, x => xmlP.parseTimestamp(x.content)),
    RequesterCharged: node.first("RequesterCharged", false, x => x.content === 'true'),
    SSEAlgorithm: node.first("SSEAlgorithm", false, x => (x.content ?? '') as s.S3SSEAlgorithm),
  };
}

function S3Tag_Serialize(data: s.S3Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function S3Tag_Parse(node: xmlP.XmlNode): s.S3Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function S3SetObjectAclOperation_Serialize(data: s.S3SetObjectAclOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlPolicy", ...S3AccessControlPolicy_Serialize(data["AccessControlPolicy"])},
  ]};
}
function S3SetObjectAclOperation_Parse(node: xmlP.XmlNode): s.S3SetObjectAclOperation {
  return {
    AccessControlPolicy: node.first("AccessControlPolicy", false, S3AccessControlPolicy_Parse),
  };
}

function S3AccessControlPolicy_Serialize(data: s.S3AccessControlPolicy | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlList", ...S3AccessControlList_Serialize(data["AccessControlList"])},
    {name: "CannedAccessControlList", content: data["CannedAccessControlList"]?.toString()},
  ]};
}
function S3AccessControlPolicy_Parse(node: xmlP.XmlNode): s.S3AccessControlPolicy {
  return {
    AccessControlList: node.first("AccessControlList", false, S3AccessControlList_Parse),
    CannedAccessControlList: node.first("CannedAccessControlList", false, x => (x.content ?? '') as s.S3CannedAccessControlList),
  };
}

function S3AccessControlList_Serialize(data: s.S3AccessControlList | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Owner", ...S3ObjectOwner_Serialize(data["Owner"])},
    {name: "Grants", children: data["Grants"]?.map(x => ({name: "member", ...S3Grant_Serialize(x)}))},
  ]};
}
function S3AccessControlList_Parse(node: xmlP.XmlNode): s.S3AccessControlList {
  return {
    Owner: node.first("Owner", true, S3ObjectOwner_Parse),
    Grants: node.getList("Grants", "member").map(S3Grant_Parse),
  };
}

function S3ObjectOwner_Serialize(data: s.S3ObjectOwner | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ID", content: data["ID"]?.toString()},
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
  ]};
}
function S3ObjectOwner_Parse(node: xmlP.XmlNode): s.S3ObjectOwner {
  return node.strings({
    optional: {"ID":true,"DisplayName":true},
  });
}

function S3SetObjectTaggingOperation_Serialize(data: s.S3SetObjectTaggingOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}
function S3SetObjectTaggingOperation_Parse(node: xmlP.XmlNode): s.S3SetObjectTaggingOperation {
  return {
    TagSet: node.getList("TagSet", "member").map(S3Tag_Parse),
  };
}

function S3DeleteObjectTaggingOperation_Serialize(data: s.S3DeleteObjectTaggingOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}
function S3DeleteObjectTaggingOperation_Parse(node: xmlP.XmlNode): s.S3DeleteObjectTaggingOperation {
  return {};
}

function S3InitiateRestoreObjectOperation_Serialize(data: s.S3InitiateRestoreObjectOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ExpirationInDays", content: data["ExpirationInDays"]?.toString()},
    {name: "GlacierJobTier", content: data["GlacierJobTier"]?.toString()},
  ]};
}
function S3InitiateRestoreObjectOperation_Parse(node: xmlP.XmlNode): s.S3InitiateRestoreObjectOperation {
  return {
    ExpirationInDays: node.first("ExpirationInDays", false, x => parseInt(x.content ?? '0')),
    GlacierJobTier: node.first("GlacierJobTier", false, x => (x.content ?? '') as s.S3GlacierJobTier),
  };
}

function S3SetObjectLegalHoldOperation_Serialize(data: s.S3SetObjectLegalHoldOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LegalHold", ...S3ObjectLockLegalHold_Serialize(data["LegalHold"])},
  ]};
}
function S3SetObjectLegalHoldOperation_Parse(node: xmlP.XmlNode): s.S3SetObjectLegalHoldOperation {
  return {
    LegalHold: node.first("LegalHold", true, S3ObjectLockLegalHold_Parse),
  };
}

function S3ObjectLockLegalHold_Serialize(data: s.S3ObjectLockLegalHold | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function S3ObjectLockLegalHold_Parse(node: xmlP.XmlNode): s.S3ObjectLockLegalHold {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.S3ObjectLockLegalHoldStatus),
  };
}

function S3SetObjectRetentionOperation_Serialize(data: s.S3SetObjectRetentionOperation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BypassGovernanceRetention", content: data["BypassGovernanceRetention"]?.toString()},
    {name: "Retention", ...S3Retention_Serialize(data["Retention"])},
  ]};
}
function S3SetObjectRetentionOperation_Parse(node: xmlP.XmlNode): s.S3SetObjectRetentionOperation {
  return {
    BypassGovernanceRetention: node.first("BypassGovernanceRetention", false, x => x.content === 'true'),
    Retention: node.first("Retention", true, S3Retention_Parse),
  };
}

function S3Retention_Serialize(data: s.S3Retention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(data["RetainUntilDate"])},
    {name: "Mode", content: data["Mode"]?.toString()},
  ]};
}
function S3Retention_Parse(node: xmlP.XmlNode): s.S3Retention {
  return {
    RetainUntilDate: node.first("RetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
    Mode: node.first("Mode", false, x => (x.content ?? '') as s.S3ObjectLockRetentionMode),
  };
}

function JobReport_Serialize(data: s.JobReport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "ReportScope", content: data["ReportScope"]?.toString()},
  ]};
}
function JobReport_Parse(node: xmlP.XmlNode): s.JobReport {
  return {
    ...node.strings({
      optional: {"Bucket":true,"Prefix":true},
    }),
    Format: node.first("Format", false, x => (x.content ?? '') as s.JobReportFormat),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ReportScope: node.first("ReportScope", false, x => (x.content ?? '') as s.JobReportScope),
  };
}

function JobManifest_Serialize(data: s.JobManifest | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Spec", ...JobManifestSpec_Serialize(data["Spec"])},
    {name: "Location", ...JobManifestLocation_Serialize(data["Location"])},
  ]};
}
function JobManifest_Parse(node: xmlP.XmlNode): s.JobManifest {
  return {
    Spec: node.first("Spec", true, JobManifestSpec_Parse),
    Location: node.first("Location", true, JobManifestLocation_Parse),
  };
}

function JobManifestSpec_Serialize(data: s.JobManifestSpec | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Fields", children: data["Fields"]?.map(x => ({name: "member", content: x}))},
  ]};
}
function JobManifestSpec_Parse(node: xmlP.XmlNode): s.JobManifestSpec {
  return {
    Format: node.first("Format", true, x => (x.content ?? '') as s.JobManifestFormat),
    Fields: node.getList("Fields", "member").map(x => (x.content ?? '') as s.JobManifestFieldName),
  };
}

function JobManifestLocation_Serialize(data: s.JobManifestLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectArn", content: data["ObjectArn"]?.toString()},
    {name: "ObjectVersionId", content: data["ObjectVersionId"]?.toString()},
    {name: "ETag", content: data["ETag"]?.toString()},
  ]};
}
function JobManifestLocation_Parse(node: xmlP.XmlNode): s.JobManifestLocation {
  return node.strings({
    required: {"ObjectArn":true,"ETag":true},
    optional: {"ObjectVersionId":true},
  });
}

function LifecycleConfiguration_Serialize(data: s.LifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Rules", children: data["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)}))},
  ]};
}

function LifecycleRule_Serialize(data: s.LifecycleRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Filter", ...LifecycleRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Transitions", children: data["Transitions"]?.map(x => ({name: "Transition", ...Transition_Serialize(x)}))},
    {name: "NoncurrentVersionTransitions", children: data["NoncurrentVersionTransitions"]?.map(x => ({name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(x)}))},
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function LifecycleRule_Parse(node: xmlP.XmlNode): s.LifecycleRule {
  return {
    ...node.strings({
      optional: {"ID":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Filter: node.first("Filter", false, LifecycleRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as s.ExpirationStatus),
    Transitions: node.getList("Transitions", "Transition").map(Transition_Parse),
    NoncurrentVersionTransitions: node.getList("NoncurrentVersionTransitions", "NoncurrentVersionTransition").map(NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

function LifecycleExpiration_Serialize(data: s.LifecycleExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "ExpiredObjectDeleteMarker", content: data["ExpiredObjectDeleteMarker"]?.toString()},
  ]};
}
function LifecycleExpiration_Parse(node: xmlP.XmlNode): s.LifecycleExpiration {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    ExpiredObjectDeleteMarker: node.first("ExpiredObjectDeleteMarker", false, x => x.content === 'true'),
  };
}

function LifecycleRuleFilter_Serialize(data: s.LifecycleRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...S3Tag_Serialize(data["Tag"])},
    {name: "And", ...LifecycleRuleAndOperator_Serialize(data["And"])},
  ]};
}
function LifecycleRuleFilter_Parse(node: xmlP.XmlNode): s.LifecycleRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, S3Tag_Parse),
    And: node.first("And", false, LifecycleRuleAndOperator_Parse),
  };
}

function LifecycleRuleAndOperator_Serialize(data: s.LifecycleRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tags", children: data["Tags"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}
function LifecycleRuleAndOperator_Parse(node: xmlP.XmlNode): s.LifecycleRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tags", "member").map(S3Tag_Parse),
  };
}

function Transition_Serialize(data: s.Transition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function Transition_Parse(node: xmlP.XmlNode): s.Transition {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.TransitionStorageClass),
  };
}

function NoncurrentVersionTransition_Serialize(data: s.NoncurrentVersionTransition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function NoncurrentVersionTransition_Parse(node: xmlP.XmlNode): s.NoncurrentVersionTransition {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.TransitionStorageClass),
  };
}

function NoncurrentVersionExpiration_Serialize(data: s.NoncurrentVersionExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
  ]};
}
function NoncurrentVersionExpiration_Parse(node: xmlP.XmlNode): s.NoncurrentVersionExpiration {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
  };
}

function AbortIncompleteMultipartUpload_Serialize(data: s.AbortIncompleteMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DaysAfterInitiation", content: data["DaysAfterInitiation"]?.toString()},
  ]};
}
function AbortIncompleteMultipartUpload_Parse(node: xmlP.XmlNode): s.AbortIncompleteMultipartUpload {
  return {
    DaysAfterInitiation: node.first("DaysAfterInitiation", false, x => parseInt(x.content ?? '0')),
  };
}

function Tagging_Serialize(data: s.Tagging | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "member", ...S3Tag_Serialize(x)}))},
  ]};
}

function StorageLensConfiguration_Serialize(data: s.StorageLensConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "AccountLevel", ...AccountLevel_Serialize(data["AccountLevel"])},
    {name: "Include", ...Include_Serialize(data["Include"])},
    {name: "Exclude", ...Exclude_Serialize(data["Exclude"])},
    {name: "DataExport", ...StorageLensDataExport_Serialize(data["DataExport"])},
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "AwsOrg", ...StorageLensAwsOrg_Serialize(data["AwsOrg"])},
    {name: "StorageLensArn", content: data["StorageLensArn"]?.toString()},
  ]};
}
function StorageLensConfiguration_Parse(node: xmlP.XmlNode): s.StorageLensConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"StorageLensArn":true},
    }),
    AccountLevel: node.first("AccountLevel", true, AccountLevel_Parse),
    Include: node.first("Include", false, Include_Parse),
    Exclude: node.first("Exclude", false, Exclude_Parse),
    DataExport: node.first("DataExport", false, StorageLensDataExport_Parse),
    IsEnabled: node.first("IsEnabled", true, x => x.content === 'true'),
    AwsOrg: node.first("AwsOrg", false, StorageLensAwsOrg_Parse),
  };
}

function AccountLevel_Serialize(data: s.AccountLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ActivityMetrics", ...ActivityMetrics_Serialize(data["ActivityMetrics"])},
    {name: "BucketLevel", ...BucketLevel_Serialize(data["BucketLevel"])},
  ]};
}
function AccountLevel_Parse(node: xmlP.XmlNode): s.AccountLevel {
  return {
    ActivityMetrics: node.first("ActivityMetrics", false, ActivityMetrics_Parse),
    BucketLevel: node.first("BucketLevel", true, BucketLevel_Parse),
  };
}

function ActivityMetrics_Serialize(data: s.ActivityMetrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
  ]};
}
function ActivityMetrics_Parse(node: xmlP.XmlNode): s.ActivityMetrics {
  return {
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
  };
}

function BucketLevel_Serialize(data: s.BucketLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ActivityMetrics", ...ActivityMetrics_Serialize(data["ActivityMetrics"])},
    {name: "PrefixLevel", ...PrefixLevel_Serialize(data["PrefixLevel"])},
  ]};
}
function BucketLevel_Parse(node: xmlP.XmlNode): s.BucketLevel {
  return {
    ActivityMetrics: node.first("ActivityMetrics", false, ActivityMetrics_Parse),
    PrefixLevel: node.first("PrefixLevel", false, PrefixLevel_Parse),
  };
}

function PrefixLevel_Serialize(data: s.PrefixLevel | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StorageMetrics", ...PrefixLevelStorageMetrics_Serialize(data["StorageMetrics"])},
  ]};
}
function PrefixLevel_Parse(node: xmlP.XmlNode): s.PrefixLevel {
  return {
    StorageMetrics: node.first("StorageMetrics", true, PrefixLevelStorageMetrics_Parse),
  };
}

function PrefixLevelStorageMetrics_Serialize(data: s.PrefixLevelStorageMetrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "SelectionCriteria", ...SelectionCriteria_Serialize(data["SelectionCriteria"])},
  ]};
}
function PrefixLevelStorageMetrics_Parse(node: xmlP.XmlNode): s.PrefixLevelStorageMetrics {
  return {
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
    SelectionCriteria: node.first("SelectionCriteria", false, SelectionCriteria_Parse),
  };
}

function SelectionCriteria_Serialize(data: s.SelectionCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Delimiter", content: data["Delimiter"]?.toString()},
    {name: "MaxDepth", content: data["MaxDepth"]?.toString()},
    {name: "MinStorageBytesPercentage", content: data["MinStorageBytesPercentage"]?.toString()},
  ]};
}
function SelectionCriteria_Parse(node: xmlP.XmlNode): s.SelectionCriteria {
  return {
    ...node.strings({
      optional: {"Delimiter":true},
    }),
    MaxDepth: node.first("MaxDepth", false, x => parseInt(x.content ?? '0')),
    MinStorageBytesPercentage: node.first("MinStorageBytesPercentage", false, x => parseFloat(x.content ?? '0')),
  };
}

function Include_Serialize(data: s.Include | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Buckets", children: data["Buckets"]?.map(x => ({name: "Arn", content: x}))},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
  ]};
}
function Include_Parse(node: xmlP.XmlNode): s.Include {
  return {
    Buckets: node.getList("Buckets", "Arn").map(x => x.content ?? ''),
    Regions: node.getList("Regions", "Region").map(x => x.content ?? ''),
  };
}

function Exclude_Serialize(data: s.Exclude | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Buckets", children: data["Buckets"]?.map(x => ({name: "Arn", content: x}))},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
  ]};
}
function Exclude_Parse(node: xmlP.XmlNode): s.Exclude {
  return {
    Buckets: node.getList("Buckets", "Arn").map(x => x.content ?? ''),
    Regions: node.getList("Regions", "Region").map(x => x.content ?? ''),
  };
}

function StorageLensDataExport_Serialize(data: s.StorageLensDataExport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...S3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function StorageLensDataExport_Parse(node: xmlP.XmlNode): s.StorageLensDataExport {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, S3BucketDestination_Parse),
  };
}

function S3BucketDestination_Serialize(data: s.S3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "OutputSchemaVersion", content: data["OutputSchemaVersion"]?.toString()},
    {name: "AccountId", content: data["AccountId"]?.toString()},
    {name: "Arn", content: data["Arn"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...StorageLensDataExportEncryption_Serialize(data["Encryption"])},
  ]};
}
function S3BucketDestination_Parse(node: xmlP.XmlNode): s.S3BucketDestination {
  return {
    ...node.strings({
      required: {"AccountId":true,"Arn":true},
      optional: {"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as s.Format),
    OutputSchemaVersion: node.first("OutputSchemaVersion", true, x => (x.content ?? '') as s.OutputSchemaVersion),
    Encryption: node.first("Encryption", false, StorageLensDataExportEncryption_Parse),
  };
}

function StorageLensDataExportEncryption_Serialize(data: s.StorageLensDataExportEncryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSE-S3", ...SSES3_Serialize(data["SSES3"])},
    {name: "SSE-KMS", ...SSEKMS_Serialize(data["SSEKMS"])},
  ]};
}
function StorageLensDataExportEncryption_Parse(node: xmlP.XmlNode): s.StorageLensDataExportEncryption {
  return {
    SSES3: node.first("SSE-S3", false, SSES3_Parse),
    SSEKMS: node.first("SSE-KMS", false, SSEKMS_Parse),
  };
}

function SSES3_Serialize(data: s.SSES3 | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}
function SSES3_Parse(node: xmlP.XmlNode): s.SSES3 {
  return {};
}

function SSEKMS_Serialize(data: s.SSEKMS | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "KeyId", content: data["KeyId"]?.toString()},
  ]};
}
function SSEKMS_Parse(node: xmlP.XmlNode): s.SSEKMS {
  return node.strings({
    required: {"KeyId":true},
  });
}

function StorageLensAwsOrg_Serialize(data: s.StorageLensAwsOrg | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Arn", content: data["Arn"]?.toString()},
  ]};
}
function StorageLensAwsOrg_Parse(node: xmlP.XmlNode): s.StorageLensAwsOrg {
  return node.strings({
    required: {"Arn":true},
  });
}

function StorageLensTag_Serialize(data: s.StorageLensTag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function StorageLensTag_Parse(node: xmlP.XmlNode): s.StorageLensTag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function JobDescriptor_Parse(node: xmlP.XmlNode): s.JobDescriptor {
  return {
    ...node.strings({
      optional: {"JobId":true,"Description":true,"JobArn":true,"StatusUpdateReason":true,"RoleArn":true,"SuspendedCause":true},
    }),
    ConfirmationRequired: node.first("ConfirmationRequired", false, x => x.content === 'true'),
    Status: node.first("Status", false, x => (x.content ?? '') as s.JobStatus),
    Manifest: node.first("Manifest", false, JobManifest_Parse),
    Operation: node.first("Operation", false, JobOperation_Parse),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    ProgressSummary: node.first("ProgressSummary", false, JobProgressSummary_Parse),
    FailureReasons: node.getList("FailureReasons", "member").map(JobFailure_Parse),
    Report: node.first("Report", false, JobReport_Parse),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    TerminationDate: node.first("TerminationDate", false, x => xmlP.parseTimestamp(x.content)),
    SuspendedDate: node.first("SuspendedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function JobProgressSummary_Parse(node: xmlP.XmlNode): s.JobProgressSummary {
  return {
    TotalNumberOfTasks: node.first("TotalNumberOfTasks", false, x => parseInt(x.content ?? '0')),
    NumberOfTasksSucceeded: node.first("NumberOfTasksSucceeded", false, x => parseInt(x.content ?? '0')),
    NumberOfTasksFailed: node.first("NumberOfTasksFailed", false, x => parseInt(x.content ?? '0')),
  };
}

function JobFailure_Parse(node: xmlP.XmlNode): s.JobFailure {
  return node.strings({
    optional: {"FailureCode":true,"FailureReason":true},
  });
}

function PolicyStatus_Parse(node: xmlP.XmlNode): s.PolicyStatus {
  return {
    IsPublic: node.first("IsPublic", false, x => x.content === 'true'),
  };
}

function AccessPoint_Parse(node: xmlP.XmlNode): s.AccessPoint {
  return {
    ...node.strings({
      required: {"Name":true,"Bucket":true},
      optional: {"AccessPointArn":true},
    }),
    NetworkOrigin: node.first("NetworkOrigin", true, x => (x.content ?? '') as s.NetworkOrigin),
    VpcConfiguration: node.first("VpcConfiguration", false, VpcConfiguration_Parse),
  };
}

function JobListDescriptor_Parse(node: xmlP.XmlNode): s.JobListDescriptor {
  return {
    ...node.strings({
      optional: {"JobId":true,"Description":true},
    }),
    Operation: node.first("Operation", false, x => (x.content ?? '') as s.OperationName),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    Status: node.first("Status", false, x => (x.content ?? '') as s.JobStatus),
    CreationTime: node.first("CreationTime", false, x => xmlP.parseTimestamp(x.content)),
    TerminationDate: node.first("TerminationDate", false, x => xmlP.parseTimestamp(x.content)),
    ProgressSummary: node.first("ProgressSummary", false, JobProgressSummary_Parse),
  };
}

function RegionalBucket_Parse(node: xmlP.XmlNode): s.RegionalBucket {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"BucketArn":true,"OutpostId":true},
    }),
    PublicAccessBlockEnabled: node.first("PublicAccessBlockEnabled", true, x => x.content === 'true'),
    CreationDate: node.first("CreationDate", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function ListStorageLensConfigurationEntry_Parse(node: xmlP.XmlNode): s.ListStorageLensConfigurationEntry {
  return {
    ...node.strings({
      required: {"Id":true,"StorageLensArn":true,"HomeRegion":true},
    }),
    IsEnabled: node.first("IsEnabled", false, x => x.content === 'true'),
  };
}
