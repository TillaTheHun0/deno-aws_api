// Autogenerated API client for: AWS CodeBuild

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CodeBuild {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeBuild.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-10-06",
    "endpointPrefix": "codebuild",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS CodeBuild",
    "serviceId": "CodeBuild",
    "signatureVersion": "v4",
    "targetPrefix": "CodeBuild_20161006",
    "uid": "codebuild-2016-10-06"
  };

  async batchDeleteBuilds(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteBuildsInput,
  ): Promise<s.BatchDeleteBuildsOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildsDeleted": ["s"],
        "buildsNotDeleted": [toBuildNotDeleted],
      },
    }, await resp.json());
  }

  async batchGetBuildBatches(
    {abortSignal, ...params}: RequestConfig & s.BatchGetBuildBatchesInput,
  ): Promise<s.BatchGetBuildBatchesOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetBuildBatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatches": [toBuildBatch],
        "buildBatchesNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetBuilds(
    {abortSignal, ...params}: RequestConfig & s.BatchGetBuildsInput,
  ): Promise<s.BatchGetBuildsOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "builds": [toBuild],
        "buildsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetProjects(
    {abortSignal, ...params}: RequestConfig & s.BatchGetProjectsInput,
  ): Promise<s.BatchGetProjectsOutput> {
    const body: jsonP.JSONObject = {
      names: params["names"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "projects": [toProject],
        "projectsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetReportGroups(
    {abortSignal, ...params}: RequestConfig & s.BatchGetReportGroupsInput,
  ): Promise<s.BatchGetReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArns: params["reportGroupArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroups": [toReportGroup],
        "reportGroupsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetReports(
    {abortSignal, ...params}: RequestConfig & s.BatchGetReportsInput,
  ): Promise<s.BatchGetReportsOutput> {
    const body: jsonP.JSONObject = {
      reportArns: params["reportArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetReports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reports": [toReport],
        "reportsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectInput,
  ): Promise<s.CreateProjectOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      source: fromProjectSource(params["source"]),
      secondarySources: params["secondarySources"]?.map(x => fromProjectSource(x)),
      sourceVersion: params["sourceVersion"],
      secondarySourceVersions: params["secondarySourceVersions"]?.map(x => fromProjectSourceVersion(x)),
      artifacts: fromProjectArtifacts(params["artifacts"]),
      secondaryArtifacts: params["secondaryArtifacts"]?.map(x => fromProjectArtifacts(x)),
      cache: fromProjectCache(params["cache"]),
      environment: fromProjectEnvironment(params["environment"]),
      serviceRole: params["serviceRole"],
      timeoutInMinutes: params["timeoutInMinutes"],
      queuedTimeoutInMinutes: params["queuedTimeoutInMinutes"],
      encryptionKey: params["encryptionKey"],
      tags: params["tags"]?.map(x => fromTag(x)),
      vpcConfig: fromVpcConfig(params["vpcConfig"]),
      badgeEnabled: params["badgeEnabled"],
      logsConfig: fromLogsConfig(params["logsConfig"]),
      fileSystemLocations: params["fileSystemLocations"]?.map(x => fromProjectFileSystemLocation(x)),
      buildBatchConfig: fromProjectBuildBatchConfig(params["buildBatchConfig"]),
      concurrentBuildLimit: params["concurrentBuildLimit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "project": toProject,
      },
    }, await resp.json());
  }

  async createReportGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateReportGroupInput,
  ): Promise<s.CreateReportGroupOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      type: params["type"],
      exportConfig: fromReportExportConfig(params["exportConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroup": toReportGroup,
      },
    }, await resp.json());
  }

  async createWebhook(
    {abortSignal, ...params}: RequestConfig & s.CreateWebhookInput,
  ): Promise<s.CreateWebhookOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      branchFilter: params["branchFilter"],
      filterGroups: params["filterGroups"]?.map(x => x?.map(fromWebhookFilter)),
      buildType: params["buildType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhook": toWebhook,
      },
    }, await resp.json());
  }

  async deleteBuildBatch(
    {abortSignal, ...params}: RequestConfig & s.DeleteBuildBatchInput,
  ): Promise<s.DeleteBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "buildsDeleted": ["s"],
        "buildsNotDeleted": [toBuildNotDeleted],
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteProject",
    });
    await resp.text();
  }

  async deleteReport(
    {abortSignal, ...params}: RequestConfig & s.DeleteReportInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReport",
    });
    await resp.text();
  }

  async deleteReportGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteReportGroupInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      deleteReports: params["deleteReports"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReportGroup",
    });
    await resp.text();
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourcePolicyInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    await resp.text();
  }

  async deleteSourceCredentials(
    {abortSignal, ...params}: RequestConfig & s.DeleteSourceCredentialsInput,
  ): Promise<s.DeleteSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async deleteWebhook(
    {abortSignal, ...params}: RequestConfig & s.DeleteWebhookInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWebhook",
    });
    await resp.text();
  }

  async describeCodeCoverages(
    {abortSignal, ...params}: RequestConfig & s.DescribeCodeCoveragesInput,
  ): Promise<s.DescribeCodeCoveragesOutput> {
    const body: jsonP.JSONObject = {
      reportArn: params["reportArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      minLineCoveragePercentage: params["minLineCoveragePercentage"],
      maxLineCoveragePercentage: params["maxLineCoveragePercentage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCodeCoverages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "codeCoverages": [toCodeCoverage],
      },
    }, await resp.json());
  }

  async describeTestCases(
    {abortSignal, ...params}: RequestConfig & s.DescribeTestCasesInput,
  ): Promise<s.DescribeTestCasesOutput> {
    const body: jsonP.JSONObject = {
      reportArn: params["reportArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromTestCaseFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTestCases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "testCases": [toTestCase],
      },
    }, await resp.json());
  }

  async getReportGroupTrend(
    {abortSignal, ...params}: RequestConfig & s.GetReportGroupTrendInput,
  ): Promise<s.GetReportGroupTrendOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArn: params["reportGroupArn"],
      numOfReports: params["numOfReports"],
      trendField: params["trendField"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReportGroupTrend",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "stats": toReportGroupTrendStats,
        "rawData": [toReportWithRawData],
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetResourcePolicyInput,
  ): Promise<s.GetResourcePolicyOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": "s",
      },
    }, await resp.json());
  }

  async importSourceCredentials(
    {abortSignal, ...params}: RequestConfig & s.ImportSourceCredentialsInput,
  ): Promise<s.ImportSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {
      username: params["username"],
      token: params["token"],
      serverType: params["serverType"],
      authType: params["authType"],
      shouldOverwrite: params["shouldOverwrite"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async invalidateProjectCache(
    {abortSignal, ...params}: RequestConfig & s.InvalidateProjectCacheInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InvalidateProjectCache",
    });
    await resp.text();
  }

  async listBuildBatches(
    {abortSignal, ...params}: RequestConfig & s.ListBuildBatchesInput = {},
  ): Promise<s.ListBuildBatchesOutput> {
    const body: jsonP.JSONObject = {
      filter: fromBuildBatchFilter(params["filter"]),
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildBatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuildBatchesForProject(
    {abortSignal, ...params}: RequestConfig & s.ListBuildBatchesForProjectInput = {},
  ): Promise<s.ListBuildBatchesForProjectOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      filter: fromBuildBatchFilter(params["filter"]),
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildBatchesForProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuilds(
    {abortSignal, ...params}: RequestConfig & s.ListBuildsInput = {},
  ): Promise<s.ListBuildsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuildsForProject(
    {abortSignal, ...params}: RequestConfig & s.ListBuildsForProjectInput,
  ): Promise<s.ListBuildsForProjectOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildsForProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCuratedEnvironmentImages(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ListCuratedEnvironmentImagesOutput> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCuratedEnvironmentImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "platforms": [toEnvironmentPlatform],
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & s.ListProjectsInput = {},
  ): Promise<s.ListProjectsOutput> {
    const body: jsonP.JSONObject = {
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "projects": ["s"],
      },
    }, await resp.json());
  }

  async listReportGroups(
    {abortSignal, ...params}: RequestConfig & s.ListReportGroupsInput = {},
  ): Promise<s.ListReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reportGroups": ["s"],
      },
    }, await resp.json());
  }

  async listReports(
    {abortSignal, ...params}: RequestConfig & s.ListReportsInput = {},
  ): Promise<s.ListReportsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromReportFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reports": ["s"],
      },
    }, await resp.json());
  }

  async listReportsForReportGroup(
    {abortSignal, ...params}: RequestConfig & s.ListReportsForReportGroupInput,
  ): Promise<s.ListReportsForReportGroupOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArn: params["reportGroupArn"],
      nextToken: params["nextToken"],
      sortOrder: params["sortOrder"],
      maxResults: params["maxResults"],
      filter: fromReportFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReportsForReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reports": ["s"],
      },
    }, await resp.json());
  }

  async listSharedProjects(
    {abortSignal, ...params}: RequestConfig & s.ListSharedProjectsInput = {},
  ): Promise<s.ListSharedProjectsOutput> {
    const body: jsonP.JSONObject = {
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSharedProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "projects": ["s"],
      },
    }, await resp.json());
  }

  async listSharedReportGroups(
    {abortSignal, ...params}: RequestConfig & s.ListSharedReportGroupsInput = {},
  ): Promise<s.ListSharedReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSharedReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reportGroups": ["s"],
      },
    }, await resp.json());
  }

  async listSourceCredentials(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ListSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sourceCredentialsInfos": [toSourceCredentialsInfo],
      },
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutResourcePolicyInput,
  ): Promise<s.PutResourcePolicyOutput> {
    const body: jsonP.JSONObject = {
      policy: params["policy"],
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceArn": "s",
      },
    }, await resp.json());
  }

  async retryBuild(
    {abortSignal, ...params}: RequestConfig & s.RetryBuildInput = {},
  ): Promise<s.RetryBuildOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
      idempotencyToken: params["idempotencyToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetryBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async retryBuildBatch(
    {abortSignal, ...params}: RequestConfig & s.RetryBuildBatchInput = {},
  ): Promise<s.RetryBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
      idempotencyToken: params["idempotencyToken"],
      retryType: params["retryType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetryBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async startBuild(
    {abortSignal, ...params}: RequestConfig & s.StartBuildInput,
  ): Promise<s.StartBuildOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      secondarySourcesOverride: params["secondarySourcesOverride"]?.map(x => fromProjectSource(x)),
      secondarySourcesVersionOverride: params["secondarySourcesVersionOverride"]?.map(x => fromProjectSourceVersion(x)),
      sourceVersion: params["sourceVersion"],
      artifactsOverride: fromProjectArtifacts(params["artifactsOverride"]),
      secondaryArtifactsOverride: params["secondaryArtifactsOverride"]?.map(x => fromProjectArtifacts(x)),
      environmentVariablesOverride: params["environmentVariablesOverride"]?.map(x => fromEnvironmentVariable(x)),
      sourceTypeOverride: params["sourceTypeOverride"],
      sourceLocationOverride: params["sourceLocationOverride"],
      sourceAuthOverride: fromSourceAuth(params["sourceAuthOverride"]),
      gitCloneDepthOverride: params["gitCloneDepthOverride"],
      gitSubmodulesConfigOverride: fromGitSubmodulesConfig(params["gitSubmodulesConfigOverride"]),
      buildspecOverride: params["buildspecOverride"],
      insecureSslOverride: params["insecureSslOverride"],
      reportBuildStatusOverride: params["reportBuildStatusOverride"],
      buildStatusConfigOverride: fromBuildStatusConfig(params["buildStatusConfigOverride"]),
      environmentTypeOverride: params["environmentTypeOverride"],
      imageOverride: params["imageOverride"],
      computeTypeOverride: params["computeTypeOverride"],
      certificateOverride: params["certificateOverride"],
      cacheOverride: fromProjectCache(params["cacheOverride"]),
      serviceRoleOverride: params["serviceRoleOverride"],
      privilegedModeOverride: params["privilegedModeOverride"],
      timeoutInMinutesOverride: params["timeoutInMinutesOverride"],
      queuedTimeoutInMinutesOverride: params["queuedTimeoutInMinutesOverride"],
      encryptionKeyOverride: params["encryptionKeyOverride"],
      idempotencyToken: params["idempotencyToken"],
      logsConfigOverride: fromLogsConfig(params["logsConfigOverride"]),
      registryCredentialOverride: fromRegistryCredential(params["registryCredentialOverride"]),
      imagePullCredentialsTypeOverride: params["imagePullCredentialsTypeOverride"],
      debugSessionEnabled: params["debugSessionEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async startBuildBatch(
    {abortSignal, ...params}: RequestConfig & s.StartBuildBatchInput,
  ): Promise<s.StartBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      secondarySourcesOverride: params["secondarySourcesOverride"]?.map(x => fromProjectSource(x)),
      secondarySourcesVersionOverride: params["secondarySourcesVersionOverride"]?.map(x => fromProjectSourceVersion(x)),
      sourceVersion: params["sourceVersion"],
      artifactsOverride: fromProjectArtifacts(params["artifactsOverride"]),
      secondaryArtifactsOverride: params["secondaryArtifactsOverride"]?.map(x => fromProjectArtifacts(x)),
      environmentVariablesOverride: params["environmentVariablesOverride"]?.map(x => fromEnvironmentVariable(x)),
      sourceTypeOverride: params["sourceTypeOverride"],
      sourceLocationOverride: params["sourceLocationOverride"],
      sourceAuthOverride: fromSourceAuth(params["sourceAuthOverride"]),
      gitCloneDepthOverride: params["gitCloneDepthOverride"],
      gitSubmodulesConfigOverride: fromGitSubmodulesConfig(params["gitSubmodulesConfigOverride"]),
      buildspecOverride: params["buildspecOverride"],
      insecureSslOverride: params["insecureSslOverride"],
      reportBuildBatchStatusOverride: params["reportBuildBatchStatusOverride"],
      environmentTypeOverride: params["environmentTypeOverride"],
      imageOverride: params["imageOverride"],
      computeTypeOverride: params["computeTypeOverride"],
      certificateOverride: params["certificateOverride"],
      cacheOverride: fromProjectCache(params["cacheOverride"]),
      serviceRoleOverride: params["serviceRoleOverride"],
      privilegedModeOverride: params["privilegedModeOverride"],
      buildTimeoutInMinutesOverride: params["buildTimeoutInMinutesOverride"],
      queuedTimeoutInMinutesOverride: params["queuedTimeoutInMinutesOverride"],
      encryptionKeyOverride: params["encryptionKeyOverride"],
      idempotencyToken: params["idempotencyToken"],
      logsConfigOverride: fromLogsConfig(params["logsConfigOverride"]),
      registryCredentialOverride: fromRegistryCredential(params["registryCredentialOverride"]),
      imagePullCredentialsTypeOverride: params["imagePullCredentialsTypeOverride"],
      buildBatchConfigOverride: fromProjectBuildBatchConfig(params["buildBatchConfigOverride"]),
      debugSessionEnabled: params["debugSessionEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async stopBuild(
    {abortSignal, ...params}: RequestConfig & s.StopBuildInput,
  ): Promise<s.StopBuildOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async stopBuildBatch(
    {abortSignal, ...params}: RequestConfig & s.StopBuildBatchInput,
  ): Promise<s.StopBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async updateProject(
    {abortSignal, ...params}: RequestConfig & s.UpdateProjectInput,
  ): Promise<s.UpdateProjectOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      source: fromProjectSource(params["source"]),
      secondarySources: params["secondarySources"]?.map(x => fromProjectSource(x)),
      sourceVersion: params["sourceVersion"],
      secondarySourceVersions: params["secondarySourceVersions"]?.map(x => fromProjectSourceVersion(x)),
      artifacts: fromProjectArtifacts(params["artifacts"]),
      secondaryArtifacts: params["secondaryArtifacts"]?.map(x => fromProjectArtifacts(x)),
      cache: fromProjectCache(params["cache"]),
      environment: fromProjectEnvironment(params["environment"]),
      serviceRole: params["serviceRole"],
      timeoutInMinutes: params["timeoutInMinutes"],
      queuedTimeoutInMinutes: params["queuedTimeoutInMinutes"],
      encryptionKey: params["encryptionKey"],
      tags: params["tags"]?.map(x => fromTag(x)),
      vpcConfig: fromVpcConfig(params["vpcConfig"]),
      badgeEnabled: params["badgeEnabled"],
      logsConfig: fromLogsConfig(params["logsConfig"]),
      fileSystemLocations: params["fileSystemLocations"]?.map(x => fromProjectFileSystemLocation(x)),
      buildBatchConfig: fromProjectBuildBatchConfig(params["buildBatchConfig"]),
      concurrentBuildLimit: params["concurrentBuildLimit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "project": toProject,
      },
    }, await resp.json());
  }

  async updateReportGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateReportGroupInput,
  ): Promise<s.UpdateReportGroupOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      exportConfig: fromReportExportConfig(params["exportConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroup": toReportGroup,
      },
    }, await resp.json());
  }

  async updateWebhook(
    {abortSignal, ...params}: RequestConfig & s.UpdateWebhookInput,
  ): Promise<s.UpdateWebhookOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      branchFilter: params["branchFilter"],
      rotateSecret: params["rotateSecret"],
      filterGroups: params["filterGroups"]?.map(x => x?.map(fromWebhookFilter)),
      buildType: params["buildType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhook": toWebhook,
      },
    }, await resp.json());
  }

}

function fromProjectSource(input?: s.ProjectSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    gitCloneDepth: input["gitCloneDepth"],
    gitSubmodulesConfig: fromGitSubmodulesConfig(input["gitSubmodulesConfig"]),
    buildspec: input["buildspec"],
    auth: fromSourceAuth(input["auth"]),
    reportBuildStatus: input["reportBuildStatus"],
    buildStatusConfig: fromBuildStatusConfig(input["buildStatusConfig"]),
    insecureSsl: input["insecureSsl"],
    sourceIdentifier: input["sourceIdentifier"],
  }
}
function toProjectSource(root: jsonP.JSONValue): s.ProjectSource {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
    },
    optional: {
      "location": "s",
      "gitCloneDepth": "n",
      "gitSubmodulesConfig": toGitSubmodulesConfig,
      "buildspec": "s",
      "auth": toSourceAuth,
      "reportBuildStatus": "b",
      "buildStatusConfig": toBuildStatusConfig,
      "insecureSsl": "b",
      "sourceIdentifier": "s",
    },
  }, root);
}

function fromGitSubmodulesConfig(input?: s.GitSubmodulesConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fetchSubmodules: input["fetchSubmodules"],
  }
}
function toGitSubmodulesConfig(root: jsonP.JSONValue): s.GitSubmodulesConfig {
  return jsonP.readObj({
    required: {
      "fetchSubmodules": "b",
    },
    optional: {},
  }, root);
}

function fromSourceAuth(input?: s.SourceAuth | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    resource: input["resource"],
  }
}
function toSourceAuth(root: jsonP.JSONValue): s.SourceAuth {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceAuthType>(x),
    },
    optional: {
      "resource": "s",
    },
  }, root);
}

function fromBuildStatusConfig(input?: s.BuildStatusConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    context: input["context"],
    targetUrl: input["targetUrl"],
  }
}
function toBuildStatusConfig(root: jsonP.JSONValue): s.BuildStatusConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "context": "s",
      "targetUrl": "s",
    },
  }, root);
}

function fromProjectSourceVersion(input?: s.ProjectSourceVersion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceIdentifier: input["sourceIdentifier"],
    sourceVersion: input["sourceVersion"],
  }
}
function toProjectSourceVersion(root: jsonP.JSONValue): s.ProjectSourceVersion {
  return jsonP.readObj({
    required: {
      "sourceIdentifier": "s",
      "sourceVersion": "s",
    },
    optional: {},
  }, root);
}

function fromProjectArtifacts(input?: s.ProjectArtifacts | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    path: input["path"],
    namespaceType: input["namespaceType"],
    name: input["name"],
    packaging: input["packaging"],
    overrideArtifactName: input["overrideArtifactName"],
    encryptionDisabled: input["encryptionDisabled"],
    artifactIdentifier: input["artifactIdentifier"],
  }
}
function toProjectArtifacts(root: jsonP.JSONValue): s.ProjectArtifacts {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactsType>(x),
    },
    optional: {
      "location": "s",
      "path": "s",
      "namespaceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactNamespace>(x),
      "name": "s",
      "packaging": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactPackaging>(x),
      "overrideArtifactName": "b",
      "encryptionDisabled": "b",
      "artifactIdentifier": "s",
    },
  }, root);
}

function fromProjectCache(input?: s.ProjectCache | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    modes: input["modes"],
  }
}
function toProjectCache(root: jsonP.JSONValue): s.ProjectCache {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CacheType>(x),
    },
    optional: {
      "location": "s",
      "modes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.CacheMode>(x)],
    },
  }, root);
}

function fromProjectEnvironment(input?: s.ProjectEnvironment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    image: input["image"],
    computeType: input["computeType"],
    environmentVariables: input["environmentVariables"]?.map(x => fromEnvironmentVariable(x)),
    privilegedMode: input["privilegedMode"],
    certificate: input["certificate"],
    registryCredential: fromRegistryCredential(input["registryCredential"]),
    imagePullCredentialsType: input["imagePullCredentialsType"],
  }
}
function toProjectEnvironment(root: jsonP.JSONValue): s.ProjectEnvironment {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EnvironmentType>(x),
      "image": "s",
      "computeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComputeType>(x),
    },
    optional: {
      "environmentVariables": [toEnvironmentVariable],
      "privilegedMode": "b",
      "certificate": "s",
      "registryCredential": toRegistryCredential,
      "imagePullCredentialsType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImagePullCredentialsType>(x),
    },
  }, root);
}

function fromEnvironmentVariable(input?: s.EnvironmentVariable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
    type: input["type"],
  }
}
function toEnvironmentVariable(root: jsonP.JSONValue): s.EnvironmentVariable {
  return jsonP.readObj({
    required: {
      "name": "s",
      "value": "s",
    },
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EnvironmentVariableType>(x),
    },
  }, root);
}

function fromRegistryCredential(input?: s.RegistryCredential | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credential: input["credential"],
    credentialProvider: input["credentialProvider"],
  }
}
function toRegistryCredential(root: jsonP.JSONValue): s.RegistryCredential {
  return jsonP.readObj({
    required: {
      "credential": "s",
      "credentialProvider": (x: jsonP.JSONValue) => cmnP.readEnum<s.CredentialProviderType>(x),
    },
    optional: {},
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

function fromVpcConfig(input?: s.VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    vpcId: input["vpcId"],
    subnets: input["subnets"],
    securityGroupIds: input["securityGroupIds"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): s.VpcConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "vpcId": "s",
      "subnets": ["s"],
      "securityGroupIds": ["s"],
    },
  }, root);
}

function fromLogsConfig(input?: s.LogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatchLogs: fromCloudWatchLogsConfig(input["cloudWatchLogs"]),
    s3Logs: fromS3LogsConfig(input["s3Logs"]),
  }
}
function toLogsConfig(root: jsonP.JSONValue): s.LogsConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "cloudWatchLogs": toCloudWatchLogsConfig,
      "s3Logs": toS3LogsConfig,
    },
  }, root);
}

function fromCloudWatchLogsConfig(input?: s.CloudWatchLogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    groupName: input["groupName"],
    streamName: input["streamName"],
  }
}
function toCloudWatchLogsConfig(root: jsonP.JSONValue): s.CloudWatchLogsConfig {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogsConfigStatusType>(x),
    },
    optional: {
      "groupName": "s",
      "streamName": "s",
    },
  }, root);
}

function fromS3LogsConfig(input?: s.S3LogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    location: input["location"],
    encryptionDisabled: input["encryptionDisabled"],
  }
}
function toS3LogsConfig(root: jsonP.JSONValue): s.S3LogsConfig {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogsConfigStatusType>(x),
    },
    optional: {
      "location": "s",
      "encryptionDisabled": "b",
    },
  }, root);
}

function fromProjectFileSystemLocation(input?: s.ProjectFileSystemLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    mountPoint: input["mountPoint"],
    identifier: input["identifier"],
    mountOptions: input["mountOptions"],
  }
}
function toProjectFileSystemLocation(root: jsonP.JSONValue): s.ProjectFileSystemLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileSystemType>(x),
      "location": "s",
      "mountPoint": "s",
      "identifier": "s",
      "mountOptions": "s",
    },
  }, root);
}

function fromProjectBuildBatchConfig(input?: s.ProjectBuildBatchConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceRole: input["serviceRole"],
    combineArtifacts: input["combineArtifacts"],
    restrictions: fromBatchRestrictions(input["restrictions"]),
    timeoutInMins: input["timeoutInMins"],
  }
}
function toProjectBuildBatchConfig(root: jsonP.JSONValue): s.ProjectBuildBatchConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceRole": "s",
      "combineArtifacts": "b",
      "restrictions": toBatchRestrictions,
      "timeoutInMins": "n",
    },
  }, root);
}

function fromBatchRestrictions(input?: s.BatchRestrictions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumBuildsAllowed: input["maximumBuildsAllowed"],
    computeTypesAllowed: input["computeTypesAllowed"],
  }
}
function toBatchRestrictions(root: jsonP.JSONValue): s.BatchRestrictions {
  return jsonP.readObj({
    required: {},
    optional: {
      "maximumBuildsAllowed": "n",
      "computeTypesAllowed": ["s"],
    },
  }, root);
}

function fromReportExportConfig(input?: s.ReportExportConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exportConfigType: input["exportConfigType"],
    s3Destination: fromS3ReportExportConfig(input["s3Destination"]),
  }
}
function toReportExportConfig(root: jsonP.JSONValue): s.ReportExportConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "exportConfigType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportExportConfigType>(x),
      "s3Destination": toS3ReportExportConfig,
    },
  }, root);
}

function fromS3ReportExportConfig(input?: s.S3ReportExportConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    bucketOwner: input["bucketOwner"],
    path: input["path"],
    packaging: input["packaging"],
    encryptionKey: input["encryptionKey"],
    encryptionDisabled: input["encryptionDisabled"],
  }
}
function toS3ReportExportConfig(root: jsonP.JSONValue): s.S3ReportExportConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "bucketOwner": "s",
      "path": "s",
      "packaging": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportPackagingType>(x),
      "encryptionKey": "s",
      "encryptionDisabled": "b",
    },
  }, root);
}

function fromWebhookFilter(input?: s.WebhookFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    pattern: input["pattern"],
    excludeMatchedPattern: input["excludeMatchedPattern"],
  }
}
function toWebhookFilter(root: jsonP.JSONValue): s.WebhookFilter {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.WebhookFilterType>(x),
      "pattern": "s",
    },
    optional: {
      "excludeMatchedPattern": "b",
    },
  }, root);
}

function fromTestCaseFilter(input?: s.TestCaseFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    keyword: input["keyword"],
  }
}

function fromBuildBatchFilter(input?: s.BuildBatchFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
  }
}

function fromReportFilter(input?: s.ReportFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
  }
}

function toBuildNotDeleted(root: jsonP.JSONValue): s.BuildNotDeleted {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "statusCode": "s",
    },
  }, root);
}

function toBuildBatch(root: jsonP.JSONValue): s.BuildBatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "arn": "s",
      "startTime": "d",
      "endTime": "d",
      "currentPhase": "s",
      "buildBatchStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "sourceVersion": "s",
      "resolvedSourceVersion": "s",
      "projectName": "s",
      "phases": [toBuildBatchPhase],
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toBuildArtifacts,
      "secondaryArtifacts": [toBuildArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "logConfig": toLogsConfig,
      "buildTimeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "complete": "b",
      "initiator": "s",
      "vpcConfig": toVpcConfig,
      "encryptionKey": "s",
      "buildBatchNumber": "n",
      "fileSystemLocations": [toProjectFileSystemLocation],
      "buildBatchConfig": toProjectBuildBatchConfig,
      "buildGroups": [toBuildGroup],
      "debugSessionEnabled": "b",
    },
  }, root);
}

function toBuildBatchPhase(root: jsonP.JSONValue): s.BuildBatchPhase {
  return jsonP.readObj({
    required: {},
    optional: {
      "phaseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BuildBatchPhaseType>(x),
      "phaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "startTime": "d",
      "endTime": "d",
      "durationInSeconds": "n",
      "contexts": [toPhaseContext],
    },
  }, root);
}

function toPhaseContext(root: jsonP.JSONValue): s.PhaseContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "message": "s",
    },
  }, root);
}

function toBuildArtifacts(root: jsonP.JSONValue): s.BuildArtifacts {
  return jsonP.readObj({
    required: {},
    optional: {
      "location": "s",
      "sha256sum": "s",
      "md5sum": "s",
      "overrideArtifactName": "b",
      "encryptionDisabled": "b",
      "artifactIdentifier": "s",
    },
  }, root);
}

function toBuildGroup(root: jsonP.JSONValue): s.BuildGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "identifier": "s",
      "dependsOn": ["s"],
      "ignoreFailure": "b",
      "currentBuildSummary": toBuildSummary,
      "priorBuildSummaryList": [toBuildSummary],
    },
  }, root);
}

function toBuildSummary(root: jsonP.JSONValue): s.BuildSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "requestedOn": "d",
      "buildStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "primaryArtifact": toResolvedArtifact,
      "secondaryArtifacts": [toResolvedArtifact],
    },
  }, root);
}

function toResolvedArtifact(root: jsonP.JSONValue): s.ResolvedArtifact {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactsType>(x),
      "location": "s",
      "identifier": "s",
    },
  }, root);
}

function toBuild(root: jsonP.JSONValue): s.Build {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "arn": "s",
      "buildNumber": "n",
      "startTime": "d",
      "endTime": "d",
      "currentPhase": "s",
      "buildStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "sourceVersion": "s",
      "resolvedSourceVersion": "s",
      "projectName": "s",
      "phases": [toBuildPhase],
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toBuildArtifacts,
      "secondaryArtifacts": [toBuildArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "logs": toLogsLocation,
      "timeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "buildComplete": "b",
      "initiator": "s",
      "vpcConfig": toVpcConfig,
      "networkInterface": toNetworkInterface,
      "encryptionKey": "s",
      "exportedEnvironmentVariables": [toExportedEnvironmentVariable],
      "reportArns": ["s"],
      "fileSystemLocations": [toProjectFileSystemLocation],
      "debugSession": toDebugSession,
      "buildBatchArn": "s",
    },
  }, root);
}

function toBuildPhase(root: jsonP.JSONValue): s.BuildPhase {
  return jsonP.readObj({
    required: {},
    optional: {
      "phaseType": (x: jsonP.JSONValue) => cmnP.readEnum<s.BuildPhaseType>(x),
      "phaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StatusType>(x),
      "startTime": "d",
      "endTime": "d",
      "durationInSeconds": "n",
      "contexts": [toPhaseContext],
    },
  }, root);
}

function toLogsLocation(root: jsonP.JSONValue): s.LogsLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "groupName": "s",
      "streamName": "s",
      "deepLink": "s",
      "s3DeepLink": "s",
      "cloudWatchLogsArn": "s",
      "s3LogsArn": "s",
      "cloudWatchLogs": toCloudWatchLogsConfig,
      "s3Logs": toS3LogsConfig,
    },
  }, root);
}

function toNetworkInterface(root: jsonP.JSONValue): s.NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetId": "s",
      "networkInterfaceId": "s",
    },
  }, root);
}

function toExportedEnvironmentVariable(root: jsonP.JSONValue): s.ExportedEnvironmentVariable {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "value": "s",
    },
  }, root);
}

function toDebugSession(root: jsonP.JSONValue): s.DebugSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "sessionEnabled": "b",
      "sessionTarget": "s",
    },
  }, root);
}

function toProject(root: jsonP.JSONValue): s.Project {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "description": "s",
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "sourceVersion": "s",
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toProjectArtifacts,
      "secondaryArtifacts": [toProjectArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "timeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "encryptionKey": "s",
      "tags": [toTag],
      "created": "d",
      "lastModified": "d",
      "webhook": toWebhook,
      "vpcConfig": toVpcConfig,
      "badge": toProjectBadge,
      "logsConfig": toLogsConfig,
      "fileSystemLocations": [toProjectFileSystemLocation],
      "buildBatchConfig": toProjectBuildBatchConfig,
      "concurrentBuildLimit": "n",
    },
  }, root);
}

function toWebhook(root: jsonP.JSONValue): s.Webhook {
  return jsonP.readObj({
    required: {},
    optional: {
      "url": "s",
      "payloadUrl": "s",
      "secret": "s",
      "branchFilter": "s",
      "filterGroups": [x => jsonP.readList(toWebhookFilter, x)],
      "buildType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WebhookBuildType>(x),
      "lastModifiedSecret": "d",
    },
  }, root);
}

function toProjectBadge(root: jsonP.JSONValue): s.ProjectBadge {
  return jsonP.readObj({
    required: {},
    optional: {
      "badgeEnabled": "b",
      "badgeRequestUrl": "s",
    },
  }, root);
}

function toReportGroup(root: jsonP.JSONValue): s.ReportGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportType>(x),
      "exportConfig": toReportExportConfig,
      "created": "d",
      "lastModified": "d",
      "tags": [toTag],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportGroupStatusType>(x),
    },
  }, root);
}

function toReport(root: jsonP.JSONValue): s.Report {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportType>(x),
      "name": "s",
      "reportGroupArn": "s",
      "executionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReportStatusType>(x),
      "created": "d",
      "expired": "d",
      "exportConfig": toReportExportConfig,
      "truncated": "b",
      "testSummary": toTestReportSummary,
      "codeCoverageSummary": toCodeCoverageReportSummary,
    },
  }, root);
}

function toTestReportSummary(root: jsonP.JSONValue): s.TestReportSummary {
  return jsonP.readObj({
    required: {
      "total": "n",
      "statusCounts": x => jsonP.readMap(String, Number, x),
      "durationInNanoSeconds": "n",
    },
    optional: {},
  }, root);
}

function toCodeCoverageReportSummary(root: jsonP.JSONValue): s.CodeCoverageReportSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "lineCoveragePercentage": "n",
      "linesCovered": "n",
      "linesMissed": "n",
      "branchCoveragePercentage": "n",
      "branchesCovered": "n",
      "branchesMissed": "n",
    },
  }, root);
}

function toCodeCoverage(root: jsonP.JSONValue): s.CodeCoverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "reportARN": "s",
      "filePath": "s",
      "lineCoveragePercentage": "n",
      "linesCovered": "n",
      "linesMissed": "n",
      "branchCoveragePercentage": "n",
      "branchesCovered": "n",
      "branchesMissed": "n",
      "expired": "d",
    },
  }, root);
}

function toTestCase(root: jsonP.JSONValue): s.TestCase {
  return jsonP.readObj({
    required: {},
    optional: {
      "reportArn": "s",
      "testRawDataPath": "s",
      "prefix": "s",
      "name": "s",
      "status": "s",
      "durationInNanoSeconds": "n",
      "message": "s",
      "expired": "d",
    },
  }, root);
}

function toReportGroupTrendStats(root: jsonP.JSONValue): s.ReportGroupTrendStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "average": "s",
      "max": "s",
      "min": "s",
    },
  }, root);
}

function toReportWithRawData(root: jsonP.JSONValue): s.ReportWithRawData {
  return jsonP.readObj({
    required: {},
    optional: {
      "reportArn": "s",
      "data": "s",
    },
  }, root);
}

function toEnvironmentPlatform(root: jsonP.JSONValue): s.EnvironmentPlatform {
  return jsonP.readObj({
    required: {},
    optional: {
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<s.PlatformType>(x),
      "languages": [toEnvironmentLanguage],
    },
  }, root);
}

function toEnvironmentLanguage(root: jsonP.JSONValue): s.EnvironmentLanguage {
  return jsonP.readObj({
    required: {},
    optional: {
      "language": (x: jsonP.JSONValue) => cmnP.readEnum<s.LanguageType>(x),
      "images": [toEnvironmentImage],
    },
  }, root);
}

function toEnvironmentImage(root: jsonP.JSONValue): s.EnvironmentImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "versions": ["s"],
    },
  }, root);
}

function toSourceCredentialsInfo(root: jsonP.JSONValue): s.SourceCredentialsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "serverType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ServerType>(x),
      "authType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthType>(x),
    },
  }, root);
}
