// Autogenerated API client for: AWS CodeBuild

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CodeBuild {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeBuild.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-10-06",
    "endpointPrefix": "codebuild",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS CodeBuild",
    "serviceId": "CodeBuild",
    "signatureVersion": "v4",
    "targetPrefix": "CodeBuild_20161006",
    "uid": "codebuild-2016-10-06"
  };

  async batchDeleteBuilds(
    {abortSignal, ...params}: RequestConfig & BatchDeleteBuildsInput,
  ): Promise<BatchDeleteBuildsOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildsDeleted": ["s"],
        "buildsNotDeleted": [toBuildNotDeleted],
      },
    }, await resp.json());
  }

  async batchGetBuildBatches(
    {abortSignal, ...params}: RequestConfig & BatchGetBuildBatchesInput,
  ): Promise<BatchGetBuildBatchesOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetBuildBatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatches": [toBuildBatch],
        "buildBatchesNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetBuilds(
    {abortSignal, ...params}: RequestConfig & BatchGetBuildsInput,
  ): Promise<BatchGetBuildsOutput> {
    const body: jsonP.JSONObject = {
      ids: params["ids"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "builds": [toBuild],
        "buildsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetProjects(
    {abortSignal, ...params}: RequestConfig & BatchGetProjectsInput,
  ): Promise<BatchGetProjectsOutput> {
    const body: jsonP.JSONObject = {
      names: params["names"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "projects": [toProject],
        "projectsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetReportGroups(
    {abortSignal, ...params}: RequestConfig & BatchGetReportGroupsInput,
  ): Promise<BatchGetReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArns: params["reportGroupArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroups": [toReportGroup],
        "reportGroupsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetReports(
    {abortSignal, ...params}: RequestConfig & BatchGetReportsInput,
  ): Promise<BatchGetReportsOutput> {
    const body: jsonP.JSONObject = {
      reportArns: params["reportArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetReports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reports": [toReport],
        "reportsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & CreateProjectInput,
  ): Promise<CreateProjectOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      source: fromProjectSource(params["source"]),
      secondarySources: params["secondarySources"]?.map(x => fromProjectSource(x)),
      sourceVersion: params["sourceVersion"],
      secondarySourceVersions: params["secondarySourceVersions"]?.map(x => fromProjectSourceVersion(x)),
      artifacts: fromProjectArtifacts(params["artifacts"]),
      secondaryArtifacts: params["secondaryArtifacts"]?.map(x => fromProjectArtifacts(x)),
      cache: fromProjectCache(params["cache"]),
      environment: fromProjectEnvironment(params["environment"]),
      serviceRole: params["serviceRole"],
      timeoutInMinutes: params["timeoutInMinutes"],
      queuedTimeoutInMinutes: params["queuedTimeoutInMinutes"],
      encryptionKey: params["encryptionKey"],
      tags: params["tags"]?.map(x => fromTag(x)),
      vpcConfig: fromVpcConfig(params["vpcConfig"]),
      badgeEnabled: params["badgeEnabled"],
      logsConfig: fromLogsConfig(params["logsConfig"]),
      fileSystemLocations: params["fileSystemLocations"]?.map(x => fromProjectFileSystemLocation(x)),
      buildBatchConfig: fromProjectBuildBatchConfig(params["buildBatchConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "project": toProject,
      },
    }, await resp.json());
  }

  async createReportGroup(
    {abortSignal, ...params}: RequestConfig & CreateReportGroupInput,
  ): Promise<CreateReportGroupOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      type: params["type"],
      exportConfig: fromReportExportConfig(params["exportConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroup": toReportGroup,
      },
    }, await resp.json());
  }

  async createWebhook(
    {abortSignal, ...params}: RequestConfig & CreateWebhookInput,
  ): Promise<CreateWebhookOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      branchFilter: params["branchFilter"],
      filterGroups: params["filterGroups"]?.map(x => x?.map(fromWebhookFilter)),
      buildType: params["buildType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhook": toWebhook,
      },
    }, await resp.json());
  }

  async deleteBuildBatch(
    {abortSignal, ...params}: RequestConfig & DeleteBuildBatchInput,
  ): Promise<DeleteBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "statusCode": "s",
        "buildsDeleted": ["s"],
        "buildsNotDeleted": [toBuildNotDeleted],
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & DeleteProjectInput,
  ): Promise<DeleteProjectOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteReport(
    {abortSignal, ...params}: RequestConfig & DeleteReportInput,
  ): Promise<DeleteReportOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReport",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteReportGroup(
    {abortSignal, ...params}: RequestConfig & DeleteReportGroupInput,
  ): Promise<DeleteReportGroupOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      deleteReports: params["deleteReports"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & DeleteResourcePolicyInput,
  ): Promise<DeleteResourcePolicyOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSourceCredentials(
    {abortSignal, ...params}: RequestConfig & DeleteSourceCredentialsInput,
  ): Promise<DeleteSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async deleteWebhook(
    {abortSignal, ...params}: RequestConfig & DeleteWebhookInput,
  ): Promise<DeleteWebhookOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeCodeCoverages(
    {abortSignal, ...params}: RequestConfig & DescribeCodeCoveragesInput,
  ): Promise<DescribeCodeCoveragesOutput> {
    const body: jsonP.JSONObject = {
      reportArn: params["reportArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      minLineCoveragePercentage: params["minLineCoveragePercentage"],
      maxLineCoveragePercentage: params["maxLineCoveragePercentage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCodeCoverages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "codeCoverages": [toCodeCoverage],
      },
    }, await resp.json());
  }

  async describeTestCases(
    {abortSignal, ...params}: RequestConfig & DescribeTestCasesInput,
  ): Promise<DescribeTestCasesOutput> {
    const body: jsonP.JSONObject = {
      reportArn: params["reportArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromTestCaseFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTestCases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "testCases": [toTestCase],
      },
    }, await resp.json());
  }

  async getReportGroupTrend(
    {abortSignal, ...params}: RequestConfig & GetReportGroupTrendInput,
  ): Promise<GetReportGroupTrendOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArn: params["reportGroupArn"],
      numOfReports: params["numOfReports"],
      trendField: params["trendField"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetReportGroupTrend",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "stats": toReportGroupTrendStats,
        "rawData": [toReportWithRawData],
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & GetResourcePolicyInput,
  ): Promise<GetResourcePolicyOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": "s",
      },
    }, await resp.json());
  }

  async importSourceCredentials(
    {abortSignal, ...params}: RequestConfig & ImportSourceCredentialsInput,
  ): Promise<ImportSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {
      username: params["username"],
      token: params["token"],
      serverType: params["serverType"],
      authType: params["authType"],
      shouldOverwrite: params["shouldOverwrite"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async invalidateProjectCache(
    {abortSignal, ...params}: RequestConfig & InvalidateProjectCacheInput,
  ): Promise<InvalidateProjectCacheOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InvalidateProjectCache",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listBuildBatches(
    {abortSignal, ...params}: RequestConfig & ListBuildBatchesInput = {},
  ): Promise<ListBuildBatchesOutput> {
    const body: jsonP.JSONObject = {
      filter: fromBuildBatchFilter(params["filter"]),
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildBatches",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuildBatchesForProject(
    {abortSignal, ...params}: RequestConfig & ListBuildBatchesForProjectInput = {},
  ): Promise<ListBuildBatchesForProjectOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      filter: fromBuildBatchFilter(params["filter"]),
      maxResults: params["maxResults"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildBatchesForProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuilds(
    {abortSignal, ...params}: RequestConfig & ListBuildsInput = {},
  ): Promise<ListBuildsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuilds",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listBuildsForProject(
    {abortSignal, ...params}: RequestConfig & ListBuildsForProjectInput,
  ): Promise<ListBuildsForProjectOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBuildsForProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listCuratedEnvironmentImages(
    {abortSignal, ...params}: RequestConfig & ListCuratedEnvironmentImagesInput = {},
  ): Promise<ListCuratedEnvironmentImagesOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCuratedEnvironmentImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "platforms": [toEnvironmentPlatform],
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & ListProjectsInput = {},
  ): Promise<ListProjectsOutput> {
    const body: jsonP.JSONObject = {
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "projects": ["s"],
      },
    }, await resp.json());
  }

  async listReportGroups(
    {abortSignal, ...params}: RequestConfig & ListReportGroupsInput = {},
  ): Promise<ListReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reportGroups": ["s"],
      },
    }, await resp.json());
  }

  async listReports(
    {abortSignal, ...params}: RequestConfig & ListReportsInput = {},
  ): Promise<ListReportsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromReportFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReports",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reports": ["s"],
      },
    }, await resp.json());
  }

  async listReportsForReportGroup(
    {abortSignal, ...params}: RequestConfig & ListReportsForReportGroupInput,
  ): Promise<ListReportsForReportGroupOutput> {
    const body: jsonP.JSONObject = {
      reportGroupArn: params["reportGroupArn"],
      nextToken: params["nextToken"],
      sortOrder: params["sortOrder"],
      maxResults: params["maxResults"],
      filter: fromReportFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListReportsForReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reports": ["s"],
      },
    }, await resp.json());
  }

  async listSharedProjects(
    {abortSignal, ...params}: RequestConfig & ListSharedProjectsInput = {},
  ): Promise<ListSharedProjectsOutput> {
    const body: jsonP.JSONObject = {
      sortBy: params["sortBy"],
      sortOrder: params["sortOrder"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSharedProjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "projects": ["s"],
      },
    }, await resp.json());
  }

  async listSharedReportGroups(
    {abortSignal, ...params}: RequestConfig & ListSharedReportGroupsInput = {},
  ): Promise<ListSharedReportGroupsOutput> {
    const body: jsonP.JSONObject = {
      sortOrder: params["sortOrder"],
      sortBy: params["sortBy"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSharedReportGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "reportGroups": ["s"],
      },
    }, await resp.json());
  }

  async listSourceCredentials(
    {abortSignal, ...params}: RequestConfig & ListSourceCredentialsInput = {},
  ): Promise<ListSourceCredentialsOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSourceCredentials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "sourceCredentialsInfos": [toSourceCredentialsInfo],
      },
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & PutResourcePolicyInput,
  ): Promise<PutResourcePolicyOutput> {
    const body: jsonP.JSONObject = {
      policy: params["policy"],
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceArn": "s",
      },
    }, await resp.json());
  }

  async retryBuild(
    {abortSignal, ...params}: RequestConfig & RetryBuildInput = {},
  ): Promise<RetryBuildOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
      idempotencyToken: params["idempotencyToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetryBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async retryBuildBatch(
    {abortSignal, ...params}: RequestConfig & RetryBuildBatchInput = {},
  ): Promise<RetryBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
      idempotencyToken: params["idempotencyToken"],
      retryType: params["retryType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetryBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async startBuild(
    {abortSignal, ...params}: RequestConfig & StartBuildInput,
  ): Promise<StartBuildOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      secondarySourcesOverride: params["secondarySourcesOverride"]?.map(x => fromProjectSource(x)),
      secondarySourcesVersionOverride: params["secondarySourcesVersionOverride"]?.map(x => fromProjectSourceVersion(x)),
      sourceVersion: params["sourceVersion"],
      artifactsOverride: fromProjectArtifacts(params["artifactsOverride"]),
      secondaryArtifactsOverride: params["secondaryArtifactsOverride"]?.map(x => fromProjectArtifacts(x)),
      environmentVariablesOverride: params["environmentVariablesOverride"]?.map(x => fromEnvironmentVariable(x)),
      sourceTypeOverride: params["sourceTypeOverride"],
      sourceLocationOverride: params["sourceLocationOverride"],
      sourceAuthOverride: fromSourceAuth(params["sourceAuthOverride"]),
      gitCloneDepthOverride: params["gitCloneDepthOverride"],
      gitSubmodulesConfigOverride: fromGitSubmodulesConfig(params["gitSubmodulesConfigOverride"]),
      buildspecOverride: params["buildspecOverride"],
      insecureSslOverride: params["insecureSslOverride"],
      reportBuildStatusOverride: params["reportBuildStatusOverride"],
      buildStatusConfigOverride: fromBuildStatusConfig(params["buildStatusConfigOverride"]),
      environmentTypeOverride: params["environmentTypeOverride"],
      imageOverride: params["imageOverride"],
      computeTypeOverride: params["computeTypeOverride"],
      certificateOverride: params["certificateOverride"],
      cacheOverride: fromProjectCache(params["cacheOverride"]),
      serviceRoleOverride: params["serviceRoleOverride"],
      privilegedModeOverride: params["privilegedModeOverride"],
      timeoutInMinutesOverride: params["timeoutInMinutesOverride"],
      queuedTimeoutInMinutesOverride: params["queuedTimeoutInMinutesOverride"],
      encryptionKeyOverride: params["encryptionKeyOverride"],
      idempotencyToken: params["idempotencyToken"],
      logsConfigOverride: fromLogsConfig(params["logsConfigOverride"]),
      registryCredentialOverride: fromRegistryCredential(params["registryCredentialOverride"]),
      imagePullCredentialsTypeOverride: params["imagePullCredentialsTypeOverride"],
      debugSessionEnabled: params["debugSessionEnabled"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async startBuildBatch(
    {abortSignal, ...params}: RequestConfig & StartBuildBatchInput,
  ): Promise<StartBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      secondarySourcesOverride: params["secondarySourcesOverride"]?.map(x => fromProjectSource(x)),
      secondarySourcesVersionOverride: params["secondarySourcesVersionOverride"]?.map(x => fromProjectSourceVersion(x)),
      sourceVersion: params["sourceVersion"],
      artifactsOverride: fromProjectArtifacts(params["artifactsOverride"]),
      secondaryArtifactsOverride: params["secondaryArtifactsOverride"]?.map(x => fromProjectArtifacts(x)),
      environmentVariablesOverride: params["environmentVariablesOverride"]?.map(x => fromEnvironmentVariable(x)),
      sourceTypeOverride: params["sourceTypeOverride"],
      sourceLocationOverride: params["sourceLocationOverride"],
      sourceAuthOverride: fromSourceAuth(params["sourceAuthOverride"]),
      gitCloneDepthOverride: params["gitCloneDepthOverride"],
      gitSubmodulesConfigOverride: fromGitSubmodulesConfig(params["gitSubmodulesConfigOverride"]),
      buildspecOverride: params["buildspecOverride"],
      insecureSslOverride: params["insecureSslOverride"],
      reportBuildBatchStatusOverride: params["reportBuildBatchStatusOverride"],
      environmentTypeOverride: params["environmentTypeOverride"],
      imageOverride: params["imageOverride"],
      computeTypeOverride: params["computeTypeOverride"],
      certificateOverride: params["certificateOverride"],
      cacheOverride: fromProjectCache(params["cacheOverride"]),
      serviceRoleOverride: params["serviceRoleOverride"],
      privilegedModeOverride: params["privilegedModeOverride"],
      buildTimeoutInMinutesOverride: params["buildTimeoutInMinutesOverride"],
      queuedTimeoutInMinutesOverride: params["queuedTimeoutInMinutesOverride"],
      encryptionKeyOverride: params["encryptionKeyOverride"],
      idempotencyToken: params["idempotencyToken"],
      logsConfigOverride: fromLogsConfig(params["logsConfigOverride"]),
      registryCredentialOverride: fromRegistryCredential(params["registryCredentialOverride"]),
      imagePullCredentialsTypeOverride: params["imagePullCredentialsTypeOverride"],
      buildBatchConfigOverride: fromProjectBuildBatchConfig(params["buildBatchConfigOverride"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async stopBuild(
    {abortSignal, ...params}: RequestConfig & StopBuildInput,
  ): Promise<StopBuildOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopBuild",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "build": toBuild,
      },
    }, await resp.json());
  }

  async stopBuildBatch(
    {abortSignal, ...params}: RequestConfig & StopBuildBatchInput,
  ): Promise<StopBuildBatchOutput> {
    const body: jsonP.JSONObject = {
      id: params["id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopBuildBatch",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "buildBatch": toBuildBatch,
      },
    }, await resp.json());
  }

  async updateProject(
    {abortSignal, ...params}: RequestConfig & UpdateProjectInput,
  ): Promise<UpdateProjectOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      source: fromProjectSource(params["source"]),
      secondarySources: params["secondarySources"]?.map(x => fromProjectSource(x)),
      sourceVersion: params["sourceVersion"],
      secondarySourceVersions: params["secondarySourceVersions"]?.map(x => fromProjectSourceVersion(x)),
      artifacts: fromProjectArtifacts(params["artifacts"]),
      secondaryArtifacts: params["secondaryArtifacts"]?.map(x => fromProjectArtifacts(x)),
      cache: fromProjectCache(params["cache"]),
      environment: fromProjectEnvironment(params["environment"]),
      serviceRole: params["serviceRole"],
      timeoutInMinutes: params["timeoutInMinutes"],
      queuedTimeoutInMinutes: params["queuedTimeoutInMinutes"],
      encryptionKey: params["encryptionKey"],
      tags: params["tags"]?.map(x => fromTag(x)),
      vpcConfig: fromVpcConfig(params["vpcConfig"]),
      badgeEnabled: params["badgeEnabled"],
      logsConfig: fromLogsConfig(params["logsConfig"]),
      fileSystemLocations: params["fileSystemLocations"]?.map(x => fromProjectFileSystemLocation(x)),
      buildBatchConfig: fromProjectBuildBatchConfig(params["buildBatchConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateProject",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "project": toProject,
      },
    }, await resp.json());
  }

  async updateReportGroup(
    {abortSignal, ...params}: RequestConfig & UpdateReportGroupInput,
  ): Promise<UpdateReportGroupOutput> {
    const body: jsonP.JSONObject = {
      arn: params["arn"],
      exportConfig: fromReportExportConfig(params["exportConfig"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReportGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "reportGroup": toReportGroup,
      },
    }, await resp.json());
  }

  async updateWebhook(
    {abortSignal, ...params}: RequestConfig & UpdateWebhookInput,
  ): Promise<UpdateWebhookOutput> {
    const body: jsonP.JSONObject = {
      projectName: params["projectName"],
      branchFilter: params["branchFilter"],
      rotateSecret: params["rotateSecret"],
      filterGroups: params["filterGroups"]?.map(x => x?.map(fromWebhookFilter)),
      buildType: params["buildType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhook": toWebhook,
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchDeleteBuildsInput {
  ids: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetBuildBatchesInput {
  ids: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetBuildsInput {
  ids: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetProjectsInput {
  names: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetReportGroupsInput {
  reportGroupArns: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetReportsInput {
  reportArns: string[];
}

// refs: 1 - tags: named, input
export interface CreateProjectInput {
  name: string;
  description?: string | null;
  source: ProjectSource;
  secondarySources?: ProjectSource[] | null;
  sourceVersion?: string | null;
  secondarySourceVersions?: ProjectSourceVersion[] | null;
  artifacts: ProjectArtifacts;
  secondaryArtifacts?: ProjectArtifacts[] | null;
  cache?: ProjectCache | null;
  environment: ProjectEnvironment;
  serviceRole: string;
  timeoutInMinutes?: number | null;
  queuedTimeoutInMinutes?: number | null;
  encryptionKey?: string | null;
  tags?: Tag[] | null;
  vpcConfig?: VpcConfig | null;
  badgeEnabled?: boolean | null;
  logsConfig?: LogsConfig | null;
  fileSystemLocations?: ProjectFileSystemLocation[] | null;
  buildBatchConfig?: ProjectBuildBatchConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateReportGroupInput {
  name: string;
  type: ReportType;
  exportConfig: ReportExportConfig;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateWebhookInput {
  projectName: string;
  branchFilter?: string | null;
  filterGroups?: WebhookFilter[][] | null;
  buildType?: WebhookBuildType | null;
}

// refs: 1 - tags: named, input
export interface DeleteBuildBatchInput {
  id: string;
}

// refs: 1 - tags: named, input
export interface DeleteProjectInput {
  name: string;
}

// refs: 1 - tags: named, input
export interface DeleteReportInput {
  arn: string;
}

// refs: 1 - tags: named, input
export interface DeleteReportGroupInput {
  arn: string;
  deleteReports?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DeleteResourcePolicyInput {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteSourceCredentialsInput {
  arn: string;
}

// refs: 1 - tags: named, input
export interface DeleteWebhookInput {
  projectName: string;
}

// refs: 1 - tags: named, input
export interface DescribeCodeCoveragesInput {
  reportArn: string;
  nextToken?: string | null;
  maxResults?: number | null;
  sortOrder?: SortOrderType | null;
  sortBy?: ReportCodeCoverageSortByType | null;
  minLineCoveragePercentage?: number | null;
  maxLineCoveragePercentage?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeTestCasesInput {
  reportArn: string;
  nextToken?: string | null;
  maxResults?: number | null;
  filter?: TestCaseFilter | null;
}

// refs: 1 - tags: named, input
export interface GetReportGroupTrendInput {
  reportGroupArn: string;
  numOfReports?: number | null;
  trendField: ReportGroupTrendFieldType;
}

// refs: 1 - tags: named, input
export interface GetResourcePolicyInput {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface ImportSourceCredentialsInput {
  username?: string | null;
  token: string;
  serverType: ServerType;
  authType: AuthType;
  shouldOverwrite?: boolean | null;
}

// refs: 1 - tags: named, input
export interface InvalidateProjectCacheInput {
  projectName: string;
}

// refs: 1 - tags: named, input
export interface ListBuildBatchesInput {
  filter?: BuildBatchFilter | null;
  maxResults?: number | null;
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBuildBatchesForProjectInput {
  projectName?: string | null;
  filter?: BuildBatchFilter | null;
  maxResults?: number | null;
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBuildsInput {
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListBuildsForProjectInput {
  projectName: string;
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCuratedEnvironmentImagesInput {
}

// refs: 1 - tags: named, input
export interface ListProjectsInput {
  sortBy?: ProjectSortByType | null;
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListReportGroupsInput {
  sortOrder?: SortOrderType | null;
  sortBy?: ReportGroupSortByType | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListReportsInput {
  sortOrder?: SortOrderType | null;
  nextToken?: string | null;
  maxResults?: number | null;
  filter?: ReportFilter | null;
}

// refs: 1 - tags: named, input
export interface ListReportsForReportGroupInput {
  reportGroupArn: string;
  nextToken?: string | null;
  sortOrder?: SortOrderType | null;
  maxResults?: number | null;
  filter?: ReportFilter | null;
}

// refs: 1 - tags: named, input
export interface ListSharedProjectsInput {
  sortBy?: SharedResourceSortByType | null;
  sortOrder?: SortOrderType | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSharedReportGroupsInput {
  sortOrder?: SortOrderType | null;
  sortBy?: SharedResourceSortByType | null;
  nextToken?: string | null;
  maxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSourceCredentialsInput {
}

// refs: 1 - tags: named, input
export interface PutResourcePolicyInput {
  policy: string;
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface RetryBuildInput {
  id?: string | null;
  idempotencyToken?: string | null;
}

// refs: 1 - tags: named, input
export interface RetryBuildBatchInput {
  id?: string | null;
  idempotencyToken?: string | null;
  retryType?: RetryBuildBatchType | null;
}

// refs: 1 - tags: named, input
export interface StartBuildInput {
  projectName: string;
  secondarySourcesOverride?: ProjectSource[] | null;
  secondarySourcesVersionOverride?: ProjectSourceVersion[] | null;
  sourceVersion?: string | null;
  artifactsOverride?: ProjectArtifacts | null;
  secondaryArtifactsOverride?: ProjectArtifacts[] | null;
  environmentVariablesOverride?: EnvironmentVariable[] | null;
  sourceTypeOverride?: SourceType | null;
  sourceLocationOverride?: string | null;
  sourceAuthOverride?: SourceAuth | null;
  gitCloneDepthOverride?: number | null;
  gitSubmodulesConfigOverride?: GitSubmodulesConfig | null;
  buildspecOverride?: string | null;
  insecureSslOverride?: boolean | null;
  reportBuildStatusOverride?: boolean | null;
  buildStatusConfigOverride?: BuildStatusConfig | null;
  environmentTypeOverride?: EnvironmentType | null;
  imageOverride?: string | null;
  computeTypeOverride?: ComputeType | null;
  certificateOverride?: string | null;
  cacheOverride?: ProjectCache | null;
  serviceRoleOverride?: string | null;
  privilegedModeOverride?: boolean | null;
  timeoutInMinutesOverride?: number | null;
  queuedTimeoutInMinutesOverride?: number | null;
  encryptionKeyOverride?: string | null;
  idempotencyToken?: string | null;
  logsConfigOverride?: LogsConfig | null;
  registryCredentialOverride?: RegistryCredential | null;
  imagePullCredentialsTypeOverride?: ImagePullCredentialsType | null;
  debugSessionEnabled?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartBuildBatchInput {
  projectName: string;
  secondarySourcesOverride?: ProjectSource[] | null;
  secondarySourcesVersionOverride?: ProjectSourceVersion[] | null;
  sourceVersion?: string | null;
  artifactsOverride?: ProjectArtifacts | null;
  secondaryArtifactsOverride?: ProjectArtifacts[] | null;
  environmentVariablesOverride?: EnvironmentVariable[] | null;
  sourceTypeOverride?: SourceType | null;
  sourceLocationOverride?: string | null;
  sourceAuthOverride?: SourceAuth | null;
  gitCloneDepthOverride?: number | null;
  gitSubmodulesConfigOverride?: GitSubmodulesConfig | null;
  buildspecOverride?: string | null;
  insecureSslOverride?: boolean | null;
  reportBuildBatchStatusOverride?: boolean | null;
  environmentTypeOverride?: EnvironmentType | null;
  imageOverride?: string | null;
  computeTypeOverride?: ComputeType | null;
  certificateOverride?: string | null;
  cacheOverride?: ProjectCache | null;
  serviceRoleOverride?: string | null;
  privilegedModeOverride?: boolean | null;
  buildTimeoutInMinutesOverride?: number | null;
  queuedTimeoutInMinutesOverride?: number | null;
  encryptionKeyOverride?: string | null;
  idempotencyToken?: string | null;
  logsConfigOverride?: LogsConfig | null;
  registryCredentialOverride?: RegistryCredential | null;
  imagePullCredentialsTypeOverride?: ImagePullCredentialsType | null;
  buildBatchConfigOverride?: ProjectBuildBatchConfig | null;
}

// refs: 1 - tags: named, input
export interface StopBuildInput {
  id: string;
}

// refs: 1 - tags: named, input
export interface StopBuildBatchInput {
  id: string;
}

// refs: 1 - tags: named, input
export interface UpdateProjectInput {
  name: string;
  description?: string | null;
  source?: ProjectSource | null;
  secondarySources?: ProjectSource[] | null;
  sourceVersion?: string | null;
  secondarySourceVersions?: ProjectSourceVersion[] | null;
  artifacts?: ProjectArtifacts | null;
  secondaryArtifacts?: ProjectArtifacts[] | null;
  cache?: ProjectCache | null;
  environment?: ProjectEnvironment | null;
  serviceRole?: string | null;
  timeoutInMinutes?: number | null;
  queuedTimeoutInMinutes?: number | null;
  encryptionKey?: string | null;
  tags?: Tag[] | null;
  vpcConfig?: VpcConfig | null;
  badgeEnabled?: boolean | null;
  logsConfig?: LogsConfig | null;
  fileSystemLocations?: ProjectFileSystemLocation[] | null;
  buildBatchConfig?: ProjectBuildBatchConfig | null;
}

// refs: 1 - tags: named, input
export interface UpdateReportGroupInput {
  arn: string;
  exportConfig?: ReportExportConfig | null;
  tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateWebhookInput {
  projectName: string;
  branchFilter?: string | null;
  rotateSecret?: boolean | null;
  filterGroups?: WebhookFilter[][] | null;
  buildType?: WebhookBuildType | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteBuildsOutput {
  buildsDeleted?: string[] | null;
  buildsNotDeleted?: BuildNotDeleted[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetBuildBatchesOutput {
  buildBatches?: BuildBatch[] | null;
  buildBatchesNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetBuildsOutput {
  builds?: Build[] | null;
  buildsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetProjectsOutput {
  projects?: Project[] | null;
  projectsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetReportGroupsOutput {
  reportGroups?: ReportGroup[] | null;
  reportGroupsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetReportsOutput {
  reports?: Report[] | null;
  reportsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface CreateProjectOutput {
  project?: Project | null;
}

// refs: 1 - tags: named, output
export interface CreateReportGroupOutput {
  reportGroup?: ReportGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateWebhookOutput {
  webhook?: Webhook | null;
}

// refs: 1 - tags: named, output
export interface DeleteBuildBatchOutput {
  statusCode?: string | null;
  buildsDeleted?: string[] | null;
  buildsNotDeleted?: BuildNotDeleted[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteProjectOutput {
}

// refs: 1 - tags: named, output
export interface DeleteReportOutput {
}

// refs: 1 - tags: named, output
export interface DeleteReportGroupOutput {
}

// refs: 1 - tags: named, output
export interface DeleteResourcePolicyOutput {
}

// refs: 1 - tags: named, output
export interface DeleteSourceCredentialsOutput {
  arn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteWebhookOutput {
}

// refs: 1 - tags: named, output
export interface DescribeCodeCoveragesOutput {
  nextToken?: string | null;
  codeCoverages?: CodeCoverage[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTestCasesOutput {
  nextToken?: string | null;
  testCases?: TestCase[] | null;
}

// refs: 1 - tags: named, output
export interface GetReportGroupTrendOutput {
  stats?: ReportGroupTrendStats | null;
  rawData?: ReportWithRawData[] | null;
}

// refs: 1 - tags: named, output
export interface GetResourcePolicyOutput {
  policy?: string | null;
}

// refs: 1 - tags: named, output
export interface ImportSourceCredentialsOutput {
  arn?: string | null;
}

// refs: 1 - tags: named, output
export interface InvalidateProjectCacheOutput {
}

// refs: 1 - tags: named, output
export interface ListBuildBatchesOutput {
  ids?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBuildBatchesForProjectOutput {
  ids?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBuildsOutput {
  ids?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListBuildsForProjectOutput {
  ids?: string[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCuratedEnvironmentImagesOutput {
  platforms?: EnvironmentPlatform[] | null;
}

// refs: 1 - tags: named, output
export interface ListProjectsOutput {
  nextToken?: string | null;
  projects?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListReportGroupsOutput {
  nextToken?: string | null;
  reportGroups?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListReportsOutput {
  nextToken?: string | null;
  reports?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListReportsForReportGroupOutput {
  nextToken?: string | null;
  reports?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListSharedProjectsOutput {
  nextToken?: string | null;
  projects?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListSharedReportGroupsOutput {
  nextToken?: string | null;
  reportGroups?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListSourceCredentialsOutput {
  sourceCredentialsInfos?: SourceCredentialsInfo[] | null;
}

// refs: 1 - tags: named, output
export interface PutResourcePolicyOutput {
  resourceArn?: string | null;
}

// refs: 1 - tags: named, output
export interface RetryBuildOutput {
  build?: Build | null;
}

// refs: 1 - tags: named, output
export interface RetryBuildBatchOutput {
  buildBatch?: BuildBatch | null;
}

// refs: 1 - tags: named, output
export interface StartBuildOutput {
  build?: Build | null;
}

// refs: 1 - tags: named, output
export interface StartBuildBatchOutput {
  buildBatch?: BuildBatch | null;
}

// refs: 1 - tags: named, output
export interface StopBuildOutput {
  build?: Build | null;
}

// refs: 1 - tags: named, output
export interface StopBuildBatchOutput {
  buildBatch?: BuildBatch | null;
}

// refs: 1 - tags: named, output
export interface UpdateProjectOutput {
  project?: Project | null;
}

// refs: 1 - tags: named, output
export interface UpdateReportGroupOutput {
  reportGroup?: ReportGroup | null;
}

// refs: 1 - tags: named, output
export interface UpdateWebhookOutput {
  webhook?: Webhook | null;
}

// refs: 28 - tags: input, named, interface, output
export interface ProjectSource {
  type: SourceType;
  location?: string | null;
  gitCloneDepth?: number | null;
  gitSubmodulesConfig?: GitSubmodulesConfig | null;
  buildspec?: string | null;
  auth?: SourceAuth | null;
  reportBuildStatus?: boolean | null;
  buildStatusConfig?: BuildStatusConfig | null;
  insecureSsl?: boolean | null;
  sourceIdentifier?: string | null;
}
function fromProjectSource(input?: ProjectSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    gitCloneDepth: input["gitCloneDepth"],
    gitSubmodulesConfig: fromGitSubmodulesConfig(input["gitSubmodulesConfig"]),
    buildspec: input["buildspec"],
    auth: fromSourceAuth(input["auth"]),
    reportBuildStatus: input["reportBuildStatus"],
    buildStatusConfig: fromBuildStatusConfig(input["buildStatusConfig"]),
    insecureSsl: input["insecureSsl"],
    sourceIdentifier: input["sourceIdentifier"],
  }
}
function toProjectSource(root: jsonP.JSONValue): ProjectSource {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<SourceType>(x),
    },
    optional: {
      "location": "s",
      "gitCloneDepth": "n",
      "gitSubmodulesConfig": toGitSubmodulesConfig,
      "buildspec": "s",
      "auth": toSourceAuth,
      "reportBuildStatus": "b",
      "buildStatusConfig": toBuildStatusConfig,
      "insecureSsl": "b",
      "sourceIdentifier": "s",
    },
  }, root);
}

// refs: 30 - tags: input, named, enum, output
export type SourceType =
| "CODECOMMIT"
| "CODEPIPELINE"
| "GITHUB"
| "S3"
| "BITBUCKET"
| "GITHUB_ENTERPRISE"
| "NO_SOURCE"
| cmnP.UnexpectedEnumValue;

// refs: 30 - tags: input, named, interface, output
export interface GitSubmodulesConfig {
  fetchSubmodules: boolean;
}
function fromGitSubmodulesConfig(input?: GitSubmodulesConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fetchSubmodules: input["fetchSubmodules"],
  }
}
function toGitSubmodulesConfig(root: jsonP.JSONValue): GitSubmodulesConfig {
  return jsonP.readObj({
    required: {
      "fetchSubmodules": "b",
    },
    optional: {},
  }, root);
}

// refs: 30 - tags: input, named, interface, output
export interface SourceAuth {
  type: SourceAuthType;
  resource?: string | null;
}
function fromSourceAuth(input?: SourceAuth | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    resource: input["resource"],
  }
}
function toSourceAuth(root: jsonP.JSONValue): SourceAuth {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<SourceAuthType>(x),
    },
    optional: {
      "resource": "s",
    },
  }, root);
}

// refs: 30 - tags: input, named, enum, output
export type SourceAuthType =
| "OAUTH"
| cmnP.UnexpectedEnumValue;

// refs: 29 - tags: input, named, interface, output
export interface BuildStatusConfig {
  context?: string | null;
  targetUrl?: string | null;
}
function fromBuildStatusConfig(input?: BuildStatusConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    context: input["context"],
    targetUrl: input["targetUrl"],
  }
}
function toBuildStatusConfig(root: jsonP.JSONValue): BuildStatusConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "context": "s",
      "targetUrl": "s",
    },
  }, root);
}

// refs: 15 - tags: input, named, interface, output
export interface ProjectSourceVersion {
  sourceIdentifier: string;
  sourceVersion: string;
}
function fromProjectSourceVersion(input?: ProjectSourceVersion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceIdentifier: input["sourceIdentifier"],
    sourceVersion: input["sourceVersion"],
  }
}
function toProjectSourceVersion(root: jsonP.JSONValue): ProjectSourceVersion {
  return jsonP.readObj({
    required: {
      "sourceIdentifier": "s",
      "sourceVersion": "s",
    },
    optional: {},
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface ProjectArtifacts {
  type: ArtifactsType;
  location?: string | null;
  path?: string | null;
  namespaceType?: ArtifactNamespace | null;
  name?: string | null;
  packaging?: ArtifactPackaging | null;
  overrideArtifactName?: boolean | null;
  encryptionDisabled?: boolean | null;
  artifactIdentifier?: string | null;
}
function fromProjectArtifacts(input?: ProjectArtifacts | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    path: input["path"],
    namespaceType: input["namespaceType"],
    name: input["name"],
    packaging: input["packaging"],
    overrideArtifactName: input["overrideArtifactName"],
    encryptionDisabled: input["encryptionDisabled"],
    artifactIdentifier: input["artifactIdentifier"],
  }
}
function toProjectArtifacts(root: jsonP.JSONValue): ProjectArtifacts {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ArtifactsType>(x),
    },
    optional: {
      "location": "s",
      "path": "s",
      "namespaceType": (x: jsonP.JSONValue) => cmnP.readEnum<ArtifactNamespace>(x),
      "name": "s",
      "packaging": (x: jsonP.JSONValue) => cmnP.readEnum<ArtifactPackaging>(x),
      "overrideArtifactName": "b",
      "encryptionDisabled": "b",
      "artifactIdentifier": "s",
    },
  }, root);
}

// refs: 30 - tags: input, named, enum, output
export type ArtifactsType =
| "CODEPIPELINE"
| "S3"
| "NO_ARTIFACTS"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type ArtifactNamespace =
| "NONE"
| "BUILD_ID"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, enum, output
export type ArtifactPackaging =
| "NONE"
| "ZIP"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface ProjectCache {
  type: CacheType;
  location?: string | null;
  modes?: CacheMode[] | null;
}
function fromProjectCache(input?: ProjectCache | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    modes: input["modes"],
  }
}
function toProjectCache(root: jsonP.JSONValue): ProjectCache {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<CacheType>(x),
    },
    optional: {
      "location": "s",
      "modes": [(x: jsonP.JSONValue) => cmnP.readEnum<CacheMode>(x)],
    },
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type CacheType =
| "NO_CACHE"
| "S3"
| "LOCAL"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, enum, output
export type CacheMode =
| "LOCAL_DOCKER_LAYER_CACHE"
| "LOCAL_SOURCE_CACHE"
| "LOCAL_CUSTOM_CACHE"
| cmnP.UnexpectedEnumValue;

// refs: 13 - tags: input, named, interface, output
export interface ProjectEnvironment {
  type: EnvironmentType;
  image: string;
  computeType: ComputeType;
  environmentVariables?: EnvironmentVariable[] | null;
  privilegedMode?: boolean | null;
  certificate?: string | null;
  registryCredential?: RegistryCredential | null;
  imagePullCredentialsType?: ImagePullCredentialsType | null;
}
function fromProjectEnvironment(input?: ProjectEnvironment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    image: input["image"],
    computeType: input["computeType"],
    environmentVariables: input["environmentVariables"]?.map(x => fromEnvironmentVariable(x)),
    privilegedMode: input["privilegedMode"],
    certificate: input["certificate"],
    registryCredential: fromRegistryCredential(input["registryCredential"]),
    imagePullCredentialsType: input["imagePullCredentialsType"],
  }
}
function toProjectEnvironment(root: jsonP.JSONValue): ProjectEnvironment {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<EnvironmentType>(x),
      "image": "s",
      "computeType": (x: jsonP.JSONValue) => cmnP.readEnum<ComputeType>(x),
    },
    optional: {
      "environmentVariables": [toEnvironmentVariable],
      "privilegedMode": "b",
      "certificate": "s",
      "registryCredential": toRegistryCredential,
      "imagePullCredentialsType": (x: jsonP.JSONValue) => cmnP.readEnum<ImagePullCredentialsType>(x),
    },
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type EnvironmentType =
| "WINDOWS_CONTAINER"
| "LINUX_CONTAINER"
| "LINUX_GPU_CONTAINER"
| "ARM_CONTAINER"
| "WINDOWS_SERVER_2019_CONTAINER"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, enum, output
export type ComputeType =
| "BUILD_GENERAL1_SMALL"
| "BUILD_GENERAL1_MEDIUM"
| "BUILD_GENERAL1_LARGE"
| "BUILD_GENERAL1_2XLARGE"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface EnvironmentVariable {
  name: string;
  value: string;
  type?: EnvironmentVariableType | null;
}
function fromEnvironmentVariable(input?: EnvironmentVariable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    value: input["value"],
    type: input["type"],
  }
}
function toEnvironmentVariable(root: jsonP.JSONValue): EnvironmentVariable {
  return jsonP.readObj({
    required: {
      "name": "s",
      "value": "s",
    },
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<EnvironmentVariableType>(x),
    },
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type EnvironmentVariableType =
| "PLAINTEXT"
| "PARAMETER_STORE"
| "SECRETS_MANAGER"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface RegistryCredential {
  credential: string;
  credentialProvider: CredentialProviderType;
}
function fromRegistryCredential(input?: RegistryCredential | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    credential: input["credential"],
    credentialProvider: input["credentialProvider"],
  }
}
function toRegistryCredential(root: jsonP.JSONValue): RegistryCredential {
  return jsonP.readObj({
    required: {
      "credential": "s",
      "credentialProvider": (x: jsonP.JSONValue) => cmnP.readEnum<CredentialProviderType>(x),
    },
    optional: {},
  }, root);
}

// refs: 15 - tags: input, named, enum, output
export type CredentialProviderType =
| "SECRETS_MANAGER"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, enum, output
export type ImagePullCredentialsType =
| "CODEBUILD"
| "SERVICE_ROLE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Tag {
  key?: string | null;
  value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "key": "s",
      "value": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface VpcConfig {
  vpcId?: string | null;
  subnets?: string[] | null;
  securityGroupIds?: string[] | null;
}
function fromVpcConfig(input?: VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    vpcId: input["vpcId"],
    subnets: input["subnets"],
    securityGroupIds: input["securityGroupIds"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): VpcConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "vpcId": "s",
      "subnets": ["s"],
      "securityGroupIds": ["s"],
    },
  }, root);
}

// refs: 11 - tags: input, named, interface, output
export interface LogsConfig {
  cloudWatchLogs?: CloudWatchLogsConfig | null;
  s3Logs?: S3LogsConfig | null;
}
function fromLogsConfig(input?: LogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cloudWatchLogs: fromCloudWatchLogsConfig(input["cloudWatchLogs"]),
    s3Logs: fromS3LogsConfig(input["s3Logs"]),
  }
}
function toLogsConfig(root: jsonP.JSONValue): LogsConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "cloudWatchLogs": toCloudWatchLogsConfig,
      "s3Logs": toS3LogsConfig,
    },
  }, root);
}

// refs: 15 - tags: input, named, interface, output
export interface CloudWatchLogsConfig {
  status: LogsConfigStatusType;
  groupName?: string | null;
  streamName?: string | null;
}
function fromCloudWatchLogsConfig(input?: CloudWatchLogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    groupName: input["groupName"],
    streamName: input["streamName"],
  }
}
function toCloudWatchLogsConfig(root: jsonP.JSONValue): CloudWatchLogsConfig {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<LogsConfigStatusType>(x),
    },
    optional: {
      "groupName": "s",
      "streamName": "s",
    },
  }, root);
}

// refs: 30 - tags: input, named, enum, output
export type LogsConfigStatusType =
| "ENABLED"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 15 - tags: input, named, interface, output
export interface S3LogsConfig {
  status: LogsConfigStatusType;
  location?: string | null;
  encryptionDisabled?: boolean | null;
}
function fromS3LogsConfig(input?: S3LogsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    location: input["location"],
    encryptionDisabled: input["encryptionDisabled"],
  }
}
function toS3LogsConfig(root: jsonP.JSONValue): S3LogsConfig {
  return jsonP.readObj({
    required: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<LogsConfigStatusType>(x),
    },
    optional: {
      "location": "s",
      "encryptionDisabled": "b",
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface ProjectFileSystemLocation {
  type?: FileSystemType | null;
  location?: string | null;
  mountPoint?: string | null;
  identifier?: string | null;
  mountOptions?: string | null;
}
function fromProjectFileSystemLocation(input?: ProjectFileSystemLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    mountPoint: input["mountPoint"],
    identifier: input["identifier"],
    mountOptions: input["mountOptions"],
  }
}
function toProjectFileSystemLocation(root: jsonP.JSONValue): ProjectFileSystemLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<FileSystemType>(x),
      "location": "s",
      "mountPoint": "s",
      "identifier": "s",
      "mountOptions": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, enum, output
export type FileSystemType =
| "EFS"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface ProjectBuildBatchConfig {
  serviceRole?: string | null;
  combineArtifacts?: boolean | null;
  restrictions?: BatchRestrictions | null;
  timeoutInMins?: number | null;
}
function fromProjectBuildBatchConfig(input?: ProjectBuildBatchConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    serviceRole: input["serviceRole"],
    combineArtifacts: input["combineArtifacts"],
    restrictions: fromBatchRestrictions(input["restrictions"]),
    timeoutInMins: input["timeoutInMins"],
  }
}
function toProjectBuildBatchConfig(root: jsonP.JSONValue): ProjectBuildBatchConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "serviceRole": "s",
      "combineArtifacts": "b",
      "restrictions": toBatchRestrictions,
      "timeoutInMins": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface BatchRestrictions {
  maximumBuildsAllowed?: number | null;
  computeTypesAllowed?: string[] | null;
}
function fromBatchRestrictions(input?: BatchRestrictions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumBuildsAllowed: input["maximumBuildsAllowed"],
    computeTypesAllowed: input["computeTypesAllowed"],
  }
}
function toBatchRestrictions(root: jsonP.JSONValue): BatchRestrictions {
  return jsonP.readObj({
    required: {},
    optional: {
      "maximumBuildsAllowed": "n",
      "computeTypesAllowed": ["s"],
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type ReportType =
| "TEST"
| "CODE_COVERAGE"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface ReportExportConfig {
  exportConfigType?: ReportExportConfigType | null;
  s3Destination?: S3ReportExportConfig | null;
}
function fromReportExportConfig(input?: ReportExportConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    exportConfigType: input["exportConfigType"],
    s3Destination: fromS3ReportExportConfig(input["s3Destination"]),
  }
}
function toReportExportConfig(root: jsonP.JSONValue): ReportExportConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "exportConfigType": (x: jsonP.JSONValue) => cmnP.readEnum<ReportExportConfigType>(x),
      "s3Destination": toS3ReportExportConfig,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ReportExportConfigType =
| "S3"
| "NO_EXPORT"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface S3ReportExportConfig {
  bucket?: string | null;
  path?: string | null;
  packaging?: ReportPackagingType | null;
  encryptionKey?: string | null;
  encryptionDisabled?: boolean | null;
}
function fromS3ReportExportConfig(input?: S3ReportExportConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucket: input["bucket"],
    path: input["path"],
    packaging: input["packaging"],
    encryptionKey: input["encryptionKey"],
    encryptionDisabled: input["encryptionDisabled"],
  }
}
function toS3ReportExportConfig(root: jsonP.JSONValue): S3ReportExportConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "path": "s",
      "packaging": (x: jsonP.JSONValue) => cmnP.readEnum<ReportPackagingType>(x),
      "encryptionKey": "s",
      "encryptionDisabled": "b",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ReportPackagingType =
| "ZIP"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface WebhookFilter {
  type: WebhookFilterType;
  pattern: string;
  excludeMatchedPattern?: boolean | null;
}
function fromWebhookFilter(input?: WebhookFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    pattern: input["pattern"],
    excludeMatchedPattern: input["excludeMatchedPattern"],
  }
}
function toWebhookFilter(root: jsonP.JSONValue): WebhookFilter {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<WebhookFilterType>(x),
      "pattern": "s",
    },
    optional: {
      "excludeMatchedPattern": "b",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type WebhookFilterType =
| "EVENT"
| "BASE_REF"
| "HEAD_REF"
| "ACTOR_ACCOUNT_ID"
| "FILE_PATH"
| "COMMIT_MESSAGE"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type WebhookBuildType =
| "BUILD"
| "BUILD_BATCH"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum
export type SortOrderType =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ReportCodeCoverageSortByType =
| "LINE_COVERAGE_PERCENTAGE"
| "FILE_PATH"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TestCaseFilter {
  status?: string | null;
  keyword?: string | null;
}
function fromTestCaseFilter(input?: TestCaseFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
    keyword: input["keyword"],
  }
}

// refs: 1 - tags: input, named, enum
export type ReportGroupTrendFieldType =
| "PASS_RATE"
| "DURATION"
| "TOTAL"
| "LINE_COVERAGE"
| "LINES_COVERED"
| "LINES_MISSED"
| "BRANCH_COVERAGE"
| "BRANCHES_COVERED"
| "BRANCHES_MISSED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ServerType =
| "GITHUB"
| "BITBUCKET"
| "GITHUB_ENTERPRISE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type AuthType =
| "OAUTH"
| "BASIC_AUTH"
| "PERSONAL_ACCESS_TOKEN"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface BuildBatchFilter {
  status?: StatusType | null;
}
function fromBuildBatchFilter(input?: BuildBatchFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
  }
}

// refs: 26 - tags: input, named, enum, output
export type StatusType =
| "SUCCEEDED"
| "FAILED"
| "FAULT"
| "TIMED_OUT"
| "IN_PROGRESS"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ProjectSortByType =
| "NAME"
| "CREATED_TIME"
| "LAST_MODIFIED_TIME"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ReportGroupSortByType =
| "NAME"
| "CREATED_TIME"
| "LAST_MODIFIED_TIME"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ReportFilter {
  status?: ReportStatusType | null;
}
function fromReportFilter(input?: ReportFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    status: input["status"],
  }
}

// refs: 3 - tags: input, named, enum, output
export type ReportStatusType =
| "GENERATING"
| "SUCCEEDED"
| "FAILED"
| "INCOMPLETE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type SharedResourceSortByType =
| "ARN"
| "MODIFIED_TIME"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type RetryBuildBatchType =
| "RETRY_ALL_BUILDS"
| "RETRY_FAILED_BUILDS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface BuildNotDeleted {
  id?: string | null;
  statusCode?: string | null;
}
function toBuildNotDeleted(root: jsonP.JSONValue): BuildNotDeleted {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "statusCode": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface BuildBatch {
  id?: string | null;
  arn?: string | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  currentPhase?: string | null;
  buildBatchStatus?: StatusType | null;
  sourceVersion?: string | null;
  resolvedSourceVersion?: string | null;
  projectName?: string | null;
  phases?: BuildBatchPhase[] | null;
  source?: ProjectSource | null;
  secondarySources?: ProjectSource[] | null;
  secondarySourceVersions?: ProjectSourceVersion[] | null;
  artifacts?: BuildArtifacts | null;
  secondaryArtifacts?: BuildArtifacts[] | null;
  cache?: ProjectCache | null;
  environment?: ProjectEnvironment | null;
  serviceRole?: string | null;
  logConfig?: LogsConfig | null;
  buildTimeoutInMinutes?: number | null;
  queuedTimeoutInMinutes?: number | null;
  complete?: boolean | null;
  initiator?: string | null;
  vpcConfig?: VpcConfig | null;
  encryptionKey?: string | null;
  buildBatchNumber?: number | null;
  fileSystemLocations?: ProjectFileSystemLocation[] | null;
  buildBatchConfig?: ProjectBuildBatchConfig | null;
  buildGroups?: BuildGroup[] | null;
}
function toBuildBatch(root: jsonP.JSONValue): BuildBatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "arn": "s",
      "startTime": "d",
      "endTime": "d",
      "currentPhase": "s",
      "buildBatchStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StatusType>(x),
      "sourceVersion": "s",
      "resolvedSourceVersion": "s",
      "projectName": "s",
      "phases": [toBuildBatchPhase],
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toBuildArtifacts,
      "secondaryArtifacts": [toBuildArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "logConfig": toLogsConfig,
      "buildTimeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "complete": "b",
      "initiator": "s",
      "vpcConfig": toVpcConfig,
      "encryptionKey": "s",
      "buildBatchNumber": "n",
      "fileSystemLocations": [toProjectFileSystemLocation],
      "buildBatchConfig": toProjectBuildBatchConfig,
      "buildGroups": [toBuildGroup],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface BuildBatchPhase {
  phaseType?: BuildBatchPhaseType | null;
  phaseStatus?: StatusType | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  durationInSeconds?: number | null;
  contexts?: PhaseContext[] | null;
}
function toBuildBatchPhase(root: jsonP.JSONValue): BuildBatchPhase {
  return jsonP.readObj({
    required: {},
    optional: {
      "phaseType": (x: jsonP.JSONValue) => cmnP.readEnum<BuildBatchPhaseType>(x),
      "phaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StatusType>(x),
      "startTime": "d",
      "endTime": "d",
      "durationInSeconds": "n",
      "contexts": [toPhaseContext],
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type BuildBatchPhaseType =
| "SUBMITTED"
| "DOWNLOAD_BATCHSPEC"
| "IN_PROGRESS"
| "COMBINE_ARTIFACTS"
| "SUCCEEDED"
| "FAILED"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: output, named, interface
export interface PhaseContext {
  statusCode?: string | null;
  message?: string | null;
}
function toPhaseContext(root: jsonP.JSONValue): PhaseContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "statusCode": "s",
      "message": "s",
    },
  }, root);
}

// refs: 16 - tags: output, named, interface
export interface BuildArtifacts {
  location?: string | null;
  sha256sum?: string | null;
  md5sum?: string | null;
  overrideArtifactName?: boolean | null;
  encryptionDisabled?: boolean | null;
  artifactIdentifier?: string | null;
}
function toBuildArtifacts(root: jsonP.JSONValue): BuildArtifacts {
  return jsonP.readObj({
    required: {},
    optional: {
      "location": "s",
      "sha256sum": "s",
      "md5sum": "s",
      "overrideArtifactName": "b",
      "encryptionDisabled": "b",
      "artifactIdentifier": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface BuildGroup {
  identifier?: string | null;
  dependsOn?: string[] | null;
  ignoreFailure?: boolean | null;
  currentBuildSummary?: BuildSummary | null;
  priorBuildSummaryList?: BuildSummary[] | null;
}
function toBuildGroup(root: jsonP.JSONValue): BuildGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "identifier": "s",
      "dependsOn": ["s"],
      "ignoreFailure": "b",
      "currentBuildSummary": toBuildSummary,
      "priorBuildSummaryList": [toBuildSummary],
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface BuildSummary {
  arn?: string | null;
  requestedOn?: Date | number | null;
  buildStatus?: StatusType | null;
  primaryArtifact?: ResolvedArtifact | null;
  secondaryArtifacts?: ResolvedArtifact[] | null;
}
function toBuildSummary(root: jsonP.JSONValue): BuildSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "requestedOn": "d",
      "buildStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StatusType>(x),
      "primaryArtifact": toResolvedArtifact,
      "secondaryArtifacts": [toResolvedArtifact],
    },
  }, root);
}

// refs: 16 - tags: output, named, interface
export interface ResolvedArtifact {
  type?: ArtifactsType | null;
  location?: string | null;
  identifier?: string | null;
}
function toResolvedArtifact(root: jsonP.JSONValue): ResolvedArtifact {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ArtifactsType>(x),
      "location": "s",
      "identifier": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Build {
  id?: string | null;
  arn?: string | null;
  buildNumber?: number | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  currentPhase?: string | null;
  buildStatus?: StatusType | null;
  sourceVersion?: string | null;
  resolvedSourceVersion?: string | null;
  projectName?: string | null;
  phases?: BuildPhase[] | null;
  source?: ProjectSource | null;
  secondarySources?: ProjectSource[] | null;
  secondarySourceVersions?: ProjectSourceVersion[] | null;
  artifacts?: BuildArtifacts | null;
  secondaryArtifacts?: BuildArtifacts[] | null;
  cache?: ProjectCache | null;
  environment?: ProjectEnvironment | null;
  serviceRole?: string | null;
  logs?: LogsLocation | null;
  timeoutInMinutes?: number | null;
  queuedTimeoutInMinutes?: number | null;
  buildComplete?: boolean | null;
  initiator?: string | null;
  vpcConfig?: VpcConfig | null;
  networkInterface?: NetworkInterface | null;
  encryptionKey?: string | null;
  exportedEnvironmentVariables?: ExportedEnvironmentVariable[] | null;
  reportArns?: string[] | null;
  fileSystemLocations?: ProjectFileSystemLocation[] | null;
  debugSession?: DebugSession | null;
  buildBatchArn?: string | null;
}
function toBuild(root: jsonP.JSONValue): Build {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "arn": "s",
      "buildNumber": "n",
      "startTime": "d",
      "endTime": "d",
      "currentPhase": "s",
      "buildStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StatusType>(x),
      "sourceVersion": "s",
      "resolvedSourceVersion": "s",
      "projectName": "s",
      "phases": [toBuildPhase],
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toBuildArtifacts,
      "secondaryArtifacts": [toBuildArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "logs": toLogsLocation,
      "timeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "buildComplete": "b",
      "initiator": "s",
      "vpcConfig": toVpcConfig,
      "networkInterface": toNetworkInterface,
      "encryptionKey": "s",
      "exportedEnvironmentVariables": [toExportedEnvironmentVariable],
      "reportArns": ["s"],
      "fileSystemLocations": [toProjectFileSystemLocation],
      "debugSession": toDebugSession,
      "buildBatchArn": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface BuildPhase {
  phaseType?: BuildPhaseType | null;
  phaseStatus?: StatusType | null;
  startTime?: Date | number | null;
  endTime?: Date | number | null;
  durationInSeconds?: number | null;
  contexts?: PhaseContext[] | null;
}
function toBuildPhase(root: jsonP.JSONValue): BuildPhase {
  return jsonP.readObj({
    required: {},
    optional: {
      "phaseType": (x: jsonP.JSONValue) => cmnP.readEnum<BuildPhaseType>(x),
      "phaseStatus": (x: jsonP.JSONValue) => cmnP.readEnum<StatusType>(x),
      "startTime": "d",
      "endTime": "d",
      "durationInSeconds": "n",
      "contexts": [toPhaseContext],
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type BuildPhaseType =
| "SUBMITTED"
| "QUEUED"
| "PROVISIONING"
| "DOWNLOAD_SOURCE"
| "INSTALL"
| "PRE_BUILD"
| "BUILD"
| "POST_BUILD"
| "UPLOAD_ARTIFACTS"
| "FINALIZING"
| "COMPLETED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface LogsLocation {
  groupName?: string | null;
  streamName?: string | null;
  deepLink?: string | null;
  s3DeepLink?: string | null;
  cloudWatchLogsArn?: string | null;
  s3LogsArn?: string | null;
  cloudWatchLogs?: CloudWatchLogsConfig | null;
  s3Logs?: S3LogsConfig | null;
}
function toLogsLocation(root: jsonP.JSONValue): LogsLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "groupName": "s",
      "streamName": "s",
      "deepLink": "s",
      "s3DeepLink": "s",
      "cloudWatchLogsArn": "s",
      "s3LogsArn": "s",
      "cloudWatchLogs": toCloudWatchLogsConfig,
      "s3Logs": toS3LogsConfig,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface NetworkInterface {
  subnetId?: string | null;
  networkInterfaceId?: string | null;
}
function toNetworkInterface(root: jsonP.JSONValue): NetworkInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "subnetId": "s",
      "networkInterfaceId": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ExportedEnvironmentVariable {
  name?: string | null;
  value?: string | null;
}
function toExportedEnvironmentVariable(root: jsonP.JSONValue): ExportedEnvironmentVariable {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "value": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface DebugSession {
  sessionEnabled?: boolean | null;
  sessionTarget?: string | null;
}
function toDebugSession(root: jsonP.JSONValue): DebugSession {
  return jsonP.readObj({
    required: {},
    optional: {
      "sessionEnabled": "b",
      "sessionTarget": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Project {
  name?: string | null;
  arn?: string | null;
  description?: string | null;
  source?: ProjectSource | null;
  secondarySources?: ProjectSource[] | null;
  sourceVersion?: string | null;
  secondarySourceVersions?: ProjectSourceVersion[] | null;
  artifacts?: ProjectArtifacts | null;
  secondaryArtifacts?: ProjectArtifacts[] | null;
  cache?: ProjectCache | null;
  environment?: ProjectEnvironment | null;
  serviceRole?: string | null;
  timeoutInMinutes?: number | null;
  queuedTimeoutInMinutes?: number | null;
  encryptionKey?: string | null;
  tags?: Tag[] | null;
  created?: Date | number | null;
  lastModified?: Date | number | null;
  webhook?: Webhook | null;
  vpcConfig?: VpcConfig | null;
  badge?: ProjectBadge | null;
  logsConfig?: LogsConfig | null;
  fileSystemLocations?: ProjectFileSystemLocation[] | null;
  buildBatchConfig?: ProjectBuildBatchConfig | null;
}
function toProject(root: jsonP.JSONValue): Project {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "arn": "s",
      "description": "s",
      "source": toProjectSource,
      "secondarySources": [toProjectSource],
      "sourceVersion": "s",
      "secondarySourceVersions": [toProjectSourceVersion],
      "artifacts": toProjectArtifacts,
      "secondaryArtifacts": [toProjectArtifacts],
      "cache": toProjectCache,
      "environment": toProjectEnvironment,
      "serviceRole": "s",
      "timeoutInMinutes": "n",
      "queuedTimeoutInMinutes": "n",
      "encryptionKey": "s",
      "tags": [toTag],
      "created": "d",
      "lastModified": "d",
      "webhook": toWebhook,
      "vpcConfig": toVpcConfig,
      "badge": toProjectBadge,
      "logsConfig": toLogsConfig,
      "fileSystemLocations": [toProjectFileSystemLocation],
      "buildBatchConfig": toProjectBuildBatchConfig,
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface Webhook {
  url?: string | null;
  payloadUrl?: string | null;
  secret?: string | null;
  branchFilter?: string | null;
  filterGroups?: WebhookFilter[][] | null;
  buildType?: WebhookBuildType | null;
  lastModifiedSecret?: Date | number | null;
}
function toWebhook(root: jsonP.JSONValue): Webhook {
  return jsonP.readObj({
    required: {},
    optional: {
      "url": "s",
      "payloadUrl": "s",
      "secret": "s",
      "branchFilter": "s",
      "filterGroups": [x => jsonP.readList(toWebhookFilter, x)],
      "buildType": (x: jsonP.JSONValue) => cmnP.readEnum<WebhookBuildType>(x),
      "lastModifiedSecret": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ProjectBadge {
  badgeEnabled?: boolean | null;
  badgeRequestUrl?: string | null;
}
function toProjectBadge(root: jsonP.JSONValue): ProjectBadge {
  return jsonP.readObj({
    required: {},
    optional: {
      "badgeEnabled": "b",
      "badgeRequestUrl": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ReportGroup {
  arn?: string | null;
  name?: string | null;
  type?: ReportType | null;
  exportConfig?: ReportExportConfig | null;
  created?: Date | number | null;
  lastModified?: Date | number | null;
  tags?: Tag[] | null;
  status?: ReportGroupStatusType | null;
}
function toReportGroup(root: jsonP.JSONValue): ReportGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ReportType>(x),
      "exportConfig": toReportExportConfig,
      "created": "d",
      "lastModified": "d",
      "tags": [toTag],
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ReportGroupStatusType>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ReportGroupStatusType =
| "ACTIVE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Report {
  arn?: string | null;
  type?: ReportType | null;
  name?: string | null;
  reportGroupArn?: string | null;
  executionId?: string | null;
  status?: ReportStatusType | null;
  created?: Date | number | null;
  expired?: Date | number | null;
  exportConfig?: ReportExportConfig | null;
  truncated?: boolean | null;
  testSummary?: TestReportSummary | null;
  codeCoverageSummary?: CodeCoverageReportSummary | null;
}
function toReport(root: jsonP.JSONValue): Report {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<ReportType>(x),
      "name": "s",
      "reportGroupArn": "s",
      "executionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ReportStatusType>(x),
      "created": "d",
      "expired": "d",
      "exportConfig": toReportExportConfig,
      "truncated": "b",
      "testSummary": toTestReportSummary,
      "codeCoverageSummary": toCodeCoverageReportSummary,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TestReportSummary {
  total: number;
  statusCounts: { [key: string]: number | null | undefined };
  durationInNanoSeconds: number;
}
function toTestReportSummary(root: jsonP.JSONValue): TestReportSummary {
  return jsonP.readObj({
    required: {
      "total": "n",
      "statusCounts": x => jsonP.readMap(String, Number, x),
      "durationInNanoSeconds": "n",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CodeCoverageReportSummary {
  lineCoveragePercentage?: number | null;
  linesCovered?: number | null;
  linesMissed?: number | null;
  branchCoveragePercentage?: number | null;
  branchesCovered?: number | null;
  branchesMissed?: number | null;
}
function toCodeCoverageReportSummary(root: jsonP.JSONValue): CodeCoverageReportSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "lineCoveragePercentage": "n",
      "linesCovered": "n",
      "linesMissed": "n",
      "branchCoveragePercentage": "n",
      "branchesCovered": "n",
      "branchesMissed": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CodeCoverage {
  id?: string | null;
  reportARN?: string | null;
  filePath?: string | null;
  lineCoveragePercentage?: number | null;
  linesCovered?: number | null;
  linesMissed?: number | null;
  branchCoveragePercentage?: number | null;
  branchesCovered?: number | null;
  branchesMissed?: number | null;
  expired?: Date | number | null;
}
function toCodeCoverage(root: jsonP.JSONValue): CodeCoverage {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "reportARN": "s",
      "filePath": "s",
      "lineCoveragePercentage": "n",
      "linesCovered": "n",
      "linesMissed": "n",
      "branchCoveragePercentage": "n",
      "branchesCovered": "n",
      "branchesMissed": "n",
      "expired": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TestCase {
  reportArn?: string | null;
  testRawDataPath?: string | null;
  prefix?: string | null;
  name?: string | null;
  status?: string | null;
  durationInNanoSeconds?: number | null;
  message?: string | null;
  expired?: Date | number | null;
}
function toTestCase(root: jsonP.JSONValue): TestCase {
  return jsonP.readObj({
    required: {},
    optional: {
      "reportArn": "s",
      "testRawDataPath": "s",
      "prefix": "s",
      "name": "s",
      "status": "s",
      "durationInNanoSeconds": "n",
      "message": "s",
      "expired": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReportGroupTrendStats {
  average?: string | null;
  max?: string | null;
  min?: string | null;
}
function toReportGroupTrendStats(root: jsonP.JSONValue): ReportGroupTrendStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "average": "s",
      "max": "s",
      "min": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ReportWithRawData {
  reportArn?: string | null;
  data?: string | null;
}
function toReportWithRawData(root: jsonP.JSONValue): ReportWithRawData {
  return jsonP.readObj({
    required: {},
    optional: {
      "reportArn": "s",
      "data": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EnvironmentPlatform {
  platform?: PlatformType | null;
  languages?: EnvironmentLanguage[] | null;
}
function toEnvironmentPlatform(root: jsonP.JSONValue): EnvironmentPlatform {
  return jsonP.readObj({
    required: {},
    optional: {
      "platform": (x: jsonP.JSONValue) => cmnP.readEnum<PlatformType>(x),
      "languages": [toEnvironmentLanguage],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type PlatformType =
| "DEBIAN"
| "AMAZON_LINUX"
| "UBUNTU"
| "WINDOWS_SERVER"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface EnvironmentLanguage {
  language?: LanguageType | null;
  images?: EnvironmentImage[] | null;
}
function toEnvironmentLanguage(root: jsonP.JSONValue): EnvironmentLanguage {
  return jsonP.readObj({
    required: {},
    optional: {
      "language": (x: jsonP.JSONValue) => cmnP.readEnum<LanguageType>(x),
      "images": [toEnvironmentImage],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type LanguageType =
| "JAVA"
| "PYTHON"
| "NODE_JS"
| "RUBY"
| "GOLANG"
| "DOCKER"
| "ANDROID"
| "DOTNET"
| "BASE"
| "PHP"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface EnvironmentImage {
  name?: string | null;
  description?: string | null;
  versions?: string[] | null;
}
function toEnvironmentImage(root: jsonP.JSONValue): EnvironmentImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "versions": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SourceCredentialsInfo {
  arn?: string | null;
  serverType?: ServerType | null;
  authType?: AuthType | null;
}
function toSourceCredentialsInfo(root: jsonP.JSONValue): SourceCredentialsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "serverType": (x: jsonP.JSONValue) => cmnP.readEnum<ServerType>(x),
      "authType": (x: jsonP.JSONValue) => cmnP.readEnum<AuthType>(x),
    },
  }, root);
}
