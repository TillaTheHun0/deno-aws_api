// Autogenerated API client for: Amazon Elastic MapReduce

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class EMR {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EMR.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2009-03-31",
    "endpointPrefix": "elasticmapreduce",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon EMR",
    "serviceFullName": "Amazon Elastic MapReduce",
    "serviceId": "EMR",
    "signatureVersion": "v4",
    "targetPrefix": "ElasticMapReduce",
    "uid": "elasticmapreduce-2009-03-31"
  };

  async addInstanceFleet(
    {abortSignal, ...params}: RequestConfig & AddInstanceFleetInput,
  ): Promise<AddInstanceFleetOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceFleet: fromInstanceFleetConfig(params["InstanceFleet"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceFleet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceFleetId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addInstanceGroups(
    {abortSignal, ...params}: RequestConfig & AddInstanceGroupsInput,
  ): Promise<AddInstanceGroupsOutput> {
    const body: jsonP.JSONObject = {
      InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
      JobFlowId: params["JobFlowId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "InstanceGroupIds": ["s"],
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addJobFlowSteps(
    {abortSignal, ...params}: RequestConfig & AddJobFlowStepsInput,
  ): Promise<AddJobFlowStepsOutput> {
    const body: jsonP.JSONObject = {
      JobFlowId: params["JobFlowId"],
      Steps: params["Steps"]?.map(x => fromStepConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddJobFlowSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StepIds": ["s"],
      },
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelSteps(
    {abortSignal, ...params}: RequestConfig & CancelStepsInput,
  ): Promise<CancelStepsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepIds: params["StepIds"],
      StepCancellationOption: params["StepCancellationOption"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CancelStepsInfoList": [toCancelStepsInfo],
      },
    }, await resp.json());
  }

  async createSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateSecurityConfigurationInput,
  ): Promise<CreateSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      SecurityConfiguration: params["SecurityConfiguration"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {
        "Name": "s",
        "CreationDateTime": "d",
      },
      optional: {},
    }, await resp.json());
  }

  async createStudio(
    {abortSignal, ...params}: RequestConfig & CreateStudioInput,
  ): Promise<CreateStudioOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      AuthMode: params["AuthMode"],
      VpcId: params["VpcId"],
      SubnetIds: params["SubnetIds"],
      ServiceRole: params["ServiceRole"],
      UserRole: params["UserRole"],
      WorkspaceSecurityGroupId: params["WorkspaceSecurityGroupId"],
      EngineSecurityGroupId: params["EngineSecurityGroupId"],
      DefaultS3Location: params["DefaultS3Location"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStudio",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StudioId": "s",
        "Url": "s",
      },
    }, await resp.json());
  }

  async createStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & CreateStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
      SessionPolicyArn: params["SessionPolicyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStudioSessionMapping",
    });
  }

  async deleteSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteSecurityConfigurationInput,
  ): Promise<DeleteSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteStudio(
    {abortSignal, ...params}: RequestConfig & DeleteStudioInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStudio",
    });
  }

  async deleteStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & DeleteStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteStudioSessionMapping",
    });
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async describeJobFlows(
    {abortSignal, ...params}: RequestConfig & DescribeJobFlowsInput = {},
  ): Promise<DescribeJobFlowsOutput> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      JobFlowIds: params["JobFlowIds"],
      JobFlowStates: params["JobFlowStates"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobFlows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlows": [toJobFlowDetail],
      },
    }, await resp.json());
  }

  async describeNotebookExecution(
    {abortSignal, ...params}: RequestConfig & DescribeNotebookExecutionInput,
  ): Promise<DescribeNotebookExecutionOutput> {
    const body: jsonP.JSONObject = {
      NotebookExecutionId: params["NotebookExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecution": toNotebookExecution,
      },
    }, await resp.json());
  }

  async describeSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & DescribeSecurityConfigurationInput,
  ): Promise<DescribeSecurityConfigurationOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "SecurityConfiguration": "s",
        "CreationDateTime": "d",
      },
    }, await resp.json());
  }

  async describeStep(
    {abortSignal, ...params}: RequestConfig & DescribeStepInput,
  ): Promise<DescribeStepOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepId: params["StepId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStep",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Step": toStep,
      },
    }, await resp.json());
  }

  async describeStudio(
    {abortSignal, ...params}: RequestConfig & DescribeStudioInput,
  ): Promise<DescribeStudioOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStudio",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Studio": toStudio,
      },
    }, await resp.json());
  }

  async getBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBlockPublicAccessConfigurationInput = {},
  ): Promise<GetBlockPublicAccessConfigurationOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlockPublicAccessConfiguration",
    });
    return jsonP.readObj({
      required: {
        "BlockPublicAccessConfiguration": toBlockPublicAccessConfiguration,
        "BlockPublicAccessConfigurationMetadata": toBlockPublicAccessConfigurationMetadata,
      },
      optional: {},
    }, await resp.json());
  }

  async getManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & GetManagedScalingPolicyInput,
  ): Promise<GetManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ManagedScalingPolicy": toManagedScalingPolicy,
      },
    }, await resp.json());
  }

  async getStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & GetStudioSessionMappingInput,
  ): Promise<GetStudioSessionMappingOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetStudioSessionMapping",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionMapping": toSessionMappingDetail,
      },
    }, await resp.json());
  }

  async listBootstrapActions(
    {abortSignal, ...params}: RequestConfig & ListBootstrapActionsInput,
  ): Promise<ListBootstrapActionsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBootstrapActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BootstrapActions": [toCommand],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & ListClustersInput = {},
  ): Promise<ListClustersOutput> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      ClusterStates: params["ClusterStates"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Clusters": [toClusterSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceFleets(
    {abortSignal, ...params}: RequestConfig & ListInstanceFleetsInput,
  ): Promise<ListInstanceFleetsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceFleets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceFleets": [toInstanceFleet],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceGroups(
    {abortSignal, ...params}: RequestConfig & ListInstanceGroupsInput,
  ): Promise<ListInstanceGroupsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InstanceGroups": [toInstanceGroup],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstances(
    {abortSignal, ...params}: RequestConfig & ListInstancesInput,
  ): Promise<ListInstancesOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
      InstanceGroupTypes: params["InstanceGroupTypes"],
      InstanceFleetId: params["InstanceFleetId"],
      InstanceFleetType: params["InstanceFleetType"],
      InstanceStates: params["InstanceStates"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listNotebookExecutions(
    {abortSignal, ...params}: RequestConfig & ListNotebookExecutionsInput = {},
  ): Promise<ListNotebookExecutionsOutput> {
    const body: jsonP.JSONObject = {
      EditorId: params["EditorId"],
      Status: params["Status"],
      From: jsonP.serializeDate_unixTimestamp(params["From"]),
      To: jsonP.serializeDate_unixTimestamp(params["To"]),
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecutions": [toNotebookExecutionSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSecurityConfigurations(
    {abortSignal, ...params}: RequestConfig & ListSecurityConfigurationsInput = {},
  ): Promise<ListSecurityConfigurationsOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecurityConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfigurations": [toSecurityConfigurationSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSteps(
    {abortSignal, ...params}: RequestConfig & ListStepsInput,
  ): Promise<ListStepsOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepStates: params["StepStates"],
      StepIds: params["StepIds"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Steps": [toStepSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listStudioSessionMappings(
    {abortSignal, ...params}: RequestConfig & ListStudioSessionMappingsInput = {},
  ): Promise<ListStudioSessionMappingsOutput> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityType: params["IdentityType"],
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStudioSessionMappings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SessionMappings": [toSessionMappingSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listStudios(
    {abortSignal, ...params}: RequestConfig & ListStudiosInput = {},
  ): Promise<ListStudiosOutput> {
    const body: jsonP.JSONObject = {
      Marker: params["Marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListStudios",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Studios": [toStudioSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & ModifyClusterInput,
  ): Promise<ModifyClusterOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      StepConcurrencyLevel: params["StepConcurrencyLevel"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StepConcurrencyLevel": "n",
      },
    }, await resp.json());
  }

  async modifyInstanceFleet(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceFleetInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceFleet: fromInstanceFleetModifyConfig(params["InstanceFleet"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceFleet",
    });
  }

  async modifyInstanceGroups(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceGroupsInput = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupModifyConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceGroups",
    });
  }

  async putAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutAutoScalingPolicyInput,
  ): Promise<PutAutoScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
      AutoScalingPolicy: fromAutoScalingPolicy(params["AutoScalingPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAutoScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceGroupId": "s",
        "AutoScalingPolicy": toAutoScalingPolicyDescription,
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async putBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBlockPublicAccessConfigurationInput,
  ): Promise<PutBlockPublicAccessConfigurationOutput> {
    const body: jsonP.JSONObject = {
      BlockPublicAccessConfiguration: fromBlockPublicAccessConfiguration(params["BlockPublicAccessConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBlockPublicAccessConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutManagedScalingPolicyInput,
  ): Promise<PutManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & RemoveAutoScalingPolicyInput,
  ): Promise<RemoveAutoScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      InstanceGroupId: params["InstanceGroupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveAutoScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & RemoveManagedScalingPolicyInput,
  ): Promise<RemoveManagedScalingPolicyOutput> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveManagedScalingPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & RemoveTagsInput,
  ): Promise<RemoveTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async runJobFlow(
    {abortSignal, ...params}: RequestConfig & RunJobFlowInput,
  ): Promise<RunJobFlowOutput> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      LogUri: params["LogUri"],
      LogEncryptionKmsKeyId: params["LogEncryptionKmsKeyId"],
      AdditionalInfo: params["AdditionalInfo"],
      AmiVersion: params["AmiVersion"],
      ReleaseLabel: params["ReleaseLabel"],
      Instances: fromJobFlowInstancesConfig(params["Instances"]),
      Steps: params["Steps"]?.map(x => fromStepConfig(x)),
      BootstrapActions: params["BootstrapActions"]?.map(x => fromBootstrapActionConfig(x)),
      SupportedProducts: params["SupportedProducts"],
      NewSupportedProducts: params["NewSupportedProducts"]?.map(x => fromSupportedProductConfig(x)),
      Applications: params["Applications"]?.map(x => fromApplication(x)),
      Configurations: params["Configurations"]?.map(x => fromConfiguration(x)),
      VisibleToAllUsers: params["VisibleToAllUsers"],
      JobFlowRole: params["JobFlowRole"],
      ServiceRole: params["ServiceRole"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      SecurityConfiguration: params["SecurityConfiguration"],
      AutoScalingRole: params["AutoScalingRole"],
      ScaleDownBehavior: params["ScaleDownBehavior"],
      CustomAmiId: params["CustomAmiId"],
      EbsRootVolumeSize: params["EbsRootVolumeSize"],
      RepoUpgradeOnBoot: params["RepoUpgradeOnBoot"],
      KerberosAttributes: fromKerberosAttributes(params["KerberosAttributes"]),
      StepConcurrencyLevel: params["StepConcurrencyLevel"],
      ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
      PlacementGroupConfigs: params["PlacementGroupConfigs"]?.map(x => fromPlacementGroupConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunJobFlow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async setTerminationProtection(
    {abortSignal, ...params}: RequestConfig & SetTerminationProtectionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
      TerminationProtected: params["TerminationProtected"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTerminationProtection",
    });
  }

  async setVisibleToAllUsers(
    {abortSignal, ...params}: RequestConfig & SetVisibleToAllUsersInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
      VisibleToAllUsers: params["VisibleToAllUsers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetVisibleToAllUsers",
    });
  }

  async startNotebookExecution(
    {abortSignal, ...params}: RequestConfig & StartNotebookExecutionInput,
  ): Promise<StartNotebookExecutionOutput> {
    const body: jsonP.JSONObject = {
      EditorId: params["EditorId"],
      RelativePath: params["RelativePath"],
      NotebookExecutionName: params["NotebookExecutionName"],
      NotebookParams: params["NotebookParams"],
      ExecutionEngine: fromExecutionEngineConfig(params["ExecutionEngine"]),
      ServiceRole: params["ServiceRole"],
      NotebookInstanceSecurityGroupId: params["NotebookInstanceSecurityGroupId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNotebookExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookExecutionId": "s",
      },
    }, await resp.json());
  }

  async stopNotebookExecution(
    {abortSignal, ...params}: RequestConfig & StopNotebookExecutionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookExecutionId: params["NotebookExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopNotebookExecution",
    });
  }

  async terminateJobFlows(
    {abortSignal, ...params}: RequestConfig & TerminateJobFlowsInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobFlowIds: params["JobFlowIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateJobFlows",
    });
  }

  async updateStudioSessionMapping(
    {abortSignal, ...params}: RequestConfig & UpdateStudioSessionMappingInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      StudioId: params["StudioId"],
      IdentityId: params["IdentityId"],
      IdentityName: params["IdentityName"],
      IdentityType: params["IdentityType"],
      SessionPolicyArn: params["SessionPolicyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStudioSessionMapping",
    });
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterRunning(
    params: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterRunning';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.Cluster?.Status?.State;
      if (field === "RUNNING") return resp;
      if (field === "WAITING") return resp;
      if (field === "TERMINATING") throw new Error(errMessage);
      if (field === "TERMINATED") throw new Error(errMessage);
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForStepComplete(
    params: RequestConfig & DescribeStepInput,
  ): Promise<DescribeStepOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StepComplete';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeStep(params);
      const field = resp?.Step?.Status?.State;
      if (field === "COMPLETED") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      if (field === "CANCELLED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterTerminated(
    params: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterTerminated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp?.Cluster?.Status?.State;
      if (field === "TERMINATED") return resp;
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddInstanceFleetInput {
  ClusterId: string;
  InstanceFleet: InstanceFleetConfig;
}

// refs: 1 - tags: named, input
export interface AddInstanceGroupsInput {
  InstanceGroups: InstanceGroupConfig[];
  JobFlowId: string;
}

// refs: 1 - tags: named, input
export interface AddJobFlowStepsInput {
  JobFlowId: string;
  Steps: StepConfig[];
}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  ResourceId: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface CancelStepsInput {
  ClusterId: string;
  StepIds: string[];
  StepCancellationOption?: StepCancellationOption | null;
}

// refs: 1 - tags: named, input
export interface CreateSecurityConfigurationInput {
  Name: string;
  SecurityConfiguration: string;
}

// refs: 1 - tags: named, input
export interface CreateStudioInput {
  Name: string;
  Description?: string | null;
  AuthMode: AuthMode;
  VpcId: string;
  SubnetIds: string[];
  ServiceRole: string;
  UserRole: string;
  WorkspaceSecurityGroupId: string;
  EngineSecurityGroupId: string;
  DefaultS3Location?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateStudioSessionMappingInput {
  StudioId: string;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType: IdentityType;
  SessionPolicyArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteSecurityConfigurationInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteStudioInput {
  StudioId: string;
}

// refs: 1 - tags: named, input
export interface DeleteStudioSessionMappingInput {
  StudioId: string;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType: IdentityType;
}

// refs: 1 - tags: named, input
export interface DescribeClusterInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobFlowsInput {
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  JobFlowIds?: string[] | null;
  JobFlowStates?: JobFlowExecutionState[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeNotebookExecutionInput {
  NotebookExecutionId: string;
}

// refs: 1 - tags: named, input
export interface DescribeSecurityConfigurationInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeStepInput {
  ClusterId: string;
  StepId: string;
}

// refs: 1 - tags: named, input
export interface DescribeStudioInput {
  StudioId: string;
}

// refs: 1 - tags: named, input
export interface GetBlockPublicAccessConfigurationInput {
}

// refs: 1 - tags: named, input
export interface GetManagedScalingPolicyInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface GetStudioSessionMappingInput {
  StudioId: string;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType: IdentityType;
}

// refs: 1 - tags: named, input
export interface ListBootstrapActionsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListClustersInput {
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  ClusterStates?: ClusterState[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceFleetsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceGroupsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstancesInput {
  ClusterId: string;
  InstanceGroupId?: string | null;
  InstanceGroupTypes?: InstanceGroupType[] | null;
  InstanceFleetId?: string | null;
  InstanceFleetType?: InstanceFleetType | null;
  InstanceStates?: InstanceState[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListNotebookExecutionsInput {
  EditorId?: string | null;
  Status?: NotebookExecutionStatus | null;
  From?: Date | number | null;
  To?: Date | number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSecurityConfigurationsInput {
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStepsInput {
  ClusterId: string;
  StepStates?: StepState[] | null;
  StepIds?: string[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStudioSessionMappingsInput {
  StudioId?: string | null;
  IdentityType?: IdentityType | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStudiosInput {
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterInput {
  ClusterId: string;
  StepConcurrencyLevel?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceFleetInput {
  ClusterId: string;
  InstanceFleet: InstanceFleetModifyConfig;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceGroupsInput {
  ClusterId?: string | null;
  InstanceGroups?: InstanceGroupModifyConfig[] | null;
}

// refs: 1 - tags: named, input
export interface PutAutoScalingPolicyInput {
  ClusterId: string;
  InstanceGroupId: string;
  AutoScalingPolicy: AutoScalingPolicy;
}

// refs: 1 - tags: named, input
export interface PutBlockPublicAccessConfigurationInput {
  BlockPublicAccessConfiguration: BlockPublicAccessConfiguration;
}

// refs: 1 - tags: named, input
export interface PutManagedScalingPolicyInput {
  ClusterId: string;
  ManagedScalingPolicy: ManagedScalingPolicy;
}

// refs: 1 - tags: named, input
export interface RemoveAutoScalingPolicyInput {
  ClusterId: string;
  InstanceGroupId: string;
}

// refs: 1 - tags: named, input
export interface RemoveManagedScalingPolicyInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsInput {
  ResourceId: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface RunJobFlowInput {
  Name: string;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  AdditionalInfo?: string | null;
  AmiVersion?: string | null;
  ReleaseLabel?: string | null;
  Instances: JobFlowInstancesConfig;
  Steps?: StepConfig[] | null;
  BootstrapActions?: BootstrapActionConfig[] | null;
  SupportedProducts?: string[] | null;
  NewSupportedProducts?: SupportedProductConfig[] | null;
  Applications?: Application[] | null;
  Configurations?: Configuration[] | null;
  VisibleToAllUsers?: boolean | null;
  JobFlowRole?: string | null;
  ServiceRole?: string | null;
  Tags?: Tag[] | null;
  SecurityConfiguration?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
  CustomAmiId?: string | null;
  EbsRootVolumeSize?: number | null;
  RepoUpgradeOnBoot?: RepoUpgradeOnBoot | null;
  KerberosAttributes?: KerberosAttributes | null;
  StepConcurrencyLevel?: number | null;
  ManagedScalingPolicy?: ManagedScalingPolicy | null;
  PlacementGroupConfigs?: PlacementGroupConfig[] | null;
}

// refs: 1 - tags: named, input
export interface SetTerminationProtectionInput {
  JobFlowIds: string[];
  TerminationProtected: boolean;
}

// refs: 1 - tags: named, input
export interface SetVisibleToAllUsersInput {
  JobFlowIds: string[];
  VisibleToAllUsers: boolean;
}

// refs: 1 - tags: named, input
export interface StartNotebookExecutionInput {
  EditorId: string;
  RelativePath: string;
  NotebookExecutionName?: string | null;
  NotebookParams?: string | null;
  ExecutionEngine: ExecutionEngineConfig;
  ServiceRole: string;
  NotebookInstanceSecurityGroupId?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface StopNotebookExecutionInput {
  NotebookExecutionId: string;
}

// refs: 1 - tags: named, input
export interface TerminateJobFlowsInput {
  JobFlowIds: string[];
}

// refs: 1 - tags: named, input
export interface UpdateStudioSessionMappingInput {
  StudioId: string;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType: IdentityType;
  SessionPolicyArn: string;
}

// refs: 1 - tags: named, output
export interface AddInstanceFleetOutput {
  ClusterId?: string | null;
  InstanceFleetId?: string | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface AddInstanceGroupsOutput {
  JobFlowId?: string | null;
  InstanceGroupIds?: string[] | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface AddJobFlowStepsOutput {
  StepIds?: string[] | null;
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
}

// refs: 1 - tags: named, output
export interface CancelStepsOutput {
  CancelStepsInfoList?: CancelStepsInfo[] | null;
}

// refs: 1 - tags: named, output
export interface CreateSecurityConfigurationOutput {
  Name: string;
  CreationDateTime: Date | number;
}

// refs: 1 - tags: named, output
export interface CreateStudioOutput {
  StudioId?: string | null;
  Url?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteSecurityConfigurationOutput {
}

// refs: 1 - tags: named, output
export interface DescribeClusterOutput {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobFlowsOutput {
  JobFlows?: JobFlowDetail[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeNotebookExecutionOutput {
  NotebookExecution?: NotebookExecution | null;
}

// refs: 1 - tags: named, output
export interface DescribeSecurityConfigurationOutput {
  Name?: string | null;
  SecurityConfiguration?: string | null;
  CreationDateTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeStepOutput {
  Step?: Step | null;
}

// refs: 1 - tags: named, output
export interface DescribeStudioOutput {
  Studio?: Studio | null;
}

// refs: 1 - tags: named, output
export interface GetBlockPublicAccessConfigurationOutput {
  BlockPublicAccessConfiguration: BlockPublicAccessConfiguration;
  BlockPublicAccessConfigurationMetadata: BlockPublicAccessConfigurationMetadata;
}

// refs: 1 - tags: named, output
export interface GetManagedScalingPolicyOutput {
  ManagedScalingPolicy?: ManagedScalingPolicy | null;
}

// refs: 1 - tags: named, output
export interface GetStudioSessionMappingOutput {
  SessionMapping?: SessionMappingDetail | null;
}

// refs: 1 - tags: named, output
export interface ListBootstrapActionsOutput {
  BootstrapActions?: Command[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListClustersOutput {
  Clusters?: ClusterSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceFleetsOutput {
  InstanceFleets?: InstanceFleet[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceGroupsOutput {
  InstanceGroups?: InstanceGroup[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstancesOutput {
  Instances?: Instance[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListNotebookExecutionsOutput {
  NotebookExecutions?: NotebookExecutionSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSecurityConfigurationsOutput {
  SecurityConfigurations?: SecurityConfigurationSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStepsOutput {
  Steps?: StepSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStudioSessionMappingsOutput {
  SessionMappings?: SessionMappingSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStudiosOutput {
  Studios?: StudioSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterOutput {
  StepConcurrencyLevel?: number | null;
}

// refs: 1 - tags: named, output
export interface PutAutoScalingPolicyOutput {
  ClusterId?: string | null;
  InstanceGroupId?: string | null;
  AutoScalingPolicy?: AutoScalingPolicyDescription | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface PutBlockPublicAccessConfigurationOutput {
}

// refs: 1 - tags: named, output
export interface PutManagedScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveAutoScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveManagedScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveTagsOutput {
}

// refs: 1 - tags: named, output
export interface RunJobFlowOutput {
  JobFlowId?: string | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface StartNotebookExecutionOutput {
  NotebookExecutionId?: string | null;
}

// refs: 2 - tags: input, named, interface
export interface InstanceFleetConfig {
  Name?: string | null;
  InstanceFleetType: InstanceFleetType;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
  InstanceTypeConfigs?: InstanceTypeConfig[] | null;
  LaunchSpecifications?: InstanceFleetProvisioningSpecifications | null;
}
function fromInstanceFleetConfig(input?: InstanceFleetConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    InstanceFleetType: input["InstanceFleetType"],
    TargetOnDemandCapacity: input["TargetOnDemandCapacity"],
    TargetSpotCapacity: input["TargetSpotCapacity"],
    InstanceTypeConfigs: input["InstanceTypeConfigs"]?.map(x => fromInstanceTypeConfig(x)),
    LaunchSpecifications: fromInstanceFleetProvisioningSpecifications(input["LaunchSpecifications"]),
  }
}

// refs: 4 - tags: input, named, enum, output
export type InstanceFleetType =
| "MASTER"
| "CORE"
| "TASK"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface InstanceTypeConfig {
  InstanceType: string;
  WeightedCapacity?: number | null;
  BidPrice?: string | null;
  BidPriceAsPercentageOfOnDemandPrice?: number | null;
  EbsConfiguration?: EbsConfiguration | null;
  Configurations?: Configuration[] | null;
}
function fromInstanceTypeConfig(input?: InstanceTypeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    WeightedCapacity: input["WeightedCapacity"],
    BidPrice: input["BidPrice"],
    BidPriceAsPercentageOfOnDemandPrice: input["BidPriceAsPercentageOfOnDemandPrice"],
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

// refs: 4 - tags: input, named, interface
export interface EbsConfiguration {
  EbsBlockDeviceConfigs?: EbsBlockDeviceConfig[] | null;
  EbsOptimized?: boolean | null;
}
function fromEbsConfiguration(input?: EbsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EbsBlockDeviceConfigs: input["EbsBlockDeviceConfigs"]?.map(x => fromEbsBlockDeviceConfig(x)),
    EbsOptimized: input["EbsOptimized"],
  }
}

// refs: 4 - tags: input, named, interface
export interface EbsBlockDeviceConfig {
  VolumeSpecification: VolumeSpecification;
  VolumesPerInstance?: number | null;
}
function fromEbsBlockDeviceConfig(input?: EbsBlockDeviceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeSpecification: fromVolumeSpecification(input["VolumeSpecification"]),
    VolumesPerInstance: input["VolumesPerInstance"],
  }
}

// refs: 6 - tags: input, named, interface, output
export interface VolumeSpecification {
  VolumeType: string;
  Iops?: number | null;
  SizeInGB: number;
}
function fromVolumeSpecification(input?: VolumeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeType: input["VolumeType"],
    Iops: input["Iops"],
    SizeInGB: input["SizeInGB"],
  }
}
function toVolumeSpecification(root: jsonP.JSONValue): VolumeSpecification {
  return jsonP.readObj({
    required: {
      "VolumeType": "s",
      "SizeInGB": "n",
    },
    optional: {
      "Iops": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, recursive, output
export interface Configuration {
  Classification?: string | null;
  Configurations?: Configuration[] | null;
  Properties?: { [key: string]: string | null | undefined } | null;
}
function fromConfiguration(input?: Configuration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
    Properties: input["Properties"],
  }
}
function toConfiguration(root: jsonP.JSONValue): Configuration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Classification": "s",
      "Configurations": [toConfiguration],
      "Properties": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface InstanceFleetProvisioningSpecifications {
  SpotSpecification?: SpotProvisioningSpecification | null;
  OnDemandSpecification?: OnDemandProvisioningSpecification | null;
}
function fromInstanceFleetProvisioningSpecifications(input?: InstanceFleetProvisioningSpecifications | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SpotSpecification: fromSpotProvisioningSpecification(input["SpotSpecification"]),
    OnDemandSpecification: fromOnDemandProvisioningSpecification(input["OnDemandSpecification"]),
  }
}
function toInstanceFleetProvisioningSpecifications(root: jsonP.JSONValue): InstanceFleetProvisioningSpecifications {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpotSpecification": toSpotProvisioningSpecification,
      "OnDemandSpecification": toOnDemandProvisioningSpecification,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SpotProvisioningSpecification {
  TimeoutDurationMinutes: number;
  TimeoutAction: SpotProvisioningTimeoutAction;
  BlockDurationMinutes?: number | null;
  AllocationStrategy?: SpotProvisioningAllocationStrategy | null;
}
function fromSpotProvisioningSpecification(input?: SpotProvisioningSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeoutDurationMinutes: input["TimeoutDurationMinutes"],
    TimeoutAction: input["TimeoutAction"],
    BlockDurationMinutes: input["BlockDurationMinutes"],
    AllocationStrategy: input["AllocationStrategy"],
  }
}
function toSpotProvisioningSpecification(root: jsonP.JSONValue): SpotProvisioningSpecification {
  return jsonP.readObj({
    required: {
      "TimeoutDurationMinutes": "n",
      "TimeoutAction": (x: jsonP.JSONValue) => cmnP.readEnum<SpotProvisioningTimeoutAction>(x),
    },
    optional: {
      "BlockDurationMinutes": "n",
      "AllocationStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<SpotProvisioningAllocationStrategy>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type SpotProvisioningTimeoutAction =
| "SWITCH_TO_ON_DEMAND"
| "TERMINATE_CLUSTER"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type SpotProvisioningAllocationStrategy =
| "capacity-optimized"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface OnDemandProvisioningSpecification {
  AllocationStrategy: OnDemandProvisioningAllocationStrategy;
}
function fromOnDemandProvisioningSpecification(input?: OnDemandProvisioningSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllocationStrategy: input["AllocationStrategy"],
  }
}
function toOnDemandProvisioningSpecification(root: jsonP.JSONValue): OnDemandProvisioningSpecification {
  return jsonP.readObj({
    required: {
      "AllocationStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<OnDemandProvisioningAllocationStrategy>(x),
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type OnDemandProvisioningAllocationStrategy =
| "lowest-price"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface InstanceGroupConfig {
  Name?: string | null;
  Market?: MarketType | null;
  InstanceRole: InstanceRoleType;
  BidPrice?: string | null;
  InstanceType: string;
  InstanceCount: number;
  Configurations?: Configuration[] | null;
  EbsConfiguration?: EbsConfiguration | null;
  AutoScalingPolicy?: AutoScalingPolicy | null;
}
function fromInstanceGroupConfig(input?: InstanceGroupConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Market: input["Market"],
    InstanceRole: input["InstanceRole"],
    BidPrice: input["BidPrice"],
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    AutoScalingPolicy: fromAutoScalingPolicy(input["AutoScalingPolicy"]),
  }
}

// refs: 10 - tags: input, named, enum, output
export type MarketType =
| "ON_DEMAND"
| "SPOT"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type InstanceRoleType =
| "MASTER"
| "CORE"
| "TASK"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface AutoScalingPolicy {
  Constraints: ScalingConstraints;
  Rules: ScalingRule[];
}
function fromAutoScalingPolicy(input?: AutoScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Constraints: fromScalingConstraints(input["Constraints"]),
    Rules: input["Rules"]?.map(x => fromScalingRule(x)),
  }
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingConstraints {
  MinCapacity: number;
  MaxCapacity: number;
}
function fromScalingConstraints(input?: ScalingConstraints | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinCapacity: input["MinCapacity"],
    MaxCapacity: input["MaxCapacity"],
  }
}
function toScalingConstraints(root: jsonP.JSONValue): ScalingConstraints {
  return jsonP.readObj({
    required: {
      "MinCapacity": "n",
      "MaxCapacity": "n",
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingRule {
  Name: string;
  Description?: string | null;
  Action: ScalingAction;
  Trigger: ScalingTrigger;
}
function fromScalingRule(input?: ScalingRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Action: fromScalingAction(input["Action"]),
    Trigger: fromScalingTrigger(input["Trigger"]),
  }
}
function toScalingRule(root: jsonP.JSONValue): ScalingRule {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Action": toScalingAction,
      "Trigger": toScalingTrigger,
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingAction {
  Market?: MarketType | null;
  SimpleScalingPolicyConfiguration: SimpleScalingPolicyConfiguration;
}
function fromScalingAction(input?: ScalingAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Market: input["Market"],
    SimpleScalingPolicyConfiguration: fromSimpleScalingPolicyConfiguration(input["SimpleScalingPolicyConfiguration"]),
  }
}
function toScalingAction(root: jsonP.JSONValue): ScalingAction {
  return jsonP.readObj({
    required: {
      "SimpleScalingPolicyConfiguration": toSimpleScalingPolicyConfiguration,
    },
    optional: {
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<MarketType>(x),
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface SimpleScalingPolicyConfiguration {
  AdjustmentType?: AdjustmentType | null;
  ScalingAdjustment: number;
  CoolDown?: number | null;
}
function fromSimpleScalingPolicyConfiguration(input?: SimpleScalingPolicyConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdjustmentType: input["AdjustmentType"],
    ScalingAdjustment: input["ScalingAdjustment"],
    CoolDown: input["CoolDown"],
  }
}
function toSimpleScalingPolicyConfiguration(root: jsonP.JSONValue): SimpleScalingPolicyConfiguration {
  return jsonP.readObj({
    required: {
      "ScalingAdjustment": "n",
    },
    optional: {
      "AdjustmentType": (x: jsonP.JSONValue) => cmnP.readEnum<AdjustmentType>(x),
      "CoolDown": "n",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type AdjustmentType =
| "CHANGE_IN_CAPACITY"
| "PERCENT_CHANGE_IN_CAPACITY"
| "EXACT_CAPACITY"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface ScalingTrigger {
  CloudWatchAlarmDefinition: CloudWatchAlarmDefinition;
}
function fromScalingTrigger(input?: ScalingTrigger | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchAlarmDefinition: fromCloudWatchAlarmDefinition(input["CloudWatchAlarmDefinition"]),
  }
}
function toScalingTrigger(root: jsonP.JSONValue): ScalingTrigger {
  return jsonP.readObj({
    required: {
      "CloudWatchAlarmDefinition": toCloudWatchAlarmDefinition,
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface CloudWatchAlarmDefinition {
  ComparisonOperator: ComparisonOperator;
  EvaluationPeriods?: number | null;
  MetricName: string;
  Namespace?: string | null;
  Period: number;
  Statistic?: Statistic | null;
  Threshold: number;
  Unit?: Unit | null;
  Dimensions?: MetricDimension[] | null;
}
function fromCloudWatchAlarmDefinition(input?: CloudWatchAlarmDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComparisonOperator: input["ComparisonOperator"],
    EvaluationPeriods: input["EvaluationPeriods"],
    MetricName: input["MetricName"],
    Namespace: input["Namespace"],
    Period: input["Period"],
    Statistic: input["Statistic"],
    Threshold: input["Threshold"],
    Unit: input["Unit"],
    Dimensions: input["Dimensions"]?.map(x => fromMetricDimension(x)),
  }
}
function toCloudWatchAlarmDefinition(root: jsonP.JSONValue): CloudWatchAlarmDefinition {
  return jsonP.readObj({
    required: {
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<ComparisonOperator>(x),
      "MetricName": "s",
      "Period": "n",
      "Threshold": "n",
    },
    optional: {
      "EvaluationPeriods": "n",
      "Namespace": "s",
      "Statistic": (x: jsonP.JSONValue) => cmnP.readEnum<Statistic>(x),
      "Unit": (x: jsonP.JSONValue) => cmnP.readEnum<Unit>(x),
      "Dimensions": [toMetricDimension],
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type ComparisonOperator =
| "GREATER_THAN_OR_EQUAL"
| "GREATER_THAN"
| "LESS_THAN"
| "LESS_THAN_OR_EQUAL"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type Statistic =
| "SAMPLE_COUNT"
| "AVERAGE"
| "SUM"
| "MINIMUM"
| "MAXIMUM"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type Unit =
| "NONE"
| "SECONDS"
| "MICRO_SECONDS"
| "MILLI_SECONDS"
| "BYTES"
| "KILO_BYTES"
| "MEGA_BYTES"
| "GIGA_BYTES"
| "TERA_BYTES"
| "BITS"
| "KILO_BITS"
| "MEGA_BITS"
| "GIGA_BITS"
| "TERA_BITS"
| "PERCENT"
| "COUNT"
| "BYTES_PER_SECOND"
| "KILO_BYTES_PER_SECOND"
| "MEGA_BYTES_PER_SECOND"
| "GIGA_BYTES_PER_SECOND"
| "TERA_BYTES_PER_SECOND"
| "BITS_PER_SECOND"
| "KILO_BITS_PER_SECOND"
| "MEGA_BITS_PER_SECOND"
| "GIGA_BITS_PER_SECOND"
| "TERA_BITS_PER_SECOND"
| "COUNT_PER_SECOND"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface MetricDimension {
  Key?: string | null;
  Value?: string | null;
}
function fromMetricDimension(input?: MetricDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toMetricDimension(root: jsonP.JSONValue): MetricDimension {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface StepConfig {
  Name: string;
  ActionOnFailure?: ActionOnFailure | null;
  HadoopJarStep: HadoopJarStepConfig;
}
function fromStepConfig(input?: StepConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ActionOnFailure: input["ActionOnFailure"],
    HadoopJarStep: fromHadoopJarStepConfig(input["HadoopJarStep"]),
  }
}
function toStepConfig(root: jsonP.JSONValue): StepConfig {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "HadoopJarStep": toHadoopJarStepConfig,
    },
    optional: {
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<ActionOnFailure>(x),
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type ActionOnFailure =
| "TERMINATE_JOB_FLOW"
| "TERMINATE_CLUSTER"
| "CANCEL_AND_WAIT"
| "CONTINUE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface HadoopJarStepConfig {
  Properties?: KeyValue[] | null;
  Jar: string;
  MainClass?: string | null;
  Args?: string[] | null;
}
function fromHadoopJarStepConfig(input?: HadoopJarStepConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Properties: input["Properties"]?.map(x => fromKeyValue(x)),
    Jar: input["Jar"],
    MainClass: input["MainClass"],
    Args: input["Args"],
  }
}
function toHadoopJarStepConfig(root: jsonP.JSONValue): HadoopJarStepConfig {
  return jsonP.readObj({
    required: {
      "Jar": "s",
    },
    optional: {
      "Properties": [toKeyValue],
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface KeyValue {
  Key?: string | null;
  Value?: string | null;
}
function fromKeyValue(input?: KeyValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toKeyValue(root: jsonP.JSONValue): KeyValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type StepCancellationOption =
| "SEND_INTERRUPT"
| "TERMINATE_PROCESS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type AuthMode =
| "SSO"
| "IAM"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type IdentityType =
| "USER"
| "GROUP"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type JobFlowExecutionState =
| "STARTING"
| "BOOTSTRAPPING"
| "RUNNING"
| "WAITING"
| "SHUTTING_DOWN"
| "TERMINATED"
| "COMPLETED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ClusterState =
| "STARTING"
| "BOOTSTRAPPING"
| "RUNNING"
| "WAITING"
| "TERMINATING"
| "TERMINATED"
| "TERMINATED_WITH_ERRORS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type InstanceGroupType =
| "MASTER"
| "CORE"
| "TASK"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type InstanceState =
| "AWAITING_FULFILLMENT"
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type NotebookExecutionStatus =
| "START_PENDING"
| "STARTING"
| "RUNNING"
| "FINISHING"
| "FINISHED"
| "FAILING"
| "FAILED"
| "STOP_PENDING"
| "STOPPING"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type StepState =
| "PENDING"
| "CANCEL_PENDING"
| "RUNNING"
| "COMPLETED"
| "CANCELLED"
| "FAILED"
| "INTERRUPTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface InstanceFleetModifyConfig {
  InstanceFleetId: string;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
}
function fromInstanceFleetModifyConfig(input?: InstanceFleetModifyConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceFleetId: input["InstanceFleetId"],
    TargetOnDemandCapacity: input["TargetOnDemandCapacity"],
    TargetSpotCapacity: input["TargetSpotCapacity"],
  }
}

// refs: 1 - tags: input, named, interface
export interface InstanceGroupModifyConfig {
  InstanceGroupId: string;
  InstanceCount?: number | null;
  EC2InstanceIdsToTerminate?: string[] | null;
  ShrinkPolicy?: ShrinkPolicy | null;
  Configurations?: Configuration[] | null;
}
function fromInstanceGroupModifyConfig(input?: InstanceGroupModifyConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceGroupId: input["InstanceGroupId"],
    InstanceCount: input["InstanceCount"],
    EC2InstanceIdsToTerminate: input["EC2InstanceIdsToTerminate"],
    ShrinkPolicy: fromShrinkPolicy(input["ShrinkPolicy"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

// refs: 2 - tags: input, named, interface, output
export interface ShrinkPolicy {
  DecommissionTimeout?: number | null;
  InstanceResizePolicy?: InstanceResizePolicy | null;
}
function fromShrinkPolicy(input?: ShrinkPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DecommissionTimeout: input["DecommissionTimeout"],
    InstanceResizePolicy: fromInstanceResizePolicy(input["InstanceResizePolicy"]),
  }
}
function toShrinkPolicy(root: jsonP.JSONValue): ShrinkPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "DecommissionTimeout": "n",
      "InstanceResizePolicy": toInstanceResizePolicy,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface InstanceResizePolicy {
  InstancesToTerminate?: string[] | null;
  InstancesToProtect?: string[] | null;
  InstanceTerminationTimeout?: number | null;
}
function fromInstanceResizePolicy(input?: InstanceResizePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstancesToTerminate: input["InstancesToTerminate"],
    InstancesToProtect: input["InstancesToProtect"],
    InstanceTerminationTimeout: input["InstanceTerminationTimeout"],
  }
}
function toInstanceResizePolicy(root: jsonP.JSONValue): InstanceResizePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstancesToTerminate": ["s"],
      "InstancesToProtect": ["s"],
      "InstanceTerminationTimeout": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BlockPublicAccessConfiguration {
  BlockPublicSecurityGroupRules: boolean;
  PermittedPublicSecurityGroupRuleRanges?: PortRange[] | null;
}
function fromBlockPublicAccessConfiguration(input?: BlockPublicAccessConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlockPublicSecurityGroupRules: input["BlockPublicSecurityGroupRules"],
    PermittedPublicSecurityGroupRuleRanges: input["PermittedPublicSecurityGroupRuleRanges"]?.map(x => fromPortRange(x)),
  }
}
function toBlockPublicAccessConfiguration(root: jsonP.JSONValue): BlockPublicAccessConfiguration {
  return jsonP.readObj({
    required: {
      "BlockPublicSecurityGroupRules": "b",
    },
    optional: {
      "PermittedPublicSecurityGroupRuleRanges": [toPortRange],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PortRange {
  MinRange: number;
  MaxRange?: number | null;
}
function fromPortRange(input?: PortRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinRange: input["MinRange"],
    MaxRange: input["MaxRange"],
  }
}
function toPortRange(root: jsonP.JSONValue): PortRange {
  return jsonP.readObj({
    required: {
      "MinRange": "n",
    },
    optional: {
      "MaxRange": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ManagedScalingPolicy {
  ComputeLimits?: ComputeLimits | null;
}
function fromManagedScalingPolicy(input?: ManagedScalingPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComputeLimits: fromComputeLimits(input["ComputeLimits"]),
  }
}
function toManagedScalingPolicy(root: jsonP.JSONValue): ManagedScalingPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComputeLimits": toComputeLimits,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ComputeLimits {
  UnitType: ComputeLimitsUnitType;
  MinimumCapacityUnits: number;
  MaximumCapacityUnits: number;
  MaximumOnDemandCapacityUnits?: number | null;
  MaximumCoreCapacityUnits?: number | null;
}
function fromComputeLimits(input?: ComputeLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UnitType: input["UnitType"],
    MinimumCapacityUnits: input["MinimumCapacityUnits"],
    MaximumCapacityUnits: input["MaximumCapacityUnits"],
    MaximumOnDemandCapacityUnits: input["MaximumOnDemandCapacityUnits"],
    MaximumCoreCapacityUnits: input["MaximumCoreCapacityUnits"],
  }
}
function toComputeLimits(root: jsonP.JSONValue): ComputeLimits {
  return jsonP.readObj({
    required: {
      "UnitType": (x: jsonP.JSONValue) => cmnP.readEnum<ComputeLimitsUnitType>(x),
      "MinimumCapacityUnits": "n",
      "MaximumCapacityUnits": "n",
    },
    optional: {
      "MaximumOnDemandCapacityUnits": "n",
      "MaximumCoreCapacityUnits": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ComputeLimitsUnitType =
| "InstanceFleetUnits"
| "Instances"
| "VCPU"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface JobFlowInstancesConfig {
  MasterInstanceType?: string | null;
  SlaveInstanceType?: string | null;
  InstanceCount?: number | null;
  InstanceGroups?: InstanceGroupConfig[] | null;
  InstanceFleets?: InstanceFleetConfig[] | null;
  Ec2KeyName?: string | null;
  Placement?: PlacementType | null;
  KeepJobFlowAliveWhenNoSteps?: boolean | null;
  TerminationProtected?: boolean | null;
  HadoopVersion?: string | null;
  Ec2SubnetId?: string | null;
  Ec2SubnetIds?: string[] | null;
  EmrManagedMasterSecurityGroup?: string | null;
  EmrManagedSlaveSecurityGroup?: string | null;
  ServiceAccessSecurityGroup?: string | null;
  AdditionalMasterSecurityGroups?: string[] | null;
  AdditionalSlaveSecurityGroups?: string[] | null;
}
function fromJobFlowInstancesConfig(input?: JobFlowInstancesConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MasterInstanceType: input["MasterInstanceType"],
    SlaveInstanceType: input["SlaveInstanceType"],
    InstanceCount: input["InstanceCount"],
    InstanceGroups: input["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
    InstanceFleets: input["InstanceFleets"]?.map(x => fromInstanceFleetConfig(x)),
    Ec2KeyName: input["Ec2KeyName"],
    Placement: fromPlacementType(input["Placement"]),
    KeepJobFlowAliveWhenNoSteps: input["KeepJobFlowAliveWhenNoSteps"],
    TerminationProtected: input["TerminationProtected"],
    HadoopVersion: input["HadoopVersion"],
    Ec2SubnetId: input["Ec2SubnetId"],
    Ec2SubnetIds: input["Ec2SubnetIds"],
    EmrManagedMasterSecurityGroup: input["EmrManagedMasterSecurityGroup"],
    EmrManagedSlaveSecurityGroup: input["EmrManagedSlaveSecurityGroup"],
    ServiceAccessSecurityGroup: input["ServiceAccessSecurityGroup"],
    AdditionalMasterSecurityGroups: input["AdditionalMasterSecurityGroups"],
    AdditionalSlaveSecurityGroups: input["AdditionalSlaveSecurityGroups"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface PlacementType {
  AvailabilityZone?: string | null;
  AvailabilityZones?: string[] | null;
}
function fromPlacementType(input?: PlacementType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZone: input["AvailabilityZone"],
    AvailabilityZones: input["AvailabilityZones"],
  }
}
function toPlacementType(root: jsonP.JSONValue): PlacementType {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZone": "s",
      "AvailabilityZones": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BootstrapActionConfig {
  Name: string;
  ScriptBootstrapAction: ScriptBootstrapActionConfig;
}
function fromBootstrapActionConfig(input?: BootstrapActionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ScriptBootstrapAction: fromScriptBootstrapActionConfig(input["ScriptBootstrapAction"]),
  }
}
function toBootstrapActionConfig(root: jsonP.JSONValue): BootstrapActionConfig {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "ScriptBootstrapAction": toScriptBootstrapActionConfig,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ScriptBootstrapActionConfig {
  Path: string;
  Args?: string[] | null;
}
function fromScriptBootstrapActionConfig(input?: ScriptBootstrapActionConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    Args: input["Args"],
  }
}
function toScriptBootstrapActionConfig(root: jsonP.JSONValue): ScriptBootstrapActionConfig {
  return jsonP.readObj({
    required: {
      "Path": "s",
    },
    optional: {
      "Args": ["s"],
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface SupportedProductConfig {
  Name?: string | null;
  Args?: string[] | null;
}
function fromSupportedProductConfig(input?: SupportedProductConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Args: input["Args"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface Application {
  Name?: string | null;
  Version?: string | null;
  Args?: string[] | null;
  AdditionalInfo?: { [key: string]: string | null | undefined } | null;
}
function fromApplication(input?: Application | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
    Args: input["Args"],
    AdditionalInfo: input["AdditionalInfo"],
  }
}
function toApplication(root: jsonP.JSONValue): Application {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
      "Args": ["s"],
      "AdditionalInfo": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ScaleDownBehavior =
| "TERMINATE_AT_INSTANCE_HOUR"
| "TERMINATE_AT_TASK_COMPLETION"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type RepoUpgradeOnBoot =
| "SECURITY"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface KerberosAttributes {
  Realm: string;
  KdcAdminPassword: string;
  CrossRealmTrustPrincipalPassword?: string | null;
  ADDomainJoinUser?: string | null;
  ADDomainJoinPassword?: string | null;
}
function fromKerberosAttributes(input?: KerberosAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Realm: input["Realm"],
    KdcAdminPassword: input["KdcAdminPassword"],
    CrossRealmTrustPrincipalPassword: input["CrossRealmTrustPrincipalPassword"],
    ADDomainJoinUser: input["ADDomainJoinUser"],
    ADDomainJoinPassword: input["ADDomainJoinPassword"],
  }
}
function toKerberosAttributes(root: jsonP.JSONValue): KerberosAttributes {
  return jsonP.readObj({
    required: {
      "Realm": "s",
      "KdcAdminPassword": "s",
    },
    optional: {
      "CrossRealmTrustPrincipalPassword": "s",
      "ADDomainJoinUser": "s",
      "ADDomainJoinPassword": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PlacementGroupConfig {
  InstanceRole: InstanceRoleType;
  PlacementStrategy?: PlacementGroupStrategy | null;
}
function fromPlacementGroupConfig(input?: PlacementGroupConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceRole: input["InstanceRole"],
    PlacementStrategy: input["PlacementStrategy"],
  }
}
function toPlacementGroupConfig(root: jsonP.JSONValue): PlacementGroupConfig {
  return jsonP.readObj({
    required: {
      "InstanceRole": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceRoleType>(x),
    },
    optional: {
      "PlacementStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<PlacementGroupStrategy>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type PlacementGroupStrategy =
| "SPREAD"
| "PARTITION"
| "CLUSTER"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ExecutionEngineConfig {
  Id: string;
  Type?: ExecutionEngineType | null;
  MasterInstanceSecurityGroupId?: string | null;
}
function fromExecutionEngineConfig(input?: ExecutionEngineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Type: input["Type"],
    MasterInstanceSecurityGroupId: input["MasterInstanceSecurityGroupId"],
  }
}
function toExecutionEngineConfig(root: jsonP.JSONValue): ExecutionEngineConfig {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<ExecutionEngineType>(x),
      "MasterInstanceSecurityGroupId": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ExecutionEngineType =
| "EMR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface CancelStepsInfo {
  StepId?: string | null;
  Status?: CancelStepsRequestStatus | null;
  Reason?: string | null;
}
function toCancelStepsInfo(root: jsonP.JSONValue): CancelStepsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<CancelStepsRequestStatus>(x),
      "Reason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type CancelStepsRequestStatus =
| "SUBMITTED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Cluster {
  Id?: string | null;
  Name?: string | null;
  Status?: ClusterStatus | null;
  Ec2InstanceAttributes?: Ec2InstanceAttributes | null;
  InstanceCollectionType?: InstanceCollectionType | null;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  RequestedAmiVersion?: string | null;
  RunningAmiVersion?: string | null;
  ReleaseLabel?: string | null;
  AutoTerminate?: boolean | null;
  TerminationProtected?: boolean | null;
  VisibleToAllUsers?: boolean | null;
  Applications?: Application[] | null;
  Tags?: Tag[] | null;
  ServiceRole?: string | null;
  NormalizedInstanceHours?: number | null;
  MasterPublicDnsName?: string | null;
  Configurations?: Configuration[] | null;
  SecurityConfiguration?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
  CustomAmiId?: string | null;
  EbsRootVolumeSize?: number | null;
  RepoUpgradeOnBoot?: RepoUpgradeOnBoot | null;
  KerberosAttributes?: KerberosAttributes | null;
  ClusterArn?: string | null;
  OutpostArn?: string | null;
  StepConcurrencyLevel?: number | null;
  PlacementGroups?: PlacementGroupConfig[] | null;
}
function toCluster(root: jsonP.JSONValue): Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "Ec2InstanceAttributes": toEc2InstanceAttributes,
      "InstanceCollectionType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceCollectionType>(x),
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "RequestedAmiVersion": "s",
      "RunningAmiVersion": "s",
      "ReleaseLabel": "s",
      "AutoTerminate": "b",
      "TerminationProtected": "b",
      "VisibleToAllUsers": "b",
      "Applications": [toApplication],
      "Tags": [toTag],
      "ServiceRole": "s",
      "NormalizedInstanceHours": "n",
      "MasterPublicDnsName": "s",
      "Configurations": [toConfiguration],
      "SecurityConfiguration": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<ScaleDownBehavior>(x),
      "CustomAmiId": "s",
      "EbsRootVolumeSize": "n",
      "RepoUpgradeOnBoot": (x: jsonP.JSONValue) => cmnP.readEnum<RepoUpgradeOnBoot>(x),
      "KerberosAttributes": toKerberosAttributes,
      "ClusterArn": "s",
      "OutpostArn": "s",
      "StepConcurrencyLevel": "n",
      "PlacementGroups": [toPlacementGroupConfig],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterStatus {
  State?: ClusterState | null;
  StateChangeReason?: ClusterStateChangeReason | null;
  Timeline?: ClusterTimeline | null;
}
function toClusterStatus(root: jsonP.JSONValue): ClusterStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterState>(x),
      "StateChangeReason": toClusterStateChangeReason,
      "Timeline": toClusterTimeline,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterStateChangeReason {
  Code?: ClusterStateChangeReasonCode | null;
  Message?: string | null;
}
function toClusterStateChangeReason(root: jsonP.JSONValue): ClusterStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<ClusterStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ClusterStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "INSTANCE_FLEET_TIMEOUT"
| "BOOTSTRAP_FAILURE"
| "USER_REQUEST"
| "STEP_FAILURE"
| "ALL_STEPS_COMPLETED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface ClusterTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toClusterTimeline(root: jsonP.JSONValue): ClusterTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Ec2InstanceAttributes {
  Ec2KeyName?: string | null;
  Ec2SubnetId?: string | null;
  RequestedEc2SubnetIds?: string[] | null;
  Ec2AvailabilityZone?: string | null;
  RequestedEc2AvailabilityZones?: string[] | null;
  IamInstanceProfile?: string | null;
  EmrManagedMasterSecurityGroup?: string | null;
  EmrManagedSlaveSecurityGroup?: string | null;
  ServiceAccessSecurityGroup?: string | null;
  AdditionalMasterSecurityGroups?: string[] | null;
  AdditionalSlaveSecurityGroups?: string[] | null;
}
function toEc2InstanceAttributes(root: jsonP.JSONValue): Ec2InstanceAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "RequestedEc2SubnetIds": ["s"],
      "Ec2AvailabilityZone": "s",
      "RequestedEc2AvailabilityZones": ["s"],
      "IamInstanceProfile": "s",
      "EmrManagedMasterSecurityGroup": "s",
      "EmrManagedSlaveSecurityGroup": "s",
      "ServiceAccessSecurityGroup": "s",
      "AdditionalMasterSecurityGroups": ["s"],
      "AdditionalSlaveSecurityGroups": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceCollectionType =
| "INSTANCE_FLEET"
| "INSTANCE_GROUP"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface JobFlowDetail {
  JobFlowId: string;
  Name: string;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  AmiVersion?: string | null;
  ExecutionStatusDetail: JobFlowExecutionStatusDetail;
  Instances: JobFlowInstancesDetail;
  Steps?: StepDetail[] | null;
  BootstrapActions?: BootstrapActionDetail[] | null;
  SupportedProducts?: string[] | null;
  VisibleToAllUsers?: boolean | null;
  JobFlowRole?: string | null;
  ServiceRole?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
}
function toJobFlowDetail(root: jsonP.JSONValue): JobFlowDetail {
  return jsonP.readObj({
    required: {
      "JobFlowId": "s",
      "Name": "s",
      "ExecutionStatusDetail": toJobFlowExecutionStatusDetail,
      "Instances": toJobFlowInstancesDetail,
    },
    optional: {
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "AmiVersion": "s",
      "Steps": [toStepDetail],
      "BootstrapActions": [toBootstrapActionDetail],
      "SupportedProducts": ["s"],
      "VisibleToAllUsers": "b",
      "JobFlowRole": "s",
      "ServiceRole": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<ScaleDownBehavior>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobFlowExecutionStatusDetail {
  State: JobFlowExecutionState;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
  LastStateChangeReason?: string | null;
}
function toJobFlowExecutionStatusDetail(root: jsonP.JSONValue): JobFlowExecutionStatusDetail {
  return jsonP.readObj({
    required: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<JobFlowExecutionState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobFlowInstancesDetail {
  MasterInstanceType: string;
  MasterPublicDnsName?: string | null;
  MasterInstanceId?: string | null;
  SlaveInstanceType: string;
  InstanceCount: number;
  InstanceGroups?: InstanceGroupDetail[] | null;
  NormalizedInstanceHours?: number | null;
  Ec2KeyName?: string | null;
  Ec2SubnetId?: string | null;
  Placement?: PlacementType | null;
  KeepJobFlowAliveWhenNoSteps?: boolean | null;
  TerminationProtected?: boolean | null;
  HadoopVersion?: string | null;
}
function toJobFlowInstancesDetail(root: jsonP.JSONValue): JobFlowInstancesDetail {
  return jsonP.readObj({
    required: {
      "MasterInstanceType": "s",
      "SlaveInstanceType": "s",
      "InstanceCount": "n",
    },
    optional: {
      "MasterPublicDnsName": "s",
      "MasterInstanceId": "s",
      "InstanceGroups": [toInstanceGroupDetail],
      "NormalizedInstanceHours": "n",
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "Placement": toPlacementType,
      "KeepJobFlowAliveWhenNoSteps": "b",
      "TerminationProtected": "b",
      "HadoopVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupDetail {
  InstanceGroupId?: string | null;
  Name?: string | null;
  Market: MarketType;
  InstanceRole: InstanceRoleType;
  BidPrice?: string | null;
  InstanceType: string;
  InstanceRequestCount: number;
  InstanceRunningCount: number;
  State: InstanceGroupState;
  LastStateChangeReason?: string | null;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceGroupDetail(root: jsonP.JSONValue): InstanceGroupDetail {
  return jsonP.readObj({
    required: {
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<MarketType>(x),
      "InstanceRole": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceRoleType>(x),
      "InstanceType": "s",
      "InstanceRequestCount": "n",
      "InstanceRunningCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceGroupState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "InstanceGroupId": "s",
      "Name": "s",
      "BidPrice": "s",
      "LastStateChangeReason": "s",
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type InstanceGroupState =
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "RECONFIGURING"
| "RESIZING"
| "SUSPENDED"
| "TERMINATING"
| "TERMINATED"
| "ARRESTED"
| "SHUTTING_DOWN"
| "ENDED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface StepDetail {
  StepConfig: StepConfig;
  ExecutionStatusDetail: StepExecutionStatusDetail;
}
function toStepDetail(root: jsonP.JSONValue): StepDetail {
  return jsonP.readObj({
    required: {
      "StepConfig": toStepConfig,
      "ExecutionStatusDetail": toStepExecutionStatusDetail,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StepExecutionStatusDetail {
  State: StepExecutionState;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
  LastStateChangeReason?: string | null;
}
function toStepExecutionStatusDetail(root: jsonP.JSONValue): StepExecutionStatusDetail {
  return jsonP.readObj({
    required: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<StepExecutionState>(x),
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type StepExecutionState =
| "PENDING"
| "RUNNING"
| "CONTINUE"
| "COMPLETED"
| "CANCELLED"
| "FAILED"
| "INTERRUPTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BootstrapActionDetail {
  BootstrapActionConfig?: BootstrapActionConfig | null;
}
function toBootstrapActionDetail(root: jsonP.JSONValue): BootstrapActionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "BootstrapActionConfig": toBootstrapActionConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookExecution {
  NotebookExecutionId?: string | null;
  EditorId?: string | null;
  ExecutionEngine?: ExecutionEngineConfig | null;
  NotebookExecutionName?: string | null;
  NotebookParams?: string | null;
  Status?: NotebookExecutionStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Arn?: string | null;
  OutputNotebookURI?: string | null;
  LastStateChangeReason?: string | null;
  NotebookInstanceSecurityGroupId?: string | null;
  Tags?: Tag[] | null;
}
function toNotebookExecution(root: jsonP.JSONValue): NotebookExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "ExecutionEngine": toExecutionEngineConfig,
      "NotebookExecutionName": "s",
      "NotebookParams": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<NotebookExecutionStatus>(x),
      "StartTime": "d",
      "EndTime": "d",
      "Arn": "s",
      "OutputNotebookURI": "s",
      "LastStateChangeReason": "s",
      "NotebookInstanceSecurityGroupId": "s",
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Step {
  Id?: string | null;
  Name?: string | null;
  Config?: HadoopStepConfig | null;
  ActionOnFailure?: ActionOnFailure | null;
  Status?: StepStatus | null;
}
function toStep(root: jsonP.JSONValue): Step {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<ActionOnFailure>(x),
      "Status": toStepStatus,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface HadoopStepConfig {
  Jar?: string | null;
  Properties?: { [key: string]: string | null | undefined } | null;
  MainClass?: string | null;
  Args?: string[] | null;
}
function toHadoopStepConfig(root: jsonP.JSONValue): HadoopStepConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Jar": "s",
      "Properties": x => jsonP.readMap(String, String, x),
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepStatus {
  State?: StepState | null;
  StateChangeReason?: StepStateChangeReason | null;
  FailureDetails?: FailureDetails | null;
  Timeline?: StepTimeline | null;
}
function toStepStatus(root: jsonP.JSONValue): StepStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<StepState>(x),
      "StateChangeReason": toStepStateChangeReason,
      "FailureDetails": toFailureDetails,
      "Timeline": toStepTimeline,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepStateChangeReason {
  Code?: StepStateChangeReasonCode | null;
  Message?: string | null;
}
function toStepStateChangeReason(root: jsonP.JSONValue): StepStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<StepStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type StepStateChangeReasonCode =
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface FailureDetails {
  Reason?: string | null;
  Message?: string | null;
  LogFile?: string | null;
}
function toFailureDetails(root: jsonP.JSONValue): FailureDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Reason": "s",
      "Message": "s",
      "LogFile": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepTimeline {
  CreationDateTime?: Date | number | null;
  StartDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toStepTimeline(root: jsonP.JSONValue): StepTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "StartDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Studio {
  StudioId?: string | null;
  StudioArn?: string | null;
  Name?: string | null;
  Description?: string | null;
  AuthMode?: AuthMode | null;
  VpcId?: string | null;
  SubnetIds?: string[] | null;
  ServiceRole?: string | null;
  UserRole?: string | null;
  WorkspaceSecurityGroupId?: string | null;
  EngineSecurityGroupId?: string | null;
  Url?: string | null;
  CreationTime?: Date | number | null;
  DefaultS3Location?: string | null;
  Tags?: Tag[] | null;
}
function toStudio(root: jsonP.JSONValue): Studio {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "StudioArn": "s",
      "Name": "s",
      "Description": "s",
      "AuthMode": (x: jsonP.JSONValue) => cmnP.readEnum<AuthMode>(x),
      "VpcId": "s",
      "SubnetIds": ["s"],
      "ServiceRole": "s",
      "UserRole": "s",
      "WorkspaceSecurityGroupId": "s",
      "EngineSecurityGroupId": "s",
      "Url": "s",
      "CreationTime": "d",
      "DefaultS3Location": "s",
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BlockPublicAccessConfigurationMetadata {
  CreationDateTime: Date | number;
  CreatedByArn: string;
}
function toBlockPublicAccessConfigurationMetadata(root: jsonP.JSONValue): BlockPublicAccessConfigurationMetadata {
  return jsonP.readObj({
    required: {
      "CreationDateTime": "d",
      "CreatedByArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SessionMappingDetail {
  StudioId?: string | null;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType?: IdentityType | null;
  SessionPolicyArn?: string | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
}
function toSessionMappingDetail(root: jsonP.JSONValue): SessionMappingDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "IdentityId": "s",
      "IdentityName": "s",
      "IdentityType": (x: jsonP.JSONValue) => cmnP.readEnum<IdentityType>(x),
      "SessionPolicyArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Command {
  Name?: string | null;
  ScriptPath?: string | null;
  Args?: string[] | null;
}
function toCommand(root: jsonP.JSONValue): Command {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ScriptPath": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ClusterSummary {
  Id?: string | null;
  Name?: string | null;
  Status?: ClusterStatus | null;
  NormalizedInstanceHours?: number | null;
  ClusterArn?: string | null;
  OutpostArn?: string | null;
}
function toClusterSummary(root: jsonP.JSONValue): ClusterSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "NormalizedInstanceHours": "n",
      "ClusterArn": "s",
      "OutpostArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleet {
  Id?: string | null;
  Name?: string | null;
  Status?: InstanceFleetStatus | null;
  InstanceFleetType?: InstanceFleetType | null;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
  ProvisionedOnDemandCapacity?: number | null;
  ProvisionedSpotCapacity?: number | null;
  InstanceTypeSpecifications?: InstanceTypeSpecification[] | null;
  LaunchSpecifications?: InstanceFleetProvisioningSpecifications | null;
}
function toInstanceFleet(root: jsonP.JSONValue): InstanceFleet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toInstanceFleetStatus,
      "InstanceFleetType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceFleetType>(x),
      "TargetOnDemandCapacity": "n",
      "TargetSpotCapacity": "n",
      "ProvisionedOnDemandCapacity": "n",
      "ProvisionedSpotCapacity": "n",
      "InstanceTypeSpecifications": [toInstanceTypeSpecification],
      "LaunchSpecifications": toInstanceFleetProvisioningSpecifications,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleetStatus {
  State?: InstanceFleetState | null;
  StateChangeReason?: InstanceFleetStateChangeReason | null;
  Timeline?: InstanceFleetTimeline | null;
}
function toInstanceFleetStatus(root: jsonP.JSONValue): InstanceFleetStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceFleetState>(x),
      "StateChangeReason": toInstanceFleetStateChangeReason,
      "Timeline": toInstanceFleetTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceFleetState =
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "RESIZING"
| "SUSPENDED"
| "TERMINATING"
| "TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InstanceFleetStateChangeReason {
  Code?: InstanceFleetStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceFleetStateChangeReason(root: jsonP.JSONValue): InstanceFleetStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceFleetStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceFleetStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "CLUSTER_TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InstanceFleetTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceFleetTimeline(root: jsonP.JSONValue): InstanceFleetTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceTypeSpecification {
  InstanceType?: string | null;
  WeightedCapacity?: number | null;
  BidPrice?: string | null;
  BidPriceAsPercentageOfOnDemandPrice?: number | null;
  Configurations?: Configuration[] | null;
  EbsBlockDevices?: EbsBlockDevice[] | null;
  EbsOptimized?: boolean | null;
}
function toInstanceTypeSpecification(root: jsonP.JSONValue): InstanceTypeSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceType": "s",
      "WeightedCapacity": "n",
      "BidPrice": "s",
      "BidPriceAsPercentageOfOnDemandPrice": "n",
      "Configurations": [toConfiguration],
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EbsBlockDevice {
  VolumeSpecification?: VolumeSpecification | null;
  Device?: string | null;
}
function toEbsBlockDevice(root: jsonP.JSONValue): EbsBlockDevice {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeSpecification": toVolumeSpecification,
      "Device": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroup {
  Id?: string | null;
  Name?: string | null;
  Market?: MarketType | null;
  InstanceGroupType?: InstanceGroupType | null;
  BidPrice?: string | null;
  InstanceType?: string | null;
  RequestedInstanceCount?: number | null;
  RunningInstanceCount?: number | null;
  Status?: InstanceGroupStatus | null;
  Configurations?: Configuration[] | null;
  ConfigurationsVersion?: number | null;
  LastSuccessfullyAppliedConfigurations?: Configuration[] | null;
  LastSuccessfullyAppliedConfigurationsVersion?: number | null;
  EbsBlockDevices?: EbsBlockDevice[] | null;
  EbsOptimized?: boolean | null;
  ShrinkPolicy?: ShrinkPolicy | null;
  AutoScalingPolicy?: AutoScalingPolicyDescription | null;
}
function toInstanceGroup(root: jsonP.JSONValue): InstanceGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<MarketType>(x),
      "InstanceGroupType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceGroupType>(x),
      "BidPrice": "s",
      "InstanceType": "s",
      "RequestedInstanceCount": "n",
      "RunningInstanceCount": "n",
      "Status": toInstanceGroupStatus,
      "Configurations": [toConfiguration],
      "ConfigurationsVersion": "n",
      "LastSuccessfullyAppliedConfigurations": [toConfiguration],
      "LastSuccessfullyAppliedConfigurationsVersion": "n",
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
      "ShrinkPolicy": toShrinkPolicy,
      "AutoScalingPolicy": toAutoScalingPolicyDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupStatus {
  State?: InstanceGroupState | null;
  StateChangeReason?: InstanceGroupStateChangeReason | null;
  Timeline?: InstanceGroupTimeline | null;
}
function toInstanceGroupStatus(root: jsonP.JSONValue): InstanceGroupStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceGroupState>(x),
      "StateChangeReason": toInstanceGroupStateChangeReason,
      "Timeline": toInstanceGroupTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupStateChangeReason {
  Code?: InstanceGroupStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceGroupStateChangeReason(root: jsonP.JSONValue): InstanceGroupStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceGroupStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceGroupStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "CLUSTER_TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InstanceGroupTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceGroupTimeline(root: jsonP.JSONValue): InstanceGroupTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyDescription {
  Status?: AutoScalingPolicyStatus | null;
  Constraints?: ScalingConstraints | null;
  Rules?: ScalingRule[] | null;
}
function toAutoScalingPolicyDescription(root: jsonP.JSONValue): AutoScalingPolicyDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": toAutoScalingPolicyStatus,
      "Constraints": toScalingConstraints,
      "Rules": [toScalingRule],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyStatus {
  State?: AutoScalingPolicyState | null;
  StateChangeReason?: AutoScalingPolicyStateChangeReason | null;
}
function toAutoScalingPolicyStatus(root: jsonP.JSONValue): AutoScalingPolicyStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<AutoScalingPolicyState>(x),
      "StateChangeReason": toAutoScalingPolicyStateChangeReason,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoScalingPolicyState =
| "PENDING"
| "ATTACHING"
| "ATTACHED"
| "DETACHING"
| "DETACHED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyStateChangeReason {
  Code?: AutoScalingPolicyStateChangeReasonCode | null;
  Message?: string | null;
}
function toAutoScalingPolicyStateChangeReason(root: jsonP.JSONValue): AutoScalingPolicyStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<AutoScalingPolicyStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoScalingPolicyStateChangeReasonCode =
| "USER_REQUEST"
| "PROVISION_FAILURE"
| "CLEANUP_FAILURE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Instance {
  Id?: string | null;
  Ec2InstanceId?: string | null;
  PublicDnsName?: string | null;
  PublicIpAddress?: string | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
  Status?: InstanceStatus | null;
  InstanceGroupId?: string | null;
  InstanceFleetId?: string | null;
  Market?: MarketType | null;
  InstanceType?: string | null;
  EbsVolumes?: EbsVolume[] | null;
}
function toInstance(root: jsonP.JSONValue): Instance {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Ec2InstanceId": "s",
      "PublicDnsName": "s",
      "PublicIpAddress": "s",
      "PrivateDnsName": "s",
      "PrivateIpAddress": "s",
      "Status": toInstanceStatus,
      "InstanceGroupId": "s",
      "InstanceFleetId": "s",
      "Market": (x: jsonP.JSONValue) => cmnP.readEnum<MarketType>(x),
      "InstanceType": "s",
      "EbsVolumes": [toEbsVolume],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceStatus {
  State?: InstanceState | null;
  StateChangeReason?: InstanceStateChangeReason | null;
  Timeline?: InstanceTimeline | null;
}
function toInstanceStatus(root: jsonP.JSONValue): InstanceStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceState>(x),
      "StateChangeReason": toInstanceStateChangeReason,
      "Timeline": toInstanceTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceStateChangeReason {
  Code?: InstanceStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceStateChangeReason(root: jsonP.JSONValue): InstanceStateChangeReason {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceStateChangeReasonCode>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "BOOTSTRAP_FAILURE"
| "CLUSTER_TERMINATED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InstanceTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceTimeline(root: jsonP.JSONValue): InstanceTimeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EbsVolume {
  Device?: string | null;
  VolumeId?: string | null;
}
function toEbsVolume(root: jsonP.JSONValue): EbsVolume {
  return jsonP.readObj({
    required: {},
    optional: {
      "Device": "s",
      "VolumeId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookExecutionSummary {
  NotebookExecutionId?: string | null;
  EditorId?: string | null;
  NotebookExecutionName?: string | null;
  Status?: NotebookExecutionStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
}
function toNotebookExecutionSummary(root: jsonP.JSONValue): NotebookExecutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "NotebookExecutionName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<NotebookExecutionStatus>(x),
      "StartTime": "d",
      "EndTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SecurityConfigurationSummary {
  Name?: string | null;
  CreationDateTime?: Date | number | null;
}
function toSecurityConfigurationSummary(root: jsonP.JSONValue): SecurityConfigurationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CreationDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StepSummary {
  Id?: string | null;
  Name?: string | null;
  Config?: HadoopStepConfig | null;
  ActionOnFailure?: ActionOnFailure | null;
  Status?: StepStatus | null;
}
function toStepSummary(root: jsonP.JSONValue): StepSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": (x: jsonP.JSONValue) => cmnP.readEnum<ActionOnFailure>(x),
      "Status": toStepStatus,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SessionMappingSummary {
  StudioId?: string | null;
  IdentityId?: string | null;
  IdentityName?: string | null;
  IdentityType?: IdentityType | null;
  SessionPolicyArn?: string | null;
  CreationTime?: Date | number | null;
}
function toSessionMappingSummary(root: jsonP.JSONValue): SessionMappingSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "IdentityId": "s",
      "IdentityName": "s",
      "IdentityType": (x: jsonP.JSONValue) => cmnP.readEnum<IdentityType>(x),
      "SessionPolicyArn": "s",
      "CreationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StudioSummary {
  StudioId?: string | null;
  Name?: string | null;
  VpcId?: string | null;
  Description?: string | null;
  Url?: string | null;
  CreationTime?: Date | number | null;
}
function toStudioSummary(root: jsonP.JSONValue): StudioSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "StudioId": "s",
      "Name": "s",
      "VpcId": "s",
      "Description": "s",
      "Url": "s",
      "CreationTime": "d",
    },
  }, root);
}
