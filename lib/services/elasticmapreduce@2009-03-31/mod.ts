// Autogenerated API client for: Amazon Elastic MapReduce

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class EMR {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(EMR.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2009-03-31",
    "endpointPrefix": "elasticmapreduce",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon EMR",
    "serviceFullName": "Amazon Elastic MapReduce",
    "serviceId": "EMR",
    "signatureVersion": "v4",
    "targetPrefix": "ElasticMapReduce",
    "uid": "elasticmapreduce-2009-03-31"
  };

  async addInstanceFleet(
    {abortSignal, ...params}: RequestConfig & AddInstanceFleetInput,
  ): Promise<AddInstanceFleetOutput> {
    const body: JSONObject = {...params,
    InstanceFleet: fromInstanceFleetConfig(params["InstanceFleet"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceFleet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceFleetId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addInstanceGroups(
    {abortSignal, ...params}: RequestConfig & AddInstanceGroupsInput,
  ): Promise<AddInstanceGroupsOutput> {
    const body: JSONObject = {...params,
    InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddInstanceGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "InstanceGroupIds": ["s"],
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async addJobFlowSteps(
    {abortSignal, ...params}: RequestConfig & AddJobFlowStepsInput,
  ): Promise<AddJobFlowStepsOutput> {
    const body: JSONObject = {...params,
    Steps: params["Steps"]?.map(x => fromStepConfig(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddJobFlowSteps",
    });
    return prt.readObj({
      required: {},
      optional: {
        "StepIds": ["s"],
      },
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async cancelSteps(
    {abortSignal, ...params}: RequestConfig & CancelStepsInput,
  ): Promise<CancelStepsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSteps",
    });
    return prt.readObj({
      required: {},
      optional: {
        "CancelStepsInfoList": [toCancelStepsInfo],
      },
    }, await resp.json());
  }

  async createSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateSecurityConfigurationInput,
  ): Promise<CreateSecurityConfigurationOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityConfiguration",
    });
    return prt.readObj({
      required: {
        "Name": "s",
        "CreationDateTime": "d",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteSecurityConfigurationInput,
  ): Promise<DeleteSecurityConfigurationOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeCluster(
    {abortSignal, ...params}: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCluster",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async describeJobFlows(
    {abortSignal, ...params}: RequestConfig & DescribeJobFlowsInput = {},
  ): Promise<DescribeJobFlowsOutput> {
    const body: JSONObject = {...params,
    CreatedAfter: prt.serializeDate_unixTimestamp(params["CreatedAfter"]),
    CreatedBefore: prt.serializeDate_unixTimestamp(params["CreatedBefore"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeJobFlows",
    });
    return prt.readObj({
      required: {},
      optional: {
        "JobFlows": [toJobFlowDetail],
      },
    }, await resp.json());
  }

  async describeNotebookExecution(
    {abortSignal, ...params}: RequestConfig & DescribeNotebookExecutionInput,
  ): Promise<DescribeNotebookExecutionOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookExecution",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NotebookExecution": toNotebookExecution,
      },
    }, await resp.json());
  }

  async describeSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & DescribeSecurityConfigurationInput,
  ): Promise<DescribeSecurityConfigurationOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSecurityConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Name": "s",
        "SecurityConfiguration": "s",
        "CreationDateTime": "d",
      },
    }, await resp.json());
  }

  async describeStep(
    {abortSignal, ...params}: RequestConfig & DescribeStepInput,
  ): Promise<DescribeStepOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeStep",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Step": toStep,
      },
    }, await resp.json());
  }

  async getBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & GetBlockPublicAccessConfigurationInput = {},
  ): Promise<GetBlockPublicAccessConfigurationOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetBlockPublicAccessConfiguration",
    });
    return prt.readObj({
      required: {
        "BlockPublicAccessConfiguration": toBlockPublicAccessConfiguration,
        "BlockPublicAccessConfigurationMetadata": toBlockPublicAccessConfigurationMetadata,
      },
      optional: {},
    }, await resp.json());
  }

  async getManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & GetManagedScalingPolicyInput,
  ): Promise<GetManagedScalingPolicyOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetManagedScalingPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ManagedScalingPolicy": toManagedScalingPolicy,
      },
    }, await resp.json());
  }

  async listBootstrapActions(
    {abortSignal, ...params}: RequestConfig & ListBootstrapActionsInput,
  ): Promise<ListBootstrapActionsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListBootstrapActions",
    });
    return prt.readObj({
      required: {},
      optional: {
        "BootstrapActions": [toCommand],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listClusters(
    {abortSignal, ...params}: RequestConfig & ListClustersInput = {},
  ): Promise<ListClustersOutput> {
    const body: JSONObject = {...params,
    CreatedAfter: prt.serializeDate_unixTimestamp(params["CreatedAfter"]),
    CreatedBefore: prt.serializeDate_unixTimestamp(params["CreatedBefore"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListClusters",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Clusters": [toClusterSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceFleets(
    {abortSignal, ...params}: RequestConfig & ListInstanceFleetsInput,
  ): Promise<ListInstanceFleetsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceFleets",
    });
    return prt.readObj({
      required: {},
      optional: {
        "InstanceFleets": [toInstanceFleet],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstanceGroups(
    {abortSignal, ...params}: RequestConfig & ListInstanceGroupsInput,
  ): Promise<ListInstanceGroupsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstanceGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "InstanceGroups": [toInstanceGroup],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listInstances(
    {abortSignal, ...params}: RequestConfig & ListInstancesInput,
  ): Promise<ListInstancesOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListInstances",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Instances": [toInstance],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listNotebookExecutions(
    {abortSignal, ...params}: RequestConfig & ListNotebookExecutionsInput = {},
  ): Promise<ListNotebookExecutionsOutput> {
    const body: JSONObject = {...params,
    From: prt.serializeDate_unixTimestamp(params["From"]),
    To: prt.serializeDate_unixTimestamp(params["To"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookExecutions",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NotebookExecutions": [toNotebookExecutionSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSecurityConfigurations(
    {abortSignal, ...params}: RequestConfig & ListSecurityConfigurationsInput = {},
  ): Promise<ListSecurityConfigurationsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSecurityConfigurations",
    });
    return prt.readObj({
      required: {},
      optional: {
        "SecurityConfigurations": [toSecurityConfigurationSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async listSteps(
    {abortSignal, ...params}: RequestConfig & ListStepsInput,
  ): Promise<ListStepsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSteps",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Steps": [toStepSummary],
        "Marker": "s",
      },
    }, await resp.json());
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & ModifyClusterInput,
  ): Promise<ModifyClusterOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    return prt.readObj({
      required: {},
      optional: {
        "StepConcurrencyLevel": "n",
      },
    }, await resp.json());
  }

  async modifyInstanceFleet(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceFleetInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
    InstanceFleet: fromInstanceFleetModifyConfig(params["InstanceFleet"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceFleet",
    });
  }

  async modifyInstanceGroups(
    {abortSignal, ...params}: RequestConfig & ModifyInstanceGroupsInput = {},
  ): Promise<void> {
    const body: JSONObject = {...params,
    InstanceGroups: params["InstanceGroups"]?.map(x => fromInstanceGroupModifyConfig(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyInstanceGroups",
    });
  }

  async putAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutAutoScalingPolicyInput,
  ): Promise<PutAutoScalingPolicyOutput> {
    const body: JSONObject = {...params,
    AutoScalingPolicy: fromAutoScalingPolicy(params["AutoScalingPolicy"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutAutoScalingPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ClusterId": "s",
        "InstanceGroupId": "s",
        "AutoScalingPolicy": toAutoScalingPolicyDescription,
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async putBlockPublicAccessConfiguration(
    {abortSignal, ...params}: RequestConfig & PutBlockPublicAccessConfigurationInput,
  ): Promise<PutBlockPublicAccessConfigurationOutput> {
    const body: JSONObject = {...params,
    BlockPublicAccessConfiguration: fromBlockPublicAccessConfiguration(params["BlockPublicAccessConfiguration"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutBlockPublicAccessConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & PutManagedScalingPolicyInput,
  ): Promise<PutManagedScalingPolicyOutput> {
    const body: JSONObject = {...params,
    ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutManagedScalingPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeAutoScalingPolicy(
    {abortSignal, ...params}: RequestConfig & RemoveAutoScalingPolicyInput,
  ): Promise<RemoveAutoScalingPolicyOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveAutoScalingPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeManagedScalingPolicy(
    {abortSignal, ...params}: RequestConfig & RemoveManagedScalingPolicyInput,
  ): Promise<RemoveManagedScalingPolicyOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveManagedScalingPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & RemoveTagsInput,
  ): Promise<RemoveTagsOutput> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async runJobFlow(
    {abortSignal, ...params}: RequestConfig & RunJobFlowInput,
  ): Promise<RunJobFlowOutput> {
    const body: JSONObject = {...params,
    Instances: fromJobFlowInstancesConfig(params["Instances"]),
    Steps: params["Steps"]?.map(x => fromStepConfig(x)),
    BootstrapActions: params["BootstrapActions"]?.map(x => fromBootstrapActionConfig(x)),
    NewSupportedProducts: params["NewSupportedProducts"]?.map(x => fromSupportedProductConfig(x)),
    Applications: params["Applications"]?.map(x => fromApplication(x)),
    Configurations: params["Configurations"]?.map(x => fromConfiguration(x)),
    Tags: params["Tags"]?.map(x => fromTag(x)),
    KerberosAttributes: fromKerberosAttributes(params["KerberosAttributes"]),
    ManagedScalingPolicy: fromManagedScalingPolicy(params["ManagedScalingPolicy"]),
    PlacementGroupConfigs: params["PlacementGroupConfigs"]?.map(x => fromPlacementGroupConfig(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RunJobFlow",
    });
    return prt.readObj({
      required: {},
      optional: {
        "JobFlowId": "s",
        "ClusterArn": "s",
      },
    }, await resp.json());
  }

  async setTerminationProtection(
    {abortSignal, ...params}: RequestConfig & SetTerminationProtectionInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTerminationProtection",
    });
  }

  async setVisibleToAllUsers(
    {abortSignal, ...params}: RequestConfig & SetVisibleToAllUsersInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetVisibleToAllUsers",
    });
  }

  async startNotebookExecution(
    {abortSignal, ...params}: RequestConfig & StartNotebookExecutionInput,
  ): Promise<StartNotebookExecutionOutput> {
    const body: JSONObject = {...params,
    ExecutionEngine: fromExecutionEngineConfig(params["ExecutionEngine"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNotebookExecution",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NotebookExecutionId": "s",
      },
    }, await resp.json());
  }

  async stopNotebookExecution(
    {abortSignal, ...params}: RequestConfig & StopNotebookExecutionInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopNotebookExecution",
    });
  }

  async terminateJobFlows(
    {abortSignal, ...params}: RequestConfig & TerminateJobFlowsInput,
  ): Promise<void> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateJobFlows",
    });
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterRunning(
    params: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterRunning';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp["Cluster"]?.["Status"]?.["State"];
      if (field === "RUNNING") return resp;
      if (field === "WAITING") return resp;
      if (field === "TERMINATING") throw new Error(errMessage);
      if (field === "TERMINATED") throw new Error(errMessage);
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForStepComplete(
    params: RequestConfig & DescribeStepInput,
  ): Promise<DescribeStepOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StepComplete';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeStep(params);
      const field = resp["Step"]?.["Status"]?.["State"];
      if (field === "COMPLETED") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      if (field === "CANCELLED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForClusterTerminated(
    params: RequestConfig & DescribeClusterInput,
  ): Promise<DescribeClusterOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ClusterTerminated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeCluster(params);
      const field = resp["Cluster"]?.["Status"]?.["State"];
      if (field === "TERMINATED") return resp;
      if (field === "TERMINATED_WITH_ERRORS") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddInstanceFleetInput {
  ClusterId: string;
  InstanceFleet: InstanceFleetConfig;
}

// refs: 1 - tags: named, input
export interface AddInstanceGroupsInput {
  InstanceGroups: InstanceGroupConfig[];
  JobFlowId: string;
}

// refs: 1 - tags: named, input
export interface AddJobFlowStepsInput {
  JobFlowId: string;
  Steps: StepConfig[];
}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  ResourceId: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface CancelStepsInput {
  ClusterId: string;
  StepIds: string[];
  StepCancellationOption?: StepCancellationOption | null;
}

// refs: 1 - tags: named, input
export interface CreateSecurityConfigurationInput {
  Name: string;
  SecurityConfiguration: string;
}

// refs: 1 - tags: named, input
export interface DeleteSecurityConfigurationInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeClusterInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface DescribeJobFlowsInput {
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  JobFlowIds?: string[] | null;
  JobFlowStates?: JobFlowExecutionState[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeNotebookExecutionInput {
  NotebookExecutionId: string;
}

// refs: 1 - tags: named, input
export interface DescribeSecurityConfigurationInput {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeStepInput {
  ClusterId: string;
  StepId: string;
}

// refs: 1 - tags: named, input
export interface GetBlockPublicAccessConfigurationInput {
}

// refs: 1 - tags: named, input
export interface GetManagedScalingPolicyInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface ListBootstrapActionsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListClustersInput {
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  ClusterStates?: ClusterState[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceFleetsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstanceGroupsInput {
  ClusterId: string;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInstancesInput {
  ClusterId: string;
  InstanceGroupId?: string | null;
  InstanceGroupTypes?: InstanceGroupType[] | null;
  InstanceFleetId?: string | null;
  InstanceFleetType?: InstanceFleetType | null;
  InstanceStates?: InstanceState[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListNotebookExecutionsInput {
  EditorId?: string | null;
  Status?: NotebookExecutionStatus | null;
  From?: Date | number | null;
  To?: Date | number | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSecurityConfigurationsInput {
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStepsInput {
  ClusterId: string;
  StepStates?: StepState[] | null;
  StepIds?: string[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ModifyClusterInput {
  ClusterId: string;
  StepConcurrencyLevel?: number | null;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceFleetInput {
  ClusterId: string;
  InstanceFleet: InstanceFleetModifyConfig;
}

// refs: 1 - tags: named, input
export interface ModifyInstanceGroupsInput {
  ClusterId?: string | null;
  InstanceGroups?: InstanceGroupModifyConfig[] | null;
}

// refs: 1 - tags: named, input
export interface PutAutoScalingPolicyInput {
  ClusterId: string;
  InstanceGroupId: string;
  AutoScalingPolicy: AutoScalingPolicy;
}

// refs: 1 - tags: named, input
export interface PutBlockPublicAccessConfigurationInput {
  BlockPublicAccessConfiguration: BlockPublicAccessConfiguration;
}

// refs: 1 - tags: named, input
export interface PutManagedScalingPolicyInput {
  ClusterId: string;
  ManagedScalingPolicy: ManagedScalingPolicy;
}

// refs: 1 - tags: named, input
export interface RemoveAutoScalingPolicyInput {
  ClusterId: string;
  InstanceGroupId: string;
}

// refs: 1 - tags: named, input
export interface RemoveManagedScalingPolicyInput {
  ClusterId: string;
}

// refs: 1 - tags: named, input
export interface RemoveTagsInput {
  ResourceId: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface RunJobFlowInput {
  Name: string;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  AdditionalInfo?: string | null;
  AmiVersion?: string | null;
  ReleaseLabel?: string | null;
  Instances: JobFlowInstancesConfig;
  Steps?: StepConfig[] | null;
  BootstrapActions?: BootstrapActionConfig[] | null;
  SupportedProducts?: string[] | null;
  NewSupportedProducts?: SupportedProductConfig[] | null;
  Applications?: Application[] | null;
  Configurations?: Configuration[] | null;
  VisibleToAllUsers?: boolean | null;
  JobFlowRole?: string | null;
  ServiceRole?: string | null;
  Tags?: Tag[] | null;
  SecurityConfiguration?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
  CustomAmiId?: string | null;
  EbsRootVolumeSize?: number | null;
  RepoUpgradeOnBoot?: RepoUpgradeOnBoot | null;
  KerberosAttributes?: KerberosAttributes | null;
  StepConcurrencyLevel?: number | null;
  ManagedScalingPolicy?: ManagedScalingPolicy | null;
  PlacementGroupConfigs?: PlacementGroupConfig[] | null;
}

// refs: 1 - tags: named, input
export interface SetTerminationProtectionInput {
  JobFlowIds: string[];
  TerminationProtected: boolean;
}

// refs: 1 - tags: named, input
export interface SetVisibleToAllUsersInput {
  JobFlowIds: string[];
  VisibleToAllUsers: boolean;
}

// refs: 1 - tags: named, input
export interface StartNotebookExecutionInput {
  EditorId: string;
  RelativePath: string;
  NotebookExecutionName?: string | null;
  NotebookParams?: string | null;
  ExecutionEngine: ExecutionEngineConfig;
  ServiceRole: string;
  NotebookInstanceSecurityGroupId?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface StopNotebookExecutionInput {
  NotebookExecutionId: string;
}

// refs: 1 - tags: named, input
export interface TerminateJobFlowsInput {
  JobFlowIds: string[];
}

// refs: 1 - tags: named, output
export interface AddInstanceFleetOutput {
  ClusterId?: string | null;
  InstanceFleetId?: string | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface AddInstanceGroupsOutput {
  JobFlowId?: string | null;
  InstanceGroupIds?: string[] | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface AddJobFlowStepsOutput {
  StepIds?: string[] | null;
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
}

// refs: 1 - tags: named, output
export interface CancelStepsOutput {
  CancelStepsInfoList?: CancelStepsInfo[] | null;
}

// refs: 1 - tags: named, output
export interface CreateSecurityConfigurationOutput {
  Name: string;
  CreationDateTime: Date | number;
}

// refs: 1 - tags: named, output
export interface DeleteSecurityConfigurationOutput {
}

// refs: 1 - tags: named, output
export interface DescribeClusterOutput {
  Cluster?: Cluster | null;
}

// refs: 1 - tags: named, output
export interface DescribeJobFlowsOutput {
  JobFlows?: JobFlowDetail[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeNotebookExecutionOutput {
  NotebookExecution?: NotebookExecution | null;
}

// refs: 1 - tags: named, output
export interface DescribeSecurityConfigurationOutput {
  Name?: string | null;
  SecurityConfiguration?: string | null;
  CreationDateTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeStepOutput {
  Step?: Step | null;
}

// refs: 1 - tags: named, output
export interface GetBlockPublicAccessConfigurationOutput {
  BlockPublicAccessConfiguration: BlockPublicAccessConfiguration;
  BlockPublicAccessConfigurationMetadata: BlockPublicAccessConfigurationMetadata;
}

// refs: 1 - tags: named, output
export interface GetManagedScalingPolicyOutput {
  ManagedScalingPolicy?: ManagedScalingPolicy | null;
}

// refs: 1 - tags: named, output
export interface ListBootstrapActionsOutput {
  BootstrapActions?: Command[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListClustersOutput {
  Clusters?: ClusterSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceFleetsOutput {
  InstanceFleets?: InstanceFleet[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstanceGroupsOutput {
  InstanceGroups?: InstanceGroup[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInstancesOutput {
  Instances?: Instance[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListNotebookExecutionsOutput {
  NotebookExecutions?: NotebookExecutionSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSecurityConfigurationsOutput {
  SecurityConfigurations?: SecurityConfigurationSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListStepsOutput {
  Steps?: StepSummary[] | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, output
export interface ModifyClusterOutput {
  StepConcurrencyLevel?: number | null;
}

// refs: 1 - tags: named, output
export interface PutAutoScalingPolicyOutput {
  ClusterId?: string | null;
  InstanceGroupId?: string | null;
  AutoScalingPolicy?: AutoScalingPolicyDescription | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface PutBlockPublicAccessConfigurationOutput {
}

// refs: 1 - tags: named, output
export interface PutManagedScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveAutoScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveManagedScalingPolicyOutput {
}

// refs: 1 - tags: named, output
export interface RemoveTagsOutput {
}

// refs: 1 - tags: named, output
export interface RunJobFlowOutput {
  JobFlowId?: string | null;
  ClusterArn?: string | null;
}

// refs: 1 - tags: named, output
export interface StartNotebookExecutionOutput {
  NotebookExecutionId?: string | null;
}

// refs: 2 - tags: input, named, interface
export interface InstanceFleetConfig {
  Name?: string | null;
  InstanceFleetType: InstanceFleetType;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
  InstanceTypeConfigs?: InstanceTypeConfig[] | null;
  LaunchSpecifications?: InstanceFleetProvisioningSpecifications | null;
}
function fromInstanceFleetConfig(input?: InstanceFleetConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    InstanceTypeConfigs: input["InstanceTypeConfigs"]?.map(x => fromInstanceTypeConfig(x)),
    LaunchSpecifications: fromInstanceFleetProvisioningSpecifications(input["LaunchSpecifications"]),
  }
}

// refs: 4 - tags: input, named, enum, output
export type InstanceFleetType =
| "MASTER"
| "CORE"
| "TASK"
;

function toInstanceFleetType(root: JSONValue): InstanceFleetType | null {
  return ( false
    || root == "MASTER"
    || root == "CORE"
    || root == "TASK"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface
export interface InstanceTypeConfig {
  InstanceType: string;
  WeightedCapacity?: number | null;
  BidPrice?: string | null;
  BidPriceAsPercentageOfOnDemandPrice?: number | null;
  EbsConfiguration?: EbsConfiguration | null;
  Configurations?: Configuration[] | null;
}
function fromInstanceTypeConfig(input?: InstanceTypeConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

// refs: 4 - tags: input, named, interface
export interface EbsConfiguration {
  EbsBlockDeviceConfigs?: EbsBlockDeviceConfig[] | null;
  EbsOptimized?: boolean | null;
}
function fromEbsConfiguration(input?: EbsConfiguration | null): JSONValue {
  if (!input) return input;
  return {...input,
    EbsBlockDeviceConfigs: input["EbsBlockDeviceConfigs"]?.map(x => fromEbsBlockDeviceConfig(x)),
  }
}

// refs: 4 - tags: input, named, interface
export interface EbsBlockDeviceConfig {
  VolumeSpecification: VolumeSpecification;
  VolumesPerInstance?: number | null;
}
function fromEbsBlockDeviceConfig(input?: EbsBlockDeviceConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    VolumeSpecification: fromVolumeSpecification(input["VolumeSpecification"]),
  }
}

// refs: 6 - tags: input, named, interface, output
export interface VolumeSpecification {
  VolumeType: string;
  Iops?: number | null;
  SizeInGB: number;
}
function fromVolumeSpecification(input?: VolumeSpecification | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toVolumeSpecification(root: JSONValue): VolumeSpecification {
  return prt.readObj({
    required: {
      "VolumeType": "s",
      "SizeInGB": "n",
    },
    optional: {
      "Iops": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, recursive, output
export interface Configuration {
  Classification?: string | null;
  Configurations?: Configuration[] | null;
  Properties?: { [key: string]: string } | null;
}
function fromConfiguration(input?: Configuration | null): JSONValue {
  if (!input) return input;
  return {...input,
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}
function toConfiguration(root: JSONValue): Configuration {
  return prt.readObj({
    required: {},
    optional: {
      "Classification": "s",
      "Configurations": [toConfiguration],
      "Properties": x => prt.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface InstanceFleetProvisioningSpecifications {
  SpotSpecification?: SpotProvisioningSpecification | null;
  OnDemandSpecification?: OnDemandProvisioningSpecification | null;
}
function fromInstanceFleetProvisioningSpecifications(input?: InstanceFleetProvisioningSpecifications | null): JSONValue {
  if (!input) return input;
  return {...input,
    SpotSpecification: fromSpotProvisioningSpecification(input["SpotSpecification"]),
    OnDemandSpecification: fromOnDemandProvisioningSpecification(input["OnDemandSpecification"]),
  }
}
function toInstanceFleetProvisioningSpecifications(root: JSONValue): InstanceFleetProvisioningSpecifications {
  return prt.readObj({
    required: {},
    optional: {
      "SpotSpecification": toSpotProvisioningSpecification,
      "OnDemandSpecification": toOnDemandProvisioningSpecification,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SpotProvisioningSpecification {
  TimeoutDurationMinutes: number;
  TimeoutAction: SpotProvisioningTimeoutAction;
  BlockDurationMinutes?: number | null;
  AllocationStrategy?: SpotProvisioningAllocationStrategy | null;
}
function fromSpotProvisioningSpecification(input?: SpotProvisioningSpecification | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSpotProvisioningSpecification(root: JSONValue): SpotProvisioningSpecification {
  return prt.readObj({
    required: {
      "TimeoutDurationMinutes": "n",
      "TimeoutAction": toSpotProvisioningTimeoutAction,
    },
    optional: {
      "BlockDurationMinutes": "n",
      "AllocationStrategy": toSpotProvisioningAllocationStrategy,
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type SpotProvisioningTimeoutAction =
| "SWITCH_TO_ON_DEMAND"
| "TERMINATE_CLUSTER"
;

function toSpotProvisioningTimeoutAction(root: JSONValue): SpotProvisioningTimeoutAction | null {
  return ( false
    || root == "SWITCH_TO_ON_DEMAND"
    || root == "TERMINATE_CLUSTER"
  ) ? root : null;
}

// refs: 3 - tags: input, named, enum, output
export type SpotProvisioningAllocationStrategy =
| "capacity-optimized"
;

function toSpotProvisioningAllocationStrategy(root: JSONValue): SpotProvisioningAllocationStrategy | null {
  return ( false
    || root == "capacity-optimized"
  ) ? root : null;
}

// refs: 3 - tags: input, named, interface, output
export interface OnDemandProvisioningSpecification {
  AllocationStrategy: OnDemandProvisioningAllocationStrategy;
}
function fromOnDemandProvisioningSpecification(input?: OnDemandProvisioningSpecification | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toOnDemandProvisioningSpecification(root: JSONValue): OnDemandProvisioningSpecification {
  return prt.readObj({
    required: {
      "AllocationStrategy": toOnDemandProvisioningAllocationStrategy,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type OnDemandProvisioningAllocationStrategy =
| "lowest-price"
;

function toOnDemandProvisioningAllocationStrategy(root: JSONValue): OnDemandProvisioningAllocationStrategy | null {
  return ( false
    || root == "lowest-price"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface
export interface InstanceGroupConfig {
  Name?: string | null;
  Market?: MarketType | null;
  InstanceRole: InstanceRoleType;
  BidPrice?: string | null;
  InstanceType: string;
  InstanceCount: number;
  Configurations?: Configuration[] | null;
  EbsConfiguration?: EbsConfiguration | null;
  AutoScalingPolicy?: AutoScalingPolicy | null;
}
function fromInstanceGroupConfig(input?: InstanceGroupConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
    EbsConfiguration: fromEbsConfiguration(input["EbsConfiguration"]),
    AutoScalingPolicy: fromAutoScalingPolicy(input["AutoScalingPolicy"]),
  }
}

// refs: 10 - tags: input, named, enum, output
export type MarketType =
| "ON_DEMAND"
| "SPOT"
;

function toMarketType(root: JSONValue): MarketType | null {
  return ( false
    || root == "ON_DEMAND"
    || root == "SPOT"
  ) ? root : null;
}

// refs: 5 - tags: input, named, enum, output
export type InstanceRoleType =
| "MASTER"
| "CORE"
| "TASK"
;

function toInstanceRoleType(root: JSONValue): InstanceRoleType | null {
  return ( false
    || root == "MASTER"
    || root == "CORE"
    || root == "TASK"
  ) ? root : null;
}

// refs: 3 - tags: input, named, interface
export interface AutoScalingPolicy {
  Constraints: ScalingConstraints;
  Rules: ScalingRule[];
}
function fromAutoScalingPolicy(input?: AutoScalingPolicy | null): JSONValue {
  if (!input) return input;
  return {...input,
    Constraints: fromScalingConstraints(input["Constraints"]),
    Rules: input["Rules"]?.map(x => fromScalingRule(x)),
  }
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingConstraints {
  MinCapacity: number;
  MaxCapacity: number;
}
function fromScalingConstraints(input?: ScalingConstraints | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toScalingConstraints(root: JSONValue): ScalingConstraints {
  return prt.readObj({
    required: {
      "MinCapacity": "n",
      "MaxCapacity": "n",
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingRule {
  Name: string;
  Description?: string | null;
  Action: ScalingAction;
  Trigger: ScalingTrigger;
}
function fromScalingRule(input?: ScalingRule | null): JSONValue {
  if (!input) return input;
  return {...input,
    Action: fromScalingAction(input["Action"]),
    Trigger: fromScalingTrigger(input["Trigger"]),
  }
}
function toScalingRule(root: JSONValue): ScalingRule {
  return prt.readObj({
    required: {
      "Name": "s",
      "Action": toScalingAction,
      "Trigger": toScalingTrigger,
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingAction {
  Market?: MarketType | null;
  SimpleScalingPolicyConfiguration: SimpleScalingPolicyConfiguration;
}
function fromScalingAction(input?: ScalingAction | null): JSONValue {
  if (!input) return input;
  return {...input,
    SimpleScalingPolicyConfiguration: fromSimpleScalingPolicyConfiguration(input["SimpleScalingPolicyConfiguration"]),
  }
}
function toScalingAction(root: JSONValue): ScalingAction {
  return prt.readObj({
    required: {
      "SimpleScalingPolicyConfiguration": toSimpleScalingPolicyConfiguration,
    },
    optional: {
      "Market": toMarketType,
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface SimpleScalingPolicyConfiguration {
  AdjustmentType?: AdjustmentType | null;
  ScalingAdjustment: number;
  CoolDown?: number | null;
}
function fromSimpleScalingPolicyConfiguration(input?: SimpleScalingPolicyConfiguration | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSimpleScalingPolicyConfiguration(root: JSONValue): SimpleScalingPolicyConfiguration {
  return prt.readObj({
    required: {
      "ScalingAdjustment": "n",
    },
    optional: {
      "AdjustmentType": toAdjustmentType,
      "CoolDown": "n",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type AdjustmentType =
| "CHANGE_IN_CAPACITY"
| "PERCENT_CHANGE_IN_CAPACITY"
| "EXACT_CAPACITY"
;

function toAdjustmentType(root: JSONValue): AdjustmentType | null {
  return ( false
    || root == "CHANGE_IN_CAPACITY"
    || root == "PERCENT_CHANGE_IN_CAPACITY"
    || root == "EXACT_CAPACITY"
  ) ? root : null;
}

// refs: 5 - tags: input, named, interface, output
export interface ScalingTrigger {
  CloudWatchAlarmDefinition: CloudWatchAlarmDefinition;
}
function fromScalingTrigger(input?: ScalingTrigger | null): JSONValue {
  if (!input) return input;
  return {...input,
    CloudWatchAlarmDefinition: fromCloudWatchAlarmDefinition(input["CloudWatchAlarmDefinition"]),
  }
}
function toScalingTrigger(root: JSONValue): ScalingTrigger {
  return prt.readObj({
    required: {
      "CloudWatchAlarmDefinition": toCloudWatchAlarmDefinition,
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface CloudWatchAlarmDefinition {
  ComparisonOperator: ComparisonOperator;
  EvaluationPeriods?: number | null;
  MetricName: string;
  Namespace?: string | null;
  Period: number;
  Statistic?: Statistic | null;
  Threshold: number;
  Unit?: Unit | null;
  Dimensions?: MetricDimension[] | null;
}
function fromCloudWatchAlarmDefinition(input?: CloudWatchAlarmDefinition | null): JSONValue {
  if (!input) return input;
  return {...input,
    Dimensions: input["Dimensions"]?.map(x => fromMetricDimension(x)),
  }
}
function toCloudWatchAlarmDefinition(root: JSONValue): CloudWatchAlarmDefinition {
  return prt.readObj({
    required: {
      "ComparisonOperator": toComparisonOperator,
      "MetricName": "s",
      "Period": "n",
      "Threshold": "n",
    },
    optional: {
      "EvaluationPeriods": "n",
      "Namespace": "s",
      "Statistic": toStatistic,
      "Unit": toUnit,
      "Dimensions": [toMetricDimension],
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type ComparisonOperator =
| "GREATER_THAN_OR_EQUAL"
| "GREATER_THAN"
| "LESS_THAN"
| "LESS_THAN_OR_EQUAL"
;

function toComparisonOperator(root: JSONValue): ComparisonOperator | null {
  return ( false
    || root == "GREATER_THAN_OR_EQUAL"
    || root == "GREATER_THAN"
    || root == "LESS_THAN"
    || root == "LESS_THAN_OR_EQUAL"
  ) ? root : null;
}

// refs: 5 - tags: input, named, enum, output
export type Statistic =
| "SAMPLE_COUNT"
| "AVERAGE"
| "SUM"
| "MINIMUM"
| "MAXIMUM"
;

function toStatistic(root: JSONValue): Statistic | null {
  return ( false
    || root == "SAMPLE_COUNT"
    || root == "AVERAGE"
    || root == "SUM"
    || root == "MINIMUM"
    || root == "MAXIMUM"
  ) ? root : null;
}

// refs: 5 - tags: input, named, enum, output
export type Unit =
| "NONE"
| "SECONDS"
| "MICRO_SECONDS"
| "MILLI_SECONDS"
| "BYTES"
| "KILO_BYTES"
| "MEGA_BYTES"
| "GIGA_BYTES"
| "TERA_BYTES"
| "BITS"
| "KILO_BITS"
| "MEGA_BITS"
| "GIGA_BITS"
| "TERA_BITS"
| "PERCENT"
| "COUNT"
| "BYTES_PER_SECOND"
| "KILO_BYTES_PER_SECOND"
| "MEGA_BYTES_PER_SECOND"
| "GIGA_BYTES_PER_SECOND"
| "TERA_BYTES_PER_SECOND"
| "BITS_PER_SECOND"
| "KILO_BITS_PER_SECOND"
| "MEGA_BITS_PER_SECOND"
| "GIGA_BITS_PER_SECOND"
| "TERA_BITS_PER_SECOND"
| "COUNT_PER_SECOND"
;

function toUnit(root: JSONValue): Unit | null {
  return ( false
    || root == "NONE"
    || root == "SECONDS"
    || root == "MICRO_SECONDS"
    || root == "MILLI_SECONDS"
    || root == "BYTES"
    || root == "KILO_BYTES"
    || root == "MEGA_BYTES"
    || root == "GIGA_BYTES"
    || root == "TERA_BYTES"
    || root == "BITS"
    || root == "KILO_BITS"
    || root == "MEGA_BITS"
    || root == "GIGA_BITS"
    || root == "TERA_BITS"
    || root == "PERCENT"
    || root == "COUNT"
    || root == "BYTES_PER_SECOND"
    || root == "KILO_BYTES_PER_SECOND"
    || root == "MEGA_BYTES_PER_SECOND"
    || root == "GIGA_BYTES_PER_SECOND"
    || root == "TERA_BYTES_PER_SECOND"
    || root == "BITS_PER_SECOND"
    || root == "KILO_BITS_PER_SECOND"
    || root == "MEGA_BITS_PER_SECOND"
    || root == "GIGA_BITS_PER_SECOND"
    || root == "TERA_BITS_PER_SECOND"
    || root == "COUNT_PER_SECOND"
  ) ? root : null;
}

// refs: 5 - tags: input, named, interface, output
export interface MetricDimension {
  Key?: string | null;
  Value?: string | null;
}
function fromMetricDimension(input?: MetricDimension | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toMetricDimension(root: JSONValue): MetricDimension {
  return prt.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface StepConfig {
  Name: string;
  ActionOnFailure?: ActionOnFailure | null;
  HadoopJarStep: HadoopJarStepConfig;
}
function fromStepConfig(input?: StepConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    HadoopJarStep: fromHadoopJarStepConfig(input["HadoopJarStep"]),
  }
}
function toStepConfig(root: JSONValue): StepConfig {
  return prt.readObj({
    required: {
      "Name": "s",
      "HadoopJarStep": toHadoopJarStepConfig,
    },
    optional: {
      "ActionOnFailure": toActionOnFailure,
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type ActionOnFailure =
| "TERMINATE_JOB_FLOW"
| "TERMINATE_CLUSTER"
| "CANCEL_AND_WAIT"
| "CONTINUE"
;

function toActionOnFailure(root: JSONValue): ActionOnFailure | null {
  return ( false
    || root == "TERMINATE_JOB_FLOW"
    || root == "TERMINATE_CLUSTER"
    || root == "CANCEL_AND_WAIT"
    || root == "CONTINUE"
  ) ? root : null;
}

// refs: 3 - tags: input, named, interface, output
export interface HadoopJarStepConfig {
  Properties?: KeyValue[] | null;
  Jar: string;
  MainClass?: string | null;
  Args?: string[] | null;
}
function fromHadoopJarStepConfig(input?: HadoopJarStepConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    Properties: input["Properties"]?.map(x => fromKeyValue(x)),
  }
}
function toHadoopJarStepConfig(root: JSONValue): HadoopJarStepConfig {
  return prt.readObj({
    required: {
      "Jar": "s",
    },
    optional: {
      "Properties": [toKeyValue],
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface KeyValue {
  Key?: string | null;
  Value?: string | null;
}
function fromKeyValue(input?: KeyValue | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toKeyValue(root: JSONValue): KeyValue {
  return prt.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function fromTag(input?: Tag | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTag(root: JSONValue): Tag {
  return prt.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type StepCancellationOption =
| "SEND_INTERRUPT"
| "TERMINATE_PROCESS"
;


// refs: 2 - tags: input, named, enum, output
export type JobFlowExecutionState =
| "STARTING"
| "BOOTSTRAPPING"
| "RUNNING"
| "WAITING"
| "SHUTTING_DOWN"
| "TERMINATED"
| "COMPLETED"
| "FAILED"
;

function toJobFlowExecutionState(root: JSONValue): JobFlowExecutionState | null {
  return ( false
    || root == "STARTING"
    || root == "BOOTSTRAPPING"
    || root == "RUNNING"
    || root == "WAITING"
    || root == "SHUTTING_DOWN"
    || root == "TERMINATED"
    || root == "COMPLETED"
    || root == "FAILED"
  ) ? root : null;
}

// refs: 3 - tags: input, named, enum, output
export type ClusterState =
| "STARTING"
| "BOOTSTRAPPING"
| "RUNNING"
| "WAITING"
| "TERMINATING"
| "TERMINATED"
| "TERMINATED_WITH_ERRORS"
;

function toClusterState(root: JSONValue): ClusterState | null {
  return ( false
    || root == "STARTING"
    || root == "BOOTSTRAPPING"
    || root == "RUNNING"
    || root == "WAITING"
    || root == "TERMINATING"
    || root == "TERMINATED"
    || root == "TERMINATED_WITH_ERRORS"
  ) ? root : null;
}

// refs: 2 - tags: input, named, enum, output
export type InstanceGroupType =
| "MASTER"
| "CORE"
| "TASK"
;

function toInstanceGroupType(root: JSONValue): InstanceGroupType | null {
  return ( false
    || root == "MASTER"
    || root == "CORE"
    || root == "TASK"
  ) ? root : null;
}

// refs: 2 - tags: input, named, enum, output
export type InstanceState =
| "AWAITING_FULFILLMENT"
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "TERMINATED"
;

function toInstanceState(root: JSONValue): InstanceState | null {
  return ( false
    || root == "AWAITING_FULFILLMENT"
    || root == "PROVISIONING"
    || root == "BOOTSTRAPPING"
    || root == "RUNNING"
    || root == "TERMINATED"
  ) ? root : null;
}

// refs: 3 - tags: input, named, enum, output
export type NotebookExecutionStatus =
| "START_PENDING"
| "STARTING"
| "RUNNING"
| "FINISHING"
| "FINISHED"
| "FAILING"
| "FAILED"
| "STOP_PENDING"
| "STOPPING"
| "STOPPED"
;

function toNotebookExecutionStatus(root: JSONValue): NotebookExecutionStatus | null {
  return ( false
    || root == "START_PENDING"
    || root == "STARTING"
    || root == "RUNNING"
    || root == "FINISHING"
    || root == "FINISHED"
    || root == "FAILING"
    || root == "FAILED"
    || root == "STOP_PENDING"
    || root == "STOPPING"
    || root == "STOPPED"
  ) ? root : null;
}

// refs: 3 - tags: input, named, enum, output
export type StepState =
| "PENDING"
| "CANCEL_PENDING"
| "RUNNING"
| "COMPLETED"
| "CANCELLED"
| "FAILED"
| "INTERRUPTED"
;

function toStepState(root: JSONValue): StepState | null {
  return ( false
    || root == "PENDING"
    || root == "CANCEL_PENDING"
    || root == "RUNNING"
    || root == "COMPLETED"
    || root == "CANCELLED"
    || root == "FAILED"
    || root == "INTERRUPTED"
  ) ? root : null;
}

// refs: 1 - tags: input, named, interface
export interface InstanceFleetModifyConfig {
  InstanceFleetId: string;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
}
function fromInstanceFleetModifyConfig(input?: InstanceFleetModifyConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}

// refs: 1 - tags: input, named, interface
export interface InstanceGroupModifyConfig {
  InstanceGroupId: string;
  InstanceCount?: number | null;
  EC2InstanceIdsToTerminate?: string[] | null;
  ShrinkPolicy?: ShrinkPolicy | null;
  Configurations?: Configuration[] | null;
}
function fromInstanceGroupModifyConfig(input?: InstanceGroupModifyConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    ShrinkPolicy: fromShrinkPolicy(input["ShrinkPolicy"]),
    Configurations: input["Configurations"]?.map(x => fromConfiguration(x)),
  }
}

// refs: 2 - tags: input, named, interface, output
export interface ShrinkPolicy {
  DecommissionTimeout?: number | null;
  InstanceResizePolicy?: InstanceResizePolicy | null;
}
function fromShrinkPolicy(input?: ShrinkPolicy | null): JSONValue {
  if (!input) return input;
  return {...input,
    InstanceResizePolicy: fromInstanceResizePolicy(input["InstanceResizePolicy"]),
  }
}
function toShrinkPolicy(root: JSONValue): ShrinkPolicy {
  return prt.readObj({
    required: {},
    optional: {
      "DecommissionTimeout": "n",
      "InstanceResizePolicy": toInstanceResizePolicy,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface InstanceResizePolicy {
  InstancesToTerminate?: string[] | null;
  InstancesToProtect?: string[] | null;
  InstanceTerminationTimeout?: number | null;
}
function fromInstanceResizePolicy(input?: InstanceResizePolicy | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toInstanceResizePolicy(root: JSONValue): InstanceResizePolicy {
  return prt.readObj({
    required: {},
    optional: {
      "InstancesToTerminate": ["s"],
      "InstancesToProtect": ["s"],
      "InstanceTerminationTimeout": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BlockPublicAccessConfiguration {
  BlockPublicSecurityGroupRules: boolean;
  PermittedPublicSecurityGroupRuleRanges?: PortRange[] | null;
}
function fromBlockPublicAccessConfiguration(input?: BlockPublicAccessConfiguration | null): JSONValue {
  if (!input) return input;
  return {...input,
    PermittedPublicSecurityGroupRuleRanges: input["PermittedPublicSecurityGroupRuleRanges"]?.map(x => fromPortRange(x)),
  }
}
function toBlockPublicAccessConfiguration(root: JSONValue): BlockPublicAccessConfiguration {
  return prt.readObj({
    required: {
      "BlockPublicSecurityGroupRules": "b",
    },
    optional: {
      "PermittedPublicSecurityGroupRuleRanges": [toPortRange],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PortRange {
  MinRange: number;
  MaxRange?: number | null;
}
function fromPortRange(input?: PortRange | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toPortRange(root: JSONValue): PortRange {
  return prt.readObj({
    required: {
      "MinRange": "n",
    },
    optional: {
      "MaxRange": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ManagedScalingPolicy {
  ComputeLimits?: ComputeLimits | null;
}
function fromManagedScalingPolicy(input?: ManagedScalingPolicy | null): JSONValue {
  if (!input) return input;
  return {...input,
    ComputeLimits: fromComputeLimits(input["ComputeLimits"]),
  }
}
function toManagedScalingPolicy(root: JSONValue): ManagedScalingPolicy {
  return prt.readObj({
    required: {},
    optional: {
      "ComputeLimits": toComputeLimits,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ComputeLimits {
  UnitType: ComputeLimitsUnitType;
  MinimumCapacityUnits: number;
  MaximumCapacityUnits: number;
  MaximumOnDemandCapacityUnits?: number | null;
  MaximumCoreCapacityUnits?: number | null;
}
function fromComputeLimits(input?: ComputeLimits | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toComputeLimits(root: JSONValue): ComputeLimits {
  return prt.readObj({
    required: {
      "UnitType": toComputeLimitsUnitType,
      "MinimumCapacityUnits": "n",
      "MaximumCapacityUnits": "n",
    },
    optional: {
      "MaximumOnDemandCapacityUnits": "n",
      "MaximumCoreCapacityUnits": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ComputeLimitsUnitType =
| "InstanceFleetUnits"
| "Instances"
| "VCPU"
;

function toComputeLimitsUnitType(root: JSONValue): ComputeLimitsUnitType | null {
  return ( false
    || root == "InstanceFleetUnits"
    || root == "Instances"
    || root == "VCPU"
  ) ? root : null;
}

// refs: 1 - tags: input, named, interface
export interface JobFlowInstancesConfig {
  MasterInstanceType?: string | null;
  SlaveInstanceType?: string | null;
  InstanceCount?: number | null;
  InstanceGroups?: InstanceGroupConfig[] | null;
  InstanceFleets?: InstanceFleetConfig[] | null;
  Ec2KeyName?: string | null;
  Placement?: PlacementType | null;
  KeepJobFlowAliveWhenNoSteps?: boolean | null;
  TerminationProtected?: boolean | null;
  HadoopVersion?: string | null;
  Ec2SubnetId?: string | null;
  Ec2SubnetIds?: string[] | null;
  EmrManagedMasterSecurityGroup?: string | null;
  EmrManagedSlaveSecurityGroup?: string | null;
  ServiceAccessSecurityGroup?: string | null;
  AdditionalMasterSecurityGroups?: string[] | null;
  AdditionalSlaveSecurityGroups?: string[] | null;
}
function fromJobFlowInstancesConfig(input?: JobFlowInstancesConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    InstanceGroups: input["InstanceGroups"]?.map(x => fromInstanceGroupConfig(x)),
    InstanceFleets: input["InstanceFleets"]?.map(x => fromInstanceFleetConfig(x)),
    Placement: fromPlacementType(input["Placement"]),
  }
}

// refs: 2 - tags: input, named, interface, output
export interface PlacementType {
  AvailabilityZone?: string | null;
  AvailabilityZones?: string[] | null;
}
function fromPlacementType(input?: PlacementType | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toPlacementType(root: JSONValue): PlacementType {
  return prt.readObj({
    required: {},
    optional: {
      "AvailabilityZone": "s",
      "AvailabilityZones": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface BootstrapActionConfig {
  Name: string;
  ScriptBootstrapAction: ScriptBootstrapActionConfig;
}
function fromBootstrapActionConfig(input?: BootstrapActionConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
    ScriptBootstrapAction: fromScriptBootstrapActionConfig(input["ScriptBootstrapAction"]),
  }
}
function toBootstrapActionConfig(root: JSONValue): BootstrapActionConfig {
  return prt.readObj({
    required: {
      "Name": "s",
      "ScriptBootstrapAction": toScriptBootstrapActionConfig,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ScriptBootstrapActionConfig {
  Path: string;
  Args?: string[] | null;
}
function fromScriptBootstrapActionConfig(input?: ScriptBootstrapActionConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toScriptBootstrapActionConfig(root: JSONValue): ScriptBootstrapActionConfig {
  return prt.readObj({
    required: {
      "Path": "s",
    },
    optional: {
      "Args": ["s"],
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface SupportedProductConfig {
  Name?: string | null;
  Args?: string[] | null;
}
function fromSupportedProductConfig(input?: SupportedProductConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}

// refs: 2 - tags: input, named, interface, output
export interface Application {
  Name?: string | null;
  Version?: string | null;
  Args?: string[] | null;
  AdditionalInfo?: { [key: string]: string } | null;
}
function fromApplication(input?: Application | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toApplication(root: JSONValue): Application {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
      "Args": ["s"],
      "AdditionalInfo": x => prt.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ScaleDownBehavior =
| "TERMINATE_AT_INSTANCE_HOUR"
| "TERMINATE_AT_TASK_COMPLETION"
;

function toScaleDownBehavior(root: JSONValue): ScaleDownBehavior | null {
  return ( false
    || root == "TERMINATE_AT_INSTANCE_HOUR"
    || root == "TERMINATE_AT_TASK_COMPLETION"
  ) ? root : null;
}

// refs: 2 - tags: input, named, enum, output
export type RepoUpgradeOnBoot =
| "SECURITY"
| "NONE"
;

function toRepoUpgradeOnBoot(root: JSONValue): RepoUpgradeOnBoot | null {
  return ( false
    || root == "SECURITY"
    || root == "NONE"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface, output
export interface KerberosAttributes {
  Realm: string;
  KdcAdminPassword: string;
  CrossRealmTrustPrincipalPassword?: string | null;
  ADDomainJoinUser?: string | null;
  ADDomainJoinPassword?: string | null;
}
function fromKerberosAttributes(input?: KerberosAttributes | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toKerberosAttributes(root: JSONValue): KerberosAttributes {
  return prt.readObj({
    required: {
      "Realm": "s",
      "KdcAdminPassword": "s",
    },
    optional: {
      "CrossRealmTrustPrincipalPassword": "s",
      "ADDomainJoinUser": "s",
      "ADDomainJoinPassword": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface PlacementGroupConfig {
  InstanceRole: InstanceRoleType;
  PlacementStrategy?: PlacementGroupStrategy | null;
}
function fromPlacementGroupConfig(input?: PlacementGroupConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toPlacementGroupConfig(root: JSONValue): PlacementGroupConfig {
  return prt.readObj({
    required: {
      "InstanceRole": toInstanceRoleType,
    },
    optional: {
      "PlacementStrategy": toPlacementGroupStrategy,
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type PlacementGroupStrategy =
| "SPREAD"
| "PARTITION"
| "CLUSTER"
| "NONE"
;

function toPlacementGroupStrategy(root: JSONValue): PlacementGroupStrategy | null {
  return ( false
    || root == "SPREAD"
    || root == "PARTITION"
    || root == "CLUSTER"
    || root == "NONE"
  ) ? root : null;
}

// refs: 2 - tags: input, named, interface, output
export interface ExecutionEngineConfig {
  Id: string;
  Type?: ExecutionEngineType | null;
  MasterInstanceSecurityGroupId?: string | null;
}
function fromExecutionEngineConfig(input?: ExecutionEngineConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toExecutionEngineConfig(root: JSONValue): ExecutionEngineConfig {
  return prt.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "Type": toExecutionEngineType,
      "MasterInstanceSecurityGroupId": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ExecutionEngineType =
| "EMR"
;

function toExecutionEngineType(root: JSONValue): ExecutionEngineType | null {
  return ( false
    || root == "EMR"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface CancelStepsInfo {
  StepId?: string | null;
  Status?: CancelStepsRequestStatus | null;
  Reason?: string | null;
}
function toCancelStepsInfo(root: JSONValue): CancelStepsInfo {
  return prt.readObj({
    required: {},
    optional: {
      "StepId": "s",
      "Status": toCancelStepsRequestStatus,
      "Reason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type CancelStepsRequestStatus =
| "SUBMITTED"
| "FAILED"
;
function toCancelStepsRequestStatus(root: JSONValue): CancelStepsRequestStatus | null {
  return ( false
    || root == "SUBMITTED"
    || root == "FAILED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface Cluster {
  Id?: string | null;
  Name?: string | null;
  Status?: ClusterStatus | null;
  Ec2InstanceAttributes?: Ec2InstanceAttributes | null;
  InstanceCollectionType?: InstanceCollectionType | null;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  RequestedAmiVersion?: string | null;
  RunningAmiVersion?: string | null;
  ReleaseLabel?: string | null;
  AutoTerminate?: boolean | null;
  TerminationProtected?: boolean | null;
  VisibleToAllUsers?: boolean | null;
  Applications?: Application[] | null;
  Tags?: Tag[] | null;
  ServiceRole?: string | null;
  NormalizedInstanceHours?: number | null;
  MasterPublicDnsName?: string | null;
  Configurations?: Configuration[] | null;
  SecurityConfiguration?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
  CustomAmiId?: string | null;
  EbsRootVolumeSize?: number | null;
  RepoUpgradeOnBoot?: RepoUpgradeOnBoot | null;
  KerberosAttributes?: KerberosAttributes | null;
  ClusterArn?: string | null;
  OutpostArn?: string | null;
  StepConcurrencyLevel?: number | null;
  PlacementGroups?: PlacementGroupConfig[] | null;
}
function toCluster(root: JSONValue): Cluster {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "Ec2InstanceAttributes": toEc2InstanceAttributes,
      "InstanceCollectionType": toInstanceCollectionType,
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "RequestedAmiVersion": "s",
      "RunningAmiVersion": "s",
      "ReleaseLabel": "s",
      "AutoTerminate": "b",
      "TerminationProtected": "b",
      "VisibleToAllUsers": "b",
      "Applications": [toApplication],
      "Tags": [toTag],
      "ServiceRole": "s",
      "NormalizedInstanceHours": "n",
      "MasterPublicDnsName": "s",
      "Configurations": [toConfiguration],
      "SecurityConfiguration": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": toScaleDownBehavior,
      "CustomAmiId": "s",
      "EbsRootVolumeSize": "n",
      "RepoUpgradeOnBoot": toRepoUpgradeOnBoot,
      "KerberosAttributes": toKerberosAttributes,
      "ClusterArn": "s",
      "OutpostArn": "s",
      "StepConcurrencyLevel": "n",
      "PlacementGroups": [toPlacementGroupConfig],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterStatus {
  State?: ClusterState | null;
  StateChangeReason?: ClusterStateChangeReason | null;
  Timeline?: ClusterTimeline | null;
}
function toClusterStatus(root: JSONValue): ClusterStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toClusterState,
      "StateChangeReason": toClusterStateChangeReason,
      "Timeline": toClusterTimeline,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ClusterStateChangeReason {
  Code?: ClusterStateChangeReasonCode | null;
  Message?: string | null;
}
function toClusterStateChangeReason(root: JSONValue): ClusterStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toClusterStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ClusterStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "INSTANCE_FLEET_TIMEOUT"
| "BOOTSTRAP_FAILURE"
| "USER_REQUEST"
| "STEP_FAILURE"
| "ALL_STEPS_COMPLETED"
;
function toClusterStateChangeReasonCode(root: JSONValue): ClusterStateChangeReasonCode | null {
  return ( false
    || root == "INTERNAL_ERROR"
    || root == "VALIDATION_ERROR"
    || root == "INSTANCE_FAILURE"
    || root == "INSTANCE_FLEET_TIMEOUT"
    || root == "BOOTSTRAP_FAILURE"
    || root == "USER_REQUEST"
    || root == "STEP_FAILURE"
    || root == "ALL_STEPS_COMPLETED"
  ) ? root : null;
}

// refs: 2 - tags: output, named, interface
export interface ClusterTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toClusterTimeline(root: JSONValue): ClusterTimeline {
  return prt.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Ec2InstanceAttributes {
  Ec2KeyName?: string | null;
  Ec2SubnetId?: string | null;
  RequestedEc2SubnetIds?: string[] | null;
  Ec2AvailabilityZone?: string | null;
  RequestedEc2AvailabilityZones?: string[] | null;
  IamInstanceProfile?: string | null;
  EmrManagedMasterSecurityGroup?: string | null;
  EmrManagedSlaveSecurityGroup?: string | null;
  ServiceAccessSecurityGroup?: string | null;
  AdditionalMasterSecurityGroups?: string[] | null;
  AdditionalSlaveSecurityGroups?: string[] | null;
}
function toEc2InstanceAttributes(root: JSONValue): Ec2InstanceAttributes {
  return prt.readObj({
    required: {},
    optional: {
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "RequestedEc2SubnetIds": ["s"],
      "Ec2AvailabilityZone": "s",
      "RequestedEc2AvailabilityZones": ["s"],
      "IamInstanceProfile": "s",
      "EmrManagedMasterSecurityGroup": "s",
      "EmrManagedSlaveSecurityGroup": "s",
      "ServiceAccessSecurityGroup": "s",
      "AdditionalMasterSecurityGroups": ["s"],
      "AdditionalSlaveSecurityGroups": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceCollectionType =
| "INSTANCE_FLEET"
| "INSTANCE_GROUP"
;
function toInstanceCollectionType(root: JSONValue): InstanceCollectionType | null {
  return ( false
    || root == "INSTANCE_FLEET"
    || root == "INSTANCE_GROUP"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface JobFlowDetail {
  JobFlowId: string;
  Name: string;
  LogUri?: string | null;
  LogEncryptionKmsKeyId?: string | null;
  AmiVersion?: string | null;
  ExecutionStatusDetail: JobFlowExecutionStatusDetail;
  Instances: JobFlowInstancesDetail;
  Steps?: StepDetail[] | null;
  BootstrapActions?: BootstrapActionDetail[] | null;
  SupportedProducts?: string[] | null;
  VisibleToAllUsers?: boolean | null;
  JobFlowRole?: string | null;
  ServiceRole?: string | null;
  AutoScalingRole?: string | null;
  ScaleDownBehavior?: ScaleDownBehavior | null;
}
function toJobFlowDetail(root: JSONValue): JobFlowDetail {
  return prt.readObj({
    required: {
      "JobFlowId": "s",
      "Name": "s",
      "ExecutionStatusDetail": toJobFlowExecutionStatusDetail,
      "Instances": toJobFlowInstancesDetail,
    },
    optional: {
      "LogUri": "s",
      "LogEncryptionKmsKeyId": "s",
      "AmiVersion": "s",
      "Steps": [toStepDetail],
      "BootstrapActions": [toBootstrapActionDetail],
      "SupportedProducts": ["s"],
      "VisibleToAllUsers": "b",
      "JobFlowRole": "s",
      "ServiceRole": "s",
      "AutoScalingRole": "s",
      "ScaleDownBehavior": toScaleDownBehavior,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobFlowExecutionStatusDetail {
  State: JobFlowExecutionState;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
  LastStateChangeReason?: string | null;
}
function toJobFlowExecutionStatusDetail(root: JSONValue): JobFlowExecutionStatusDetail {
  return prt.readObj({
    required: {
      "State": toJobFlowExecutionState,
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface JobFlowInstancesDetail {
  MasterInstanceType: string;
  MasterPublicDnsName?: string | null;
  MasterInstanceId?: string | null;
  SlaveInstanceType: string;
  InstanceCount: number;
  InstanceGroups?: InstanceGroupDetail[] | null;
  NormalizedInstanceHours?: number | null;
  Ec2KeyName?: string | null;
  Ec2SubnetId?: string | null;
  Placement?: PlacementType | null;
  KeepJobFlowAliveWhenNoSteps?: boolean | null;
  TerminationProtected?: boolean | null;
  HadoopVersion?: string | null;
}
function toJobFlowInstancesDetail(root: JSONValue): JobFlowInstancesDetail {
  return prt.readObj({
    required: {
      "MasterInstanceType": "s",
      "SlaveInstanceType": "s",
      "InstanceCount": "n",
    },
    optional: {
      "MasterPublicDnsName": "s",
      "MasterInstanceId": "s",
      "InstanceGroups": [toInstanceGroupDetail],
      "NormalizedInstanceHours": "n",
      "Ec2KeyName": "s",
      "Ec2SubnetId": "s",
      "Placement": toPlacementType,
      "KeepJobFlowAliveWhenNoSteps": "b",
      "TerminationProtected": "b",
      "HadoopVersion": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupDetail {
  InstanceGroupId?: string | null;
  Name?: string | null;
  Market: MarketType;
  InstanceRole: InstanceRoleType;
  BidPrice?: string | null;
  InstanceType: string;
  InstanceRequestCount: number;
  InstanceRunningCount: number;
  State: InstanceGroupState;
  LastStateChangeReason?: string | null;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceGroupDetail(root: JSONValue): InstanceGroupDetail {
  return prt.readObj({
    required: {
      "Market": toMarketType,
      "InstanceRole": toInstanceRoleType,
      "InstanceType": "s",
      "InstanceRequestCount": "n",
      "InstanceRunningCount": "n",
      "State": toInstanceGroupState,
      "CreationDateTime": "d",
    },
    optional: {
      "InstanceGroupId": "s",
      "Name": "s",
      "BidPrice": "s",
      "LastStateChangeReason": "s",
      "StartDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type InstanceGroupState =
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "RECONFIGURING"
| "RESIZING"
| "SUSPENDED"
| "TERMINATING"
| "TERMINATED"
| "ARRESTED"
| "SHUTTING_DOWN"
| "ENDED"
;
function toInstanceGroupState(root: JSONValue): InstanceGroupState | null {
  return ( false
    || root == "PROVISIONING"
    || root == "BOOTSTRAPPING"
    || root == "RUNNING"
    || root == "RECONFIGURING"
    || root == "RESIZING"
    || root == "SUSPENDED"
    || root == "TERMINATING"
    || root == "TERMINATED"
    || root == "ARRESTED"
    || root == "SHUTTING_DOWN"
    || root == "ENDED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface StepDetail {
  StepConfig: StepConfig;
  ExecutionStatusDetail: StepExecutionStatusDetail;
}
function toStepDetail(root: JSONValue): StepDetail {
  return prt.readObj({
    required: {
      "StepConfig": toStepConfig,
      "ExecutionStatusDetail": toStepExecutionStatusDetail,
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StepExecutionStatusDetail {
  State: StepExecutionState;
  CreationDateTime: Date | number;
  StartDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
  LastStateChangeReason?: string | null;
}
function toStepExecutionStatusDetail(root: JSONValue): StepExecutionStatusDetail {
  return prt.readObj({
    required: {
      "State": toStepExecutionState,
      "CreationDateTime": "d",
    },
    optional: {
      "StartDateTime": "d",
      "EndDateTime": "d",
      "LastStateChangeReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type StepExecutionState =
| "PENDING"
| "RUNNING"
| "CONTINUE"
| "COMPLETED"
| "CANCELLED"
| "FAILED"
| "INTERRUPTED"
;
function toStepExecutionState(root: JSONValue): StepExecutionState | null {
  return ( false
    || root == "PENDING"
    || root == "RUNNING"
    || root == "CONTINUE"
    || root == "COMPLETED"
    || root == "CANCELLED"
    || root == "FAILED"
    || root == "INTERRUPTED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface BootstrapActionDetail {
  BootstrapActionConfig?: BootstrapActionConfig | null;
}
function toBootstrapActionDetail(root: JSONValue): BootstrapActionDetail {
  return prt.readObj({
    required: {},
    optional: {
      "BootstrapActionConfig": toBootstrapActionConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookExecution {
  NotebookExecutionId?: string | null;
  EditorId?: string | null;
  ExecutionEngine?: ExecutionEngineConfig | null;
  NotebookExecutionName?: string | null;
  NotebookParams?: string | null;
  Status?: NotebookExecutionStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Arn?: string | null;
  OutputNotebookURI?: string | null;
  LastStateChangeReason?: string | null;
  NotebookInstanceSecurityGroupId?: string | null;
  Tags?: Tag[] | null;
}
function toNotebookExecution(root: JSONValue): NotebookExecution {
  return prt.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "ExecutionEngine": toExecutionEngineConfig,
      "NotebookExecutionName": "s",
      "NotebookParams": "s",
      "Status": toNotebookExecutionStatus,
      "StartTime": "d",
      "EndTime": "d",
      "Arn": "s",
      "OutputNotebookURI": "s",
      "LastStateChangeReason": "s",
      "NotebookInstanceSecurityGroupId": "s",
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Step {
  Id?: string | null;
  Name?: string | null;
  Config?: HadoopStepConfig | null;
  ActionOnFailure?: ActionOnFailure | null;
  Status?: StepStatus | null;
}
function toStep(root: JSONValue): Step {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": toActionOnFailure,
      "Status": toStepStatus,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface HadoopStepConfig {
  Jar?: string | null;
  Properties?: { [key: string]: string } | null;
  MainClass?: string | null;
  Args?: string[] | null;
}
function toHadoopStepConfig(root: JSONValue): HadoopStepConfig {
  return prt.readObj({
    required: {},
    optional: {
      "Jar": "s",
      "Properties": x => prt.readMap(String, String, x),
      "MainClass": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepStatus {
  State?: StepState | null;
  StateChangeReason?: StepStateChangeReason | null;
  FailureDetails?: FailureDetails | null;
  Timeline?: StepTimeline | null;
}
function toStepStatus(root: JSONValue): StepStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toStepState,
      "StateChangeReason": toStepStateChangeReason,
      "FailureDetails": toFailureDetails,
      "Timeline": toStepTimeline,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepStateChangeReason {
  Code?: StepStateChangeReasonCode | null;
  Message?: string | null;
}
function toStepStateChangeReason(root: JSONValue): StepStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toStepStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type StepStateChangeReasonCode =
| "NONE"
;
function toStepStateChangeReasonCode(root: JSONValue): StepStateChangeReasonCode | null {
  return ( false
    || root == "NONE"
  ) ? root : null;
}

// refs: 2 - tags: output, named, interface
export interface FailureDetails {
  Reason?: string | null;
  Message?: string | null;
  LogFile?: string | null;
}
function toFailureDetails(root: JSONValue): FailureDetails {
  return prt.readObj({
    required: {},
    optional: {
      "Reason": "s",
      "Message": "s",
      "LogFile": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface StepTimeline {
  CreationDateTime?: Date | number | null;
  StartDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toStepTimeline(root: JSONValue): StepTimeline {
  return prt.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "StartDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BlockPublicAccessConfigurationMetadata {
  CreationDateTime: Date | number;
  CreatedByArn: string;
}
function toBlockPublicAccessConfigurationMetadata(root: JSONValue): BlockPublicAccessConfigurationMetadata {
  return prt.readObj({
    required: {
      "CreationDateTime": "d",
      "CreatedByArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Command {
  Name?: string | null;
  ScriptPath?: string | null;
  Args?: string[] | null;
}
function toCommand(root: JSONValue): Command {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ScriptPath": "s",
      "Args": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ClusterSummary {
  Id?: string | null;
  Name?: string | null;
  Status?: ClusterStatus | null;
  NormalizedInstanceHours?: number | null;
  ClusterArn?: string | null;
  OutpostArn?: string | null;
}
function toClusterSummary(root: JSONValue): ClusterSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toClusterStatus,
      "NormalizedInstanceHours": "n",
      "ClusterArn": "s",
      "OutpostArn": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleet {
  Id?: string | null;
  Name?: string | null;
  Status?: InstanceFleetStatus | null;
  InstanceFleetType?: InstanceFleetType | null;
  TargetOnDemandCapacity?: number | null;
  TargetSpotCapacity?: number | null;
  ProvisionedOnDemandCapacity?: number | null;
  ProvisionedSpotCapacity?: number | null;
  InstanceTypeSpecifications?: InstanceTypeSpecification[] | null;
  LaunchSpecifications?: InstanceFleetProvisioningSpecifications | null;
}
function toInstanceFleet(root: JSONValue): InstanceFleet {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Status": toInstanceFleetStatus,
      "InstanceFleetType": toInstanceFleetType,
      "TargetOnDemandCapacity": "n",
      "TargetSpotCapacity": "n",
      "ProvisionedOnDemandCapacity": "n",
      "ProvisionedSpotCapacity": "n",
      "InstanceTypeSpecifications": [toInstanceTypeSpecification],
      "LaunchSpecifications": toInstanceFleetProvisioningSpecifications,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleetStatus {
  State?: InstanceFleetState | null;
  StateChangeReason?: InstanceFleetStateChangeReason | null;
  Timeline?: InstanceFleetTimeline | null;
}
function toInstanceFleetStatus(root: JSONValue): InstanceFleetStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toInstanceFleetState,
      "StateChangeReason": toInstanceFleetStateChangeReason,
      "Timeline": toInstanceFleetTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceFleetState =
| "PROVISIONING"
| "BOOTSTRAPPING"
| "RUNNING"
| "RESIZING"
| "SUSPENDED"
| "TERMINATING"
| "TERMINATED"
;
function toInstanceFleetState(root: JSONValue): InstanceFleetState | null {
  return ( false
    || root == "PROVISIONING"
    || root == "BOOTSTRAPPING"
    || root == "RUNNING"
    || root == "RESIZING"
    || root == "SUSPENDED"
    || root == "TERMINATING"
    || root == "TERMINATED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleetStateChangeReason {
  Code?: InstanceFleetStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceFleetStateChangeReason(root: JSONValue): InstanceFleetStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toInstanceFleetStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceFleetStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "CLUSTER_TERMINATED"
;
function toInstanceFleetStateChangeReasonCode(root: JSONValue): InstanceFleetStateChangeReasonCode | null {
  return ( false
    || root == "INTERNAL_ERROR"
    || root == "VALIDATION_ERROR"
    || root == "INSTANCE_FAILURE"
    || root == "CLUSTER_TERMINATED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface InstanceFleetTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceFleetTimeline(root: JSONValue): InstanceFleetTimeline {
  return prt.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceTypeSpecification {
  InstanceType?: string | null;
  WeightedCapacity?: number | null;
  BidPrice?: string | null;
  BidPriceAsPercentageOfOnDemandPrice?: number | null;
  Configurations?: Configuration[] | null;
  EbsBlockDevices?: EbsBlockDevice[] | null;
  EbsOptimized?: boolean | null;
}
function toInstanceTypeSpecification(root: JSONValue): InstanceTypeSpecification {
  return prt.readObj({
    required: {},
    optional: {
      "InstanceType": "s",
      "WeightedCapacity": "n",
      "BidPrice": "s",
      "BidPriceAsPercentageOfOnDemandPrice": "n",
      "Configurations": [toConfiguration],
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EbsBlockDevice {
  VolumeSpecification?: VolumeSpecification | null;
  Device?: string | null;
}
function toEbsBlockDevice(root: JSONValue): EbsBlockDevice {
  return prt.readObj({
    required: {},
    optional: {
      "VolumeSpecification": toVolumeSpecification,
      "Device": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroup {
  Id?: string | null;
  Name?: string | null;
  Market?: MarketType | null;
  InstanceGroupType?: InstanceGroupType | null;
  BidPrice?: string | null;
  InstanceType?: string | null;
  RequestedInstanceCount?: number | null;
  RunningInstanceCount?: number | null;
  Status?: InstanceGroupStatus | null;
  Configurations?: Configuration[] | null;
  ConfigurationsVersion?: number | null;
  LastSuccessfullyAppliedConfigurations?: Configuration[] | null;
  LastSuccessfullyAppliedConfigurationsVersion?: number | null;
  EbsBlockDevices?: EbsBlockDevice[] | null;
  EbsOptimized?: boolean | null;
  ShrinkPolicy?: ShrinkPolicy | null;
  AutoScalingPolicy?: AutoScalingPolicyDescription | null;
}
function toInstanceGroup(root: JSONValue): InstanceGroup {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Market": toMarketType,
      "InstanceGroupType": toInstanceGroupType,
      "BidPrice": "s",
      "InstanceType": "s",
      "RequestedInstanceCount": "n",
      "RunningInstanceCount": "n",
      "Status": toInstanceGroupStatus,
      "Configurations": [toConfiguration],
      "ConfigurationsVersion": "n",
      "LastSuccessfullyAppliedConfigurations": [toConfiguration],
      "LastSuccessfullyAppliedConfigurationsVersion": "n",
      "EbsBlockDevices": [toEbsBlockDevice],
      "EbsOptimized": "b",
      "ShrinkPolicy": toShrinkPolicy,
      "AutoScalingPolicy": toAutoScalingPolicyDescription,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupStatus {
  State?: InstanceGroupState | null;
  StateChangeReason?: InstanceGroupStateChangeReason | null;
  Timeline?: InstanceGroupTimeline | null;
}
function toInstanceGroupStatus(root: JSONValue): InstanceGroupStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toInstanceGroupState,
      "StateChangeReason": toInstanceGroupStateChangeReason,
      "Timeline": toInstanceGroupTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupStateChangeReason {
  Code?: InstanceGroupStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceGroupStateChangeReason(root: JSONValue): InstanceGroupStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toInstanceGroupStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceGroupStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "CLUSTER_TERMINATED"
;
function toInstanceGroupStateChangeReasonCode(root: JSONValue): InstanceGroupStateChangeReasonCode | null {
  return ( false
    || root == "INTERNAL_ERROR"
    || root == "VALIDATION_ERROR"
    || root == "INSTANCE_FAILURE"
    || root == "CLUSTER_TERMINATED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface InstanceGroupTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceGroupTimeline(root: JSONValue): InstanceGroupTimeline {
  return prt.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyDescription {
  Status?: AutoScalingPolicyStatus | null;
  Constraints?: ScalingConstraints | null;
  Rules?: ScalingRule[] | null;
}
function toAutoScalingPolicyDescription(root: JSONValue): AutoScalingPolicyDescription {
  return prt.readObj({
    required: {},
    optional: {
      "Status": toAutoScalingPolicyStatus,
      "Constraints": toScalingConstraints,
      "Rules": [toScalingRule],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyStatus {
  State?: AutoScalingPolicyState | null;
  StateChangeReason?: AutoScalingPolicyStateChangeReason | null;
}
function toAutoScalingPolicyStatus(root: JSONValue): AutoScalingPolicyStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toAutoScalingPolicyState,
      "StateChangeReason": toAutoScalingPolicyStateChangeReason,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoScalingPolicyState =
| "PENDING"
| "ATTACHING"
| "ATTACHED"
| "DETACHING"
| "DETACHED"
| "FAILED"
;
function toAutoScalingPolicyState(root: JSONValue): AutoScalingPolicyState | null {
  return ( false
    || root == "PENDING"
    || root == "ATTACHING"
    || root == "ATTACHED"
    || root == "DETACHING"
    || root == "DETACHED"
    || root == "FAILED"
  ) ? root : null;
}

// refs: 2 - tags: output, named, interface
export interface AutoScalingPolicyStateChangeReason {
  Code?: AutoScalingPolicyStateChangeReasonCode | null;
  Message?: string | null;
}
function toAutoScalingPolicyStateChangeReason(root: JSONValue): AutoScalingPolicyStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toAutoScalingPolicyStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoScalingPolicyStateChangeReasonCode =
| "USER_REQUEST"
| "PROVISION_FAILURE"
| "CLEANUP_FAILURE"
;
function toAutoScalingPolicyStateChangeReasonCode(root: JSONValue): AutoScalingPolicyStateChangeReasonCode | null {
  return ( false
    || root == "USER_REQUEST"
    || root == "PROVISION_FAILURE"
    || root == "CLEANUP_FAILURE"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface Instance {
  Id?: string | null;
  Ec2InstanceId?: string | null;
  PublicDnsName?: string | null;
  PublicIpAddress?: string | null;
  PrivateDnsName?: string | null;
  PrivateIpAddress?: string | null;
  Status?: InstanceStatus | null;
  InstanceGroupId?: string | null;
  InstanceFleetId?: string | null;
  Market?: MarketType | null;
  InstanceType?: string | null;
  EbsVolumes?: EbsVolume[] | null;
}
function toInstance(root: JSONValue): Instance {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Ec2InstanceId": "s",
      "PublicDnsName": "s",
      "PublicIpAddress": "s",
      "PrivateDnsName": "s",
      "PrivateIpAddress": "s",
      "Status": toInstanceStatus,
      "InstanceGroupId": "s",
      "InstanceFleetId": "s",
      "Market": toMarketType,
      "InstanceType": "s",
      "EbsVolumes": [toEbsVolume],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceStatus {
  State?: InstanceState | null;
  StateChangeReason?: InstanceStateChangeReason | null;
  Timeline?: InstanceTimeline | null;
}
function toInstanceStatus(root: JSONValue): InstanceStatus {
  return prt.readObj({
    required: {},
    optional: {
      "State": toInstanceState,
      "StateChangeReason": toInstanceStateChangeReason,
      "Timeline": toInstanceTimeline,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface InstanceStateChangeReason {
  Code?: InstanceStateChangeReasonCode | null;
  Message?: string | null;
}
function toInstanceStateChangeReason(root: JSONValue): InstanceStateChangeReason {
  return prt.readObj({
    required: {},
    optional: {
      "Code": toInstanceStateChangeReasonCode,
      "Message": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InstanceStateChangeReasonCode =
| "INTERNAL_ERROR"
| "VALIDATION_ERROR"
| "INSTANCE_FAILURE"
| "BOOTSTRAP_FAILURE"
| "CLUSTER_TERMINATED"
;
function toInstanceStateChangeReasonCode(root: JSONValue): InstanceStateChangeReasonCode | null {
  return ( false
    || root == "INTERNAL_ERROR"
    || root == "VALIDATION_ERROR"
    || root == "INSTANCE_FAILURE"
    || root == "BOOTSTRAP_FAILURE"
    || root == "CLUSTER_TERMINATED"
  ) ? root : null;
}

// refs: 1 - tags: output, named, interface
export interface InstanceTimeline {
  CreationDateTime?: Date | number | null;
  ReadyDateTime?: Date | number | null;
  EndDateTime?: Date | number | null;
}
function toInstanceTimeline(root: JSONValue): InstanceTimeline {
  return prt.readObj({
    required: {},
    optional: {
      "CreationDateTime": "d",
      "ReadyDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EbsVolume {
  Device?: string | null;
  VolumeId?: string | null;
}
function toEbsVolume(root: JSONValue): EbsVolume {
  return prt.readObj({
    required: {},
    optional: {
      "Device": "s",
      "VolumeId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookExecutionSummary {
  NotebookExecutionId?: string | null;
  EditorId?: string | null;
  NotebookExecutionName?: string | null;
  Status?: NotebookExecutionStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
}
function toNotebookExecutionSummary(root: JSONValue): NotebookExecutionSummary {
  return prt.readObj({
    required: {},
    optional: {
      "NotebookExecutionId": "s",
      "EditorId": "s",
      "NotebookExecutionName": "s",
      "Status": toNotebookExecutionStatus,
      "StartTime": "d",
      "EndTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SecurityConfigurationSummary {
  Name?: string | null;
  CreationDateTime?: Date | number | null;
}
function toSecurityConfigurationSummary(root: JSONValue): SecurityConfigurationSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CreationDateTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StepSummary {
  Id?: string | null;
  Name?: string | null;
  Config?: HadoopStepConfig | null;
  ActionOnFailure?: ActionOnFailure | null;
  Status?: StepStatus | null;
}
function toStepSummary(root: JSONValue): StepSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Config": toHadoopStepConfig,
      "ActionOnFailure": toActionOnFailure,
      "Status": toStepStatus,
    },
  }, root);
}
