// Autogenerated API client for: AWS RDS DataService

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class RDSDataService {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(RDSDataService.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-08-01",
    "endpointPrefix": "rds-data",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS RDS DataService",
    "serviceId": "RDS Data",
    "signatureVersion": "v4",
    "signingName": "rds-data",
    "uid": "rds-data-2018-08-01"
  };

  async batchExecuteStatement(
    {abortSignal, ...params}: RequestConfig & BatchExecuteStatementRequest,
  ): Promise<BatchExecuteStatementResponse> {
    const body: jsonP.JSONObject = params ? {
      database: params["database"],
      parameterSets: params["parameterSets"]?.map(x => x?.map(fromSqlParameter)),
      resourceArn: params["resourceArn"],
      schema: params["schema"],
      secretArn: params["secretArn"],
      sql: params["sql"],
      transactionId: params["transactionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchExecuteStatement",
      requestUri: "/BatchExecute",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "updateResults": [toUpdateResult],
        },
      }, await resp.json()),
  };
  }

  async beginTransaction(
    {abortSignal, ...params}: RequestConfig & BeginTransactionRequest,
  ): Promise<BeginTransactionResponse> {
    const body: jsonP.JSONObject = params ? {
      database: params["database"],
      resourceArn: params["resourceArn"],
      schema: params["schema"],
      secretArn: params["secretArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BeginTransaction",
      requestUri: "/BeginTransaction",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "transactionId": "s",
        },
      }, await resp.json()),
  };
  }

  async commitTransaction(
    {abortSignal, ...params}: RequestConfig & CommitTransactionRequest,
  ): Promise<CommitTransactionResponse> {
    const body: jsonP.JSONObject = params ? {
      resourceArn: params["resourceArn"],
      secretArn: params["secretArn"],
      transactionId: params["transactionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CommitTransaction",
      requestUri: "/CommitTransaction",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "transactionStatus": "s",
        },
      }, await resp.json()),
  };
  }

  async executeSql(
    {abortSignal, ...params}: RequestConfig & ExecuteSqlRequest,
  ): Promise<ExecuteSqlResponse> {
    const body: jsonP.JSONObject = params ? {
      awsSecretStoreArn: params["awsSecretStoreArn"],
      database: params["database"],
      dbClusterOrInstanceArn: params["dbClusterOrInstanceArn"],
      schema: params["schema"],
      sqlStatements: params["sqlStatements"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteSql",
      requestUri: "/ExecuteSql",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "sqlStatementResults": [toSqlStatementResult],
        },
      }, await resp.json()),
  };
  }

  async executeStatement(
    {abortSignal, ...params}: RequestConfig & ExecuteStatementRequest,
  ): Promise<ExecuteStatementResponse> {
    const body: jsonP.JSONObject = params ? {
      continueAfterTimeout: params["continueAfterTimeout"],
      database: params["database"],
      includeResultMetadata: params["includeResultMetadata"],
      parameters: params["parameters"]?.map(x => fromSqlParameter(x)),
      resourceArn: params["resourceArn"],
      resultSetOptions: fromResultSetOptions(params["resultSetOptions"]),
      schema: params["schema"],
      secretArn: params["secretArn"],
      sql: params["sql"],
      transactionId: params["transactionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ExecuteStatement",
      requestUri: "/Execute",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "columnMetadata": [toColumnMetadata],
          "generatedFields": [toField],
          "numberOfRecordsUpdated": "n",
          "records": [x => jsonP.readList(toField, x)],
        },
      }, await resp.json()),
  };
  }

  async rollbackTransaction(
    {abortSignal, ...params}: RequestConfig & RollbackTransactionRequest,
  ): Promise<RollbackTransactionResponse> {
    const body: jsonP.JSONObject = params ? {
      resourceArn: params["resourceArn"],
      secretArn: params["secretArn"],
      transactionId: params["transactionId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RollbackTransaction",
      requestUri: "/RollbackTransaction",
      responseCode: 200,
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "transactionStatus": "s",
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface BatchExecuteStatementRequest {
  database?: string | null;
  parameterSets?: SqlParameter[][] | null;
  resourceArn: string;
  schema?: string | null;
  secretArn: string;
  sql: string;
  transactionId?: string | null;
}

// refs: 1 - tags: named, input
export interface BeginTransactionRequest {
  database?: string | null;
  resourceArn: string;
  schema?: string | null;
  secretArn: string;
}

// refs: 1 - tags: named, input
export interface CommitTransactionRequest {
  resourceArn: string;
  secretArn: string;
  transactionId: string;
}

// refs: 1 - tags: named, input
export interface ExecuteSqlRequest {
  awsSecretStoreArn: string;
  database?: string | null;
  dbClusterOrInstanceArn: string;
  schema?: string | null;
  sqlStatements: string;
}

// refs: 1 - tags: named, input
export interface ExecuteStatementRequest {
  continueAfterTimeout?: boolean | null;
  database?: string | null;
  includeResultMetadata?: boolean | null;
  parameters?: SqlParameter[] | null;
  resourceArn: string;
  resultSetOptions?: ResultSetOptions | null;
  schema?: string | null;
  secretArn: string;
  sql: string;
  transactionId?: string | null;
}

// refs: 1 - tags: named, input
export interface RollbackTransactionRequest {
  resourceArn: string;
  secretArn: string;
  transactionId: string;
}

// refs: 1 - tags: named, output
export interface BatchExecuteStatementResponse {
  updateResults?: UpdateResult[] | null;
}

// refs: 1 - tags: named, output
export interface BeginTransactionResponse {
  transactionId?: string | null;
}

// refs: 1 - tags: named, output
export interface CommitTransactionResponse {
  transactionStatus?: string | null;
}

// refs: 1 - tags: named, output
export interface ExecuteSqlResponse {
  sqlStatementResults?: SqlStatementResult[] | null;
}

// refs: 1 - tags: named, output
export interface ExecuteStatementResponse {
  columnMetadata?: ColumnMetadata[] | null;
  generatedFields?: Field[] | null;
  numberOfRecordsUpdated?: number | null;
  records?: Field[][] | null;
}

// refs: 1 - tags: named, output
export interface RollbackTransactionResponse {
  transactionStatus?: string | null;
}

// refs: 2 - tags: input, named, interface
export interface SqlParameter {
  name?: string | null;
  typeHint?: TypeHint | null;
  value?: Field | null;
}
function fromSqlParameter(input?: SqlParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    typeHint: input["typeHint"],
    value: fromField(input["value"]),
  }
}

// refs: 2 - tags: input, named, enum
export type TypeHint =
| "DATE"
| "DECIMAL"
| "TIME"
| "TIMESTAMP"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface Field {
  arrayValue?: ArrayValue | null;
  blobValue?: Uint8Array | string | null;
  booleanValue?: boolean | null;
  doubleValue?: number | null;
  isNull?: boolean | null;
  longValue?: number | null;
  stringValue?: string | null;
}
function fromField(input?: Field | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    arrayValue: fromArrayValue(input["arrayValue"]),
    blobValue: jsonP.serializeBlob(input["blobValue"]),
    booleanValue: input["booleanValue"],
    doubleValue: input["doubleValue"],
    isNull: input["isNull"],
    longValue: input["longValue"],
    stringValue: input["stringValue"],
  }
}
function toField(root: jsonP.JSONValue): Field {
  return jsonP.readObj({
    required: {},
    optional: {
      "arrayValue": toArrayValue,
      "blobValue": "a",
      "booleanValue": "b",
      "doubleValue": "n",
      "isNull": "b",
      "longValue": "n",
      "stringValue": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, recursed, output
export interface ArrayValue {
  arrayValues?: ArrayValue[] | null;
  booleanValues?: boolean[] | null;
  doubleValues?: number[] | null;
  longValues?: number[] | null;
  stringValues?: string[] | null;
}
function fromArrayValue(input?: ArrayValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    arrayValues: input["arrayValues"]?.map(x => fromArrayValue(x)),
    booleanValues: input["booleanValues"],
    doubleValues: input["doubleValues"],
    longValues: input["longValues"],
    stringValues: input["stringValues"],
  }
}
function toArrayValue(root: jsonP.JSONValue): ArrayValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "arrayValues": [toArrayValue],
      "booleanValues": ["b"],
      "doubleValues": ["n"],
      "longValues": ["n"],
      "stringValues": ["s"],
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface ResultSetOptions {
  decimalReturnType?: DecimalReturnType | null;
}
function fromResultSetOptions(input?: ResultSetOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    decimalReturnType: input["decimalReturnType"],
  }
}

// refs: 1 - tags: input, named, enum
export type DecimalReturnType =
| "DOUBLE_OR_LONG"
| "STRING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface UpdateResult {
  generatedFields?: Field[] | null;
}
function toUpdateResult(root: jsonP.JSONValue): UpdateResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "generatedFields": [toField],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SqlStatementResult {
  numberOfRecordsUpdated?: number | null;
  resultFrame?: ResultFrame | null;
}
function toSqlStatementResult(root: jsonP.JSONValue): SqlStatementResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "numberOfRecordsUpdated": "n",
      "resultFrame": toResultFrame,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResultFrame {
  records?: Record[] | null;
  resultSetMetadata?: ResultSetMetadata | null;
}
function toResultFrame(root: jsonP.JSONValue): ResultFrame {
  return jsonP.readObj({
    required: {},
    optional: {
      "records": [toRecord],
      "resultSetMetadata": toResultSetMetadata,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Record {
  values?: Value[] | null;
}
function toRecord(root: jsonP.JSONValue): Record {
  return jsonP.readObj({
    required: {},
    optional: {
      "values": [toValue],
    },
  }, root);
}

// refs: 3 - tags: output, named, interface, recursed
export interface Value {
  arrayValues?: Value[] | null;
  bigIntValue?: number | null;
  bitValue?: boolean | null;
  blobValue?: Uint8Array | string | null;
  doubleValue?: number | null;
  intValue?: number | null;
  isNull?: boolean | null;
  realValue?: number | null;
  stringValue?: string | null;
  structValue?: StructValue | null;
}
function toValue(root: jsonP.JSONValue): Value {
  return jsonP.readObj({
    required: {},
    optional: {
      "arrayValues": [toValue],
      "bigIntValue": "n",
      "bitValue": "b",
      "blobValue": "a",
      "doubleValue": "n",
      "intValue": "n",
      "isNull": "b",
      "realValue": "n",
      "stringValue": "s",
      "structValue": toStructValue,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface StructValue {
  attributes?: Value[] | null;
}
function toStructValue(root: jsonP.JSONValue): StructValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "attributes": [toValue],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResultSetMetadata {
  columnCount?: number | null;
  columnMetadata?: ColumnMetadata[] | null;
}
function toResultSetMetadata(root: jsonP.JSONValue): ResultSetMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "columnCount": "n",
      "columnMetadata": [toColumnMetadata],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ColumnMetadata {
  arrayBaseColumnType?: number | null;
  isAutoIncrement?: boolean | null;
  isCaseSensitive?: boolean | null;
  isCurrency?: boolean | null;
  isSigned?: boolean | null;
  label?: string | null;
  name?: string | null;
  nullable?: number | null;
  precision?: number | null;
  scale?: number | null;
  schemaName?: string | null;
  tableName?: string | null;
  type?: number | null;
  typeName?: string | null;
}
function toColumnMetadata(root: jsonP.JSONValue): ColumnMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "arrayBaseColumnType": "n",
      "isAutoIncrement": "b",
      "isCaseSensitive": "b",
      "isCurrency": "b",
      "isSigned": "b",
      "label": "s",
      "name": "s",
      "nullable": "n",
      "precision": "n",
      "scale": "n",
      "schemaName": "s",
      "tableName": "s",
      "type": "n",
      "typeName": "s",
    },
  }, root);
}
