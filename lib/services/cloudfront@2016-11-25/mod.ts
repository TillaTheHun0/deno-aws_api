// Autogenerated API client for: Amazon CloudFront

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";

export default class CloudFront {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFront.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2016-11-25",
    "endpointPrefix": "cloudfront",
    "globalEndpoint": "cloudfront.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "CloudFront",
    "serviceFullName": "Amazon CloudFront",
    "serviceId": "CloudFront",
    "signatureVersion": "v4",
    "uid": "cloudfront-2016-11-25"
  };

  async createCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & CreateCloudFrontOriginAccessIdentityRequest,
  ): Promise<CreateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFrontOriginAccessIdentity2016_11_25",
      requestUri: "/2016-11-25/origin-access-identity/cloudfront",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async createDistribution(
    {abortSignal, ...params}: RequestConfig & CreateDistributionRequest,
  ): Promise<CreateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistribution2016_11_25",
      requestUri: "/2016-11-25/distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & CreateDistributionWithTagsRequest,
  ): Promise<CreateDistributionWithTagsResult> {
    const inner = params["DistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "DistributionConfig", ...DistributionConfig_Serialize(inner["DistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistributionWithTags2016_11_25",
      requestUri: "/2016-11-25/distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createInvalidation(
    {abortSignal, ...params}: RequestConfig & CreateInvalidationRequest,
  ): Promise<CreateInvalidationResult> {
    const inner = params["InvalidationBatch"];
    const body = inner ? xmlP.stringify({
      name: "InvalidationBatch",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "Paths", ...Paths_Serialize(inner["Paths"])},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInvalidation2016_11_25",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["DistributionId"]}/invalidation`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async createStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & CreateStreamingDistributionRequest,
  ): Promise<CreateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistribution2016_11_25",
      requestUri: "/2016-11-25/streaming-distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async createStreamingDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & CreateStreamingDistributionWithTagsRequest,
  ): Promise<CreateStreamingDistributionWithTagsResult> {
    const inner = params["StreamingDistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(inner["StreamingDistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistributionWithTags2016_11_25",
      requestUri: "/2016-11-25/streaming-distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async deleteCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & DeleteCloudFrontOriginAccessIdentityRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCloudFrontOriginAccessIdentity2016_11_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2016-11-25/origin-access-identity/cloudfront/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteDistribution(
    {abortSignal, ...params}: RequestConfig & DeleteDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDistribution2016_11_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & DeleteStreamingDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStreamingDistribution2016_11_25",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2016-11-25/streaming-distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async getCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & GetCloudFrontOriginAccessIdentityRequest,
  ): Promise<GetCloudFrontOriginAccessIdentityResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentity2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/origin-access-identity/cloudfront/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentityConfig(
    {abortSignal, ...params}: RequestConfig & GetCloudFrontOriginAccessIdentityConfigRequest,
  ): Promise<GetCloudFrontOriginAccessIdentityConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentityConfig2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig_Parse(xml),
  };
  }

  async getDistribution(
    {abortSignal, ...params}: RequestConfig & GetDistributionRequest,
  ): Promise<GetDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistribution2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async getDistributionConfig(
    {abortSignal, ...params}: RequestConfig & GetDistributionConfigRequest,
  ): Promise<GetDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistributionConfig2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    DistributionConfig: DistributionConfig_Parse(xml),
  };
  }

  async getInvalidation(
    {abortSignal, ...params}: RequestConfig & GetInvalidationRequest,
  ): Promise<GetInvalidationResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInvalidation2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["DistributionId"]}/invalidation/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async getStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & GetStreamingDistributionRequest,
  ): Promise<GetStreamingDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistribution2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/streaming-distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async getStreamingDistributionConfig(
    {abortSignal, ...params}: RequestConfig & GetStreamingDistributionConfigRequest,
  ): Promise<GetStreamingDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistributionConfig2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistributionConfig: StreamingDistributionConfig_Parse(xml),
  };
  }

  async listCloudFrontOriginAccessIdentities(
    {abortSignal, ...params}: RequestConfig & ListCloudFrontOriginAccessIdentitiesRequest = {},
  ): Promise<ListCloudFrontOriginAccessIdentitiesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCloudFrontOriginAccessIdentities2016_11_25",
      method: "GET",
      requestUri: "/2016-11-25/origin-access-identity/cloudfront",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CloudFrontOriginAccessIdentityList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
      },
  };
  }

  async listDistributions(
    {abortSignal, ...params}: RequestConfig & ListDistributionsRequest = {},
  ): Promise<ListDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributions2016_11_25",
      method: "GET",
      requestUri: "/2016-11-25/distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByWebACLId(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByWebACLIdRequest,
  ): Promise<ListDistributionsByWebACLIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByWebACLId2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/distributionsByWebACLId/${params["WebACLId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listInvalidations(
    {abortSignal, ...params}: RequestConfig & ListInvalidationsRequest,
  ): Promise<ListInvalidationsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvalidations2016_11_25",
      method: "GET",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["DistributionId"]}/invalidation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    InvalidationList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
      },
  };
  }

  async listStreamingDistributions(
    {abortSignal, ...params}: RequestConfig & ListStreamingDistributionsRequest = {},
  ): Promise<ListStreamingDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListStreamingDistributions2016_11_25",
      method: "GET",
      requestUri: "/2016-11-25/streaming-distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StreamingDistributionList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
      },
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResult> {
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource2016_11_25",
      method: "GET",
      requestUri: "/2016-11-25/tagging",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Tags: Tags_Parse(xml),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const inner = params["Tags"];
    const body = inner ? xmlP.stringify({
      name: "Tags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource2016_11_25",
      requestUri: "/2016-11-25/tagging?Operation=Tag",
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const inner = params["TagKeys"];
    const body = inner ? xmlP.stringify({
      name: "TagKeys",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Key", content: x}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource2016_11_25",
      requestUri: "/2016-11-25/tagging?Operation=Untag",
      responseCode: 204,
    });
  }

  async updateCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & UpdateCloudFrontOriginAccessIdentityRequest,
  ): Promise<UpdateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCloudFrontOriginAccessIdentity2016_11_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2016-11-25/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async updateDistribution(
    {abortSignal, ...params}: RequestConfig & UpdateDistributionRequest,
  ): Promise<UpdateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDistribution2016_11_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2016-11-25/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async updateStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & UpdateStreamingDistributionRequest,
  ): Promise<UpdateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2016-11-25/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateStreamingDistribution2016_11_25",
      method: "PUT",
      requestUri: cmnP.encodePath`/2016-11-25/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  // Resource State Waiters

  /**
   * Wait until a distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForDistributionDeployed(
    params: RequestConfig & GetDistributionRequest,
  ): Promise<GetDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getDistribution(params);
      if (resp?.Distribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an invalidation has completed.
   * Checks state up to 30 times, 20 seconds apart (about 10 minutes max wait time).
   */
  async waitForInvalidationCompleted(
    params: RequestConfig & GetInvalidationRequest,
  ): Promise<GetInvalidationResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InvalidationCompleted';
    for (let i = 0; i < 30; i++) {
      const resp = await this.getInvalidation(params);
      if (resp?.Invalidation?.Status === "Completed") return resp;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a streaming distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForStreamingDistributionDeployed(
    params: RequestConfig & GetStreamingDistributionRequest,
  ): Promise<GetStreamingDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamingDistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getStreamingDistribution(params);
      if (resp?.StreamingDistribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CreateCloudFrontOriginAccessIdentityRequest {
  CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
}

// refs: 1 - tags: named, input
export interface CreateDistributionRequest {
  DistributionConfig: DistributionConfig;
}

// refs: 1 - tags: named, input
export interface CreateDistributionWithTagsRequest {
  DistributionConfigWithTags: DistributionConfigWithTags;
}

// refs: 1 - tags: named, input
export interface CreateInvalidationRequest {
  DistributionId: string;
  InvalidationBatch: InvalidationBatch;
}

// refs: 1 - tags: named, input
export interface CreateStreamingDistributionRequest {
  StreamingDistributionConfig: StreamingDistributionConfig;
}

// refs: 1 - tags: named, input
export interface CreateStreamingDistributionWithTagsRequest {
  StreamingDistributionConfigWithTags: StreamingDistributionConfigWithTags;
}

// refs: 1 - tags: named, input
export interface DeleteCloudFrontOriginAccessIdentityRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDistributionRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStreamingDistributionRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCloudFrontOriginAccessIdentityRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetCloudFrontOriginAccessIdentityConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetDistributionRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetDistributionConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetInvalidationRequest {
  DistributionId: string;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetStreamingDistributionRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetStreamingDistributionConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ListCloudFrontOriginAccessIdentitiesRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDistributionsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByWebACLIdRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  WebACLId: string;
}

// refs: 1 - tags: named, input
export interface ListInvalidationsRequest {
  DistributionId: string;
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStreamingDistributionsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  Resource: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  Resource: string;
  Tags: Tags;
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  Resource: string;
  TagKeys: TagKeys;
}

// refs: 1 - tags: named, input
export interface UpdateCloudFrontOriginAccessIdentityRequest {
  CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateDistributionRequest {
  DistributionConfig: DistributionConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateStreamingDistributionRequest {
  StreamingDistributionConfig: StreamingDistributionConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDistributionResult {
  Distribution?: Distribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDistributionWithTagsResult {
  Distribution?: Distribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateInvalidationResult {
  Location?: string | null;
  Invalidation?: Invalidation | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamingDistributionWithTagsResult {
  StreamingDistribution?: StreamingDistribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCloudFrontOriginAccessIdentityConfigResult {
  CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDistributionResult {
  Distribution?: Distribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDistributionConfigResult {
  DistributionConfig?: DistributionConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetInvalidationResult {
  Invalidation?: Invalidation | null;
}

// refs: 1 - tags: named, output
export interface GetStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetStreamingDistributionConfigResult {
  StreamingDistributionConfig?: StreamingDistributionConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCloudFrontOriginAccessIdentitiesResult {
  CloudFrontOriginAccessIdentityList?: CloudFrontOriginAccessIdentityList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsResult {
  DistributionList?: DistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByWebACLIdResult {
  DistributionList?: DistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListInvalidationsResult {
  InvalidationList?: InvalidationList | null;
}

// refs: 1 - tags: named, output
export interface ListStreamingDistributionsResult {
  StreamingDistributionList?: StreamingDistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResult {
  Tags: Tags;
}

// refs: 1 - tags: named, output
export interface UpdateCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateDistributionResult {
  Distribution?: Distribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  ETag?: string | null;
}

// refs: 6 - tags: input, named, interface, output
export interface CloudFrontOriginAccessIdentityConfig {
  CallerReference: string;
  Comment: string;
}
function CloudFrontOriginAccessIdentityConfig_Serialize(data: CloudFrontOriginAccessIdentityConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function CloudFrontOriginAccessIdentityConfig_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentityConfig {
  return node.strings({
    required: {"CallerReference":true,"Comment":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface DistributionConfig {
  CallerReference: string;
  Aliases?: Aliases | null;
  DefaultRootObject?: string | null;
  Origins: Origins;
  DefaultCacheBehavior: DefaultCacheBehavior;
  CacheBehaviors?: CacheBehaviors | null;
  CustomErrorResponses?: CustomErrorResponses | null;
  Comment: string;
  Logging?: LoggingConfig | null;
  PriceClass?: PriceClass | null;
  Enabled: boolean;
  ViewerCertificate?: ViewerCertificate | null;
  Restrictions?: Restrictions | null;
  WebACLId?: string | null;
  HttpVersion?: HttpVersion | null;
  IsIPV6Enabled?: boolean | null;
}
function DistributionConfig_Serialize(data: DistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "DefaultRootObject", content: data["DefaultRootObject"]?.toString()},
    {name: "Origins", ...Origins_Serialize(data["Origins"])},
    {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(data["DefaultCacheBehavior"])},
    {name: "CacheBehaviors", ...CacheBehaviors_Serialize(data["CacheBehaviors"])},
    {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(data["CustomErrorResponses"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...LoggingConfig_Serialize(data["Logging"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "ViewerCertificate", ...ViewerCertificate_Serialize(data["ViewerCertificate"])},
    {name: "Restrictions", ...Restrictions_Serialize(data["Restrictions"])},
    {name: "WebACLId", content: data["WebACLId"]?.toString()},
    {name: "HttpVersion", content: data["HttpVersion"]?.toString()},
    {name: "IsIPV6Enabled", content: data["IsIPV6Enabled"]?.toString()},
  ]};
}
function DistributionConfig_Parse(node: xmlP.XmlNode): DistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
      optional: {"DefaultRootObject":true,"WebACLId":true},
    }),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", false, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", false, CustomErrorResponses_Parse),
    Logging: node.first("Logging", false, LoggingConfig_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", false, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", false, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", false, x => (x.content ?? '') as HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", false, x => x.content === 'true'),
  };
}

// refs: 19 - tags: input, named, interface, output
export interface Aliases {
  Quantity: number;
  Items: string[];
}
function Aliases_Serialize(data: Aliases | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CNAME", content: x}))},
  ]};
}
function Aliases_Parse(node: xmlP.XmlNode): Aliases {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CNAME").map(x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface Origins {
  Quantity: number;
  Items: Origin[];
}
function Origins_Serialize(data: Origins | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Origin", ...Origin_Serialize(x)}))},
  ]};
}
function Origins_Parse(node: xmlP.XmlNode): Origins {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Origin").map(Origin_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface Origin {
  Id: string;
  DomainName: string;
  OriginPath?: string | null;
  CustomHeaders?: CustomHeaders | null;
  S3OriginConfig?: S3OriginConfig | null;
  CustomOriginConfig?: CustomOriginConfig | null;
}
function Origin_Serialize(data: Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginPath", content: data["OriginPath"]?.toString()},
    {name: "CustomHeaders", ...CustomHeaders_Serialize(data["CustomHeaders"])},
    {name: "S3OriginConfig", ...S3OriginConfig_Serialize(data["S3OriginConfig"])},
    {name: "CustomOriginConfig", ...CustomOriginConfig_Serialize(data["CustomOriginConfig"])},
  ]};
}
function Origin_Parse(node: xmlP.XmlNode): Origin {
  return {
    ...node.strings({
      required: {"Id":true,"DomainName":true},
      optional: {"OriginPath":true},
    }),
    CustomHeaders: node.first("CustomHeaders", false, CustomHeaders_Parse),
    S3OriginConfig: node.first("S3OriginConfig", false, S3OriginConfig_Parse),
    CustomOriginConfig: node.first("CustomOriginConfig", false, CustomOriginConfig_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface CustomHeaders {
  Quantity: number;
  Items: OriginCustomHeader[];
}
function CustomHeaders_Serialize(data: CustomHeaders | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginCustomHeader", ...OriginCustomHeader_Serialize(x)}))},
  ]};
}
function CustomHeaders_Parse(node: xmlP.XmlNode): CustomHeaders {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginCustomHeader").map(OriginCustomHeader_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface OriginCustomHeader {
  HeaderName: string;
  HeaderValue: string;
}
function OriginCustomHeader_Serialize(data: OriginCustomHeader | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderName", content: data["HeaderName"]?.toString()},
    {name: "HeaderValue", content: data["HeaderValue"]?.toString()},
  ]};
}
function OriginCustomHeader_Parse(node: xmlP.XmlNode): OriginCustomHeader {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

// refs: 10 - tags: input, named, interface, output
export interface S3OriginConfig {
  OriginAccessIdentity: string;
}
function S3OriginConfig_Serialize(data: S3OriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3OriginConfig_Parse(node: xmlP.XmlNode): S3OriginConfig {
  return node.strings({
    required: {"OriginAccessIdentity":true},
  });
}

// refs: 10 - tags: input, named, interface, output
export interface CustomOriginConfig {
  HTTPPort: number;
  HTTPSPort: number;
  OriginProtocolPolicy: OriginProtocolPolicy;
  OriginSslProtocols?: OriginSslProtocols | null;
}
function CustomOriginConfig_Serialize(data: CustomOriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HTTPPort", content: data["HTTPPort"]?.toString()},
    {name: "HTTPSPort", content: data["HTTPSPort"]?.toString()},
    {name: "OriginProtocolPolicy", content: data["OriginProtocolPolicy"]?.toString()},
    {name: "OriginSslProtocols", ...OriginSslProtocols_Serialize(data["OriginSslProtocols"])},
  ]};
}
function CustomOriginConfig_Parse(node: xmlP.XmlNode): CustomOriginConfig {
  return {
    HTTPPort: node.first("HTTPPort", true, x => parseInt(x.content ?? '0')),
    HTTPSPort: node.first("HTTPSPort", true, x => parseInt(x.content ?? '0')),
    OriginProtocolPolicy: node.first("OriginProtocolPolicy", true, x => (x.content ?? '') as OriginProtocolPolicy),
    OriginSslProtocols: node.first("OriginSslProtocols", false, OriginSslProtocols_Parse),
  };
}

// refs: 10 - tags: input, named, enum, output
export type OriginProtocolPolicy =
| "http-only"
| "match-viewer"
| "https-only"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface OriginSslProtocols {
  Quantity: number;
  Items: SslProtocol[];
}
function OriginSslProtocols_Serialize(data: OriginSslProtocols | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "SslProtocol", content: x}))},
  ]};
}
function OriginSslProtocols_Parse(node: xmlP.XmlNode): OriginSslProtocols {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "SslProtocol").map(x => (x.content ?? '') as SslProtocol),
  };
}

// refs: 10 - tags: input, named, enum, output
export type SslProtocol =
| "SSLv3"
| "TLSv1"
| "TLSv1.1"
| "TLSv1.2"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface DefaultCacheBehavior {
  TargetOriginId: string;
  ForwardedValues: ForwardedValues;
  TrustedSigners: TrustedSigners;
  ViewerProtocolPolicy: ViewerProtocolPolicy;
  MinTTL: number;
  AllowedMethods?: AllowedMethods | null;
  SmoothStreaming?: boolean | null;
  DefaultTTL?: number | null;
  MaxTTL?: number | null;
  Compress?: boolean | null;
  LambdaFunctionAssociations?: LambdaFunctionAssociations | null;
}
function DefaultCacheBehavior_Serialize(data: DefaultCacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
  ]};
}
function DefaultCacheBehavior_Parse(node: xmlP.XmlNode): DefaultCacheBehavior {
  return {
    ...node.strings({
      required: {"TargetOriginId":true},
    }),
    ForwardedValues: node.first("ForwardedValues", true, ForwardedValues_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as ViewerProtocolPolicy),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface ForwardedValues {
  QueryString: boolean;
  Cookies: CookiePreference;
  Headers?: Headers | null;
  QueryStringCacheKeys?: QueryStringCacheKeys | null;
}
function ForwardedValues_Serialize(data: ForwardedValues | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryString", content: data["QueryString"]?.toString()},
    {name: "Cookies", ...CookiePreference_Serialize(data["Cookies"])},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
    {name: "QueryStringCacheKeys", ...QueryStringCacheKeys_Serialize(data["QueryStringCacheKeys"])},
  ]};
}
function ForwardedValues_Parse(node: xmlP.XmlNode): ForwardedValues {
  return {
    QueryString: node.first("QueryString", true, x => x.content === 'true'),
    Cookies: node.first("Cookies", true, CookiePreference_Parse),
    Headers: node.first("Headers", false, Headers_Parse),
    QueryStringCacheKeys: node.first("QueryStringCacheKeys", false, QueryStringCacheKeys_Parse),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface CookiePreference {
  Forward: ItemSelection;
  WhitelistedNames?: CookieNames | null;
}
function CookiePreference_Serialize(data: CookiePreference | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Forward", content: data["Forward"]?.toString()},
    {name: "WhitelistedNames", ...CookieNames_Serialize(data["WhitelistedNames"])},
  ]};
}
function CookiePreference_Parse(node: xmlP.XmlNode): CookiePreference {
  return {
    Forward: node.first("Forward", true, x => (x.content ?? '') as ItemSelection),
    WhitelistedNames: node.first("WhitelistedNames", false, CookieNames_Parse),
  };
}

// refs: 20 - tags: input, named, enum, output
export type ItemSelection =
| "none"
| "whitelist"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 20 - tags: input, named, interface, output
export interface CookieNames {
  Quantity: number;
  Items: string[];
}
function CookieNames_Serialize(data: CookieNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function CookieNames_Parse(node: xmlP.XmlNode): CookieNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface Headers {
  Quantity: number;
  Items: string[];
}
function Headers_Serialize(data: Headers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function Headers_Parse(node: xmlP.XmlNode): Headers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface QueryStringCacheKeys {
  Quantity: number;
  Items: string[];
}
function QueryStringCacheKeys_Serialize(data: QueryStringCacheKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringCacheKeys_Parse(node: xmlP.XmlNode): QueryStringCacheKeys {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 29 - tags: input, named, interface, output
export interface TrustedSigners {
  Enabled: boolean;
  Quantity: number;
  Items: string[];
}
function TrustedSigners_Serialize(data: TrustedSigners | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "AwsAccountNumber", content: x}))},
  ]};
}
function TrustedSigners_Parse(node: xmlP.XmlNode): TrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "AwsAccountNumber").map(x => x.content ?? ''),
  };
}

// refs: 20 - tags: input, named, enum, output
export type ViewerProtocolPolicy =
| "allow-all"
| "https-only"
| "redirect-to-https"
| cmnP.UnexpectedEnumValue;

// refs: 20 - tags: input, named, interface, output
export interface AllowedMethods {
  Quantity: number;
  Items: Method[];
  CachedMethods?: CachedMethods | null;
}
function AllowedMethods_Serialize(data: AllowedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
    {name: "CachedMethods", ...CachedMethods_Serialize(data["CachedMethods"])},
  ]};
}
function AllowedMethods_Parse(node: xmlP.XmlNode): AllowedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as Method),
    CachedMethods: node.first("CachedMethods", false, CachedMethods_Parse),
  };
}

// refs: 40 - tags: input, named, enum, output
export type Method =
| "GET"
| "HEAD"
| "POST"
| "PUT"
| "PATCH"
| "OPTIONS"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 20 - tags: input, named, interface, output
export interface CachedMethods {
  Quantity: number;
  Items: Method[];
}
function CachedMethods_Serialize(data: CachedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
  ]};
}
function CachedMethods_Parse(node: xmlP.XmlNode): CachedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as Method),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface LambdaFunctionAssociations {
  Quantity: number;
  Items: LambdaFunctionAssociation[];
}
function LambdaFunctionAssociations_Serialize(data: LambdaFunctionAssociations | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "LambdaFunctionAssociation", ...LambdaFunctionAssociation_Serialize(x)}))},
  ]};
}
function LambdaFunctionAssociations_Parse(node: xmlP.XmlNode): LambdaFunctionAssociations {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "LambdaFunctionAssociation").map(LambdaFunctionAssociation_Parse),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface LambdaFunctionAssociation {
  LambdaFunctionARN?: string | null;
  EventType?: EventType | null;
}
function LambdaFunctionAssociation_Serialize(data: LambdaFunctionAssociation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaFunctionARN", content: data["LambdaFunctionARN"]?.toString()},
    {name: "EventType", content: data["EventType"]?.toString()},
  ]};
}
function LambdaFunctionAssociation_Parse(node: xmlP.XmlNode): LambdaFunctionAssociation {
  return {
    ...node.strings({
      optional: {"LambdaFunctionARN":true},
    }),
    EventType: node.first("EventType", false, x => (x.content ?? '') as EventType),
  };
}

// refs: 20 - tags: input, named, enum, output
export type EventType =
| "viewer-request"
| "viewer-response"
| "origin-request"
| "origin-response"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface CacheBehaviors {
  Quantity: number;
  Items: CacheBehavior[];
}
function CacheBehaviors_Serialize(data: CacheBehaviors | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CacheBehavior", ...CacheBehavior_Serialize(x)}))},
  ]};
}
function CacheBehaviors_Parse(node: xmlP.XmlNode): CacheBehaviors {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CacheBehavior").map(CacheBehavior_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface CacheBehavior {
  PathPattern: string;
  TargetOriginId: string;
  ForwardedValues: ForwardedValues;
  TrustedSigners: TrustedSigners;
  ViewerProtocolPolicy: ViewerProtocolPolicy;
  MinTTL: number;
  AllowedMethods?: AllowedMethods | null;
  SmoothStreaming?: boolean | null;
  DefaultTTL?: number | null;
  MaxTTL?: number | null;
  Compress?: boolean | null;
  LambdaFunctionAssociations?: LambdaFunctionAssociations | null;
}
function CacheBehavior_Serialize(data: CacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PathPattern", content: data["PathPattern"]?.toString()},
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
  ]};
}
function CacheBehavior_Parse(node: xmlP.XmlNode): CacheBehavior {
  return {
    ...node.strings({
      required: {"PathPattern":true,"TargetOriginId":true},
    }),
    ForwardedValues: node.first("ForwardedValues", true, ForwardedValues_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as ViewerProtocolPolicy),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface CustomErrorResponses {
  Quantity: number;
  Items: CustomErrorResponse[];
}
function CustomErrorResponses_Serialize(data: CustomErrorResponses | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CustomErrorResponse", ...CustomErrorResponse_Serialize(x)}))},
  ]};
}
function CustomErrorResponses_Parse(node: xmlP.XmlNode): CustomErrorResponses {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CustomErrorResponse").map(CustomErrorResponse_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface CustomErrorResponse {
  ErrorCode: number;
  ResponsePagePath?: string | null;
  ResponseCode?: string | null;
  ErrorCachingMinTTL?: number | null;
}
function CustomErrorResponse_Serialize(data: CustomErrorResponse | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorCode", content: data["ErrorCode"]?.toString()},
    {name: "ResponsePagePath", content: data["ResponsePagePath"]?.toString()},
    {name: "ResponseCode", content: data["ResponseCode"]?.toString()},
    {name: "ErrorCachingMinTTL", content: data["ErrorCachingMinTTL"]?.toString()},
  ]};
}
function CustomErrorResponse_Parse(node: xmlP.XmlNode): CustomErrorResponse {
  return {
    ...node.strings({
      optional: {"ResponsePagePath":true,"ResponseCode":true},
    }),
    ErrorCode: node.first("ErrorCode", true, x => parseInt(x.content ?? '0')),
    ErrorCachingMinTTL: node.first("ErrorCachingMinTTL", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 8 - tags: input, named, interface, output
export interface LoggingConfig {
  Enabled: boolean;
  IncludeCookies: boolean;
  Bucket: string;
  Prefix: string;
}
function LoggingConfig_Serialize(data: LoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "IncludeCookies", content: data["IncludeCookies"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function LoggingConfig_Parse(node: xmlP.XmlNode): LoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    IncludeCookies: node.first("IncludeCookies", true, x => x.content === 'true'),
  };
}

// refs: 19 - tags: input, named, enum, output
export type PriceClass =
| "PriceClass_100"
| "PriceClass_200"
| "PriceClass_All"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface ViewerCertificate {
  CloudFrontDefaultCertificate?: boolean | null;
  IAMCertificateId?: string | null;
  ACMCertificateArn?: string | null;
  SSLSupportMethod?: SSLSupportMethod | null;
  MinimumProtocolVersion?: MinimumProtocolVersion | null;
  Certificate?: string | null;
  CertificateSource?: CertificateSource | null;
}
function ViewerCertificate_Serialize(data: ViewerCertificate | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CloudFrontDefaultCertificate", content: data["CloudFrontDefaultCertificate"]?.toString()},
    {name: "IAMCertificateId", content: data["IAMCertificateId"]?.toString()},
    {name: "ACMCertificateArn", content: data["ACMCertificateArn"]?.toString()},
    {name: "SSLSupportMethod", content: data["SSLSupportMethod"]?.toString()},
    {name: "MinimumProtocolVersion", content: data["MinimumProtocolVersion"]?.toString()},
    {name: "Certificate", content: data["Certificate"]?.toString()},
    {name: "CertificateSource", content: data["CertificateSource"]?.toString()},
  ]};
}
function ViewerCertificate_Parse(node: xmlP.XmlNode): ViewerCertificate {
  return {
    ...node.strings({
      optional: {"IAMCertificateId":true,"ACMCertificateArn":true,"Certificate":true},
    }),
    CloudFrontDefaultCertificate: node.first("CloudFrontDefaultCertificate", false, x => x.content === 'true'),
    SSLSupportMethod: node.first("SSLSupportMethod", false, x => (x.content ?? '') as SSLSupportMethod),
    MinimumProtocolVersion: node.first("MinimumProtocolVersion", false, x => (x.content ?? '') as MinimumProtocolVersion),
    CertificateSource: node.first("CertificateSource", false, x => (x.content ?? '') as CertificateSource),
  };
}

// refs: 10 - tags: input, named, enum, output
export type SSLSupportMethod =
| "sni-only"
| "vip"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type MinimumProtocolVersion =
| "SSLv3"
| "TLSv1"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type CertificateSource =
| "cloudfront"
| "iam"
| "acm"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Restrictions {
  GeoRestriction: GeoRestriction;
}
function Restrictions_Serialize(data: Restrictions | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "GeoRestriction", ...GeoRestriction_Serialize(data["GeoRestriction"])},
  ]};
}
function Restrictions_Parse(node: xmlP.XmlNode): Restrictions {
  return {
    GeoRestriction: node.first("GeoRestriction", true, GeoRestriction_Parse),
  };
}

// refs: 10 - tags: input, named, interface, output
export interface GeoRestriction {
  RestrictionType: GeoRestrictionType;
  Quantity: number;
  Items: string[];
}
function GeoRestriction_Serialize(data: GeoRestriction | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RestrictionType", content: data["RestrictionType"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Location", content: x}))},
  ]};
}
function GeoRestriction_Parse(node: xmlP.XmlNode): GeoRestriction {
  return {
    RestrictionType: node.first("RestrictionType", true, x => (x.content ?? '') as GeoRestrictionType),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Location").map(x => x.content ?? ''),
  };
}

// refs: 10 - tags: input, named, enum, output
export type GeoRestrictionType =
| "blacklist"
| "whitelist"
| "none"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type HttpVersion =
| "http1.1"
| "http2"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DistributionConfigWithTags {
  DistributionConfig: DistributionConfig;
  Tags: Tags;
}
function DistributionConfigWithTags_Serialize(data: DistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DistributionConfig", ...DistributionConfig_Serialize(data["DistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

// refs: 4 - tags: input, named, interface, output
export interface Tags {
  Items: Tag[];
}
function Tags_Serialize(data: Tags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}
function Tags_Parse(node: xmlP.XmlNode): Tags {
  return {
    Items: node.getList("Items", "Tag").map(Tag_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function Tag_Serialize(data: Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

// refs: 3 - tags: input, named, interface, output
export interface InvalidationBatch {
  Paths: Paths;
  CallerReference: string;
}
function InvalidationBatch_Serialize(data: InvalidationBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Paths", ...Paths_Serialize(data["Paths"])},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
  ]};
}
function InvalidationBatch_Parse(node: xmlP.XmlNode): InvalidationBatch {
  return {
    ...node.strings({
      required: {"CallerReference":true},
    }),
    Paths: node.first("Paths", true, Paths_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface Paths {
  Quantity: number;
  Items: string[];
}
function Paths_Serialize(data: Paths | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Path", content: x}))},
  ]};
}
function Paths_Parse(node: xmlP.XmlNode): Paths {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Path").map(x => x.content ?? ''),
  };
}

// refs: 8 - tags: input, named, interface, output
export interface StreamingDistributionConfig {
  CallerReference: string;
  S3Origin: S3Origin;
  Aliases?: Aliases | null;
  Comment: string;
  Logging?: StreamingLoggingConfig | null;
  TrustedSigners: TrustedSigners;
  PriceClass?: PriceClass | null;
  Enabled: boolean;
}
function StreamingDistributionConfig_Serialize(data: StreamingDistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "S3Origin", ...S3Origin_Serialize(data["S3Origin"])},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...StreamingLoggingConfig_Serialize(data["Logging"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}
function StreamingDistributionConfig_Parse(node: xmlP.XmlNode): StreamingDistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
    }),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Logging: node.first("Logging", false, StreamingLoggingConfig_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 9 - tags: input, named, interface, output
export interface S3Origin {
  DomainName: string;
  OriginAccessIdentity: string;
}
function S3Origin_Serialize(data: S3Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3Origin_Parse(node: xmlP.XmlNode): S3Origin {
  return node.strings({
    required: {"DomainName":true,"OriginAccessIdentity":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface StreamingLoggingConfig {
  Enabled: boolean;
  Bucket: string;
  Prefix: string;
}
function StreamingLoggingConfig_Serialize(data: StreamingLoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function StreamingLoggingConfig_Parse(node: xmlP.XmlNode): StreamingLoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, interface
export interface StreamingDistributionConfigWithTags {
  StreamingDistributionConfig: StreamingDistributionConfig;
  Tags: Tags;
}
function StreamingDistributionConfigWithTags_Serialize(data: StreamingDistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(data["StreamingDistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface TagKeys {
  Items?: string[] | null;
}
function TagKeys_Serialize(data: TagKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Key", content: x}))},
  ]};
}

// refs: 3 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentity {
  Id: string;
  S3CanonicalUserId: string;
  CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig | null;
}
function CloudFrontOriginAccessIdentity_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentity {
  return {
    ...node.strings({
      required: {"Id":true,"S3CanonicalUserId":true},
    }),
    CloudFrontOriginAccessIdentityConfig: node.first("CloudFrontOriginAccessIdentityConfig", false, CloudFrontOriginAccessIdentityConfig_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface Distribution {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  InProgressInvalidationBatches: number;
  DomainName: string;
  ActiveTrustedSigners: ActiveTrustedSigners;
  DistributionConfig: DistributionConfig;
}
function Distribution_Parse(node: xmlP.XmlNode): Distribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    InProgressInvalidationBatches: node.first("InProgressInvalidationBatches", true, x => parseInt(x.content ?? '0')),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    DistributionConfig: node.first("DistributionConfig", true, DistributionConfig_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface ActiveTrustedSigners {
  Enabled: boolean;
  Quantity: number;
  Items: Signer[];
}
function ActiveTrustedSigners_Parse(node: xmlP.XmlNode): ActiveTrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Signer").map(Signer_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface Signer {
  AwsAccountNumber?: string | null;
  KeyPairIds?: KeyPairIds | null;
}
function Signer_Parse(node: xmlP.XmlNode): Signer {
  return {
    ...node.strings({
      optional: {"AwsAccountNumber":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface KeyPairIds {
  Quantity: number;
  Items: string[];
}
function KeyPairIds_Parse(node: xmlP.XmlNode): KeyPairIds {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyPairId").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface Invalidation {
  Id: string;
  Status: string;
  CreateTime: Date | number;
  InvalidationBatch: InvalidationBatch;
}
function Invalidation_Parse(node: xmlP.XmlNode): Invalidation {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
    InvalidationBatch: node.first("InvalidationBatch", true, InvalidationBatch_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface StreamingDistribution {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime?: Date | number | null;
  DomainName: string;
  ActiveTrustedSigners: ActiveTrustedSigners;
  StreamingDistributionConfig: StreamingDistributionConfig;
}
function StreamingDistribution_Parse(node: xmlP.XmlNode): StreamingDistribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", false, x => xmlP.parseTimestamp(x.content)),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    StreamingDistributionConfig: node.first("StreamingDistributionConfig", true, StreamingDistributionConfig_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentityList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: CloudFrontOriginAccessIdentitySummary[];
}
function CloudFrontOriginAccessIdentityList_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentityList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentitySummary {
  Id: string;
  S3CanonicalUserId: string;
  Comment: string;
}
function CloudFrontOriginAccessIdentitySummary_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentitySummary {
  return node.strings({
    required: {"Id":true,"S3CanonicalUserId":true,"Comment":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface DistributionList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: DistributionSummary[];
}
function DistributionList_Parse(node: xmlP.XmlNode): DistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionSummary").map(DistributionSummary_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DistributionSummary {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  DomainName: string;
  Aliases: Aliases;
  Origins: Origins;
  DefaultCacheBehavior: DefaultCacheBehavior;
  CacheBehaviors: CacheBehaviors;
  CustomErrorResponses: CustomErrorResponses;
  Comment: string;
  PriceClass: PriceClass;
  Enabled: boolean;
  ViewerCertificate: ViewerCertificate;
  Restrictions: Restrictions;
  WebACLId: string;
  HttpVersion: HttpVersion;
  IsIPV6Enabled: boolean;
}
function DistributionSummary_Parse(node: xmlP.XmlNode): DistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true,"WebACLId":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", true, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", true, CustomErrorResponses_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", true, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", true, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", true, x => (x.content ?? '') as HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface InvalidationList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: InvalidationSummary[];
}
function InvalidationList_Parse(node: xmlP.XmlNode): InvalidationList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface InvalidationSummary {
  Id: string;
  CreateTime: Date | number;
  Status: string;
}
function InvalidationSummary_Parse(node: xmlP.XmlNode): InvalidationSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface StreamingDistributionList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: StreamingDistributionSummary[];
}
function StreamingDistributionList_Parse(node: xmlP.XmlNode): StreamingDistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface StreamingDistributionSummary {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  DomainName: string;
  S3Origin: S3Origin;
  Aliases: Aliases;
  TrustedSigners: TrustedSigners;
  Comment: string;
  PriceClass: PriceClass;
  Enabled: boolean;
}
function StreamingDistributionSummary_Parse(node: xmlP.XmlNode): StreamingDistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}
