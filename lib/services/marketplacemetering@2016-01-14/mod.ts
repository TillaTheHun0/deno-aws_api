// Autogenerated API client for: AWSMarketplace Metering

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class MarketplaceMetering {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MarketplaceMetering.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-01-14",
    "endpointPrefix": "metering.marketplace",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWSMarketplace Metering",
    "serviceId": "Marketplace Metering",
    "signatureVersion": "v4",
    "signingName": "aws-marketplace",
    "targetPrefix": "AWSMPMeteringService",
    "uid": "meteringmarketplace-2016-01-14"
  };

  async batchMeterUsage(
    {abortSignal, ...params}: RequestConfig & s.BatchMeterUsageRequest,
  ): Promise<s.BatchMeterUsageResult> {
    const body: jsonP.JSONObject = {
      UsageRecords: params["UsageRecords"]?.map(x => fromUsageRecord(x)),
      ProductCode: params["ProductCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchMeterUsage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toUsageRecordResult],
        "UnprocessedRecords": [toUsageRecord],
      },
    }, await resp.json());
  }

  async meterUsage(
    {abortSignal, ...params}: RequestConfig & s.MeterUsageRequest,
  ): Promise<s.MeterUsageResult> {
    const body: jsonP.JSONObject = {
      ProductCode: params["ProductCode"],
      Timestamp: jsonP.serializeDate_unixTimestamp(params["Timestamp"]),
      UsageDimension: params["UsageDimension"],
      UsageQuantity: params["UsageQuantity"],
      DryRun: params["DryRun"],
      UsageAllocations: params["UsageAllocations"]?.map(x => fromUsageAllocation(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "MeterUsage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MeteringRecordId": "s",
      },
    }, await resp.json());
  }

  async registerUsage(
    {abortSignal, ...params}: RequestConfig & s.RegisterUsageRequest,
  ): Promise<s.RegisterUsageResult> {
    const body: jsonP.JSONObject = {
      ProductCode: params["ProductCode"],
      PublicKeyVersion: params["PublicKeyVersion"],
      Nonce: params["Nonce"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterUsage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PublicKeyRotationTimestamp": "d",
        "Signature": "s",
      },
    }, await resp.json());
  }

  async resolveCustomer(
    {abortSignal, ...params}: RequestConfig & s.ResolveCustomerRequest,
  ): Promise<s.ResolveCustomerResult> {
    const body: jsonP.JSONObject = {
      RegistrationToken: params["RegistrationToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResolveCustomer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CustomerIdentifier": "s",
        "ProductCode": "s",
      },
    }, await resp.json());
  }

}

function fromUsageRecord(input?: s.UsageRecord | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Timestamp: jsonP.serializeDate_unixTimestamp(input["Timestamp"]),
    CustomerIdentifier: input["CustomerIdentifier"],
    Dimension: input["Dimension"],
    Quantity: input["Quantity"],
    UsageAllocations: input["UsageAllocations"]?.map(x => fromUsageAllocation(x)),
  }
}
function toUsageRecord(root: jsonP.JSONValue): s.UsageRecord {
  return jsonP.readObj({
    required: {
      "Timestamp": "d",
      "CustomerIdentifier": "s",
      "Dimension": "s",
    },
    optional: {
      "Quantity": "n",
      "UsageAllocations": [toUsageAllocation],
    },
  }, root);
}

function fromUsageAllocation(input?: s.UsageAllocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllocatedUsageQuantity: input["AllocatedUsageQuantity"],
    Tags: input["Tags"]?.map(x => fromTag(x)),
  }
}
function toUsageAllocation(root: jsonP.JSONValue): s.UsageAllocation {
  return jsonP.readObj({
    required: {
      "AllocatedUsageQuantity": "n",
    },
    optional: {
      "Tags": [toTag],
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function toUsageRecordResult(root: jsonP.JSONValue): s.UsageRecordResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "UsageRecord": toUsageRecord,
      "MeteringRecordId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UsageRecordResultStatus>(x),
    },
  }, root);
}
