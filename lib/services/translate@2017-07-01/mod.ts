// Autogenerated API client for: Amazon Translate

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Translate {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Translate.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-07-01",
    "endpointPrefix": "translate",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Translate",
    "serviceId": "Translate",
    "signatureVersion": "v4",
    "signingName": "translate",
    "targetPrefix": "AWSShineFrontendService_20170701",
    "uid": "translate-2017-07-01"
  };

  async createParallelData(
    {abortSignal, ...params}: RequestConfig & CreateParallelDataRequest,
  ): Promise<CreateParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      ParallelDataConfig: fromParallelDataConfig(params["ParallelDataConfig"]),
      EncryptionKey: fromEncryptionKey(params["EncryptionKey"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
      },
    }, await resp.json());
  }

  async deleteParallelData(
    {abortSignal, ...params}: RequestConfig & DeleteParallelDataRequest,
  ): Promise<DeleteParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
      },
    }, await resp.json());
  }

  async deleteTerminology(
    {abortSignal, ...params}: RequestConfig & DeleteTerminologyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTerminology",
    });
  }

  async describeTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & DescribeTextTranslationJobRequest,
  ): Promise<DescribeTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TextTranslationJobProperties": toTextTranslationJobProperties,
      },
    }, await resp.json());
  }

  async getParallelData(
    {abortSignal, ...params}: RequestConfig & GetParallelDataRequest,
  ): Promise<GetParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParallelDataProperties": toParallelDataProperties,
        "DataLocation": toParallelDataDataLocation,
        "AuxiliaryDataLocation": toParallelDataDataLocation,
        "LatestUpdateAttemptAuxiliaryDataLocation": toParallelDataDataLocation,
      },
    }, await resp.json());
  }

  async getTerminology(
    {abortSignal, ...params}: RequestConfig & GetTerminologyRequest,
  ): Promise<GetTerminologyResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TerminologyDataFormat: params["TerminologyDataFormat"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTerminology",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyProperties": toTerminologyProperties,
        "TerminologyDataLocation": toTerminologyDataLocation,
      },
    }, await resp.json());
  }

  async importTerminology(
    {abortSignal, ...params}: RequestConfig & ImportTerminologyRequest,
  ): Promise<ImportTerminologyResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      MergeStrategy: params["MergeStrategy"],
      Description: params["Description"],
      TerminologyData: fromTerminologyData(params["TerminologyData"]),
      EncryptionKey: fromEncryptionKey(params["EncryptionKey"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportTerminology",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyProperties": toTerminologyProperties,
      },
    }, await resp.json());
  }

  async listParallelData(
    {abortSignal, ...params}: RequestConfig & ListParallelDataRequest = {},
  ): Promise<ListParallelDataResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParallelDataPropertiesList": [toParallelDataProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTerminologies(
    {abortSignal, ...params}: RequestConfig & ListTerminologiesRequest = {},
  ): Promise<ListTerminologiesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTerminologies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyPropertiesList": [toTerminologyProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTextTranslationJobs(
    {abortSignal, ...params}: RequestConfig & ListTextTranslationJobsRequest = {},
  ): Promise<ListTextTranslationJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromTextTranslationJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTextTranslationJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TextTranslationJobPropertiesList": [toTextTranslationJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & StartTextTranslationJobRequest,
  ): Promise<StartTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      SourceLanguageCode: params["SourceLanguageCode"],
      TargetLanguageCodes: params["TargetLanguageCodes"],
      TerminologyNames: params["TerminologyNames"],
      ParallelDataNames: params["ParallelDataNames"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & StopTextTranslationJobRequest,
  ): Promise<StopTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      },
    }, await resp.json());
  }

  async translateText(
    {abortSignal, ...params}: RequestConfig & TranslateTextRequest,
  ): Promise<TranslateTextResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      TerminologyNames: params["TerminologyNames"],
      SourceLanguageCode: params["SourceLanguageCode"],
      TargetLanguageCode: params["TargetLanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TranslateText",
    });
    return jsonP.readObj({
      required: {
        "TranslatedText": "s",
        "SourceLanguageCode": "s",
        "TargetLanguageCode": "s",
      },
      optional: {
        "AppliedTerminologies": [toAppliedTerminology],
      },
    }, await resp.json());
  }

  async updateParallelData(
    {abortSignal, ...params}: RequestConfig & UpdateParallelDataRequest,
  ): Promise<UpdateParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      ParallelDataConfig: fromParallelDataConfig(params["ParallelDataConfig"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
        "LatestUpdateAttemptStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
        "LatestUpdateAttemptAt": "d",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface CreateParallelDataRequest {
  Name: string;
  Description?: string | null;
  ParallelDataConfig: ParallelDataConfig;
  EncryptionKey?: EncryptionKey | null;
  ClientToken: string;
}

// refs: 1 - tags: named, input
export interface DeleteParallelDataRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteTerminologyRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DescribeTextTranslationJobRequest {
  JobId: string;
}

// refs: 1 - tags: named, input
export interface GetParallelDataRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetTerminologyRequest {
  Name: string;
  TerminologyDataFormat: TerminologyDataFormat;
}

// refs: 1 - tags: named, input
export interface ImportTerminologyRequest {
  Name: string;
  MergeStrategy: MergeStrategy;
  Description?: string | null;
  TerminologyData: TerminologyData;
  EncryptionKey?: EncryptionKey | null;
}

// refs: 1 - tags: named, input
export interface ListParallelDataRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTerminologiesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTextTranslationJobsRequest {
  Filter?: TextTranslationJobFilter | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface StartTextTranslationJobRequest {
  JobName?: string | null;
  InputDataConfig: InputDataConfig;
  OutputDataConfig: OutputDataConfig;
  DataAccessRoleArn: string;
  SourceLanguageCode: string;
  TargetLanguageCodes: string[];
  TerminologyNames?: string[] | null;
  ParallelDataNames?: string[] | null;
  ClientToken: string;
}

// refs: 1 - tags: named, input
export interface StopTextTranslationJobRequest {
  JobId: string;
}

// refs: 1 - tags: named, input
export interface TranslateTextRequest {
  Text: string;
  TerminologyNames?: string[] | null;
  SourceLanguageCode: string;
  TargetLanguageCode: string;
}

// refs: 1 - tags: named, input
export interface UpdateParallelDataRequest {
  Name: string;
  Description?: string | null;
  ParallelDataConfig: ParallelDataConfig;
  ClientToken: string;
}

// refs: 1 - tags: named, output
export interface CreateParallelDataResponse {
  Name?: string | null;
  Status?: ParallelDataStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteParallelDataResponse {
  Name?: string | null;
  Status?: ParallelDataStatus | null;
}

// refs: 1 - tags: named, output
export interface DescribeTextTranslationJobResponse {
  TextTranslationJobProperties?: TextTranslationJobProperties | null;
}

// refs: 1 - tags: named, output
export interface GetParallelDataResponse {
  ParallelDataProperties?: ParallelDataProperties | null;
  DataLocation?: ParallelDataDataLocation | null;
  AuxiliaryDataLocation?: ParallelDataDataLocation | null;
  LatestUpdateAttemptAuxiliaryDataLocation?: ParallelDataDataLocation | null;
}

// refs: 1 - tags: named, output
export interface GetTerminologyResponse {
  TerminologyProperties?: TerminologyProperties | null;
  TerminologyDataLocation?: TerminologyDataLocation | null;
}

// refs: 1 - tags: named, output
export interface ImportTerminologyResponse {
  TerminologyProperties?: TerminologyProperties | null;
}

// refs: 1 - tags: named, output
export interface ListParallelDataResponse {
  ParallelDataPropertiesList?: ParallelDataProperties[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTerminologiesResponse {
  TerminologyPropertiesList?: TerminologyProperties[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTextTranslationJobsResponse {
  TextTranslationJobPropertiesList?: TextTranslationJobProperties[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface StartTextTranslationJobResponse {
  JobId?: string | null;
  JobStatus?: JobStatus | null;
}

// refs: 1 - tags: named, output
export interface StopTextTranslationJobResponse {
  JobId?: string | null;
  JobStatus?: JobStatus | null;
}

// refs: 1 - tags: named, output
export interface TranslateTextResponse {
  TranslatedText: string;
  SourceLanguageCode: string;
  TargetLanguageCode: string;
  AppliedTerminologies?: AppliedTerminology[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateParallelDataResponse {
  Name?: string | null;
  Status?: ParallelDataStatus | null;
  LatestUpdateAttemptStatus?: ParallelDataStatus | null;
  LatestUpdateAttemptAt?: Date | number | null;
}

// refs: 4 - tags: input, named, interface, output
export interface ParallelDataConfig {
  S3Uri: string;
  Format: ParallelDataFormat;
}
function fromParallelDataConfig(input?: ParallelDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    Format: input["Format"],
  }
}
function toParallelDataConfig(root: jsonP.JSONValue): ParallelDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataFormat>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ParallelDataFormat =
| "TSV"
| "CSV"
| "TMX"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface EncryptionKey {
  Type: EncryptionKeyType;
  Id: string;
}
function fromEncryptionKey(input?: EncryptionKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Id: input["Id"],
  }
}
function toEncryptionKey(root: jsonP.JSONValue): EncryptionKey {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionKeyType>(x),
      "Id": "s",
    },
    optional: {},
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type EncryptionKeyType =
| "KMS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type TerminologyDataFormat =
| "CSV"
| "TMX"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type MergeStrategy =
| "OVERWRITE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TerminologyData {
  File: Uint8Array | string;
  Format: TerminologyDataFormat;
}
function fromTerminologyData(input?: TerminologyData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    File: jsonP.serializeBlob(input["File"]),
    Format: input["Format"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TextTranslationJobFilter {
  JobName?: string | null;
  JobStatus?: JobStatus | null;
  SubmittedBeforeTime?: Date | number | null;
  SubmittedAfterTime?: Date | number | null;
}
function fromTextTranslationJobFilter(input?: TextTranslationJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmittedBeforeTime: jsonP.serializeDate_unixTimestamp(input["SubmittedBeforeTime"]),
    SubmittedAfterTime: jsonP.serializeDate_unixTimestamp(input["SubmittedAfterTime"]),
  }
}

// refs: 5 - tags: input, named, enum, output
export type JobStatus =
| "SUBMITTED"
| "IN_PROGRESS"
| "COMPLETED"
| "COMPLETED_WITH_ERROR"
| "FAILED"
| "STOP_REQUESTED"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface InputDataConfig {
  S3Uri: string;
  ContentType: string;
}
function fromInputDataConfig(input?: InputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    ContentType: input["ContentType"],
  }
}
function toInputDataConfig(root: jsonP.JSONValue): InputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "ContentType": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface OutputDataConfig {
  S3Uri: string;
}
function fromOutputDataConfig(input?: OutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toOutputDataConfig(root: jsonP.JSONValue): OutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: output, named, enum
export type ParallelDataStatus =
| "CREATING"
| "UPDATING"
| "ACTIVE"
| "DELETING"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface TextTranslationJobProperties {
  JobId?: string | null;
  JobName?: string | null;
  JobStatus?: JobStatus | null;
  JobDetails?: JobDetails | null;
  SourceLanguageCode?: string | null;
  TargetLanguageCodes?: string[] | null;
  TerminologyNames?: string[] | null;
  ParallelDataNames?: string[] | null;
  Message?: string | null;
  SubmittedTime?: Date | number | null;
  EndTime?: Date | number | null;
  InputDataConfig?: InputDataConfig | null;
  OutputDataConfig?: OutputDataConfig | null;
  DataAccessRoleArn?: string | null;
}
function toTextTranslationJobProperties(root: jsonP.JSONValue): TextTranslationJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
      "JobDetails": toJobDetails,
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "TerminologyNames": ["s"],
      "ParallelDataNames": ["s"],
      "Message": "s",
      "SubmittedTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "DataAccessRoleArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface JobDetails {
  TranslatedDocumentsCount?: number | null;
  DocumentsWithErrorsCount?: number | null;
  InputDocumentsCount?: number | null;
}
function toJobDetails(root: jsonP.JSONValue): JobDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranslatedDocumentsCount": "n",
      "DocumentsWithErrorsCount": "n",
      "InputDocumentsCount": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ParallelDataProperties {
  Name?: string | null;
  Arn?: string | null;
  Description?: string | null;
  Status?: ParallelDataStatus | null;
  SourceLanguageCode?: string | null;
  TargetLanguageCodes?: string[] | null;
  ParallelDataConfig?: ParallelDataConfig | null;
  Message?: string | null;
  ImportedDataSize?: number | null;
  ImportedRecordCount?: number | null;
  FailedRecordCount?: number | null;
  SkippedRecordCount?: number | null;
  EncryptionKey?: EncryptionKey | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
  LatestUpdateAttemptStatus?: ParallelDataStatus | null;
  LatestUpdateAttemptAt?: Date | number | null;
}
function toParallelDataProperties(root: jsonP.JSONValue): ParallelDataProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Arn": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "ParallelDataConfig": toParallelDataConfig,
      "Message": "s",
      "ImportedDataSize": "n",
      "ImportedRecordCount": "n",
      "FailedRecordCount": "n",
      "SkippedRecordCount": "n",
      "EncryptionKey": toEncryptionKey,
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "LatestUpdateAttemptStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ParallelDataStatus>(x),
      "LatestUpdateAttemptAt": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface ParallelDataDataLocation {
  RepositoryType: string;
  Location: string;
}
function toParallelDataDataLocation(root: jsonP.JSONValue): ParallelDataDataLocation {
  return jsonP.readObj({
    required: {
      "RepositoryType": "s",
      "Location": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface TerminologyProperties {
  Name?: string | null;
  Description?: string | null;
  Arn?: string | null;
  SourceLanguageCode?: string | null;
  TargetLanguageCodes?: string[] | null;
  EncryptionKey?: EncryptionKey | null;
  SizeBytes?: number | null;
  TermCount?: number | null;
  CreatedAt?: Date | number | null;
  LastUpdatedAt?: Date | number | null;
}
function toTerminologyProperties(root: jsonP.JSONValue): TerminologyProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "Arn": "s",
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "EncryptionKey": toEncryptionKey,
      "SizeBytes": "n",
      "TermCount": "n",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TerminologyDataLocation {
  RepositoryType: string;
  Location: string;
}
function toTerminologyDataLocation(root: jsonP.JSONValue): TerminologyDataLocation {
  return jsonP.readObj({
    required: {
      "RepositoryType": "s",
      "Location": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AppliedTerminology {
  Name?: string | null;
  Terms?: Term[] | null;
}
function toAppliedTerminology(root: jsonP.JSONValue): AppliedTerminology {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Terms": [toTerm],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Term {
  SourceText?: string | null;
  TargetText?: string | null;
}
function toTerm(root: jsonP.JSONValue): Term {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceText": "s",
      "TargetText": "s",
    },
  }, root);
}
