// Autogenerated API client for: Amazon Translate

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Translate {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Translate.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-07-01",
    "endpointPrefix": "translate",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Translate",
    "serviceId": "Translate",
    "signatureVersion": "v4",
    "signingName": "translate",
    "targetPrefix": "AWSShineFrontendService_20170701",
    "uid": "translate-2017-07-01"
  };

  async createParallelData(
    {abortSignal, ...params}: RequestConfig & s.CreateParallelDataRequest,
  ): Promise<s.CreateParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      ParallelDataConfig: fromParallelDataConfig(params["ParallelDataConfig"]),
      EncryptionKey: fromEncryptionKey(params["EncryptionKey"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
      },
    }, await resp.json());
  }

  async deleteParallelData(
    {abortSignal, ...params}: RequestConfig & s.DeleteParallelDataRequest,
  ): Promise<s.DeleteParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
      },
    }, await resp.json());
  }

  async deleteTerminology(
    {abortSignal, ...params}: RequestConfig & s.DeleteTerminologyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTerminology",
    });
  }

  async describeTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeTextTranslationJobRequest,
  ): Promise<s.DescribeTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TextTranslationJobProperties": toTextTranslationJobProperties,
      },
    }, await resp.json());
  }

  async getParallelData(
    {abortSignal, ...params}: RequestConfig & s.GetParallelDataRequest,
  ): Promise<s.GetParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParallelDataProperties": toParallelDataProperties,
        "DataLocation": toParallelDataDataLocation,
        "AuxiliaryDataLocation": toParallelDataDataLocation,
        "LatestUpdateAttemptAuxiliaryDataLocation": toParallelDataDataLocation,
      },
    }, await resp.json());
  }

  async getTerminology(
    {abortSignal, ...params}: RequestConfig & s.GetTerminologyRequest,
  ): Promise<s.GetTerminologyResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TerminologyDataFormat: params["TerminologyDataFormat"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTerminology",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyProperties": toTerminologyProperties,
        "TerminologyDataLocation": toTerminologyDataLocation,
      },
    }, await resp.json());
  }

  async importTerminology(
    {abortSignal, ...params}: RequestConfig & s.ImportTerminologyRequest,
  ): Promise<s.ImportTerminologyResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      MergeStrategy: params["MergeStrategy"],
      Description: params["Description"],
      TerminologyData: fromTerminologyData(params["TerminologyData"]),
      EncryptionKey: fromEncryptionKey(params["EncryptionKey"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportTerminology",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyProperties": toTerminologyProperties,
      },
    }, await resp.json());
  }

  async listParallelData(
    {abortSignal, ...params}: RequestConfig & s.ListParallelDataRequest = {},
  ): Promise<s.ListParallelDataResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ParallelDataPropertiesList": [toParallelDataProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTerminologies(
    {abortSignal, ...params}: RequestConfig & s.ListTerminologiesRequest = {},
  ): Promise<s.ListTerminologiesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTerminologies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TerminologyPropertiesList": [toTerminologyProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTextTranslationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListTextTranslationJobsRequest = {},
  ): Promise<s.ListTextTranslationJobsResponse> {
    const body: jsonP.JSONObject = {
      Filter: fromTextTranslationJobFilter(params["Filter"]),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTextTranslationJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TextTranslationJobPropertiesList": [toTextTranslationJobProperties],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & s.StartTextTranslationJobRequest,
  ): Promise<s.StartTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      InputDataConfig: fromInputDataConfig(params["InputDataConfig"]),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      DataAccessRoleArn: params["DataAccessRoleArn"],
      SourceLanguageCode: params["SourceLanguageCode"],
      TargetLanguageCodes: params["TargetLanguageCodes"],
      TerminologyNames: params["TerminologyNames"],
      ParallelDataNames: params["ParallelDataNames"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async stopTextTranslationJob(
    {abortSignal, ...params}: RequestConfig & s.StopTextTranslationJobRequest,
  ): Promise<s.StopTextTranslationJobResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTextTranslationJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async translateText(
    {abortSignal, ...params}: RequestConfig & s.TranslateTextRequest,
  ): Promise<s.TranslateTextResponse> {
    const body: jsonP.JSONObject = {
      Text: params["Text"],
      TerminologyNames: params["TerminologyNames"],
      SourceLanguageCode: params["SourceLanguageCode"],
      TargetLanguageCode: params["TargetLanguageCode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TranslateText",
    });
    return jsonP.readObj({
      required: {
        "TranslatedText": "s",
        "SourceLanguageCode": "s",
        "TargetLanguageCode": "s",
      },
      optional: {
        "AppliedTerminologies": [toAppliedTerminology],
      },
    }, await resp.json());
  }

  async updateParallelData(
    {abortSignal, ...params}: RequestConfig & s.UpdateParallelDataRequest,
  ): Promise<s.UpdateParallelDataResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      ParallelDataConfig: fromParallelDataConfig(params["ParallelDataConfig"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateParallelData",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
        "LatestUpdateAttemptStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
        "LatestUpdateAttemptAt": "d",
      },
    }, await resp.json());
  }

}

function fromParallelDataConfig(input?: s.ParallelDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    Format: input["Format"],
  }
}
function toParallelDataConfig(root: jsonP.JSONValue): s.ParallelDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataFormat>(x),
    },
    optional: {},
  }, root);
}

function fromEncryptionKey(input?: s.EncryptionKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Id: input["Id"],
  }
}
function toEncryptionKey(root: jsonP.JSONValue): s.EncryptionKey {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionKeyType>(x),
      "Id": "s",
    },
    optional: {},
  }, root);
}

function fromTerminologyData(input?: s.TerminologyData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    File: jsonP.serializeBlob(input["File"]),
    Format: input["Format"],
  }
}

function fromTextTranslationJobFilter(input?: s.TextTranslationJobFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    JobStatus: input["JobStatus"],
    SubmittedBeforeTime: jsonP.serializeDate_unixTimestamp(input["SubmittedBeforeTime"]),
    SubmittedAfterTime: jsonP.serializeDate_unixTimestamp(input["SubmittedAfterTime"]),
  }
}

function fromInputDataConfig(input?: s.InputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    ContentType: input["ContentType"],
  }
}
function toInputDataConfig(root: jsonP.JSONValue): s.InputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "ContentType": "s",
    },
    optional: {},
  }, root);
}

function fromOutputDataConfig(input?: s.OutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toOutputDataConfig(root: jsonP.JSONValue): s.OutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function toTextTranslationJobProperties(root: jsonP.JSONValue): s.TextTranslationJobProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "JobDetails": toJobDetails,
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "TerminologyNames": ["s"],
      "ParallelDataNames": ["s"],
      "Message": "s",
      "SubmittedTime": "d",
      "EndTime": "d",
      "InputDataConfig": toInputDataConfig,
      "OutputDataConfig": toOutputDataConfig,
      "DataAccessRoleArn": "s",
    },
  }, root);
}

function toJobDetails(root: jsonP.JSONValue): s.JobDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "TranslatedDocumentsCount": "n",
      "DocumentsWithErrorsCount": "n",
      "InputDocumentsCount": "n",
    },
  }, root);
}

function toParallelDataProperties(root: jsonP.JSONValue): s.ParallelDataProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Arn": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "ParallelDataConfig": toParallelDataConfig,
      "Message": "s",
      "ImportedDataSize": "n",
      "ImportedRecordCount": "n",
      "FailedRecordCount": "n",
      "SkippedRecordCount": "n",
      "EncryptionKey": toEncryptionKey,
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
      "LatestUpdateAttemptStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParallelDataStatus>(x),
      "LatestUpdateAttemptAt": "d",
    },
  }, root);
}

function toParallelDataDataLocation(root: jsonP.JSONValue): s.ParallelDataDataLocation {
  return jsonP.readObj({
    required: {
      "RepositoryType": "s",
      "Location": "s",
    },
    optional: {},
  }, root);
}

function toTerminologyProperties(root: jsonP.JSONValue): s.TerminologyProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "Arn": "s",
      "SourceLanguageCode": "s",
      "TargetLanguageCodes": ["s"],
      "EncryptionKey": toEncryptionKey,
      "SizeBytes": "n",
      "TermCount": "n",
      "CreatedAt": "d",
      "LastUpdatedAt": "d",
    },
  }, root);
}

function toTerminologyDataLocation(root: jsonP.JSONValue): s.TerminologyDataLocation {
  return jsonP.readObj({
    required: {
      "RepositoryType": "s",
      "Location": "s",
    },
    optional: {},
  }, root);
}

function toAppliedTerminology(root: jsonP.JSONValue): s.AppliedTerminology {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Terms": [toTerm],
    },
  }, root);
}

function toTerm(root: jsonP.JSONValue): s.Term {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceText": "s",
      "TargetText": "s",
    },
  }, root);
}
