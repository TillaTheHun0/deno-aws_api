// Autogenerated API client for: AWS Direct Connect

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class DirectConnect {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DirectConnect.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-10-25",
    "endpointPrefix": "directconnect",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Direct Connect",
    "serviceId": "Direct Connect",
    "signatureVersion": "v4",
    "targetPrefix": "OvertureService",
    "uid": "directconnect-2012-10-25"
  };

  async acceptDirectConnectGatewayAssociationProposal(
    {abortSignal, ...params}: RequestConfig & s.AcceptDirectConnectGatewayAssociationProposalRequest,
  ): Promise<s.AcceptDirectConnectGatewayAssociationProposalResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      proposalId: params["proposalId"],
      associatedGatewayOwnerAccount: params["associatedGatewayOwnerAccount"],
      overrideAllowedPrefixesToDirectConnectGateway: params["overrideAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptDirectConnectGatewayAssociationProposal",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociation": toDirectConnectGatewayAssociation,
      },
    }, await resp.json());
  }

  async allocateConnectionOnInterconnect(
    {abortSignal, ...params}: RequestConfig & s.AllocateConnectionOnInterconnectRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      bandwidth: params["bandwidth"],
      connectionName: params["connectionName"],
      ownerAccount: params["ownerAccount"],
      interconnectId: params["interconnectId"],
      vlan: params["vlan"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateConnectionOnInterconnect",
    });
    return toConnection(await resp.json());
  }

  async allocateHostedConnection(
    {abortSignal, ...params}: RequestConfig & s.AllocateHostedConnectionRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      ownerAccount: params["ownerAccount"],
      bandwidth: params["bandwidth"],
      connectionName: params["connectionName"],
      vlan: params["vlan"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateHostedConnection",
    });
    return toConnection(await resp.json());
  }

  async allocatePrivateVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.AllocatePrivateVirtualInterfaceRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      ownerAccount: params["ownerAccount"],
      newPrivateVirtualInterfaceAllocation: fromNewPrivateVirtualInterfaceAllocation(params["newPrivateVirtualInterfaceAllocation"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocatePrivateVirtualInterface",
    });
    return toVirtualInterface(await resp.json());
  }

  async allocatePublicVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.AllocatePublicVirtualInterfaceRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      ownerAccount: params["ownerAccount"],
      newPublicVirtualInterfaceAllocation: fromNewPublicVirtualInterfaceAllocation(params["newPublicVirtualInterfaceAllocation"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocatePublicVirtualInterface",
    });
    return toVirtualInterface(await resp.json());
  }

  async allocateTransitVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.AllocateTransitVirtualInterfaceRequest,
  ): Promise<s.AllocateTransitVirtualInterfaceResult> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      ownerAccount: params["ownerAccount"],
      newTransitVirtualInterfaceAllocation: fromNewTransitVirtualInterfaceAllocation(params["newTransitVirtualInterfaceAllocation"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AllocateTransitVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterface": toVirtualInterface,
      },
    }, await resp.json());
  }

  async associateConnectionWithLag(
    {abortSignal, ...params}: RequestConfig & s.AssociateConnectionWithLagRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      lagId: params["lagId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateConnectionWithLag",
    });
    return toConnection(await resp.json());
  }

  async associateHostedConnection(
    {abortSignal, ...params}: RequestConfig & s.AssociateHostedConnectionRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      parentConnectionId: params["parentConnectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateHostedConnection",
    });
    return toConnection(await resp.json());
  }

  async associateVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.AssociateVirtualInterfaceRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      connectionId: params["connectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateVirtualInterface",
    });
    return toVirtualInterface(await resp.json());
  }

  async confirmConnection(
    {abortSignal, ...params}: RequestConfig & s.ConfirmConnectionRequest,
  ): Promise<s.ConfirmConnectionResponse> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "connectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionState>(x),
      },
    }, await resp.json());
  }

  async confirmPrivateVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.ConfirmPrivateVirtualInterfaceRequest,
  ): Promise<s.ConfirmPrivateVirtualInterfaceResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      virtualGatewayId: params["virtualGatewayId"],
      directConnectGatewayId: params["directConnectGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmPrivateVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualInterfaceState>(x),
      },
    }, await resp.json());
  }

  async confirmPublicVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.ConfirmPublicVirtualInterfaceRequest,
  ): Promise<s.ConfirmPublicVirtualInterfaceResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmPublicVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualInterfaceState>(x),
      },
    }, await resp.json());
  }

  async confirmTransitVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.ConfirmTransitVirtualInterfaceRequest,
  ): Promise<s.ConfirmTransitVirtualInterfaceResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      directConnectGatewayId: params["directConnectGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConfirmTransitVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualInterfaceState>(x),
      },
    }, await resp.json());
  }

  async createBGPPeer(
    {abortSignal, ...params}: RequestConfig & s.CreateBGPPeerRequest = {},
  ): Promise<s.CreateBGPPeerResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      newBGPPeer: fromNewBGPPeer(params["newBGPPeer"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateBGPPeer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterface": toVirtualInterface,
      },
    }, await resp.json());
  }

  async createConnection(
    {abortSignal, ...params}: RequestConfig & s.CreateConnectionRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      location: params["location"],
      bandwidth: params["bandwidth"],
      connectionName: params["connectionName"],
      lagId: params["lagId"],
      tags: params["tags"]?.map(x => fromTag(x)),
      providerName: params["providerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConnection",
    });
    return toConnection(await resp.json());
  }

  async createDirectConnectGateway(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectConnectGatewayRequest,
  ): Promise<s.CreateDirectConnectGatewayResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayName: params["directConnectGatewayName"],
      amazonSideAsn: params["amazonSideAsn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDirectConnectGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGateway": toDirectConnectGateway,
      },
    }, await resp.json());
  }

  async createDirectConnectGatewayAssociation(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectConnectGatewayAssociationRequest,
  ): Promise<s.CreateDirectConnectGatewayAssociationResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      gatewayId: params["gatewayId"],
      addAllowedPrefixesToDirectConnectGateway: params["addAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
      virtualGatewayId: params["virtualGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDirectConnectGatewayAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociation": toDirectConnectGatewayAssociation,
      },
    }, await resp.json());
  }

  async createDirectConnectGatewayAssociationProposal(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectConnectGatewayAssociationProposalRequest,
  ): Promise<s.CreateDirectConnectGatewayAssociationProposalResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      directConnectGatewayOwnerAccount: params["directConnectGatewayOwnerAccount"],
      gatewayId: params["gatewayId"],
      addAllowedPrefixesToDirectConnectGateway: params["addAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
      removeAllowedPrefixesToDirectConnectGateway: params["removeAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDirectConnectGatewayAssociationProposal",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociationProposal": toDirectConnectGatewayAssociationProposal,
      },
    }, await resp.json());
  }

  async createInterconnect(
    {abortSignal, ...params}: RequestConfig & s.CreateInterconnectRequest,
  ): Promise<s.Interconnect> {
    const body: jsonP.JSONObject = {
      interconnectName: params["interconnectName"],
      bandwidth: params["bandwidth"],
      location: params["location"],
      lagId: params["lagId"],
      tags: params["tags"]?.map(x => fromTag(x)),
      providerName: params["providerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInterconnect",
    });
    return toInterconnect(await resp.json());
  }

  async createLag(
    {abortSignal, ...params}: RequestConfig & s.CreateLagRequest,
  ): Promise<s.Lag> {
    const body: jsonP.JSONObject = {
      numberOfConnections: params["numberOfConnections"],
      location: params["location"],
      connectionsBandwidth: params["connectionsBandwidth"],
      lagName: params["lagName"],
      connectionId: params["connectionId"],
      tags: params["tags"]?.map(x => fromTag(x)),
      childConnectionTags: params["childConnectionTags"]?.map(x => fromTag(x)),
      providerName: params["providerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLag",
    });
    return toLag(await resp.json());
  }

  async createPrivateVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.CreatePrivateVirtualInterfaceRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      newPrivateVirtualInterface: fromNewPrivateVirtualInterface(params["newPrivateVirtualInterface"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePrivateVirtualInterface",
    });
    return toVirtualInterface(await resp.json());
  }

  async createPublicVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.CreatePublicVirtualInterfaceRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      newPublicVirtualInterface: fromNewPublicVirtualInterface(params["newPublicVirtualInterface"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePublicVirtualInterface",
    });
    return toVirtualInterface(await resp.json());
  }

  async createTransitVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.CreateTransitVirtualInterfaceRequest,
  ): Promise<s.CreateTransitVirtualInterfaceResult> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      newTransitVirtualInterface: fromNewTransitVirtualInterface(params["newTransitVirtualInterface"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransitVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterface": toVirtualInterface,
      },
    }, await resp.json());
  }

  async deleteBGPPeer(
    {abortSignal, ...params}: RequestConfig & s.DeleteBGPPeerRequest = {},
  ): Promise<s.DeleteBGPPeerResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      asn: params["asn"],
      customerAddress: params["customerAddress"],
      bgpPeerId: params["bgpPeerId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBGPPeer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterface": toVirtualInterface,
      },
    }, await resp.json());
  }

  async deleteConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteConnectionRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConnection",
    });
    return toConnection(await resp.json());
  }

  async deleteDirectConnectGateway(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectConnectGatewayRequest,
  ): Promise<s.DeleteDirectConnectGatewayResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDirectConnectGateway",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGateway": toDirectConnectGateway,
      },
    }, await resp.json());
  }

  async deleteDirectConnectGatewayAssociation(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectConnectGatewayAssociationRequest = {},
  ): Promise<s.DeleteDirectConnectGatewayAssociationResult> {
    const body: jsonP.JSONObject = {
      associationId: params["associationId"],
      directConnectGatewayId: params["directConnectGatewayId"],
      virtualGatewayId: params["virtualGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDirectConnectGatewayAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociation": toDirectConnectGatewayAssociation,
      },
    }, await resp.json());
  }

  async deleteDirectConnectGatewayAssociationProposal(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectConnectGatewayAssociationProposalRequest,
  ): Promise<s.DeleteDirectConnectGatewayAssociationProposalResult> {
    const body: jsonP.JSONObject = {
      proposalId: params["proposalId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDirectConnectGatewayAssociationProposal",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociationProposal": toDirectConnectGatewayAssociationProposal,
      },
    }, await resp.json());
  }

  async deleteInterconnect(
    {abortSignal, ...params}: RequestConfig & s.DeleteInterconnectRequest,
  ): Promise<s.DeleteInterconnectResponse> {
    const body: jsonP.JSONObject = {
      interconnectId: params["interconnectId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInterconnect",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "interconnectState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InterconnectState>(x),
      },
    }, await resp.json());
  }

  async deleteLag(
    {abortSignal, ...params}: RequestConfig & s.DeleteLagRequest,
  ): Promise<s.Lag> {
    const body: jsonP.JSONObject = {
      lagId: params["lagId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLag",
    });
    return toLag(await resp.json());
  }

  async deleteVirtualInterface(
    {abortSignal, ...params}: RequestConfig & s.DeleteVirtualInterfaceRequest,
  ): Promise<s.DeleteVirtualInterfaceResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVirtualInterface",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualInterfaceState>(x),
      },
    }, await resp.json());
  }

  async describeConnectionLoa(
    {abortSignal, ...params}: RequestConfig & s.DescribeConnectionLoaRequest,
  ): Promise<s.DescribeConnectionLoaResponse> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      providerName: params["providerName"],
      loaContentType: params["loaContentType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConnectionLoa",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loa": toLoa,
      },
    }, await resp.json());
  }

  async describeConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeConnectionsRequest = {},
  ): Promise<s.Connections> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "connections": [toConnection],
      },
    }, await resp.json());
  }

  async describeConnectionsOnInterconnect(
    {abortSignal, ...params}: RequestConfig & s.DescribeConnectionsOnInterconnectRequest,
  ): Promise<s.Connections> {
    const body: jsonP.JSONObject = {
      interconnectId: params["interconnectId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConnectionsOnInterconnect",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "connections": [toConnection],
      },
    }, await resp.json());
  }

  async describeDirectConnectGatewayAssociationProposals(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectConnectGatewayAssociationProposalsRequest = {},
  ): Promise<s.DescribeDirectConnectGatewayAssociationProposalsResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      proposalId: params["proposalId"],
      associatedGatewayId: params["associatedGatewayId"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectConnectGatewayAssociationProposals",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociationProposals": [toDirectConnectGatewayAssociationProposal],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeDirectConnectGatewayAssociations(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectConnectGatewayAssociationsRequest = {},
  ): Promise<s.DescribeDirectConnectGatewayAssociationsResult> {
    const body: jsonP.JSONObject = {
      associationId: params["associationId"],
      associatedGatewayId: params["associatedGatewayId"],
      directConnectGatewayId: params["directConnectGatewayId"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
      virtualGatewayId: params["virtualGatewayId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectConnectGatewayAssociations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociations": [toDirectConnectGatewayAssociation],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeDirectConnectGatewayAttachments(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectConnectGatewayAttachmentsRequest = {},
  ): Promise<s.DescribeDirectConnectGatewayAttachmentsResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      virtualInterfaceId: params["virtualInterfaceId"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectConnectGatewayAttachments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAttachments": [toDirectConnectGatewayAttachment],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeDirectConnectGateways(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectConnectGatewaysRequest = {},
  ): Promise<s.DescribeDirectConnectGatewaysResult> {
    const body: jsonP.JSONObject = {
      directConnectGatewayId: params["directConnectGatewayId"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectConnectGateways",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGateways": [toDirectConnectGateway],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeHostedConnections(
    {abortSignal, ...params}: RequestConfig & s.DescribeHostedConnectionsRequest,
  ): Promise<s.Connections> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHostedConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "connections": [toConnection],
      },
    }, await resp.json());
  }

  async describeInterconnectLoa(
    {abortSignal, ...params}: RequestConfig & s.DescribeInterconnectLoaRequest,
  ): Promise<s.DescribeInterconnectLoaResponse> {
    const body: jsonP.JSONObject = {
      interconnectId: params["interconnectId"],
      providerName: params["providerName"],
      loaContentType: params["loaContentType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInterconnectLoa",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "loa": toLoa,
      },
    }, await resp.json());
  }

  async describeInterconnects(
    {abortSignal, ...params}: RequestConfig & s.DescribeInterconnectsRequest = {},
  ): Promise<s.Interconnects> {
    const body: jsonP.JSONObject = {
      interconnectId: params["interconnectId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInterconnects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "interconnects": [toInterconnect],
      },
    }, await resp.json());
  }

  async describeLags(
    {abortSignal, ...params}: RequestConfig & s.DescribeLagsRequest = {},
  ): Promise<s.Lags> {
    const body: jsonP.JSONObject = {
      lagId: params["lagId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "lags": [toLag],
      },
    }, await resp.json());
  }

  async describeLoa(
    {abortSignal, ...params}: RequestConfig & s.DescribeLoaRequest,
  ): Promise<s.Loa> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      providerName: params["providerName"],
      loaContentType: params["loaContentType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLoa",
    });
    return toLoa(await resp.json());
  }

  async describeLocations(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.Locations> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeLocations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "locations": [toLocation],
      },
    }, await resp.json());
  }

  async describeTags(
    {abortSignal, ...params}: RequestConfig & s.DescribeTagsRequest,
  ): Promise<s.DescribeTagsResponse> {
    const body: jsonP.JSONObject = {
      resourceArns: params["resourceArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "resourceTags": [toResourceTag],
      },
    }, await resp.json());
  }

  async describeVirtualGateways(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.VirtualGateways> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeVirtualGateways",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualGateways": [toVirtualGateway],
      },
    }, await resp.json());
  }

  async describeVirtualInterfaces(
    {abortSignal, ...params}: RequestConfig & s.DescribeVirtualInterfacesRequest = {},
  ): Promise<s.VirtualInterfaces> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      virtualInterfaceId: params["virtualInterfaceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeVirtualInterfaces",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaces": [toVirtualInterface],
      },
    }, await resp.json());
  }

  async disassociateConnectionFromLag(
    {abortSignal, ...params}: RequestConfig & s.DisassociateConnectionFromLagRequest,
  ): Promise<s.Connection> {
    const body: jsonP.JSONObject = {
      connectionId: params["connectionId"],
      lagId: params["lagId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateConnectionFromLag",
    });
    return toConnection(await resp.json());
  }

  async listVirtualInterfaceTestHistory(
    {abortSignal, ...params}: RequestConfig & s.ListVirtualInterfaceTestHistoryRequest = {},
  ): Promise<s.ListVirtualInterfaceTestHistoryResponse> {
    const body: jsonP.JSONObject = {
      testId: params["testId"],
      virtualInterfaceId: params["virtualInterfaceId"],
      bgpPeers: params["bgpPeers"],
      status: params["status"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListVirtualInterfaceTestHistory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceTestHistory": [toVirtualInterfaceTestHistory],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async startBgpFailoverTest(
    {abortSignal, ...params}: RequestConfig & s.StartBgpFailoverTestRequest,
  ): Promise<s.StartBgpFailoverTestResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      bgpPeers: params["bgpPeers"],
      testDurationInMinutes: params["testDurationInMinutes"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartBgpFailoverTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceTest": toVirtualInterfaceTestHistory,
      },
    }, await resp.json());
  }

  async stopBgpFailoverTest(
    {abortSignal, ...params}: RequestConfig & s.StopBgpFailoverTestRequest,
  ): Promise<s.StopBgpFailoverTestResponse> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopBgpFailoverTest",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "virtualInterfaceTest": toVirtualInterfaceTestHistory,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDirectConnectGatewayAssociation(
    {abortSignal, ...params}: RequestConfig & s.UpdateDirectConnectGatewayAssociationRequest = {},
  ): Promise<s.UpdateDirectConnectGatewayAssociationResult> {
    const body: jsonP.JSONObject = {
      associationId: params["associationId"],
      addAllowedPrefixesToDirectConnectGateway: params["addAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
      removeAllowedPrefixesToDirectConnectGateway: params["removeAllowedPrefixesToDirectConnectGateway"]?.map(x => fromRouteFilterPrefix(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDirectConnectGatewayAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "directConnectGatewayAssociation": toDirectConnectGatewayAssociation,
      },
    }, await resp.json());
  }

  async updateLag(
    {abortSignal, ...params}: RequestConfig & s.UpdateLagRequest,
  ): Promise<s.Lag> {
    const body: jsonP.JSONObject = {
      lagId: params["lagId"],
      lagName: params["lagName"],
      minimumLinks: params["minimumLinks"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateLag",
    });
    return toLag(await resp.json());
  }

  async updateVirtualInterfaceAttributes(
    {abortSignal, ...params}: RequestConfig & s.UpdateVirtualInterfaceAttributesRequest,
  ): Promise<s.VirtualInterface> {
    const body: jsonP.JSONObject = {
      virtualInterfaceId: params["virtualInterfaceId"],
      mtu: params["mtu"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVirtualInterfaceAttributes",
    });
    return toVirtualInterface(await resp.json());
  }

}

function toConnection(root: jsonP.JSONValue): s.Connection {
  return jsonP.readObj({
    required: {},
    optional: {
      "ownerAccount": "s",
      "connectionId": "s",
      "connectionName": "s",
      "connectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionState>(x),
      "region": "s",
      "location": "s",
      "bandwidth": "s",
      "vlan": "n",
      "partnerName": "s",
      "loaIssueTime": "d",
      "lagId": "s",
      "awsDevice": "s",
      "jumboFrameCapable": "b",
      "awsDeviceV2": "s",
      "hasLogicalRedundancy": (x: jsonP.JSONValue) => cmnP.readEnum<s.HasLogicalRedundancy>(x),
      "tags": [toTag],
      "providerName": "s",
    },
  }, root);
}

function toVirtualInterface(root: jsonP.JSONValue): s.VirtualInterface {
  return jsonP.readObj({
    required: {},
    optional: {
      "ownerAccount": "s",
      "virtualInterfaceId": "s",
      "location": "s",
      "connectionId": "s",
      "virtualInterfaceType": "s",
      "virtualInterfaceName": "s",
      "vlan": "n",
      "asn": "n",
      "amazonSideAsn": "n",
      "authKey": "s",
      "amazonAddress": "s",
      "customerAddress": "s",
      "addressFamily": (x: jsonP.JSONValue) => cmnP.readEnum<s.AddressFamily>(x),
      "virtualInterfaceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VirtualInterfaceState>(x),
      "customerRouterConfig": "s",
      "mtu": "n",
      "jumboFrameCapable": "b",
      "virtualGatewayId": "s",
      "directConnectGatewayId": "s",
      "routeFilterPrefixes": [toRouteFilterPrefix],
      "bgpPeers": [toBGPPeer],
      "region": "s",
      "awsDeviceV2": "s",
      "tags": [toTag],
    },
  }, root);
}

function toInterconnect(root: jsonP.JSONValue): s.Interconnect {
  return jsonP.readObj({
    required: {},
    optional: {
      "interconnectId": "s",
      "interconnectName": "s",
      "interconnectState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InterconnectState>(x),
      "region": "s",
      "location": "s",
      "bandwidth": "s",
      "loaIssueTime": "d",
      "lagId": "s",
      "awsDevice": "s",
      "jumboFrameCapable": "b",
      "awsDeviceV2": "s",
      "hasLogicalRedundancy": (x: jsonP.JSONValue) => cmnP.readEnum<s.HasLogicalRedundancy>(x),
      "tags": [toTag],
      "providerName": "s",
    },
  }, root);
}

function toLag(root: jsonP.JSONValue): s.Lag {
  return jsonP.readObj({
    required: {},
    optional: {
      "connectionsBandwidth": "s",
      "numberOfConnections": "n",
      "lagId": "s",
      "ownerAccount": "s",
      "lagName": "s",
      "lagState": (x: jsonP.JSONValue) => cmnP.readEnum<s.LagState>(x),
      "location": "s",
      "region": "s",
      "minimumLinks": "n",
      "awsDevice": "s",
      "awsDeviceV2": "s",
      "connections": [toConnection],
      "allowsHostedConnections": "b",
      "jumboFrameCapable": "b",
      "hasLogicalRedundancy": (x: jsonP.JSONValue) => cmnP.readEnum<s.HasLogicalRedundancy>(x),
      "tags": [toTag],
      "providerName": "s",
    },
  }, root);
}

function toLoa(root: jsonP.JSONValue): s.Loa {
  return jsonP.readObj({
    required: {},
    optional: {
      "loaContent": "a",
      "loaContentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.LoaContentType>(x),
    },
  }, root);
}

function fromRouteFilterPrefix(input?: s.RouteFilterPrefix | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cidr: input["cidr"],
  }
}
function toRouteFilterPrefix(root: jsonP.JSONValue): s.RouteFilterPrefix {
  return jsonP.readObj({
    required: {},
    optional: {
      "cidr": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "value": "s",
    },
  }, root);
}

function fromNewPrivateVirtualInterfaceAllocation(input?: s.NewPrivateVirtualInterfaceAllocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    mtu: input["mtu"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    addressFamily: input["addressFamily"],
    customerAddress: input["customerAddress"],
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function fromNewPublicVirtualInterfaceAllocation(input?: s.NewPublicVirtualInterfaceAllocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
    addressFamily: input["addressFamily"],
    routeFilterPrefixes: input["routeFilterPrefixes"]?.map(x => fromRouteFilterPrefix(x)),
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function fromNewTransitVirtualInterfaceAllocation(input?: s.NewTransitVirtualInterfaceAllocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    mtu: input["mtu"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
    addressFamily: input["addressFamily"],
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function fromNewBGPPeer(input?: s.NewBGPPeer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    asn: input["asn"],
    authKey: input["authKey"],
    addressFamily: input["addressFamily"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
  }
}

function fromNewPrivateVirtualInterface(input?: s.NewPrivateVirtualInterface | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    mtu: input["mtu"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
    addressFamily: input["addressFamily"],
    virtualGatewayId: input["virtualGatewayId"],
    directConnectGatewayId: input["directConnectGatewayId"],
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function fromNewPublicVirtualInterface(input?: s.NewPublicVirtualInterface | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
    addressFamily: input["addressFamily"],
    routeFilterPrefixes: input["routeFilterPrefixes"]?.map(x => fromRouteFilterPrefix(x)),
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function fromNewTransitVirtualInterface(input?: s.NewTransitVirtualInterface | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    virtualInterfaceName: input["virtualInterfaceName"],
    vlan: input["vlan"],
    asn: input["asn"],
    mtu: input["mtu"],
    authKey: input["authKey"],
    amazonAddress: input["amazonAddress"],
    customerAddress: input["customerAddress"],
    addressFamily: input["addressFamily"],
    directConnectGatewayId: input["directConnectGatewayId"],
    tags: input["tags"]?.map(x => fromTag(x)),
  }
}

function toDirectConnectGatewayAssociation(root: jsonP.JSONValue): s.DirectConnectGatewayAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "directConnectGatewayId": "s",
      "directConnectGatewayOwnerAccount": "s",
      "associationState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectConnectGatewayAssociationState>(x),
      "stateChangeError": "s",
      "associatedGateway": toAssociatedGateway,
      "associationId": "s",
      "allowedPrefixesToDirectConnectGateway": [toRouteFilterPrefix],
      "virtualGatewayId": "s",
      "virtualGatewayRegion": "s",
      "virtualGatewayOwnerAccount": "s",
    },
  }, root);
}

function toAssociatedGateway(root: jsonP.JSONValue): s.AssociatedGateway {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.GatewayType>(x),
      "ownerAccount": "s",
      "region": "s",
    },
  }, root);
}

function toBGPPeer(root: jsonP.JSONValue): s.BGPPeer {
  return jsonP.readObj({
    required: {},
    optional: {
      "bgpPeerId": "s",
      "asn": "n",
      "authKey": "s",
      "addressFamily": (x: jsonP.JSONValue) => cmnP.readEnum<s.AddressFamily>(x),
      "amazonAddress": "s",
      "customerAddress": "s",
      "bgpPeerState": (x: jsonP.JSONValue) => cmnP.readEnum<s.BGPPeerState>(x),
      "bgpStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.BGPStatus>(x),
      "awsDeviceV2": "s",
    },
  }, root);
}

function toDirectConnectGateway(root: jsonP.JSONValue): s.DirectConnectGateway {
  return jsonP.readObj({
    required: {},
    optional: {
      "directConnectGatewayId": "s",
      "directConnectGatewayName": "s",
      "amazonSideAsn": "n",
      "ownerAccount": "s",
      "directConnectGatewayState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectConnectGatewayState>(x),
      "stateChangeError": "s",
    },
  }, root);
}

function toDirectConnectGatewayAssociationProposal(root: jsonP.JSONValue): s.DirectConnectGatewayAssociationProposal {
  return jsonP.readObj({
    required: {},
    optional: {
      "proposalId": "s",
      "directConnectGatewayId": "s",
      "directConnectGatewayOwnerAccount": "s",
      "proposalState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectConnectGatewayAssociationProposalState>(x),
      "associatedGateway": toAssociatedGateway,
      "existingAllowedPrefixesToDirectConnectGateway": [toRouteFilterPrefix],
      "requestedAllowedPrefixesToDirectConnectGateway": [toRouteFilterPrefix],
    },
  }, root);
}

function toDirectConnectGatewayAttachment(root: jsonP.JSONValue): s.DirectConnectGatewayAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "directConnectGatewayId": "s",
      "virtualInterfaceId": "s",
      "virtualInterfaceRegion": "s",
      "virtualInterfaceOwnerAccount": "s",
      "attachmentState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectConnectGatewayAttachmentState>(x),
      "attachmentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectConnectGatewayAttachmentType>(x),
      "stateChangeError": "s",
    },
  }, root);
}

function toLocation(root: jsonP.JSONValue): s.Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "locationCode": "s",
      "locationName": "s",
      "region": "s",
      "availablePortSpeeds": ["s"],
      "availableProviders": ["s"],
    },
  }, root);
}

function toResourceTag(root: jsonP.JSONValue): s.ResourceTag {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceArn": "s",
      "tags": [toTag],
    },
  }, root);
}

function toVirtualGateway(root: jsonP.JSONValue): s.VirtualGateway {
  return jsonP.readObj({
    required: {},
    optional: {
      "virtualGatewayId": "s",
      "virtualGatewayState": "s",
    },
  }, root);
}

function toVirtualInterfaceTestHistory(root: jsonP.JSONValue): s.VirtualInterfaceTestHistory {
  return jsonP.readObj({
    required: {},
    optional: {
      "testId": "s",
      "virtualInterfaceId": "s",
      "bgpPeers": ["s"],
      "status": "s",
      "ownerAccount": "s",
      "testDurationInMinutes": "n",
      "startTime": "d",
      "endTime": "d",
    },
  }, root);
}
