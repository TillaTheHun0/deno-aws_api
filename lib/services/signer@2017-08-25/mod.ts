// Autogenerated API client for: AWS Signer

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class Signer {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Signer.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-08-25",
    "endpointPrefix": "signer",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceAbbreviation": "signer",
    "serviceFullName": "AWS Signer",
    "serviceId": "signer",
    "signatureVersion": "v4",
    "signingName": "signer",
    "uid": "signer-2017-08-25"
  };

  async cancelSigningProfile(
    {abortSignal, ...params}: RequestConfig & CancelSigningProfileRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelSigningProfile",
      method: "DELETE",
      requestUri: cmnP.encodePath`/signing-profiles/${params["profileName"]}`,
    });
  }

  async describeSigningJob(
    {abortSignal, ...params}: RequestConfig & DescribeSigningJobRequest,
  ): Promise<DescribeSigningJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeSigningJob",
      method: "GET",
      requestUri: cmnP.encodePath`/signing-jobs/${params["jobId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobId": "s",
        "source": toSource,
        "signingMaterial": toSigningMaterial,
        "platformId": "s",
        "profileName": "s",
        "overrides": toSigningPlatformOverrides,
        "signingParameters": x => jsonP.readMap(String, String, x),
        "createdAt": "d",
        "completedAt": "d",
        "requestedBy": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<SigningStatus>(x),
        "statusReason": "s",
        "signedObject": toSignedObject,
      },
    }, await resp.json());
  }

  async getSigningPlatform(
    {abortSignal, ...params}: RequestConfig & GetSigningPlatformRequest,
  ): Promise<GetSigningPlatformResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSigningPlatform",
      method: "GET",
      requestUri: cmnP.encodePath`/signing-platforms/${params["platformId"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "platformId": "s",
        "displayName": "s",
        "partner": "s",
        "target": "s",
        "category": (x: jsonP.JSONValue) => cmnP.readEnum<Category>(x),
        "signingConfiguration": toSigningConfiguration,
        "signingImageFormat": toSigningImageFormat,
        "maxSizeInMB": "n",
      },
    }, await resp.json());
  }

  async getSigningProfile(
    {abortSignal, ...params}: RequestConfig & GetSigningProfileRequest,
  ): Promise<GetSigningProfileResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSigningProfile",
      method: "GET",
      requestUri: cmnP.encodePath`/signing-profiles/${params["profileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "profileName": "s",
        "signingMaterial": toSigningMaterial,
        "platformId": "s",
        "overrides": toSigningPlatformOverrides,
        "signingParameters": x => jsonP.readMap(String, String, x),
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<SigningProfileStatus>(x),
        "arn": "s",
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listSigningJobs(
    {abortSignal, ...params}: RequestConfig & ListSigningJobsRequest = {},
  ): Promise<ListSigningJobsResponse> {
    const query = new URLSearchParams;
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["platformId"] != null) query.set("platformId", params["platformId"]?.toString() ?? "");
    if (params["requestedBy"] != null) query.set("requestedBy", params["requestedBy"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSigningJobs",
      method: "GET",
      requestUri: "/signing-jobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toSigningJob],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSigningPlatforms(
    {abortSignal, ...params}: RequestConfig & ListSigningPlatformsRequest = {},
  ): Promise<ListSigningPlatformsResponse> {
    const query = new URLSearchParams;
    if (params["category"] != null) query.set("category", params["category"]?.toString() ?? "");
    if (params["partner"] != null) query.set("partner", params["partner"]?.toString() ?? "");
    if (params["target"] != null) query.set("target", params["target"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSigningPlatforms",
      method: "GET",
      requestUri: "/signing-platforms",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "platforms": [toSigningPlatform],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listSigningProfiles(
    {abortSignal, ...params}: RequestConfig & ListSigningProfilesRequest = {},
  ): Promise<ListSigningProfilesResponse> {
    const query = new URLSearchParams;
    if (params["includeCanceled"] != null) query.set("includeCanceled", params["includeCanceled"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("maxResults", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("nextToken", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListSigningProfiles",
      method: "GET",
      requestUri: "/signing-profiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "profiles": [toSigningProfile],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async putSigningProfile(
    {abortSignal, ...params}: RequestConfig & PutSigningProfileRequest,
  ): Promise<PutSigningProfileResponse> {
    const body: jsonP.JSONObject = {
      signingMaterial: fromSigningMaterial(params["signingMaterial"]),
      platformId: params["platformId"],
      overrides: fromSigningPlatformOverrides(params["overrides"]),
      signingParameters: params["signingParameters"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSigningProfile",
      method: "PUT",
      requestUri: cmnP.encodePath`/signing-profiles/${params["profileName"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "arn": "s",
      },
    }, await resp.json());
  }

  async startSigningJob(
    {abortSignal, ...params}: RequestConfig & StartSigningJobRequest,
  ): Promise<StartSigningJobResponse> {
    const body: jsonP.JSONObject = {
      source: fromSource(params["source"]),
      destination: fromDestination(params["destination"]),
      profileName: params["profileName"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSigningJob",
      requestUri: "/signing-jobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["tagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["resourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 25 times, 20 seconds apart (about 9 minutes max wait time). */
  async waitForSuccessfulSigningJob(
    params: RequestConfig & DescribeSigningJobRequest,
  ): Promise<DescribeSigningJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state SuccessfulSigningJob';
    for (let i = 0; i < 25; i++) {
      try {
        const resp = await this.describeSigningJob(params);
        const field = resp?.status;
        if (field === "Succeeded") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ResourceNotFoundException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CancelSigningProfileRequest {
  profileName: string;
}

// refs: 1 - tags: named, input
export interface DescribeSigningJobRequest {
  jobId: string;
}

// refs: 1 - tags: named, input
export interface GetSigningPlatformRequest {
  platformId: string;
}

// refs: 1 - tags: named, input
export interface GetSigningProfileRequest {
  profileName: string;
}

// refs: 1 - tags: named, input
export interface ListSigningJobsRequest {
  status?: SigningStatus | null;
  platformId?: string | null;
  requestedBy?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSigningPlatformsRequest {
  category?: string | null;
  partner?: string | null;
  target?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSigningProfilesRequest {
  includeCanceled?: boolean | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  resourceArn: string;
}

// refs: 1 - tags: named, input
export interface PutSigningProfileRequest {
  profileName: string;
  signingMaterial: SigningMaterial;
  platformId: string;
  overrides?: SigningPlatformOverrides | null;
  signingParameters?: { [key: string]: string | null | undefined } | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface StartSigningJobRequest {
  source: Source;
  destination: Destination;
  profileName?: string | null;
  clientRequestToken: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  resourceArn: string;
  tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  resourceArn: string;
  tagKeys: string[];
}

// refs: 1 - tags: named, output
export interface DescribeSigningJobResponse {
  jobId?: string | null;
  source?: Source | null;
  signingMaterial?: SigningMaterial | null;
  platformId?: string | null;
  profileName?: string | null;
  overrides?: SigningPlatformOverrides | null;
  signingParameters?: { [key: string]: string | null | undefined } | null;
  createdAt?: Date | number | null;
  completedAt?: Date | number | null;
  requestedBy?: string | null;
  status?: SigningStatus | null;
  statusReason?: string | null;
  signedObject?: SignedObject | null;
}

// refs: 1 - tags: named, output
export interface GetSigningPlatformResponse {
  platformId?: string | null;
  displayName?: string | null;
  partner?: string | null;
  target?: string | null;
  category?: Category | null;
  signingConfiguration?: SigningConfiguration | null;
  signingImageFormat?: SigningImageFormat | null;
  maxSizeInMB?: number | null;
}

// refs: 1 - tags: named, output
export interface GetSigningProfileResponse {
  profileName?: string | null;
  signingMaterial?: SigningMaterial | null;
  platformId?: string | null;
  overrides?: SigningPlatformOverrides | null;
  signingParameters?: { [key: string]: string | null | undefined } | null;
  status?: SigningProfileStatus | null;
  arn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListSigningJobsResponse {
  jobs?: SigningJob[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSigningPlatformsResponse {
  platforms?: SigningPlatform[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSigningProfilesResponse {
  profiles?: SigningProfile[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface PutSigningProfileResponse {
  arn?: string | null;
}

// refs: 1 - tags: named, output
export interface StartSigningJobResponse {
  jobId?: string | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 3 - tags: input, named, enum, output
export type SigningStatus =
| "InProgress"
| "Failed"
| "Succeeded"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface SigningMaterial {
  certificateArn: string;
}
function fromSigningMaterial(input?: SigningMaterial | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateArn: input["certificateArn"],
  }
}
function toSigningMaterial(root: jsonP.JSONValue): SigningMaterial {
  return jsonP.readObj({
    required: {
      "certificateArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SigningPlatformOverrides {
  signingConfiguration?: SigningConfigurationOverrides | null;
  signingImageFormat?: ImageFormat | null;
}
function fromSigningPlatformOverrides(input?: SigningPlatformOverrides | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    signingConfiguration: fromSigningConfigurationOverrides(input["signingConfiguration"]),
    signingImageFormat: input["signingImageFormat"],
  }
}
function toSigningPlatformOverrides(root: jsonP.JSONValue): SigningPlatformOverrides {
  return jsonP.readObj({
    required: {},
    optional: {
      "signingConfiguration": toSigningConfigurationOverrides,
      "signingImageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<ImageFormat>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface SigningConfigurationOverrides {
  encryptionAlgorithm?: EncryptionAlgorithm | null;
  hashAlgorithm?: HashAlgorithm | null;
}
function fromSigningConfigurationOverrides(input?: SigningConfigurationOverrides | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionAlgorithm: input["encryptionAlgorithm"],
    hashAlgorithm: input["hashAlgorithm"],
  }
}
function toSigningConfigurationOverrides(root: jsonP.JSONValue): SigningConfigurationOverrides {
  return jsonP.readObj({
    required: {},
    optional: {
      "encryptionAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithm>(x),
      "hashAlgorithm": (x: jsonP.JSONValue) => cmnP.readEnum<HashAlgorithm>(x),
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type EncryptionAlgorithm =
| "RSA"
| "ECDSA"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type HashAlgorithm =
| "SHA1"
| "SHA256"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, enum, output
export type ImageFormat =
| "JSON"
| "JSONEmbedded"
| "JSONDetached"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Source {
  s3?: S3Source | null;
}
function fromSource(input?: Source | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3: fromS3Source(input["s3"]),
  }
}
function toSource(root: jsonP.JSONValue): Source {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3": toS3Source,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface S3Source {
  bucketName: string;
  key: string;
  version: string;
}
function fromS3Source(input?: S3Source | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketName: input["bucketName"],
    key: input["key"],
    version: input["version"],
  }
}
function toS3Source(root: jsonP.JSONValue): S3Source {
  return jsonP.readObj({
    required: {
      "bucketName": "s",
      "key": "s",
      "version": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface Destination {
  s3?: S3Destination | null;
}
function fromDestination(input?: Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    s3: fromS3Destination(input["s3"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface S3Destination {
  bucketName?: string | null;
  prefix?: string | null;
}
function fromS3Destination(input?: S3Destination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bucketName: input["bucketName"],
    prefix: input["prefix"],
  }
}

// refs: 2 - tags: output, named, interface
export interface SignedObject {
  s3?: S3SignedObject | null;
}
function toSignedObject(root: jsonP.JSONValue): SignedObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "s3": toS3SignedObject,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface S3SignedObject {
  bucketName?: string | null;
  key?: string | null;
}
function toS3SignedObject(root: jsonP.JSONValue): S3SignedObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucketName": "s",
      "key": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type Category =
| "AWSIoT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface SigningConfiguration {
  encryptionAlgorithmOptions: EncryptionAlgorithmOptions;
  hashAlgorithmOptions: HashAlgorithmOptions;
}
function toSigningConfiguration(root: jsonP.JSONValue): SigningConfiguration {
  return jsonP.readObj({
    required: {
      "encryptionAlgorithmOptions": toEncryptionAlgorithmOptions,
      "hashAlgorithmOptions": toHashAlgorithmOptions,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EncryptionAlgorithmOptions {
  allowedValues: EncryptionAlgorithm[];
  defaultValue: EncryptionAlgorithm;
}
function toEncryptionAlgorithmOptions(root: jsonP.JSONValue): EncryptionAlgorithmOptions {
  return jsonP.readObj({
    required: {
      "allowedValues": [(x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithm>(x)],
      "defaultValue": (x: jsonP.JSONValue) => cmnP.readEnum<EncryptionAlgorithm>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface HashAlgorithmOptions {
  allowedValues: HashAlgorithm[];
  defaultValue: HashAlgorithm;
}
function toHashAlgorithmOptions(root: jsonP.JSONValue): HashAlgorithmOptions {
  return jsonP.readObj({
    required: {
      "allowedValues": [(x: jsonP.JSONValue) => cmnP.readEnum<HashAlgorithm>(x)],
      "defaultValue": (x: jsonP.JSONValue) => cmnP.readEnum<HashAlgorithm>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SigningImageFormat {
  supportedFormats: ImageFormat[];
  defaultFormat: ImageFormat;
}
function toSigningImageFormat(root: jsonP.JSONValue): SigningImageFormat {
  return jsonP.readObj({
    required: {
      "supportedFormats": [(x: jsonP.JSONValue) => cmnP.readEnum<ImageFormat>(x)],
      "defaultFormat": (x: jsonP.JSONValue) => cmnP.readEnum<ImageFormat>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, enum
export type SigningProfileStatus =
| "Active"
| "Canceled"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SigningJob {
  jobId?: string | null;
  source?: Source | null;
  signedObject?: SignedObject | null;
  signingMaterial?: SigningMaterial | null;
  createdAt?: Date | number | null;
  status?: SigningStatus | null;
}
function toSigningJob(root: jsonP.JSONValue): SigningJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "jobId": "s",
      "source": toSource,
      "signedObject": toSignedObject,
      "signingMaterial": toSigningMaterial,
      "createdAt": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<SigningStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SigningPlatform {
  platformId?: string | null;
  displayName?: string | null;
  partner?: string | null;
  target?: string | null;
  category?: Category | null;
  signingConfiguration?: SigningConfiguration | null;
  signingImageFormat?: SigningImageFormat | null;
  maxSizeInMB?: number | null;
}
function toSigningPlatform(root: jsonP.JSONValue): SigningPlatform {
  return jsonP.readObj({
    required: {},
    optional: {
      "platformId": "s",
      "displayName": "s",
      "partner": "s",
      "target": "s",
      "category": (x: jsonP.JSONValue) => cmnP.readEnum<Category>(x),
      "signingConfiguration": toSigningConfiguration,
      "signingImageFormat": toSigningImageFormat,
      "maxSizeInMB": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SigningProfile {
  profileName?: string | null;
  signingMaterial?: SigningMaterial | null;
  platformId?: string | null;
  signingParameters?: { [key: string]: string | null | undefined } | null;
  status?: SigningProfileStatus | null;
  arn?: string | null;
  tags?: { [key: string]: string | null | undefined } | null;
}
function toSigningProfile(root: jsonP.JSONValue): SigningProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "profileName": "s",
      "signingMaterial": toSigningMaterial,
      "platformId": "s",
      "signingParameters": x => jsonP.readMap(String, String, x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<SigningProfileStatus>(x),
      "arn": "s",
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}
