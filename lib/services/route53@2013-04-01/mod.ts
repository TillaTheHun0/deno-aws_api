// Autogenerated API client for: Amazon Route 53

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";

export default class Route53 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Route53.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-04-01",
    "endpointPrefix": "route53",
    "globalEndpoint": "route53.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Route 53",
    "serviceFullName": "Amazon Route 53",
    "serviceId": "Route 53",
    "signatureVersion": "v4",
    "uid": "route53-2013-04-01"
  };

  async activateKeySigningKey(
    {abortSignal, ...params}: RequestConfig & ActivateKeySigningKeyRequest,
  ): Promise<ActivateKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ActivateKeySigningKey",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}/activate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async associateVPCWithHostedZone(
    {abortSignal, ...params}: RequestConfig & AssociateVPCWithHostedZoneRequest,
  ): Promise<AssociateVPCWithHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "AssociateVPCWithHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateVPCWithHostedZone",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/associatevpc`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async changeResourceRecordSets(
    {abortSignal, ...params}: RequestConfig & ChangeResourceRecordSetsRequest,
  ): Promise<ChangeResourceRecordSetsResponse> {
    const body = xmlP.stringify({
      name: "ChangeResourceRecordSetsRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "ChangeBatch", ...ChangeBatch_Serialize(params["ChangeBatch"])},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ChangeResourceRecordSets",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset/`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async changeTagsForResource(
    {abortSignal, ...params}: RequestConfig & ChangeTagsForResourceRequest,
  ): Promise<ChangeTagsForResourceResponse> {
    const body = xmlP.stringify({
      name: "ChangeTagsForResourceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "AddTags", children: params["AddTags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
        {name: "RemoveTagKeys", children: params["RemoveTagKeys"]?.map(x => ({name: "Key", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ChangeTagsForResource",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}/${params["ResourceId"]}`,
    });
    return {
    };
  }

  async createHealthCheck(
    {abortSignal, ...params}: RequestConfig & CreateHealthCheckRequest,
  ): Promise<CreateHealthCheckResponse> {
    const body = xmlP.stringify({
      name: "CreateHealthCheckRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HealthCheckConfig", ...HealthCheckConfig_Serialize(params["HealthCheckConfig"])},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHealthCheck",
      requestUri: "/2013-04-01/healthcheck",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
      },
    };
  }

  async createHostedZone(
    {abortSignal, ...params}: RequestConfig & CreateHostedZoneRequest,
  ): Promise<CreateHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "CreateHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneConfig", ...HostedZoneConfig_Serialize(params["HostedZoneConfig"])},
        {name: "DelegationSetId", content: params["DelegationSetId"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHostedZone",
      requestUri: "/2013-04-01/hostedzone",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
        ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
        DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
        VPC: xml.first("VPC", false, VPC_Parse),
      },
    };
  }

  async createKeySigningKey(
    {abortSignal, ...params}: RequestConfig & CreateKeySigningKeyRequest,
  ): Promise<CreateKeySigningKeyResponse> {
    const body = xmlP.stringify({
      name: "CreateKeySigningKeyRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "KeyManagementServiceArn", content: params["KeyManagementServiceArn"]?.toString()},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "Status", content: params["Status"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeySigningKey",
      requestUri: "/2013-04-01/keysigningkey",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
        KeySigningKey: xml.first("KeySigningKey", true, KeySigningKey_Parse),
      },
    };
  }

  async createQueryLoggingConfig(
    {abortSignal, ...params}: RequestConfig & CreateQueryLoggingConfigRequest,
  ): Promise<CreateQueryLoggingConfigResponse> {
    const body = xmlP.stringify({
      name: "CreateQueryLoggingConfigRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "CloudWatchLogsLogGroupArn", content: params["CloudWatchLogsLogGroupArn"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateQueryLoggingConfig",
      requestUri: "/2013-04-01/queryloggingconfig",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        QueryLoggingConfig: xml.first("QueryLoggingConfig", true, QueryLoggingConfig_Parse),
      },
    };
  }

  async createReusableDelegationSet(
    {abortSignal, ...params}: RequestConfig & CreateReusableDelegationSetRequest,
  ): Promise<CreateReusableDelegationSetResponse> {
    const body = xmlP.stringify({
      name: "CreateReusableDelegationSetRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateReusableDelegationSet",
      requestUri: "/2013-04-01/delegationset",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
      },
    };
  }

  async createTrafficPolicy(
    {abortSignal, ...params}: RequestConfig & CreateTrafficPolicyRequest,
  ): Promise<CreateTrafficPolicyResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "Document", content: params["Document"]?.toString()},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficPolicy",
      requestUri: "/2013-04-01/trafficpolicy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
      },
    };
  }

  async createTrafficPolicyInstance(
    {abortSignal, ...params}: RequestConfig & CreateTrafficPolicyInstanceRequest,
  ): Promise<CreateTrafficPolicyInstanceResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyInstanceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "TTL", content: params["TTL"]?.toString()},
        {name: "TrafficPolicyId", content: params["TrafficPolicyId"]?.toString()},
        {name: "TrafficPolicyVersion", content: params["TrafficPolicyVersion"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficPolicyInstance",
      requestUri: "/2013-04-01/trafficpolicyinstance",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
      },
    };
  }

  async createTrafficPolicyVersion(
    {abortSignal, ...params}: RequestConfig & CreateTrafficPolicyVersionRequest,
  ): Promise<CreateTrafficPolicyVersionResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyVersionRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Document", content: params["Document"]?.toString()},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrafficPolicyVersion",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
      },
    };
  }

  async createVPCAssociationAuthorization(
    {abortSignal, ...params}: RequestConfig & CreateVPCAssociationAuthorizationRequest,
  ): Promise<CreateVPCAssociationAuthorizationResponse> {
    const body = xmlP.stringify({
      name: "CreateVPCAssociationAuthorizationRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVPCAssociationAuthorization",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/authorizevpcassociation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"HostedZoneId":true},
      }),
      VPC: xml.first("VPC", true, VPC_Parse),
    };
  }

  async deactivateKeySigningKey(
    {abortSignal, ...params}: RequestConfig & DeactivateKeySigningKeyRequest,
  ): Promise<DeactivateKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeactivateKeySigningKey",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}/deactivate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteHealthCheck(
    {abortSignal, ...params}: RequestConfig & DeleteHealthCheckRequest,
  ): Promise<DeleteHealthCheckResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteHealthCheck",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    return {
    };
  }

  async deleteHostedZone(
    {abortSignal, ...params}: RequestConfig & DeleteHostedZoneRequest,
  ): Promise<DeleteHostedZoneResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteHostedZone",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteKeySigningKey(
    {abortSignal, ...params}: RequestConfig & DeleteKeySigningKeyRequest,
  ): Promise<DeleteKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteKeySigningKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteQueryLoggingConfig(
    {abortSignal, ...params}: RequestConfig & DeleteQueryLoggingConfigRequest,
  ): Promise<DeleteQueryLoggingConfigResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteQueryLoggingConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/queryloggingconfig/${params["Id"]}`,
    });
    return {
    };
  }

  async deleteReusableDelegationSet(
    {abortSignal, ...params}: RequestConfig & DeleteReusableDelegationSetRequest,
  ): Promise<DeleteReusableDelegationSetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteReusableDelegationSet",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/delegationset/${params["Id"]}`,
    });
    return {
    };
  }

  async deleteTrafficPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficPolicyRequest,
  ): Promise<DeleteTrafficPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteTrafficPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    return {
    };
  }

  async deleteTrafficPolicyInstance(
    {abortSignal, ...params}: RequestConfig & DeleteTrafficPolicyInstanceRequest,
  ): Promise<DeleteTrafficPolicyInstanceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteTrafficPolicyInstance",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    return {
    };
  }

  async deleteVPCAssociationAuthorization(
    {abortSignal, ...params}: RequestConfig & DeleteVPCAssociationAuthorizationRequest,
  ): Promise<DeleteVPCAssociationAuthorizationResponse> {
    const body = xmlP.stringify({
      name: "DeleteVPCAssociationAuthorizationRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVPCAssociationAuthorization",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/deauthorizevpcassociation`,
    });
    return {
    };
  }

  async disableHostedZoneDNSSEC(
    {abortSignal, ...params}: RequestConfig & DisableHostedZoneDNSSECRequest,
  ): Promise<DisableHostedZoneDNSSECResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisableHostedZoneDNSSEC",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/disable-dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async disassociateVPCFromHostedZone(
    {abortSignal, ...params}: RequestConfig & DisassociateVPCFromHostedZoneRequest,
  ): Promise<DisassociateVPCFromHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "DisassociateVPCFromHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateVPCFromHostedZone",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/disassociatevpc`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async enableHostedZoneDNSSEC(
    {abortSignal, ...params}: RequestConfig & EnableHostedZoneDNSSECRequest,
  ): Promise<EnableHostedZoneDNSSECResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "EnableHostedZoneDNSSEC",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/enable-dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async getAccountLimit(
    {abortSignal, ...params}: RequestConfig & GetAccountLimitRequest,
  ): Promise<GetAccountLimitResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/accountlimit/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, AccountLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getChange(
    {abortSignal, ...params}: RequestConfig & GetChangeRequest,
  ): Promise<GetChangeResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetChange",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/change/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async getCheckerIpRanges(
    {abortSignal, ...params}: RequestConfig & GetCheckerIpRangesRequest = {},
  ): Promise<GetCheckerIpRangesResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCheckerIpRanges",
      method: "GET",
      requestUri: "/2013-04-01/checkeripranges",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CheckerIpRanges: xml.getList("CheckerIpRanges", "member").map(x => x.content ?? ''),
    };
  }

  async getDNSSEC(
    {abortSignal, ...params}: RequestConfig & GetDNSSECRequest,
  ): Promise<GetDNSSECResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDNSSEC",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", true, DNSSECStatus_Parse),
      KeySigningKeys: xml.getList("KeySigningKeys", "member").map(KeySigningKey_Parse),
    };
  }

  async getGeoLocation(
    {abortSignal, ...params}: RequestConfig & GetGeoLocationRequest = {},
  ): Promise<GetGeoLocationResponse> {
    const query = new URLSearchParams;
    if (params["ContinentCode"] != null) query.set("continentcode", params["ContinentCode"]?.toString() ?? "");
    if (params["CountryCode"] != null) query.set("countrycode", params["CountryCode"]?.toString() ?? "");
    if (params["SubdivisionCode"] != null) query.set("subdivisioncode", params["SubdivisionCode"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetGeoLocation",
      method: "GET",
      requestUri: "/2013-04-01/geolocation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      GeoLocationDetails: xml.first("GeoLocationDetails", true, GeoLocationDetails_Parse),
    };
  }

  async getHealthCheck(
    {abortSignal, ...params}: RequestConfig & GetHealthCheckRequest,
  ): Promise<GetHealthCheckResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHealthCheck",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
    };
  }

  async getHealthCheckCount(
    {abortSignal, ...params}: RequestConfig & GetHealthCheckCountRequest = {},
  ): Promise<GetHealthCheckCountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHealthCheckCount",
      method: "GET",
      requestUri: "/2013-04-01/healthcheckcount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckCount: xml.first("HealthCheckCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getHealthCheckLastFailureReason(
    {abortSignal, ...params}: RequestConfig & GetHealthCheckLastFailureReasonRequest,
  ): Promise<GetHealthCheckLastFailureReasonResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHealthCheckLastFailureReason",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}/lastfailurereason`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckObservations: xml.getList("HealthCheckObservations", "HealthCheckObservation").map(HealthCheckObservation_Parse),
    };
  }

  async getHealthCheckStatus(
    {abortSignal, ...params}: RequestConfig & GetHealthCheckStatusRequest,
  ): Promise<GetHealthCheckStatusResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHealthCheckStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}/status`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckObservations: xml.getList("HealthCheckObservations", "HealthCheckObservation").map(HealthCheckObservation_Parse),
    };
  }

  async getHostedZone(
    {abortSignal, ...params}: RequestConfig & GetHostedZoneRequest,
  ): Promise<GetHostedZoneResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHostedZone",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
      DelegationSet: xml.first("DelegationSet", false, DelegationSet_Parse),
      VPCs: xml.getList("VPCs", "VPC").map(VPC_Parse),
    };
  }

  async getHostedZoneCount(
    {abortSignal, ...params}: RequestConfig & GetHostedZoneCountRequest = {},
  ): Promise<GetHostedZoneCountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHostedZoneCount",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonecount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZoneCount: xml.first("HostedZoneCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getHostedZoneLimit(
    {abortSignal, ...params}: RequestConfig & GetHostedZoneLimitRequest,
  ): Promise<GetHostedZoneLimitResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetHostedZoneLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzonelimit/${params["HostedZoneId"]}/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, HostedZoneLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getQueryLoggingConfig(
    {abortSignal, ...params}: RequestConfig & GetQueryLoggingConfigRequest,
  ): Promise<GetQueryLoggingConfigResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetQueryLoggingConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/queryloggingconfig/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      QueryLoggingConfig: xml.first("QueryLoggingConfig", true, QueryLoggingConfig_Parse),
    };
  }

  async getReusableDelegationSet(
    {abortSignal, ...params}: RequestConfig & GetReusableDelegationSetRequest,
  ): Promise<GetReusableDelegationSetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetReusableDelegationSet",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/delegationset/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
    };
  }

  async getReusableDelegationSetLimit(
    {abortSignal, ...params}: RequestConfig & GetReusableDelegationSetLimitRequest,
  ): Promise<GetReusableDelegationSetLimitResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetReusableDelegationSetLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/reusabledelegationsetlimit/${params["DelegationSetId"]}/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, ReusableDelegationSetLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getTrafficPolicy(
    {abortSignal, ...params}: RequestConfig & GetTrafficPolicyRequest,
  ): Promise<GetTrafficPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTrafficPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
    };
  }

  async getTrafficPolicyInstance(
    {abortSignal, ...params}: RequestConfig & GetTrafficPolicyInstanceRequest,
  ): Promise<GetTrafficPolicyInstanceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTrafficPolicyInstance",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
    };
  }

  async getTrafficPolicyInstanceCount(
    {abortSignal, ...params}: RequestConfig & GetTrafficPolicyInstanceCountRequest = {},
  ): Promise<GetTrafficPolicyInstanceCountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetTrafficPolicyInstanceCount",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstancecount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstanceCount: xml.first("TrafficPolicyInstanceCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async listGeoLocations(
    {abortSignal, ...params}: RequestConfig & ListGeoLocationsRequest = {},
  ): Promise<ListGeoLocationsResponse> {
    const query = new URLSearchParams;
    if (params["StartContinentCode"] != null) query.set("startcontinentcode", params["StartContinentCode"]?.toString() ?? "");
    if (params["StartCountryCode"] != null) query.set("startcountrycode", params["StartCountryCode"]?.toString() ?? "");
    if (params["StartSubdivisionCode"] != null) query.set("startsubdivisioncode", params["StartSubdivisionCode"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListGeoLocations",
      method: "GET",
      requestUri: "/2013-04-01/geolocations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextContinentCode":true,"NextCountryCode":true,"NextSubdivisionCode":true},
      }),
      GeoLocationDetailsList: xml.getList("GeoLocationDetailsList", "GeoLocationDetails").map(GeoLocationDetails_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHealthChecks(
    {abortSignal, ...params}: RequestConfig & ListHealthChecksRequest = {},
  ): Promise<ListHealthChecksResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHealthChecks",
      method: "GET",
      requestUri: "/2013-04-01/healthcheck",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Marker":true,"MaxItems":true},
        optional: {"NextMarker":true},
      }),
      HealthChecks: xml.getList("HealthChecks", "HealthCheck").map(HealthCheck_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZones(
    {abortSignal, ...params}: RequestConfig & ListHostedZonesRequest = {},
  ): Promise<ListHostedZonesResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    if (params["DelegationSetId"] != null) query.set("delegationsetid", params["DelegationSetId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHostedZones",
      method: "GET",
      requestUri: "/2013-04-01/hostedzone",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"Marker":true,"NextMarker":true},
      }),
      HostedZones: xml.getList("HostedZones", "HostedZone").map(HostedZone_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZonesByName(
    {abortSignal, ...params}: RequestConfig & ListHostedZonesByNameRequest = {},
  ): Promise<ListHostedZonesByNameResponse> {
    const query = new URLSearchParams;
    if (params["DNSName"] != null) query.set("dnsname", params["DNSName"]?.toString() ?? "");
    if (params["HostedZoneId"] != null) query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHostedZonesByName",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonesbyname",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"DNSName":true,"HostedZoneId":true,"NextDNSName":true,"NextHostedZoneId":true},
      }),
      HostedZones: xml.getList("HostedZones", "HostedZone").map(HostedZone_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZonesByVPC(
    {abortSignal, ...params}: RequestConfig & ListHostedZonesByVPCRequest,
  ): Promise<ListHostedZonesByVPCResponse> {
    const query = new URLSearchParams;
    query.set("vpcid", params["VPCId"]?.toString() ?? "");
    query.set("vpcregion", params["VPCRegion"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListHostedZonesByVPC",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonesbyvpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextToken":true},
      }),
      HostedZoneSummaries: xml.getList("HostedZoneSummaries", "HostedZoneSummary").map(HostedZoneSummary_Parse),
    };
  }

  async listQueryLoggingConfigs(
    {abortSignal, ...params}: RequestConfig & ListQueryLoggingConfigsRequest = {},
  ): Promise<ListQueryLoggingConfigsResponse> {
    const query = new URLSearchParams;
    if (params["HostedZoneId"] != null) query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxresults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListQueryLoggingConfigs",
      method: "GET",
      requestUri: "/2013-04-01/queryloggingconfig",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      QueryLoggingConfigs: xml.getList("QueryLoggingConfigs", "QueryLoggingConfig").map(QueryLoggingConfig_Parse),
    };
  }

  async listResourceRecordSets(
    {abortSignal, ...params}: RequestConfig & ListResourceRecordSetsRequest,
  ): Promise<ListResourceRecordSetsResponse> {
    const query = new URLSearchParams;
    if (params["StartRecordName"] != null) query.set("name", params["StartRecordName"]?.toString() ?? "");
    if (params["StartRecordType"] != null) query.set("type", params["StartRecordType"]?.toString() ?? "");
    if (params["StartRecordIdentifier"] != null) query.set("identifier", params["StartRecordIdentifier"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListResourceRecordSets",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextRecordName":true,"NextRecordIdentifier":true},
      }),
      ResourceRecordSets: xml.getList("ResourceRecordSets", "ResourceRecordSet").map(ResourceRecordSet_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
      NextRecordType: xml.first("NextRecordType", false, x => (x.content ?? '') as RRType),
    };
  }

  async listReusableDelegationSets(
    {abortSignal, ...params}: RequestConfig & ListReusableDelegationSetsRequest = {},
  ): Promise<ListReusableDelegationSetsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListReusableDelegationSets",
      method: "GET",
      requestUri: "/2013-04-01/delegationset",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Marker":true,"MaxItems":true},
        optional: {"NextMarker":true},
      }),
      DelegationSets: xml.getList("DelegationSets", "DelegationSet").map(DelegationSet_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}/${params["ResourceId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ResourceTagSet: xml.first("ResourceTagSet", true, ResourceTagSet_Parse),
    };
  }

  async listTagsForResources(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourcesRequest,
  ): Promise<ListTagsForResourcesResponse> {
    const body = xmlP.stringify({
      name: "ListTagsForResourcesRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "ResourceIds", children: params["ResourceIds"]?.map(x => ({name: "ResourceId", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResources",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ResourceTagSets: xml.getList("ResourceTagSets", "ResourceTagSet").map(ResourceTagSet_Parse),
    };
  }

  async listTrafficPolicies(
    {abortSignal, ...params}: RequestConfig & ListTrafficPoliciesRequest = {},
  ): Promise<ListTrafficPoliciesResponse> {
    const query = new URLSearchParams;
    if (params["TrafficPolicyIdMarker"] != null) query.set("trafficpolicyid", params["TrafficPolicyIdMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTrafficPolicies",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"TrafficPolicyIdMarker":true,"MaxItems":true},
      }),
      TrafficPolicySummaries: xml.getList("TrafficPolicySummaries", "TrafficPolicySummary").map(TrafficPolicySummary_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstances(
    {abortSignal, ...params}: RequestConfig & ListTrafficPolicyInstancesRequest = {},
  ): Promise<ListTrafficPolicyInstancesResponse> {
    const query = new URLSearchParams;
    if (params["HostedZoneIdMarker"] != null) query.set("hostedzoneid", params["HostedZoneIdMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTrafficPolicyInstances",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"HostedZoneIdMarker":true,"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstancesByHostedZone(
    {abortSignal, ...params}: RequestConfig & ListTrafficPolicyInstancesByHostedZoneRequest,
  ): Promise<ListTrafficPolicyInstancesByHostedZoneResponse> {
    const query = new URLSearchParams;
    query.set("id", params["HostedZoneId"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTrafficPolicyInstancesByHostedZone",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances/hostedzone",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstancesByPolicy(
    {abortSignal, ...params}: RequestConfig & ListTrafficPolicyInstancesByPolicyRequest,
  ): Promise<ListTrafficPolicyInstancesByPolicyResponse> {
    const query = new URLSearchParams;
    query.set("id", params["TrafficPolicyId"]?.toString() ?? "");
    query.set("version", params["TrafficPolicyVersion"]?.toString() ?? "");
    if (params["HostedZoneIdMarker"] != null) query.set("hostedzoneid", params["HostedZoneIdMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTrafficPolicyInstancesByPolicy",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances/trafficpolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"HostedZoneIdMarker":true,"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyVersions(
    {abortSignal, ...params}: RequestConfig & ListTrafficPolicyVersionsRequest,
  ): Promise<ListTrafficPolicyVersionsResponse> {
    const query = new URLSearchParams;
    if (params["TrafficPolicyVersionMarker"] != null) query.set("trafficpolicyversion", params["TrafficPolicyVersionMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTrafficPolicyVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicies/${params["Id"]}/versions`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"TrafficPolicyVersionMarker":true,"MaxItems":true},
      }),
      TrafficPolicies: xml.getList("TrafficPolicies", "TrafficPolicy").map(TrafficPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listVPCAssociationAuthorizations(
    {abortSignal, ...params}: RequestConfig & ListVPCAssociationAuthorizationsRequest,
  ): Promise<ListVPCAssociationAuthorizationsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxresults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVPCAssociationAuthorizations",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/authorizevpcassociation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"HostedZoneId":true},
        optional: {"NextToken":true},
      }),
      VPCs: xml.getList("VPCs", "VPC").map(VPC_Parse),
    };
  }

  async testDNSAnswer(
    {abortSignal, ...params}: RequestConfig & TestDNSAnswerRequest,
  ): Promise<TestDNSAnswerResponse> {
    const query = new URLSearchParams;
    query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    query.set("recordname", params["RecordName"]?.toString() ?? "");
    query.set("recordtype", params["RecordType"]?.toString() ?? "");
    if (params["ResolverIP"] != null) query.set("resolverip", params["ResolverIP"]?.toString() ?? "");
    if (params["EDNS0ClientSubnetIP"] != null) query.set("edns0clientsubnetip", params["EDNS0ClientSubnetIP"]?.toString() ?? "");
    if (params["EDNS0ClientSubnetMask"] != null) query.set("edns0clientsubnetmask", params["EDNS0ClientSubnetMask"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "TestDNSAnswer",
      method: "GET",
      requestUri: "/2013-04-01/testdnsanswer",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Nameserver":true,"RecordName":true,"ResponseCode":true,"Protocol":true},
      }),
      RecordType: xml.first("RecordType", true, x => (x.content ?? '') as RRType),
      RecordData: xml.getList("RecordData", "RecordDataEntry").map(x => x.content ?? ''),
    };
  }

  async updateHealthCheck(
    {abortSignal, ...params}: RequestConfig & UpdateHealthCheckRequest,
  ): Promise<UpdateHealthCheckResponse> {
    const body = xmlP.stringify({
      name: "UpdateHealthCheckRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HealthCheckVersion", content: params["HealthCheckVersion"]?.toString()},
        {name: "IPAddress", content: params["IPAddress"]?.toString()},
        {name: "Port", content: params["Port"]?.toString()},
        {name: "ResourcePath", content: params["ResourcePath"]?.toString()},
        {name: "FullyQualifiedDomainName", content: params["FullyQualifiedDomainName"]?.toString()},
        {name: "SearchString", content: params["SearchString"]?.toString()},
        {name: "FailureThreshold", content: params["FailureThreshold"]?.toString()},
        {name: "Inverted", content: params["Inverted"]?.toString()},
        {name: "Disabled", content: params["Disabled"]?.toString()},
        {name: "HealthThreshold", content: params["HealthThreshold"]?.toString()},
        {name: "ChildHealthChecks", children: params["ChildHealthChecks"]?.map(x => ({name: "ChildHealthCheck", content: x}))},
        {name: "EnableSNI", content: params["EnableSNI"]?.toString()},
        {name: "Regions", children: params["Regions"]?.map(x => ({name: "Region", content: x}))},
        {name: "AlarmIdentifier", ...AlarmIdentifier_Serialize(params["AlarmIdentifier"])},
        {name: "InsufficientDataHealthStatus", content: params["InsufficientDataHealthStatus"]?.toString()},
        {name: "ResetElements", children: params["ResetElements"]?.map(x => ({name: "ResettableElementName", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateHealthCheck",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
    };
  }

  async updateHostedZoneComment(
    {abortSignal, ...params}: RequestConfig & UpdateHostedZoneCommentRequest,
  ): Promise<UpdateHostedZoneCommentResponse> {
    const body = xmlP.stringify({
      name: "UpdateHostedZoneCommentRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateHostedZoneComment",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
    };
  }

  async updateTrafficPolicyComment(
    {abortSignal, ...params}: RequestConfig & UpdateTrafficPolicyCommentRequest,
  ): Promise<UpdateTrafficPolicyCommentResponse> {
    const body = xmlP.stringify({
      name: "UpdateTrafficPolicyCommentRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrafficPolicyComment",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
    };
  }

  async updateTrafficPolicyInstance(
    {abortSignal, ...params}: RequestConfig & UpdateTrafficPolicyInstanceRequest,
  ): Promise<UpdateTrafficPolicyInstanceResponse> {
    const body = xmlP.stringify({
      name: "UpdateTrafficPolicyInstanceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "TTL", content: params["TTL"]?.toString()},
        {name: "TrafficPolicyId", content: params["TrafficPolicyId"]?.toString()},
        {name: "TrafficPolicyVersion", content: params["TrafficPolicyVersion"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrafficPolicyInstance",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForResourceRecordSetsChanged(
    params: RequestConfig & GetChangeRequest,
  ): Promise<GetChangeResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ResourceRecordSetsChanged';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getChange(params);
      if (resp?.ChangeInfo?.Status === "INSYNC") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface ActivateKeySigningKeyRequest {
  HostedZoneId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface AssociateVPCWithHostedZoneRequest {
  HostedZoneId: string;
  VPC: VPC;
  Comment?: string | null;
}

// refs: 1 - tags: named, input
export interface ChangeResourceRecordSetsRequest {
  HostedZoneId: string;
  ChangeBatch: ChangeBatch;
}

// refs: 1 - tags: named, input
export interface ChangeTagsForResourceRequest {
  ResourceType: TagResourceType;
  ResourceId: string;
  AddTags?: Tag[] | null;
  RemoveTagKeys?: string[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHealthCheckRequest {
  CallerReference: string;
  HealthCheckConfig: HealthCheckConfig;
}

// refs: 1 - tags: named, input
export interface CreateHostedZoneRequest {
  Name: string;
  VPC?: VPC | null;
  CallerReference: string;
  HostedZoneConfig?: HostedZoneConfig | null;
  DelegationSetId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateKeySigningKeyRequest {
  CallerReference: string;
  HostedZoneId: string;
  KeyManagementServiceArn: string;
  Name: string;
  Status: string;
}

// refs: 1 - tags: named, input
export interface CreateQueryLoggingConfigRequest {
  HostedZoneId: string;
  CloudWatchLogsLogGroupArn: string;
}

// refs: 1 - tags: named, input
export interface CreateReusableDelegationSetRequest {
  CallerReference: string;
  HostedZoneId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTrafficPolicyRequest {
  Name: string;
  Document: string;
  Comment?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateTrafficPolicyInstanceRequest {
  HostedZoneId: string;
  Name: string;
  TTL: number;
  TrafficPolicyId: string;
  TrafficPolicyVersion: number;
}

// refs: 1 - tags: named, input
export interface CreateTrafficPolicyVersionRequest {
  Id: string;
  Document: string;
  Comment?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateVPCAssociationAuthorizationRequest {
  HostedZoneId: string;
  VPC: VPC;
}

// refs: 1 - tags: named, input
export interface DeactivateKeySigningKeyRequest {
  HostedZoneId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteHealthCheckRequest {
  HealthCheckId: string;
}

// refs: 1 - tags: named, input
export interface DeleteHostedZoneRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteKeySigningKeyRequest {
  HostedZoneId: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteQueryLoggingConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteReusableDelegationSetRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficPolicyRequest {
  Id: string;
  Version: number;
}

// refs: 1 - tags: named, input
export interface DeleteTrafficPolicyInstanceRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface DeleteVPCAssociationAuthorizationRequest {
  HostedZoneId: string;
  VPC: VPC;
}

// refs: 1 - tags: named, input
export interface DisableHostedZoneDNSSECRequest {
  HostedZoneId: string;
}

// refs: 1 - tags: named, input
export interface DisassociateVPCFromHostedZoneRequest {
  HostedZoneId: string;
  VPC: VPC;
  Comment?: string | null;
}

// refs: 1 - tags: named, input
export interface EnableHostedZoneDNSSECRequest {
  HostedZoneId: string;
}

// refs: 1 - tags: named, input
export interface GetAccountLimitRequest {
  Type: AccountLimitType;
}

// refs: 1 - tags: named, input
export interface GetChangeRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetCheckerIpRangesRequest {
}

// refs: 1 - tags: named, input
export interface GetDNSSECRequest {
  HostedZoneId: string;
}

// refs: 1 - tags: named, input
export interface GetGeoLocationRequest {
  ContinentCode?: string | null;
  CountryCode?: string | null;
  SubdivisionCode?: string | null;
}

// refs: 1 - tags: named, input
export interface GetHealthCheckRequest {
  HealthCheckId: string;
}

// refs: 1 - tags: named, input
export interface GetHealthCheckCountRequest {
}

// refs: 1 - tags: named, input
export interface GetHealthCheckLastFailureReasonRequest {
  HealthCheckId: string;
}

// refs: 1 - tags: named, input
export interface GetHealthCheckStatusRequest {
  HealthCheckId: string;
}

// refs: 1 - tags: named, input
export interface GetHostedZoneRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetHostedZoneCountRequest {
}

// refs: 1 - tags: named, input
export interface GetHostedZoneLimitRequest {
  Type: HostedZoneLimitType;
  HostedZoneId: string;
}

// refs: 1 - tags: named, input
export interface GetQueryLoggingConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetReusableDelegationSetRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetReusableDelegationSetLimitRequest {
  Type: ReusableDelegationSetLimitType;
  DelegationSetId: string;
}

// refs: 1 - tags: named, input
export interface GetTrafficPolicyRequest {
  Id: string;
  Version: number;
}

// refs: 1 - tags: named, input
export interface GetTrafficPolicyInstanceRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetTrafficPolicyInstanceCountRequest {
}

// refs: 1 - tags: named, input
export interface ListGeoLocationsRequest {
  StartContinentCode?: string | null;
  StartCountryCode?: string | null;
  StartSubdivisionCode?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListHealthChecksRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListHostedZonesRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  DelegationSetId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListHostedZonesByNameRequest {
  DNSName?: string | null;
  HostedZoneId?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListHostedZonesByVPCRequest {
  VPCId: string;
  VPCRegion: VPCRegion;
  MaxItems?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListQueryLoggingConfigsRequest {
  HostedZoneId?: string | null;
  NextToken?: string | null;
  MaxResults?: string | null;
}

// refs: 1 - tags: named, input
export interface ListResourceRecordSetsRequest {
  HostedZoneId: string;
  StartRecordName?: string | null;
  StartRecordType?: RRType | null;
  StartRecordIdentifier?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListReusableDelegationSetsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceType: TagResourceType;
  ResourceId: string;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourcesRequest {
  ResourceType: TagResourceType;
  ResourceIds: string[];
}

// refs: 1 - tags: named, input
export interface ListTrafficPoliciesRequest {
  TrafficPolicyIdMarker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTrafficPolicyInstancesRequest {
  HostedZoneIdMarker?: string | null;
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTrafficPolicyInstancesByHostedZoneRequest {
  HostedZoneId: string;
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTrafficPolicyInstancesByPolicyRequest {
  TrafficPolicyId: string;
  TrafficPolicyVersion: number;
  HostedZoneIdMarker?: string | null;
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTrafficPolicyVersionsRequest {
  Id: string;
  TrafficPolicyVersionMarker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListVPCAssociationAuthorizationsRequest {
  HostedZoneId: string;
  NextToken?: string | null;
  MaxResults?: string | null;
}

// refs: 1 - tags: named, input
export interface TestDNSAnswerRequest {
  HostedZoneId: string;
  RecordName: string;
  RecordType: RRType;
  ResolverIP?: string | null;
  EDNS0ClientSubnetIP?: string | null;
  EDNS0ClientSubnetMask?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateHealthCheckRequest {
  HealthCheckId: string;
  HealthCheckVersion?: number | null;
  IPAddress?: string | null;
  Port?: number | null;
  ResourcePath?: string | null;
  FullyQualifiedDomainName?: string | null;
  SearchString?: string | null;
  FailureThreshold?: number | null;
  Inverted?: boolean | null;
  Disabled?: boolean | null;
  HealthThreshold?: number | null;
  ChildHealthChecks?: string[] | null;
  EnableSNI?: boolean | null;
  Regions?: HealthCheckRegion[] | null;
  AlarmIdentifier?: AlarmIdentifier | null;
  InsufficientDataHealthStatus?: InsufficientDataHealthStatus | null;
  ResetElements?: ResettableElementName[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateHostedZoneCommentRequest {
  Id: string;
  Comment?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateTrafficPolicyCommentRequest {
  Id: string;
  Version: number;
  Comment: string;
}

// refs: 1 - tags: named, input
export interface UpdateTrafficPolicyInstanceRequest {
  Id: string;
  TTL: number;
  TrafficPolicyId: string;
  TrafficPolicyVersion: number;
}

// refs: 1 - tags: named, output
export interface ActivateKeySigningKeyResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface AssociateVPCWithHostedZoneResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface ChangeResourceRecordSetsResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface ChangeTagsForResourceResponse {
}

// refs: 1 - tags: named, output
export interface CreateHealthCheckResponse {
  HealthCheck: HealthCheck;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateHostedZoneResponse {
  HostedZone: HostedZone;
  ChangeInfo: ChangeInfo;
  DelegationSet: DelegationSet;
  VPC?: VPC | null;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateKeySigningKeyResponse {
  ChangeInfo: ChangeInfo;
  KeySigningKey: KeySigningKey;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateQueryLoggingConfigResponse {
  QueryLoggingConfig: QueryLoggingConfig;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateReusableDelegationSetResponse {
  DelegationSet: DelegationSet;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateTrafficPolicyResponse {
  TrafficPolicy: TrafficPolicy;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateTrafficPolicyInstanceResponse {
  TrafficPolicyInstance: TrafficPolicyInstance;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateTrafficPolicyVersionResponse {
  TrafficPolicy: TrafficPolicy;
  Location: string;
}

// refs: 1 - tags: named, output
export interface CreateVPCAssociationAuthorizationResponse {
  HostedZoneId: string;
  VPC: VPC;
}

// refs: 1 - tags: named, output
export interface DeactivateKeySigningKeyResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface DeleteHealthCheckResponse {
}

// refs: 1 - tags: named, output
export interface DeleteHostedZoneResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface DeleteKeySigningKeyResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface DeleteQueryLoggingConfigResponse {
}

// refs: 1 - tags: named, output
export interface DeleteReusableDelegationSetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTrafficPolicyResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTrafficPolicyInstanceResponse {
}

// refs: 1 - tags: named, output
export interface DeleteVPCAssociationAuthorizationResponse {
}

// refs: 1 - tags: named, output
export interface DisableHostedZoneDNSSECResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface DisassociateVPCFromHostedZoneResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface EnableHostedZoneDNSSECResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface GetAccountLimitResponse {
  Limit: AccountLimit;
  Count: number;
}

// refs: 1 - tags: named, output
export interface GetChangeResponse {
  ChangeInfo: ChangeInfo;
}

// refs: 1 - tags: named, output
export interface GetCheckerIpRangesResponse {
  CheckerIpRanges: string[];
}

// refs: 1 - tags: named, output
export interface GetDNSSECResponse {
  Status: DNSSECStatus;
  KeySigningKeys: KeySigningKey[];
}

// refs: 1 - tags: named, output
export interface GetGeoLocationResponse {
  GeoLocationDetails: GeoLocationDetails;
}

// refs: 1 - tags: named, output
export interface GetHealthCheckResponse {
  HealthCheck: HealthCheck;
}

// refs: 1 - tags: named, output
export interface GetHealthCheckCountResponse {
  HealthCheckCount: number;
}

// refs: 1 - tags: named, output
export interface GetHealthCheckLastFailureReasonResponse {
  HealthCheckObservations: HealthCheckObservation[];
}

// refs: 1 - tags: named, output
export interface GetHealthCheckStatusResponse {
  HealthCheckObservations: HealthCheckObservation[];
}

// refs: 1 - tags: named, output
export interface GetHostedZoneResponse {
  HostedZone: HostedZone;
  DelegationSet?: DelegationSet | null;
  VPCs: VPC[];
}

// refs: 1 - tags: named, output
export interface GetHostedZoneCountResponse {
  HostedZoneCount: number;
}

// refs: 1 - tags: named, output
export interface GetHostedZoneLimitResponse {
  Limit: HostedZoneLimit;
  Count: number;
}

// refs: 1 - tags: named, output
export interface GetQueryLoggingConfigResponse {
  QueryLoggingConfig: QueryLoggingConfig;
}

// refs: 1 - tags: named, output
export interface GetReusableDelegationSetResponse {
  DelegationSet: DelegationSet;
}

// refs: 1 - tags: named, output
export interface GetReusableDelegationSetLimitResponse {
  Limit: ReusableDelegationSetLimit;
  Count: number;
}

// refs: 1 - tags: named, output
export interface GetTrafficPolicyResponse {
  TrafficPolicy: TrafficPolicy;
}

// refs: 1 - tags: named, output
export interface GetTrafficPolicyInstanceResponse {
  TrafficPolicyInstance: TrafficPolicyInstance;
}

// refs: 1 - tags: named, output
export interface GetTrafficPolicyInstanceCountResponse {
  TrafficPolicyInstanceCount: number;
}

// refs: 1 - tags: named, output
export interface ListGeoLocationsResponse {
  GeoLocationDetailsList: GeoLocationDetails[];
  IsTruncated: boolean;
  NextContinentCode?: string | null;
  NextCountryCode?: string | null;
  NextSubdivisionCode?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListHealthChecksResponse {
  HealthChecks: HealthCheck[];
  Marker: string;
  IsTruncated: boolean;
  NextMarker?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListHostedZonesResponse {
  HostedZones: HostedZone[];
  Marker?: string | null;
  IsTruncated: boolean;
  NextMarker?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListHostedZonesByNameResponse {
  HostedZones: HostedZone[];
  DNSName?: string | null;
  HostedZoneId?: string | null;
  IsTruncated: boolean;
  NextDNSName?: string | null;
  NextHostedZoneId?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListHostedZonesByVPCResponse {
  HostedZoneSummaries: HostedZoneSummary[];
  MaxItems: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListQueryLoggingConfigsResponse {
  QueryLoggingConfigs: QueryLoggingConfig[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListResourceRecordSetsResponse {
  ResourceRecordSets: ResourceRecordSet[];
  IsTruncated: boolean;
  NextRecordName?: string | null;
  NextRecordType?: RRType | null;
  NextRecordIdentifier?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListReusableDelegationSetsResponse {
  DelegationSets: DelegationSet[];
  Marker: string;
  IsTruncated: boolean;
  NextMarker?: string | null;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  ResourceTagSet: ResourceTagSet;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourcesResponse {
  ResourceTagSets: ResourceTagSet[];
}

// refs: 1 - tags: named, output
export interface ListTrafficPoliciesResponse {
  TrafficPolicySummaries: TrafficPolicySummary[];
  IsTruncated: boolean;
  TrafficPolicyIdMarker: string;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListTrafficPolicyInstancesResponse {
  TrafficPolicyInstances: TrafficPolicyInstance[];
  HostedZoneIdMarker?: string | null;
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  IsTruncated: boolean;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListTrafficPolicyInstancesByHostedZoneResponse {
  TrafficPolicyInstances: TrafficPolicyInstance[];
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  IsTruncated: boolean;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListTrafficPolicyInstancesByPolicyResponse {
  TrafficPolicyInstances: TrafficPolicyInstance[];
  HostedZoneIdMarker?: string | null;
  TrafficPolicyInstanceNameMarker?: string | null;
  TrafficPolicyInstanceTypeMarker?: RRType | null;
  IsTruncated: boolean;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListTrafficPolicyVersionsResponse {
  TrafficPolicies: TrafficPolicy[];
  IsTruncated: boolean;
  TrafficPolicyVersionMarker: string;
  MaxItems: string;
}

// refs: 1 - tags: named, output
export interface ListVPCAssociationAuthorizationsResponse {
  HostedZoneId: string;
  NextToken?: string | null;
  VPCs: VPC[];
}

// refs: 1 - tags: named, output
export interface TestDNSAnswerResponse {
  Nameserver: string;
  RecordName: string;
  RecordType: RRType;
  RecordData: string[];
  ResponseCode: string;
  Protocol: string;
}

// refs: 1 - tags: named, output
export interface UpdateHealthCheckResponse {
  HealthCheck: HealthCheck;
}

// refs: 1 - tags: named, output
export interface UpdateHostedZoneCommentResponse {
  HostedZone: HostedZone;
}

// refs: 1 - tags: named, output
export interface UpdateTrafficPolicyCommentResponse {
  TrafficPolicy: TrafficPolicy;
}

// refs: 1 - tags: named, output
export interface UpdateTrafficPolicyInstanceResponse {
  TrafficPolicyInstance: TrafficPolicyInstance;
}

// refs: 9 - tags: input, named, interface, output
export interface VPC {
  VPCRegion?: VPCRegion | null;
  VPCId?: string | null;
}
function VPC_Serialize(data: VPC | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "VPCRegion", content: data["VPCRegion"]?.toString()},
    {name: "VPCId", content: data["VPCId"]?.toString()},
  ]};
}
function VPC_Parse(node: xmlP.XmlNode): VPC {
  return {
    ...node.strings({
      optional: {"VPCId":true},
    }),
    VPCRegion: node.first("VPCRegion", false, x => (x.content ?? '') as VPCRegion),
  };
}

// refs: 10 - tags: input, named, enum, output
export type VPCRegion =
| "us-east-1"
| "us-east-2"
| "us-west-1"
| "us-west-2"
| "eu-west-1"
| "eu-west-2"
| "eu-west-3"
| "eu-central-1"
| "ap-east-1"
| "me-south-1"
| "us-gov-west-1"
| "us-gov-east-1"
| "us-iso-east-1"
| "us-isob-east-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-south-1"
| "ap-northeast-1"
| "ap-northeast-2"
| "ap-northeast-3"
| "eu-north-1"
| "sa-east-1"
| "ca-central-1"
| "cn-north-1"
| "af-south-1"
| "eu-south-1"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface ChangeBatch {
  Comment?: string | null;
  Changes: Change[];
}
function ChangeBatch_Serialize(data: ChangeBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Changes", children: data["Changes"]?.map(x => ({name: "Change", ...Change_Serialize(x)}))},
  ]};
}

// refs: 1 - tags: input, named, interface
export interface Change {
  Action: ChangeAction;
  ResourceRecordSet: ResourceRecordSet;
}
function Change_Serialize(data: Change | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Action", content: data["Action"]?.toString()},
    {name: "ResourceRecordSet", ...ResourceRecordSet_Serialize(data["ResourceRecordSet"])},
  ]};
}

// refs: 1 - tags: input, named, enum
export type ChangeAction =
| "CREATE"
| "DELETE"
| "UPSERT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ResourceRecordSet {
  Name: string;
  Type: RRType;
  SetIdentifier?: string | null;
  Weight?: number | null;
  Region?: ResourceRecordSetRegion | null;
  GeoLocation?: GeoLocation | null;
  Failover?: ResourceRecordSetFailover | null;
  MultiValueAnswer?: boolean | null;
  TTL?: number | null;
  ResourceRecords: ResourceRecord[];
  AliasTarget?: AliasTarget | null;
  HealthCheckId?: string | null;
  TrafficPolicyInstanceId?: string | null;
}
function ResourceRecordSet_Serialize(data: ResourceRecordSet | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "SetIdentifier", content: data["SetIdentifier"]?.toString()},
    {name: "Weight", content: data["Weight"]?.toString()},
    {name: "Region", content: data["Region"]?.toString()},
    {name: "GeoLocation", ...GeoLocation_Serialize(data["GeoLocation"])},
    {name: "Failover", content: data["Failover"]?.toString()},
    {name: "MultiValueAnswer", content: data["MultiValueAnswer"]?.toString()},
    {name: "TTL", content: data["TTL"]?.toString()},
    {name: "ResourceRecords", children: data["ResourceRecords"]?.map(x => ({name: "ResourceRecord", ...ResourceRecord_Serialize(x)}))},
    {name: "AliasTarget", ...AliasTarget_Serialize(data["AliasTarget"])},
    {name: "HealthCheckId", content: data["HealthCheckId"]?.toString()},
    {name: "TrafficPolicyInstanceId", content: data["TrafficPolicyInstanceId"]?.toString()},
  ]};
}
function ResourceRecordSet_Parse(node: xmlP.XmlNode): ResourceRecordSet {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"SetIdentifier":true,"HealthCheckId":true,"TrafficPolicyInstanceId":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as RRType),
    Weight: node.first("Weight", false, x => parseInt(x.content ?? '0')),
    Region: node.first("Region", false, x => (x.content ?? '') as ResourceRecordSetRegion),
    GeoLocation: node.first("GeoLocation", false, GeoLocation_Parse),
    Failover: node.first("Failover", false, x => (x.content ?? '') as ResourceRecordSetFailover),
    MultiValueAnswer: node.first("MultiValueAnswer", false, x => x.content === 'true'),
    TTL: node.first("TTL", false, x => parseInt(x.content ?? '0')),
    ResourceRecords: node.getList("ResourceRecords", "ResourceRecord").map(ResourceRecord_Parse),
    AliasTarget: node.first("AliasTarget", false, AliasTarget_Parse),
  };
}

// refs: 24 - tags: input, named, enum, output
export type RRType =
| "SOA"
| "A"
| "TXT"
| "NS"
| "CNAME"
| "MX"
| "NAPTR"
| "PTR"
| "SRV"
| "SPF"
| "AAAA"
| "CAA"
| "DS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ResourceRecordSetRegion =
| "us-east-1"
| "us-east-2"
| "us-west-1"
| "us-west-2"
| "ca-central-1"
| "eu-west-1"
| "eu-west-2"
| "eu-west-3"
| "eu-central-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-northeast-1"
| "ap-northeast-2"
| "ap-northeast-3"
| "eu-north-1"
| "sa-east-1"
| "cn-north-1"
| "cn-northwest-1"
| "ap-east-1"
| "me-south-1"
| "ap-south-1"
| "af-south-1"
| "eu-south-1"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface GeoLocation {
  ContinentCode?: string | null;
  CountryCode?: string | null;
  SubdivisionCode?: string | null;
}
function GeoLocation_Serialize(data: GeoLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ContinentCode", content: data["ContinentCode"]?.toString()},
    {name: "CountryCode", content: data["CountryCode"]?.toString()},
    {name: "SubdivisionCode", content: data["SubdivisionCode"]?.toString()},
  ]};
}
function GeoLocation_Parse(node: xmlP.XmlNode): GeoLocation {
  return node.strings({
    optional: {"ContinentCode":true,"CountryCode":true,"SubdivisionCode":true},
  });
}

// refs: 2 - tags: input, named, enum, output
export type ResourceRecordSetFailover =
| "PRIMARY"
| "SECONDARY"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ResourceRecord {
  Value: string;
}
function ResourceRecord_Serialize(data: ResourceRecord | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function ResourceRecord_Parse(node: xmlP.XmlNode): ResourceRecord {
  return node.strings({
    required: {"Value":true},
  });
}

// refs: 2 - tags: input, named, interface, output
export interface AliasTarget {
  HostedZoneId: string;
  DNSName: string;
  EvaluateTargetHealth: boolean;
}
function AliasTarget_Serialize(data: AliasTarget | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostedZoneId", content: data["HostedZoneId"]?.toString()},
    {name: "DNSName", content: data["DNSName"]?.toString()},
    {name: "EvaluateTargetHealth", content: data["EvaluateTargetHealth"]?.toString()},
  ]};
}
function AliasTarget_Parse(node: xmlP.XmlNode): AliasTarget {
  return {
    ...node.strings({
      required: {"HostedZoneId":true,"DNSName":true},
    }),
    EvaluateTargetHealth: node.first("EvaluateTargetHealth", true, x => x.content === 'true'),
  };
}

// refs: 5 - tags: input, named, enum, output
export type TagResourceType =
| "healthcheck"
| "hostedzone"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface Tag {
  Key?: string | null;
  Value?: string | null;
}
function Tag_Serialize(data: Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

// refs: 5 - tags: input, named, interface, output
export interface HealthCheckConfig {
  IPAddress?: string | null;
  Port?: number | null;
  Type: HealthCheckType;
  ResourcePath?: string | null;
  FullyQualifiedDomainName?: string | null;
  SearchString?: string | null;
  RequestInterval?: number | null;
  FailureThreshold?: number | null;
  MeasureLatency?: boolean | null;
  Inverted?: boolean | null;
  Disabled?: boolean | null;
  HealthThreshold?: number | null;
  ChildHealthChecks: string[];
  EnableSNI?: boolean | null;
  Regions: HealthCheckRegion[];
  AlarmIdentifier?: AlarmIdentifier | null;
  InsufficientDataHealthStatus?: InsufficientDataHealthStatus | null;
}
function HealthCheckConfig_Serialize(data: HealthCheckConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IPAddress", content: data["IPAddress"]?.toString()},
    {name: "Port", content: data["Port"]?.toString()},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "ResourcePath", content: data["ResourcePath"]?.toString()},
    {name: "FullyQualifiedDomainName", content: data["FullyQualifiedDomainName"]?.toString()},
    {name: "SearchString", content: data["SearchString"]?.toString()},
    {name: "RequestInterval", content: data["RequestInterval"]?.toString()},
    {name: "FailureThreshold", content: data["FailureThreshold"]?.toString()},
    {name: "MeasureLatency", content: data["MeasureLatency"]?.toString()},
    {name: "Inverted", content: data["Inverted"]?.toString()},
    {name: "Disabled", content: data["Disabled"]?.toString()},
    {name: "HealthThreshold", content: data["HealthThreshold"]?.toString()},
    {name: "ChildHealthChecks", children: data["ChildHealthChecks"]?.map(x => ({name: "ChildHealthCheck", content: x}))},
    {name: "EnableSNI", content: data["EnableSNI"]?.toString()},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
    {name: "AlarmIdentifier", ...AlarmIdentifier_Serialize(data["AlarmIdentifier"])},
    {name: "InsufficientDataHealthStatus", content: data["InsufficientDataHealthStatus"]?.toString()},
  ]};
}
function HealthCheckConfig_Parse(node: xmlP.XmlNode): HealthCheckConfig {
  return {
    ...node.strings({
      optional: {"IPAddress":true,"ResourcePath":true,"FullyQualifiedDomainName":true,"SearchString":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    Type: node.first("Type", true, x => (x.content ?? '') as HealthCheckType),
    RequestInterval: node.first("RequestInterval", false, x => parseInt(x.content ?? '0')),
    FailureThreshold: node.first("FailureThreshold", false, x => parseInt(x.content ?? '0')),
    MeasureLatency: node.first("MeasureLatency", false, x => x.content === 'true'),
    Inverted: node.first("Inverted", false, x => x.content === 'true'),
    Disabled: node.first("Disabled", false, x => x.content === 'true'),
    HealthThreshold: node.first("HealthThreshold", false, x => parseInt(x.content ?? '0')),
    ChildHealthChecks: node.getList("ChildHealthChecks", "ChildHealthCheck").map(x => x.content ?? ''),
    EnableSNI: node.first("EnableSNI", false, x => x.content === 'true'),
    Regions: node.getList("Regions", "Region").map(x => (x.content ?? '') as HealthCheckRegion),
    AlarmIdentifier: node.first("AlarmIdentifier", false, AlarmIdentifier_Parse),
    InsufficientDataHealthStatus: node.first("InsufficientDataHealthStatus", false, x => (x.content ?? '') as InsufficientDataHealthStatus),
  };
}

// refs: 5 - tags: input, named, enum, output
export type HealthCheckType =
| "HTTP"
| "HTTPS"
| "HTTP_STR_MATCH"
| "HTTPS_STR_MATCH"
| "TCP"
| "CALCULATED"
| "CLOUDWATCH_METRIC"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, enum, output
export type HealthCheckRegion =
| "us-east-1"
| "us-west-1"
| "us-west-2"
| "eu-west-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-northeast-1"
| "sa-east-1"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface AlarmIdentifier {
  Region: CloudWatchRegion;
  Name: string;
}
function AlarmIdentifier_Serialize(data: AlarmIdentifier | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Region", content: data["Region"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
  ]};
}
function AlarmIdentifier_Parse(node: xmlP.XmlNode): AlarmIdentifier {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Region: node.first("Region", true, x => (x.content ?? '') as CloudWatchRegion),
  };
}

// refs: 6 - tags: input, named, enum, output
export type CloudWatchRegion =
| "us-east-1"
| "us-east-2"
| "us-west-1"
| "us-west-2"
| "ca-central-1"
| "eu-central-1"
| "eu-west-1"
| "eu-west-2"
| "eu-west-3"
| "ap-east-1"
| "me-south-1"
| "ap-south-1"
| "ap-southeast-1"
| "ap-southeast-2"
| "ap-northeast-1"
| "ap-northeast-2"
| "ap-northeast-3"
| "eu-north-1"
| "sa-east-1"
| "cn-northwest-1"
| "cn-north-1"
| "af-south-1"
| "eu-south-1"
| "us-gov-west-1"
| "us-gov-east-1"
| "us-iso-east-1"
| "us-isob-east-1"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type InsufficientDataHealthStatus =
| "Healthy"
| "Unhealthy"
| "LastKnownStatus"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface HostedZoneConfig {
  Comment?: string | null;
  PrivateZone?: boolean | null;
}
function HostedZoneConfig_Serialize(data: HostedZoneConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "PrivateZone", content: data["PrivateZone"]?.toString()},
  ]};
}
function HostedZoneConfig_Parse(node: xmlP.XmlNode): HostedZoneConfig {
  return {
    ...node.strings({
      optional: {"Comment":true},
    }),
    PrivateZone: node.first("PrivateZone", false, x => x.content === 'true'),
  };
}

// refs: 2 - tags: input, named, enum, output
export type AccountLimitType =
| "MAX_HEALTH_CHECKS_BY_OWNER"
| "MAX_HOSTED_ZONES_BY_OWNER"
| "MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER"
| "MAX_REUSABLE_DELEGATION_SETS_BY_OWNER"
| "MAX_TRAFFIC_POLICIES_BY_OWNER"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type HostedZoneLimitType =
| "MAX_RRSETS_BY_ZONE"
| "MAX_VPCS_ASSOCIATED_BY_ZONE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type ReusableDelegationSetLimitType =
| "MAX_ZONES_BY_REUSABLE_DELEGATION_SET"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ResettableElementName =
| "FullyQualifiedDomainName"
| "Regions"
| "ResourcePath"
| "ChildHealthChecks"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: output, named, interface
export interface ChangeInfo {
  Id: string;
  Status: ChangeStatus;
  SubmittedAt: Date | number;
  Comment?: string | null;
}
function ChangeInfo_Parse(node: xmlP.XmlNode): ChangeInfo {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Comment":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as ChangeStatus),
    SubmittedAt: node.first("SubmittedAt", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 12 - tags: output, named, enum
export type ChangeStatus =
| "PENDING"
| "INSYNC"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface HealthCheck {
  Id: string;
  CallerReference: string;
  LinkedService?: LinkedService | null;
  HealthCheckConfig: HealthCheckConfig;
  HealthCheckVersion: number;
  CloudWatchAlarmConfiguration?: CloudWatchAlarmConfiguration | null;
}
function HealthCheck_Parse(node: xmlP.XmlNode): HealthCheck {
  return {
    ...node.strings({
      required: {"Id":true,"CallerReference":true},
    }),
    LinkedService: node.first("LinkedService", false, LinkedService_Parse),
    HealthCheckConfig: node.first("HealthCheckConfig", true, HealthCheckConfig_Parse),
    HealthCheckVersion: node.first("HealthCheckVersion", true, x => parseInt(x.content ?? '0')),
    CloudWatchAlarmConfiguration: node.first("CloudWatchAlarmConfiguration", false, CloudWatchAlarmConfiguration_Parse),
  };
}

// refs: 9 - tags: output, named, interface
export interface LinkedService {
  ServicePrincipal?: string | null;
  Description?: string | null;
}
function LinkedService_Parse(node: xmlP.XmlNode): LinkedService {
  return node.strings({
    optional: {"ServicePrincipal":true,"Description":true},
  });
}

// refs: 4 - tags: output, named, interface
export interface CloudWatchAlarmConfiguration {
  EvaluationPeriods: number;
  Threshold: number;
  ComparisonOperator: ComparisonOperator;
  Period: number;
  MetricName: string;
  Namespace: string;
  Statistic: Statistic;
  Dimensions: Dimension[];
}
function CloudWatchAlarmConfiguration_Parse(node: xmlP.XmlNode): CloudWatchAlarmConfiguration {
  return {
    ...node.strings({
      required: {"MetricName":true,"Namespace":true},
    }),
    EvaluationPeriods: node.first("EvaluationPeriods", true, x => parseInt(x.content ?? '0')),
    Threshold: node.first("Threshold", true, x => parseFloat(x.content ?? '0')),
    ComparisonOperator: node.first("ComparisonOperator", true, x => (x.content ?? '') as ComparisonOperator),
    Period: node.first("Period", true, x => parseInt(x.content ?? '0')),
    Statistic: node.first("Statistic", true, x => (x.content ?? '') as Statistic),
    Dimensions: node.getList("Dimensions", "Dimension").map(Dimension_Parse),
  };
}

// refs: 4 - tags: output, named, enum
export type ComparisonOperator =
| "GreaterThanOrEqualToThreshold"
| "GreaterThanThreshold"
| "LessThanThreshold"
| "LessThanOrEqualToThreshold"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type Statistic =
| "Average"
| "Sum"
| "SampleCount"
| "Maximum"
| "Minimum"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Dimension {
  Name: string;
  Value: string;
}
function Dimension_Parse(node: xmlP.XmlNode): Dimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface HostedZone {
  Id: string;
  Name: string;
  CallerReference: string;
  Config?: HostedZoneConfig | null;
  ResourceRecordSetCount?: number | null;
  LinkedService?: LinkedService | null;
}
function HostedZone_Parse(node: xmlP.XmlNode): HostedZone {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"CallerReference":true},
    }),
    Config: node.first("Config", false, HostedZoneConfig_Parse),
    ResourceRecordSetCount: node.first("ResourceRecordSetCount", false, x => parseInt(x.content ?? '0')),
    LinkedService: node.first("LinkedService", false, LinkedService_Parse),
  };
}

// refs: 5 - tags: output, named, interface
export interface DelegationSet {
  Id?: string | null;
  CallerReference?: string | null;
  NameServers: string[];
}
function DelegationSet_Parse(node: xmlP.XmlNode): DelegationSet {
  return {
    ...node.strings({
      optional: {"Id":true,"CallerReference":true},
    }),
    NameServers: node.getList("NameServers", "NameServer").map(x => x.content ?? ''),
  };
}

// refs: 2 - tags: output, named, interface
export interface KeySigningKey {
  Name?: string | null;
  KmsArn?: string | null;
  Flag?: number | null;
  SigningAlgorithmMnemonic?: string | null;
  SigningAlgorithmType?: number | null;
  DigestAlgorithmMnemonic?: string | null;
  DigestAlgorithmType?: number | null;
  KeyTag?: number | null;
  DigestValue?: string | null;
  PublicKey?: string | null;
  DSRecord?: string | null;
  DNSKEYRecord?: string | null;
  Status?: string | null;
  StatusMessage?: string | null;
  CreatedDate?: Date | number | null;
  LastModifiedDate?: Date | number | null;
}
function KeySigningKey_Parse(node: xmlP.XmlNode): KeySigningKey {
  return {
    ...node.strings({
      optional: {"Name":true,"KmsArn":true,"SigningAlgorithmMnemonic":true,"DigestAlgorithmMnemonic":true,"DigestValue":true,"PublicKey":true,"DSRecord":true,"DNSKEYRecord":true,"Status":true,"StatusMessage":true},
    }),
    Flag: node.first("Flag", false, x => parseInt(x.content ?? '0')),
    SigningAlgorithmType: node.first("SigningAlgorithmType", false, x => parseInt(x.content ?? '0')),
    DigestAlgorithmType: node.first("DigestAlgorithmType", false, x => parseInt(x.content ?? '0')),
    KeyTag: node.first("KeyTag", false, x => parseInt(x.content ?? '0')),
    CreatedDate: node.first("CreatedDate", false, x => xmlP.parseTimestamp(x.content)),
    LastModifiedDate: node.first("LastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 3 - tags: output, named, interface
export interface QueryLoggingConfig {
  Id: string;
  HostedZoneId: string;
  CloudWatchLogsLogGroupArn: string;
}
function QueryLoggingConfig_Parse(node: xmlP.XmlNode): QueryLoggingConfig {
  return node.strings({
    required: {"Id":true,"HostedZoneId":true,"CloudWatchLogsLogGroupArn":true},
  });
}

// refs: 5 - tags: output, named, interface
export interface TrafficPolicy {
  Id: string;
  Version: number;
  Name: string;
  Type: RRType;
  Document: string;
  Comment?: string | null;
}
function TrafficPolicy_Parse(node: xmlP.XmlNode): TrafficPolicy {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"Document":true},
      optional: {"Comment":true},
    }),
    Version: node.first("Version", true, x => parseInt(x.content ?? '0')),
    Type: node.first("Type", true, x => (x.content ?? '') as RRType),
  };
}

// refs: 6 - tags: output, named, interface
export interface TrafficPolicyInstance {
  Id: string;
  HostedZoneId: string;
  Name: string;
  TTL: number;
  State: string;
  Message: string;
  TrafficPolicyId: string;
  TrafficPolicyVersion: number;
  TrafficPolicyType: RRType;
}
function TrafficPolicyInstance_Parse(node: xmlP.XmlNode): TrafficPolicyInstance {
  return {
    ...node.strings({
      required: {"Id":true,"HostedZoneId":true,"Name":true,"State":true,"Message":true,"TrafficPolicyId":true},
    }),
    TTL: node.first("TTL", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyVersion: node.first("TrafficPolicyVersion", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyType: node.first("TrafficPolicyType", true, x => (x.content ?? '') as RRType),
  };
}

// refs: 1 - tags: output, named, interface
export interface AccountLimit {
  Type: AccountLimitType;
  Value: number;
}
function AccountLimit_Parse(node: xmlP.XmlNode): AccountLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as AccountLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface DNSSECStatus {
  ServeSignature?: string | null;
  StatusMessage?: string | null;
}
function DNSSECStatus_Parse(node: xmlP.XmlNode): DNSSECStatus {
  return node.strings({
    optional: {"ServeSignature":true,"StatusMessage":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface GeoLocationDetails {
  ContinentCode?: string | null;
  ContinentName?: string | null;
  CountryCode?: string | null;
  CountryName?: string | null;
  SubdivisionCode?: string | null;
  SubdivisionName?: string | null;
}
function GeoLocationDetails_Parse(node: xmlP.XmlNode): GeoLocationDetails {
  return node.strings({
    optional: {"ContinentCode":true,"ContinentName":true,"CountryCode":true,"CountryName":true,"SubdivisionCode":true,"SubdivisionName":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface HealthCheckObservation {
  Region?: HealthCheckRegion | null;
  IPAddress?: string | null;
  StatusReport?: StatusReport | null;
}
function HealthCheckObservation_Parse(node: xmlP.XmlNode): HealthCheckObservation {
  return {
    ...node.strings({
      optional: {"IPAddress":true},
    }),
    Region: node.first("Region", false, x => (x.content ?? '') as HealthCheckRegion),
    StatusReport: node.first("StatusReport", false, StatusReport_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface StatusReport {
  Status?: string | null;
  CheckedTime?: Date | number | null;
}
function StatusReport_Parse(node: xmlP.XmlNode): StatusReport {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CheckedTime: node.first("CheckedTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface HostedZoneLimit {
  Type: HostedZoneLimitType;
  Value: number;
}
function HostedZoneLimit_Parse(node: xmlP.XmlNode): HostedZoneLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as HostedZoneLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface ReusableDelegationSetLimit {
  Type: ReusableDelegationSetLimitType;
  Value: number;
}
function ReusableDelegationSetLimit_Parse(node: xmlP.XmlNode): ReusableDelegationSetLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as ReusableDelegationSetLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 1 - tags: output, named, interface
export interface HostedZoneSummary {
  HostedZoneId: string;
  Name: string;
  Owner: HostedZoneOwner;
}
function HostedZoneSummary_Parse(node: xmlP.XmlNode): HostedZoneSummary {
  return {
    ...node.strings({
      required: {"HostedZoneId":true,"Name":true},
    }),
    Owner: node.first("Owner", true, HostedZoneOwner_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface HostedZoneOwner {
  OwningAccount?: string | null;
  OwningService?: string | null;
}
function HostedZoneOwner_Parse(node: xmlP.XmlNode): HostedZoneOwner {
  return node.strings({
    optional: {"OwningAccount":true,"OwningService":true},
  });
}

// refs: 2 - tags: output, named, interface
export interface ResourceTagSet {
  ResourceType?: TagResourceType | null;
  ResourceId?: string | null;
  Tags: Tag[];
}
function ResourceTagSet_Parse(node: xmlP.XmlNode): ResourceTagSet {
  return {
    ...node.strings({
      optional: {"ResourceId":true},
    }),
    ResourceType: node.first("ResourceType", false, x => (x.content ?? '') as TagResourceType),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface TrafficPolicySummary {
  Id: string;
  Name: string;
  Type: RRType;
  LatestVersion: number;
  TrafficPolicyCount: number;
}
function TrafficPolicySummary_Parse(node: xmlP.XmlNode): TrafficPolicySummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as RRType),
    LatestVersion: node.first("LatestVersion", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyCount: node.first("TrafficPolicyCount", true, x => parseInt(x.content ?? '0')),
  };
}
