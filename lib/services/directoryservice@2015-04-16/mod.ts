// Autogenerated API client for: AWS Directory Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class DirectoryService {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DirectoryService.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-04-16",
    "endpointPrefix": "ds",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Directory Service",
    "serviceFullName": "AWS Directory Service",
    "serviceId": "Directory Service",
    "signatureVersion": "v4",
    "targetPrefix": "DirectoryService_20150416",
    "uid": "ds-2015-04-16"
  };

  async acceptSharedDirectory(
    {abortSignal, ...params}: RequestConfig & s.AcceptSharedDirectoryRequest,
  ): Promise<s.AcceptSharedDirectoryResult> {
    const body: jsonP.JSONObject = {
      SharedDirectoryId: params["SharedDirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptSharedDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SharedDirectory": toSharedDirectory,
      },
    }, await resp.json());
  }

  async addIpRoutes(
    {abortSignal, ...params}: RequestConfig & s.AddIpRoutesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      IpRoutes: params["IpRoutes"]?.map(x => fromIpRoute(x)),
      UpdateSecurityGroupForDirectoryControllers: params["UpdateSecurityGroupForDirectoryControllers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddIpRoutes",
    });
    await resp.text();
  }

  async addRegion(
    {abortSignal, ...params}: RequestConfig & s.AddRegionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RegionName: params["RegionName"],
      VPCSettings: fromDirectoryVpcSettings(params["VPCSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddRegion",
    });
    await resp.text();
  }

  async addTagsToResource(
    {abortSignal, ...params}: RequestConfig & s.AddTagsToResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTagsToResource",
    });
    await resp.text();
  }

  async cancelSchemaExtension(
    {abortSignal, ...params}: RequestConfig & s.CancelSchemaExtensionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      SchemaExtensionId: params["SchemaExtensionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelSchemaExtension",
    });
    await resp.text();
  }

  async connectDirectory(
    {abortSignal, ...params}: RequestConfig & s.ConnectDirectoryRequest,
  ): Promise<s.ConnectDirectoryResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ShortName: params["ShortName"],
      Password: params["Password"],
      Description: params["Description"],
      Size: params["Size"],
      ConnectSettings: fromDirectoryConnectSettings(params["ConnectSettings"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ConnectDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryId": "s",
      },
    }, await resp.json());
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & s.CreateAliasRequest,
  ): Promise<s.CreateAliasResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Alias: params["Alias"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryId": "s",
        "Alias": "s",
      },
    }, await resp.json());
  }

  async createComputer(
    {abortSignal, ...params}: RequestConfig & s.CreateComputerRequest,
  ): Promise<s.CreateComputerResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      ComputerName: params["ComputerName"],
      Password: params["Password"],
      OrganizationalUnitDistinguishedName: params["OrganizationalUnitDistinguishedName"],
      ComputerAttributes: params["ComputerAttributes"]?.map(x => fromAttribute(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateComputer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Computer": toComputer,
      },
    }, await resp.json());
  }

  async createConditionalForwarder(
    {abortSignal, ...params}: RequestConfig & s.CreateConditionalForwarderRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RemoteDomainName: params["RemoteDomainName"],
      DnsIpAddrs: params["DnsIpAddrs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConditionalForwarder",
    });
    await resp.text();
  }

  async createDirectory(
    {abortSignal, ...params}: RequestConfig & s.CreateDirectoryRequest,
  ): Promise<s.CreateDirectoryResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ShortName: params["ShortName"],
      Password: params["Password"],
      Description: params["Description"],
      Size: params["Size"],
      VpcSettings: fromDirectoryVpcSettings(params["VpcSettings"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryId": "s",
      },
    }, await resp.json());
  }

  async createLogSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateLogSubscriptionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      LogGroupName: params["LogGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLogSubscription",
    });
    await resp.text();
  }

  async createMicrosoftAD(
    {abortSignal, ...params}: RequestConfig & s.CreateMicrosoftADRequest,
  ): Promise<s.CreateMicrosoftADResult> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      ShortName: params["ShortName"],
      Password: params["Password"],
      Description: params["Description"],
      VpcSettings: fromDirectoryVpcSettings(params["VpcSettings"]),
      Edition: params["Edition"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMicrosoftAD",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryId": "s",
      },
    }, await resp.json());
  }

  async createSnapshot(
    {abortSignal, ...params}: RequestConfig & s.CreateSnapshotRequest,
  ): Promise<s.CreateSnapshotResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SnapshotId": "s",
      },
    }, await resp.json());
  }

  async createTrust(
    {abortSignal, ...params}: RequestConfig & s.CreateTrustRequest,
  ): Promise<s.CreateTrustResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RemoteDomainName: params["RemoteDomainName"],
      TrustPassword: params["TrustPassword"],
      TrustDirection: params["TrustDirection"],
      TrustType: params["TrustType"],
      ConditionalForwarderIpAddrs: params["ConditionalForwarderIpAddrs"],
      SelectiveAuth: params["SelectiveAuth"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrust",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrustId": "s",
      },
    }, await resp.json());
  }

  async deleteConditionalForwarder(
    {abortSignal, ...params}: RequestConfig & s.DeleteConditionalForwarderRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RemoteDomainName: params["RemoteDomainName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConditionalForwarder",
    });
    await resp.text();
  }

  async deleteDirectory(
    {abortSignal, ...params}: RequestConfig & s.DeleteDirectoryRequest,
  ): Promise<s.DeleteDirectoryResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryId": "s",
      },
    }, await resp.json());
  }

  async deleteLogSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteLogSubscriptionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLogSubscription",
    });
    await resp.text();
  }

  async deleteSnapshot(
    {abortSignal, ...params}: RequestConfig & s.DeleteSnapshotRequest,
  ): Promise<s.DeleteSnapshotResult> {
    const body: jsonP.JSONObject = {
      SnapshotId: params["SnapshotId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSnapshot",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SnapshotId": "s",
      },
    }, await resp.json());
  }

  async deleteTrust(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrustRequest,
  ): Promise<s.DeleteTrustResult> {
    const body: jsonP.JSONObject = {
      TrustId: params["TrustId"],
      DeleteAssociatedConditionalForwarder: params["DeleteAssociatedConditionalForwarder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrust",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrustId": "s",
      },
    }, await resp.json());
  }

  async deregisterCertificate(
    {abortSignal, ...params}: RequestConfig & s.DeregisterCertificateRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      CertificateId: params["CertificateId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterCertificate",
    });
    await resp.text();
  }

  async deregisterEventTopic(
    {abortSignal, ...params}: RequestConfig & s.DeregisterEventTopicRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      TopicName: params["TopicName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterEventTopic",
    });
    await resp.text();
  }

  async describeCertificate(
    {abortSignal, ...params}: RequestConfig & s.DescribeCertificateRequest,
  ): Promise<s.DescribeCertificateResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      CertificateId: params["CertificateId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Certificate": toCertificate,
      },
    }, await resp.json());
  }

  async describeConditionalForwarders(
    {abortSignal, ...params}: RequestConfig & s.DescribeConditionalForwardersRequest,
  ): Promise<s.DescribeConditionalForwardersResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RemoteDomainNames: params["RemoteDomainNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConditionalForwarders",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConditionalForwarders": [toConditionalForwarder],
      },
    }, await resp.json());
  }

  async describeDirectories(
    {abortSignal, ...params}: RequestConfig & s.DescribeDirectoriesRequest = {},
  ): Promise<s.DescribeDirectoriesResult> {
    const body: jsonP.JSONObject = {
      DirectoryIds: params["DirectoryIds"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDirectories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryDescriptions": [toDirectoryDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeDomainControllers(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainControllersRequest,
  ): Promise<s.DescribeDomainControllersResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      DomainControllerIds: params["DomainControllerIds"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomainControllers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainControllers": [toDomainController],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeEventTopics(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventTopicsRequest = {},
  ): Promise<s.DescribeEventTopicsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      TopicNames: params["TopicNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventTopics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EventTopics": [toEventTopic],
      },
    }, await resp.json());
  }

  async describeLDAPSSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeLDAPSSettingsRequest,
  ): Promise<s.DescribeLDAPSSettingsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Type: params["Type"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLDAPSSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LDAPSSettingsInfo": [toLDAPSSettingInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeRegions(
    {abortSignal, ...params}: RequestConfig & s.DescribeRegionsRequest,
  ): Promise<s.DescribeRegionsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RegionName: params["RegionName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeRegions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegionsDescription": [toRegionDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeSharedDirectories(
    {abortSignal, ...params}: RequestConfig & s.DescribeSharedDirectoriesRequest,
  ): Promise<s.DescribeSharedDirectoriesResult> {
    const body: jsonP.JSONObject = {
      OwnerDirectoryId: params["OwnerDirectoryId"],
      SharedDirectoryIds: params["SharedDirectoryIds"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSharedDirectories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SharedDirectories": [toSharedDirectory],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeSnapshots(
    {abortSignal, ...params}: RequestConfig & s.DescribeSnapshotsRequest = {},
  ): Promise<s.DescribeSnapshotsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      SnapshotIds: params["SnapshotIds"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSnapshots",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Snapshots": [toSnapshot],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeTrusts(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrustsRequest = {},
  ): Promise<s.DescribeTrustsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      TrustIds: params["TrustIds"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrusts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Trusts": [toTrust],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disableClientAuthentication(
    {abortSignal, ...params}: RequestConfig & s.DisableClientAuthenticationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableClientAuthentication",
    });
    await resp.text();
  }

  async disableLDAPS(
    {abortSignal, ...params}: RequestConfig & s.DisableLDAPSRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableLDAPS",
    });
    await resp.text();
  }

  async disableRadius(
    {abortSignal, ...params}: RequestConfig & s.DisableRadiusRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableRadius",
    });
    await resp.text();
  }

  async disableSso(
    {abortSignal, ...params}: RequestConfig & s.DisableSsoRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      UserName: params["UserName"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableSso",
    });
    await resp.text();
  }

  async enableClientAuthentication(
    {abortSignal, ...params}: RequestConfig & s.EnableClientAuthenticationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableClientAuthentication",
    });
    await resp.text();
  }

  async enableLDAPS(
    {abortSignal, ...params}: RequestConfig & s.EnableLDAPSRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      Type: params["Type"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableLDAPS",
    });
    await resp.text();
  }

  async enableRadius(
    {abortSignal, ...params}: RequestConfig & s.EnableRadiusRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RadiusSettings: fromRadiusSettings(params["RadiusSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableRadius",
    });
    await resp.text();
  }

  async enableSso(
    {abortSignal, ...params}: RequestConfig & s.EnableSsoRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      UserName: params["UserName"],
      Password: params["Password"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableSso",
    });
    await resp.text();
  }

  async getDirectoryLimits(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.GetDirectoryLimitsResult> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDirectoryLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DirectoryLimits": toDirectoryLimits,
      },
    }, await resp.json());
  }

  async getSnapshotLimits(
    {abortSignal, ...params}: RequestConfig & s.GetSnapshotLimitsRequest,
  ): Promise<s.GetSnapshotLimitsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSnapshotLimits",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SnapshotLimits": toSnapshotLimits,
      },
    }, await resp.json());
  }

  async listCertificates(
    {abortSignal, ...params}: RequestConfig & s.ListCertificatesRequest,
  ): Promise<s.ListCertificatesResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCertificates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "CertificatesInfo": [toCertificateInfo],
      },
    }, await resp.json());
  }

  async listIpRoutes(
    {abortSignal, ...params}: RequestConfig & s.ListIpRoutesRequest,
  ): Promise<s.ListIpRoutesResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIpRoutes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IpRoutesInfo": [toIpRouteInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLogSubscriptions(
    {abortSignal, ...params}: RequestConfig & s.ListLogSubscriptionsRequest = {},
  ): Promise<s.ListLogSubscriptionsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLogSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LogSubscriptions": [toLogSubscription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemaExtensions(
    {abortSignal, ...params}: RequestConfig & s.ListSchemaExtensionsRequest,
  ): Promise<s.ListSchemaExtensionsResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemaExtensions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaExtensionsInfo": [toSchemaExtensionInfo],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      NextToken: params["NextToken"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async registerCertificate(
    {abortSignal, ...params}: RequestConfig & s.RegisterCertificateRequest,
  ): Promise<s.RegisterCertificateResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      CertificateData: params["CertificateData"],
      Type: params["Type"],
      ClientCertAuthSettings: fromClientCertAuthSettings(params["ClientCertAuthSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterCertificate",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CertificateId": "s",
      },
    }, await resp.json());
  }

  async registerEventTopic(
    {abortSignal, ...params}: RequestConfig & s.RegisterEventTopicRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      TopicName: params["TopicName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterEventTopic",
    });
    await resp.text();
  }

  async rejectSharedDirectory(
    {abortSignal, ...params}: RequestConfig & s.RejectSharedDirectoryRequest,
  ): Promise<s.RejectSharedDirectoryResult> {
    const body: jsonP.JSONObject = {
      SharedDirectoryId: params["SharedDirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RejectSharedDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SharedDirectoryId": "s",
      },
    }, await resp.json());
  }

  async removeIpRoutes(
    {abortSignal, ...params}: RequestConfig & s.RemoveIpRoutesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      CidrIps: params["CidrIps"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveIpRoutes",
    });
    await resp.text();
  }

  async removeRegion(
    {abortSignal, ...params}: RequestConfig & s.RemoveRegionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveRegion",
    });
    await resp.text();
  }

  async removeTagsFromResource(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsFromResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTagsFromResource",
    });
    await resp.text();
  }

  async resetUserPassword(
    {abortSignal, ...params}: RequestConfig & s.ResetUserPasswordRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      UserName: params["UserName"],
      NewPassword: params["NewPassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetUserPassword",
    });
    await resp.text();
  }

  async restoreFromSnapshot(
    {abortSignal, ...params}: RequestConfig & s.RestoreFromSnapshotRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      SnapshotId: params["SnapshotId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreFromSnapshot",
    });
    await resp.text();
  }

  async shareDirectory(
    {abortSignal, ...params}: RequestConfig & s.ShareDirectoryRequest,
  ): Promise<s.ShareDirectoryResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      ShareNotes: params["ShareNotes"],
      ShareTarget: fromShareTarget(params["ShareTarget"]),
      ShareMethod: params["ShareMethod"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ShareDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SharedDirectoryId": "s",
      },
    }, await resp.json());
  }

  async startSchemaExtension(
    {abortSignal, ...params}: RequestConfig & s.StartSchemaExtensionRequest,
  ): Promise<s.StartSchemaExtensionResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      CreateSnapshotBeforeSchemaExtension: params["CreateSnapshotBeforeSchemaExtension"],
      LdifContent: params["LdifContent"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartSchemaExtension",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaExtensionId": "s",
      },
    }, await resp.json());
  }

  async unshareDirectory(
    {abortSignal, ...params}: RequestConfig & s.UnshareDirectoryRequest,
  ): Promise<s.UnshareDirectoryResult> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      UnshareTarget: fromUnshareTarget(params["UnshareTarget"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UnshareDirectory",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SharedDirectoryId": "s",
      },
    }, await resp.json());
  }

  async updateConditionalForwarder(
    {abortSignal, ...params}: RequestConfig & s.UpdateConditionalForwarderRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RemoteDomainName: params["RemoteDomainName"],
      DnsIpAddrs: params["DnsIpAddrs"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConditionalForwarder",
    });
    await resp.text();
  }

  async updateNumberOfDomainControllers(
    {abortSignal, ...params}: RequestConfig & s.UpdateNumberOfDomainControllersRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      DesiredNumber: params["DesiredNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNumberOfDomainControllers",
    });
    await resp.text();
  }

  async updateRadius(
    {abortSignal, ...params}: RequestConfig & s.UpdateRadiusRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DirectoryId: params["DirectoryId"],
      RadiusSettings: fromRadiusSettings(params["RadiusSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRadius",
    });
    await resp.text();
  }

  async updateTrust(
    {abortSignal, ...params}: RequestConfig & s.UpdateTrustRequest,
  ): Promise<s.UpdateTrustResult> {
    const body: jsonP.JSONObject = {
      TrustId: params["TrustId"],
      SelectiveAuth: params["SelectiveAuth"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrust",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RequestId": "s",
        "TrustId": "s",
      },
    }, await resp.json());
  }

  async verifyTrust(
    {abortSignal, ...params}: RequestConfig & s.VerifyTrustRequest,
  ): Promise<s.VerifyTrustResult> {
    const body: jsonP.JSONObject = {
      TrustId: params["TrustId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "VerifyTrust",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrustId": "s",
      },
    }, await resp.json());
  }

}

function fromIpRoute(input?: s.IpRoute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CidrIp: input["CidrIp"],
    Description: input["Description"],
  }
}

function fromDirectoryVpcSettings(input?: s.DirectoryVpcSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VpcId: input["VpcId"],
    SubnetIds: input["SubnetIds"],
  }
}
function toDirectoryVpcSettings(root: jsonP.JSONValue): s.DirectoryVpcSettings {
  return jsonP.readObj({
    required: {
      "VpcId": "s",
      "SubnetIds": ["s"],
    },
    optional: {},
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromDirectoryConnectSettings(input?: s.DirectoryConnectSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VpcId: input["VpcId"],
    SubnetIds: input["SubnetIds"],
    CustomerDnsIps: input["CustomerDnsIps"],
    CustomerUserName: input["CustomerUserName"],
  }
}

function fromAttribute(input?: s.Attribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toAttribute(root: jsonP.JSONValue): s.Attribute {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Value": "s",
    },
  }, root);
}

function fromRadiusSettings(input?: s.RadiusSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RadiusServers: input["RadiusServers"],
    RadiusPort: input["RadiusPort"],
    RadiusTimeout: input["RadiusTimeout"],
    RadiusRetries: input["RadiusRetries"],
    SharedSecret: input["SharedSecret"],
    AuthenticationProtocol: input["AuthenticationProtocol"],
    DisplayLabel: input["DisplayLabel"],
    UseSameUsername: input["UseSameUsername"],
  }
}
function toRadiusSettings(root: jsonP.JSONValue): s.RadiusSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "RadiusServers": ["s"],
      "RadiusPort": "n",
      "RadiusTimeout": "n",
      "RadiusRetries": "n",
      "SharedSecret": "s",
      "AuthenticationProtocol": (x: jsonP.JSONValue) => cmnP.readEnum<s.RadiusAuthenticationProtocol>(x),
      "DisplayLabel": "s",
      "UseSameUsername": "b",
    },
  }, root);
}

function fromClientCertAuthSettings(input?: s.ClientCertAuthSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OCSPUrl: input["OCSPUrl"],
  }
}
function toClientCertAuthSettings(root: jsonP.JSONValue): s.ClientCertAuthSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "OCSPUrl": "s",
    },
  }, root);
}

function fromShareTarget(input?: s.ShareTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Type: input["Type"],
  }
}

function fromUnshareTarget(input?: s.UnshareTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Type: input["Type"],
  }
}

function toSharedDirectory(root: jsonP.JSONValue): s.SharedDirectory {
  return jsonP.readObj({
    required: {},
    optional: {
      "OwnerAccountId": "s",
      "OwnerDirectoryId": "s",
      "ShareMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.ShareMethod>(x),
      "SharedAccountId": "s",
      "SharedDirectoryId": "s",
      "ShareStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ShareStatus>(x),
      "ShareNotes": "s",
      "CreatedDateTime": "d",
      "LastUpdatedDateTime": "d",
    },
  }, root);
}

function toComputer(root: jsonP.JSONValue): s.Computer {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComputerId": "s",
      "ComputerName": "s",
      "ComputerAttributes": [toAttribute],
    },
  }, root);
}

function toCertificate(root: jsonP.JSONValue): s.Certificate {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateState>(x),
      "StateReason": "s",
      "CommonName": "s",
      "RegisteredDateTime": "d",
      "ExpiryDateTime": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateType>(x),
      "ClientCertAuthSettings": toClientCertAuthSettings,
    },
  }, root);
}

function toConditionalForwarder(root: jsonP.JSONValue): s.ConditionalForwarder {
  return jsonP.readObj({
    required: {},
    optional: {
      "RemoteDomainName": "s",
      "DnsIpAddrs": ["s"],
      "ReplicationScope": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicationScope>(x),
    },
  }, root);
}

function toDirectoryDescription(root: jsonP.JSONValue): s.DirectoryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "Name": "s",
      "ShortName": "s",
      "Size": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectorySize>(x),
      "Edition": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectoryEdition>(x),
      "Alias": "s",
      "AccessUrl": "s",
      "Description": "s",
      "DnsIpAddrs": ["s"],
      "Stage": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectoryStage>(x),
      "ShareStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ShareStatus>(x),
      "ShareMethod": (x: jsonP.JSONValue) => cmnP.readEnum<s.ShareMethod>(x),
      "ShareNotes": "s",
      "LaunchTime": "d",
      "StageLastUpdatedDateTime": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectoryType>(x),
      "VpcSettings": toDirectoryVpcSettingsDescription,
      "ConnectSettings": toDirectoryConnectSettingsDescription,
      "RadiusSettings": toRadiusSettings,
      "RadiusStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RadiusStatus>(x),
      "StageReason": "s",
      "SsoEnabled": "b",
      "DesiredNumberOfDomainControllers": "n",
      "OwnerDirectoryDescription": toOwnerDirectoryDescription,
      "RegionsInfo": toRegionsInfo,
    },
  }, root);
}

function toDirectoryVpcSettingsDescription(root: jsonP.JSONValue): s.DirectoryVpcSettingsDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcId": "s",
      "SubnetIds": ["s"],
      "SecurityGroupId": "s",
      "AvailabilityZones": ["s"],
    },
  }, root);
}

function toDirectoryConnectSettingsDescription(root: jsonP.JSONValue): s.DirectoryConnectSettingsDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcId": "s",
      "SubnetIds": ["s"],
      "CustomerUserName": "s",
      "SecurityGroupId": "s",
      "AvailabilityZones": ["s"],
      "ConnectIps": ["s"],
    },
  }, root);
}

function toOwnerDirectoryDescription(root: jsonP.JSONValue): s.OwnerDirectoryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "AccountId": "s",
      "DnsIpAddrs": ["s"],
      "VpcSettings": toDirectoryVpcSettingsDescription,
      "RadiusSettings": toRadiusSettings,
      "RadiusStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RadiusStatus>(x),
    },
  }, root);
}

function toRegionsInfo(root: jsonP.JSONValue): s.RegionsInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryRegion": "s",
      "AdditionalRegions": ["s"],
    },
  }, root);
}

function toDomainController(root: jsonP.JSONValue): s.DomainController {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "DomainControllerId": "s",
      "DnsIpAddr": "s",
      "VpcId": "s",
      "SubnetId": "s",
      "AvailabilityZone": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainControllerStatus>(x),
      "StatusReason": "s",
      "LaunchTime": "d",
      "StatusLastUpdatedDateTime": "d",
    },
  }, root);
}

function toEventTopic(root: jsonP.JSONValue): s.EventTopic {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "TopicName": "s",
      "TopicArn": "s",
      "CreatedDateTime": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TopicStatus>(x),
    },
  }, root);
}

function toLDAPSSettingInfo(root: jsonP.JSONValue): s.LDAPSSettingInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "LDAPSStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LDAPSStatus>(x),
      "LDAPSStatusReason": "s",
      "LastUpdatedDateTime": "d",
    },
  }, root);
}

function toRegionDescription(root: jsonP.JSONValue): s.RegionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "RegionName": "s",
      "RegionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegionType>(x),
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectoryStage>(x),
      "VpcSettings": toDirectoryVpcSettings,
      "DesiredNumberOfDomainControllers": "n",
      "LaunchTime": "d",
      "StatusLastUpdatedDateTime": "d",
      "LastUpdatedDateTime": "d",
    },
  }, root);
}

function toSnapshot(root: jsonP.JSONValue): s.Snapshot {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "SnapshotId": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SnapshotType>(x),
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SnapshotStatus>(x),
      "StartTime": "d",
    },
  }, root);
}

function toTrust(root: jsonP.JSONValue): s.Trust {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "TrustId": "s",
      "RemoteDomainName": "s",
      "TrustType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrustType>(x),
      "TrustDirection": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrustDirection>(x),
      "TrustState": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrustState>(x),
      "CreatedDateTime": "d",
      "LastUpdatedDateTime": "d",
      "StateLastUpdatedDateTime": "d",
      "TrustStateReason": "s",
      "SelectiveAuth": (x: jsonP.JSONValue) => cmnP.readEnum<s.SelectiveAuth>(x),
    },
  }, root);
}

function toDirectoryLimits(root: jsonP.JSONValue): s.DirectoryLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudOnlyDirectoriesLimit": "n",
      "CloudOnlyDirectoriesCurrentCount": "n",
      "CloudOnlyDirectoriesLimitReached": "b",
      "CloudOnlyMicrosoftADLimit": "n",
      "CloudOnlyMicrosoftADCurrentCount": "n",
      "CloudOnlyMicrosoftADLimitReached": "b",
      "ConnectedDirectoriesLimit": "n",
      "ConnectedDirectoriesCurrentCount": "n",
      "ConnectedDirectoriesLimitReached": "b",
    },
  }, root);
}

function toSnapshotLimits(root: jsonP.JSONValue): s.SnapshotLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManualSnapshotsLimit": "n",
      "ManualSnapshotsCurrentCount": "n",
      "ManualSnapshotsLimitReached": "b",
    },
  }, root);
}

function toCertificateInfo(root: jsonP.JSONValue): s.CertificateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateId": "s",
      "CommonName": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateState>(x),
      "ExpiryDateTime": "d",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CertificateType>(x),
    },
  }, root);
}

function toIpRouteInfo(root: jsonP.JSONValue): s.IpRouteInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "CidrIp": "s",
      "IpRouteStatusMsg": (x: jsonP.JSONValue) => cmnP.readEnum<s.IpRouteStatusMsg>(x),
      "AddedDateTime": "d",
      "IpRouteStatusReason": "s",
      "Description": "s",
    },
  }, root);
}

function toLogSubscription(root: jsonP.JSONValue): s.LogSubscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "LogGroupName": "s",
      "SubscriptionCreatedDateTime": "d",
    },
  }, root);
}

function toSchemaExtensionInfo(root: jsonP.JSONValue): s.SchemaExtensionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "DirectoryId": "s",
      "SchemaExtensionId": "s",
      "Description": "s",
      "SchemaExtensionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaExtensionStatus>(x),
      "SchemaExtensionStatusReason": "s",
      "StartDateTime": "d",
      "EndDateTime": "d",
    },
  }, root);
}
