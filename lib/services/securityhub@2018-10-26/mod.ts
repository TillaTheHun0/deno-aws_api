// Autogenerated API client for: AWS SecurityHub

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class SecurityHub {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SecurityHub.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-10-26",
    "endpointPrefix": "securityhub",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "AWS SecurityHub",
    "serviceId": "SecurityHub",
    "signatureVersion": "v4",
    "signingName": "securityhub",
    "uid": "securityhub-2018-10-26"
  };

  async acceptInvitation(
    {abortSignal, ...params}: RequestConfig & s.AcceptInvitationRequest,
  ): Promise<s.AcceptInvitationResponse> {
    const body: jsonP.JSONObject = {
      MasterId: params["MasterId"],
      InvitationId: params["InvitationId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcceptInvitation",
      requestUri: "/master",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async batchDisableStandards(
    {abortSignal, ...params}: RequestConfig & s.BatchDisableStandardsRequest,
  ): Promise<s.BatchDisableStandardsResponse> {
    const body: jsonP.JSONObject = {
      StandardsSubscriptionArns: params["StandardsSubscriptionArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDisableStandards",
      requestUri: "/standards/deregister",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StandardsSubscriptions": [toStandardsSubscription],
      },
    }, await resp.json());
  }

  async batchEnableStandards(
    {abortSignal, ...params}: RequestConfig & s.BatchEnableStandardsRequest,
  ): Promise<s.BatchEnableStandardsResponse> {
    const body: jsonP.JSONObject = {
      StandardsSubscriptionRequests: params["StandardsSubscriptionRequests"]?.map(x => fromStandardsSubscriptionRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchEnableStandards",
      requestUri: "/standards/register",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StandardsSubscriptions": [toStandardsSubscription],
      },
    }, await resp.json());
  }

  async batchImportFindings(
    {abortSignal, ...params}: RequestConfig & s.BatchImportFindingsRequest,
  ): Promise<s.BatchImportFindingsResponse> {
    const body: jsonP.JSONObject = {
      Findings: params["Findings"]?.map(x => fromAwsSecurityFinding(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchImportFindings",
      requestUri: "/findings/import",
    });
    return jsonP.readObj({
      required: {
        "FailedCount": "n",
        "SuccessCount": "n",
      },
      optional: {
        "FailedFindings": [toImportFindingsError],
      },
    }, await resp.json());
  }

  async batchUpdateFindings(
    {abortSignal, ...params}: RequestConfig & s.BatchUpdateFindingsRequest,
  ): Promise<s.BatchUpdateFindingsResponse> {
    const body: jsonP.JSONObject = {
      FindingIdentifiers: params["FindingIdentifiers"]?.map(x => fromAwsSecurityFindingIdentifier(x)),
      Note: fromNoteUpdate(params["Note"]),
      Severity: fromSeverityUpdate(params["Severity"]),
      VerificationState: params["VerificationState"],
      Confidence: params["Confidence"],
      Criticality: params["Criticality"],
      Types: params["Types"],
      UserDefinedFields: params["UserDefinedFields"],
      Workflow: fromWorkflowUpdate(params["Workflow"]),
      RelatedFindings: params["RelatedFindings"]?.map(x => fromRelatedFinding(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdateFindings",
      method: "PATCH",
      requestUri: "/findings/batchupdate",
    });
    return jsonP.readObj({
      required: {
        "ProcessedFindings": [toAwsSecurityFindingIdentifier],
        "UnprocessedFindings": [toBatchUpdateFindingsUnprocessedFinding],
      },
      optional: {},
    }, await resp.json());
  }

  async createActionTarget(
    {abortSignal, ...params}: RequestConfig & s.CreateActionTargetRequest,
  ): Promise<s.CreateActionTargetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateActionTarget",
      requestUri: "/actionTargets",
    });
    return jsonP.readObj({
      required: {
        "ActionTargetArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createInsight(
    {abortSignal, ...params}: RequestConfig & s.CreateInsightRequest,
  ): Promise<s.CreateInsightResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Filters: fromAwsSecurityFindingFilters(params["Filters"]),
      GroupByAttribute: params["GroupByAttribute"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInsight",
      requestUri: "/insights",
    });
    return jsonP.readObj({
      required: {
        "InsightArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createMembers(
    {abortSignal, ...params}: RequestConfig & s.CreateMembersRequest,
  ): Promise<s.CreateMembersResponse> {
    const body: jsonP.JSONObject = {
      AccountDetails: params["AccountDetails"]?.map(x => fromAccountDetails(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMembers",
      requestUri: "/members",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async declineInvitations(
    {abortSignal, ...params}: RequestConfig & s.DeclineInvitationsRequest,
  ): Promise<s.DeclineInvitationsResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeclineInvitations",
      requestUri: "/invitations/decline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async deleteActionTarget(
    {abortSignal, ...params}: RequestConfig & s.DeleteActionTargetRequest,
  ): Promise<s.DeleteActionTargetResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteActionTarget",
      method: "DELETE",
      requestUri: cmnP.encodePath`/actionTargets/${params["ActionTargetArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {
        "ActionTargetArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteInsight(
    {abortSignal, ...params}: RequestConfig & s.DeleteInsightRequest,
  ): Promise<s.DeleteInsightResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInsight",
      method: "DELETE",
      requestUri: cmnP.encodePath`/insights/${params["InsightArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {
        "InsightArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deleteInvitations(
    {abortSignal, ...params}: RequestConfig & s.DeleteInvitationsRequest,
  ): Promise<s.DeleteInvitationsResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteInvitations",
      requestUri: "/invitations/delete",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async deleteMembers(
    {abortSignal, ...params}: RequestConfig & s.DeleteMembersRequest,
  ): Promise<s.DeleteMembersResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMembers",
      requestUri: "/members/delete",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async describeActionTargets(
    {abortSignal, ...params}: RequestConfig & s.DescribeActionTargetsRequest = {},
  ): Promise<s.DescribeActionTargetsResponse> {
    const body: jsonP.JSONObject = {
      ActionTargetArns: params["ActionTargetArns"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeActionTargets",
      requestUri: "/actionTargets/get",
    });
    return jsonP.readObj({
      required: {
        "ActionTargets": [toActionTarget],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeHub(
    {abortSignal, ...params}: RequestConfig & s.DescribeHubRequest = {},
  ): Promise<s.DescribeHubResponse> {
    const query = new URLSearchParams;
    if (params["HubArn"] != null) query.set("HubArn", params["HubArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeHub",
      method: "GET",
      requestUri: "/accounts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HubArn": "s",
        "SubscribedAt": "s",
        "AutoEnableControls": "b",
      },
    }, await resp.json());
  }

  async describeOrganizationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DescribeOrganizationConfigurationRequest = {},
  ): Promise<s.DescribeOrganizationConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOrganizationConfiguration",
      method: "GET",
      requestUri: "/organization/configuration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AutoEnable": "b",
        "MemberAccountLimitReached": "b",
      },
    }, await resp.json());
  }

  async describeProducts(
    {abortSignal, ...params}: RequestConfig & s.DescribeProductsRequest = {},
  ): Promise<s.DescribeProductsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["ProductArn"] != null) query.set("ProductArn", params["ProductArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeProducts",
      method: "GET",
      requestUri: "/products",
    });
    return jsonP.readObj({
      required: {
        "Products": [toProduct],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeStandards(
    {abortSignal, ...params}: RequestConfig & s.DescribeStandardsRequest = {},
  ): Promise<s.DescribeStandardsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeStandards",
      method: "GET",
      requestUri: "/standards",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Standards": [toStandard],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeStandardsControls(
    {abortSignal, ...params}: RequestConfig & s.DescribeStandardsControlsRequest,
  ): Promise<s.DescribeStandardsControlsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeStandardsControls",
      method: "GET",
      requestUri: cmnP.encodePath`/standards/controls/${params["StandardsSubscriptionArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Controls": [toStandardsControl],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async disableImportFindingsForProduct(
    {abortSignal, ...params}: RequestConfig & s.DisableImportFindingsForProductRequest,
  ): Promise<s.DisableImportFindingsForProductResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisableImportFindingsForProduct",
      method: "DELETE",
      requestUri: cmnP.encodePath`/productSubscriptions/${params["ProductSubscriptionArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disableOrganizationAdminAccount(
    {abortSignal, ...params}: RequestConfig & s.DisableOrganizationAdminAccountRequest,
  ): Promise<s.DisableOrganizationAdminAccountResponse> {
    const body: jsonP.JSONObject = {
      AdminAccountId: params["AdminAccountId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableOrganizationAdminAccount",
      requestUri: "/organization/admin/disable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disableSecurityHub(
    {abortSignal, ...params}: RequestConfig & s.DisableSecurityHubRequest = {},
  ): Promise<s.DisableSecurityHubResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisableSecurityHub",
      method: "DELETE",
      requestUri: "/accounts",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disassociateFromMasterAccount(
    {abortSignal, ...params}: RequestConfig & s.DisassociateFromMasterAccountRequest = {},
  ): Promise<s.DisassociateFromMasterAccountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisassociateFromMasterAccount",
      requestUri: "/master/disassociate",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disassociateMembers(
    {abortSignal, ...params}: RequestConfig & s.DisassociateMembersRequest,
  ): Promise<s.DisassociateMembersResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateMembers",
      requestUri: "/members/disassociate",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async enableImportFindingsForProduct(
    {abortSignal, ...params}: RequestConfig & s.EnableImportFindingsForProductRequest,
  ): Promise<s.EnableImportFindingsForProductResponse> {
    const body: jsonP.JSONObject = {
      ProductArn: params["ProductArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableImportFindingsForProduct",
      requestUri: "/productSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProductSubscriptionArn": "s",
      },
    }, await resp.json());
  }

  async enableOrganizationAdminAccount(
    {abortSignal, ...params}: RequestConfig & s.EnableOrganizationAdminAccountRequest,
  ): Promise<s.EnableOrganizationAdminAccountResponse> {
    const body: jsonP.JSONObject = {
      AdminAccountId: params["AdminAccountId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableOrganizationAdminAccount",
      requestUri: "/organization/admin/enable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async enableSecurityHub(
    {abortSignal, ...params}: RequestConfig & s.EnableSecurityHubRequest = {},
  ): Promise<s.EnableSecurityHubResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
      EnableDefaultStandards: params["EnableDefaultStandards"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableSecurityHub",
      requestUri: "/accounts",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getEnabledStandards(
    {abortSignal, ...params}: RequestConfig & s.GetEnabledStandardsRequest = {},
  ): Promise<s.GetEnabledStandardsResponse> {
    const body: jsonP.JSONObject = {
      StandardsSubscriptionArns: params["StandardsSubscriptionArns"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEnabledStandards",
      requestUri: "/standards/get",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "StandardsSubscriptions": [toStandardsSubscription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getFindings(
    {abortSignal, ...params}: RequestConfig & s.GetFindingsRequest = {},
  ): Promise<s.GetFindingsResponse> {
    const body: jsonP.JSONObject = {
      Filters: fromAwsSecurityFindingFilters(params["Filters"]),
      SortCriteria: params["SortCriteria"]?.map(x => fromSortCriterion(x)),
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetFindings",
      requestUri: "/findings",
    });
    return jsonP.readObj({
      required: {
        "Findings": [toAwsSecurityFinding],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInsightResults(
    {abortSignal, ...params}: RequestConfig & s.GetInsightResultsRequest,
  ): Promise<s.GetInsightResultsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInsightResults",
      method: "GET",
      requestUri: cmnP.encodePath`/insights/results/${params["InsightArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {
        "InsightResults": toInsightResults,
      },
      optional: {},
    }, await resp.json());
  }

  async getInsights(
    {abortSignal, ...params}: RequestConfig & s.GetInsightsRequest = {},
  ): Promise<s.GetInsightsResponse> {
    const body: jsonP.JSONObject = {
      InsightArns: params["InsightArns"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetInsights",
      requestUri: "/insights/get",
    });
    return jsonP.readObj({
      required: {
        "Insights": [toInsight],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getInvitationsCount(
    {abortSignal, ...params}: RequestConfig & s.GetInvitationsCountRequest = {},
  ): Promise<s.GetInvitationsCountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInvitationsCount",
      method: "GET",
      requestUri: "/invitations/count",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InvitationsCount": "n",
      },
    }, await resp.json());
  }

  async getMasterAccount(
    {abortSignal, ...params}: RequestConfig & s.GetMasterAccountRequest = {},
  ): Promise<s.GetMasterAccountResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMasterAccount",
      method: "GET",
      requestUri: "/master",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Master": toInvitation,
      },
    }, await resp.json());
  }

  async getMembers(
    {abortSignal, ...params}: RequestConfig & s.GetMembersRequest,
  ): Promise<s.GetMembersResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMembers",
      requestUri: "/members/get",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Members": [toMember],
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async inviteMembers(
    {abortSignal, ...params}: RequestConfig & s.InviteMembersRequest,
  ): Promise<s.InviteMembersResponse> {
    const body: jsonP.JSONObject = {
      AccountIds: params["AccountIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InviteMembers",
      requestUri: "/members/invite",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UnprocessedAccounts": [toResult],
      },
    }, await resp.json());
  }

  async listEnabledProductsForImport(
    {abortSignal, ...params}: RequestConfig & s.ListEnabledProductsForImportRequest = {},
  ): Promise<s.ListEnabledProductsForImportResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListEnabledProductsForImport",
      method: "GET",
      requestUri: "/productSubscriptions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProductSubscriptions": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInvitations(
    {abortSignal, ...params}: RequestConfig & s.ListInvitationsRequest = {},
  ): Promise<s.ListInvitationsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvitations",
      method: "GET",
      requestUri: "/invitations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Invitations": [toInvitation],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMembers(
    {abortSignal, ...params}: RequestConfig & s.ListMembersRequest = {},
  ): Promise<s.ListMembersResponse> {
    const query = new URLSearchParams;
    if (params["OnlyAssociated"] != null) query.set("OnlyAssociated", params["OnlyAssociated"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMembers",
      method: "GET",
      requestUri: "/members",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Members": [toMember],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOrganizationAdminAccounts(
    {abortSignal, ...params}: RequestConfig & s.ListOrganizationAdminAccountsRequest = {},
  ): Promise<s.ListOrganizationAdminAccountsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("MaxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("NextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOrganizationAdminAccounts",
      method: "GET",
      requestUri: "/organization/admin",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AdminAccounts": [toAdminAccount],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/tags/${params["ResourceArn"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateActionTarget(
    {abortSignal, ...params}: RequestConfig & s.UpdateActionTargetRequest,
  ): Promise<s.UpdateActionTargetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateActionTarget",
      method: "PATCH",
      requestUri: cmnP.encodePath`/actionTargets/${params["ActionTargetArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateFindings(
    {abortSignal, ...params}: RequestConfig & s.UpdateFindingsRequest,
  ): Promise<s.UpdateFindingsResponse> {
    const body: jsonP.JSONObject = {
      Filters: fromAwsSecurityFindingFilters(params["Filters"]),
      Note: fromNoteUpdate(params["Note"]),
      RecordState: params["RecordState"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFindings",
      method: "PATCH",
      requestUri: "/findings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateInsight(
    {abortSignal, ...params}: RequestConfig & s.UpdateInsightRequest,
  ): Promise<s.UpdateInsightResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Filters: fromAwsSecurityFindingFilters(params["Filters"]),
      GroupByAttribute: params["GroupByAttribute"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInsight",
      method: "PATCH",
      requestUri: cmnP.encodePath`/insights/${params["InsightArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateOrganizationConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateOrganizationConfigurationRequest,
  ): Promise<s.UpdateOrganizationConfigurationResponse> {
    const body: jsonP.JSONObject = {
      AutoEnable: params["AutoEnable"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateOrganizationConfiguration",
      requestUri: "/organization/configuration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateSecurityHubConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateSecurityHubConfigurationRequest = {},
  ): Promise<s.UpdateSecurityHubConfigurationResponse> {
    const body: jsonP.JSONObject = {
      AutoEnableControls: params["AutoEnableControls"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSecurityHubConfiguration",
      method: "PATCH",
      requestUri: "/accounts",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateStandardsControl(
    {abortSignal, ...params}: RequestConfig & s.UpdateStandardsControlRequest,
  ): Promise<s.UpdateStandardsControlResponse> {
    const body: jsonP.JSONObject = {
      ControlStatus: params["ControlStatus"],
      DisabledReason: params["DisabledReason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateStandardsControl",
      method: "PATCH",
      requestUri: cmnP.encodePath`/standards/control/${params["StandardsControlArn"].split("/")}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromStandardsSubscriptionRequest(input?: s.StandardsSubscriptionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StandardsArn: input["StandardsArn"],
    StandardsInput: input["StandardsInput"],
  }
}

function fromAwsSecurityFinding(input?: s.AwsSecurityFinding | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaVersion: input["SchemaVersion"],
    Id: input["Id"],
    ProductArn: input["ProductArn"],
    GeneratorId: input["GeneratorId"],
    AwsAccountId: input["AwsAccountId"],
    Types: input["Types"],
    FirstObservedAt: input["FirstObservedAt"],
    LastObservedAt: input["LastObservedAt"],
    CreatedAt: input["CreatedAt"],
    UpdatedAt: input["UpdatedAt"],
    Severity: fromSeverity(input["Severity"]),
    Confidence: input["Confidence"],
    Criticality: input["Criticality"],
    Title: input["Title"],
    Description: input["Description"],
    Remediation: fromRemediation(input["Remediation"]),
    SourceUrl: input["SourceUrl"],
    ProductFields: input["ProductFields"],
    UserDefinedFields: input["UserDefinedFields"],
    Malware: input["Malware"]?.map(x => fromMalware(x)),
    Network: fromNetwork(input["Network"]),
    NetworkPath: input["NetworkPath"]?.map(x => fromNetworkPathComponent(x)),
    Process: fromProcessDetails(input["Process"]),
    ThreatIntelIndicators: input["ThreatIntelIndicators"]?.map(x => fromThreatIntelIndicator(x)),
    Resources: input["Resources"]?.map(x => fromResource(x)),
    Compliance: fromCompliance(input["Compliance"]),
    VerificationState: input["VerificationState"],
    WorkflowState: input["WorkflowState"],
    Workflow: fromWorkflow(input["Workflow"]),
    RecordState: input["RecordState"],
    RelatedFindings: input["RelatedFindings"]?.map(x => fromRelatedFinding(x)),
    Note: fromNote(input["Note"]),
    Vulnerabilities: input["Vulnerabilities"]?.map(x => fromVulnerability(x)),
    PatchSummary: fromPatchSummary(input["PatchSummary"]),
    Action: fromAction(input["Action"]),
  }
}
function toAwsSecurityFinding(root: jsonP.JSONValue): s.AwsSecurityFinding {
  return jsonP.readObj({
    required: {
      "SchemaVersion": "s",
      "Id": "s",
      "ProductArn": "s",
      "GeneratorId": "s",
      "AwsAccountId": "s",
      "Types": ["s"],
      "CreatedAt": "s",
      "UpdatedAt": "s",
      "Severity": toSeverity,
      "Title": "s",
      "Description": "s",
      "Resources": [toResource],
    },
    optional: {
      "FirstObservedAt": "s",
      "LastObservedAt": "s",
      "Confidence": "n",
      "Criticality": "n",
      "Remediation": toRemediation,
      "SourceUrl": "s",
      "ProductFields": x => jsonP.readMap(String, String, x),
      "UserDefinedFields": x => jsonP.readMap(String, String, x),
      "Malware": [toMalware],
      "Network": toNetwork,
      "NetworkPath": [toNetworkPathComponent],
      "Process": toProcessDetails,
      "ThreatIntelIndicators": [toThreatIntelIndicator],
      "Compliance": toCompliance,
      "VerificationState": (x: jsonP.JSONValue) => cmnP.readEnum<s.VerificationState>(x),
      "WorkflowState": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowState>(x),
      "Workflow": toWorkflow,
      "RecordState": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordState>(x),
      "RelatedFindings": [toRelatedFinding],
      "Note": toNote,
      "Vulnerabilities": [toVulnerability],
      "PatchSummary": toPatchSummary,
      "Action": toAction,
    },
  }, root);
}

function fromSeverity(input?: s.Severity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Product: input["Product"],
    Label: input["Label"],
    Normalized: input["Normalized"],
    Original: input["Original"],
  }
}
function toSeverity(root: jsonP.JSONValue): s.Severity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Product": "n",
      "Label": (x: jsonP.JSONValue) => cmnP.readEnum<s.SeverityLabel>(x),
      "Normalized": "n",
      "Original": "s",
    },
  }, root);
}

function fromRemediation(input?: s.Remediation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Recommendation: fromRecommendation(input["Recommendation"]),
  }
}
function toRemediation(root: jsonP.JSONValue): s.Remediation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Recommendation": toRecommendation,
    },
  }, root);
}

function fromRecommendation(input?: s.Recommendation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Text: input["Text"],
    Url: input["Url"],
  }
}
function toRecommendation(root: jsonP.JSONValue): s.Recommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Text": "s",
      "Url": "s",
    },
  }, root);
}

function fromMalware(input?: s.Malware | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    Path: input["Path"],
    State: input["State"],
  }
}
function toMalware(root: jsonP.JSONValue): s.Malware {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.MalwareType>(x),
      "Path": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MalwareState>(x),
    },
  }, root);
}

function fromNetwork(input?: s.Network | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Direction: input["Direction"],
    Protocol: input["Protocol"],
    OpenPortRange: fromPortRange(input["OpenPortRange"]),
    SourceIpV4: input["SourceIpV4"],
    SourceIpV6: input["SourceIpV6"],
    SourcePort: input["SourcePort"],
    SourceDomain: input["SourceDomain"],
    SourceMac: input["SourceMac"],
    DestinationIpV4: input["DestinationIpV4"],
    DestinationIpV6: input["DestinationIpV6"],
    DestinationPort: input["DestinationPort"],
    DestinationDomain: input["DestinationDomain"],
  }
}
function toNetwork(root: jsonP.JSONValue): s.Network {
  return jsonP.readObj({
    required: {},
    optional: {
      "Direction": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkDirection>(x),
      "Protocol": "s",
      "OpenPortRange": toPortRange,
      "SourceIpV4": "s",
      "SourceIpV6": "s",
      "SourcePort": "n",
      "SourceDomain": "s",
      "SourceMac": "s",
      "DestinationIpV4": "s",
      "DestinationIpV6": "s",
      "DestinationPort": "n",
      "DestinationDomain": "s",
    },
  }, root);
}

function fromPortRange(input?: s.PortRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Begin: input["Begin"],
    End: input["End"],
  }
}
function toPortRange(root: jsonP.JSONValue): s.PortRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "Begin": "n",
      "End": "n",
    },
  }, root);
}

function fromNetworkPathComponent(input?: s.NetworkPathComponent | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComponentId: input["ComponentId"],
    ComponentType: input["ComponentType"],
    Egress: fromNetworkHeader(input["Egress"]),
    Ingress: fromNetworkHeader(input["Ingress"]),
  }
}
function toNetworkPathComponent(root: jsonP.JSONValue): s.NetworkPathComponent {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComponentId": "s",
      "ComponentType": "s",
      "Egress": toNetworkHeader,
      "Ingress": toNetworkHeader,
    },
  }, root);
}

function fromNetworkHeader(input?: s.NetworkHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Protocol: input["Protocol"],
    Destination: fromNetworkPathComponentDetails(input["Destination"]),
    Source: fromNetworkPathComponentDetails(input["Source"]),
  }
}
function toNetworkHeader(root: jsonP.JSONValue): s.NetworkHeader {
  return jsonP.readObj({
    required: {},
    optional: {
      "Protocol": "s",
      "Destination": toNetworkPathComponentDetails,
      "Source": toNetworkPathComponentDetails,
    },
  }, root);
}

function fromNetworkPathComponentDetails(input?: s.NetworkPathComponentDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    PortRanges: input["PortRanges"]?.map(x => fromPortRange(x)),
  }
}
function toNetworkPathComponentDetails(root: jsonP.JSONValue): s.NetworkPathComponentDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": ["s"],
      "PortRanges": [toPortRange],
    },
  }, root);
}

function fromProcessDetails(input?: s.ProcessDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Path: input["Path"],
    Pid: input["Pid"],
    ParentPid: input["ParentPid"],
    LaunchedAt: input["LaunchedAt"],
    TerminatedAt: input["TerminatedAt"],
  }
}
function toProcessDetails(root: jsonP.JSONValue): s.ProcessDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Path": "s",
      "Pid": "n",
      "ParentPid": "n",
      "LaunchedAt": "s",
      "TerminatedAt": "s",
    },
  }, root);
}

function fromThreatIntelIndicator(input?: s.ThreatIntelIndicator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Value: input["Value"],
    Category: input["Category"],
    LastObservedAt: input["LastObservedAt"],
    Source: input["Source"],
    SourceUrl: input["SourceUrl"],
  }
}
function toThreatIntelIndicator(root: jsonP.JSONValue): s.ThreatIntelIndicator {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThreatIntelIndicatorType>(x),
      "Value": "s",
      "Category": (x: jsonP.JSONValue) => cmnP.readEnum<s.ThreatIntelIndicatorCategory>(x),
      "LastObservedAt": "s",
      "Source": "s",
      "SourceUrl": "s",
    },
  }, root);
}

function fromResource(input?: s.Resource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Id: input["Id"],
    Partition: input["Partition"],
    Region: input["Region"],
    ResourceRole: input["ResourceRole"],
    Tags: input["Tags"],
    Details: fromResourceDetails(input["Details"]),
  }
}
function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {
      "Type": "s",
      "Id": "s",
    },
    optional: {
      "Partition": (x: jsonP.JSONValue) => cmnP.readEnum<s.Partition>(x),
      "Region": "s",
      "ResourceRole": "s",
      "Tags": x => jsonP.readMap(String, String, x),
      "Details": toResourceDetails,
    },
  }, root);
}

function fromResourceDetails(input?: s.ResourceDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AwsAutoScalingAutoScalingGroup: fromAwsAutoScalingAutoScalingGroupDetails(input["AwsAutoScalingAutoScalingGroup"]),
    AwsCodeBuildProject: fromAwsCodeBuildProjectDetails(input["AwsCodeBuildProject"]),
    AwsCloudFrontDistribution: fromAwsCloudFrontDistributionDetails(input["AwsCloudFrontDistribution"]),
    AwsEc2Instance: fromAwsEc2InstanceDetails(input["AwsEc2Instance"]),
    AwsEc2NetworkInterface: fromAwsEc2NetworkInterfaceDetails(input["AwsEc2NetworkInterface"]),
    AwsEc2SecurityGroup: fromAwsEc2SecurityGroupDetails(input["AwsEc2SecurityGroup"]),
    AwsEc2Volume: fromAwsEc2VolumeDetails(input["AwsEc2Volume"]),
    AwsEc2Vpc: fromAwsEc2VpcDetails(input["AwsEc2Vpc"]),
    AwsEc2Eip: fromAwsEc2EipDetails(input["AwsEc2Eip"]),
    AwsElbv2LoadBalancer: fromAwsElbv2LoadBalancerDetails(input["AwsElbv2LoadBalancer"]),
    AwsElasticsearchDomain: fromAwsElasticsearchDomainDetails(input["AwsElasticsearchDomain"]),
    AwsS3Bucket: fromAwsS3BucketDetails(input["AwsS3Bucket"]),
    AwsS3Object: fromAwsS3ObjectDetails(input["AwsS3Object"]),
    AwsSecretsManagerSecret: fromAwsSecretsManagerSecretDetails(input["AwsSecretsManagerSecret"]),
    AwsIamAccessKey: fromAwsIamAccessKeyDetails(input["AwsIamAccessKey"]),
    AwsIamUser: fromAwsIamUserDetails(input["AwsIamUser"]),
    AwsIamPolicy: fromAwsIamPolicyDetails(input["AwsIamPolicy"]),
    AwsApiGatewayV2Stage: fromAwsApiGatewayV2StageDetails(input["AwsApiGatewayV2Stage"]),
    AwsApiGatewayV2Api: fromAwsApiGatewayV2ApiDetails(input["AwsApiGatewayV2Api"]),
    AwsDynamoDbTable: fromAwsDynamoDbTableDetails(input["AwsDynamoDbTable"]),
    AwsApiGatewayStage: fromAwsApiGatewayStageDetails(input["AwsApiGatewayStage"]),
    AwsApiGatewayRestApi: fromAwsApiGatewayRestApiDetails(input["AwsApiGatewayRestApi"]),
    AwsCloudTrailTrail: fromAwsCloudTrailTrailDetails(input["AwsCloudTrailTrail"]),
    AwsSsmPatchCompliance: fromAwsSsmPatchComplianceDetails(input["AwsSsmPatchCompliance"]),
    AwsCertificateManagerCertificate: fromAwsCertificateManagerCertificateDetails(input["AwsCertificateManagerCertificate"]),
    AwsRedshiftCluster: fromAwsRedshiftClusterDetails(input["AwsRedshiftCluster"]),
    AwsElbLoadBalancer: fromAwsElbLoadBalancerDetails(input["AwsElbLoadBalancer"]),
    AwsIamGroup: fromAwsIamGroupDetails(input["AwsIamGroup"]),
    AwsIamRole: fromAwsIamRoleDetails(input["AwsIamRole"]),
    AwsKmsKey: fromAwsKmsKeyDetails(input["AwsKmsKey"]),
    AwsLambdaFunction: fromAwsLambdaFunctionDetails(input["AwsLambdaFunction"]),
    AwsLambdaLayerVersion: fromAwsLambdaLayerVersionDetails(input["AwsLambdaLayerVersion"]),
    AwsRdsDbInstance: fromAwsRdsDbInstanceDetails(input["AwsRdsDbInstance"]),
    AwsSnsTopic: fromAwsSnsTopicDetails(input["AwsSnsTopic"]),
    AwsSqsQueue: fromAwsSqsQueueDetails(input["AwsSqsQueue"]),
    AwsWafWebAcl: fromAwsWafWebAclDetails(input["AwsWafWebAcl"]),
    AwsRdsDbSnapshot: fromAwsRdsDbSnapshotDetails(input["AwsRdsDbSnapshot"]),
    AwsRdsDbClusterSnapshot: fromAwsRdsDbClusterSnapshotDetails(input["AwsRdsDbClusterSnapshot"]),
    AwsRdsDbCluster: fromAwsRdsDbClusterDetails(input["AwsRdsDbCluster"]),
    Container: fromContainerDetails(input["Container"]),
    Other: input["Other"],
  }
}
function toResourceDetails(root: jsonP.JSONValue): s.ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AwsAutoScalingAutoScalingGroup": toAwsAutoScalingAutoScalingGroupDetails,
      "AwsCodeBuildProject": toAwsCodeBuildProjectDetails,
      "AwsCloudFrontDistribution": toAwsCloudFrontDistributionDetails,
      "AwsEc2Instance": toAwsEc2InstanceDetails,
      "AwsEc2NetworkInterface": toAwsEc2NetworkInterfaceDetails,
      "AwsEc2SecurityGroup": toAwsEc2SecurityGroupDetails,
      "AwsEc2Volume": toAwsEc2VolumeDetails,
      "AwsEc2Vpc": toAwsEc2VpcDetails,
      "AwsEc2Eip": toAwsEc2EipDetails,
      "AwsElbv2LoadBalancer": toAwsElbv2LoadBalancerDetails,
      "AwsElasticsearchDomain": toAwsElasticsearchDomainDetails,
      "AwsS3Bucket": toAwsS3BucketDetails,
      "AwsS3Object": toAwsS3ObjectDetails,
      "AwsSecretsManagerSecret": toAwsSecretsManagerSecretDetails,
      "AwsIamAccessKey": toAwsIamAccessKeyDetails,
      "AwsIamUser": toAwsIamUserDetails,
      "AwsIamPolicy": toAwsIamPolicyDetails,
      "AwsApiGatewayV2Stage": toAwsApiGatewayV2StageDetails,
      "AwsApiGatewayV2Api": toAwsApiGatewayV2ApiDetails,
      "AwsDynamoDbTable": toAwsDynamoDbTableDetails,
      "AwsApiGatewayStage": toAwsApiGatewayStageDetails,
      "AwsApiGatewayRestApi": toAwsApiGatewayRestApiDetails,
      "AwsCloudTrailTrail": toAwsCloudTrailTrailDetails,
      "AwsSsmPatchCompliance": toAwsSsmPatchComplianceDetails,
      "AwsCertificateManagerCertificate": toAwsCertificateManagerCertificateDetails,
      "AwsRedshiftCluster": toAwsRedshiftClusterDetails,
      "AwsElbLoadBalancer": toAwsElbLoadBalancerDetails,
      "AwsIamGroup": toAwsIamGroupDetails,
      "AwsIamRole": toAwsIamRoleDetails,
      "AwsKmsKey": toAwsKmsKeyDetails,
      "AwsLambdaFunction": toAwsLambdaFunctionDetails,
      "AwsLambdaLayerVersion": toAwsLambdaLayerVersionDetails,
      "AwsRdsDbInstance": toAwsRdsDbInstanceDetails,
      "AwsSnsTopic": toAwsSnsTopicDetails,
      "AwsSqsQueue": toAwsSqsQueueDetails,
      "AwsWafWebAcl": toAwsWafWebAclDetails,
      "AwsRdsDbSnapshot": toAwsRdsDbSnapshotDetails,
      "AwsRdsDbClusterSnapshot": toAwsRdsDbClusterSnapshotDetails,
      "AwsRdsDbCluster": toAwsRdsDbClusterDetails,
      "Container": toContainerDetails,
      "Other": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromAwsAutoScalingAutoScalingGroupDetails(input?: s.AwsAutoScalingAutoScalingGroupDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LaunchConfigurationName: input["LaunchConfigurationName"],
    LoadBalancerNames: input["LoadBalancerNames"],
    HealthCheckType: input["HealthCheckType"],
    HealthCheckGracePeriod: input["HealthCheckGracePeriod"],
    CreatedTime: input["CreatedTime"],
  }
}
function toAwsAutoScalingAutoScalingGroupDetails(root: jsonP.JSONValue): s.AwsAutoScalingAutoScalingGroupDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "LaunchConfigurationName": "s",
      "LoadBalancerNames": ["s"],
      "HealthCheckType": "s",
      "HealthCheckGracePeriod": "n",
      "CreatedTime": "s",
    },
  }, root);
}

function fromAwsCodeBuildProjectDetails(input?: s.AwsCodeBuildProjectDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionKey: input["EncryptionKey"],
    Environment: fromAwsCodeBuildProjectEnvironment(input["Environment"]),
    Name: input["Name"],
    Source: fromAwsCodeBuildProjectSource(input["Source"]),
    ServiceRole: input["ServiceRole"],
    VpcConfig: fromAwsCodeBuildProjectVpcConfig(input["VpcConfig"]),
  }
}
function toAwsCodeBuildProjectDetails(root: jsonP.JSONValue): s.AwsCodeBuildProjectDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionKey": "s",
      "Environment": toAwsCodeBuildProjectEnvironment,
      "Name": "s",
      "Source": toAwsCodeBuildProjectSource,
      "ServiceRole": "s",
      "VpcConfig": toAwsCodeBuildProjectVpcConfig,
    },
  }, root);
}

function fromAwsCodeBuildProjectEnvironment(input?: s.AwsCodeBuildProjectEnvironment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Certificate: input["Certificate"],
    ImagePullCredentialsType: input["ImagePullCredentialsType"],
    RegistryCredential: fromAwsCodeBuildProjectEnvironmentRegistryCredential(input["RegistryCredential"]),
    Type: input["Type"],
  }
}
function toAwsCodeBuildProjectEnvironment(root: jsonP.JSONValue): s.AwsCodeBuildProjectEnvironment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Certificate": "s",
      "ImagePullCredentialsType": "s",
      "RegistryCredential": toAwsCodeBuildProjectEnvironmentRegistryCredential,
      "Type": "s",
    },
  }, root);
}

function fromAwsCodeBuildProjectEnvironmentRegistryCredential(input?: s.AwsCodeBuildProjectEnvironmentRegistryCredential | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Credential: input["Credential"],
    CredentialProvider: input["CredentialProvider"],
  }
}
function toAwsCodeBuildProjectEnvironmentRegistryCredential(root: jsonP.JSONValue): s.AwsCodeBuildProjectEnvironmentRegistryCredential {
  return jsonP.readObj({
    required: {},
    optional: {
      "Credential": "s",
      "CredentialProvider": "s",
    },
  }, root);
}

function fromAwsCodeBuildProjectSource(input?: s.AwsCodeBuildProjectSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Location: input["Location"],
    GitCloneDepth: input["GitCloneDepth"],
    InsecureSsl: input["InsecureSsl"],
  }
}
function toAwsCodeBuildProjectSource(root: jsonP.JSONValue): s.AwsCodeBuildProjectSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "Location": "s",
      "GitCloneDepth": "n",
      "InsecureSsl": "b",
    },
  }, root);
}

function fromAwsCodeBuildProjectVpcConfig(input?: s.AwsCodeBuildProjectVpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VpcId: input["VpcId"],
    Subnets: input["Subnets"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}
function toAwsCodeBuildProjectVpcConfig(root: jsonP.JSONValue): s.AwsCodeBuildProjectVpcConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcId": "s",
      "Subnets": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

function fromAwsCloudFrontDistributionDetails(input?: s.AwsCloudFrontDistributionDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CacheBehaviors: fromAwsCloudFrontDistributionCacheBehaviors(input["CacheBehaviors"]),
    DefaultCacheBehavior: fromAwsCloudFrontDistributionDefaultCacheBehavior(input["DefaultCacheBehavior"]),
    DefaultRootObject: input["DefaultRootObject"],
    DomainName: input["DomainName"],
    ETag: input["ETag"],
    LastModifiedTime: input["LastModifiedTime"],
    Logging: fromAwsCloudFrontDistributionLogging(input["Logging"]),
    Origins: fromAwsCloudFrontDistributionOrigins(input["Origins"]),
    OriginGroups: fromAwsCloudFrontDistributionOriginGroups(input["OriginGroups"]),
    Status: input["Status"],
    WebAclId: input["WebAclId"],
  }
}
function toAwsCloudFrontDistributionDetails(root: jsonP.JSONValue): s.AwsCloudFrontDistributionDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CacheBehaviors": toAwsCloudFrontDistributionCacheBehaviors,
      "DefaultCacheBehavior": toAwsCloudFrontDistributionDefaultCacheBehavior,
      "DefaultRootObject": "s",
      "DomainName": "s",
      "ETag": "s",
      "LastModifiedTime": "s",
      "Logging": toAwsCloudFrontDistributionLogging,
      "Origins": toAwsCloudFrontDistributionOrigins,
      "OriginGroups": toAwsCloudFrontDistributionOriginGroups,
      "Status": "s",
      "WebAclId": "s",
    },
  }, root);
}

function fromAwsCloudFrontDistributionCacheBehaviors(input?: s.AwsCloudFrontDistributionCacheBehaviors | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Items: input["Items"]?.map(x => fromAwsCloudFrontDistributionCacheBehavior(x)),
  }
}
function toAwsCloudFrontDistributionCacheBehaviors(root: jsonP.JSONValue): s.AwsCloudFrontDistributionCacheBehaviors {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": [toAwsCloudFrontDistributionCacheBehavior],
    },
  }, root);
}

function fromAwsCloudFrontDistributionCacheBehavior(input?: s.AwsCloudFrontDistributionCacheBehavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ViewerProtocolPolicy: input["ViewerProtocolPolicy"],
  }
}
function toAwsCloudFrontDistributionCacheBehavior(root: jsonP.JSONValue): s.AwsCloudFrontDistributionCacheBehavior {
  return jsonP.readObj({
    required: {},
    optional: {
      "ViewerProtocolPolicy": "s",
    },
  }, root);
}

function fromAwsCloudFrontDistributionDefaultCacheBehavior(input?: s.AwsCloudFrontDistributionDefaultCacheBehavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ViewerProtocolPolicy: input["ViewerProtocolPolicy"],
  }
}
function toAwsCloudFrontDistributionDefaultCacheBehavior(root: jsonP.JSONValue): s.AwsCloudFrontDistributionDefaultCacheBehavior {
  return jsonP.readObj({
    required: {},
    optional: {
      "ViewerProtocolPolicy": "s",
    },
  }, root);
}

function fromAwsCloudFrontDistributionLogging(input?: s.AwsCloudFrontDistributionLogging | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Enabled: input["Enabled"],
    IncludeCookies: input["IncludeCookies"],
    Prefix: input["Prefix"],
  }
}
function toAwsCloudFrontDistributionLogging(root: jsonP.JSONValue): s.AwsCloudFrontDistributionLogging {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bucket": "s",
      "Enabled": "b",
      "IncludeCookies": "b",
      "Prefix": "s",
    },
  }, root);
}

function fromAwsCloudFrontDistributionOrigins(input?: s.AwsCloudFrontDistributionOrigins | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Items: input["Items"]?.map(x => fromAwsCloudFrontDistributionOriginItem(x)),
  }
}
function toAwsCloudFrontDistributionOrigins(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOrigins {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": [toAwsCloudFrontDistributionOriginItem],
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginItem(input?: s.AwsCloudFrontDistributionOriginItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DomainName: input["DomainName"],
    Id: input["Id"],
    OriginPath: input["OriginPath"],
    S3OriginConfig: fromAwsCloudFrontDistributionOriginS3OriginConfig(input["S3OriginConfig"]),
  }
}
function toAwsCloudFrontDistributionOriginItem(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainName": "s",
      "Id": "s",
      "OriginPath": "s",
      "S3OriginConfig": toAwsCloudFrontDistributionOriginS3OriginConfig,
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginS3OriginConfig(input?: s.AwsCloudFrontDistributionOriginS3OriginConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OriginAccessIdentity: input["OriginAccessIdentity"],
  }
}
function toAwsCloudFrontDistributionOriginS3OriginConfig(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginS3OriginConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "OriginAccessIdentity": "s",
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginGroups(input?: s.AwsCloudFrontDistributionOriginGroups | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Items: input["Items"]?.map(x => fromAwsCloudFrontDistributionOriginGroup(x)),
  }
}
function toAwsCloudFrontDistributionOriginGroups(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginGroups {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": [toAwsCloudFrontDistributionOriginGroup],
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginGroup(input?: s.AwsCloudFrontDistributionOriginGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FailoverCriteria: fromAwsCloudFrontDistributionOriginGroupFailover(input["FailoverCriteria"]),
  }
}
function toAwsCloudFrontDistributionOriginGroup(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "FailoverCriteria": toAwsCloudFrontDistributionOriginGroupFailover,
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginGroupFailover(input?: s.AwsCloudFrontDistributionOriginGroupFailover | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StatusCodes: fromAwsCloudFrontDistributionOriginGroupFailoverStatusCodes(input["StatusCodes"]),
  }
}
function toAwsCloudFrontDistributionOriginGroupFailover(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginGroupFailover {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusCodes": toAwsCloudFrontDistributionOriginGroupFailoverStatusCodes,
    },
  }, root);
}

function fromAwsCloudFrontDistributionOriginGroupFailoverStatusCodes(input?: s.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Items: input["Items"],
    Quantity: input["Quantity"],
  }
}
function toAwsCloudFrontDistributionOriginGroupFailoverStatusCodes(root: jsonP.JSONValue): s.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
  return jsonP.readObj({
    required: {},
    optional: {
      "Items": ["n"],
      "Quantity": "n",
    },
  }, root);
}

function fromAwsEc2InstanceDetails(input?: s.AwsEc2InstanceDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    ImageId: input["ImageId"],
    IpV4Addresses: input["IpV4Addresses"],
    IpV6Addresses: input["IpV6Addresses"],
    KeyName: input["KeyName"],
    IamInstanceProfileArn: input["IamInstanceProfileArn"],
    VpcId: input["VpcId"],
    SubnetId: input["SubnetId"],
    LaunchedAt: input["LaunchedAt"],
  }
}
function toAwsEc2InstanceDetails(root: jsonP.JSONValue): s.AwsEc2InstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "ImageId": "s",
      "IpV4Addresses": ["s"],
      "IpV6Addresses": ["s"],
      "KeyName": "s",
      "IamInstanceProfileArn": "s",
      "VpcId": "s",
      "SubnetId": "s",
      "LaunchedAt": "s",
    },
  }, root);
}

function fromAwsEc2NetworkInterfaceDetails(input?: s.AwsEc2NetworkInterfaceDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attachment: fromAwsEc2NetworkInterfaceAttachment(input["Attachment"]),
    NetworkInterfaceId: input["NetworkInterfaceId"],
    SecurityGroups: input["SecurityGroups"]?.map(x => fromAwsEc2NetworkInterfaceSecurityGroup(x)),
    SourceDestCheck: input["SourceDestCheck"],
    IpV6Addresses: input["IpV6Addresses"]?.map(x => fromAwsEc2NetworkInterfaceIpV6AddressDetail(x)),
    PrivateIpAddresses: input["PrivateIpAddresses"]?.map(x => fromAwsEc2NetworkInterfacePrivateIpAddressDetail(x)),
    PublicDnsName: input["PublicDnsName"],
    PublicIp: input["PublicIp"],
  }
}
function toAwsEc2NetworkInterfaceDetails(root: jsonP.JSONValue): s.AwsEc2NetworkInterfaceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attachment": toAwsEc2NetworkInterfaceAttachment,
      "NetworkInterfaceId": "s",
      "SecurityGroups": [toAwsEc2NetworkInterfaceSecurityGroup],
      "SourceDestCheck": "b",
      "IpV6Addresses": [toAwsEc2NetworkInterfaceIpV6AddressDetail],
      "PrivateIpAddresses": [toAwsEc2NetworkInterfacePrivateIpAddressDetail],
      "PublicDnsName": "s",
      "PublicIp": "s",
    },
  }, root);
}

function fromAwsEc2NetworkInterfaceAttachment(input?: s.AwsEc2NetworkInterfaceAttachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttachTime: input["AttachTime"],
    AttachmentId: input["AttachmentId"],
    DeleteOnTermination: input["DeleteOnTermination"],
    DeviceIndex: input["DeviceIndex"],
    InstanceId: input["InstanceId"],
    InstanceOwnerId: input["InstanceOwnerId"],
    Status: input["Status"],
  }
}
function toAwsEc2NetworkInterfaceAttachment(root: jsonP.JSONValue): s.AwsEc2NetworkInterfaceAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachTime": "s",
      "AttachmentId": "s",
      "DeleteOnTermination": "b",
      "DeviceIndex": "n",
      "InstanceId": "s",
      "InstanceOwnerId": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsEc2NetworkInterfaceSecurityGroup(input?: s.AwsEc2NetworkInterfaceSecurityGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroupName: input["GroupName"],
    GroupId: input["GroupId"],
  }
}
function toAwsEc2NetworkInterfaceSecurityGroup(root: jsonP.JSONValue): s.AwsEc2NetworkInterfaceSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupId": "s",
    },
  }, root);
}

function fromAwsEc2NetworkInterfaceIpV6AddressDetail(input?: s.AwsEc2NetworkInterfaceIpV6AddressDetail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IpV6Address: input["IpV6Address"],
  }
}
function toAwsEc2NetworkInterfaceIpV6AddressDetail(root: jsonP.JSONValue): s.AwsEc2NetworkInterfaceIpV6AddressDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "IpV6Address": "s",
    },
  }, root);
}

function fromAwsEc2NetworkInterfacePrivateIpAddressDetail(input?: s.AwsEc2NetworkInterfacePrivateIpAddressDetail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrivateIpAddress: input["PrivateIpAddress"],
    PrivateDnsName: input["PrivateDnsName"],
  }
}
function toAwsEc2NetworkInterfacePrivateIpAddressDetail(root: jsonP.JSONValue): s.AwsEc2NetworkInterfacePrivateIpAddressDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrivateIpAddress": "s",
      "PrivateDnsName": "s",
    },
  }, root);
}

function fromAwsEc2SecurityGroupDetails(input?: s.AwsEc2SecurityGroupDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroupName: input["GroupName"],
    GroupId: input["GroupId"],
    OwnerId: input["OwnerId"],
    VpcId: input["VpcId"],
    IpPermissions: input["IpPermissions"]?.map(x => fromAwsEc2SecurityGroupIpPermission(x)),
    IpPermissionsEgress: input["IpPermissionsEgress"]?.map(x => fromAwsEc2SecurityGroupIpPermission(x)),
  }
}
function toAwsEc2SecurityGroupDetails(root: jsonP.JSONValue): s.AwsEc2SecurityGroupDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "GroupId": "s",
      "OwnerId": "s",
      "VpcId": "s",
      "IpPermissions": [toAwsEc2SecurityGroupIpPermission],
      "IpPermissionsEgress": [toAwsEc2SecurityGroupIpPermission],
    },
  }, root);
}

function fromAwsEc2SecurityGroupIpPermission(input?: s.AwsEc2SecurityGroupIpPermission | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IpProtocol: input["IpProtocol"],
    FromPort: input["FromPort"],
    ToPort: input["ToPort"],
    UserIdGroupPairs: input["UserIdGroupPairs"]?.map(x => fromAwsEc2SecurityGroupUserIdGroupPair(x)),
    IpRanges: input["IpRanges"]?.map(x => fromAwsEc2SecurityGroupIpRange(x)),
    Ipv6Ranges: input["Ipv6Ranges"]?.map(x => fromAwsEc2SecurityGroupIpv6Range(x)),
    PrefixListIds: input["PrefixListIds"]?.map(x => fromAwsEc2SecurityGroupPrefixListId(x)),
  }
}
function toAwsEc2SecurityGroupIpPermission(root: jsonP.JSONValue): s.AwsEc2SecurityGroupIpPermission {
  return jsonP.readObj({
    required: {},
    optional: {
      "IpProtocol": "s",
      "FromPort": "n",
      "ToPort": "n",
      "UserIdGroupPairs": [toAwsEc2SecurityGroupUserIdGroupPair],
      "IpRanges": [toAwsEc2SecurityGroupIpRange],
      "Ipv6Ranges": [toAwsEc2SecurityGroupIpv6Range],
      "PrefixListIds": [toAwsEc2SecurityGroupPrefixListId],
    },
  }, root);
}

function fromAwsEc2SecurityGroupUserIdGroupPair(input?: s.AwsEc2SecurityGroupUserIdGroupPair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroupId: input["GroupId"],
    GroupName: input["GroupName"],
    PeeringStatus: input["PeeringStatus"],
    UserId: input["UserId"],
    VpcId: input["VpcId"],
    VpcPeeringConnectionId: input["VpcPeeringConnectionId"],
  }
}
function toAwsEc2SecurityGroupUserIdGroupPair(root: jsonP.JSONValue): s.AwsEc2SecurityGroupUserIdGroupPair {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupId": "s",
      "GroupName": "s",
      "PeeringStatus": "s",
      "UserId": "s",
      "VpcId": "s",
      "VpcPeeringConnectionId": "s",
    },
  }, root);
}

function fromAwsEc2SecurityGroupIpRange(input?: s.AwsEc2SecurityGroupIpRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CidrIp: input["CidrIp"],
  }
}
function toAwsEc2SecurityGroupIpRange(root: jsonP.JSONValue): s.AwsEc2SecurityGroupIpRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "CidrIp": "s",
    },
  }, root);
}

function fromAwsEc2SecurityGroupIpv6Range(input?: s.AwsEc2SecurityGroupIpv6Range | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CidrIpv6: input["CidrIpv6"],
  }
}
function toAwsEc2SecurityGroupIpv6Range(root: jsonP.JSONValue): s.AwsEc2SecurityGroupIpv6Range {
  return jsonP.readObj({
    required: {},
    optional: {
      "CidrIpv6": "s",
    },
  }, root);
}

function fromAwsEc2SecurityGroupPrefixListId(input?: s.AwsEc2SecurityGroupPrefixListId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrefixListId: input["PrefixListId"],
  }
}
function toAwsEc2SecurityGroupPrefixListId(root: jsonP.JSONValue): s.AwsEc2SecurityGroupPrefixListId {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrefixListId": "s",
    },
  }, root);
}

function fromAwsEc2VolumeDetails(input?: s.AwsEc2VolumeDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CreateTime: input["CreateTime"],
    Encrypted: input["Encrypted"],
    Size: input["Size"],
    SnapshotId: input["SnapshotId"],
    Status: input["Status"],
    KmsKeyId: input["KmsKeyId"],
    Attachments: input["Attachments"]?.map(x => fromAwsEc2VolumeAttachment(x)),
  }
}
function toAwsEc2VolumeDetails(root: jsonP.JSONValue): s.AwsEc2VolumeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreateTime": "s",
      "Encrypted": "b",
      "Size": "n",
      "SnapshotId": "s",
      "Status": "s",
      "KmsKeyId": "s",
      "Attachments": [toAwsEc2VolumeAttachment],
    },
  }, root);
}

function fromAwsEc2VolumeAttachment(input?: s.AwsEc2VolumeAttachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttachTime: input["AttachTime"],
    DeleteOnTermination: input["DeleteOnTermination"],
    InstanceId: input["InstanceId"],
    Status: input["Status"],
  }
}
function toAwsEc2VolumeAttachment(root: jsonP.JSONValue): s.AwsEc2VolumeAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachTime": "s",
      "DeleteOnTermination": "b",
      "InstanceId": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsEc2VpcDetails(input?: s.AwsEc2VpcDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CidrBlockAssociationSet: input["CidrBlockAssociationSet"]?.map(x => fromCidrBlockAssociation(x)),
    Ipv6CidrBlockAssociationSet: input["Ipv6CidrBlockAssociationSet"]?.map(x => fromIpv6CidrBlockAssociation(x)),
    DhcpOptionsId: input["DhcpOptionsId"],
    State: input["State"],
  }
}
function toAwsEc2VpcDetails(root: jsonP.JSONValue): s.AwsEc2VpcDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CidrBlockAssociationSet": [toCidrBlockAssociation],
      "Ipv6CidrBlockAssociationSet": [toIpv6CidrBlockAssociation],
      "DhcpOptionsId": "s",
      "State": "s",
    },
  }, root);
}

function fromCidrBlockAssociation(input?: s.CidrBlockAssociation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AssociationId: input["AssociationId"],
    CidrBlock: input["CidrBlock"],
    CidrBlockState: input["CidrBlockState"],
  }
}
function toCidrBlockAssociation(root: jsonP.JSONValue): s.CidrBlockAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "CidrBlock": "s",
      "CidrBlockState": "s",
    },
  }, root);
}

function fromIpv6CidrBlockAssociation(input?: s.Ipv6CidrBlockAssociation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AssociationId: input["AssociationId"],
    Ipv6CidrBlock: input["Ipv6CidrBlock"],
    CidrBlockState: input["CidrBlockState"],
  }
}
function toIpv6CidrBlockAssociation(root: jsonP.JSONValue): s.Ipv6CidrBlockAssociation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociationId": "s",
      "Ipv6CidrBlock": "s",
      "CidrBlockState": "s",
    },
  }, root);
}

function fromAwsEc2EipDetails(input?: s.AwsEc2EipDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceId: input["InstanceId"],
    PublicIp: input["PublicIp"],
    AllocationId: input["AllocationId"],
    AssociationId: input["AssociationId"],
    Domain: input["Domain"],
    PublicIpv4Pool: input["PublicIpv4Pool"],
    NetworkBorderGroup: input["NetworkBorderGroup"],
    NetworkInterfaceId: input["NetworkInterfaceId"],
    NetworkInterfaceOwnerId: input["NetworkInterfaceOwnerId"],
    PrivateIpAddress: input["PrivateIpAddress"],
  }
}
function toAwsEc2EipDetails(root: jsonP.JSONValue): s.AwsEc2EipDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceId": "s",
      "PublicIp": "s",
      "AllocationId": "s",
      "AssociationId": "s",
      "Domain": "s",
      "PublicIpv4Pool": "s",
      "NetworkBorderGroup": "s",
      "NetworkInterfaceId": "s",
      "NetworkInterfaceOwnerId": "s",
      "PrivateIpAddress": "s",
    },
  }, root);
}

function fromAwsElbv2LoadBalancerDetails(input?: s.AwsElbv2LoadBalancerDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZones: input["AvailabilityZones"]?.map(x => fromAvailabilityZone(x)),
    CanonicalHostedZoneId: input["CanonicalHostedZoneId"],
    CreatedTime: input["CreatedTime"],
    DNSName: input["DNSName"],
    IpAddressType: input["IpAddressType"],
    Scheme: input["Scheme"],
    SecurityGroups: input["SecurityGroups"],
    State: fromLoadBalancerState(input["State"]),
    Type: input["Type"],
    VpcId: input["VpcId"],
  }
}
function toAwsElbv2LoadBalancerDetails(root: jsonP.JSONValue): s.AwsElbv2LoadBalancerDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZones": [toAvailabilityZone],
      "CanonicalHostedZoneId": "s",
      "CreatedTime": "s",
      "DNSName": "s",
      "IpAddressType": "s",
      "Scheme": "s",
      "SecurityGroups": ["s"],
      "State": toLoadBalancerState,
      "Type": "s",
      "VpcId": "s",
    },
  }, root);
}

function fromAvailabilityZone(input?: s.AvailabilityZone | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ZoneName: input["ZoneName"],
    SubnetId: input["SubnetId"],
  }
}
function toAvailabilityZone(root: jsonP.JSONValue): s.AvailabilityZone {
  return jsonP.readObj({
    required: {},
    optional: {
      "ZoneName": "s",
      "SubnetId": "s",
    },
  }, root);
}

function fromLoadBalancerState(input?: s.LoadBalancerState | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Code: input["Code"],
    Reason: input["Reason"],
  }
}
function toLoadBalancerState(root: jsonP.JSONValue): s.LoadBalancerState {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": "s",
      "Reason": "s",
    },
  }, root);
}

function fromAwsElasticsearchDomainDetails(input?: s.AwsElasticsearchDomainDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccessPolicies: input["AccessPolicies"],
    DomainEndpointOptions: fromAwsElasticsearchDomainDomainEndpointOptions(input["DomainEndpointOptions"]),
    DomainId: input["DomainId"],
    DomainName: input["DomainName"],
    Endpoint: input["Endpoint"],
    Endpoints: input["Endpoints"],
    ElasticsearchVersion: input["ElasticsearchVersion"],
    EncryptionAtRestOptions: fromAwsElasticsearchDomainEncryptionAtRestOptions(input["EncryptionAtRestOptions"]),
    NodeToNodeEncryptionOptions: fromAwsElasticsearchDomainNodeToNodeEncryptionOptions(input["NodeToNodeEncryptionOptions"]),
    VPCOptions: fromAwsElasticsearchDomainVPCOptions(input["VPCOptions"]),
  }
}
function toAwsElasticsearchDomainDetails(root: jsonP.JSONValue): s.AwsElasticsearchDomainDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessPolicies": "s",
      "DomainEndpointOptions": toAwsElasticsearchDomainDomainEndpointOptions,
      "DomainId": "s",
      "DomainName": "s",
      "Endpoint": "s",
      "Endpoints": x => jsonP.readMap(String, String, x),
      "ElasticsearchVersion": "s",
      "EncryptionAtRestOptions": toAwsElasticsearchDomainEncryptionAtRestOptions,
      "NodeToNodeEncryptionOptions": toAwsElasticsearchDomainNodeToNodeEncryptionOptions,
      "VPCOptions": toAwsElasticsearchDomainVPCOptions,
    },
  }, root);
}

function fromAwsElasticsearchDomainDomainEndpointOptions(input?: s.AwsElasticsearchDomainDomainEndpointOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnforceHTTPS: input["EnforceHTTPS"],
    TLSSecurityPolicy: input["TLSSecurityPolicy"],
  }
}
function toAwsElasticsearchDomainDomainEndpointOptions(root: jsonP.JSONValue): s.AwsElasticsearchDomainDomainEndpointOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnforceHTTPS": "b",
      "TLSSecurityPolicy": "s",
    },
  }, root);
}

function fromAwsElasticsearchDomainEncryptionAtRestOptions(input?: s.AwsElasticsearchDomainEncryptionAtRestOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toAwsElasticsearchDomainEncryptionAtRestOptions(root: jsonP.JSONValue): s.AwsElasticsearchDomainEncryptionAtRestOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "KmsKeyId": "s",
    },
  }, root);
}

function fromAwsElasticsearchDomainNodeToNodeEncryptionOptions(input?: s.AwsElasticsearchDomainNodeToNodeEncryptionOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toAwsElasticsearchDomainNodeToNodeEncryptionOptions(root: jsonP.JSONValue): s.AwsElasticsearchDomainNodeToNodeEncryptionOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromAwsElasticsearchDomainVPCOptions(input?: s.AwsElasticsearchDomainVPCOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZones: input["AvailabilityZones"],
    SecurityGroupIds: input["SecurityGroupIds"],
    SubnetIds: input["SubnetIds"],
    VPCId: input["VPCId"],
  }
}
function toAwsElasticsearchDomainVPCOptions(root: jsonP.JSONValue): s.AwsElasticsearchDomainVPCOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZones": ["s"],
      "SecurityGroupIds": ["s"],
      "SubnetIds": ["s"],
      "VPCId": "s",
    },
  }, root);
}

function fromAwsS3BucketDetails(input?: s.AwsS3BucketDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OwnerId: input["OwnerId"],
    OwnerName: input["OwnerName"],
    CreatedAt: input["CreatedAt"],
    ServerSideEncryptionConfiguration: fromAwsS3BucketServerSideEncryptionConfiguration(input["ServerSideEncryptionConfiguration"]),
  }
}
function toAwsS3BucketDetails(root: jsonP.JSONValue): s.AwsS3BucketDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "OwnerId": "s",
      "OwnerName": "s",
      "CreatedAt": "s",
      "ServerSideEncryptionConfiguration": toAwsS3BucketServerSideEncryptionConfiguration,
    },
  }, root);
}

function fromAwsS3BucketServerSideEncryptionConfiguration(input?: s.AwsS3BucketServerSideEncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Rules: input["Rules"]?.map(x => fromAwsS3BucketServerSideEncryptionRule(x)),
  }
}
function toAwsS3BucketServerSideEncryptionConfiguration(root: jsonP.JSONValue): s.AwsS3BucketServerSideEncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Rules": [toAwsS3BucketServerSideEncryptionRule],
    },
  }, root);
}

function fromAwsS3BucketServerSideEncryptionRule(input?: s.AwsS3BucketServerSideEncryptionRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApplyServerSideEncryptionByDefault: fromAwsS3BucketServerSideEncryptionByDefault(input["ApplyServerSideEncryptionByDefault"]),
  }
}
function toAwsS3BucketServerSideEncryptionRule(root: jsonP.JSONValue): s.AwsS3BucketServerSideEncryptionRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApplyServerSideEncryptionByDefault": toAwsS3BucketServerSideEncryptionByDefault,
    },
  }, root);
}

function fromAwsS3BucketServerSideEncryptionByDefault(input?: s.AwsS3BucketServerSideEncryptionByDefault | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SSEAlgorithm: input["SSEAlgorithm"],
    KMSMasterKeyID: input["KMSMasterKeyID"],
  }
}
function toAwsS3BucketServerSideEncryptionByDefault(root: jsonP.JSONValue): s.AwsS3BucketServerSideEncryptionByDefault {
  return jsonP.readObj({
    required: {},
    optional: {
      "SSEAlgorithm": "s",
      "KMSMasterKeyID": "s",
    },
  }, root);
}

function fromAwsS3ObjectDetails(input?: s.AwsS3ObjectDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LastModified: input["LastModified"],
    ETag: input["ETag"],
    VersionId: input["VersionId"],
    ContentType: input["ContentType"],
    ServerSideEncryption: input["ServerSideEncryption"],
    SSEKMSKeyId: input["SSEKMSKeyId"],
  }
}
function toAwsS3ObjectDetails(root: jsonP.JSONValue): s.AwsS3ObjectDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastModified": "s",
      "ETag": "s",
      "VersionId": "s",
      "ContentType": "s",
      "ServerSideEncryption": "s",
      "SSEKMSKeyId": "s",
    },
  }, root);
}

function fromAwsSecretsManagerSecretDetails(input?: s.AwsSecretsManagerSecretDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RotationRules: fromAwsSecretsManagerSecretRotationRules(input["RotationRules"]),
    RotationOccurredWithinFrequency: input["RotationOccurredWithinFrequency"],
    KmsKeyId: input["KmsKeyId"],
    RotationEnabled: input["RotationEnabled"],
    RotationLambdaArn: input["RotationLambdaArn"],
    Deleted: input["Deleted"],
    Name: input["Name"],
    Description: input["Description"],
  }
}
function toAwsSecretsManagerSecretDetails(root: jsonP.JSONValue): s.AwsSecretsManagerSecretDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "RotationRules": toAwsSecretsManagerSecretRotationRules,
      "RotationOccurredWithinFrequency": "b",
      "KmsKeyId": "s",
      "RotationEnabled": "b",
      "RotationLambdaArn": "s",
      "Deleted": "b",
      "Name": "s",
      "Description": "s",
    },
  }, root);
}

function fromAwsSecretsManagerSecretRotationRules(input?: s.AwsSecretsManagerSecretRotationRules | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomaticallyAfterDays: input["AutomaticallyAfterDays"],
  }
}
function toAwsSecretsManagerSecretRotationRules(root: jsonP.JSONValue): s.AwsSecretsManagerSecretRotationRules {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticallyAfterDays": "n",
    },
  }, root);
}

function fromAwsIamAccessKeyDetails(input?: s.AwsIamAccessKeyDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserName: input["UserName"],
    Status: input["Status"],
    CreatedAt: input["CreatedAt"],
    PrincipalId: input["PrincipalId"],
    PrincipalType: input["PrincipalType"],
    PrincipalName: input["PrincipalName"],
    AccountId: input["AccountId"],
    AccessKeyId: input["AccessKeyId"],
    SessionContext: fromAwsIamAccessKeySessionContext(input["SessionContext"]),
  }
}
function toAwsIamAccessKeyDetails(root: jsonP.JSONValue): s.AwsIamAccessKeyDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AwsIamAccessKeyStatus>(x),
      "CreatedAt": "s",
      "PrincipalId": "s",
      "PrincipalType": "s",
      "PrincipalName": "s",
      "AccountId": "s",
      "AccessKeyId": "s",
      "SessionContext": toAwsIamAccessKeySessionContext,
    },
  }, root);
}

function fromAwsIamAccessKeySessionContext(input?: s.AwsIamAccessKeySessionContext | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: fromAwsIamAccessKeySessionContextAttributes(input["Attributes"]),
    SessionIssuer: fromAwsIamAccessKeySessionContextSessionIssuer(input["SessionIssuer"]),
  }
}
function toAwsIamAccessKeySessionContext(root: jsonP.JSONValue): s.AwsIamAccessKeySessionContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": toAwsIamAccessKeySessionContextAttributes,
      "SessionIssuer": toAwsIamAccessKeySessionContextSessionIssuer,
    },
  }, root);
}

function fromAwsIamAccessKeySessionContextAttributes(input?: s.AwsIamAccessKeySessionContextAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MfaAuthenticated: input["MfaAuthenticated"],
    CreationDate: input["CreationDate"],
  }
}
function toAwsIamAccessKeySessionContextAttributes(root: jsonP.JSONValue): s.AwsIamAccessKeySessionContextAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "MfaAuthenticated": "b",
      "CreationDate": "s",
    },
  }, root);
}

function fromAwsIamAccessKeySessionContextSessionIssuer(input?: s.AwsIamAccessKeySessionContextSessionIssuer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    PrincipalId: input["PrincipalId"],
    Arn: input["Arn"],
    AccountId: input["AccountId"],
    UserName: input["UserName"],
  }
}
function toAwsIamAccessKeySessionContextSessionIssuer(root: jsonP.JSONValue): s.AwsIamAccessKeySessionContextSessionIssuer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
      "PrincipalId": "s",
      "Arn": "s",
      "AccountId": "s",
      "UserName": "s",
    },
  }, root);
}

function fromAwsIamUserDetails(input?: s.AwsIamUserDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttachedManagedPolicies: input["AttachedManagedPolicies"]?.map(x => fromAwsIamAttachedManagedPolicy(x)),
    CreateDate: input["CreateDate"],
    GroupList: input["GroupList"],
    Path: input["Path"],
    PermissionsBoundary: fromAwsIamPermissionsBoundary(input["PermissionsBoundary"]),
    UserId: input["UserId"],
    UserName: input["UserName"],
    UserPolicyList: input["UserPolicyList"]?.map(x => fromAwsIamUserPolicy(x)),
  }
}
function toAwsIamUserDetails(root: jsonP.JSONValue): s.AwsIamUserDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedManagedPolicies": [toAwsIamAttachedManagedPolicy],
      "CreateDate": "s",
      "GroupList": ["s"],
      "Path": "s",
      "PermissionsBoundary": toAwsIamPermissionsBoundary,
      "UserId": "s",
      "UserName": "s",
      "UserPolicyList": [toAwsIamUserPolicy],
    },
  }, root);
}

function fromAwsIamAttachedManagedPolicy(input?: s.AwsIamAttachedManagedPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
    PolicyArn: input["PolicyArn"],
  }
}
function toAwsIamAttachedManagedPolicy(root: jsonP.JSONValue): s.AwsIamAttachedManagedPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
      "PolicyArn": "s",
    },
  }, root);
}

function fromAwsIamPermissionsBoundary(input?: s.AwsIamPermissionsBoundary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PermissionsBoundaryArn: input["PermissionsBoundaryArn"],
    PermissionsBoundaryType: input["PermissionsBoundaryType"],
  }
}
function toAwsIamPermissionsBoundary(root: jsonP.JSONValue): s.AwsIamPermissionsBoundary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PermissionsBoundaryArn": "s",
      "PermissionsBoundaryType": "s",
    },
  }, root);
}

function fromAwsIamUserPolicy(input?: s.AwsIamUserPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
  }
}
function toAwsIamUserPolicy(root: jsonP.JSONValue): s.AwsIamUserPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
    },
  }, root);
}

function fromAwsIamPolicyDetails(input?: s.AwsIamPolicyDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttachmentCount: input["AttachmentCount"],
    CreateDate: input["CreateDate"],
    DefaultVersionId: input["DefaultVersionId"],
    Description: input["Description"],
    IsAttachable: input["IsAttachable"],
    Path: input["Path"],
    PermissionsBoundaryUsageCount: input["PermissionsBoundaryUsageCount"],
    PolicyId: input["PolicyId"],
    PolicyName: input["PolicyName"],
    PolicyVersionList: input["PolicyVersionList"]?.map(x => fromAwsIamPolicyVersion(x)),
    UpdateDate: input["UpdateDate"],
  }
}
function toAwsIamPolicyDetails(root: jsonP.JSONValue): s.AwsIamPolicyDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachmentCount": "n",
      "CreateDate": "s",
      "DefaultVersionId": "s",
      "Description": "s",
      "IsAttachable": "b",
      "Path": "s",
      "PermissionsBoundaryUsageCount": "n",
      "PolicyId": "s",
      "PolicyName": "s",
      "PolicyVersionList": [toAwsIamPolicyVersion],
      "UpdateDate": "s",
    },
  }, root);
}

function fromAwsIamPolicyVersion(input?: s.AwsIamPolicyVersion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VersionId: input["VersionId"],
    IsDefaultVersion: input["IsDefaultVersion"],
    CreateDate: input["CreateDate"],
  }
}
function toAwsIamPolicyVersion(root: jsonP.JSONValue): s.AwsIamPolicyVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionId": "s",
      "IsDefaultVersion": "b",
      "CreateDate": "s",
    },
  }, root);
}

function fromAwsApiGatewayV2StageDetails(input?: s.AwsApiGatewayV2StageDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CreatedDate: input["CreatedDate"],
    Description: input["Description"],
    DefaultRouteSettings: fromAwsApiGatewayV2RouteSettings(input["DefaultRouteSettings"]),
    DeploymentId: input["DeploymentId"],
    LastUpdatedDate: input["LastUpdatedDate"],
    RouteSettings: fromAwsApiGatewayV2RouteSettings(input["RouteSettings"]),
    StageName: input["StageName"],
    StageVariables: input["StageVariables"],
    AccessLogSettings: fromAwsApiGatewayAccessLogSettings(input["AccessLogSettings"]),
    AutoDeploy: input["AutoDeploy"],
    LastDeploymentStatusMessage: input["LastDeploymentStatusMessage"],
    ApiGatewayManaged: input["ApiGatewayManaged"],
  }
}
function toAwsApiGatewayV2StageDetails(root: jsonP.JSONValue): s.AwsApiGatewayV2StageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreatedDate": "s",
      "Description": "s",
      "DefaultRouteSettings": toAwsApiGatewayV2RouteSettings,
      "DeploymentId": "s",
      "LastUpdatedDate": "s",
      "RouteSettings": toAwsApiGatewayV2RouteSettings,
      "StageName": "s",
      "StageVariables": x => jsonP.readMap(String, String, x),
      "AccessLogSettings": toAwsApiGatewayAccessLogSettings,
      "AutoDeploy": "b",
      "LastDeploymentStatusMessage": "s",
      "ApiGatewayManaged": "b",
    },
  }, root);
}

function fromAwsApiGatewayV2RouteSettings(input?: s.AwsApiGatewayV2RouteSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DetailedMetricsEnabled: input["DetailedMetricsEnabled"],
    LoggingLevel: input["LoggingLevel"],
    DataTraceEnabled: input["DataTraceEnabled"],
    ThrottlingBurstLimit: input["ThrottlingBurstLimit"],
    ThrottlingRateLimit: input["ThrottlingRateLimit"],
  }
}
function toAwsApiGatewayV2RouteSettings(root: jsonP.JSONValue): s.AwsApiGatewayV2RouteSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DetailedMetricsEnabled": "b",
      "LoggingLevel": "s",
      "DataTraceEnabled": "b",
      "ThrottlingBurstLimit": "n",
      "ThrottlingRateLimit": "n",
    },
  }, root);
}

function fromAwsApiGatewayAccessLogSettings(input?: s.AwsApiGatewayAccessLogSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Format: input["Format"],
    DestinationArn: input["DestinationArn"],
  }
}
function toAwsApiGatewayAccessLogSettings(root: jsonP.JSONValue): s.AwsApiGatewayAccessLogSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Format": "s",
      "DestinationArn": "s",
    },
  }, root);
}

function fromAwsApiGatewayV2ApiDetails(input?: s.AwsApiGatewayV2ApiDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApiEndpoint: input["ApiEndpoint"],
    ApiId: input["ApiId"],
    ApiKeySelectionExpression: input["ApiKeySelectionExpression"],
    CreatedDate: input["CreatedDate"],
    Description: input["Description"],
    Version: input["Version"],
    Name: input["Name"],
    ProtocolType: input["ProtocolType"],
    RouteSelectionExpression: input["RouteSelectionExpression"],
    CorsConfiguration: fromAwsCorsConfiguration(input["CorsConfiguration"]),
  }
}
function toAwsApiGatewayV2ApiDetails(root: jsonP.JSONValue): s.AwsApiGatewayV2ApiDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApiEndpoint": "s",
      "ApiId": "s",
      "ApiKeySelectionExpression": "s",
      "CreatedDate": "s",
      "Description": "s",
      "Version": "s",
      "Name": "s",
      "ProtocolType": "s",
      "RouteSelectionExpression": "s",
      "CorsConfiguration": toAwsCorsConfiguration,
    },
  }, root);
}

function fromAwsCorsConfiguration(input?: s.AwsCorsConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowOrigins: input["AllowOrigins"],
    AllowCredentials: input["AllowCredentials"],
    ExposeHeaders: input["ExposeHeaders"],
    MaxAge: input["MaxAge"],
    AllowMethods: input["AllowMethods"],
    AllowHeaders: input["AllowHeaders"],
  }
}
function toAwsCorsConfiguration(root: jsonP.JSONValue): s.AwsCorsConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowOrigins": ["s"],
      "AllowCredentials": "b",
      "ExposeHeaders": ["s"],
      "MaxAge": "n",
      "AllowMethods": ["s"],
      "AllowHeaders": ["s"],
    },
  }, root);
}

function fromAwsDynamoDbTableDetails(input?: s.AwsDynamoDbTableDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeDefinitions: input["AttributeDefinitions"]?.map(x => fromAwsDynamoDbTableAttributeDefinition(x)),
    BillingModeSummary: fromAwsDynamoDbTableBillingModeSummary(input["BillingModeSummary"]),
    CreationDateTime: input["CreationDateTime"],
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromAwsDynamoDbTableGlobalSecondaryIndex(x)),
    GlobalTableVersion: input["GlobalTableVersion"],
    ItemCount: input["ItemCount"],
    KeySchema: input["KeySchema"]?.map(x => fromAwsDynamoDbTableKeySchema(x)),
    LatestStreamArn: input["LatestStreamArn"],
    LatestStreamLabel: input["LatestStreamLabel"],
    LocalSecondaryIndexes: input["LocalSecondaryIndexes"]?.map(x => fromAwsDynamoDbTableLocalSecondaryIndex(x)),
    ProvisionedThroughput: fromAwsDynamoDbTableProvisionedThroughput(input["ProvisionedThroughput"]),
    Replicas: input["Replicas"]?.map(x => fromAwsDynamoDbTableReplica(x)),
    RestoreSummary: fromAwsDynamoDbTableRestoreSummary(input["RestoreSummary"]),
    SseDescription: fromAwsDynamoDbTableSseDescription(input["SseDescription"]),
    StreamSpecification: fromAwsDynamoDbTableStreamSpecification(input["StreamSpecification"]),
    TableId: input["TableId"],
    TableName: input["TableName"],
    TableSizeBytes: input["TableSizeBytes"],
    TableStatus: input["TableStatus"],
  }
}
function toAwsDynamoDbTableDetails(root: jsonP.JSONValue): s.AwsDynamoDbTableDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeDefinitions": [toAwsDynamoDbTableAttributeDefinition],
      "BillingModeSummary": toAwsDynamoDbTableBillingModeSummary,
      "CreationDateTime": "s",
      "GlobalSecondaryIndexes": [toAwsDynamoDbTableGlobalSecondaryIndex],
      "GlobalTableVersion": "s",
      "ItemCount": "n",
      "KeySchema": [toAwsDynamoDbTableKeySchema],
      "LatestStreamArn": "s",
      "LatestStreamLabel": "s",
      "LocalSecondaryIndexes": [toAwsDynamoDbTableLocalSecondaryIndex],
      "ProvisionedThroughput": toAwsDynamoDbTableProvisionedThroughput,
      "Replicas": [toAwsDynamoDbTableReplica],
      "RestoreSummary": toAwsDynamoDbTableRestoreSummary,
      "SseDescription": toAwsDynamoDbTableSseDescription,
      "StreamSpecification": toAwsDynamoDbTableStreamSpecification,
      "TableId": "s",
      "TableName": "s",
      "TableSizeBytes": "n",
      "TableStatus": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableAttributeDefinition(input?: s.AwsDynamoDbTableAttributeDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    AttributeType: input["AttributeType"],
  }
}
function toAwsDynamoDbTableAttributeDefinition(root: jsonP.JSONValue): s.AwsDynamoDbTableAttributeDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeName": "s",
      "AttributeType": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableBillingModeSummary(input?: s.AwsDynamoDbTableBillingModeSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BillingMode: input["BillingMode"],
    LastUpdateToPayPerRequestDateTime: input["LastUpdateToPayPerRequestDateTime"],
  }
}
function toAwsDynamoDbTableBillingModeSummary(root: jsonP.JSONValue): s.AwsDynamoDbTableBillingModeSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "BillingMode": "s",
      "LastUpdateToPayPerRequestDateTime": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableGlobalSecondaryIndex(input?: s.AwsDynamoDbTableGlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Backfilling: input["Backfilling"],
    IndexArn: input["IndexArn"],
    IndexName: input["IndexName"],
    IndexSizeBytes: input["IndexSizeBytes"],
    IndexStatus: input["IndexStatus"],
    ItemCount: input["ItemCount"],
    KeySchema: input["KeySchema"]?.map(x => fromAwsDynamoDbTableKeySchema(x)),
    Projection: fromAwsDynamoDbTableProjection(input["Projection"]),
    ProvisionedThroughput: fromAwsDynamoDbTableProvisionedThroughput(input["ProvisionedThroughput"]),
  }
}
function toAwsDynamoDbTableGlobalSecondaryIndex(root: jsonP.JSONValue): s.AwsDynamoDbTableGlobalSecondaryIndex {
  return jsonP.readObj({
    required: {},
    optional: {
      "Backfilling": "b",
      "IndexArn": "s",
      "IndexName": "s",
      "IndexSizeBytes": "n",
      "IndexStatus": "s",
      "ItemCount": "n",
      "KeySchema": [toAwsDynamoDbTableKeySchema],
      "Projection": toAwsDynamoDbTableProjection,
      "ProvisionedThroughput": toAwsDynamoDbTableProvisionedThroughput,
    },
  }, root);
}

function fromAwsDynamoDbTableKeySchema(input?: s.AwsDynamoDbTableKeySchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeName: input["AttributeName"],
    KeyType: input["KeyType"],
  }
}
function toAwsDynamoDbTableKeySchema(root: jsonP.JSONValue): s.AwsDynamoDbTableKeySchema {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttributeName": "s",
      "KeyType": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableProjection(input?: s.AwsDynamoDbTableProjection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NonKeyAttributes: input["NonKeyAttributes"],
    ProjectionType: input["ProjectionType"],
  }
}
function toAwsDynamoDbTableProjection(root: jsonP.JSONValue): s.AwsDynamoDbTableProjection {
  return jsonP.readObj({
    required: {},
    optional: {
      "NonKeyAttributes": ["s"],
      "ProjectionType": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableProvisionedThroughput(input?: s.AwsDynamoDbTableProvisionedThroughput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LastDecreaseDateTime: input["LastDecreaseDateTime"],
    LastIncreaseDateTime: input["LastIncreaseDateTime"],
    NumberOfDecreasesToday: input["NumberOfDecreasesToday"],
    ReadCapacityUnits: input["ReadCapacityUnits"],
    WriteCapacityUnits: input["WriteCapacityUnits"],
  }
}
function toAwsDynamoDbTableProvisionedThroughput(root: jsonP.JSONValue): s.AwsDynamoDbTableProvisionedThroughput {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastDecreaseDateTime": "s",
      "LastIncreaseDateTime": "s",
      "NumberOfDecreasesToday": "n",
      "ReadCapacityUnits": "n",
      "WriteCapacityUnits": "n",
    },
  }, root);
}

function fromAwsDynamoDbTableLocalSecondaryIndex(input?: s.AwsDynamoDbTableLocalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexArn: input["IndexArn"],
    IndexName: input["IndexName"],
    KeySchema: input["KeySchema"]?.map(x => fromAwsDynamoDbTableKeySchema(x)),
    Projection: fromAwsDynamoDbTableProjection(input["Projection"]),
  }
}
function toAwsDynamoDbTableLocalSecondaryIndex(root: jsonP.JSONValue): s.AwsDynamoDbTableLocalSecondaryIndex {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexArn": "s",
      "IndexName": "s",
      "KeySchema": [toAwsDynamoDbTableKeySchema],
      "Projection": toAwsDynamoDbTableProjection,
    },
  }, root);
}

function fromAwsDynamoDbTableReplica(input?: s.AwsDynamoDbTableReplica | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GlobalSecondaryIndexes: input["GlobalSecondaryIndexes"]?.map(x => fromAwsDynamoDbTableReplicaGlobalSecondaryIndex(x)),
    KmsMasterKeyId: input["KmsMasterKeyId"],
    ProvisionedThroughputOverride: fromAwsDynamoDbTableProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
    RegionName: input["RegionName"],
    ReplicaStatus: input["ReplicaStatus"],
    ReplicaStatusDescription: input["ReplicaStatusDescription"],
  }
}
function toAwsDynamoDbTableReplica(root: jsonP.JSONValue): s.AwsDynamoDbTableReplica {
  return jsonP.readObj({
    required: {},
    optional: {
      "GlobalSecondaryIndexes": [toAwsDynamoDbTableReplicaGlobalSecondaryIndex],
      "KmsMasterKeyId": "s",
      "ProvisionedThroughputOverride": toAwsDynamoDbTableProvisionedThroughputOverride,
      "RegionName": "s",
      "ReplicaStatus": "s",
      "ReplicaStatusDescription": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableReplicaGlobalSecondaryIndex(input?: s.AwsDynamoDbTableReplicaGlobalSecondaryIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IndexName: input["IndexName"],
    ProvisionedThroughputOverride: fromAwsDynamoDbTableProvisionedThroughputOverride(input["ProvisionedThroughputOverride"]),
  }
}
function toAwsDynamoDbTableReplicaGlobalSecondaryIndex(root: jsonP.JSONValue): s.AwsDynamoDbTableReplicaGlobalSecondaryIndex {
  return jsonP.readObj({
    required: {},
    optional: {
      "IndexName": "s",
      "ProvisionedThroughputOverride": toAwsDynamoDbTableProvisionedThroughputOverride,
    },
  }, root);
}

function fromAwsDynamoDbTableProvisionedThroughputOverride(input?: s.AwsDynamoDbTableProvisionedThroughputOverride | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReadCapacityUnits: input["ReadCapacityUnits"],
  }
}
function toAwsDynamoDbTableProvisionedThroughputOverride(root: jsonP.JSONValue): s.AwsDynamoDbTableProvisionedThroughputOverride {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReadCapacityUnits": "n",
    },
  }, root);
}

function fromAwsDynamoDbTableRestoreSummary(input?: s.AwsDynamoDbTableRestoreSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceBackupArn: input["SourceBackupArn"],
    SourceTableArn: input["SourceTableArn"],
    RestoreDateTime: input["RestoreDateTime"],
    RestoreInProgress: input["RestoreInProgress"],
  }
}
function toAwsDynamoDbTableRestoreSummary(root: jsonP.JSONValue): s.AwsDynamoDbTableRestoreSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceBackupArn": "s",
      "SourceTableArn": "s",
      "RestoreDateTime": "s",
      "RestoreInProgress": "b",
    },
  }, root);
}

function fromAwsDynamoDbTableSseDescription(input?: s.AwsDynamoDbTableSseDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InaccessibleEncryptionDateTime: input["InaccessibleEncryptionDateTime"],
    Status: input["Status"],
    SseType: input["SseType"],
    KmsMasterKeyArn: input["KmsMasterKeyArn"],
  }
}
function toAwsDynamoDbTableSseDescription(root: jsonP.JSONValue): s.AwsDynamoDbTableSseDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "InaccessibleEncryptionDateTime": "s",
      "Status": "s",
      "SseType": "s",
      "KmsMasterKeyArn": "s",
    },
  }, root);
}

function fromAwsDynamoDbTableStreamSpecification(input?: s.AwsDynamoDbTableStreamSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StreamEnabled: input["StreamEnabled"],
    StreamViewType: input["StreamViewType"],
  }
}
function toAwsDynamoDbTableStreamSpecification(root: jsonP.JSONValue): s.AwsDynamoDbTableStreamSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "StreamEnabled": "b",
      "StreamViewType": "s",
    },
  }, root);
}

function fromAwsApiGatewayStageDetails(input?: s.AwsApiGatewayStageDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeploymentId: input["DeploymentId"],
    ClientCertificateId: input["ClientCertificateId"],
    StageName: input["StageName"],
    Description: input["Description"],
    CacheClusterEnabled: input["CacheClusterEnabled"],
    CacheClusterSize: input["CacheClusterSize"],
    CacheClusterStatus: input["CacheClusterStatus"],
    MethodSettings: input["MethodSettings"]?.map(x => fromAwsApiGatewayMethodSettings(x)),
    Variables: input["Variables"],
    DocumentationVersion: input["DocumentationVersion"],
    AccessLogSettings: fromAwsApiGatewayAccessLogSettings(input["AccessLogSettings"]),
    CanarySettings: fromAwsApiGatewayCanarySettings(input["CanarySettings"]),
    TracingEnabled: input["TracingEnabled"],
    CreatedDate: input["CreatedDate"],
    LastUpdatedDate: input["LastUpdatedDate"],
    WebAclArn: input["WebAclArn"],
  }
}
function toAwsApiGatewayStageDetails(root: jsonP.JSONValue): s.AwsApiGatewayStageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeploymentId": "s",
      "ClientCertificateId": "s",
      "StageName": "s",
      "Description": "s",
      "CacheClusterEnabled": "b",
      "CacheClusterSize": "s",
      "CacheClusterStatus": "s",
      "MethodSettings": [toAwsApiGatewayMethodSettings],
      "Variables": x => jsonP.readMap(String, String, x),
      "DocumentationVersion": "s",
      "AccessLogSettings": toAwsApiGatewayAccessLogSettings,
      "CanarySettings": toAwsApiGatewayCanarySettings,
      "TracingEnabled": "b",
      "CreatedDate": "s",
      "LastUpdatedDate": "s",
      "WebAclArn": "s",
    },
  }, root);
}

function fromAwsApiGatewayMethodSettings(input?: s.AwsApiGatewayMethodSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetricsEnabled: input["MetricsEnabled"],
    LoggingLevel: input["LoggingLevel"],
    DataTraceEnabled: input["DataTraceEnabled"],
    ThrottlingBurstLimit: input["ThrottlingBurstLimit"],
    ThrottlingRateLimit: input["ThrottlingRateLimit"],
    CachingEnabled: input["CachingEnabled"],
    CacheTtlInSeconds: input["CacheTtlInSeconds"],
    CacheDataEncrypted: input["CacheDataEncrypted"],
    RequireAuthorizationForCacheControl: input["RequireAuthorizationForCacheControl"],
    UnauthorizedCacheControlHeaderStrategy: input["UnauthorizedCacheControlHeaderStrategy"],
    HttpMethod: input["HttpMethod"],
    ResourcePath: input["ResourcePath"],
  }
}
function toAwsApiGatewayMethodSettings(root: jsonP.JSONValue): s.AwsApiGatewayMethodSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetricsEnabled": "b",
      "LoggingLevel": "s",
      "DataTraceEnabled": "b",
      "ThrottlingBurstLimit": "n",
      "ThrottlingRateLimit": "n",
      "CachingEnabled": "b",
      "CacheTtlInSeconds": "n",
      "CacheDataEncrypted": "b",
      "RequireAuthorizationForCacheControl": "b",
      "UnauthorizedCacheControlHeaderStrategy": "s",
      "HttpMethod": "s",
      "ResourcePath": "s",
    },
  }, root);
}

function fromAwsApiGatewayCanarySettings(input?: s.AwsApiGatewayCanarySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PercentTraffic: input["PercentTraffic"],
    DeploymentId: input["DeploymentId"],
    StageVariableOverrides: input["StageVariableOverrides"],
    UseStageCache: input["UseStageCache"],
  }
}
function toAwsApiGatewayCanarySettings(root: jsonP.JSONValue): s.AwsApiGatewayCanarySettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PercentTraffic": "n",
      "DeploymentId": "s",
      "StageVariableOverrides": x => jsonP.readMap(String, String, x),
      "UseStageCache": "b",
    },
  }, root);
}

function fromAwsApiGatewayRestApiDetails(input?: s.AwsApiGatewayRestApiDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Name: input["Name"],
    Description: input["Description"],
    CreatedDate: input["CreatedDate"],
    Version: input["Version"],
    BinaryMediaTypes: input["BinaryMediaTypes"],
    MinimumCompressionSize: input["MinimumCompressionSize"],
    ApiKeySource: input["ApiKeySource"],
    EndpointConfiguration: fromAwsApiGatewayEndpointConfiguration(input["EndpointConfiguration"]),
  }
}
function toAwsApiGatewayRestApiDetails(root: jsonP.JSONValue): s.AwsApiGatewayRestApiDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Name": "s",
      "Description": "s",
      "CreatedDate": "s",
      "Version": "s",
      "BinaryMediaTypes": ["s"],
      "MinimumCompressionSize": "n",
      "ApiKeySource": "s",
      "EndpointConfiguration": toAwsApiGatewayEndpointConfiguration,
    },
  }, root);
}

function fromAwsApiGatewayEndpointConfiguration(input?: s.AwsApiGatewayEndpointConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Types: input["Types"],
  }
}
function toAwsApiGatewayEndpointConfiguration(root: jsonP.JSONValue): s.AwsApiGatewayEndpointConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Types": ["s"],
    },
  }, root);
}

function fromAwsCloudTrailTrailDetails(input?: s.AwsCloudTrailTrailDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchLogsLogGroupArn: input["CloudWatchLogsLogGroupArn"],
    CloudWatchLogsRoleArn: input["CloudWatchLogsRoleArn"],
    HasCustomEventSelectors: input["HasCustomEventSelectors"],
    HomeRegion: input["HomeRegion"],
    IncludeGlobalServiceEvents: input["IncludeGlobalServiceEvents"],
    IsMultiRegionTrail: input["IsMultiRegionTrail"],
    IsOrganizationTrail: input["IsOrganizationTrail"],
    KmsKeyId: input["KmsKeyId"],
    LogFileValidationEnabled: input["LogFileValidationEnabled"],
    Name: input["Name"],
    S3BucketName: input["S3BucketName"],
    S3KeyPrefix: input["S3KeyPrefix"],
    SnsTopicArn: input["SnsTopicArn"],
    SnsTopicName: input["SnsTopicName"],
    TrailArn: input["TrailArn"],
  }
}
function toAwsCloudTrailTrailDetails(root: jsonP.JSONValue): s.AwsCloudTrailTrailDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchLogsLogGroupArn": "s",
      "CloudWatchLogsRoleArn": "s",
      "HasCustomEventSelectors": "b",
      "HomeRegion": "s",
      "IncludeGlobalServiceEvents": "b",
      "IsMultiRegionTrail": "b",
      "IsOrganizationTrail": "b",
      "KmsKeyId": "s",
      "LogFileValidationEnabled": "b",
      "Name": "s",
      "S3BucketName": "s",
      "S3KeyPrefix": "s",
      "SnsTopicArn": "s",
      "SnsTopicName": "s",
      "TrailArn": "s",
    },
  }, root);
}

function fromAwsSsmPatchComplianceDetails(input?: s.AwsSsmPatchComplianceDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Patch: fromAwsSsmPatch(input["Patch"]),
  }
}
function toAwsSsmPatchComplianceDetails(root: jsonP.JSONValue): s.AwsSsmPatchComplianceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Patch": toAwsSsmPatch,
    },
  }, root);
}

function fromAwsSsmPatch(input?: s.AwsSsmPatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComplianceSummary: fromAwsSsmComplianceSummary(input["ComplianceSummary"]),
  }
}
function toAwsSsmPatch(root: jsonP.JSONValue): s.AwsSsmPatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "ComplianceSummary": toAwsSsmComplianceSummary,
    },
  }, root);
}

function fromAwsSsmComplianceSummary(input?: s.AwsSsmComplianceSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
    CompliantCriticalCount: input["CompliantCriticalCount"],
    CompliantHighCount: input["CompliantHighCount"],
    CompliantMediumCount: input["CompliantMediumCount"],
    ExecutionType: input["ExecutionType"],
    NonCompliantCriticalCount: input["NonCompliantCriticalCount"],
    CompliantInformationalCount: input["CompliantInformationalCount"],
    NonCompliantInformationalCount: input["NonCompliantInformationalCount"],
    CompliantUnspecifiedCount: input["CompliantUnspecifiedCount"],
    NonCompliantLowCount: input["NonCompliantLowCount"],
    NonCompliantHighCount: input["NonCompliantHighCount"],
    CompliantLowCount: input["CompliantLowCount"],
    ComplianceType: input["ComplianceType"],
    PatchBaselineId: input["PatchBaselineId"],
    OverallSeverity: input["OverallSeverity"],
    NonCompliantMediumCount: input["NonCompliantMediumCount"],
    NonCompliantUnspecifiedCount: input["NonCompliantUnspecifiedCount"],
    PatchGroup: input["PatchGroup"],
  }
}
function toAwsSsmComplianceSummary(root: jsonP.JSONValue): s.AwsSsmComplianceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": "s",
      "CompliantCriticalCount": "n",
      "CompliantHighCount": "n",
      "CompliantMediumCount": "n",
      "ExecutionType": "s",
      "NonCompliantCriticalCount": "n",
      "CompliantInformationalCount": "n",
      "NonCompliantInformationalCount": "n",
      "CompliantUnspecifiedCount": "n",
      "NonCompliantLowCount": "n",
      "NonCompliantHighCount": "n",
      "CompliantLowCount": "n",
      "ComplianceType": "s",
      "PatchBaselineId": "s",
      "OverallSeverity": "s",
      "NonCompliantMediumCount": "n",
      "NonCompliantUnspecifiedCount": "n",
      "PatchGroup": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateDetails(input?: s.AwsCertificateManagerCertificateDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateAuthorityArn: input["CertificateAuthorityArn"],
    CreatedAt: input["CreatedAt"],
    DomainName: input["DomainName"],
    DomainValidationOptions: input["DomainValidationOptions"]?.map(x => fromAwsCertificateManagerCertificateDomainValidationOption(x)),
    ExtendedKeyUsages: input["ExtendedKeyUsages"]?.map(x => fromAwsCertificateManagerCertificateExtendedKeyUsage(x)),
    FailureReason: input["FailureReason"],
    ImportedAt: input["ImportedAt"],
    InUseBy: input["InUseBy"],
    IssuedAt: input["IssuedAt"],
    Issuer: input["Issuer"],
    KeyAlgorithm: input["KeyAlgorithm"],
    KeyUsages: input["KeyUsages"]?.map(x => fromAwsCertificateManagerCertificateKeyUsage(x)),
    NotAfter: input["NotAfter"],
    NotBefore: input["NotBefore"],
    Options: fromAwsCertificateManagerCertificateOptions(input["Options"]),
    RenewalEligibility: input["RenewalEligibility"],
    RenewalSummary: fromAwsCertificateManagerCertificateRenewalSummary(input["RenewalSummary"]),
    Serial: input["Serial"],
    SignatureAlgorithm: input["SignatureAlgorithm"],
    Status: input["Status"],
    Subject: input["Subject"],
    SubjectAlternativeNames: input["SubjectAlternativeNames"],
    Type: input["Type"],
  }
}
function toAwsCertificateManagerCertificateDetails(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateAuthorityArn": "s",
      "CreatedAt": "s",
      "DomainName": "s",
      "DomainValidationOptions": [toAwsCertificateManagerCertificateDomainValidationOption],
      "ExtendedKeyUsages": [toAwsCertificateManagerCertificateExtendedKeyUsage],
      "FailureReason": "s",
      "ImportedAt": "s",
      "InUseBy": ["s"],
      "IssuedAt": "s",
      "Issuer": "s",
      "KeyAlgorithm": "s",
      "KeyUsages": [toAwsCertificateManagerCertificateKeyUsage],
      "NotAfter": "s",
      "NotBefore": "s",
      "Options": toAwsCertificateManagerCertificateOptions,
      "RenewalEligibility": "s",
      "RenewalSummary": toAwsCertificateManagerCertificateRenewalSummary,
      "Serial": "s",
      "SignatureAlgorithm": "s",
      "Status": "s",
      "Subject": "s",
      "SubjectAlternativeNames": ["s"],
      "Type": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateDomainValidationOption(input?: s.AwsCertificateManagerCertificateDomainValidationOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DomainName: input["DomainName"],
    ResourceRecord: fromAwsCertificateManagerCertificateResourceRecord(input["ResourceRecord"]),
    ValidationDomain: input["ValidationDomain"],
    ValidationEmails: input["ValidationEmails"],
    ValidationMethod: input["ValidationMethod"],
    ValidationStatus: input["ValidationStatus"],
  }
}
function toAwsCertificateManagerCertificateDomainValidationOption(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateDomainValidationOption {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainName": "s",
      "ResourceRecord": toAwsCertificateManagerCertificateResourceRecord,
      "ValidationDomain": "s",
      "ValidationEmails": ["s"],
      "ValidationMethod": "s",
      "ValidationStatus": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateResourceRecord(input?: s.AwsCertificateManagerCertificateResourceRecord | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    Value: input["Value"],
  }
}
function toAwsCertificateManagerCertificateResourceRecord(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateResourceRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Type": "s",
      "Value": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateExtendedKeyUsage(input?: s.AwsCertificateManagerCertificateExtendedKeyUsage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    OId: input["OId"],
  }
}
function toAwsCertificateManagerCertificateExtendedKeyUsage(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateExtendedKeyUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "OId": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateKeyUsage(input?: s.AwsCertificateManagerCertificateKeyUsage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
  }
}
function toAwsCertificateManagerCertificateKeyUsage(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateKeyUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateOptions(input?: s.AwsCertificateManagerCertificateOptions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CertificateTransparencyLoggingPreference: input["CertificateTransparencyLoggingPreference"],
  }
}
function toAwsCertificateManagerCertificateOptions(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateOptions {
  return jsonP.readObj({
    required: {},
    optional: {
      "CertificateTransparencyLoggingPreference": "s",
    },
  }, root);
}

function fromAwsCertificateManagerCertificateRenewalSummary(input?: s.AwsCertificateManagerCertificateRenewalSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DomainValidationOptions: input["DomainValidationOptions"]?.map(x => fromAwsCertificateManagerCertificateDomainValidationOption(x)),
    RenewalStatus: input["RenewalStatus"],
    RenewalStatusReason: input["RenewalStatusReason"],
    UpdatedAt: input["UpdatedAt"],
  }
}
function toAwsCertificateManagerCertificateRenewalSummary(root: jsonP.JSONValue): s.AwsCertificateManagerCertificateRenewalSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainValidationOptions": [toAwsCertificateManagerCertificateDomainValidationOption],
      "RenewalStatus": "s",
      "RenewalStatusReason": "s",
      "UpdatedAt": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterDetails(input?: s.AwsRedshiftClusterDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowVersionUpgrade: input["AllowVersionUpgrade"],
    AutomatedSnapshotRetentionPeriod: input["AutomatedSnapshotRetentionPeriod"],
    AvailabilityZone: input["AvailabilityZone"],
    ClusterAvailabilityStatus: input["ClusterAvailabilityStatus"],
    ClusterCreateTime: input["ClusterCreateTime"],
    ClusterIdentifier: input["ClusterIdentifier"],
    ClusterNodes: input["ClusterNodes"]?.map(x => fromAwsRedshiftClusterClusterNode(x)),
    ClusterParameterGroups: input["ClusterParameterGroups"]?.map(x => fromAwsRedshiftClusterClusterParameterGroup(x)),
    ClusterPublicKey: input["ClusterPublicKey"],
    ClusterRevisionNumber: input["ClusterRevisionNumber"],
    ClusterSecurityGroups: input["ClusterSecurityGroups"]?.map(x => fromAwsRedshiftClusterClusterSecurityGroup(x)),
    ClusterSnapshotCopyStatus: fromAwsRedshiftClusterClusterSnapshotCopyStatus(input["ClusterSnapshotCopyStatus"]),
    ClusterStatus: input["ClusterStatus"],
    ClusterSubnetGroupName: input["ClusterSubnetGroupName"],
    ClusterVersion: input["ClusterVersion"],
    DBName: input["DBName"],
    DeferredMaintenanceWindows: input["DeferredMaintenanceWindows"]?.map(x => fromAwsRedshiftClusterDeferredMaintenanceWindow(x)),
    ElasticIpStatus: fromAwsRedshiftClusterElasticIpStatus(input["ElasticIpStatus"]),
    ElasticResizeNumberOfNodeOptions: input["ElasticResizeNumberOfNodeOptions"],
    Encrypted: input["Encrypted"],
    Endpoint: fromAwsRedshiftClusterEndpoint(input["Endpoint"]),
    EnhancedVpcRouting: input["EnhancedVpcRouting"],
    ExpectedNextSnapshotScheduleTime: input["ExpectedNextSnapshotScheduleTime"],
    ExpectedNextSnapshotScheduleTimeStatus: input["ExpectedNextSnapshotScheduleTimeStatus"],
    HsmStatus: fromAwsRedshiftClusterHsmStatus(input["HsmStatus"]),
    IamRoles: input["IamRoles"]?.map(x => fromAwsRedshiftClusterIamRole(x)),
    KmsKeyId: input["KmsKeyId"],
    MaintenanceTrackName: input["MaintenanceTrackName"],
    ManualSnapshotRetentionPeriod: input["ManualSnapshotRetentionPeriod"],
    MasterUsername: input["MasterUsername"],
    NextMaintenanceWindowStartTime: input["NextMaintenanceWindowStartTime"],
    NodeType: input["NodeType"],
    NumberOfNodes: input["NumberOfNodes"],
    PendingActions: input["PendingActions"],
    PendingModifiedValues: fromAwsRedshiftClusterPendingModifiedValues(input["PendingModifiedValues"]),
    PreferredMaintenanceWindow: input["PreferredMaintenanceWindow"],
    PubliclyAccessible: input["PubliclyAccessible"],
    ResizeInfo: fromAwsRedshiftClusterResizeInfo(input["ResizeInfo"]),
    RestoreStatus: fromAwsRedshiftClusterRestoreStatus(input["RestoreStatus"]),
    SnapshotScheduleIdentifier: input["SnapshotScheduleIdentifier"],
    SnapshotScheduleState: input["SnapshotScheduleState"],
    VpcId: input["VpcId"],
    VpcSecurityGroups: input["VpcSecurityGroups"]?.map(x => fromAwsRedshiftClusterVpcSecurityGroup(x)),
  }
}
function toAwsRedshiftClusterDetails(root: jsonP.JSONValue): s.AwsRedshiftClusterDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowVersionUpgrade": "b",
      "AutomatedSnapshotRetentionPeriod": "n",
      "AvailabilityZone": "s",
      "ClusterAvailabilityStatus": "s",
      "ClusterCreateTime": "s",
      "ClusterIdentifier": "s",
      "ClusterNodes": [toAwsRedshiftClusterClusterNode],
      "ClusterParameterGroups": [toAwsRedshiftClusterClusterParameterGroup],
      "ClusterPublicKey": "s",
      "ClusterRevisionNumber": "s",
      "ClusterSecurityGroups": [toAwsRedshiftClusterClusterSecurityGroup],
      "ClusterSnapshotCopyStatus": toAwsRedshiftClusterClusterSnapshotCopyStatus,
      "ClusterStatus": "s",
      "ClusterSubnetGroupName": "s",
      "ClusterVersion": "s",
      "DBName": "s",
      "DeferredMaintenanceWindows": [toAwsRedshiftClusterDeferredMaintenanceWindow],
      "ElasticIpStatus": toAwsRedshiftClusterElasticIpStatus,
      "ElasticResizeNumberOfNodeOptions": "s",
      "Encrypted": "b",
      "Endpoint": toAwsRedshiftClusterEndpoint,
      "EnhancedVpcRouting": "b",
      "ExpectedNextSnapshotScheduleTime": "s",
      "ExpectedNextSnapshotScheduleTimeStatus": "s",
      "HsmStatus": toAwsRedshiftClusterHsmStatus,
      "IamRoles": [toAwsRedshiftClusterIamRole],
      "KmsKeyId": "s",
      "MaintenanceTrackName": "s",
      "ManualSnapshotRetentionPeriod": "n",
      "MasterUsername": "s",
      "NextMaintenanceWindowStartTime": "s",
      "NodeType": "s",
      "NumberOfNodes": "n",
      "PendingActions": ["s"],
      "PendingModifiedValues": toAwsRedshiftClusterPendingModifiedValues,
      "PreferredMaintenanceWindow": "s",
      "PubliclyAccessible": "b",
      "ResizeInfo": toAwsRedshiftClusterResizeInfo,
      "RestoreStatus": toAwsRedshiftClusterRestoreStatus,
      "SnapshotScheduleIdentifier": "s",
      "SnapshotScheduleState": "s",
      "VpcId": "s",
      "VpcSecurityGroups": [toAwsRedshiftClusterVpcSecurityGroup],
    },
  }, root);
}

function fromAwsRedshiftClusterClusterNode(input?: s.AwsRedshiftClusterClusterNode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NodeRole: input["NodeRole"],
    PrivateIpAddress: input["PrivateIpAddress"],
    PublicIpAddress: input["PublicIpAddress"],
  }
}
function toAwsRedshiftClusterClusterNode(root: jsonP.JSONValue): s.AwsRedshiftClusterClusterNode {
  return jsonP.readObj({
    required: {},
    optional: {
      "NodeRole": "s",
      "PrivateIpAddress": "s",
      "PublicIpAddress": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterClusterParameterGroup(input?: s.AwsRedshiftClusterClusterParameterGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterParameterStatusList: input["ClusterParameterStatusList"]?.map(x => fromAwsRedshiftClusterClusterParameterStatus(x)),
    ParameterApplyStatus: input["ParameterApplyStatus"],
    ParameterGroupName: input["ParameterGroupName"],
  }
}
function toAwsRedshiftClusterClusterParameterGroup(root: jsonP.JSONValue): s.AwsRedshiftClusterClusterParameterGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClusterParameterStatusList": [toAwsRedshiftClusterClusterParameterStatus],
      "ParameterApplyStatus": "s",
      "ParameterGroupName": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterClusterParameterStatus(input?: s.AwsRedshiftClusterClusterParameterStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParameterName: input["ParameterName"],
    ParameterApplyStatus: input["ParameterApplyStatus"],
    ParameterApplyErrorDescription: input["ParameterApplyErrorDescription"],
  }
}
function toAwsRedshiftClusterClusterParameterStatus(root: jsonP.JSONValue): s.AwsRedshiftClusterClusterParameterStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ParameterName": "s",
      "ParameterApplyStatus": "s",
      "ParameterApplyErrorDescription": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterClusterSecurityGroup(input?: s.AwsRedshiftClusterClusterSecurityGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterSecurityGroupName: input["ClusterSecurityGroupName"],
    Status: input["Status"],
  }
}
function toAwsRedshiftClusterClusterSecurityGroup(root: jsonP.JSONValue): s.AwsRedshiftClusterClusterSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClusterSecurityGroupName": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterClusterSnapshotCopyStatus(input?: s.AwsRedshiftClusterClusterSnapshotCopyStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DestinationRegion: input["DestinationRegion"],
    ManualSnapshotRetentionPeriod: input["ManualSnapshotRetentionPeriod"],
    RetentionPeriod: input["RetentionPeriod"],
    SnapshotCopyGrantName: input["SnapshotCopyGrantName"],
  }
}
function toAwsRedshiftClusterClusterSnapshotCopyStatus(root: jsonP.JSONValue): s.AwsRedshiftClusterClusterSnapshotCopyStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationRegion": "s",
      "ManualSnapshotRetentionPeriod": "n",
      "RetentionPeriod": "n",
      "SnapshotCopyGrantName": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterDeferredMaintenanceWindow(input?: s.AwsRedshiftClusterDeferredMaintenanceWindow | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeferMaintenanceEndTime: input["DeferMaintenanceEndTime"],
    DeferMaintenanceIdentifier: input["DeferMaintenanceIdentifier"],
    DeferMaintenanceStartTime: input["DeferMaintenanceStartTime"],
  }
}
function toAwsRedshiftClusterDeferredMaintenanceWindow(root: jsonP.JSONValue): s.AwsRedshiftClusterDeferredMaintenanceWindow {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeferMaintenanceEndTime": "s",
      "DeferMaintenanceIdentifier": "s",
      "DeferMaintenanceStartTime": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterElasticIpStatus(input?: s.AwsRedshiftClusterElasticIpStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ElasticIp: input["ElasticIp"],
    Status: input["Status"],
  }
}
function toAwsRedshiftClusterElasticIpStatus(root: jsonP.JSONValue): s.AwsRedshiftClusterElasticIpStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ElasticIp": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterEndpoint(input?: s.AwsRedshiftClusterEndpoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Port: input["Port"],
  }
}
function toAwsRedshiftClusterEndpoint(root: jsonP.JSONValue): s.AwsRedshiftClusterEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "Port": "n",
    },
  }, root);
}

function fromAwsRedshiftClusterHsmStatus(input?: s.AwsRedshiftClusterHsmStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HsmClientCertificateIdentifier: input["HsmClientCertificateIdentifier"],
    HsmConfigurationIdentifier: input["HsmConfigurationIdentifier"],
    Status: input["Status"],
  }
}
function toAwsRedshiftClusterHsmStatus(root: jsonP.JSONValue): s.AwsRedshiftClusterHsmStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "HsmClientCertificateIdentifier": "s",
      "HsmConfigurationIdentifier": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterIamRole(input?: s.AwsRedshiftClusterIamRole | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApplyStatus: input["ApplyStatus"],
    IamRoleArn: input["IamRoleArn"],
  }
}
function toAwsRedshiftClusterIamRole(root: jsonP.JSONValue): s.AwsRedshiftClusterIamRole {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApplyStatus": "s",
      "IamRoleArn": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterPendingModifiedValues(input?: s.AwsRedshiftClusterPendingModifiedValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AutomatedSnapshotRetentionPeriod: input["AutomatedSnapshotRetentionPeriod"],
    ClusterIdentifier: input["ClusterIdentifier"],
    ClusterType: input["ClusterType"],
    ClusterVersion: input["ClusterVersion"],
    EncryptionType: input["EncryptionType"],
    EnhancedVpcRouting: input["EnhancedVpcRouting"],
    MaintenanceTrackName: input["MaintenanceTrackName"],
    MasterUserPassword: input["MasterUserPassword"],
    NodeType: input["NodeType"],
    NumberOfNodes: input["NumberOfNodes"],
    PubliclyAccessible: input["PubliclyAccessible"],
  }
}
function toAwsRedshiftClusterPendingModifiedValues(root: jsonP.JSONValue): s.AwsRedshiftClusterPendingModifiedValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomatedSnapshotRetentionPeriod": "n",
      "ClusterIdentifier": "s",
      "ClusterType": "s",
      "ClusterVersion": "s",
      "EncryptionType": "s",
      "EnhancedVpcRouting": "b",
      "MaintenanceTrackName": "s",
      "MasterUserPassword": "s",
      "NodeType": "s",
      "NumberOfNodes": "n",
      "PubliclyAccessible": "b",
    },
  }, root);
}

function fromAwsRedshiftClusterResizeInfo(input?: s.AwsRedshiftClusterResizeInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowCancelResize: input["AllowCancelResize"],
    ResizeType: input["ResizeType"],
  }
}
function toAwsRedshiftClusterResizeInfo(root: jsonP.JSONValue): s.AwsRedshiftClusterResizeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowCancelResize": "b",
      "ResizeType": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterRestoreStatus(input?: s.AwsRedshiftClusterRestoreStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CurrentRestoreRateInMegaBytesPerSecond: input["CurrentRestoreRateInMegaBytesPerSecond"],
    ElapsedTimeInSeconds: input["ElapsedTimeInSeconds"],
    EstimatedTimeToCompletionInSeconds: input["EstimatedTimeToCompletionInSeconds"],
    ProgressInMegaBytes: input["ProgressInMegaBytes"],
    SnapshotSizeInMegaBytes: input["SnapshotSizeInMegaBytes"],
    Status: input["Status"],
  }
}
function toAwsRedshiftClusterRestoreStatus(root: jsonP.JSONValue): s.AwsRedshiftClusterRestoreStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "CurrentRestoreRateInMegaBytesPerSecond": "n",
      "ElapsedTimeInSeconds": "n",
      "EstimatedTimeToCompletionInSeconds": "n",
      "ProgressInMegaBytes": "n",
      "SnapshotSizeInMegaBytes": "n",
      "Status": "s",
    },
  }, root);
}

function fromAwsRedshiftClusterVpcSecurityGroup(input?: s.AwsRedshiftClusterVpcSecurityGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
    VpcSecurityGroupId: input["VpcSecurityGroupId"],
  }
}
function toAwsRedshiftClusterVpcSecurityGroup(root: jsonP.JSONValue): s.AwsRedshiftClusterVpcSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": "s",
      "VpcSecurityGroupId": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerDetails(input?: s.AwsElbLoadBalancerDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZones: input["AvailabilityZones"],
    BackendServerDescriptions: input["BackendServerDescriptions"]?.map(x => fromAwsElbLoadBalancerBackendServerDescription(x)),
    CanonicalHostedZoneName: input["CanonicalHostedZoneName"],
    CanonicalHostedZoneNameID: input["CanonicalHostedZoneNameID"],
    CreatedTime: input["CreatedTime"],
    DnsName: input["DnsName"],
    HealthCheck: fromAwsElbLoadBalancerHealthCheck(input["HealthCheck"]),
    Instances: input["Instances"]?.map(x => fromAwsElbLoadBalancerInstance(x)),
    ListenerDescriptions: input["ListenerDescriptions"]?.map(x => fromAwsElbLoadBalancerListenerDescription(x)),
    LoadBalancerAttributes: fromAwsElbLoadBalancerAttributes(input["LoadBalancerAttributes"]),
    LoadBalancerName: input["LoadBalancerName"],
    Policies: fromAwsElbLoadBalancerPolicies(input["Policies"]),
    Scheme: input["Scheme"],
    SecurityGroups: input["SecurityGroups"],
    SourceSecurityGroup: fromAwsElbLoadBalancerSourceSecurityGroup(input["SourceSecurityGroup"]),
    Subnets: input["Subnets"],
    VpcId: input["VpcId"],
  }
}
function toAwsElbLoadBalancerDetails(root: jsonP.JSONValue): s.AwsElbLoadBalancerDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZones": ["s"],
      "BackendServerDescriptions": [toAwsElbLoadBalancerBackendServerDescription],
      "CanonicalHostedZoneName": "s",
      "CanonicalHostedZoneNameID": "s",
      "CreatedTime": "s",
      "DnsName": "s",
      "HealthCheck": toAwsElbLoadBalancerHealthCheck,
      "Instances": [toAwsElbLoadBalancerInstance],
      "ListenerDescriptions": [toAwsElbLoadBalancerListenerDescription],
      "LoadBalancerAttributes": toAwsElbLoadBalancerAttributes,
      "LoadBalancerName": "s",
      "Policies": toAwsElbLoadBalancerPolicies,
      "Scheme": "s",
      "SecurityGroups": ["s"],
      "SourceSecurityGroup": toAwsElbLoadBalancerSourceSecurityGroup,
      "Subnets": ["s"],
      "VpcId": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerBackendServerDescription(input?: s.AwsElbLoadBalancerBackendServerDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstancePort: input["InstancePort"],
    PolicyNames: input["PolicyNames"],
  }
}
function toAwsElbLoadBalancerBackendServerDescription(root: jsonP.JSONValue): s.AwsElbLoadBalancerBackendServerDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstancePort": "n",
      "PolicyNames": ["s"],
    },
  }, root);
}

function fromAwsElbLoadBalancerHealthCheck(input?: s.AwsElbLoadBalancerHealthCheck | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HealthyThreshold: input["HealthyThreshold"],
    Interval: input["Interval"],
    Target: input["Target"],
    Timeout: input["Timeout"],
    UnhealthyThreshold: input["UnhealthyThreshold"],
  }
}
function toAwsElbLoadBalancerHealthCheck(root: jsonP.JSONValue): s.AwsElbLoadBalancerHealthCheck {
  return jsonP.readObj({
    required: {},
    optional: {
      "HealthyThreshold": "n",
      "Interval": "n",
      "Target": "s",
      "Timeout": "n",
      "UnhealthyThreshold": "n",
    },
  }, root);
}

function fromAwsElbLoadBalancerInstance(input?: s.AwsElbLoadBalancerInstance | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceId: input["InstanceId"],
  }
}
function toAwsElbLoadBalancerInstance(root: jsonP.JSONValue): s.AwsElbLoadBalancerInstance {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstanceId": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerListenerDescription(input?: s.AwsElbLoadBalancerListenerDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Listener: fromAwsElbLoadBalancerListener(input["Listener"]),
    PolicyNames: input["PolicyNames"],
  }
}
function toAwsElbLoadBalancerListenerDescription(root: jsonP.JSONValue): s.AwsElbLoadBalancerListenerDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Listener": toAwsElbLoadBalancerListener,
      "PolicyNames": ["s"],
    },
  }, root);
}

function fromAwsElbLoadBalancerListener(input?: s.AwsElbLoadBalancerListener | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstancePort: input["InstancePort"],
    InstanceProtocol: input["InstanceProtocol"],
    LoadBalancerPort: input["LoadBalancerPort"],
    Protocol: input["Protocol"],
    SslCertificateId: input["SslCertificateId"],
  }
}
function toAwsElbLoadBalancerListener(root: jsonP.JSONValue): s.AwsElbLoadBalancerListener {
  return jsonP.readObj({
    required: {},
    optional: {
      "InstancePort": "n",
      "InstanceProtocol": "s",
      "LoadBalancerPort": "n",
      "Protocol": "s",
      "SslCertificateId": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerAttributes(input?: s.AwsElbLoadBalancerAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccessLog: fromAwsElbLoadBalancerAccessLog(input["AccessLog"]),
    ConnectionDraining: fromAwsElbLoadBalancerConnectionDraining(input["ConnectionDraining"]),
    ConnectionSettings: fromAwsElbLoadBalancerConnectionSettings(input["ConnectionSettings"]),
    CrossZoneLoadBalancing: fromAwsElbLoadBalancerCrossZoneLoadBalancing(input["CrossZoneLoadBalancing"]),
  }
}
function toAwsElbLoadBalancerAttributes(root: jsonP.JSONValue): s.AwsElbLoadBalancerAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccessLog": toAwsElbLoadBalancerAccessLog,
      "ConnectionDraining": toAwsElbLoadBalancerConnectionDraining,
      "ConnectionSettings": toAwsElbLoadBalancerConnectionSettings,
      "CrossZoneLoadBalancing": toAwsElbLoadBalancerCrossZoneLoadBalancing,
    },
  }, root);
}

function fromAwsElbLoadBalancerAccessLog(input?: s.AwsElbLoadBalancerAccessLog | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EmitInterval: input["EmitInterval"],
    Enabled: input["Enabled"],
    S3BucketName: input["S3BucketName"],
    S3BucketPrefix: input["S3BucketPrefix"],
  }
}
function toAwsElbLoadBalancerAccessLog(root: jsonP.JSONValue): s.AwsElbLoadBalancerAccessLog {
  return jsonP.readObj({
    required: {},
    optional: {
      "EmitInterval": "n",
      "Enabled": "b",
      "S3BucketName": "s",
      "S3BucketPrefix": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerConnectionDraining(input?: s.AwsElbLoadBalancerConnectionDraining | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    Timeout: input["Timeout"],
  }
}
function toAwsElbLoadBalancerConnectionDraining(root: jsonP.JSONValue): s.AwsElbLoadBalancerConnectionDraining {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
      "Timeout": "n",
    },
  }, root);
}

function fromAwsElbLoadBalancerConnectionSettings(input?: s.AwsElbLoadBalancerConnectionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IdleTimeout: input["IdleTimeout"],
  }
}
function toAwsElbLoadBalancerConnectionSettings(root: jsonP.JSONValue): s.AwsElbLoadBalancerConnectionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "IdleTimeout": "n",
    },
  }, root);
}

function fromAwsElbLoadBalancerCrossZoneLoadBalancing(input?: s.AwsElbLoadBalancerCrossZoneLoadBalancing | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}
function toAwsElbLoadBalancerCrossZoneLoadBalancing(root: jsonP.JSONValue): s.AwsElbLoadBalancerCrossZoneLoadBalancing {
  return jsonP.readObj({
    required: {},
    optional: {
      "Enabled": "b",
    },
  }, root);
}

function fromAwsElbLoadBalancerPolicies(input?: s.AwsElbLoadBalancerPolicies | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AppCookieStickinessPolicies: input["AppCookieStickinessPolicies"]?.map(x => fromAwsElbAppCookieStickinessPolicy(x)),
    LbCookieStickinessPolicies: input["LbCookieStickinessPolicies"]?.map(x => fromAwsElbLbCookieStickinessPolicy(x)),
    OtherPolicies: input["OtherPolicies"],
  }
}
function toAwsElbLoadBalancerPolicies(root: jsonP.JSONValue): s.AwsElbLoadBalancerPolicies {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppCookieStickinessPolicies": [toAwsElbAppCookieStickinessPolicy],
      "LbCookieStickinessPolicies": [toAwsElbLbCookieStickinessPolicy],
      "OtherPolicies": ["s"],
    },
  }, root);
}

function fromAwsElbAppCookieStickinessPolicy(input?: s.AwsElbAppCookieStickinessPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CookieName: input["CookieName"],
    PolicyName: input["PolicyName"],
  }
}
function toAwsElbAppCookieStickinessPolicy(root: jsonP.JSONValue): s.AwsElbAppCookieStickinessPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "CookieName": "s",
      "PolicyName": "s",
    },
  }, root);
}

function fromAwsElbLbCookieStickinessPolicy(input?: s.AwsElbLbCookieStickinessPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CookieExpirationPeriod: input["CookieExpirationPeriod"],
    PolicyName: input["PolicyName"],
  }
}
function toAwsElbLbCookieStickinessPolicy(root: jsonP.JSONValue): s.AwsElbLbCookieStickinessPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "CookieExpirationPeriod": "n",
      "PolicyName": "s",
    },
  }, root);
}

function fromAwsElbLoadBalancerSourceSecurityGroup(input?: s.AwsElbLoadBalancerSourceSecurityGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    GroupName: input["GroupName"],
    OwnerAlias: input["OwnerAlias"],
  }
}
function toAwsElbLoadBalancerSourceSecurityGroup(root: jsonP.JSONValue): s.AwsElbLoadBalancerSourceSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "GroupName": "s",
      "OwnerAlias": "s",
    },
  }, root);
}

function fromAwsIamGroupDetails(input?: s.AwsIamGroupDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttachedManagedPolicies: input["AttachedManagedPolicies"]?.map(x => fromAwsIamAttachedManagedPolicy(x)),
    CreateDate: input["CreateDate"],
    GroupId: input["GroupId"],
    GroupName: input["GroupName"],
    GroupPolicyList: input["GroupPolicyList"]?.map(x => fromAwsIamGroupPolicy(x)),
    Path: input["Path"],
  }
}
function toAwsIamGroupDetails(root: jsonP.JSONValue): s.AwsIamGroupDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttachedManagedPolicies": [toAwsIamAttachedManagedPolicy],
      "CreateDate": "s",
      "GroupId": "s",
      "GroupName": "s",
      "GroupPolicyList": [toAwsIamGroupPolicy],
      "Path": "s",
    },
  }, root);
}

function fromAwsIamGroupPolicy(input?: s.AwsIamGroupPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
  }
}
function toAwsIamGroupPolicy(root: jsonP.JSONValue): s.AwsIamGroupPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
    },
  }, root);
}

function fromAwsIamRoleDetails(input?: s.AwsIamRoleDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AssumeRolePolicyDocument: input["AssumeRolePolicyDocument"],
    AttachedManagedPolicies: input["AttachedManagedPolicies"]?.map(x => fromAwsIamAttachedManagedPolicy(x)),
    CreateDate: input["CreateDate"],
    InstanceProfileList: input["InstanceProfileList"]?.map(x => fromAwsIamInstanceProfile(x)),
    PermissionsBoundary: fromAwsIamPermissionsBoundary(input["PermissionsBoundary"]),
    RoleId: input["RoleId"],
    RoleName: input["RoleName"],
    RolePolicyList: input["RolePolicyList"]?.map(x => fromAwsIamRolePolicy(x)),
    MaxSessionDuration: input["MaxSessionDuration"],
    Path: input["Path"],
  }
}
function toAwsIamRoleDetails(root: jsonP.JSONValue): s.AwsIamRoleDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssumeRolePolicyDocument": "s",
      "AttachedManagedPolicies": [toAwsIamAttachedManagedPolicy],
      "CreateDate": "s",
      "InstanceProfileList": [toAwsIamInstanceProfile],
      "PermissionsBoundary": toAwsIamPermissionsBoundary,
      "RoleId": "s",
      "RoleName": "s",
      "RolePolicyList": [toAwsIamRolePolicy],
      "MaxSessionDuration": "n",
      "Path": "s",
    },
  }, root);
}

function fromAwsIamInstanceProfile(input?: s.AwsIamInstanceProfile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    CreateDate: input["CreateDate"],
    InstanceProfileId: input["InstanceProfileId"],
    InstanceProfileName: input["InstanceProfileName"],
    Path: input["Path"],
    Roles: input["Roles"]?.map(x => fromAwsIamInstanceProfileRole(x)),
  }
}
function toAwsIamInstanceProfile(root: jsonP.JSONValue): s.AwsIamInstanceProfile {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CreateDate": "s",
      "InstanceProfileId": "s",
      "InstanceProfileName": "s",
      "Path": "s",
      "Roles": [toAwsIamInstanceProfileRole],
    },
  }, root);
}

function fromAwsIamInstanceProfileRole(input?: s.AwsIamInstanceProfileRole | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    AssumeRolePolicyDocument: input["AssumeRolePolicyDocument"],
    CreateDate: input["CreateDate"],
    Path: input["Path"],
    RoleId: input["RoleId"],
    RoleName: input["RoleName"],
  }
}
function toAwsIamInstanceProfileRole(root: jsonP.JSONValue): s.AwsIamInstanceProfileRole {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AssumeRolePolicyDocument": "s",
      "CreateDate": "s",
      "Path": "s",
      "RoleId": "s",
      "RoleName": "s",
    },
  }, root);
}

function fromAwsIamRolePolicy(input?: s.AwsIamRolePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PolicyName: input["PolicyName"],
  }
}
function toAwsIamRolePolicy(root: jsonP.JSONValue): s.AwsIamRolePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyName": "s",
    },
  }, root);
}

function fromAwsKmsKeyDetails(input?: s.AwsKmsKeyDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AWSAccountId: input["AWSAccountId"],
    CreationDate: input["CreationDate"],
    KeyId: input["KeyId"],
    KeyManager: input["KeyManager"],
    KeyState: input["KeyState"],
    Origin: input["Origin"],
    Description: input["Description"],
  }
}
function toAwsKmsKeyDetails(root: jsonP.JSONValue): s.AwsKmsKeyDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AWSAccountId": "s",
      "CreationDate": "n",
      "KeyId": "s",
      "KeyManager": "s",
      "KeyState": "s",
      "Origin": "s",
      "Description": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionDetails(input?: s.AwsLambdaFunctionDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Code: fromAwsLambdaFunctionCode(input["Code"]),
    CodeSha256: input["CodeSha256"],
    DeadLetterConfig: fromAwsLambdaFunctionDeadLetterConfig(input["DeadLetterConfig"]),
    Environment: fromAwsLambdaFunctionEnvironment(input["Environment"]),
    FunctionName: input["FunctionName"],
    Handler: input["Handler"],
    KmsKeyArn: input["KmsKeyArn"],
    LastModified: input["LastModified"],
    Layers: input["Layers"]?.map(x => fromAwsLambdaFunctionLayer(x)),
    MasterArn: input["MasterArn"],
    MemorySize: input["MemorySize"],
    RevisionId: input["RevisionId"],
    Role: input["Role"],
    Runtime: input["Runtime"],
    Timeout: input["Timeout"],
    TracingConfig: fromAwsLambdaFunctionTracingConfig(input["TracingConfig"]),
    VpcConfig: fromAwsLambdaFunctionVpcConfig(input["VpcConfig"]),
    Version: input["Version"],
  }
}
function toAwsLambdaFunctionDetails(root: jsonP.JSONValue): s.AwsLambdaFunctionDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": toAwsLambdaFunctionCode,
      "CodeSha256": "s",
      "DeadLetterConfig": toAwsLambdaFunctionDeadLetterConfig,
      "Environment": toAwsLambdaFunctionEnvironment,
      "FunctionName": "s",
      "Handler": "s",
      "KmsKeyArn": "s",
      "LastModified": "s",
      "Layers": [toAwsLambdaFunctionLayer],
      "MasterArn": "s",
      "MemorySize": "n",
      "RevisionId": "s",
      "Role": "s",
      "Runtime": "s",
      "Timeout": "n",
      "TracingConfig": toAwsLambdaFunctionTracingConfig,
      "VpcConfig": toAwsLambdaFunctionVpcConfig,
      "Version": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionCode(input?: s.AwsLambdaFunctionCode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Bucket: input["S3Bucket"],
    S3Key: input["S3Key"],
    S3ObjectVersion: input["S3ObjectVersion"],
    ZipFile: input["ZipFile"],
  }
}
function toAwsLambdaFunctionCode(root: jsonP.JSONValue): s.AwsLambdaFunctionCode {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Bucket": "s",
      "S3Key": "s",
      "S3ObjectVersion": "s",
      "ZipFile": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionDeadLetterConfig(input?: s.AwsLambdaFunctionDeadLetterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetArn: input["TargetArn"],
  }
}
function toAwsLambdaFunctionDeadLetterConfig(root: jsonP.JSONValue): s.AwsLambdaFunctionDeadLetterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetArn": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionEnvironment(input?: s.AwsLambdaFunctionEnvironment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Variables: input["Variables"],
    Error: fromAwsLambdaFunctionEnvironmentError(input["Error"]),
  }
}
function toAwsLambdaFunctionEnvironment(root: jsonP.JSONValue): s.AwsLambdaFunctionEnvironment {
  return jsonP.readObj({
    required: {},
    optional: {
      "Variables": x => jsonP.readMap(String, String, x),
      "Error": toAwsLambdaFunctionEnvironmentError,
    },
  }, root);
}

function fromAwsLambdaFunctionEnvironmentError(input?: s.AwsLambdaFunctionEnvironmentError | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ErrorCode: input["ErrorCode"],
    Message: input["Message"],
  }
}
function toAwsLambdaFunctionEnvironmentError(root: jsonP.JSONValue): s.AwsLambdaFunctionEnvironmentError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionLayer(input?: s.AwsLambdaFunctionLayer | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    CodeSize: input["CodeSize"],
  }
}
function toAwsLambdaFunctionLayer(root: jsonP.JSONValue): s.AwsLambdaFunctionLayer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CodeSize": "n",
    },
  }, root);
}

function fromAwsLambdaFunctionTracingConfig(input?: s.AwsLambdaFunctionTracingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Mode: input["Mode"],
  }
}
function toAwsLambdaFunctionTracingConfig(root: jsonP.JSONValue): s.AwsLambdaFunctionTracingConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Mode": "s",
    },
  }, root);
}

function fromAwsLambdaFunctionVpcConfig(input?: s.AwsLambdaFunctionVpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecurityGroupIds: input["SecurityGroupIds"],
    SubnetIds: input["SubnetIds"],
    VpcId: input["VpcId"],
  }
}
function toAwsLambdaFunctionVpcConfig(root: jsonP.JSONValue): s.AwsLambdaFunctionVpcConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "SecurityGroupIds": ["s"],
      "SubnetIds": ["s"],
      "VpcId": "s",
    },
  }, root);
}

function fromAwsLambdaLayerVersionDetails(input?: s.AwsLambdaLayerVersionDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Version: input["Version"],
    CompatibleRuntimes: input["CompatibleRuntimes"],
    CreatedDate: input["CreatedDate"],
  }
}
function toAwsLambdaLayerVersionDetails(root: jsonP.JSONValue): s.AwsLambdaLayerVersionDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "n",
      "CompatibleRuntimes": ["s"],
      "CreatedDate": "s",
    },
  }, root);
}

function fromAwsRdsDbInstanceDetails(input?: s.AwsRdsDbInstanceDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AssociatedRoles: input["AssociatedRoles"]?.map(x => fromAwsRdsDbInstanceAssociatedRole(x)),
    CACertificateIdentifier: input["CACertificateIdentifier"],
    DBClusterIdentifier: input["DBClusterIdentifier"],
    DBInstanceIdentifier: input["DBInstanceIdentifier"],
    DBInstanceClass: input["DBInstanceClass"],
    DbInstancePort: input["DbInstancePort"],
    DbiResourceId: input["DbiResourceId"],
    DBName: input["DBName"],
    DeletionProtection: input["DeletionProtection"],
    Endpoint: fromAwsRdsDbInstanceEndpoint(input["Endpoint"]),
    Engine: input["Engine"],
    EngineVersion: input["EngineVersion"],
    IAMDatabaseAuthenticationEnabled: input["IAMDatabaseAuthenticationEnabled"],
    InstanceCreateTime: input["InstanceCreateTime"],
    KmsKeyId: input["KmsKeyId"],
    PubliclyAccessible: input["PubliclyAccessible"],
    StorageEncrypted: input["StorageEncrypted"],
    TdeCredentialArn: input["TdeCredentialArn"],
    VpcSecurityGroups: input["VpcSecurityGroups"]?.map(x => fromAwsRdsDbInstanceVpcSecurityGroup(x)),
    MultiAz: input["MultiAz"],
    EnhancedMonitoringResourceArn: input["EnhancedMonitoringResourceArn"],
    DbInstanceStatus: input["DbInstanceStatus"],
    MasterUsername: input["MasterUsername"],
    AllocatedStorage: input["AllocatedStorage"],
    PreferredBackupWindow: input["PreferredBackupWindow"],
    BackupRetentionPeriod: input["BackupRetentionPeriod"],
    DbSecurityGroups: input["DbSecurityGroups"],
    DbParameterGroups: input["DbParameterGroups"]?.map(x => fromAwsRdsDbParameterGroup(x)),
    AvailabilityZone: input["AvailabilityZone"],
    DbSubnetGroup: fromAwsRdsDbSubnetGroup(input["DbSubnetGroup"]),
    PreferredMaintenanceWindow: input["PreferredMaintenanceWindow"],
    PendingModifiedValues: fromAwsRdsDbPendingModifiedValues(input["PendingModifiedValues"]),
    LatestRestorableTime: input["LatestRestorableTime"],
    AutoMinorVersionUpgrade: input["AutoMinorVersionUpgrade"],
    ReadReplicaSourceDBInstanceIdentifier: input["ReadReplicaSourceDBInstanceIdentifier"],
    ReadReplicaDBInstanceIdentifiers: input["ReadReplicaDBInstanceIdentifiers"],
    ReadReplicaDBClusterIdentifiers: input["ReadReplicaDBClusterIdentifiers"],
    LicenseModel: input["LicenseModel"],
    Iops: input["Iops"],
    OptionGroupMemberships: input["OptionGroupMemberships"]?.map(x => fromAwsRdsDbOptionGroupMembership(x)),
    CharacterSetName: input["CharacterSetName"],
    SecondaryAvailabilityZone: input["SecondaryAvailabilityZone"],
    StatusInfos: input["StatusInfos"]?.map(x => fromAwsRdsDbStatusInfo(x)),
    StorageType: input["StorageType"],
    DomainMemberships: input["DomainMemberships"]?.map(x => fromAwsRdsDbDomainMembership(x)),
    CopyTagsToSnapshot: input["CopyTagsToSnapshot"],
    MonitoringInterval: input["MonitoringInterval"],
    MonitoringRoleArn: input["MonitoringRoleArn"],
    PromotionTier: input["PromotionTier"],
    Timezone: input["Timezone"],
    PerformanceInsightsEnabled: input["PerformanceInsightsEnabled"],
    PerformanceInsightsKmsKeyId: input["PerformanceInsightsKmsKeyId"],
    PerformanceInsightsRetentionPeriod: input["PerformanceInsightsRetentionPeriod"],
    EnabledCloudWatchLogsExports: input["EnabledCloudWatchLogsExports"],
    ProcessorFeatures: input["ProcessorFeatures"]?.map(x => fromAwsRdsDbProcessorFeature(x)),
    ListenerEndpoint: fromAwsRdsDbInstanceEndpoint(input["ListenerEndpoint"]),
    MaxAllocatedStorage: input["MaxAllocatedStorage"],
  }
}
function toAwsRdsDbInstanceDetails(root: jsonP.JSONValue): s.AwsRdsDbInstanceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AssociatedRoles": [toAwsRdsDbInstanceAssociatedRole],
      "CACertificateIdentifier": "s",
      "DBClusterIdentifier": "s",
      "DBInstanceIdentifier": "s",
      "DBInstanceClass": "s",
      "DbInstancePort": "n",
      "DbiResourceId": "s",
      "DBName": "s",
      "DeletionProtection": "b",
      "Endpoint": toAwsRdsDbInstanceEndpoint,
      "Engine": "s",
      "EngineVersion": "s",
      "IAMDatabaseAuthenticationEnabled": "b",
      "InstanceCreateTime": "s",
      "KmsKeyId": "s",
      "PubliclyAccessible": "b",
      "StorageEncrypted": "b",
      "TdeCredentialArn": "s",
      "VpcSecurityGroups": [toAwsRdsDbInstanceVpcSecurityGroup],
      "MultiAz": "b",
      "EnhancedMonitoringResourceArn": "s",
      "DbInstanceStatus": "s",
      "MasterUsername": "s",
      "AllocatedStorage": "n",
      "PreferredBackupWindow": "s",
      "BackupRetentionPeriod": "n",
      "DbSecurityGroups": ["s"],
      "DbParameterGroups": [toAwsRdsDbParameterGroup],
      "AvailabilityZone": "s",
      "DbSubnetGroup": toAwsRdsDbSubnetGroup,
      "PreferredMaintenanceWindow": "s",
      "PendingModifiedValues": toAwsRdsDbPendingModifiedValues,
      "LatestRestorableTime": "s",
      "AutoMinorVersionUpgrade": "b",
      "ReadReplicaSourceDBInstanceIdentifier": "s",
      "ReadReplicaDBInstanceIdentifiers": ["s"],
      "ReadReplicaDBClusterIdentifiers": ["s"],
      "LicenseModel": "s",
      "Iops": "n",
      "OptionGroupMemberships": [toAwsRdsDbOptionGroupMembership],
      "CharacterSetName": "s",
      "SecondaryAvailabilityZone": "s",
      "StatusInfos": [toAwsRdsDbStatusInfo],
      "StorageType": "s",
      "DomainMemberships": [toAwsRdsDbDomainMembership],
      "CopyTagsToSnapshot": "b",
      "MonitoringInterval": "n",
      "MonitoringRoleArn": "s",
      "PromotionTier": "n",
      "Timezone": "s",
      "PerformanceInsightsEnabled": "b",
      "PerformanceInsightsKmsKeyId": "s",
      "PerformanceInsightsRetentionPeriod": "n",
      "EnabledCloudWatchLogsExports": ["s"],
      "ProcessorFeatures": [toAwsRdsDbProcessorFeature],
      "ListenerEndpoint": toAwsRdsDbInstanceEndpoint,
      "MaxAllocatedStorage": "n",
    },
  }, root);
}

function fromAwsRdsDbInstanceAssociatedRole(input?: s.AwsRdsDbInstanceAssociatedRole | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleArn: input["RoleArn"],
    FeatureName: input["FeatureName"],
    Status: input["Status"],
  }
}
function toAwsRdsDbInstanceAssociatedRole(root: jsonP.JSONValue): s.AwsRdsDbInstanceAssociatedRole {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleArn": "s",
      "FeatureName": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRdsDbInstanceEndpoint(input?: s.AwsRdsDbInstanceEndpoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Port: input["Port"],
    HostedZoneId: input["HostedZoneId"],
  }
}
function toAwsRdsDbInstanceEndpoint(root: jsonP.JSONValue): s.AwsRdsDbInstanceEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "Port": "n",
      "HostedZoneId": "s",
    },
  }, root);
}

function fromAwsRdsDbInstanceVpcSecurityGroup(input?: s.AwsRdsDbInstanceVpcSecurityGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VpcSecurityGroupId: input["VpcSecurityGroupId"],
    Status: input["Status"],
  }
}
function toAwsRdsDbInstanceVpcSecurityGroup(root: jsonP.JSONValue): s.AwsRdsDbInstanceVpcSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "VpcSecurityGroupId": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRdsDbParameterGroup(input?: s.AwsRdsDbParameterGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DbParameterGroupName: input["DbParameterGroupName"],
    ParameterApplyStatus: input["ParameterApplyStatus"],
  }
}
function toAwsRdsDbParameterGroup(root: jsonP.JSONValue): s.AwsRdsDbParameterGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "DbParameterGroupName": "s",
      "ParameterApplyStatus": "s",
    },
  }, root);
}

function fromAwsRdsDbSubnetGroup(input?: s.AwsRdsDbSubnetGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DbSubnetGroupName: input["DbSubnetGroupName"],
    DbSubnetGroupDescription: input["DbSubnetGroupDescription"],
    VpcId: input["VpcId"],
    SubnetGroupStatus: input["SubnetGroupStatus"],
    Subnets: input["Subnets"]?.map(x => fromAwsRdsDbSubnetGroupSubnet(x)),
    DbSubnetGroupArn: input["DbSubnetGroupArn"],
  }
}
function toAwsRdsDbSubnetGroup(root: jsonP.JSONValue): s.AwsRdsDbSubnetGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "DbSubnetGroupName": "s",
      "DbSubnetGroupDescription": "s",
      "VpcId": "s",
      "SubnetGroupStatus": "s",
      "Subnets": [toAwsRdsDbSubnetGroupSubnet],
      "DbSubnetGroupArn": "s",
    },
  }, root);
}

function fromAwsRdsDbSubnetGroupSubnet(input?: s.AwsRdsDbSubnetGroupSubnet | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIdentifier: input["SubnetIdentifier"],
    SubnetAvailabilityZone: fromAwsRdsDbSubnetGroupSubnetAvailabilityZone(input["SubnetAvailabilityZone"]),
    SubnetStatus: input["SubnetStatus"],
  }
}
function toAwsRdsDbSubnetGroupSubnet(root: jsonP.JSONValue): s.AwsRdsDbSubnetGroupSubnet {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIdentifier": "s",
      "SubnetAvailabilityZone": toAwsRdsDbSubnetGroupSubnetAvailabilityZone,
      "SubnetStatus": "s",
    },
  }, root);
}

function fromAwsRdsDbSubnetGroupSubnetAvailabilityZone(input?: s.AwsRdsDbSubnetGroupSubnetAvailabilityZone | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
  }
}
function toAwsRdsDbSubnetGroupSubnetAvailabilityZone(root: jsonP.JSONValue): s.AwsRdsDbSubnetGroupSubnetAvailabilityZone {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
    },
  }, root);
}

function fromAwsRdsDbPendingModifiedValues(input?: s.AwsRdsDbPendingModifiedValues | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DbInstanceClass: input["DbInstanceClass"],
    AllocatedStorage: input["AllocatedStorage"],
    MasterUserPassword: input["MasterUserPassword"],
    Port: input["Port"],
    BackupRetentionPeriod: input["BackupRetentionPeriod"],
    MultiAZ: input["MultiAZ"],
    EngineVersion: input["EngineVersion"],
    LicenseModel: input["LicenseModel"],
    Iops: input["Iops"],
    DbInstanceIdentifier: input["DbInstanceIdentifier"],
    StorageType: input["StorageType"],
    CaCertificateIdentifier: input["CaCertificateIdentifier"],
    DbSubnetGroupName: input["DbSubnetGroupName"],
    PendingCloudWatchLogsExports: fromAwsRdsPendingCloudWatchLogsExports(input["PendingCloudWatchLogsExports"]),
    ProcessorFeatures: input["ProcessorFeatures"]?.map(x => fromAwsRdsDbProcessorFeature(x)),
  }
}
function toAwsRdsDbPendingModifiedValues(root: jsonP.JSONValue): s.AwsRdsDbPendingModifiedValues {
  return jsonP.readObj({
    required: {},
    optional: {
      "DbInstanceClass": "s",
      "AllocatedStorage": "n",
      "MasterUserPassword": "s",
      "Port": "n",
      "BackupRetentionPeriod": "n",
      "MultiAZ": "b",
      "EngineVersion": "s",
      "LicenseModel": "s",
      "Iops": "n",
      "DbInstanceIdentifier": "s",
      "StorageType": "s",
      "CaCertificateIdentifier": "s",
      "DbSubnetGroupName": "s",
      "PendingCloudWatchLogsExports": toAwsRdsPendingCloudWatchLogsExports,
      "ProcessorFeatures": [toAwsRdsDbProcessorFeature],
    },
  }, root);
}

function fromAwsRdsPendingCloudWatchLogsExports(input?: s.AwsRdsPendingCloudWatchLogsExports | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogTypesToEnable: input["LogTypesToEnable"],
    LogTypesToDisable: input["LogTypesToDisable"],
  }
}
function toAwsRdsPendingCloudWatchLogsExports(root: jsonP.JSONValue): s.AwsRdsPendingCloudWatchLogsExports {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogTypesToEnable": ["s"],
      "LogTypesToDisable": ["s"],
    },
  }, root);
}

function fromAwsRdsDbProcessorFeature(input?: s.AwsRdsDbProcessorFeature | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toAwsRdsDbProcessorFeature(root: jsonP.JSONValue): s.AwsRdsDbProcessorFeature {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Value": "s",
    },
  }, root);
}

function fromAwsRdsDbOptionGroupMembership(input?: s.AwsRdsDbOptionGroupMembership | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OptionGroupName: input["OptionGroupName"],
    Status: input["Status"],
  }
}
function toAwsRdsDbOptionGroupMembership(root: jsonP.JSONValue): s.AwsRdsDbOptionGroupMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "OptionGroupName": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRdsDbStatusInfo(input?: s.AwsRdsDbStatusInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StatusType: input["StatusType"],
    Normal: input["Normal"],
    Status: input["Status"],
    Message: input["Message"],
  }
}
function toAwsRdsDbStatusInfo(root: jsonP.JSONValue): s.AwsRdsDbStatusInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "StatusType": "s",
      "Normal": "b",
      "Status": "s",
      "Message": "s",
    },
  }, root);
}

function fromAwsRdsDbDomainMembership(input?: s.AwsRdsDbDomainMembership | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Domain: input["Domain"],
    Status: input["Status"],
    Fqdn: input["Fqdn"],
    IamRoleName: input["IamRoleName"],
  }
}
function toAwsRdsDbDomainMembership(root: jsonP.JSONValue): s.AwsRdsDbDomainMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "Domain": "s",
      "Status": "s",
      "Fqdn": "s",
      "IamRoleName": "s",
    },
  }, root);
}

function fromAwsSnsTopicDetails(input?: s.AwsSnsTopicDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsMasterKeyId: input["KmsMasterKeyId"],
    Subscription: input["Subscription"]?.map(x => fromAwsSnsTopicSubscription(x)),
    TopicName: input["TopicName"],
    Owner: input["Owner"],
  }
}
function toAwsSnsTopicDetails(root: jsonP.JSONValue): s.AwsSnsTopicDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "KmsMasterKeyId": "s",
      "Subscription": [toAwsSnsTopicSubscription],
      "TopicName": "s",
      "Owner": "s",
    },
  }, root);
}

function fromAwsSnsTopicSubscription(input?: s.AwsSnsTopicSubscription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Endpoint: input["Endpoint"],
    Protocol: input["Protocol"],
  }
}
function toAwsSnsTopicSubscription(root: jsonP.JSONValue): s.AwsSnsTopicSubscription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Endpoint": "s",
      "Protocol": "s",
    },
  }, root);
}

function fromAwsSqsQueueDetails(input?: s.AwsSqsQueueDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsDataKeyReusePeriodSeconds: input["KmsDataKeyReusePeriodSeconds"],
    KmsMasterKeyId: input["KmsMasterKeyId"],
    QueueName: input["QueueName"],
    DeadLetterTargetArn: input["DeadLetterTargetArn"],
  }
}
function toAwsSqsQueueDetails(root: jsonP.JSONValue): s.AwsSqsQueueDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "KmsDataKeyReusePeriodSeconds": "n",
      "KmsMasterKeyId": "s",
      "QueueName": "s",
      "DeadLetterTargetArn": "s",
    },
  }, root);
}

function fromAwsWafWebAclDetails(input?: s.AwsWafWebAclDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    DefaultAction: input["DefaultAction"],
    Rules: input["Rules"]?.map(x => fromAwsWafWebAclRule(x)),
    WebAclId: input["WebAclId"],
  }
}
function toAwsWafWebAclDetails(root: jsonP.JSONValue): s.AwsWafWebAclDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DefaultAction": "s",
      "Rules": [toAwsWafWebAclRule],
      "WebAclId": "s",
    },
  }, root);
}

function fromAwsWafWebAclRule(input?: s.AwsWafWebAclRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: fromWafAction(input["Action"]),
    ExcludedRules: input["ExcludedRules"]?.map(x => fromWafExcludedRule(x)),
    OverrideAction: fromWafOverrideAction(input["OverrideAction"]),
    Priority: input["Priority"],
    RuleId: input["RuleId"],
    Type: input["Type"],
  }
}
function toAwsWafWebAclRule(root: jsonP.JSONValue): s.AwsWafWebAclRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": toWafAction,
      "ExcludedRules": [toWafExcludedRule],
      "OverrideAction": toWafOverrideAction,
      "Priority": "n",
      "RuleId": "s",
      "Type": "s",
    },
  }, root);
}

function fromWafAction(input?: s.WafAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
  }
}
function toWafAction(root: jsonP.JSONValue): s.WafAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
    },
  }, root);
}

function fromWafExcludedRule(input?: s.WafExcludedRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleId: input["RuleId"],
  }
}
function toWafExcludedRule(root: jsonP.JSONValue): s.WafExcludedRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleId": "s",
    },
  }, root);
}

function fromWafOverrideAction(input?: s.WafOverrideAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
  }
}
function toWafOverrideAction(root: jsonP.JSONValue): s.WafOverrideAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": "s",
    },
  }, root);
}

function fromAwsRdsDbSnapshotDetails(input?: s.AwsRdsDbSnapshotDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DbSnapshotIdentifier: input["DbSnapshotIdentifier"],
    DbInstanceIdentifier: input["DbInstanceIdentifier"],
    SnapshotCreateTime: input["SnapshotCreateTime"],
    Engine: input["Engine"],
    AllocatedStorage: input["AllocatedStorage"],
    Status: input["Status"],
    Port: input["Port"],
    AvailabilityZone: input["AvailabilityZone"],
    VpcId: input["VpcId"],
    InstanceCreateTime: input["InstanceCreateTime"],
    MasterUsername: input["MasterUsername"],
    EngineVersion: input["EngineVersion"],
    LicenseModel: input["LicenseModel"],
    SnapshotType: input["SnapshotType"],
    Iops: input["Iops"],
    OptionGroupName: input["OptionGroupName"],
    PercentProgress: input["PercentProgress"],
    SourceRegion: input["SourceRegion"],
    SourceDbSnapshotIdentifier: input["SourceDbSnapshotIdentifier"],
    StorageType: input["StorageType"],
    TdeCredentialArn: input["TdeCredentialArn"],
    Encrypted: input["Encrypted"],
    KmsKeyId: input["KmsKeyId"],
    Timezone: input["Timezone"],
    IamDatabaseAuthenticationEnabled: input["IamDatabaseAuthenticationEnabled"],
    ProcessorFeatures: input["ProcessorFeatures"]?.map(x => fromAwsRdsDbProcessorFeature(x)),
    DbiResourceId: input["DbiResourceId"],
  }
}
function toAwsRdsDbSnapshotDetails(root: jsonP.JSONValue): s.AwsRdsDbSnapshotDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DbSnapshotIdentifier": "s",
      "DbInstanceIdentifier": "s",
      "SnapshotCreateTime": "s",
      "Engine": "s",
      "AllocatedStorage": "n",
      "Status": "s",
      "Port": "n",
      "AvailabilityZone": "s",
      "VpcId": "s",
      "InstanceCreateTime": "s",
      "MasterUsername": "s",
      "EngineVersion": "s",
      "LicenseModel": "s",
      "SnapshotType": "s",
      "Iops": "n",
      "OptionGroupName": "s",
      "PercentProgress": "n",
      "SourceRegion": "s",
      "SourceDbSnapshotIdentifier": "s",
      "StorageType": "s",
      "TdeCredentialArn": "s",
      "Encrypted": "b",
      "KmsKeyId": "s",
      "Timezone": "s",
      "IamDatabaseAuthenticationEnabled": "b",
      "ProcessorFeatures": [toAwsRdsDbProcessorFeature],
      "DbiResourceId": "s",
    },
  }, root);
}

function fromAwsRdsDbClusterSnapshotDetails(input?: s.AwsRdsDbClusterSnapshotDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AvailabilityZones: input["AvailabilityZones"],
    SnapshotCreateTime: input["SnapshotCreateTime"],
    Engine: input["Engine"],
    AllocatedStorage: input["AllocatedStorage"],
    Status: input["Status"],
    Port: input["Port"],
    VpcId: input["VpcId"],
    ClusterCreateTime: input["ClusterCreateTime"],
    MasterUsername: input["MasterUsername"],
    EngineVersion: input["EngineVersion"],
    LicenseModel: input["LicenseModel"],
    SnapshotType: input["SnapshotType"],
    PercentProgress: input["PercentProgress"],
    StorageEncrypted: input["StorageEncrypted"],
    KmsKeyId: input["KmsKeyId"],
    DbClusterIdentifier: input["DbClusterIdentifier"],
    DbClusterSnapshotIdentifier: input["DbClusterSnapshotIdentifier"],
    IamDatabaseAuthenticationEnabled: input["IamDatabaseAuthenticationEnabled"],
  }
}
function toAwsRdsDbClusterSnapshotDetails(root: jsonP.JSONValue): s.AwsRdsDbClusterSnapshotDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZones": ["s"],
      "SnapshotCreateTime": "s",
      "Engine": "s",
      "AllocatedStorage": "n",
      "Status": "s",
      "Port": "n",
      "VpcId": "s",
      "ClusterCreateTime": "s",
      "MasterUsername": "s",
      "EngineVersion": "s",
      "LicenseModel": "s",
      "SnapshotType": "s",
      "PercentProgress": "n",
      "StorageEncrypted": "b",
      "KmsKeyId": "s",
      "DbClusterIdentifier": "s",
      "DbClusterSnapshotIdentifier": "s",
      "IamDatabaseAuthenticationEnabled": "b",
    },
  }, root);
}

function fromAwsRdsDbClusterDetails(input?: s.AwsRdsDbClusterDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllocatedStorage: input["AllocatedStorage"],
    AvailabilityZones: input["AvailabilityZones"],
    BackupRetentionPeriod: input["BackupRetentionPeriod"],
    DatabaseName: input["DatabaseName"],
    Status: input["Status"],
    Endpoint: input["Endpoint"],
    ReaderEndpoint: input["ReaderEndpoint"],
    CustomEndpoints: input["CustomEndpoints"],
    MultiAz: input["MultiAz"],
    Engine: input["Engine"],
    EngineVersion: input["EngineVersion"],
    Port: input["Port"],
    MasterUsername: input["MasterUsername"],
    PreferredBackupWindow: input["PreferredBackupWindow"],
    PreferredMaintenanceWindow: input["PreferredMaintenanceWindow"],
    ReadReplicaIdentifiers: input["ReadReplicaIdentifiers"],
    VpcSecurityGroups: input["VpcSecurityGroups"]?.map(x => fromAwsRdsDbInstanceVpcSecurityGroup(x)),
    HostedZoneId: input["HostedZoneId"],
    StorageEncrypted: input["StorageEncrypted"],
    KmsKeyId: input["KmsKeyId"],
    DbClusterResourceId: input["DbClusterResourceId"],
    AssociatedRoles: input["AssociatedRoles"]?.map(x => fromAwsRdsDbClusterAssociatedRole(x)),
    ClusterCreateTime: input["ClusterCreateTime"],
    EnabledCloudWatchLogsExports: input["EnabledCloudWatchLogsExports"],
    EngineMode: input["EngineMode"],
    DeletionProtection: input["DeletionProtection"],
    HttpEndpointEnabled: input["HttpEndpointEnabled"],
    ActivityStreamStatus: input["ActivityStreamStatus"],
    CopyTagsToSnapshot: input["CopyTagsToSnapshot"],
    CrossAccountClone: input["CrossAccountClone"],
    DomainMemberships: input["DomainMemberships"]?.map(x => fromAwsRdsDbDomainMembership(x)),
    DbClusterParameterGroup: input["DbClusterParameterGroup"],
    DbSubnetGroup: input["DbSubnetGroup"],
    DbClusterOptionGroupMemberships: input["DbClusterOptionGroupMemberships"]?.map(x => fromAwsRdsDbClusterOptionGroupMembership(x)),
    DbClusterIdentifier: input["DbClusterIdentifier"],
    DbClusterMembers: input["DbClusterMembers"]?.map(x => fromAwsRdsDbClusterMember(x)),
    IamDatabaseAuthenticationEnabled: input["IamDatabaseAuthenticationEnabled"],
  }
}
function toAwsRdsDbClusterDetails(root: jsonP.JSONValue): s.AwsRdsDbClusterDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllocatedStorage": "n",
      "AvailabilityZones": ["s"],
      "BackupRetentionPeriod": "n",
      "DatabaseName": "s",
      "Status": "s",
      "Endpoint": "s",
      "ReaderEndpoint": "s",
      "CustomEndpoints": ["s"],
      "MultiAz": "b",
      "Engine": "s",
      "EngineVersion": "s",
      "Port": "n",
      "MasterUsername": "s",
      "PreferredBackupWindow": "s",
      "PreferredMaintenanceWindow": "s",
      "ReadReplicaIdentifiers": ["s"],
      "VpcSecurityGroups": [toAwsRdsDbInstanceVpcSecurityGroup],
      "HostedZoneId": "s",
      "StorageEncrypted": "b",
      "KmsKeyId": "s",
      "DbClusterResourceId": "s",
      "AssociatedRoles": [toAwsRdsDbClusterAssociatedRole],
      "ClusterCreateTime": "s",
      "EnabledCloudWatchLogsExports": ["s"],
      "EngineMode": "s",
      "DeletionProtection": "b",
      "HttpEndpointEnabled": "b",
      "ActivityStreamStatus": "s",
      "CopyTagsToSnapshot": "b",
      "CrossAccountClone": "b",
      "DomainMemberships": [toAwsRdsDbDomainMembership],
      "DbClusterParameterGroup": "s",
      "DbSubnetGroup": "s",
      "DbClusterOptionGroupMemberships": [toAwsRdsDbClusterOptionGroupMembership],
      "DbClusterIdentifier": "s",
      "DbClusterMembers": [toAwsRdsDbClusterMember],
      "IamDatabaseAuthenticationEnabled": "b",
    },
  }, root);
}

function fromAwsRdsDbClusterAssociatedRole(input?: s.AwsRdsDbClusterAssociatedRole | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleArn: input["RoleArn"],
    Status: input["Status"],
  }
}
function toAwsRdsDbClusterAssociatedRole(root: jsonP.JSONValue): s.AwsRdsDbClusterAssociatedRole {
  return jsonP.readObj({
    required: {},
    optional: {
      "RoleArn": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRdsDbClusterOptionGroupMembership(input?: s.AwsRdsDbClusterOptionGroupMembership | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DbClusterOptionGroupName: input["DbClusterOptionGroupName"],
    Status: input["Status"],
  }
}
function toAwsRdsDbClusterOptionGroupMembership(root: jsonP.JSONValue): s.AwsRdsDbClusterOptionGroupMembership {
  return jsonP.readObj({
    required: {},
    optional: {
      "DbClusterOptionGroupName": "s",
      "Status": "s",
    },
  }, root);
}

function fromAwsRdsDbClusterMember(input?: s.AwsRdsDbClusterMember | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IsClusterWriter: input["IsClusterWriter"],
    PromotionTier: input["PromotionTier"],
    DbInstanceIdentifier: input["DbInstanceIdentifier"],
    DbClusterParameterGroupStatus: input["DbClusterParameterGroupStatus"],
  }
}
function toAwsRdsDbClusterMember(root: jsonP.JSONValue): s.AwsRdsDbClusterMember {
  return jsonP.readObj({
    required: {},
    optional: {
      "IsClusterWriter": "b",
      "PromotionTier": "n",
      "DbInstanceIdentifier": "s",
      "DbClusterParameterGroupStatus": "s",
    },
  }, root);
}

function fromContainerDetails(input?: s.ContainerDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ImageId: input["ImageId"],
    ImageName: input["ImageName"],
    LaunchedAt: input["LaunchedAt"],
  }
}
function toContainerDetails(root: jsonP.JSONValue): s.ContainerDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ImageId": "s",
      "ImageName": "s",
      "LaunchedAt": "s",
    },
  }, root);
}

function fromCompliance(input?: s.Compliance | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
    RelatedRequirements: input["RelatedRequirements"],
    StatusReasons: input["StatusReasons"]?.map(x => fromStatusReason(x)),
  }
}
function toCompliance(root: jsonP.JSONValue): s.Compliance {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComplianceStatus>(x),
      "RelatedRequirements": ["s"],
      "StatusReasons": [toStatusReason],
    },
  }, root);
}

function fromStatusReason(input?: s.StatusReason | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReasonCode: input["ReasonCode"],
    Description: input["Description"],
  }
}
function toStatusReason(root: jsonP.JSONValue): s.StatusReason {
  return jsonP.readObj({
    required: {
      "ReasonCode": "s",
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

function fromWorkflow(input?: s.Workflow | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
  }
}
function toWorkflow(root: jsonP.JSONValue): s.Workflow {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowStatus>(x),
    },
  }, root);
}

function fromRelatedFinding(input?: s.RelatedFinding | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProductArn: input["ProductArn"],
    Id: input["Id"],
  }
}
function toRelatedFinding(root: jsonP.JSONValue): s.RelatedFinding {
  return jsonP.readObj({
    required: {
      "ProductArn": "s",
      "Id": "s",
    },
    optional: {},
  }, root);
}

function fromNote(input?: s.Note | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Text: input["Text"],
    UpdatedBy: input["UpdatedBy"],
    UpdatedAt: input["UpdatedAt"],
  }
}
function toNote(root: jsonP.JSONValue): s.Note {
  return jsonP.readObj({
    required: {
      "Text": "s",
      "UpdatedBy": "s",
      "UpdatedAt": "s",
    },
    optional: {},
  }, root);
}

function fromVulnerability(input?: s.Vulnerability | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    VulnerablePackages: input["VulnerablePackages"]?.map(x => fromSoftwarePackage(x)),
    Cvss: input["Cvss"]?.map(x => fromCvss(x)),
    RelatedVulnerabilities: input["RelatedVulnerabilities"],
    Vendor: fromVulnerabilityVendor(input["Vendor"]),
    ReferenceUrls: input["ReferenceUrls"],
  }
}
function toVulnerability(root: jsonP.JSONValue): s.Vulnerability {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "VulnerablePackages": [toSoftwarePackage],
      "Cvss": [toCvss],
      "RelatedVulnerabilities": ["s"],
      "Vendor": toVulnerabilityVendor,
      "ReferenceUrls": ["s"],
    },
  }, root);
}

function fromSoftwarePackage(input?: s.SoftwarePackage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
    Epoch: input["Epoch"],
    Release: input["Release"],
    Architecture: input["Architecture"],
  }
}
function toSoftwarePackage(root: jsonP.JSONValue): s.SoftwarePackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
      "Epoch": "s",
      "Release": "s",
      "Architecture": "s",
    },
  }, root);
}

function fromCvss(input?: s.Cvss | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Version: input["Version"],
    BaseScore: input["BaseScore"],
    BaseVector: input["BaseVector"],
  }
}
function toCvss(root: jsonP.JSONValue): s.Cvss {
  return jsonP.readObj({
    required: {},
    optional: {
      "Version": "s",
      "BaseScore": "n",
      "BaseVector": "s",
    },
  }, root);
}

function fromVulnerabilityVendor(input?: s.VulnerabilityVendor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Url: input["Url"],
    VendorSeverity: input["VendorSeverity"],
    VendorCreatedAt: input["VendorCreatedAt"],
    VendorUpdatedAt: input["VendorUpdatedAt"],
  }
}
function toVulnerabilityVendor(root: jsonP.JSONValue): s.VulnerabilityVendor {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Url": "s",
      "VendorSeverity": "s",
      "VendorCreatedAt": "s",
      "VendorUpdatedAt": "s",
    },
  }, root);
}

function fromPatchSummary(input?: s.PatchSummary | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    InstalledCount: input["InstalledCount"],
    MissingCount: input["MissingCount"],
    FailedCount: input["FailedCount"],
    InstalledOtherCount: input["InstalledOtherCount"],
    InstalledRejectedCount: input["InstalledRejectedCount"],
    InstalledPendingReboot: input["InstalledPendingReboot"],
    OperationStartTime: input["OperationStartTime"],
    OperationEndTime: input["OperationEndTime"],
    RebootOption: input["RebootOption"],
    Operation: input["Operation"],
  }
}
function toPatchSummary(root: jsonP.JSONValue): s.PatchSummary {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "InstalledCount": "n",
      "MissingCount": "n",
      "FailedCount": "n",
      "InstalledOtherCount": "n",
      "InstalledRejectedCount": "n",
      "InstalledPendingReboot": "n",
      "OperationStartTime": "s",
      "OperationEndTime": "s",
      "RebootOption": "s",
      "Operation": "s",
    },
  }, root);
}

function fromAction(input?: s.Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ActionType: input["ActionType"],
    NetworkConnectionAction: fromNetworkConnectionAction(input["NetworkConnectionAction"]),
    AwsApiCallAction: fromAwsApiCallAction(input["AwsApiCallAction"]),
    DnsRequestAction: fromDnsRequestAction(input["DnsRequestAction"]),
    PortProbeAction: fromPortProbeAction(input["PortProbeAction"]),
  }
}
function toAction(root: jsonP.JSONValue): s.Action {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActionType": "s",
      "NetworkConnectionAction": toNetworkConnectionAction,
      "AwsApiCallAction": toAwsApiCallAction,
      "DnsRequestAction": toDnsRequestAction,
      "PortProbeAction": toPortProbeAction,
    },
  }, root);
}

function fromNetworkConnectionAction(input?: s.NetworkConnectionAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectionDirection: input["ConnectionDirection"],
    RemoteIpDetails: fromActionRemoteIpDetails(input["RemoteIpDetails"]),
    RemotePortDetails: fromActionRemotePortDetails(input["RemotePortDetails"]),
    LocalPortDetails: fromActionLocalPortDetails(input["LocalPortDetails"]),
    Protocol: input["Protocol"],
    Blocked: input["Blocked"],
  }
}
function toNetworkConnectionAction(root: jsonP.JSONValue): s.NetworkConnectionAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionDirection": "s",
      "RemoteIpDetails": toActionRemoteIpDetails,
      "RemotePortDetails": toActionRemotePortDetails,
      "LocalPortDetails": toActionLocalPortDetails,
      "Protocol": "s",
      "Blocked": "b",
    },
  }, root);
}

function fromActionRemoteIpDetails(input?: s.ActionRemoteIpDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IpAddressV4: input["IpAddressV4"],
    Organization: fromIpOrganizationDetails(input["Organization"]),
    Country: fromCountry(input["Country"]),
    City: fromCity(input["City"]),
    GeoLocation: fromGeoLocation(input["GeoLocation"]),
  }
}
function toActionRemoteIpDetails(root: jsonP.JSONValue): s.ActionRemoteIpDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "IpAddressV4": "s",
      "Organization": toIpOrganizationDetails,
      "Country": toCountry,
      "City": toCity,
      "GeoLocation": toGeoLocation,
    },
  }, root);
}

function fromIpOrganizationDetails(input?: s.IpOrganizationDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Asn: input["Asn"],
    AsnOrg: input["AsnOrg"],
    Isp: input["Isp"],
    Org: input["Org"],
  }
}
function toIpOrganizationDetails(root: jsonP.JSONValue): s.IpOrganizationDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Asn": "n",
      "AsnOrg": "s",
      "Isp": "s",
      "Org": "s",
    },
  }, root);
}

function fromCountry(input?: s.Country | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CountryCode: input["CountryCode"],
    CountryName: input["CountryName"],
  }
}
function toCountry(root: jsonP.JSONValue): s.Country {
  return jsonP.readObj({
    required: {},
    optional: {
      "CountryCode": "s",
      "CountryName": "s",
    },
  }, root);
}

function fromCity(input?: s.City | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CityName: input["CityName"],
  }
}
function toCity(root: jsonP.JSONValue): s.City {
  return jsonP.readObj({
    required: {},
    optional: {
      "CityName": "s",
    },
  }, root);
}

function fromGeoLocation(input?: s.GeoLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Lon: input["Lon"],
    Lat: input["Lat"],
  }
}
function toGeoLocation(root: jsonP.JSONValue): s.GeoLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Lon": "n",
      "Lat": "n",
    },
  }, root);
}

function fromActionRemotePortDetails(input?: s.ActionRemotePortDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Port: input["Port"],
    PortName: input["PortName"],
  }
}
function toActionRemotePortDetails(root: jsonP.JSONValue): s.ActionRemotePortDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Port": "n",
      "PortName": "s",
    },
  }, root);
}

function fromActionLocalPortDetails(input?: s.ActionLocalPortDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Port: input["Port"],
    PortName: input["PortName"],
  }
}
function toActionLocalPortDetails(root: jsonP.JSONValue): s.ActionLocalPortDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Port": "n",
      "PortName": "s",
    },
  }, root);
}

function fromAwsApiCallAction(input?: s.AwsApiCallAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Api: input["Api"],
    ServiceName: input["ServiceName"],
    CallerType: input["CallerType"],
    RemoteIpDetails: fromActionRemoteIpDetails(input["RemoteIpDetails"]),
    DomainDetails: fromAwsApiCallActionDomainDetails(input["DomainDetails"]),
    AffectedResources: input["AffectedResources"],
    FirstSeen: input["FirstSeen"],
    LastSeen: input["LastSeen"],
  }
}
function toAwsApiCallAction(root: jsonP.JSONValue): s.AwsApiCallAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Api": "s",
      "ServiceName": "s",
      "CallerType": "s",
      "RemoteIpDetails": toActionRemoteIpDetails,
      "DomainDetails": toAwsApiCallActionDomainDetails,
      "AffectedResources": x => jsonP.readMap(String, String, x),
      "FirstSeen": "s",
      "LastSeen": "s",
    },
  }, root);
}

function fromAwsApiCallActionDomainDetails(input?: s.AwsApiCallActionDomainDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Domain: input["Domain"],
  }
}
function toAwsApiCallActionDomainDetails(root: jsonP.JSONValue): s.AwsApiCallActionDomainDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Domain": "s",
    },
  }, root);
}

function fromDnsRequestAction(input?: s.DnsRequestAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Domain: input["Domain"],
    Protocol: input["Protocol"],
    Blocked: input["Blocked"],
  }
}
function toDnsRequestAction(root: jsonP.JSONValue): s.DnsRequestAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Domain": "s",
      "Protocol": "s",
      "Blocked": "b",
    },
  }, root);
}

function fromPortProbeAction(input?: s.PortProbeAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PortProbeDetails: input["PortProbeDetails"]?.map(x => fromPortProbeDetail(x)),
    Blocked: input["Blocked"],
  }
}
function toPortProbeAction(root: jsonP.JSONValue): s.PortProbeAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "PortProbeDetails": [toPortProbeDetail],
      "Blocked": "b",
    },
  }, root);
}

function fromPortProbeDetail(input?: s.PortProbeDetail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LocalPortDetails: fromActionLocalPortDetails(input["LocalPortDetails"]),
    LocalIpDetails: fromActionLocalIpDetails(input["LocalIpDetails"]),
    RemoteIpDetails: fromActionRemoteIpDetails(input["RemoteIpDetails"]),
  }
}
function toPortProbeDetail(root: jsonP.JSONValue): s.PortProbeDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "LocalPortDetails": toActionLocalPortDetails,
      "LocalIpDetails": toActionLocalIpDetails,
      "RemoteIpDetails": toActionRemoteIpDetails,
    },
  }, root);
}

function fromActionLocalIpDetails(input?: s.ActionLocalIpDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IpAddressV4: input["IpAddressV4"],
  }
}
function toActionLocalIpDetails(root: jsonP.JSONValue): s.ActionLocalIpDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "IpAddressV4": "s",
    },
  }, root);
}

function fromAwsSecurityFindingIdentifier(input?: s.AwsSecurityFindingIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    ProductArn: input["ProductArn"],
  }
}
function toAwsSecurityFindingIdentifier(root: jsonP.JSONValue): s.AwsSecurityFindingIdentifier {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "ProductArn": "s",
    },
    optional: {},
  }, root);
}

function fromNoteUpdate(input?: s.NoteUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Text: input["Text"],
    UpdatedBy: input["UpdatedBy"],
  }
}

function fromSeverityUpdate(input?: s.SeverityUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Normalized: input["Normalized"],
    Product: input["Product"],
    Label: input["Label"],
  }
}

function fromWorkflowUpdate(input?: s.WorkflowUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Status: input["Status"],
  }
}

function fromAwsSecurityFindingFilters(input?: s.AwsSecurityFindingFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProductArn: input["ProductArn"]?.map(x => fromStringFilter(x)),
    AwsAccountId: input["AwsAccountId"]?.map(x => fromStringFilter(x)),
    Id: input["Id"]?.map(x => fromStringFilter(x)),
    GeneratorId: input["GeneratorId"]?.map(x => fromStringFilter(x)),
    Type: input["Type"]?.map(x => fromStringFilter(x)),
    FirstObservedAt: input["FirstObservedAt"]?.map(x => fromDateFilter(x)),
    LastObservedAt: input["LastObservedAt"]?.map(x => fromDateFilter(x)),
    CreatedAt: input["CreatedAt"]?.map(x => fromDateFilter(x)),
    UpdatedAt: input["UpdatedAt"]?.map(x => fromDateFilter(x)),
    SeverityProduct: input["SeverityProduct"]?.map(x => fromNumberFilter(x)),
    SeverityNormalized: input["SeverityNormalized"]?.map(x => fromNumberFilter(x)),
    SeverityLabel: input["SeverityLabel"]?.map(x => fromStringFilter(x)),
    Confidence: input["Confidence"]?.map(x => fromNumberFilter(x)),
    Criticality: input["Criticality"]?.map(x => fromNumberFilter(x)),
    Title: input["Title"]?.map(x => fromStringFilter(x)),
    Description: input["Description"]?.map(x => fromStringFilter(x)),
    RecommendationText: input["RecommendationText"]?.map(x => fromStringFilter(x)),
    SourceUrl: input["SourceUrl"]?.map(x => fromStringFilter(x)),
    ProductFields: input["ProductFields"]?.map(x => fromMapFilter(x)),
    ProductName: input["ProductName"]?.map(x => fromStringFilter(x)),
    CompanyName: input["CompanyName"]?.map(x => fromStringFilter(x)),
    UserDefinedFields: input["UserDefinedFields"]?.map(x => fromMapFilter(x)),
    MalwareName: input["MalwareName"]?.map(x => fromStringFilter(x)),
    MalwareType: input["MalwareType"]?.map(x => fromStringFilter(x)),
    MalwarePath: input["MalwarePath"]?.map(x => fromStringFilter(x)),
    MalwareState: input["MalwareState"]?.map(x => fromStringFilter(x)),
    NetworkDirection: input["NetworkDirection"]?.map(x => fromStringFilter(x)),
    NetworkProtocol: input["NetworkProtocol"]?.map(x => fromStringFilter(x)),
    NetworkSourceIpV4: input["NetworkSourceIpV4"]?.map(x => fromIpFilter(x)),
    NetworkSourceIpV6: input["NetworkSourceIpV6"]?.map(x => fromIpFilter(x)),
    NetworkSourcePort: input["NetworkSourcePort"]?.map(x => fromNumberFilter(x)),
    NetworkSourceDomain: input["NetworkSourceDomain"]?.map(x => fromStringFilter(x)),
    NetworkSourceMac: input["NetworkSourceMac"]?.map(x => fromStringFilter(x)),
    NetworkDestinationIpV4: input["NetworkDestinationIpV4"]?.map(x => fromIpFilter(x)),
    NetworkDestinationIpV6: input["NetworkDestinationIpV6"]?.map(x => fromIpFilter(x)),
    NetworkDestinationPort: input["NetworkDestinationPort"]?.map(x => fromNumberFilter(x)),
    NetworkDestinationDomain: input["NetworkDestinationDomain"]?.map(x => fromStringFilter(x)),
    ProcessName: input["ProcessName"]?.map(x => fromStringFilter(x)),
    ProcessPath: input["ProcessPath"]?.map(x => fromStringFilter(x)),
    ProcessPid: input["ProcessPid"]?.map(x => fromNumberFilter(x)),
    ProcessParentPid: input["ProcessParentPid"]?.map(x => fromNumberFilter(x)),
    ProcessLaunchedAt: input["ProcessLaunchedAt"]?.map(x => fromDateFilter(x)),
    ProcessTerminatedAt: input["ProcessTerminatedAt"]?.map(x => fromDateFilter(x)),
    ThreatIntelIndicatorType: input["ThreatIntelIndicatorType"]?.map(x => fromStringFilter(x)),
    ThreatIntelIndicatorValue: input["ThreatIntelIndicatorValue"]?.map(x => fromStringFilter(x)),
    ThreatIntelIndicatorCategory: input["ThreatIntelIndicatorCategory"]?.map(x => fromStringFilter(x)),
    ThreatIntelIndicatorLastObservedAt: input["ThreatIntelIndicatorLastObservedAt"]?.map(x => fromDateFilter(x)),
    ThreatIntelIndicatorSource: input["ThreatIntelIndicatorSource"]?.map(x => fromStringFilter(x)),
    ThreatIntelIndicatorSourceUrl: input["ThreatIntelIndicatorSourceUrl"]?.map(x => fromStringFilter(x)),
    ResourceType: input["ResourceType"]?.map(x => fromStringFilter(x)),
    ResourceId: input["ResourceId"]?.map(x => fromStringFilter(x)),
    ResourcePartition: input["ResourcePartition"]?.map(x => fromStringFilter(x)),
    ResourceRegion: input["ResourceRegion"]?.map(x => fromStringFilter(x)),
    ResourceTags: input["ResourceTags"]?.map(x => fromMapFilter(x)),
    ResourceAwsEc2InstanceType: input["ResourceAwsEc2InstanceType"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceImageId: input["ResourceAwsEc2InstanceImageId"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceIpV4Addresses: input["ResourceAwsEc2InstanceIpV4Addresses"]?.map(x => fromIpFilter(x)),
    ResourceAwsEc2InstanceIpV6Addresses: input["ResourceAwsEc2InstanceIpV6Addresses"]?.map(x => fromIpFilter(x)),
    ResourceAwsEc2InstanceKeyName: input["ResourceAwsEc2InstanceKeyName"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceIamInstanceProfileArn: input["ResourceAwsEc2InstanceIamInstanceProfileArn"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceVpcId: input["ResourceAwsEc2InstanceVpcId"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceSubnetId: input["ResourceAwsEc2InstanceSubnetId"]?.map(x => fromStringFilter(x)),
    ResourceAwsEc2InstanceLaunchedAt: input["ResourceAwsEc2InstanceLaunchedAt"]?.map(x => fromDateFilter(x)),
    ResourceAwsS3BucketOwnerId: input["ResourceAwsS3BucketOwnerId"]?.map(x => fromStringFilter(x)),
    ResourceAwsS3BucketOwnerName: input["ResourceAwsS3BucketOwnerName"]?.map(x => fromStringFilter(x)),
    ResourceAwsIamAccessKeyUserName: input["ResourceAwsIamAccessKeyUserName"]?.map(x => fromStringFilter(x)),
    ResourceAwsIamAccessKeyStatus: input["ResourceAwsIamAccessKeyStatus"]?.map(x => fromStringFilter(x)),
    ResourceAwsIamAccessKeyCreatedAt: input["ResourceAwsIamAccessKeyCreatedAt"]?.map(x => fromDateFilter(x)),
    ResourceContainerName: input["ResourceContainerName"]?.map(x => fromStringFilter(x)),
    ResourceContainerImageId: input["ResourceContainerImageId"]?.map(x => fromStringFilter(x)),
    ResourceContainerImageName: input["ResourceContainerImageName"]?.map(x => fromStringFilter(x)),
    ResourceContainerLaunchedAt: input["ResourceContainerLaunchedAt"]?.map(x => fromDateFilter(x)),
    ResourceDetailsOther: input["ResourceDetailsOther"]?.map(x => fromMapFilter(x)),
    ComplianceStatus: input["ComplianceStatus"]?.map(x => fromStringFilter(x)),
    VerificationState: input["VerificationState"]?.map(x => fromStringFilter(x)),
    WorkflowState: input["WorkflowState"]?.map(x => fromStringFilter(x)),
    WorkflowStatus: input["WorkflowStatus"]?.map(x => fromStringFilter(x)),
    RecordState: input["RecordState"]?.map(x => fromStringFilter(x)),
    RelatedFindingsProductArn: input["RelatedFindingsProductArn"]?.map(x => fromStringFilter(x)),
    RelatedFindingsId: input["RelatedFindingsId"]?.map(x => fromStringFilter(x)),
    NoteText: input["NoteText"]?.map(x => fromStringFilter(x)),
    NoteUpdatedAt: input["NoteUpdatedAt"]?.map(x => fromDateFilter(x)),
    NoteUpdatedBy: input["NoteUpdatedBy"]?.map(x => fromStringFilter(x)),
    Keyword: input["Keyword"]?.map(x => fromKeywordFilter(x)),
  }
}
function toAwsSecurityFindingFilters(root: jsonP.JSONValue): s.AwsSecurityFindingFilters {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProductArn": [toStringFilter],
      "AwsAccountId": [toStringFilter],
      "Id": [toStringFilter],
      "GeneratorId": [toStringFilter],
      "Type": [toStringFilter],
      "FirstObservedAt": [toDateFilter],
      "LastObservedAt": [toDateFilter],
      "CreatedAt": [toDateFilter],
      "UpdatedAt": [toDateFilter],
      "SeverityProduct": [toNumberFilter],
      "SeverityNormalized": [toNumberFilter],
      "SeverityLabel": [toStringFilter],
      "Confidence": [toNumberFilter],
      "Criticality": [toNumberFilter],
      "Title": [toStringFilter],
      "Description": [toStringFilter],
      "RecommendationText": [toStringFilter],
      "SourceUrl": [toStringFilter],
      "ProductFields": [toMapFilter],
      "ProductName": [toStringFilter],
      "CompanyName": [toStringFilter],
      "UserDefinedFields": [toMapFilter],
      "MalwareName": [toStringFilter],
      "MalwareType": [toStringFilter],
      "MalwarePath": [toStringFilter],
      "MalwareState": [toStringFilter],
      "NetworkDirection": [toStringFilter],
      "NetworkProtocol": [toStringFilter],
      "NetworkSourceIpV4": [toIpFilter],
      "NetworkSourceIpV6": [toIpFilter],
      "NetworkSourcePort": [toNumberFilter],
      "NetworkSourceDomain": [toStringFilter],
      "NetworkSourceMac": [toStringFilter],
      "NetworkDestinationIpV4": [toIpFilter],
      "NetworkDestinationIpV6": [toIpFilter],
      "NetworkDestinationPort": [toNumberFilter],
      "NetworkDestinationDomain": [toStringFilter],
      "ProcessName": [toStringFilter],
      "ProcessPath": [toStringFilter],
      "ProcessPid": [toNumberFilter],
      "ProcessParentPid": [toNumberFilter],
      "ProcessLaunchedAt": [toDateFilter],
      "ProcessTerminatedAt": [toDateFilter],
      "ThreatIntelIndicatorType": [toStringFilter],
      "ThreatIntelIndicatorValue": [toStringFilter],
      "ThreatIntelIndicatorCategory": [toStringFilter],
      "ThreatIntelIndicatorLastObservedAt": [toDateFilter],
      "ThreatIntelIndicatorSource": [toStringFilter],
      "ThreatIntelIndicatorSourceUrl": [toStringFilter],
      "ResourceType": [toStringFilter],
      "ResourceId": [toStringFilter],
      "ResourcePartition": [toStringFilter],
      "ResourceRegion": [toStringFilter],
      "ResourceTags": [toMapFilter],
      "ResourceAwsEc2InstanceType": [toStringFilter],
      "ResourceAwsEc2InstanceImageId": [toStringFilter],
      "ResourceAwsEc2InstanceIpV4Addresses": [toIpFilter],
      "ResourceAwsEc2InstanceIpV6Addresses": [toIpFilter],
      "ResourceAwsEc2InstanceKeyName": [toStringFilter],
      "ResourceAwsEc2InstanceIamInstanceProfileArn": [toStringFilter],
      "ResourceAwsEc2InstanceVpcId": [toStringFilter],
      "ResourceAwsEc2InstanceSubnetId": [toStringFilter],
      "ResourceAwsEc2InstanceLaunchedAt": [toDateFilter],
      "ResourceAwsS3BucketOwnerId": [toStringFilter],
      "ResourceAwsS3BucketOwnerName": [toStringFilter],
      "ResourceAwsIamAccessKeyUserName": [toStringFilter],
      "ResourceAwsIamAccessKeyStatus": [toStringFilter],
      "ResourceAwsIamAccessKeyCreatedAt": [toDateFilter],
      "ResourceContainerName": [toStringFilter],
      "ResourceContainerImageId": [toStringFilter],
      "ResourceContainerImageName": [toStringFilter],
      "ResourceContainerLaunchedAt": [toDateFilter],
      "ResourceDetailsOther": [toMapFilter],
      "ComplianceStatus": [toStringFilter],
      "VerificationState": [toStringFilter],
      "WorkflowState": [toStringFilter],
      "WorkflowStatus": [toStringFilter],
      "RecordState": [toStringFilter],
      "RelatedFindingsProductArn": [toStringFilter],
      "RelatedFindingsId": [toStringFilter],
      "NoteText": [toStringFilter],
      "NoteUpdatedAt": [toDateFilter],
      "NoteUpdatedBy": [toStringFilter],
      "Keyword": [toKeywordFilter],
    },
  }, root);
}

function fromStringFilter(input?: s.StringFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Comparison: input["Comparison"],
  }
}
function toStringFilter(root: jsonP.JSONValue): s.StringFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
      "Comparison": (x: jsonP.JSONValue) => cmnP.readEnum<s.StringFilterComparison>(x),
    },
  }, root);
}

function fromDateFilter(input?: s.DateFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Start: input["Start"],
    End: input["End"],
    DateRange: fromDateRange(input["DateRange"]),
  }
}
function toDateFilter(root: jsonP.JSONValue): s.DateFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Start": "s",
      "End": "s",
      "DateRange": toDateRange,
    },
  }, root);
}

function fromDateRange(input?: s.DateRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
    Unit: input["Unit"],
  }
}
function toDateRange(root: jsonP.JSONValue): s.DateRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "n",
      "Unit": (x: jsonP.JSONValue) => cmnP.readEnum<s.DateRangeUnit>(x),
    },
  }, root);
}

function fromNumberFilter(input?: s.NumberFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Gte: input["Gte"],
    Lte: input["Lte"],
    Eq: input["Eq"],
  }
}
function toNumberFilter(root: jsonP.JSONValue): s.NumberFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Gte": "n",
      "Lte": "n",
      "Eq": "n",
    },
  }, root);
}

function fromMapFilter(input?: s.MapFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Comparison: input["Comparison"],
  }
}
function toMapFilter(root: jsonP.JSONValue): s.MapFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
      "Comparison": (x: jsonP.JSONValue) => cmnP.readEnum<s.MapFilterComparison>(x),
    },
  }, root);
}

function fromIpFilter(input?: s.IpFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Cidr: input["Cidr"],
  }
}
function toIpFilter(root: jsonP.JSONValue): s.IpFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Cidr": "s",
    },
  }, root);
}

function fromKeywordFilter(input?: s.KeywordFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Value: input["Value"],
  }
}
function toKeywordFilter(root: jsonP.JSONValue): s.KeywordFilter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Value": "s",
    },
  }, root);
}

function fromAccountDetails(input?: s.AccountDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AccountId: input["AccountId"],
    Email: input["Email"],
  }
}

function fromSortCriterion(input?: s.SortCriterion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Field: input["Field"],
    SortOrder: input["SortOrder"],
  }
}

function toStandardsSubscription(root: jsonP.JSONValue): s.StandardsSubscription {
  return jsonP.readObj({
    required: {
      "StandardsSubscriptionArn": "s",
      "StandardsArn": "s",
      "StandardsInput": x => jsonP.readMap(String, String, x),
      "StandardsStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StandardsStatus>(x),
    },
    optional: {},
  }, root);
}

function toImportFindingsError(root: jsonP.JSONValue): s.ImportFindingsError {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
    optional: {},
  }, root);
}

function toBatchUpdateFindingsUnprocessedFinding(root: jsonP.JSONValue): s.BatchUpdateFindingsUnprocessedFinding {
  return jsonP.readObj({
    required: {
      "FindingIdentifier": toAwsSecurityFindingIdentifier,
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
    optional: {},
  }, root);
}

function toResult(root: jsonP.JSONValue): s.Result {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "ProcessingResult": "s",
    },
  }, root);
}

function toActionTarget(root: jsonP.JSONValue): s.ActionTarget {
  return jsonP.readObj({
    required: {
      "ActionTargetArn": "s",
      "Name": "s",
      "Description": "s",
    },
    optional: {},
  }, root);
}

function toProduct(root: jsonP.JSONValue): s.Product {
  return jsonP.readObj({
    required: {
      "ProductArn": "s",
    },
    optional: {
      "ProductName": "s",
      "CompanyName": "s",
      "Description": "s",
      "Categories": ["s"],
      "IntegrationTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.IntegrationType>(x)],
      "MarketplaceUrl": "s",
      "ActivationUrl": "s",
      "ProductSubscriptionResourcePolicy": "s",
    },
  }, root);
}

function toStandard(root: jsonP.JSONValue): s.Standard {
  return jsonP.readObj({
    required: {},
    optional: {
      "StandardsArn": "s",
      "Name": "s",
      "Description": "s",
      "EnabledByDefault": "b",
    },
  }, root);
}

function toStandardsControl(root: jsonP.JSONValue): s.StandardsControl {
  return jsonP.readObj({
    required: {},
    optional: {
      "StandardsControlArn": "s",
      "ControlStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ControlStatus>(x),
      "DisabledReason": "s",
      "ControlStatusUpdatedAt": "d",
      "ControlId": "s",
      "Title": "s",
      "Description": "s",
      "RemediationUrl": "s",
      "SeverityRating": (x: jsonP.JSONValue) => cmnP.readEnum<s.SeverityRating>(x),
      "RelatedRequirements": ["s"],
    },
  }, root);
}

function toInsightResults(root: jsonP.JSONValue): s.InsightResults {
  return jsonP.readObj({
    required: {
      "InsightArn": "s",
      "GroupByAttribute": "s",
      "ResultValues": [toInsightResultValue],
    },
    optional: {},
  }, root);
}

function toInsightResultValue(root: jsonP.JSONValue): s.InsightResultValue {
  return jsonP.readObj({
    required: {
      "GroupByAttributeValue": "s",
      "Count": "n",
    },
    optional: {},
  }, root);
}

function toInsight(root: jsonP.JSONValue): s.Insight {
  return jsonP.readObj({
    required: {
      "InsightArn": "s",
      "Name": "s",
      "Filters": toAwsSecurityFindingFilters,
      "GroupByAttribute": "s",
    },
    optional: {},
  }, root);
}

function toInvitation(root: jsonP.JSONValue): s.Invitation {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "InvitationId": "s",
      "InvitedAt": "d",
      "MemberStatus": "s",
    },
  }, root);
}

function toMember(root: jsonP.JSONValue): s.Member {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "Email": "s",
      "MasterId": "s",
      "MemberStatus": "s",
      "InvitedAt": "d",
      "UpdatedAt": "d",
    },
  }, root);
}

function toAdminAccount(root: jsonP.JSONValue): s.AdminAccount {
  return jsonP.readObj({
    required: {},
    optional: {
      "AccountId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AdminStatus>(x),
    },
  }, root);
}
