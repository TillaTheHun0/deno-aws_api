// Autogenerated API client for: AWS CloudHSM V2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CloudHSMV2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudHSMV2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-04-28",
    "endpointPrefix": "cloudhsmv2",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CloudHSM V2",
    "serviceFullName": "AWS CloudHSM V2",
    "serviceId": "CloudHSM V2",
    "signatureVersion": "v4",
    "signingName": "cloudhsm",
    "targetPrefix": "BaldrApiService",
    "uid": "cloudhsmv2-2017-04-28"
  };

  async copyBackupToRegion(
    {abortSignal, ...params}: RequestConfig & s.CopyBackupToRegionRequest,
  ): Promise<s.CopyBackupToRegionResponse> {
    const body: jsonP.JSONObject = {
      DestinationRegion: params["DestinationRegion"],
      BackupId: params["BackupId"],
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CopyBackupToRegion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DestinationBackup": toDestinationBackup,
      },
    }, await resp.json());
  }

  async createCluster(
    {abortSignal, ...params}: RequestConfig & s.CreateClusterRequest,
  ): Promise<s.CreateClusterResponse> {
    const body: jsonP.JSONObject = {
      BackupRetentionPolicy: fromBackupRetentionPolicy(params["BackupRetentionPolicy"]),
      HsmType: params["HsmType"],
      SourceBackupId: params["SourceBackupId"],
      SubnetIds: params["SubnetIds"],
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async createHsm(
    {abortSignal, ...params}: RequestConfig & s.CreateHsmRequest,
  ): Promise<s.CreateHsmResponse> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      AvailabilityZone: params["AvailabilityZone"],
      IpAddress: params["IpAddress"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHsm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Hsm": toHsm,
      },
    }, await resp.json());
  }

  async deleteBackup(
    {abortSignal, ...params}: RequestConfig & s.DeleteBackupRequest,
  ): Promise<s.DeleteBackupResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backup": toBackup,
      },
    }, await resp.json());
  }

  async deleteCluster(
    {abortSignal, ...params}: RequestConfig & s.DeleteClusterRequest,
  ): Promise<s.DeleteClusterResponse> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async deleteHsm(
    {abortSignal, ...params}: RequestConfig & s.DeleteHsmRequest,
  ): Promise<s.DeleteHsmResponse> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      HsmId: params["HsmId"],
      EniId: params["EniId"],
      EniIp: params["EniIp"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHsm",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HsmId": "s",
      },
    }, await resp.json());
  }

  async describeBackups(
    {abortSignal, ...params}: RequestConfig & s.DescribeBackupsRequest = {},
  ): Promise<s.DescribeBackupsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filters: params["Filters"],
      SortAscending: params["SortAscending"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeBackups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backups": [toBackup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeClusters(
    {abortSignal, ...params}: RequestConfig & s.DescribeClustersRequest = {},
  ): Promise<s.DescribeClustersResponse> {
    const body: jsonP.JSONObject = {
      Filters: params["Filters"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeClusters",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Clusters": [toCluster],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async initializeCluster(
    {abortSignal, ...params}: RequestConfig & s.InitializeClusterRequest,
  ): Promise<s.InitializeClusterResponse> {
    const body: jsonP.JSONObject = {
      ClusterId: params["ClusterId"],
      SignedCert: params["SignedCert"],
      TrustAnchor: params["TrustAnchor"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InitializeCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
        "StateMessage": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & s.ListTagsRequest,
  ): Promise<s.ListTagsResponse> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {
        "TagList": [toTag],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async modifyBackupAttributes(
    {abortSignal, ...params}: RequestConfig & s.ModifyBackupAttributesRequest,
  ): Promise<s.ModifyBackupAttributesResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
      NeverExpires: params["NeverExpires"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyBackupAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backup": toBackup,
      },
    }, await resp.json());
  }

  async modifyCluster(
    {abortSignal, ...params}: RequestConfig & s.ModifyClusterRequest,
  ): Promise<s.ModifyClusterResponse> {
    const body: jsonP.JSONObject = {
      BackupRetentionPolicy: fromBackupRetentionPolicy(params["BackupRetentionPolicy"]),
      ClusterId: params["ClusterId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ModifyCluster",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Cluster": toCluster,
      },
    }, await resp.json());
  }

  async restoreBackup(
    {abortSignal, ...params}: RequestConfig & s.RestoreBackupRequest,
  ): Promise<s.RestoreBackupResponse> {
    const body: jsonP.JSONObject = {
      BackupId: params["BackupId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestoreBackup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Backup": toBackup,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      TagList: params["TagList"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceId: params["ResourceId"],
      TagKeyList: params["TagKeyList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromBackupRetentionPolicy(input?: s.BackupRetentionPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Value: input["Value"],
  }
}
function toBackupRetentionPolicy(root: jsonP.JSONValue): s.BackupRetentionPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupRetentionType>(x),
      "Value": "s",
    },
  }, root);
}

function toDestinationBackup(root: jsonP.JSONValue): s.DestinationBackup {
  return jsonP.readObj({
    required: {},
    optional: {
      "CreateTimestamp": "d",
      "SourceRegion": "s",
      "SourceBackup": "s",
      "SourceCluster": "s",
    },
  }, root);
}

function toCluster(root: jsonP.JSONValue): s.Cluster {
  return jsonP.readObj({
    required: {},
    optional: {
      "BackupPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupPolicy>(x),
      "BackupRetentionPolicy": toBackupRetentionPolicy,
      "ClusterId": "s",
      "CreateTimestamp": "d",
      "Hsms": [toHsm],
      "HsmType": "s",
      "PreCoPassword": "s",
      "SecurityGroup": "s",
      "SourceBackupId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ClusterState>(x),
      "StateMessage": "s",
      "SubnetMapping": x => jsonP.readMap(String, String, x),
      "VpcId": "s",
      "Certificates": toCertificates,
      "TagList": [toTag],
    },
  }, root);
}

function toHsm(root: jsonP.JSONValue): s.Hsm {
  return jsonP.readObj({
    required: {
      "HsmId": "s",
    },
    optional: {
      "AvailabilityZone": "s",
      "ClusterId": "s",
      "SubnetId": "s",
      "EniId": "s",
      "EniIp": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.HsmState>(x),
      "StateMessage": "s",
    },
  }, root);
}

function toCertificates(root: jsonP.JSONValue): s.Certificates {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClusterCsr": "s",
      "HsmCertificate": "s",
      "AwsHardwareCertificate": "s",
      "ManufacturerHardwareCertificate": "s",
      "ClusterCertificate": "s",
    },
  }, root);
}

function toBackup(root: jsonP.JSONValue): s.Backup {
  return jsonP.readObj({
    required: {
      "BackupId": "s",
    },
    optional: {
      "BackupState": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackupState>(x),
      "ClusterId": "s",
      "CreateTimestamp": "d",
      "CopyTimestamp": "d",
      "NeverExpires": "b",
      "SourceRegion": "s",
      "SourceBackup": "s",
      "SourceCluster": "s",
      "DeleteTimestamp": "d",
      "TagList": [toTag],
    },
  }, root);
}
