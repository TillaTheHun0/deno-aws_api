// Autogenerated API client for: AWS Elemental MediaLive

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class MediaLive {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaLive.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-10-14",
    "endpointPrefix": "medialive",
    "signingName": "medialive",
    "serviceFullName": "AWS Elemental MediaLive",
    "serviceId": "MediaLive",
    "protocol": "rest-json",
    "uid": "medialive-2017-10-14",
    "signatureVersion": "v4",
    "serviceAbbreviation": "MediaLive",
    "jsonVersion": "1.1"
  };

  async acceptInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & s.AcceptInputDeviceTransferRequest,
  ): Promise<s.AcceptInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AcceptInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/accept`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async batchDelete(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteRequest = {},
  ): Promise<s.BatchDeleteResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      inputIds: params["InputIds"],
      inputSecurityGroupIds: params["InputSecurityGroupIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDelete",
      requestUri: "/prod/batch/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchStart(
    {abortSignal, ...params}: RequestConfig & s.BatchStartRequest = {},
  ): Promise<s.BatchStartResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStart",
      requestUri: "/prod/batch/start",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchStop(
    {abortSignal, ...params}: RequestConfig & s.BatchStopRequest = {},
  ): Promise<s.BatchStopResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStop",
      requestUri: "/prod/batch/stop",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchUpdateSchedule(
    {abortSignal, ...params}: RequestConfig & s.BatchUpdateScheduleRequest,
  ): Promise<s.BatchUpdateScheduleResponse> {
    const body: jsonP.JSONObject = {
      creates: fromBatchScheduleActionCreateRequest(params["Creates"]),
      deletes: fromBatchScheduleActionDeleteRequest(params["Deletes"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdateSchedule",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Creates": toBatchScheduleActionCreateResult,
        "Deletes": toBatchScheduleActionDeleteResult,
      },
    }, await resp.json());
  }

  async cancelInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & s.CancelInputDeviceTransferRequest,
  ): Promise<s.CancelInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/cancel`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & s.CreateChannelRequest = {},
  ): Promise<s.CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      cdiInputSpecification: fromCdiInputSpecification(params["CdiInputSpecification"]),
      channelClass: params["ChannelClass"],
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
      encoderSettings: fromEncoderSettings(params["EncoderSettings"]),
      inputAttachments: params["InputAttachments"]?.map(x => fromInputAttachment(x)),
      inputSpecification: fromInputSpecification(params["InputSpecification"]),
      logLevel: params["LogLevel"],
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      reserved: params["Reserved"],
      roleArn: params["RoleArn"],
      tags: params["Tags"],
      vpc: fromVpcOutputSettings(params["Vpc"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/prod/channels",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async createInput(
    {abortSignal, ...params}: RequestConfig & s.CreateInputRequest = {},
  ): Promise<s.CreateInputResponse> {
    const body: jsonP.JSONObject = {
      destinations: params["Destinations"]?.map(x => fromInputDestinationRequest(x)),
      inputDevices: params["InputDevices"]?.map(x => fromInputDeviceSettings(x)),
      inputSecurityGroups: params["InputSecurityGroups"],
      mediaConnectFlows: params["MediaConnectFlows"]?.map(x => fromMediaConnectFlowRequest(x)),
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      roleArn: params["RoleArn"],
      sources: params["Sources"]?.map(x => fromInputSourceRequest(x)),
      tags: params["Tags"],
      type: params["Type"],
      vpc: fromInputVpcRequest(params["Vpc"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInput",
      requestUri: "/prod/inputs",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Input": toInput,
      },
    }, await resp.json());
  }

  async createInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateInputSecurityGroupRequest = {},
  ): Promise<s.CreateInputSecurityGroupResponse> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
      whitelistRules: params["WhitelistRules"]?.map(x => fromInputWhitelistRuleCidr(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInputSecurityGroup",
      requestUri: "/prod/inputSecurityGroups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityGroup": toInputSecurityGroup,
      },
    }, await resp.json());
  }

  async createMultiplex(
    {abortSignal, ...params}: RequestConfig & s.CreateMultiplexRequest,
  ): Promise<s.CreateMultiplexResponse> {
    const body: jsonP.JSONObject = {
      availabilityZones: params["AvailabilityZones"],
      multiplexSettings: fromMultiplexSettings(params["MultiplexSettings"]),
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMultiplex",
      requestUri: "/prod/multiplexes",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplex": toMultiplex,
      },
    }, await resp.json());
  }

  async createMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & s.CreateMultiplexProgramRequest,
  ): Promise<s.CreateMultiplexProgramResponse> {
    const body: jsonP.JSONObject = {
      multiplexProgramSettings: fromMultiplexProgramSettings(params["MultiplexProgramSettings"]),
      programName: params["ProgramName"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMultiplexProgram",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexProgram": toMultiplexProgram,
      },
    }, await resp.json());
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & s.CreateTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteChannelRequest,
  ): Promise<s.DeleteChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async deleteInput(
    {abortSignal, ...params}: RequestConfig & s.DeleteInputRequest,
  ): Promise<s.DeleteInputResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInput",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteInputSecurityGroupRequest,
  ): Promise<s.DeleteInputSecurityGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInputSecurityGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMultiplex(
    {abortSignal, ...params}: RequestConfig & s.DeleteMultiplexRequest,
  ): Promise<s.DeleteMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMultiplex",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & s.DeleteMultiplexProgramRequest,
  ): Promise<s.DeleteMultiplexProgramResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMultiplexProgram",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChannelId": "s",
        "MultiplexProgramSettings": toMultiplexProgramSettings,
        "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
        "PipelineDetails": [toMultiplexProgramPipelineDetail],
        "ProgramName": "s",
      },
    }, await resp.json());
  }

  async deleteReservation(
    {abortSignal, ...params}: RequestConfig & s.DeleteReservationRequest,
  ): Promise<s.DeleteReservationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteReservation",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Count": "n",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingDurationUnits>(x),
        "End": "s",
        "FixedPrice": "n",
        "Name": "s",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingType>(x),
        "Region": "s",
        "ReservationId": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "Start": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async deleteSchedule(
    {abortSignal, ...params}: RequestConfig & s.DeleteScheduleRequest,
  ): Promise<s.DeleteScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSchedule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteTags",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async describeInput(
    {abortSignal, ...params}: RequestConfig & s.DescribeInputRequest,
  ): Promise<s.DescribeInputResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInput",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AttachedChannels": ["s"],
        "Destinations": [toInputDestination],
        "Id": "s",
        "InputClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputClass>(x),
        "InputDevices": [toInputDeviceSettings],
        "InputSourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputSourceType>(x),
        "MediaConnectFlows": [toMediaConnectFlow],
        "Name": "s",
        "RoleArn": "s",
        "SecurityGroups": ["s"],
        "Sources": [toInputSource],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputType>(x),
      },
    }, await resp.json());
  }

  async describeInputDevice(
    {abortSignal, ...params}: RequestConfig & s.DescribeInputDeviceRequest,
  ): Promise<s.DescribeInputDeviceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInputDevice",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceConnectionState>(x),
        "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceSettingsSyncState>(x),
        "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceUpdateStatus>(x),
        "HdDeviceSettings": toInputDeviceHdSettings,
        "Id": "s",
        "MacAddress": "s",
        "Name": "s",
        "NetworkSettings": toInputDeviceNetworkSettings,
        "SerialNumber": "s",
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceType>(x),
        "UhdDeviceSettings": toInputDeviceUhdSettings,
      },
    }, await resp.json());
  }

  async describeInputDeviceThumbnail(
    {abortSignal, ...params}: RequestConfig & s.DescribeInputDeviceThumbnailRequest,
  ): Promise<s.DescribeInputDeviceThumbnailResponse> {
    const headers = new Headers;
    headers.append("accept", params["Accept"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DescribeInputDeviceThumbnail",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/thumbnailData`,
      responseCode: 200,
    });
  return {
    ContentType: cmnP.readEnum<s.ContentType>(resp.headers.get("Content-Type")),
    ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
    ETag: resp.headers.get("ETag"),
    LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async describeInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeInputSecurityGroupRequest,
  ): Promise<s.DescribeInputSecurityGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInputSecurityGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Id": "s",
        "Inputs": ["s"],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputSecurityGroupState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "WhitelistRules": [toInputWhitelistRule],
      },
    }, await resp.json());
  }

  async describeMultiplex(
    {abortSignal, ...params}: RequestConfig & s.DescribeMultiplexRequest,
  ): Promise<s.DescribeMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMultiplex",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & s.DescribeMultiplexProgramRequest,
  ): Promise<s.DescribeMultiplexProgramResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMultiplexProgram",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChannelId": "s",
        "MultiplexProgramSettings": toMultiplexProgramSettings,
        "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
        "PipelineDetails": [toMultiplexProgramPipelineDetail],
        "ProgramName": "s",
      },
    }, await resp.json());
  }

  async describeOffering(
    {abortSignal, ...params}: RequestConfig & s.DescribeOfferingRequest,
  ): Promise<s.DescribeOfferingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOffering",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/offerings/${params["OfferingId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingDurationUnits>(x),
        "FixedPrice": "n",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingType>(x),
        "Region": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async describeReservation(
    {abortSignal, ...params}: RequestConfig & s.DescribeReservationRequest,
  ): Promise<s.DescribeReservationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeReservation",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Count": "n",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingDurationUnits>(x),
        "End": "s",
        "FixedPrice": "n",
        "Name": "s",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingType>(x),
        "Region": "s",
        "ReservationId": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "Start": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async describeSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeScheduleRequest,
  ): Promise<s.DescribeScheduleResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeSchedule",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ScheduleActions": [toScheduleAction],
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & s.ListChannelsRequest = {},
  ): Promise<s.ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/prod/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channels": [toChannelSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputDeviceTransfers(
    {abortSignal, ...params}: RequestConfig & s.ListInputDeviceTransfersRequest,
  ): Promise<s.ListInputDeviceTransfersResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    query.set("transferType", params["TransferType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputDeviceTransfers",
      method: "GET",
      requestUri: "/prod/inputDeviceTransfers",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputDeviceTransfers": [toTransferringInputDeviceSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputDevices(
    {abortSignal, ...params}: RequestConfig & s.ListInputDevicesRequest = {},
  ): Promise<s.ListInputDevicesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputDevices",
      method: "GET",
      requestUri: "/prod/inputDevices",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputDevices": [toInputDeviceSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputSecurityGroups(
    {abortSignal, ...params}: RequestConfig & s.ListInputSecurityGroupsRequest = {},
  ): Promise<s.ListInputSecurityGroupsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputSecurityGroups",
      method: "GET",
      requestUri: "/prod/inputSecurityGroups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputSecurityGroups": [toInputSecurityGroup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputs(
    {abortSignal, ...params}: RequestConfig & s.ListInputsRequest = {},
  ): Promise<s.ListInputsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputs",
      method: "GET",
      requestUri: "/prod/inputs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Inputs": [toInput],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMultiplexPrograms(
    {abortSignal, ...params}: RequestConfig & s.ListMultiplexProgramsRequest,
  ): Promise<s.ListMultiplexProgramsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMultiplexPrograms",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexPrograms": [toMultiplexProgramSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMultiplexes(
    {abortSignal, ...params}: RequestConfig & s.ListMultiplexesRequest = {},
  ): Promise<s.ListMultiplexesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMultiplexes",
      method: "GET",
      requestUri: "/prod/multiplexes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplexes": [toMultiplexSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOfferings(
    {abortSignal, ...params}: RequestConfig & s.ListOfferingsRequest = {},
  ): Promise<s.ListOfferingsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelClass"] != null) query.set("channelClass", params["ChannelClass"]?.toString() ?? "");
    if (params["ChannelConfiguration"] != null) query.set("channelConfiguration", params["ChannelConfiguration"]?.toString() ?? "");
    if (params["Codec"] != null) query.set("codec", params["Codec"]?.toString() ?? "");
    if (params["Duration"] != null) query.set("duration", params["Duration"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["MaximumBitrate"] != null) query.set("maximumBitrate", params["MaximumBitrate"]?.toString() ?? "");
    if (params["MaximumFramerate"] != null) query.set("maximumFramerate", params["MaximumFramerate"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Resolution"] != null) query.set("resolution", params["Resolution"]?.toString() ?? "");
    if (params["ResourceType"] != null) query.set("resourceType", params["ResourceType"]?.toString() ?? "");
    if (params["SpecialFeature"] != null) query.set("specialFeature", params["SpecialFeature"]?.toString() ?? "");
    if (params["VideoQuality"] != null) query.set("videoQuality", params["VideoQuality"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOfferings",
      method: "GET",
      requestUri: "/prod/offerings",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Offerings": [toOffering],
      },
    }, await resp.json());
  }

  async listReservations(
    {abortSignal, ...params}: RequestConfig & s.ListReservationsRequest = {},
  ): Promise<s.ListReservationsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelClass"] != null) query.set("channelClass", params["ChannelClass"]?.toString() ?? "");
    if (params["Codec"] != null) query.set("codec", params["Codec"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["MaximumBitrate"] != null) query.set("maximumBitrate", params["MaximumBitrate"]?.toString() ?? "");
    if (params["MaximumFramerate"] != null) query.set("maximumFramerate", params["MaximumFramerate"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Resolution"] != null) query.set("resolution", params["Resolution"]?.toString() ?? "");
    if (params["ResourceType"] != null) query.set("resourceType", params["ResourceType"]?.toString() ?? "");
    if (params["SpecialFeature"] != null) query.set("specialFeature", params["SpecialFeature"]?.toString() ?? "");
    if (params["VideoQuality"] != null) query.set("videoQuality", params["VideoQuality"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListReservations",
      method: "GET",
      requestUri: "/prod/reservations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Reservations": [toReservation],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async purchaseOffering(
    {abortSignal, ...params}: RequestConfig & s.PurchaseOfferingRequest,
  ): Promise<s.PurchaseOfferingResponse> {
    const body: jsonP.JSONObject = {
      count: params["Count"],
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      start: params["Start"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseOffering",
      requestUri: cmnP.encodePath`/prod/offerings/${params["OfferingId"]}/purchase`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  async rejectInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & s.RejectInputDeviceTransferRequest,
  ): Promise<s.RejectInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RejectInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/reject`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startChannel(
    {abortSignal, ...params}: RequestConfig & s.StartChannelRequest,
  ): Promise<s.StartChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartChannel",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/start`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async startMultiplex(
    {abortSignal, ...params}: RequestConfig & s.StartMultiplexRequest,
  ): Promise<s.StartMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartMultiplex",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/start`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async stopChannel(
    {abortSignal, ...params}: RequestConfig & s.StopChannelRequest,
  ): Promise<s.StopChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopChannel",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/stop`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async stopMultiplex(
    {abortSignal, ...params}: RequestConfig & s.StopMultiplexRequest,
  ): Promise<s.StopMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopMultiplex",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/stop`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async transferInputDevice(
    {abortSignal, ...params}: RequestConfig & s.TransferInputDeviceRequest,
  ): Promise<s.TransferInputDeviceResponse> {
    const body: jsonP.JSONObject = {
      targetCustomerId: params["TargetCustomerId"],
      transferMessage: params["TransferMessage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransferInputDevice",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/transfer`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateChannelRequest,
  ): Promise<s.UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      cdiInputSpecification: fromCdiInputSpecification(params["CdiInputSpecification"]),
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
      encoderSettings: fromEncoderSettings(params["EncoderSettings"]),
      inputAttachments: params["InputAttachments"]?.map(x => fromInputAttachment(x)),
      inputSpecification: fromInputSpecification(params["InputSpecification"]),
      logLevel: params["LogLevel"],
      name: params["Name"],
      roleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async updateChannelClass(
    {abortSignal, ...params}: RequestConfig & s.UpdateChannelClassRequest,
  ): Promise<s.UpdateChannelClassResponse> {
    const body: jsonP.JSONObject = {
      channelClass: params["ChannelClass"],
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannelClass",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/channelClass`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async updateInput(
    {abortSignal, ...params}: RequestConfig & s.UpdateInputRequest,
  ): Promise<s.UpdateInputResponse> {
    const body: jsonP.JSONObject = {
      destinations: params["Destinations"]?.map(x => fromInputDestinationRequest(x)),
      inputDevices: params["InputDevices"]?.map(x => fromInputDeviceRequest(x)),
      inputSecurityGroups: params["InputSecurityGroups"],
      mediaConnectFlows: params["MediaConnectFlows"]?.map(x => fromMediaConnectFlowRequest(x)),
      name: params["Name"],
      roleArn: params["RoleArn"],
      sources: params["Sources"]?.map(x => fromInputSourceRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInput",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Input": toInput,
      },
    }, await resp.json());
  }

  async updateInputDevice(
    {abortSignal, ...params}: RequestConfig & s.UpdateInputDeviceRequest,
  ): Promise<s.UpdateInputDeviceResponse> {
    const body: jsonP.JSONObject = {
      hdDeviceSettings: fromInputDeviceConfigurableSettings(params["HdDeviceSettings"]),
      name: params["Name"],
      uhdDeviceSettings: fromInputDeviceConfigurableSettings(params["UhdDeviceSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInputDevice",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceConnectionState>(x),
        "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceSettingsSyncState>(x),
        "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceUpdateStatus>(x),
        "HdDeviceSettings": toInputDeviceHdSettings,
        "Id": "s",
        "MacAddress": "s",
        "Name": "s",
        "NetworkSettings": toInputDeviceNetworkSettings,
        "SerialNumber": "s",
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceType>(x),
        "UhdDeviceSettings": toInputDeviceUhdSettings,
      },
    }, await resp.json());
  }

  async updateInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateInputSecurityGroupRequest,
  ): Promise<s.UpdateInputSecurityGroupResponse> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
      whitelistRules: params["WhitelistRules"]?.map(x => fromInputWhitelistRuleCidr(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInputSecurityGroup",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityGroup": toInputSecurityGroup,
      },
    }, await resp.json());
  }

  async updateMultiplex(
    {abortSignal, ...params}: RequestConfig & s.UpdateMultiplexRequest,
  ): Promise<s.UpdateMultiplexResponse> {
    const body: jsonP.JSONObject = {
      multiplexSettings: fromMultiplexSettings(params["MultiplexSettings"]),
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMultiplex",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplex": toMultiplex,
      },
    }, await resp.json());
  }

  async updateMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & s.UpdateMultiplexProgramRequest,
  ): Promise<s.UpdateMultiplexProgramResponse> {
    const body: jsonP.JSONObject = {
      multiplexProgramSettings: fromMultiplexProgramSettings(params["MultiplexProgramSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMultiplexProgram",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexProgram": toMultiplexProgram,
      },
    }, await resp.json());
  }

  async updateReservation(
    {abortSignal, ...params}: RequestConfig & s.UpdateReservationRequest,
  ): Promise<s.UpdateReservationResponse> {
    const body: jsonP.JSONObject = {
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReservation",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until a channel has been created
   * Checks state up to 5 times, 3 seconds apart (about 1 minutes max wait time).
   */
  async waitForChannelCreated(
    params: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelCreated';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "CREATING") continue;
        if (field === "CREATE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel is running
   * Checks state up to 120 times, 5 seconds apart (about 10 minutes max wait time).
   */
  async waitForChannelRunning(
    params: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelRunning';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "RUNNING") return resp;
        if (field === "STARTING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel has is stopped
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForChannelStopped(
    params: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "STOPPING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel has been deleted
   * Checks state up to 84 times, 5 seconds apart (about 7 minutes max wait time).
   */
  async waitForChannelDeleted(
    params: RequestConfig & s.DescribeChannelRequest,
  ): Promise<s.DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelDeleted';
    for (let i = 0; i < 84; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been attached
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForInputAttached(
    params: RequestConfig & s.DescribeInputRequest,
  ): Promise<s.DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputAttached';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "ATTACHED") return resp;
        if (field === "DETACHED") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been detached
   * Checks state up to 84 times, 5 seconds apart (about 7 minutes max wait time).
   */
  async waitForInputDetached(
    params: RequestConfig & s.DescribeInputRequest,
  ): Promise<s.DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputDetached';
    for (let i = 0; i < 84; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "DETACHED") return resp;
        if (field === "CREATING") continue;
        if (field === "ATTACHED") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been deleted
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForInputDeleted(
    params: RequestConfig & s.DescribeInputRequest,
  ): Promise<s.DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputDeleted';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has been created
   * Checks state up to 5 times, 3 seconds apart (about 1 minutes max wait time).
   */
  async waitForMultiplexCreated(
    params: RequestConfig & s.DescribeMultiplexRequest,
  ): Promise<s.DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexCreated';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "CREATING") continue;
        if (field === "CREATE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex is running
   * Checks state up to 120 times, 5 seconds apart (about 10 minutes max wait time).
   */
  async waitForMultiplexRunning(
    params: RequestConfig & s.DescribeMultiplexRequest,
  ): Promise<s.DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexRunning';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "RUNNING") return resp;
        if (field === "STARTING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has is stopped
   * Checks state up to 28 times, 5 seconds apart (about 3 minutes max wait time).
   */
  async waitForMultiplexStopped(
    params: RequestConfig & s.DescribeMultiplexRequest,
  ): Promise<s.DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexStopped';
    for (let i = 0; i < 28; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "STOPPING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has been deleted
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForMultiplexDeleted(
    params: RequestConfig & s.DescribeMultiplexRequest,
  ): Promise<s.DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexDeleted';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function fromBatchScheduleActionCreateRequest(input?: s.BatchScheduleActionCreateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scheduleActions: input["ScheduleActions"]?.map(x => fromScheduleAction(x)),
  }
}

function fromScheduleAction(input?: s.ScheduleAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionName: input["ActionName"],
    scheduleActionSettings: fromScheduleActionSettings(input["ScheduleActionSettings"]),
    scheduleActionStartSettings: fromScheduleActionStartSettings(input["ScheduleActionStartSettings"]),
  }
}
function toScheduleAction(root: jsonP.JSONValue): s.ScheduleAction {
  return jsonP.readObj({
    required: {
      "ActionName": "s",
      "ScheduleActionSettings": toScheduleActionSettings,
      "ScheduleActionStartSettings": toScheduleActionStartSettings,
    },
    optional: {},
  }, root);
}

function fromScheduleActionSettings(input?: s.ScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsId3SegmentTaggingSettings: fromHlsId3SegmentTaggingScheduleActionSettings(input["HlsId3SegmentTaggingSettings"]),
    hlsTimedMetadataSettings: fromHlsTimedMetadataScheduleActionSettings(input["HlsTimedMetadataSettings"]),
    inputPrepareSettings: fromInputPrepareScheduleActionSettings(input["InputPrepareSettings"]),
    inputSwitchSettings: fromInputSwitchScheduleActionSettings(input["InputSwitchSettings"]),
    pauseStateSettings: fromPauseStateScheduleActionSettings(input["PauseStateSettings"]),
    scte35ReturnToNetworkSettings: fromScte35ReturnToNetworkScheduleActionSettings(input["Scte35ReturnToNetworkSettings"]),
    scte35SpliceInsertSettings: fromScte35SpliceInsertScheduleActionSettings(input["Scte35SpliceInsertSettings"]),
    scte35TimeSignalSettings: fromScte35TimeSignalScheduleActionSettings(input["Scte35TimeSignalSettings"]),
    staticImageActivateSettings: fromStaticImageActivateScheduleActionSettings(input["StaticImageActivateSettings"]),
    staticImageDeactivateSettings: fromStaticImageDeactivateScheduleActionSettings(input["StaticImageDeactivateSettings"]),
  }
}
function toScheduleActionSettings(root: jsonP.JSONValue): s.ScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsId3SegmentTaggingSettings": toHlsId3SegmentTaggingScheduleActionSettings,
      "HlsTimedMetadataSettings": toHlsTimedMetadataScheduleActionSettings,
      "InputPrepareSettings": toInputPrepareScheduleActionSettings,
      "InputSwitchSettings": toInputSwitchScheduleActionSettings,
      "PauseStateSettings": toPauseStateScheduleActionSettings,
      "Scte35ReturnToNetworkSettings": toScte35ReturnToNetworkScheduleActionSettings,
      "Scte35SpliceInsertSettings": toScte35SpliceInsertScheduleActionSettings,
      "Scte35TimeSignalSettings": toScte35TimeSignalScheduleActionSettings,
      "StaticImageActivateSettings": toStaticImageActivateScheduleActionSettings,
      "StaticImageDeactivateSettings": toStaticImageDeactivateScheduleActionSettings,
    },
  }, root);
}

function fromHlsId3SegmentTaggingScheduleActionSettings(input?: s.HlsId3SegmentTaggingScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tag: input["Tag"],
  }
}
function toHlsId3SegmentTaggingScheduleActionSettings(root: jsonP.JSONValue): s.HlsId3SegmentTaggingScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Tag": "s",
    },
    optional: {},
  }, root);
}

function fromHlsTimedMetadataScheduleActionSettings(input?: s.HlsTimedMetadataScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3: input["Id3"],
  }
}
function toHlsTimedMetadataScheduleActionSettings(root: jsonP.JSONValue): s.HlsTimedMetadataScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Id3": "s",
    },
    optional: {},
  }, root);
}

function fromInputPrepareScheduleActionSettings(input?: s.InputPrepareScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputAttachmentNameReference: input["InputAttachmentNameReference"],
    inputClippingSettings: fromInputClippingSettings(input["InputClippingSettings"]),
    urlPath: input["UrlPath"],
  }
}
function toInputPrepareScheduleActionSettings(root: jsonP.JSONValue): s.InputPrepareScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputAttachmentNameReference": "s",
      "InputClippingSettings": toInputClippingSettings,
      "UrlPath": ["s"],
    },
  }, root);
}

function fromInputClippingSettings(input?: s.InputClippingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputTimecodeSource: input["InputTimecodeSource"],
    startTimecode: fromStartTimecode(input["StartTimecode"]),
    stopTimecode: fromStopTimecode(input["StopTimecode"]),
  }
}
function toInputClippingSettings(root: jsonP.JSONValue): s.InputClippingSettings {
  return jsonP.readObj({
    required: {
      "InputTimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputTimecodeSource>(x),
    },
    optional: {
      "StartTimecode": toStartTimecode,
      "StopTimecode": toStopTimecode,
    },
  }, root);
}

function fromStartTimecode(input?: s.StartTimecode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timecode: input["Timecode"],
  }
}
function toStartTimecode(root: jsonP.JSONValue): s.StartTimecode {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timecode": "s",
    },
  }, root);
}

function fromStopTimecode(input?: s.StopTimecode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lastFrameClippingBehavior: input["LastFrameClippingBehavior"],
    timecode: input["Timecode"],
  }
}
function toStopTimecode(root: jsonP.JSONValue): s.StopTimecode {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastFrameClippingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastFrameClippingBehavior>(x),
      "Timecode": "s",
    },
  }, root);
}

function fromInputSwitchScheduleActionSettings(input?: s.InputSwitchScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputAttachmentNameReference: input["InputAttachmentNameReference"],
    inputClippingSettings: fromInputClippingSettings(input["InputClippingSettings"]),
    urlPath: input["UrlPath"],
  }
}
function toInputSwitchScheduleActionSettings(root: jsonP.JSONValue): s.InputSwitchScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "InputAttachmentNameReference": "s",
    },
    optional: {
      "InputClippingSettings": toInputClippingSettings,
      "UrlPath": ["s"],
    },
  }, root);
}

function fromPauseStateScheduleActionSettings(input?: s.PauseStateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pipelines: input["Pipelines"]?.map(x => fromPipelinePauseStateSettings(x)),
  }
}
function toPauseStateScheduleActionSettings(root: jsonP.JSONValue): s.PauseStateScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pipelines": [toPipelinePauseStateSettings],
    },
  }, root);
}

function fromPipelinePauseStateSettings(input?: s.PipelinePauseStateSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pipelineId: input["PipelineId"],
  }
}
function toPipelinePauseStateSettings(root: jsonP.JSONValue): s.PipelinePauseStateSettings {
  return jsonP.readObj({
    required: {
      "PipelineId": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineId>(x),
    },
    optional: {},
  }, root);
}

function fromScte35ReturnToNetworkScheduleActionSettings(input?: s.Scte35ReturnToNetworkScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spliceEventId: input["SpliceEventId"],
  }
}
function toScte35ReturnToNetworkScheduleActionSettings(root: jsonP.JSONValue): s.Scte35ReturnToNetworkScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "SpliceEventId": "n",
    },
    optional: {},
  }, root);
}

function fromScte35SpliceInsertScheduleActionSettings(input?: s.Scte35SpliceInsertScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    spliceEventId: input["SpliceEventId"],
  }
}
function toScte35SpliceInsertScheduleActionSettings(root: jsonP.JSONValue): s.Scte35SpliceInsertScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "SpliceEventId": "n",
    },
    optional: {
      "Duration": "n",
    },
  }, root);
}

function fromScte35TimeSignalScheduleActionSettings(input?: s.Scte35TimeSignalScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35Descriptors: input["Scte35Descriptors"]?.map(x => fromScte35Descriptor(x)),
  }
}
function toScte35TimeSignalScheduleActionSettings(root: jsonP.JSONValue): s.Scte35TimeSignalScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Scte35Descriptors": [toScte35Descriptor],
    },
    optional: {},
  }, root);
}

function fromScte35Descriptor(input?: s.Scte35Descriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35DescriptorSettings: fromScte35DescriptorSettings(input["Scte35DescriptorSettings"]),
  }
}
function toScte35Descriptor(root: jsonP.JSONValue): s.Scte35Descriptor {
  return jsonP.readObj({
    required: {
      "Scte35DescriptorSettings": toScte35DescriptorSettings,
    },
    optional: {},
  }, root);
}

function fromScte35DescriptorSettings(input?: s.Scte35DescriptorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    segmentationDescriptorScte35DescriptorSettings: fromScte35SegmentationDescriptor(input["SegmentationDescriptorScte35DescriptorSettings"]),
  }
}
function toScte35DescriptorSettings(root: jsonP.JSONValue): s.Scte35DescriptorSettings {
  return jsonP.readObj({
    required: {
      "SegmentationDescriptorScte35DescriptorSettings": toScte35SegmentationDescriptor,
    },
    optional: {},
  }, root);
}

function fromScte35SegmentationDescriptor(input?: s.Scte35SegmentationDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deliveryRestrictions: fromScte35DeliveryRestrictions(input["DeliveryRestrictions"]),
    segmentNum: input["SegmentNum"],
    segmentationCancelIndicator: input["SegmentationCancelIndicator"],
    segmentationDuration: input["SegmentationDuration"],
    segmentationEventId: input["SegmentationEventId"],
    segmentationTypeId: input["SegmentationTypeId"],
    segmentationUpid: input["SegmentationUpid"],
    segmentationUpidType: input["SegmentationUpidType"],
    segmentsExpected: input["SegmentsExpected"],
    subSegmentNum: input["SubSegmentNum"],
    subSegmentsExpected: input["SubSegmentsExpected"],
  }
}
function toScte35SegmentationDescriptor(root: jsonP.JSONValue): s.Scte35SegmentationDescriptor {
  return jsonP.readObj({
    required: {
      "SegmentationCancelIndicator": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35SegmentationCancelIndicator>(x),
      "SegmentationEventId": "n",
    },
    optional: {
      "DeliveryRestrictions": toScte35DeliveryRestrictions,
      "SegmentNum": "n",
      "SegmentationDuration": "n",
      "SegmentationTypeId": "n",
      "SegmentationUpid": "s",
      "SegmentationUpidType": "n",
      "SegmentsExpected": "n",
      "SubSegmentNum": "n",
      "SubSegmentsExpected": "n",
    },
  }, root);
}

function fromScte35DeliveryRestrictions(input?: s.Scte35DeliveryRestrictions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveAllowedFlag: input["ArchiveAllowedFlag"],
    deviceRestrictions: input["DeviceRestrictions"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35DeliveryRestrictions(root: jsonP.JSONValue): s.Scte35DeliveryRestrictions {
  return jsonP.readObj({
    required: {
      "ArchiveAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35ArchiveAllowedFlag>(x),
      "DeviceRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35DeviceRestrictions>(x),
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35NoRegionalBlackoutFlag>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35WebDeliveryAllowedFlag>(x),
    },
    optional: {},
  }, root);
}

function fromStaticImageActivateScheduleActionSettings(input?: s.StaticImageActivateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    fadeIn: input["FadeIn"],
    fadeOut: input["FadeOut"],
    height: input["Height"],
    image: fromInputLocation(input["Image"]),
    imageX: input["ImageX"],
    imageY: input["ImageY"],
    layer: input["Layer"],
    opacity: input["Opacity"],
    width: input["Width"],
  }
}
function toStaticImageActivateScheduleActionSettings(root: jsonP.JSONValue): s.StaticImageActivateScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Image": toInputLocation,
    },
    optional: {
      "Duration": "n",
      "FadeIn": "n",
      "FadeOut": "n",
      "Height": "n",
      "ImageX": "n",
      "ImageY": "n",
      "Layer": "n",
      "Opacity": "n",
      "Width": "n",
    },
  }, root);
}

function fromInputLocation(input?: s.InputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    uri: input["Uri"],
    username: input["Username"],
  }
}
function toInputLocation(root: jsonP.JSONValue): s.InputLocation {
  return jsonP.readObj({
    required: {
      "Uri": "s",
    },
    optional: {
      "PasswordParam": "s",
      "Username": "s",
    },
  }, root);
}

function fromStaticImageDeactivateScheduleActionSettings(input?: s.StaticImageDeactivateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fadeOut: input["FadeOut"],
    layer: input["Layer"],
  }
}
function toStaticImageDeactivateScheduleActionSettings(root: jsonP.JSONValue): s.StaticImageDeactivateScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FadeOut": "n",
      "Layer": "n",
    },
  }, root);
}

function fromScheduleActionStartSettings(input?: s.ScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fixedModeScheduleActionStartSettings: fromFixedModeScheduleActionStartSettings(input["FixedModeScheduleActionStartSettings"]),
    followModeScheduleActionStartSettings: fromFollowModeScheduleActionStartSettings(input["FollowModeScheduleActionStartSettings"]),
    immediateModeScheduleActionStartSettings: fromImmediateModeScheduleActionStartSettings(input["ImmediateModeScheduleActionStartSettings"]),
  }
}
function toScheduleActionStartSettings(root: jsonP.JSONValue): s.ScheduleActionStartSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FixedModeScheduleActionStartSettings": toFixedModeScheduleActionStartSettings,
      "FollowModeScheduleActionStartSettings": toFollowModeScheduleActionStartSettings,
      "ImmediateModeScheduleActionStartSettings": toImmediateModeScheduleActionStartSettings,
    },
  }, root);
}

function fromFixedModeScheduleActionStartSettings(input?: s.FixedModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    time: input["Time"],
  }
}
function toFixedModeScheduleActionStartSettings(root: jsonP.JSONValue): s.FixedModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {
      "Time": "s",
    },
    optional: {},
  }, root);
}

function fromFollowModeScheduleActionStartSettings(input?: s.FollowModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    followPoint: input["FollowPoint"],
    referenceActionName: input["ReferenceActionName"],
  }
}
function toFollowModeScheduleActionStartSettings(root: jsonP.JSONValue): s.FollowModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {
      "FollowPoint": (x: jsonP.JSONValue) => cmnP.readEnum<s.FollowPoint>(x),
      "ReferenceActionName": "s",
    },
    optional: {},
  }, root);
}

function fromImmediateModeScheduleActionStartSettings(input?: s.ImmediateModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toImmediateModeScheduleActionStartSettings(root: jsonP.JSONValue): s.ImmediateModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromBatchScheduleActionDeleteRequest(input?: s.BatchScheduleActionDeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionNames: input["ActionNames"],
  }
}

function fromCdiInputSpecification(input?: s.CdiInputSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    resolution: input["Resolution"],
  }
}
function toCdiInputSpecification(root: jsonP.JSONValue): s.CdiInputSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.CdiInputResolution>(x),
    },
  }, root);
}

function fromOutputDestination(input?: s.OutputDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
    mediaPackageSettings: input["MediaPackageSettings"]?.map(x => fromMediaPackageOutputDestinationSettings(x)),
    multiplexSettings: fromMultiplexProgramChannelDestinationSettings(input["MultiplexSettings"]),
    settings: input["Settings"]?.map(x => fromOutputDestinationSettings(x)),
  }
}
function toOutputDestination(root: jsonP.JSONValue): s.OutputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "MediaPackageSettings": [toMediaPackageOutputDestinationSettings],
      "MultiplexSettings": toMultiplexProgramChannelDestinationSettings,
      "Settings": [toOutputDestinationSettings],
    },
  }, root);
}

function fromMediaPackageOutputDestinationSettings(input?: s.MediaPackageOutputDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelId: input["ChannelId"],
  }
}
function toMediaPackageOutputDestinationSettings(root: jsonP.JSONValue): s.MediaPackageOutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
    },
  }, root);
}

function fromMultiplexProgramChannelDestinationSettings(input?: s.MultiplexProgramChannelDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    multiplexId: input["MultiplexId"],
    programName: input["ProgramName"],
  }
}
function toMultiplexProgramChannelDestinationSettings(root: jsonP.JSONValue): s.MultiplexProgramChannelDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultiplexId": "s",
      "ProgramName": "s",
    },
  }, root);
}

function fromOutputDestinationSettings(input?: s.OutputDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    streamName: input["StreamName"],
    url: input["Url"],
    username: input["Username"],
  }
}
function toOutputDestinationSettings(root: jsonP.JSONValue): s.OutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PasswordParam": "s",
      "StreamName": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

function fromEncoderSettings(input?: s.EncoderSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    availConfiguration: fromAvailConfiguration(input["AvailConfiguration"]),
    blackoutSlate: fromBlackoutSlate(input["BlackoutSlate"]),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescription(x)),
    featureActivations: fromFeatureActivations(input["FeatureActivations"]),
    globalConfiguration: fromGlobalConfiguration(input["GlobalConfiguration"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    videoDescriptions: input["VideoDescriptions"]?.map(x => fromVideoDescription(x)),
  }
}
function toEncoderSettings(root: jsonP.JSONValue): s.EncoderSettings {
  return jsonP.readObj({
    required: {
      "AudioDescriptions": [toAudioDescription],
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "VideoDescriptions": [toVideoDescription],
    },
    optional: {
      "AvailBlanking": toAvailBlanking,
      "AvailConfiguration": toAvailConfiguration,
      "BlackoutSlate": toBlackoutSlate,
      "CaptionDescriptions": [toCaptionDescription],
      "FeatureActivations": toFeatureActivations,
      "GlobalConfiguration": toGlobalConfiguration,
      "NielsenConfiguration": toNielsenConfiguration,
    },
  }, root);
}

function fromAudioDescription(input?: s.AudioDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioNormalizationSettings: fromAudioNormalizationSettings(input["AudioNormalizationSettings"]),
    audioSelectorName: input["AudioSelectorName"],
    audioType: input["AudioType"],
    audioTypeControl: input["AudioTypeControl"],
    codecSettings: fromAudioCodecSettings(input["CodecSettings"]),
    languageCode: input["LanguageCode"],
    languageCodeControl: input["LanguageCodeControl"],
    name: input["Name"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    streamName: input["StreamName"],
  }
}
function toAudioDescription(root: jsonP.JSONValue): s.AudioDescription {
  return jsonP.readObj({
    required: {
      "AudioSelectorName": "s",
      "Name": "s",
    },
    optional: {
      "AudioNormalizationSettings": toAudioNormalizationSettings,
      "AudioType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioType>(x),
      "AudioTypeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioDescriptionAudioTypeControl>(x),
      "CodecSettings": toAudioCodecSettings,
      "LanguageCode": "s",
      "LanguageCodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioDescriptionLanguageCodeControl>(x),
      "RemixSettings": toRemixSettings,
      "StreamName": "s",
    },
  }, root);
}

function fromAudioNormalizationSettings(input?: s.AudioNormalizationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    algorithmControl: input["AlgorithmControl"],
    targetLkfs: input["TargetLkfs"],
  }
}
function toAudioNormalizationSettings(root: jsonP.JSONValue): s.AudioNormalizationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationAlgorithm>(x),
      "AlgorithmControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioNormalizationAlgorithmControl>(x),
      "TargetLkfs": "n",
    },
  }, root);
}

function fromAudioCodecSettings(input?: s.AudioCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aacSettings: fromAacSettings(input["AacSettings"]),
    ac3Settings: fromAc3Settings(input["Ac3Settings"]),
    eac3Settings: fromEac3Settings(input["Eac3Settings"]),
    mp2Settings: fromMp2Settings(input["Mp2Settings"]),
    passThroughSettings: fromPassThroughSettings(input["PassThroughSettings"]),
    wavSettings: fromWavSettings(input["WavSettings"]),
  }
}
function toAudioCodecSettings(root: jsonP.JSONValue): s.AudioCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AacSettings": toAacSettings,
      "Ac3Settings": toAc3Settings,
      "Eac3Settings": toEac3Settings,
      "Mp2Settings": toMp2Settings,
      "PassThroughSettings": toPassThroughSettings,
      "WavSettings": toWavSettings,
    },
  }, root);
}

function fromAacSettings(input?: s.AacSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    codingMode: input["CodingMode"],
    inputType: input["InputType"],
    profile: input["Profile"],
    rateControlMode: input["RateControlMode"],
    rawFormat: input["RawFormat"],
    sampleRate: input["SampleRate"],
    spec: input["Spec"],
    vbrQuality: input["VbrQuality"],
  }
}
function toAacSettings(root: jsonP.JSONValue): s.AacSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacCodingMode>(x),
      "InputType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacInputType>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacProfile>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacRateControlMode>(x),
      "RawFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacRawFormat>(x),
      "SampleRate": "n",
      "Spec": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacSpec>(x),
      "VbrQuality": (x: jsonP.JSONValue) => cmnP.readEnum<s.AacVbrQuality>(x),
    },
  }, root);
}

function fromAc3Settings(input?: s.Ac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialnorm: input["Dialnorm"],
    drcProfile: input["DrcProfile"],
    lfeFilter: input["LfeFilter"],
    metadataControl: input["MetadataControl"],
  }
}
function toAc3Settings(root: jsonP.JSONValue): s.Ac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3CodingMode>(x),
      "Dialnorm": "n",
      "DrcProfile": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3DrcProfile>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3LfeFilter>(x),
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Ac3MetadataControl>(x),
    },
  }, root);
}

function fromEac3Settings(input?: s.Eac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attenuationControl: input["AttenuationControl"],
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dcFilter: input["DcFilter"],
    dialnorm: input["Dialnorm"],
    drcLine: input["DrcLine"],
    drcRf: input["DrcRf"],
    lfeControl: input["LfeControl"],
    lfeFilter: input["LfeFilter"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    metadataControl: input["MetadataControl"],
    passthroughControl: input["PassthroughControl"],
    phaseControl: input["PhaseControl"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
    surroundMode: input["SurroundMode"],
  }
}
function toEac3Settings(root: jsonP.JSONValue): s.Eac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttenuationControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3AttenuationControl>(x),
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3CodingMode>(x),
      "DcFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DcFilter>(x),
      "Dialnorm": "n",
      "DrcLine": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DrcLine>(x),
      "DrcRf": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3DrcRf>(x),
      "LfeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3LfeControl>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3LfeFilter>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3MetadataControl>(x),
      "PassthroughControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3PassthroughControl>(x),
      "PhaseControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3PhaseControl>(x),
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3StereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3SurroundExMode>(x),
      "SurroundMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Eac3SurroundMode>(x),
    },
  }, root);
}

function fromMp2Settings(input?: s.Mp2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    codingMode: input["CodingMode"],
    sampleRate: input["SampleRate"],
  }
}
function toMp2Settings(root: jsonP.JSONValue): s.Mp2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mp2CodingMode>(x),
      "SampleRate": "n",
    },
  }, root);
}

function fromPassThroughSettings(input?: s.PassThroughSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toPassThroughSettings(root: jsonP.JSONValue): s.PassThroughSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromWavSettings(input?: s.WavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    codingMode: input["CodingMode"],
    sampleRate: input["SampleRate"],
  }
}
function toWavSettings(root: jsonP.JSONValue): s.WavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.WavCodingMode>(x),
      "SampleRate": "n",
    },
  }, root);
}

function fromRemixSettings(input?: s.RemixSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelMappings: input["ChannelMappings"]?.map(x => fromAudioChannelMapping(x)),
    channelsIn: input["ChannelsIn"],
    channelsOut: input["ChannelsOut"],
  }
}
function toRemixSettings(root: jsonP.JSONValue): s.RemixSettings {
  return jsonP.readObj({
    required: {
      "ChannelMappings": [toAudioChannelMapping],
    },
    optional: {
      "ChannelsIn": "n",
      "ChannelsOut": "n",
    },
  }, root);
}

function fromAudioChannelMapping(input?: s.AudioChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputChannelLevels: input["InputChannelLevels"]?.map(x => fromInputChannelLevel(x)),
    outputChannel: input["OutputChannel"],
  }
}
function toAudioChannelMapping(root: jsonP.JSONValue): s.AudioChannelMapping {
  return jsonP.readObj({
    required: {
      "InputChannelLevels": [toInputChannelLevel],
      "OutputChannel": "n",
    },
    optional: {},
  }, root);
}

function fromInputChannelLevel(input?: s.InputChannelLevel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    gain: input["Gain"],
    inputChannel: input["InputChannel"],
  }
}
function toInputChannelLevel(root: jsonP.JSONValue): s.InputChannelLevel {
  return jsonP.readObj({
    required: {
      "Gain": "n",
      "InputChannel": "n",
    },
    optional: {},
  }, root);
}

function fromAvailBlanking(input?: s.AvailBlanking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availBlankingImage: fromInputLocation(input["AvailBlankingImage"]),
    state: input["State"],
  }
}
function toAvailBlanking(root: jsonP.JSONValue): s.AvailBlanking {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailBlankingImage": toInputLocation,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.AvailBlankingState>(x),
    },
  }, root);
}

function fromAvailConfiguration(input?: s.AvailConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availSettings: fromAvailSettings(input["AvailSettings"]),
  }
}
function toAvailConfiguration(root: jsonP.JSONValue): s.AvailConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailSettings": toAvailSettings,
    },
  }, root);
}

function fromAvailSettings(input?: s.AvailSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35SpliceInsert: fromScte35SpliceInsert(input["Scte35SpliceInsert"]),
    scte35TimeSignalApos: fromScte35TimeSignalApos(input["Scte35TimeSignalApos"]),
  }
}
function toAvailSettings(root: jsonP.JSONValue): s.AvailSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scte35SpliceInsert": toScte35SpliceInsert,
      "Scte35TimeSignalApos": toScte35TimeSignalApos,
    },
  }, root);
}

function fromScte35SpliceInsert(input?: s.Scte35SpliceInsert | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35SpliceInsert(root: jsonP.JSONValue): s.Scte35SpliceInsert {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35SpliceInsertNoRegionalBlackoutBehavior>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35SpliceInsertWebDeliveryAllowedBehavior>(x),
    },
  }, root);
}

function fromScte35TimeSignalApos(input?: s.Scte35TimeSignalApos | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35TimeSignalApos(root: jsonP.JSONValue): s.Scte35TimeSignalApos {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35AposNoRegionalBlackoutBehavior>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte35AposWebDeliveryAllowedBehavior>(x),
    },
  }, root);
}

function fromBlackoutSlate(input?: s.BlackoutSlate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackoutSlateImage: fromInputLocation(input["BlackoutSlateImage"]),
    networkEndBlackout: input["NetworkEndBlackout"],
    networkEndBlackoutImage: fromInputLocation(input["NetworkEndBlackoutImage"]),
    networkId: input["NetworkId"],
    state: input["State"],
  }
}
function toBlackoutSlate(root: jsonP.JSONValue): s.BlackoutSlate {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackoutSlateImage": toInputLocation,
      "NetworkEndBlackout": (x: jsonP.JSONValue) => cmnP.readEnum<s.BlackoutSlateNetworkEndBlackout>(x),
      "NetworkEndBlackoutImage": toInputLocation,
      "NetworkId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.BlackoutSlateState>(x),
    },
  }, root);
}

function fromCaptionDescription(input?: s.CaptionDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionSelectorName: input["CaptionSelectorName"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
    name: input["Name"],
  }
}
function toCaptionDescription(root: jsonP.JSONValue): s.CaptionDescription {
  return jsonP.readObj({
    required: {
      "CaptionSelectorName": "s",
      "Name": "s",
    },
    optional: {
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": "s",
      "LanguageDescription": "s",
    },
  }, root);
}

function fromCaptionDestinationSettings(input?: s.CaptionDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aribDestinationSettings: fromAribDestinationSettings(input["AribDestinationSettings"]),
    burnInDestinationSettings: fromBurnInDestinationSettings(input["BurnInDestinationSettings"]),
    dvbSubDestinationSettings: fromDvbSubDestinationSettings(input["DvbSubDestinationSettings"]),
    ebuTtDDestinationSettings: fromEbuTtDDestinationSettings(input["EbuTtDDestinationSettings"]),
    embeddedDestinationSettings: fromEmbeddedDestinationSettings(input["EmbeddedDestinationSettings"]),
    embeddedPlusScte20DestinationSettings: fromEmbeddedPlusScte20DestinationSettings(input["EmbeddedPlusScte20DestinationSettings"]),
    rtmpCaptionInfoDestinationSettings: fromRtmpCaptionInfoDestinationSettings(input["RtmpCaptionInfoDestinationSettings"]),
    scte20PlusEmbeddedDestinationSettings: fromScte20PlusEmbeddedDestinationSettings(input["Scte20PlusEmbeddedDestinationSettings"]),
    scte27DestinationSettings: fromScte27DestinationSettings(input["Scte27DestinationSettings"]),
    smpteTtDestinationSettings: fromSmpteTtDestinationSettings(input["SmpteTtDestinationSettings"]),
    teletextDestinationSettings: fromTeletextDestinationSettings(input["TeletextDestinationSettings"]),
    ttmlDestinationSettings: fromTtmlDestinationSettings(input["TtmlDestinationSettings"]),
    webvttDestinationSettings: fromWebvttDestinationSettings(input["WebvttDestinationSettings"]),
  }
}
function toCaptionDestinationSettings(root: jsonP.JSONValue): s.CaptionDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AribDestinationSettings": toAribDestinationSettings,
      "BurnInDestinationSettings": toBurnInDestinationSettings,
      "DvbSubDestinationSettings": toDvbSubDestinationSettings,
      "EbuTtDDestinationSettings": toEbuTtDDestinationSettings,
      "EmbeddedDestinationSettings": toEmbeddedDestinationSettings,
      "EmbeddedPlusScte20DestinationSettings": toEmbeddedPlusScte20DestinationSettings,
      "RtmpCaptionInfoDestinationSettings": toRtmpCaptionInfoDestinationSettings,
      "Scte20PlusEmbeddedDestinationSettings": toScte20PlusEmbeddedDestinationSettings,
      "Scte27DestinationSettings": toScte27DestinationSettings,
      "SmpteTtDestinationSettings": toSmpteTtDestinationSettings,
      "TeletextDestinationSettings": toTeletextDestinationSettings,
      "TtmlDestinationSettings": toTtmlDestinationSettings,
      "WebvttDestinationSettings": toWebvttDestinationSettings,
    },
  }, root);
}

function fromAribDestinationSettings(input?: s.AribDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAribDestinationSettings(root: jsonP.JSONValue): s.AribDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromBurnInDestinationSettings(input?: s.BurnInDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    font: fromInputLocation(input["Font"]),
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextGridControl: input["TeletextGridControl"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toBurnInDestinationSettings(root: jsonP.JSONValue): s.BurnInDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "Font": toInputLocation,
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontSize": "s",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextGridControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.BurnInTeletextGridControl>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

function fromDvbSubDestinationSettings(input?: s.DvbSubDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    font: fromInputLocation(input["Font"]),
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextGridControl: input["TeletextGridControl"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toDvbSubDestinationSettings(root: jsonP.JSONValue): s.DvbSubDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "Font": toInputLocation,
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontSize": "s",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextGridControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSubDestinationTeletextGridControl>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

function fromEbuTtDDestinationSettings(input?: s.EbuTtDDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fillLineGap: input["FillLineGap"],
    fontFamily: input["FontFamily"],
    styleControl: input["StyleControl"],
  }
}
function toEbuTtDDestinationSettings(root: jsonP.JSONValue): s.EbuTtDDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FillLineGap": (x: jsonP.JSONValue) => cmnP.readEnum<s.EbuTtDFillLineGapControl>(x),
      "FontFamily": "s",
      "StyleControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.EbuTtDDestinationStyleControl>(x),
    },
  }, root);
}

function fromEmbeddedDestinationSettings(input?: s.EmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toEmbeddedDestinationSettings(root: jsonP.JSONValue): s.EmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromEmbeddedPlusScte20DestinationSettings(input?: s.EmbeddedPlusScte20DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toEmbeddedPlusScte20DestinationSettings(root: jsonP.JSONValue): s.EmbeddedPlusScte20DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromRtmpCaptionInfoDestinationSettings(input?: s.RtmpCaptionInfoDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRtmpCaptionInfoDestinationSettings(root: jsonP.JSONValue): s.RtmpCaptionInfoDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromScte20PlusEmbeddedDestinationSettings(input?: s.Scte20PlusEmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toScte20PlusEmbeddedDestinationSettings(root: jsonP.JSONValue): s.Scte20PlusEmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromScte27DestinationSettings(input?: s.Scte27DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toScte27DestinationSettings(root: jsonP.JSONValue): s.Scte27DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromSmpteTtDestinationSettings(input?: s.SmpteTtDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toSmpteTtDestinationSettings(root: jsonP.JSONValue): s.SmpteTtDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromTeletextDestinationSettings(input?: s.TeletextDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toTeletextDestinationSettings(root: jsonP.JSONValue): s.TeletextDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromTtmlDestinationSettings(input?: s.TtmlDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    styleControl: input["StyleControl"],
  }
}
function toTtmlDestinationSettings(root: jsonP.JSONValue): s.TtmlDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StyleControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.TtmlDestinationStyleControl>(x),
    },
  }, root);
}

function fromWebvttDestinationSettings(input?: s.WebvttDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toWebvttDestinationSettings(root: jsonP.JSONValue): s.WebvttDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromFeatureActivations(input?: s.FeatureActivations | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputPrepareScheduleActions: input["InputPrepareScheduleActions"],
  }
}
function toFeatureActivations(root: jsonP.JSONValue): s.FeatureActivations {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputPrepareScheduleActions": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeatureActivationsInputPrepareScheduleActions>(x),
    },
  }, root);
}

function fromGlobalConfiguration(input?: s.GlobalConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    initialAudioGain: input["InitialAudioGain"],
    inputEndAction: input["InputEndAction"],
    inputLossBehavior: fromInputLossBehavior(input["InputLossBehavior"]),
    outputLockingMode: input["OutputLockingMode"],
    outputTimingSource: input["OutputTimingSource"],
    supportLowFramerateInputs: input["SupportLowFramerateInputs"],
  }
}
function toGlobalConfiguration(root: jsonP.JSONValue): s.GlobalConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InitialAudioGain": "n",
      "InputEndAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.GlobalConfigurationInputEndAction>(x),
      "InputLossBehavior": toInputLossBehavior,
      "OutputLockingMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.GlobalConfigurationOutputLockingMode>(x),
      "OutputTimingSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.GlobalConfigurationOutputTimingSource>(x),
      "SupportLowFramerateInputs": (x: jsonP.JSONValue) => cmnP.readEnum<s.GlobalConfigurationLowFramerateInputs>(x),
    },
  }, root);
}

function fromInputLossBehavior(input?: s.InputLossBehavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackFrameMsec: input["BlackFrameMsec"],
    inputLossImageColor: input["InputLossImageColor"],
    inputLossImageSlate: fromInputLocation(input["InputLossImageSlate"]),
    inputLossImageType: input["InputLossImageType"],
    repeatFrameMsec: input["RepeatFrameMsec"],
  }
}
function toInputLossBehavior(root: jsonP.JSONValue): s.InputLossBehavior {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackFrameMsec": "n",
      "InputLossImageColor": "s",
      "InputLossImageSlate": toInputLocation,
      "InputLossImageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputLossImageType>(x),
      "RepeatFrameMsec": "n",
    },
  }, root);
}

function fromNielsenConfiguration(input?: s.NielsenConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    distributorId: input["DistributorId"],
    nielsenPcmToId3Tagging: input["NielsenPcmToId3Tagging"],
  }
}
function toNielsenConfiguration(root: jsonP.JSONValue): s.NielsenConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "DistributorId": "s",
      "NielsenPcmToId3Tagging": (x: jsonP.JSONValue) => cmnP.readEnum<s.NielsenPcmToId3TaggingState>(x),
    },
  }, root);
}

function fromOutputGroup(input?: s.OutputGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    outputGroupSettings: fromOutputGroupSettings(input["OutputGroupSettings"]),
    outputs: input["Outputs"]?.map(x => fromOutput(x)),
  }
}
function toOutputGroup(root: jsonP.JSONValue): s.OutputGroup {
  return jsonP.readObj({
    required: {
      "OutputGroupSettings": toOutputGroupSettings,
      "Outputs": [toOutput],
    },
    optional: {
      "Name": "s",
    },
  }, root);
}

function fromOutputGroupSettings(input?: s.OutputGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveGroupSettings: fromArchiveGroupSettings(input["ArchiveGroupSettings"]),
    frameCaptureGroupSettings: fromFrameCaptureGroupSettings(input["FrameCaptureGroupSettings"]),
    hlsGroupSettings: fromHlsGroupSettings(input["HlsGroupSettings"]),
    mediaPackageGroupSettings: fromMediaPackageGroupSettings(input["MediaPackageGroupSettings"]),
    msSmoothGroupSettings: fromMsSmoothGroupSettings(input["MsSmoothGroupSettings"]),
    multiplexGroupSettings: fromMultiplexGroupSettings(input["MultiplexGroupSettings"]),
    rtmpGroupSettings: fromRtmpGroupSettings(input["RtmpGroupSettings"]),
    udpGroupSettings: fromUdpGroupSettings(input["UdpGroupSettings"]),
  }
}
function toOutputGroupSettings(root: jsonP.JSONValue): s.OutputGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchiveGroupSettings": toArchiveGroupSettings,
      "FrameCaptureGroupSettings": toFrameCaptureGroupSettings,
      "HlsGroupSettings": toHlsGroupSettings,
      "MediaPackageGroupSettings": toMediaPackageGroupSettings,
      "MsSmoothGroupSettings": toMsSmoothGroupSettings,
      "MultiplexGroupSettings": toMultiplexGroupSettings,
      "RtmpGroupSettings": toRtmpGroupSettings,
      "UdpGroupSettings": toUdpGroupSettings,
    },
  }, root);
}

function fromArchiveGroupSettings(input?: s.ArchiveGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
    rolloverInterval: input["RolloverInterval"],
  }
}
function toArchiveGroupSettings(root: jsonP.JSONValue): s.ArchiveGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "RolloverInterval": "n",
    },
  }, root);
}

function fromOutputLocationRef(input?: s.OutputLocationRef | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinationRefId: input["DestinationRefId"],
  }
}
function toOutputLocationRef(root: jsonP.JSONValue): s.OutputLocationRef {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationRefId": "s",
    },
  }, root);
}

function fromFrameCaptureGroupSettings(input?: s.FrameCaptureGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toFrameCaptureGroupSettings(root: jsonP.JSONValue): s.FrameCaptureGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

function fromHlsGroupSettings(input?: s.HlsGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    baseUrlContent: input["BaseUrlContent"],
    baseUrlContent1: input["BaseUrlContent1"],
    baseUrlManifest: input["BaseUrlManifest"],
    baseUrlManifest1: input["BaseUrlManifest1"],
    captionLanguageMappings: input["CaptionLanguageMappings"]?.map(x => fromCaptionLanguageMapping(x)),
    captionLanguageSetting: input["CaptionLanguageSetting"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    constantIv: input["ConstantIv"],
    destination: fromOutputLocationRef(input["Destination"]),
    directoryStructure: input["DirectoryStructure"],
    discontinuityTags: input["DiscontinuityTags"],
    encryptionType: input["EncryptionType"],
    hlsCdnSettings: fromHlsCdnSettings(input["HlsCdnSettings"]),
    hlsId3SegmentTagging: input["HlsId3SegmentTagging"],
    iFrameOnlyPlaylists: input["IFrameOnlyPlaylists"],
    incompleteSegmentBehavior: input["IncompleteSegmentBehavior"],
    indexNSegments: input["IndexNSegments"],
    inputLossAction: input["InputLossAction"],
    ivInManifest: input["IvInManifest"],
    ivSource: input["IvSource"],
    keepSegments: input["KeepSegments"],
    keyFormat: input["KeyFormat"],
    keyFormatVersions: input["KeyFormatVersions"],
    keyProviderSettings: fromKeyProviderSettings(input["KeyProviderSettings"]),
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minSegmentLength: input["MinSegmentLength"],
    mode: input["Mode"],
    outputSelection: input["OutputSelection"],
    programDateTime: input["ProgramDateTime"],
    programDateTimePeriod: input["ProgramDateTimePeriod"],
    redundantManifest: input["RedundantManifest"],
    segmentLength: input["SegmentLength"],
    segmentationMode: input["SegmentationMode"],
    segmentsPerSubdirectory: input["SegmentsPerSubdirectory"],
    streamInfResolution: input["StreamInfResolution"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
    timestampDeltaMilliseconds: input["TimestampDeltaMilliseconds"],
    tsFileMode: input["TsFileMode"],
  }
}
function toHlsGroupSettings(root: jsonP.JSONValue): s.HlsGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAdMarkers>(x)],
      "BaseUrlContent": "s",
      "BaseUrlContent1": "s",
      "BaseUrlManifest": "s",
      "BaseUrlManifest1": "s",
      "CaptionLanguageMappings": [toCaptionLanguageMapping],
      "CaptionLanguageSetting": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsCaptionLanguageSetting>(x),
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsCodecSpecification>(x),
      "ConstantIv": "s",
      "DirectoryStructure": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsDirectoryStructure>(x),
      "DiscontinuityTags": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsDiscontinuityTags>(x),
      "EncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsEncryptionType>(x),
      "HlsCdnSettings": toHlsCdnSettings,
      "HlsId3SegmentTagging": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsId3SegmentTaggingState>(x),
      "IFrameOnlyPlaylists": (x: jsonP.JSONValue) => cmnP.readEnum<s.IFrameOnlyPlaylistType>(x),
      "IncompleteSegmentBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsIncompleteSegmentBehavior>(x),
      "IndexNSegments": "n",
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputLossActionForHlsOut>(x),
      "IvInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsIvInManifest>(x),
      "IvSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsIvSource>(x),
      "KeepSegments": "n",
      "KeyFormat": "s",
      "KeyFormatVersions": "s",
      "KeyProviderSettings": toKeyProviderSettings,
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsManifestDurationFormat>(x),
      "MinSegmentLength": "n",
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsMode>(x),
      "OutputSelection": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsOutputSelection>(x),
      "ProgramDateTime": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsProgramDateTime>(x),
      "ProgramDateTimePeriod": "n",
      "RedundantManifest": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsRedundantManifest>(x),
      "SegmentLength": "n",
      "SegmentationMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsSegmentationMode>(x),
      "SegmentsPerSubdirectory": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsStreamInfResolution>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
      "TimestampDeltaMilliseconds": "n",
      "TsFileMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsTsFileMode>(x),
    },
  }, root);
}

function fromCaptionLanguageMapping(input?: s.CaptionLanguageMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionChannel: input["CaptionChannel"],
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionLanguageMapping(root: jsonP.JSONValue): s.CaptionLanguageMapping {
  return jsonP.readObj({
    required: {
      "CaptionChannel": "n",
      "LanguageCode": "s",
      "LanguageDescription": "s",
    },
    optional: {},
  }, root);
}

function fromHlsCdnSettings(input?: s.HlsCdnSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsAkamaiSettings: fromHlsAkamaiSettings(input["HlsAkamaiSettings"]),
    hlsBasicPutSettings: fromHlsBasicPutSettings(input["HlsBasicPutSettings"]),
    hlsMediaStoreSettings: fromHlsMediaStoreSettings(input["HlsMediaStoreSettings"]),
    hlsWebdavSettings: fromHlsWebdavSettings(input["HlsWebdavSettings"]),
  }
}
function toHlsCdnSettings(root: jsonP.JSONValue): s.HlsCdnSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsAkamaiSettings": toHlsAkamaiSettings,
      "HlsBasicPutSettings": toHlsBasicPutSettings,
      "HlsMediaStoreSettings": toHlsMediaStoreSettings,
      "HlsWebdavSettings": toHlsWebdavSettings,
    },
  }, root);
}

function fromHlsAkamaiSettings(input?: s.HlsAkamaiSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    httpTransferMode: input["HttpTransferMode"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
    salt: input["Salt"],
    token: input["Token"],
  }
}
function toHlsAkamaiSettings(root: jsonP.JSONValue): s.HlsAkamaiSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "HttpTransferMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsAkamaiHttpTransferMode>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
      "Salt": "s",
      "Token": "s",
    },
  }, root);
}

function fromHlsBasicPutSettings(input?: s.HlsBasicPutSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsBasicPutSettings(root: jsonP.JSONValue): s.HlsBasicPutSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

function fromHlsMediaStoreSettings(input?: s.HlsMediaStoreSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    mediaStoreStorageClass: input["MediaStoreStorageClass"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsMediaStoreSettings(root: jsonP.JSONValue): s.HlsMediaStoreSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "MediaStoreStorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsMediaStoreStorageClass>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

function fromHlsWebdavSettings(input?: s.HlsWebdavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    httpTransferMode: input["HttpTransferMode"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsWebdavSettings(root: jsonP.JSONValue): s.HlsWebdavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "HttpTransferMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsWebdavHttpTransferMode>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

function fromKeyProviderSettings(input?: s.KeyProviderSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    staticKeySettings: fromStaticKeySettings(input["StaticKeySettings"]),
  }
}
function toKeyProviderSettings(root: jsonP.JSONValue): s.KeyProviderSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StaticKeySettings": toStaticKeySettings,
    },
  }, root);
}

function fromStaticKeySettings(input?: s.StaticKeySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyProviderServer: fromInputLocation(input["KeyProviderServer"]),
    staticKeyValue: input["StaticKeyValue"],
  }
}
function toStaticKeySettings(root: jsonP.JSONValue): s.StaticKeySettings {
  return jsonP.readObj({
    required: {
      "StaticKeyValue": "s",
    },
    optional: {
      "KeyProviderServer": toInputLocation,
    },
  }, root);
}

function fromMediaPackageGroupSettings(input?: s.MediaPackageGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toMediaPackageGroupSettings(root: jsonP.JSONValue): s.MediaPackageGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

function fromMsSmoothGroupSettings(input?: s.MsSmoothGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acquisitionPointId: input["AcquisitionPointId"],
    audioOnlyTimecodeControl: input["AudioOnlyTimecodeControl"],
    certificateMode: input["CertificateMode"],
    connectionRetryInterval: input["ConnectionRetryInterval"],
    destination: fromOutputLocationRef(input["Destination"]),
    eventId: input["EventId"],
    eventIdMode: input["EventIdMode"],
    eventStopBehavior: input["EventStopBehavior"],
    filecacheDuration: input["FilecacheDuration"],
    fragmentLength: input["FragmentLength"],
    inputLossAction: input["InputLossAction"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
    segmentationMode: input["SegmentationMode"],
    sendDelayMs: input["SendDelayMs"],
    sparseTrackType: input["SparseTrackType"],
    streamManifestBehavior: input["StreamManifestBehavior"],
    timestampOffset: input["TimestampOffset"],
    timestampOffsetMode: input["TimestampOffsetMode"],
  }
}
function toMsSmoothGroupSettings(root: jsonP.JSONValue): s.MsSmoothGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "AcquisitionPointId": "s",
      "AudioOnlyTimecodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupAudioOnlyTimecodeControl>(x),
      "CertificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupCertificateMode>(x),
      "ConnectionRetryInterval": "n",
      "EventId": "s",
      "EventIdMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupEventIdMode>(x),
      "EventStopBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupEventStopBehavior>(x),
      "FilecacheDuration": "n",
      "FragmentLength": "n",
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputLossActionForMsSmoothOut>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
      "SegmentationMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupSegmentationMode>(x),
      "SendDelayMs": "n",
      "SparseTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupSparseTrackType>(x),
      "StreamManifestBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupStreamManifestBehavior>(x),
      "TimestampOffset": "s",
      "TimestampOffsetMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.SmoothGroupTimestampOffsetMode>(x),
    },
  }, root);
}

function fromMultiplexGroupSettings(input?: s.MultiplexGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toMultiplexGroupSettings(root: jsonP.JSONValue): s.MultiplexGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromRtmpGroupSettings(input?: s.RtmpGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    authenticationScheme: input["AuthenticationScheme"],
    cacheFullBehavior: input["CacheFullBehavior"],
    cacheLength: input["CacheLength"],
    captionData: input["CaptionData"],
    inputLossAction: input["InputLossAction"],
    restartDelay: input["RestartDelay"],
  }
}
function toRtmpGroupSettings(root: jsonP.JSONValue): s.RtmpGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.RtmpAdMarkers>(x)],
      "AuthenticationScheme": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthenticationScheme>(x),
      "CacheFullBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.RtmpCacheFullBehavior>(x),
      "CacheLength": "n",
      "CaptionData": (x: jsonP.JSONValue) => cmnP.readEnum<s.RtmpCaptionData>(x),
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputLossActionForRtmpOut>(x),
      "RestartDelay": "n",
    },
  }, root);
}

function fromUdpGroupSettings(input?: s.UdpGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputLossAction: input["InputLossAction"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
  }
}
function toUdpGroupSettings(root: jsonP.JSONValue): s.UdpGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputLossActionForUdpOut>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<s.UdpTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
    },
  }, root);
}

function fromOutput(input?: s.Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptionNames: input["AudioDescriptionNames"],
    captionDescriptionNames: input["CaptionDescriptionNames"],
    outputName: input["OutputName"],
    outputSettings: fromOutputSettings(input["OutputSettings"]),
    videoDescriptionName: input["VideoDescriptionName"],
  }
}
function toOutput(root: jsonP.JSONValue): s.Output {
  return jsonP.readObj({
    required: {
      "OutputSettings": toOutputSettings,
    },
    optional: {
      "AudioDescriptionNames": ["s"],
      "CaptionDescriptionNames": ["s"],
      "OutputName": "s",
      "VideoDescriptionName": "s",
    },
  }, root);
}

function fromOutputSettings(input?: s.OutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveOutputSettings: fromArchiveOutputSettings(input["ArchiveOutputSettings"]),
    frameCaptureOutputSettings: fromFrameCaptureOutputSettings(input["FrameCaptureOutputSettings"]),
    hlsOutputSettings: fromHlsOutputSettings(input["HlsOutputSettings"]),
    mediaPackageOutputSettings: fromMediaPackageOutputSettings(input["MediaPackageOutputSettings"]),
    msSmoothOutputSettings: fromMsSmoothOutputSettings(input["MsSmoothOutputSettings"]),
    multiplexOutputSettings: fromMultiplexOutputSettings(input["MultiplexOutputSettings"]),
    rtmpOutputSettings: fromRtmpOutputSettings(input["RtmpOutputSettings"]),
    udpOutputSettings: fromUdpOutputSettings(input["UdpOutputSettings"]),
  }
}
function toOutputSettings(root: jsonP.JSONValue): s.OutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchiveOutputSettings": toArchiveOutputSettings,
      "FrameCaptureOutputSettings": toFrameCaptureOutputSettings,
      "HlsOutputSettings": toHlsOutputSettings,
      "MediaPackageOutputSettings": toMediaPackageOutputSettings,
      "MsSmoothOutputSettings": toMsSmoothOutputSettings,
      "MultiplexOutputSettings": toMultiplexOutputSettings,
      "RtmpOutputSettings": toRtmpOutputSettings,
      "UdpOutputSettings": toUdpOutputSettings,
    },
  }, root);
}

function fromArchiveOutputSettings(input?: s.ArchiveOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerSettings: fromArchiveContainerSettings(input["ContainerSettings"]),
    extension: input["Extension"],
    nameModifier: input["NameModifier"],
  }
}
function toArchiveOutputSettings(root: jsonP.JSONValue): s.ArchiveOutputSettings {
  return jsonP.readObj({
    required: {
      "ContainerSettings": toArchiveContainerSettings,
    },
    optional: {
      "Extension": "s",
      "NameModifier": "s",
    },
  }, root);
}

function fromArchiveContainerSettings(input?: s.ArchiveContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
    rawSettings: fromRawSettings(input["RawSettings"]),
  }
}
function toArchiveContainerSettings(root: jsonP.JSONValue): s.ArchiveContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "M2tsSettings": toM2tsSettings,
      "RawSettings": toRawSettings,
    },
  }, root);
}

function fromM2tsSettings(input?: s.M2tsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    absentInputAudioBehavior: input["AbsentInputAudioBehavior"],
    arib: input["Arib"],
    aribCaptionsPid: input["AribCaptionsPid"],
    aribCaptionsPidControl: input["AribCaptionsPidControl"],
    audioBufferModel: input["AudioBufferModel"],
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    audioStreamType: input["AudioStreamType"],
    bitrate: input["Bitrate"],
    bufferModel: input["BufferModel"],
    ccDescriptor: input["CcDescriptor"],
    dvbNitSettings: fromDvbNitSettings(input["DvbNitSettings"]),
    dvbSdtSettings: fromDvbSdtSettings(input["DvbSdtSettings"]),
    dvbSubPids: input["DvbSubPids"],
    dvbTdtSettings: fromDvbTdtSettings(input["DvbTdtSettings"]),
    dvbTeletextPid: input["DvbTeletextPid"],
    ebif: input["Ebif"],
    ebpAudioInterval: input["EbpAudioInterval"],
    ebpLookaheadMs: input["EbpLookaheadMs"],
    ebpPlacement: input["EbpPlacement"],
    ecmPid: input["EcmPid"],
    esRateInPes: input["EsRateInPes"],
    etvPlatformPid: input["EtvPlatformPid"],
    etvSignalPid: input["EtvSignalPid"],
    fragmentTime: input["FragmentTime"],
    klv: input["Klv"],
    klvDataPids: input["KlvDataPids"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    nullPacketBitrate: input["NullPacketBitrate"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPeriod: input["PcrPeriod"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    programNum: input["ProgramNum"],
    rateMode: input["RateMode"],
    scte27Pids: input["Scte27Pids"],
    scte35Control: input["Scte35Control"],
    scte35Pid: input["Scte35Pid"],
    segmentationMarkers: input["SegmentationMarkers"],
    segmentationStyle: input["SegmentationStyle"],
    segmentationTime: input["SegmentationTime"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM2tsSettings(root: jsonP.JSONValue): s.M2tsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AbsentInputAudioBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAbsentInputAudioBehavior>(x),
      "Arib": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsArib>(x),
      "AribCaptionsPid": "s",
      "AribCaptionsPidControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAribCaptionsPidControl>(x),
      "AudioBufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAudioBufferModel>(x),
      "AudioFramesPerPes": "n",
      "AudioPids": "s",
      "AudioStreamType": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAudioStreamType>(x),
      "Bitrate": "n",
      "BufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsBufferModel>(x),
      "CcDescriptor": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsCcDescriptor>(x),
      "DvbNitSettings": toDvbNitSettings,
      "DvbSdtSettings": toDvbSdtSettings,
      "DvbSubPids": "s",
      "DvbTdtSettings": toDvbTdtSettings,
      "DvbTeletextPid": "s",
      "Ebif": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEbifControl>(x),
      "EbpAudioInterval": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsAudioInterval>(x),
      "EbpLookaheadMs": "n",
      "EbpPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEbpPlacement>(x),
      "EcmPid": "s",
      "EsRateInPes": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsEsRateInPes>(x),
      "EtvPlatformPid": "s",
      "EtvSignalPid": "s",
      "FragmentTime": "n",
      "Klv": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsKlv>(x),
      "KlvDataPids": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsNielsenId3Behavior>(x),
      "NullPacketBitrate": "n",
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsPcrControl>(x),
      "PcrPeriod": "n",
      "PcrPid": "s",
      "PmtInterval": "n",
      "PmtPid": "s",
      "ProgramNum": "n",
      "RateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsRateMode>(x),
      "Scte27Pids": "s",
      "Scte35Control": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsScte35Control>(x),
      "Scte35Pid": "s",
      "SegmentationMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsSegmentationMarkers>(x),
      "SegmentationStyle": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsSegmentationStyle>(x),
      "SegmentationTime": "n",
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M2tsTimedMetadataBehavior>(x),
      "TimedMetadataPid": "s",
      "TransportStreamId": "n",
      "VideoPid": "s",
    },
  }, root);
}

function fromDvbNitSettings(input?: s.DvbNitSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    networkId: input["NetworkId"],
    networkName: input["NetworkName"],
    repInterval: input["RepInterval"],
  }
}
function toDvbNitSettings(root: jsonP.JSONValue): s.DvbNitSettings {
  return jsonP.readObj({
    required: {
      "NetworkId": "n",
      "NetworkName": "s",
    },
    optional: {
      "RepInterval": "n",
    },
  }, root);
}

function fromDvbSdtSettings(input?: s.DvbSdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputSdt: input["OutputSdt"],
    repInterval: input["RepInterval"],
    serviceName: input["ServiceName"],
    serviceProviderName: input["ServiceProviderName"],
  }
}
function toDvbSdtSettings(root: jsonP.JSONValue): s.DvbSdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputSdt": (x: jsonP.JSONValue) => cmnP.readEnum<s.DvbSdtOutputSdt>(x),
      "RepInterval": "n",
      "ServiceName": "s",
      "ServiceProviderName": "s",
    },
  }, root);
}

function fromDvbTdtSettings(input?: s.DvbTdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repInterval: input["RepInterval"],
  }
}
function toDvbTdtSettings(root: jsonP.JSONValue): s.DvbTdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "RepInterval": "n",
    },
  }, root);
}

function fromRawSettings(input?: s.RawSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRawSettings(root: jsonP.JSONValue): s.RawSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromFrameCaptureOutputSettings(input?: s.FrameCaptureOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    nameModifier: input["NameModifier"],
  }
}
function toFrameCaptureOutputSettings(root: jsonP.JSONValue): s.FrameCaptureOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NameModifier": "s",
    },
  }, root);
}

function fromHlsOutputSettings(input?: s.HlsOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    h265PackagingType: input["H265PackagingType"],
    hlsSettings: fromHlsSettings(input["HlsSettings"]),
    nameModifier: input["NameModifier"],
    segmentModifier: input["SegmentModifier"],
  }
}
function toHlsOutputSettings(root: jsonP.JSONValue): s.HlsOutputSettings {
  return jsonP.readObj({
    required: {
      "HlsSettings": toHlsSettings,
    },
    optional: {
      "H265PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HlsH265PackagingType>(x),
      "NameModifier": "s",
      "SegmentModifier": "s",
    },
  }, root);
}

function fromHlsSettings(input?: s.HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioOnlyHlsSettings: fromAudioOnlyHlsSettings(input["AudioOnlyHlsSettings"]),
    fmp4HlsSettings: fromFmp4HlsSettings(input["Fmp4HlsSettings"]),
    frameCaptureHlsSettings: fromFrameCaptureHlsSettings(input["FrameCaptureHlsSettings"]),
    standardHlsSettings: fromStandardHlsSettings(input["StandardHlsSettings"]),
  }
}
function toHlsSettings(root: jsonP.JSONValue): s.HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioOnlyHlsSettings": toAudioOnlyHlsSettings,
      "Fmp4HlsSettings": toFmp4HlsSettings,
      "FrameCaptureHlsSettings": toFrameCaptureHlsSettings,
      "StandardHlsSettings": toStandardHlsSettings,
    },
  }, root);
}

function fromAudioOnlyHlsSettings(input?: s.AudioOnlyHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioGroupId: input["AudioGroupId"],
    audioOnlyImage: fromInputLocation(input["AudioOnlyImage"]),
    audioTrackType: input["AudioTrackType"],
    segmentType: input["SegmentType"],
  }
}
function toAudioOnlyHlsSettings(root: jsonP.JSONValue): s.AudioOnlyHlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioGroupId": "s",
      "AudioOnlyImage": toInputLocation,
      "AudioTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioOnlyHlsTrackType>(x),
      "SegmentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioOnlyHlsSegmentType>(x),
    },
  }, root);
}

function fromFmp4HlsSettings(input?: s.Fmp4HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioRenditionSets: input["AudioRenditionSets"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
  }
}
function toFmp4HlsSettings(root: jsonP.JSONValue): s.Fmp4HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioRenditionSets": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.Fmp4NielsenId3Behavior>(x),
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.Fmp4TimedMetadataBehavior>(x),
    },
  }, root);
}

function fromFrameCaptureHlsSettings(input?: s.FrameCaptureHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toFrameCaptureHlsSettings(root: jsonP.JSONValue): s.FrameCaptureHlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromStandardHlsSettings(input?: s.StandardHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioRenditionSets: input["AudioRenditionSets"],
    m3u8Settings: fromM3u8Settings(input["M3u8Settings"]),
  }
}
function toStandardHlsSettings(root: jsonP.JSONValue): s.StandardHlsSettings {
  return jsonP.readObj({
    required: {
      "M3u8Settings": toM3u8Settings,
    },
    optional: {
      "AudioRenditionSets": "s",
    },
  }, root);
}

function fromM3u8Settings(input?: s.M3u8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    ecmPid: input["EcmPid"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPeriod: input["PcrPeriod"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    programNum: input["ProgramNum"],
    scte35Behavior: input["Scte35Behavior"],
    scte35Pid: input["Scte35Pid"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM3u8Settings(root: jsonP.JSONValue): s.M3u8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioFramesPerPes": "n",
      "AudioPids": "s",
      "EcmPid": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8NielsenId3Behavior>(x),
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8PcrControl>(x),
      "PcrPeriod": "n",
      "PcrPid": "s",
      "PmtInterval": "n",
      "PmtPid": "s",
      "ProgramNum": "n",
      "Scte35Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8Scte35Behavior>(x),
      "Scte35Pid": "s",
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.M3u8TimedMetadataBehavior>(x),
      "TimedMetadataPid": "s",
      "TransportStreamId": "n",
      "VideoPid": "s",
    },
  }, root);
}

function fromMediaPackageOutputSettings(input?: s.MediaPackageOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toMediaPackageOutputSettings(root: jsonP.JSONValue): s.MediaPackageOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromMsSmoothOutputSettings(input?: s.MsSmoothOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    h265PackagingType: input["H265PackagingType"],
    nameModifier: input["NameModifier"],
  }
}
function toMsSmoothOutputSettings(root: jsonP.JSONValue): s.MsSmoothOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "H265PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MsSmoothH265PackagingType>(x),
      "NameModifier": "s",
    },
  }, root);
}

function fromMultiplexOutputSettings(input?: s.MultiplexOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toMultiplexOutputSettings(root: jsonP.JSONValue): s.MultiplexOutputSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

function fromRtmpOutputSettings(input?: s.RtmpOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateMode: input["CertificateMode"],
    connectionRetryInterval: input["ConnectionRetryInterval"],
    destination: fromOutputLocationRef(input["Destination"]),
    numRetries: input["NumRetries"],
  }
}
function toRtmpOutputSettings(root: jsonP.JSONValue): s.RtmpOutputSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "CertificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.RtmpOutputCertificateMode>(x),
      "ConnectionRetryInterval": "n",
      "NumRetries": "n",
    },
  }, root);
}

function fromUdpOutputSettings(input?: s.UdpOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bufferMsec: input["BufferMsec"],
    containerSettings: fromUdpContainerSettings(input["ContainerSettings"]),
    destination: fromOutputLocationRef(input["Destination"]),
    fecOutputSettings: fromFecOutputSettings(input["FecOutputSettings"]),
  }
}
function toUdpOutputSettings(root: jsonP.JSONValue): s.UdpOutputSettings {
  return jsonP.readObj({
    required: {
      "ContainerSettings": toUdpContainerSettings,
      "Destination": toOutputLocationRef,
    },
    optional: {
      "BufferMsec": "n",
      "FecOutputSettings": toFecOutputSettings,
    },
  }, root);
}

function fromUdpContainerSettings(input?: s.UdpContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
  }
}
function toUdpContainerSettings(root: jsonP.JSONValue): s.UdpContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "M2tsSettings": toM2tsSettings,
    },
  }, root);
}

function fromFecOutputSettings(input?: s.FecOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columnDepth: input["ColumnDepth"],
    includeFec: input["IncludeFec"],
    rowLength: input["RowLength"],
  }
}
function toFecOutputSettings(root: jsonP.JSONValue): s.FecOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnDepth": "n",
      "IncludeFec": (x: jsonP.JSONValue) => cmnP.readEnum<s.FecOutputIncludeFec>(x),
      "RowLength": "n",
    },
  }, root);
}

function fromTimecodeConfig(input?: s.TimecodeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    source: input["Source"],
    syncThreshold: input["SyncThreshold"],
  }
}
function toTimecodeConfig(root: jsonP.JSONValue): s.TimecodeConfig {
  return jsonP.readObj({
    required: {
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<s.TimecodeConfigSource>(x),
    },
    optional: {
      "SyncThreshold": "n",
    },
  }, root);
}

function fromVideoDescription(input?: s.VideoDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codecSettings: fromVideoCodecSettings(input["CodecSettings"]),
    height: input["Height"],
    name: input["Name"],
    respondToAfd: input["RespondToAfd"],
    scalingBehavior: input["ScalingBehavior"],
    sharpness: input["Sharpness"],
    width: input["Width"],
  }
}
function toVideoDescription(root: jsonP.JSONValue): s.VideoDescription {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CodecSettings": toVideoCodecSettings,
      "Height": "n",
      "RespondToAfd": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoDescriptionRespondToAfd>(x),
      "ScalingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoDescriptionScalingBehavior>(x),
      "Sharpness": "n",
      "Width": "n",
    },
  }, root);
}

function fromVideoCodecSettings(input?: s.VideoCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    frameCaptureSettings: fromFrameCaptureSettings(input["FrameCaptureSettings"]),
    h264Settings: fromH264Settings(input["H264Settings"]),
    h265Settings: fromH265Settings(input["H265Settings"]),
    mpeg2Settings: fromMpeg2Settings(input["Mpeg2Settings"]),
  }
}
function toVideoCodecSettings(root: jsonP.JSONValue): s.VideoCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FrameCaptureSettings": toFrameCaptureSettings,
      "H264Settings": toH264Settings,
      "H265Settings": toH265Settings,
      "Mpeg2Settings": toMpeg2Settings,
    },
  }, root);
}

function fromFrameCaptureSettings(input?: s.FrameCaptureSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captureInterval: input["CaptureInterval"],
    captureIntervalUnits: input["CaptureIntervalUnits"],
  }
}
function toFrameCaptureSettings(root: jsonP.JSONValue): s.FrameCaptureSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptureInterval": "n",
      "CaptureIntervalUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.FrameCaptureIntervalUnit>(x),
    },
  }, root);
}

function fromH264Settings(input?: s.H264Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    bitrate: input["Bitrate"],
    bufFillPct: input["BufFillPct"],
    bufSize: input["BufSize"],
    colorMetadata: input["ColorMetadata"],
    colorSpaceSettings: fromH264ColorSpaceSettings(input["ColorSpaceSettings"]),
    entropyEncoding: input["EntropyEncoding"],
    filterSettings: fromH264FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    flickerAq: input["FlickerAq"],
    forceFieldPictures: input["ForceFieldPictures"],
    framerateControl: input["FramerateControl"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopNumBFrames: input["GopNumBFrames"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    level: input["Level"],
    lookAheadRateControl: input["LookAheadRateControl"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numRefFrames: input["NumRefFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    profile: input["Profile"],
    qualityLevel: input["QualityLevel"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    rateControlMode: input["RateControlMode"],
    scanType: input["ScanType"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    softness: input["Softness"],
    spatialAq: input["SpatialAq"],
    subgopLength: input["SubgopLength"],
    syntax: input["Syntax"],
    temporalAq: input["TemporalAq"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toH264Settings(root: jsonP.JSONValue): s.H264Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<s.AfdSignaling>(x),
      "Bitrate": "n",
      "BufFillPct": "n",
      "BufSize": "n",
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ColorMetadata>(x),
      "ColorSpaceSettings": toH264ColorSpaceSettings,
      "EntropyEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264EntropyEncoding>(x),
      "FilterSettings": toH264FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<s.FixedAfd>(x),
      "FlickerAq": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FlickerAq>(x),
      "ForceFieldPictures": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ForceFieldPictures>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264FramerateControl>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264GopBReference>(x),
      "GopClosedCadence": "n",
      "GopNumBFrames": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264GopSizeUnits>(x),
      "Level": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264Level>(x),
      "LookAheadRateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264LookAheadRateControl>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumRefFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264Profile>(x),
      "QualityLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264QualityLevel>(x),
      "QvbrQualityLevel": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264RateControlMode>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264ScanType>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SceneChangeDetect>(x),
      "Slices": "n",
      "Softness": "n",
      "SpatialAq": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SpatialAq>(x),
      "SubgopLength": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264SubGopLength>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264Syntax>(x),
      "TemporalAq": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264TemporalAq>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<s.H264TimecodeInsertionBehavior>(x),
    },
  }, root);
}

function fromH264ColorSpaceSettings(input?: s.H264ColorSpaceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpacePassthroughSettings: fromColorSpacePassthroughSettings(input["ColorSpacePassthroughSettings"]),
    rec601Settings: fromRec601Settings(input["Rec601Settings"]),
    rec709Settings: fromRec709Settings(input["Rec709Settings"]),
  }
}
function toH264ColorSpaceSettings(root: jsonP.JSONValue): s.H264ColorSpaceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpacePassthroughSettings": toColorSpacePassthroughSettings,
      "Rec601Settings": toRec601Settings,
      "Rec709Settings": toRec709Settings,
    },
  }, root);
}

function fromColorSpacePassthroughSettings(input?: s.ColorSpacePassthroughSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toColorSpacePassthroughSettings(root: jsonP.JSONValue): s.ColorSpacePassthroughSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromRec601Settings(input?: s.Rec601Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRec601Settings(root: jsonP.JSONValue): s.Rec601Settings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromRec709Settings(input?: s.Rec709Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRec709Settings(root: jsonP.JSONValue): s.Rec709Settings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromH264FilterSettings(input?: s.H264FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toH264FilterSettings(root: jsonP.JSONValue): s.H264FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

function fromTemporalFilterSettings(input?: s.TemporalFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    postFilterSharpening: input["PostFilterSharpening"],
    strength: input["Strength"],
  }
}
function toTemporalFilterSettings(root: jsonP.JSONValue): s.TemporalFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PostFilterSharpening": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemporalFilterPostFilterSharpening>(x),
      "Strength": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemporalFilterStrength>(x),
    },
  }, root);
}

function fromH265Settings(input?: s.H265Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    alternativeTransferFunction: input["AlternativeTransferFunction"],
    bitrate: input["Bitrate"],
    bufSize: input["BufSize"],
    colorMetadata: input["ColorMetadata"],
    colorSpaceSettings: fromH265ColorSpaceSettings(input["ColorSpaceSettings"]),
    filterSettings: fromH265FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    flickerAq: input["FlickerAq"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    level: input["Level"],
    lookAheadRateControl: input["LookAheadRateControl"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    profile: input["Profile"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    rateControlMode: input["RateControlMode"],
    scanType: input["ScanType"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    tier: input["Tier"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toH265Settings(root: jsonP.JSONValue): s.H265Settings {
  return jsonP.readObj({
    required: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<s.AfdSignaling>(x),
      "AlternativeTransferFunction": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265AlternativeTransferFunction>(x),
      "Bitrate": "n",
      "BufSize": "n",
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265ColorMetadata>(x),
      "ColorSpaceSettings": toH265ColorSpaceSettings,
      "FilterSettings": toH265FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<s.FixedAfd>(x),
      "FlickerAq": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265FlickerAq>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265GopSizeUnits>(x),
      "Level": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265Level>(x),
      "LookAheadRateControl": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265LookAheadRateControl>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "ParDenominator": "n",
      "ParNumerator": "n",
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265Profile>(x),
      "QvbrQualityLevel": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265RateControlMode>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265ScanType>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265SceneChangeDetect>(x),
      "Slices": "n",
      "Tier": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265Tier>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<s.H265TimecodeInsertionBehavior>(x),
    },
  }, root);
}

function fromH265ColorSpaceSettings(input?: s.H265ColorSpaceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpacePassthroughSettings: fromColorSpacePassthroughSettings(input["ColorSpacePassthroughSettings"]),
    hdr10Settings: fromHdr10Settings(input["Hdr10Settings"]),
    rec601Settings: fromRec601Settings(input["Rec601Settings"]),
    rec709Settings: fromRec709Settings(input["Rec709Settings"]),
  }
}
function toH265ColorSpaceSettings(root: jsonP.JSONValue): s.H265ColorSpaceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpacePassthroughSettings": toColorSpacePassthroughSettings,
      "Hdr10Settings": toHdr10Settings,
      "Rec601Settings": toRec601Settings,
      "Rec709Settings": toRec709Settings,
    },
  }, root);
}

function fromHdr10Settings(input?: s.Hdr10Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxCll: input["MaxCll"],
    maxFall: input["MaxFall"],
  }
}
function toHdr10Settings(root: jsonP.JSONValue): s.Hdr10Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCll": "n",
      "MaxFall": "n",
    },
  }, root);
}

function fromH265FilterSettings(input?: s.H265FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toH265FilterSettings(root: jsonP.JSONValue): s.H265FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

function fromMpeg2Settings(input?: s.Mpeg2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    colorMetadata: input["ColorMetadata"],
    colorSpace: input["ColorSpace"],
    displayAspectRatio: input["DisplayAspectRatio"],
    filterSettings: fromMpeg2FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopNumBFrames: input["GopNumBFrames"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    scanType: input["ScanType"],
    subgopLength: input["SubgopLength"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toMpeg2Settings(root: jsonP.JSONValue): s.Mpeg2Settings {
  return jsonP.readObj({
    required: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<s.AfdSignaling>(x),
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2ColorMetadata>(x),
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2ColorSpace>(x),
      "DisplayAspectRatio": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2DisplayRatio>(x),
      "FilterSettings": toMpeg2FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<s.FixedAfd>(x),
      "GopClosedCadence": "n",
      "GopNumBFrames": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2GopSizeUnits>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2ScanType>(x),
      "SubgopLength": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2SubGopLength>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mpeg2TimecodeInsertionBehavior>(x),
    },
  }, root);
}

function fromMpeg2FilterSettings(input?: s.Mpeg2FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toMpeg2FilterSettings(root: jsonP.JSONValue): s.Mpeg2FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

function fromInputAttachment(input?: s.InputAttachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    automaticInputFailoverSettings: fromAutomaticInputFailoverSettings(input["AutomaticInputFailoverSettings"]),
    inputAttachmentName: input["InputAttachmentName"],
    inputId: input["InputId"],
    inputSettings: fromInputSettings(input["InputSettings"]),
  }
}
function toInputAttachment(root: jsonP.JSONValue): s.InputAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticInputFailoverSettings": toAutomaticInputFailoverSettings,
      "InputAttachmentName": "s",
      "InputId": "s",
      "InputSettings": toInputSettings,
    },
  }, root);
}

function fromAutomaticInputFailoverSettings(input?: s.AutomaticInputFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    errorClearTimeMsec: input["ErrorClearTimeMsec"],
    failoverConditions: input["FailoverConditions"]?.map(x => fromFailoverCondition(x)),
    inputPreference: input["InputPreference"],
    secondaryInputId: input["SecondaryInputId"],
  }
}
function toAutomaticInputFailoverSettings(root: jsonP.JSONValue): s.AutomaticInputFailoverSettings {
  return jsonP.readObj({
    required: {
      "SecondaryInputId": "s",
    },
    optional: {
      "ErrorClearTimeMsec": "n",
      "FailoverConditions": [toFailoverCondition],
      "InputPreference": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputPreference>(x),
    },
  }, root);
}

function fromFailoverCondition(input?: s.FailoverCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    failoverConditionSettings: fromFailoverConditionSettings(input["FailoverConditionSettings"]),
  }
}
function toFailoverCondition(root: jsonP.JSONValue): s.FailoverCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "FailoverConditionSettings": toFailoverConditionSettings,
    },
  }, root);
}

function fromFailoverConditionSettings(input?: s.FailoverConditionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSilenceSettings: fromAudioSilenceFailoverSettings(input["AudioSilenceSettings"]),
    inputLossSettings: fromInputLossFailoverSettings(input["InputLossSettings"]),
    videoBlackSettings: fromVideoBlackFailoverSettings(input["VideoBlackSettings"]),
  }
}
function toFailoverConditionSettings(root: jsonP.JSONValue): s.FailoverConditionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSilenceSettings": toAudioSilenceFailoverSettings,
      "InputLossSettings": toInputLossFailoverSettings,
      "VideoBlackSettings": toVideoBlackFailoverSettings,
    },
  }, root);
}

function fromAudioSilenceFailoverSettings(input?: s.AudioSilenceFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorName: input["AudioSelectorName"],
    audioSilenceThresholdMsec: input["AudioSilenceThresholdMsec"],
  }
}
function toAudioSilenceFailoverSettings(root: jsonP.JSONValue): s.AudioSilenceFailoverSettings {
  return jsonP.readObj({
    required: {
      "AudioSelectorName": "s",
    },
    optional: {
      "AudioSilenceThresholdMsec": "n",
    },
  }, root);
}

function fromInputLossFailoverSettings(input?: s.InputLossFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputLossThresholdMsec: input["InputLossThresholdMsec"],
  }
}
function toInputLossFailoverSettings(root: jsonP.JSONValue): s.InputLossFailoverSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputLossThresholdMsec": "n",
    },
  }, root);
}

function fromVideoBlackFailoverSettings(input?: s.VideoBlackFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackDetectThreshold: input["BlackDetectThreshold"],
    videoBlackThresholdMsec: input["VideoBlackThresholdMsec"],
  }
}
function toVideoBlackFailoverSettings(root: jsonP.JSONValue): s.VideoBlackFailoverSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackDetectThreshold": "n",
      "VideoBlackThresholdMsec": "n",
    },
  }, root);
}

function fromInputSettings(input?: s.InputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectors: input["AudioSelectors"]?.map(x => fromAudioSelector(x)),
    captionSelectors: input["CaptionSelectors"]?.map(x => fromCaptionSelector(x)),
    deblockFilter: input["DeblockFilter"],
    denoiseFilter: input["DenoiseFilter"],
    filterStrength: input["FilterStrength"],
    inputFilter: input["InputFilter"],
    networkInputSettings: fromNetworkInputSettings(input["NetworkInputSettings"]),
    smpte2038DataPreference: input["Smpte2038DataPreference"],
    sourceEndBehavior: input["SourceEndBehavior"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInputSettings(root: jsonP.JSONValue): s.InputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectors": [toAudioSelector],
      "CaptionSelectors": [toCaptionSelector],
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeblockFilter>(x),
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDenoiseFilter>(x),
      "FilterStrength": "n",
      "InputFilter": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputFilter>(x),
      "NetworkInputSettings": toNetworkInputSettings,
      "Smpte2038DataPreference": (x: jsonP.JSONValue) => cmnP.readEnum<s.Smpte2038DataPreference>(x),
      "SourceEndBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputSourceEndBehavior>(x),
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

function fromAudioSelector(input?: s.AudioSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    selectorSettings: fromAudioSelectorSettings(input["SelectorSettings"]),
  }
}
function toAudioSelector(root: jsonP.JSONValue): s.AudioSelector {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "SelectorSettings": toAudioSelectorSettings,
    },
  }, root);
}

function fromAudioSelectorSettings(input?: s.AudioSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioLanguageSelection: fromAudioLanguageSelection(input["AudioLanguageSelection"]),
    audioPidSelection: fromAudioPidSelection(input["AudioPidSelection"]),
    audioTrackSelection: fromAudioTrackSelection(input["AudioTrackSelection"]),
  }
}
function toAudioSelectorSettings(root: jsonP.JSONValue): s.AudioSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioLanguageSelection": toAudioLanguageSelection,
      "AudioPidSelection": toAudioPidSelection,
      "AudioTrackSelection": toAudioTrackSelection,
    },
  }, root);
}

function fromAudioLanguageSelection(input?: s.AudioLanguageSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    languageCode: input["LanguageCode"],
    languageSelectionPolicy: input["LanguageSelectionPolicy"],
  }
}
function toAudioLanguageSelection(root: jsonP.JSONValue): s.AudioLanguageSelection {
  return jsonP.readObj({
    required: {
      "LanguageCode": "s",
    },
    optional: {
      "LanguageSelectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<s.AudioLanguageSelectionPolicy>(x),
    },
  }, root);
}

function fromAudioPidSelection(input?: s.AudioPidSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toAudioPidSelection(root: jsonP.JSONValue): s.AudioPidSelection {
  return jsonP.readObj({
    required: {
      "Pid": "n",
    },
    optional: {},
  }, root);
}

function fromAudioTrackSelection(input?: s.AudioTrackSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tracks: input["Tracks"]?.map(x => fromAudioTrack(x)),
  }
}
function toAudioTrackSelection(root: jsonP.JSONValue): s.AudioTrackSelection {
  return jsonP.readObj({
    required: {
      "Tracks": [toAudioTrack],
    },
    optional: {},
  }, root);
}

function fromAudioTrack(input?: s.AudioTrack | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    track: input["Track"],
  }
}
function toAudioTrack(root: jsonP.JSONValue): s.AudioTrack {
  return jsonP.readObj({
    required: {
      "Track": "n",
    },
    optional: {},
  }, root);
}

function fromCaptionSelector(input?: s.CaptionSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    languageCode: input["LanguageCode"],
    name: input["Name"],
    selectorSettings: fromCaptionSelectorSettings(input["SelectorSettings"]),
  }
}
function toCaptionSelector(root: jsonP.JSONValue): s.CaptionSelector {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "LanguageCode": "s",
      "SelectorSettings": toCaptionSelectorSettings,
    },
  }, root);
}

function fromCaptionSelectorSettings(input?: s.CaptionSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ancillarySourceSettings: fromAncillarySourceSettings(input["AncillarySourceSettings"]),
    aribSourceSettings: fromAribSourceSettings(input["AribSourceSettings"]),
    dvbSubSourceSettings: fromDvbSubSourceSettings(input["DvbSubSourceSettings"]),
    embeddedSourceSettings: fromEmbeddedSourceSettings(input["EmbeddedSourceSettings"]),
    scte20SourceSettings: fromScte20SourceSettings(input["Scte20SourceSettings"]),
    scte27SourceSettings: fromScte27SourceSettings(input["Scte27SourceSettings"]),
    teletextSourceSettings: fromTeletextSourceSettings(input["TeletextSourceSettings"]),
  }
}
function toCaptionSelectorSettings(root: jsonP.JSONValue): s.CaptionSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AncillarySourceSettings": toAncillarySourceSettings,
      "AribSourceSettings": toAribSourceSettings,
      "DvbSubSourceSettings": toDvbSubSourceSettings,
      "EmbeddedSourceSettings": toEmbeddedSourceSettings,
      "Scte20SourceSettings": toScte20SourceSettings,
      "Scte27SourceSettings": toScte27SourceSettings,
      "TeletextSourceSettings": toTeletextSourceSettings,
    },
  }, root);
}

function fromAncillarySourceSettings(input?: s.AncillarySourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceAncillaryChannelNumber: input["SourceAncillaryChannelNumber"],
  }
}
function toAncillarySourceSettings(root: jsonP.JSONValue): s.AncillarySourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceAncillaryChannelNumber": "n",
    },
  }, root);
}

function fromAribSourceSettings(input?: s.AribSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAribSourceSettings(root: jsonP.JSONValue): s.AribSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromDvbSubSourceSettings(input?: s.DvbSubSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toDvbSubSourceSettings(root: jsonP.JSONValue): s.DvbSubSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

function fromEmbeddedSourceSettings(input?: s.EmbeddedSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    scte20Detection: input["Scte20Detection"],
    source608ChannelNumber: input["Source608ChannelNumber"],
    source608TrackNumber: input["Source608TrackNumber"],
  }
}
function toEmbeddedSourceSettings(root: jsonP.JSONValue): s.EmbeddedSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmbeddedConvert608To708>(x),
      "Scte20Detection": (x: jsonP.JSONValue) => cmnP.readEnum<s.EmbeddedScte20Detection>(x),
      "Source608ChannelNumber": "n",
      "Source608TrackNumber": "n",
    },
  }, root);
}

function fromScte20SourceSettings(input?: s.Scte20SourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    source608ChannelNumber: input["Source608ChannelNumber"],
  }
}
function toScte20SourceSettings(root: jsonP.JSONValue): s.Scte20SourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<s.Scte20Convert608To708>(x),
      "Source608ChannelNumber": "n",
    },
  }, root);
}

function fromScte27SourceSettings(input?: s.Scte27SourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toScte27SourceSettings(root: jsonP.JSONValue): s.Scte27SourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

function fromTeletextSourceSettings(input?: s.TeletextSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
  }
}
function toTeletextSourceSettings(root: jsonP.JSONValue): s.TeletextSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
    },
  }, root);
}

function fromNetworkInputSettings(input?: s.NetworkInputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsInputSettings: fromHlsInputSettings(input["HlsInputSettings"]),
    serverValidation: input["ServerValidation"],
  }
}
function toNetworkInputSettings(root: jsonP.JSONValue): s.NetworkInputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsInputSettings": toHlsInputSettings,
      "ServerValidation": (x: jsonP.JSONValue) => cmnP.readEnum<s.NetworkInputServerValidation>(x),
    },
  }, root);
}

function fromHlsInputSettings(input?: s.HlsInputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bandwidth: input["Bandwidth"],
    bufferSegments: input["BufferSegments"],
    retries: input["Retries"],
    retryInterval: input["RetryInterval"],
  }
}
function toHlsInputSettings(root: jsonP.JSONValue): s.HlsInputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bandwidth": "n",
      "BufferSegments": "n",
      "Retries": "n",
      "RetryInterval": "n",
    },
  }, root);
}

function fromVideoSelector(input?: s.VideoSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpace: input["ColorSpace"],
    colorSpaceUsage: input["ColorSpaceUsage"],
    selectorSettings: fromVideoSelectorSettings(input["SelectorSettings"]),
  }
}
function toVideoSelector(root: jsonP.JSONValue): s.VideoSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoSelectorColorSpace>(x),
      "ColorSpaceUsage": (x: jsonP.JSONValue) => cmnP.readEnum<s.VideoSelectorColorSpaceUsage>(x),
      "SelectorSettings": toVideoSelectorSettings,
    },
  }, root);
}

function fromVideoSelectorSettings(input?: s.VideoSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    videoSelectorPid: fromVideoSelectorPid(input["VideoSelectorPid"]),
    videoSelectorProgramId: fromVideoSelectorProgramId(input["VideoSelectorProgramId"]),
  }
}
function toVideoSelectorSettings(root: jsonP.JSONValue): s.VideoSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "VideoSelectorPid": toVideoSelectorPid,
      "VideoSelectorProgramId": toVideoSelectorProgramId,
    },
  }, root);
}

function fromVideoSelectorPid(input?: s.VideoSelectorPid | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toVideoSelectorPid(root: jsonP.JSONValue): s.VideoSelectorPid {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

function fromVideoSelectorProgramId(input?: s.VideoSelectorProgramId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    programId: input["ProgramId"],
  }
}
function toVideoSelectorProgramId(root: jsonP.JSONValue): s.VideoSelectorProgramId {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProgramId": "n",
    },
  }, root);
}

function fromInputSpecification(input?: s.InputSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codec: input["Codec"],
    maximumBitrate: input["MaximumBitrate"],
    resolution: input["Resolution"],
  }
}
function toInputSpecification(root: jsonP.JSONValue): s.InputSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputCodec>(x),
      "MaximumBitrate": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputMaximumBitrate>(x),
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputResolution>(x),
    },
  }, root);
}

function fromVpcOutputSettings(input?: s.VpcOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    publicAddressAllocationIds: input["PublicAddressAllocationIds"],
    securityGroupIds: input["SecurityGroupIds"],
    subnetIds: input["SubnetIds"],
  }
}
function toVpcOutputSettings(root: jsonP.JSONValue): s.VpcOutputSettings {
  return jsonP.readObj({
    required: {
      "SubnetIds": ["s"],
    },
    optional: {
      "PublicAddressAllocationIds": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

function fromInputDestinationRequest(input?: s.InputDestinationRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    streamName: input["StreamName"],
  }
}

function fromInputDeviceSettings(input?: s.InputDeviceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
  }
}
function toInputDeviceSettings(root: jsonP.JSONValue): s.InputDeviceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
    },
  }, root);
}

function fromMediaConnectFlowRequest(input?: s.MediaConnectFlowRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    flowArn: input["FlowArn"],
  }
}

function fromInputSourceRequest(input?: s.InputSourceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    url: input["Url"],
    username: input["Username"],
  }
}

function fromInputVpcRequest(input?: s.InputVpcRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    securityGroupIds: input["SecurityGroupIds"],
    subnetIds: input["SubnetIds"],
  }
}

function fromInputWhitelistRuleCidr(input?: s.InputWhitelistRuleCidr | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cidr: input["Cidr"],
  }
}

function fromMultiplexSettings(input?: s.MultiplexSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumVideoBufferDelayMilliseconds: input["MaximumVideoBufferDelayMilliseconds"],
    transportStreamBitrate: input["TransportStreamBitrate"],
    transportStreamId: input["TransportStreamId"],
    transportStreamReservedBitrate: input["TransportStreamReservedBitrate"],
  }
}
function toMultiplexSettings(root: jsonP.JSONValue): s.MultiplexSettings {
  return jsonP.readObj({
    required: {
      "TransportStreamBitrate": "n",
      "TransportStreamId": "n",
    },
    optional: {
      "MaximumVideoBufferDelayMilliseconds": "n",
      "TransportStreamReservedBitrate": "n",
    },
  }, root);
}

function fromMultiplexProgramSettings(input?: s.MultiplexProgramSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    preferredChannelPipeline: input["PreferredChannelPipeline"],
    programNumber: input["ProgramNumber"],
    serviceDescriptor: fromMultiplexProgramServiceDescriptor(input["ServiceDescriptor"]),
    videoSettings: fromMultiplexVideoSettings(input["VideoSettings"]),
  }
}
function toMultiplexProgramSettings(root: jsonP.JSONValue): s.MultiplexProgramSettings {
  return jsonP.readObj({
    required: {
      "ProgramNumber": "n",
    },
    optional: {
      "PreferredChannelPipeline": (x: jsonP.JSONValue) => cmnP.readEnum<s.PreferredChannelPipeline>(x),
      "ServiceDescriptor": toMultiplexProgramServiceDescriptor,
      "VideoSettings": toMultiplexVideoSettings,
    },
  }, root);
}

function fromMultiplexProgramServiceDescriptor(input?: s.MultiplexProgramServiceDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    providerName: input["ProviderName"],
    serviceName: input["ServiceName"],
  }
}
function toMultiplexProgramServiceDescriptor(root: jsonP.JSONValue): s.MultiplexProgramServiceDescriptor {
  return jsonP.readObj({
    required: {
      "ProviderName": "s",
      "ServiceName": "s",
    },
    optional: {},
  }, root);
}

function fromMultiplexVideoSettings(input?: s.MultiplexVideoSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantBitrate: input["ConstantBitrate"],
    statmuxSettings: fromMultiplexStatmuxVideoSettings(input["StatmuxSettings"]),
  }
}
function toMultiplexVideoSettings(root: jsonP.JSONValue): s.MultiplexVideoSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantBitrate": "n",
      "StatmuxSettings": toMultiplexStatmuxVideoSettings,
    },
  }, root);
}

function fromMultiplexStatmuxVideoSettings(input?: s.MultiplexStatmuxVideoSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumBitrate: input["MaximumBitrate"],
    minimumBitrate: input["MinimumBitrate"],
    priority: input["Priority"],
  }
}
function toMultiplexStatmuxVideoSettings(root: jsonP.JSONValue): s.MultiplexStatmuxVideoSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaximumBitrate": "n",
      "MinimumBitrate": "n",
      "Priority": "n",
    },
  }, root);
}

function fromInputDeviceRequest(input?: s.InputDeviceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
  }
}

function fromInputDeviceConfigurableSettings(input?: s.InputDeviceConfigurableSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    configuredInput: input["ConfiguredInput"],
    maxBitrate: input["MaxBitrate"],
  }
}

function toBatchFailedResultModel(root: jsonP.JSONValue): s.BatchFailedResultModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Code": "s",
      "Id": "s",
      "Message": "s",
    },
  }, root);
}

function toBatchSuccessfulResultModel(root: jsonP.JSONValue): s.BatchSuccessfulResultModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Id": "s",
      "State": "s",
    },
  }, root);
}

function toBatchScheduleActionCreateResult(root: jsonP.JSONValue): s.BatchScheduleActionCreateResult {
  return jsonP.readObj({
    required: {
      "ScheduleActions": [toScheduleAction],
    },
    optional: {},
  }, root);
}

function toBatchScheduleActionDeleteResult(root: jsonP.JSONValue): s.BatchScheduleActionDeleteResult {
  return jsonP.readObj({
    required: {
      "ScheduleActions": [toScheduleAction],
    },
    optional: {},
  }, root);
}

function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CdiInputSpecification": toCdiInputSpecification,
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
      "Destinations": [toOutputDestination],
      "EgressEndpoints": [toChannelEgressEndpoint],
      "EncoderSettings": toEncoderSettings,
      "Id": "s",
      "InputAttachments": [toInputAttachment],
      "InputSpecification": toInputSpecification,
      "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
      "Name": "s",
      "PipelineDetails": [toPipelineDetail],
      "PipelinesRunningCount": "n",
      "RoleArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Vpc": toVpcOutputSettings,
    },
  }, root);
}

function toChannelEgressEndpoint(root: jsonP.JSONValue): s.ChannelEgressEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceIp": "s",
    },
  }, root);
}

function toPipelineDetail(root: jsonP.JSONValue): s.PipelineDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInputAttachmentName": "s",
      "ActiveInputSwitchActionName": "s",
      "PipelineId": "s",
    },
  }, root);
}

function toInput(root: jsonP.JSONValue): s.Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AttachedChannels": ["s"],
      "Destinations": [toInputDestination],
      "Id": "s",
      "InputClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputClass>(x),
      "InputDevices": [toInputDeviceSettings],
      "InputSourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputSourceType>(x),
      "MediaConnectFlows": [toMediaConnectFlow],
      "Name": "s",
      "RoleArn": "s",
      "SecurityGroups": ["s"],
      "Sources": [toInputSource],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputType>(x),
    },
  }, root);
}

function toInputDestination(root: jsonP.JSONValue): s.InputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ip": "s",
      "Port": "s",
      "Url": "s",
      "Vpc": toInputDestinationVpc,
    },
  }, root);
}

function toInputDestinationVpc(root: jsonP.JSONValue): s.InputDestinationVpc {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZone": "s",
      "NetworkInterfaceId": "s",
    },
  }, root);
}

function toMediaConnectFlow(root: jsonP.JSONValue): s.MediaConnectFlow {
  return jsonP.readObj({
    required: {},
    optional: {
      "FlowArn": "s",
    },
  }, root);
}

function toInputSource(root: jsonP.JSONValue): s.InputSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "PasswordParam": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

function toInputSecurityGroup(root: jsonP.JSONValue): s.InputSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Id": "s",
      "Inputs": ["s"],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputSecurityGroupState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "WhitelistRules": [toInputWhitelistRule],
    },
  }, root);
}

function toInputWhitelistRule(root: jsonP.JSONValue): s.InputWhitelistRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Cidr": "s",
    },
  }, root);
}

function toMultiplex(root: jsonP.JSONValue): s.Multiplex {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AvailabilityZones": ["s"],
      "Destinations": [toMultiplexOutputDestination],
      "Id": "s",
      "MultiplexSettings": toMultiplexSettings,
      "Name": "s",
      "PipelinesRunningCount": "n",
      "ProgramCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toMultiplexOutputDestination(root: jsonP.JSONValue): s.MultiplexOutputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "MediaConnectSettings": toMultiplexMediaConnectOutputDestinationSettings,
    },
  }, root);
}

function toMultiplexMediaConnectOutputDestinationSettings(root: jsonP.JSONValue): s.MultiplexMediaConnectOutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EntitlementArn": "s",
    },
  }, root);
}

function toMultiplexProgram(root: jsonP.JSONValue): s.MultiplexProgram {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
      "MultiplexProgramSettings": toMultiplexProgramSettings,
      "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
      "PipelineDetails": [toMultiplexProgramPipelineDetail],
      "ProgramName": "s",
    },
  }, root);
}

function toMultiplexProgramPacketIdentifiersMap(root: jsonP.JSONValue): s.MultiplexProgramPacketIdentifiersMap {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioPids": ["n"],
      "DvbSubPids": ["n"],
      "DvbTeletextPid": "n",
      "EtvPlatformPid": "n",
      "EtvSignalPid": "n",
      "KlvDataPids": ["n"],
      "PcrPid": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "Scte27Pids": ["n"],
      "Scte35Pid": "n",
      "TimedMetadataPid": "n",
      "VideoPid": "n",
    },
  }, root);
}

function toMultiplexProgramPipelineDetail(root: jsonP.JSONValue): s.MultiplexProgramPipelineDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveChannelPipeline": "s",
      "PipelineId": "s",
    },
  }, root);
}

function toReservationResourceSpecification(root: jsonP.JSONValue): s.ReservationResourceSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationCodec>(x),
      "MaximumBitrate": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationMaximumBitrate>(x),
      "MaximumFramerate": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationMaximumFramerate>(x),
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationResolution>(x),
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationResourceType>(x),
      "SpecialFeature": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationSpecialFeature>(x),
      "VideoQuality": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationVideoQuality>(x),
    },
  }, root);
}

function toInputDeviceHdSettings(root: jsonP.JSONValue): s.InputDeviceHdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInput": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceActiveInput>(x),
      "ConfiguredInput": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceConfiguredInput>(x),
      "DeviceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceState>(x),
      "Framerate": "n",
      "Height": "n",
      "MaxBitrate": "n",
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceScanType>(x),
      "Width": "n",
    },
  }, root);
}

function toInputDeviceNetworkSettings(root: jsonP.JSONValue): s.InputDeviceNetworkSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DnsAddresses": ["s"],
      "Gateway": "s",
      "IpAddress": "s",
      "IpScheme": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceIpScheme>(x),
      "SubnetMask": "s",
    },
  }, root);
}

function toInputDeviceUhdSettings(root: jsonP.JSONValue): s.InputDeviceUhdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInput": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceActiveInput>(x),
      "ConfiguredInput": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceConfiguredInput>(x),
      "DeviceState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceState>(x),
      "Framerate": "n",
      "Height": "n",
      "MaxBitrate": "n",
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceScanType>(x),
      "Width": "n",
    },
  }, root);
}

function toChannelSummary(root: jsonP.JSONValue): s.ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CdiInputSpecification": toCdiInputSpecification,
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelClass>(x),
      "Destinations": [toOutputDestination],
      "EgressEndpoints": [toChannelEgressEndpoint],
      "Id": "s",
      "InputAttachments": [toInputAttachment],
      "InputSpecification": toInputSpecification,
      "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogLevel>(x),
      "Name": "s",
      "PipelinesRunningCount": "n",
      "RoleArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Vpc": toVpcOutputSettings,
    },
  }, root);
}

function toTransferringInputDeviceSummary(root: jsonP.JSONValue): s.TransferringInputDeviceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Message": "s",
      "TargetCustomerId": "s",
      "TransferType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceTransferType>(x),
    },
  }, root);
}

function toInputDeviceSummary(root: jsonP.JSONValue): s.InputDeviceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceConnectionState>(x),
      "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceSettingsSyncState>(x),
      "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeviceUpdateStatus>(x),
      "HdDeviceSettings": toInputDeviceHdSettings,
      "Id": "s",
      "MacAddress": "s",
      "Name": "s",
      "NetworkSettings": toInputDeviceNetworkSettings,
      "SerialNumber": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputDeviceType>(x),
      "UhdDeviceSettings": toInputDeviceUhdSettings,
    },
  }, root);
}

function toMultiplexProgramSummary(root: jsonP.JSONValue): s.MultiplexProgramSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
      "ProgramName": "s",
    },
  }, root);
}

function toMultiplexSummary(root: jsonP.JSONValue): s.MultiplexSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AvailabilityZones": ["s"],
      "Id": "s",
      "MultiplexSettings": toMultiplexSettingsSummary,
      "Name": "s",
      "PipelinesRunningCount": "n",
      "ProgramCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.MultiplexState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toMultiplexSettingsSummary(root: jsonP.JSONValue): s.MultiplexSettingsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransportStreamBitrate": "n",
    },
  }, root);
}

function toOffering(root: jsonP.JSONValue): s.Offering {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingDurationUnits>(x),
      "FixedPrice": "n",
      "OfferingDescription": "s",
      "OfferingId": "s",
      "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingType>(x),
      "Region": "s",
      "ResourceSpecification": toReservationResourceSpecification,
      "UsagePrice": "n",
    },
  }, root);
}

function toReservation(root: jsonP.JSONValue): s.Reservation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Count": "n",
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingDurationUnits>(x),
      "End": "s",
      "FixedPrice": "n",
      "Name": "s",
      "OfferingDescription": "s",
      "OfferingId": "s",
      "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfferingType>(x),
      "Region": "s",
      "ReservationId": "s",
      "ResourceSpecification": toReservationResourceSpecification,
      "Start": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReservationState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "UsagePrice": "n",
    },
  }, root);
}
