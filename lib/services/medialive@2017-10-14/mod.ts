// Autogenerated API client for: AWS Elemental MediaLive

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class MediaLive {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(MediaLive.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-10-14",
    "endpointPrefix": "medialive",
    "signingName": "medialive",
    "serviceFullName": "AWS Elemental MediaLive",
    "serviceId": "MediaLive",
    "protocol": "rest-json",
    "uid": "medialive-2017-10-14",
    "signatureVersion": "v4",
    "serviceAbbreviation": "MediaLive",
    "jsonVersion": "1.1"
  };

  async acceptInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & AcceptInputDeviceTransferRequest,
  ): Promise<AcceptInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "AcceptInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/accept`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async batchDelete(
    {abortSignal, ...params}: RequestConfig & BatchDeleteRequest = {},
  ): Promise<BatchDeleteResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      inputIds: params["InputIds"],
      inputSecurityGroupIds: params["InputSecurityGroupIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDelete",
      requestUri: "/prod/batch/delete",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchStart(
    {abortSignal, ...params}: RequestConfig & BatchStartRequest = {},
  ): Promise<BatchStartResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStart",
      requestUri: "/prod/batch/start",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchStop(
    {abortSignal, ...params}: RequestConfig & BatchStopRequest = {},
  ): Promise<BatchStopResponse> {
    const body: jsonP.JSONObject = {
      channelIds: params["ChannelIds"],
      multiplexIds: params["MultiplexIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStop",
      requestUri: "/prod/batch/stop",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Failed": [toBatchFailedResultModel],
        "Successful": [toBatchSuccessfulResultModel],
      },
    }, await resp.json());
  }

  async batchUpdateSchedule(
    {abortSignal, ...params}: RequestConfig & BatchUpdateScheduleRequest,
  ): Promise<BatchUpdateScheduleResponse> {
    const body: jsonP.JSONObject = {
      creates: fromBatchScheduleActionCreateRequest(params["Creates"]),
      deletes: fromBatchScheduleActionDeleteRequest(params["Deletes"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdateSchedule",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Creates": toBatchScheduleActionCreateResult,
        "Deletes": toBatchScheduleActionDeleteResult,
      },
    }, await resp.json());
  }

  async cancelInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & CancelInputDeviceTransferRequest,
  ): Promise<CancelInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CancelInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/cancel`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createChannel(
    {abortSignal, ...params}: RequestConfig & CreateChannelRequest = {},
  ): Promise<CreateChannelResponse> {
    const body: jsonP.JSONObject = {
      cdiInputSpecification: fromCdiInputSpecification(params["CdiInputSpecification"]),
      channelClass: params["ChannelClass"],
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
      encoderSettings: fromEncoderSettings(params["EncoderSettings"]),
      inputAttachments: params["InputAttachments"]?.map(x => fromInputAttachment(x)),
      inputSpecification: fromInputSpecification(params["InputSpecification"]),
      logLevel: params["LogLevel"],
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      reserved: params["Reserved"],
      roleArn: params["RoleArn"],
      tags: params["Tags"],
      vpc: fromVpcOutputSettings(params["Vpc"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateChannel",
      requestUri: "/prod/channels",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async createInput(
    {abortSignal, ...params}: RequestConfig & CreateInputRequest = {},
  ): Promise<CreateInputResponse> {
    const body: jsonP.JSONObject = {
      destinations: params["Destinations"]?.map(x => fromInputDestinationRequest(x)),
      inputDevices: params["InputDevices"]?.map(x => fromInputDeviceSettings(x)),
      inputSecurityGroups: params["InputSecurityGroups"],
      mediaConnectFlows: params["MediaConnectFlows"]?.map(x => fromMediaConnectFlowRequest(x)),
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      roleArn: params["RoleArn"],
      sources: params["Sources"]?.map(x => fromInputSourceRequest(x)),
      tags: params["Tags"],
      type: params["Type"],
      vpc: fromInputVpcRequest(params["Vpc"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInput",
      requestUri: "/prod/inputs",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Input": toInput,
      },
    }, await resp.json());
  }

  async createInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & CreateInputSecurityGroupRequest = {},
  ): Promise<CreateInputSecurityGroupResponse> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
      whitelistRules: params["WhitelistRules"]?.map(x => fromInputWhitelistRuleCidr(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInputSecurityGroup",
      requestUri: "/prod/inputSecurityGroups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityGroup": toInputSecurityGroup,
      },
    }, await resp.json());
  }

  async createMultiplex(
    {abortSignal, ...params}: RequestConfig & CreateMultiplexRequest,
  ): Promise<CreateMultiplexResponse> {
    const body: jsonP.JSONObject = {
      availabilityZones: params["AvailabilityZones"],
      multiplexSettings: fromMultiplexSettings(params["MultiplexSettings"]),
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMultiplex",
      requestUri: "/prod/multiplexes",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplex": toMultiplex,
      },
    }, await resp.json());
  }

  async createMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & CreateMultiplexProgramRequest,
  ): Promise<CreateMultiplexProgramResponse> {
    const body: jsonP.JSONObject = {
      multiplexProgramSettings: fromMultiplexProgramSettings(params["MultiplexProgramSettings"]),
      programName: params["ProgramName"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMultiplexProgram",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexProgram": toMultiplexProgram,
      },
    }, await resp.json());
  }

  async createTags(
    {abortSignal, ...params}: RequestConfig & CreateTagsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTags",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async deleteChannel(
    {abortSignal, ...params}: RequestConfig & DeleteChannelRequest,
  ): Promise<DeleteChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async deleteInput(
    {abortSignal, ...params}: RequestConfig & DeleteInputRequest,
  ): Promise<DeleteInputResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInput",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DeleteInputSecurityGroupRequest,
  ): Promise<DeleteInputSecurityGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteInputSecurityGroup",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteMultiplex(
    {abortSignal, ...params}: RequestConfig & DeleteMultiplexRequest,
  ): Promise<DeleteMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMultiplex",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async deleteMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & DeleteMultiplexProgramRequest,
  ): Promise<DeleteMultiplexProgramResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMultiplexProgram",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChannelId": "s",
        "MultiplexProgramSettings": toMultiplexProgramSettings,
        "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
        "PipelineDetails": [toMultiplexProgramPipelineDetail],
        "ProgramName": "s",
      },
    }, await resp.json());
  }

  async deleteReservation(
    {abortSignal, ...params}: RequestConfig & DeleteReservationRequest,
  ): Promise<DeleteReservationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteReservation",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Count": "n",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingDurationUnits>(x),
        "End": "s",
        "FixedPrice": "n",
        "Name": "s",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingType>(x),
        "Region": "s",
        "ReservationId": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "Start": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async deleteSchedule(
    {abortSignal, ...params}: RequestConfig & DeleteScheduleRequest,
  ): Promise<DeleteScheduleResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSchedule",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteTags",
      method: "DELETE",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async describeChannel(
    {abortSignal, ...params}: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async describeInput(
    {abortSignal, ...params}: RequestConfig & DescribeInputRequest,
  ): Promise<DescribeInputResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInput",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AttachedChannels": ["s"],
        "Destinations": [toInputDestination],
        "Id": "s",
        "InputClass": (x: jsonP.JSONValue) => cmnP.readEnum<InputClass>(x),
        "InputDevices": [toInputDeviceSettings],
        "InputSourceType": (x: jsonP.JSONValue) => cmnP.readEnum<InputSourceType>(x),
        "MediaConnectFlows": [toMediaConnectFlow],
        "Name": "s",
        "RoleArn": "s",
        "SecurityGroups": ["s"],
        "Sources": [toInputSource],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<InputState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<InputType>(x),
      },
    }, await resp.json());
  }

  async describeInputDevice(
    {abortSignal, ...params}: RequestConfig & DescribeInputDeviceRequest,
  ): Promise<DescribeInputDeviceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInputDevice",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceConnectionState>(x),
        "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceSettingsSyncState>(x),
        "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceUpdateStatus>(x),
        "HdDeviceSettings": toInputDeviceHdSettings,
        "Id": "s",
        "MacAddress": "s",
        "Name": "s",
        "NetworkSettings": toInputDeviceNetworkSettings,
        "SerialNumber": "s",
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceType>(x),
        "UhdDeviceSettings": toInputDeviceUhdSettings,
      },
    }, await resp.json());
  }

  async describeInputDeviceThumbnail(
    {abortSignal, ...params}: RequestConfig & DescribeInputDeviceThumbnailRequest,
  ): Promise<DescribeInputDeviceThumbnailResponse> {
    const headers = new Headers;
    headers.append("accept", params["Accept"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DescribeInputDeviceThumbnail",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/thumbnailData`,
      responseCode: 200,
    });
  return {
    ContentType: cmnP.readEnum<ContentType>(resp.headers.get("Content-Type")),
    ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
    ETag: resp.headers.get("ETag"),
    LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
    Body: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async describeInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & DescribeInputSecurityGroupRequest,
  ): Promise<DescribeInputSecurityGroupResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeInputSecurityGroup",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Id": "s",
        "Inputs": ["s"],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<InputSecurityGroupState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "WhitelistRules": [toInputWhitelistRule],
      },
    }, await resp.json());
  }

  async describeMultiplex(
    {abortSignal, ...params}: RequestConfig & DescribeMultiplexRequest,
  ): Promise<DescribeMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMultiplex",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async describeMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & DescribeMultiplexProgramRequest,
  ): Promise<DescribeMultiplexProgramResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeMultiplexProgram",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ChannelId": "s",
        "MultiplexProgramSettings": toMultiplexProgramSettings,
        "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
        "PipelineDetails": [toMultiplexProgramPipelineDetail],
        "ProgramName": "s",
      },
    }, await resp.json());
  }

  async describeOffering(
    {abortSignal, ...params}: RequestConfig & DescribeOfferingRequest,
  ): Promise<DescribeOfferingResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeOffering",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/offerings/${params["OfferingId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingDurationUnits>(x),
        "FixedPrice": "n",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingType>(x),
        "Region": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async describeReservation(
    {abortSignal, ...params}: RequestConfig & DescribeReservationRequest,
  ): Promise<DescribeReservationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeReservation",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "Count": "n",
        "CurrencyCode": "s",
        "Duration": "n",
        "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingDurationUnits>(x),
        "End": "s",
        "FixedPrice": "n",
        "Name": "s",
        "OfferingDescription": "s",
        "OfferingId": "s",
        "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingType>(x),
        "Region": "s",
        "ReservationId": "s",
        "ResourceSpecification": toReservationResourceSpecification,
        "Start": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "UsagePrice": "n",
      },
    }, await resp.json());
  }

  async describeSchedule(
    {abortSignal, ...params}: RequestConfig & DescribeScheduleRequest,
  ): Promise<DescribeScheduleResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeSchedule",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/schedule`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "ScheduleActions": [toScheduleAction],
      },
    }, await resp.json());
  }

  async listChannels(
    {abortSignal, ...params}: RequestConfig & ListChannelsRequest = {},
  ): Promise<ListChannelsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListChannels",
      method: "GET",
      requestUri: "/prod/channels",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channels": [toChannelSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputDeviceTransfers(
    {abortSignal, ...params}: RequestConfig & ListInputDeviceTransfersRequest,
  ): Promise<ListInputDeviceTransfersResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    query.set("transferType", params["TransferType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputDeviceTransfers",
      method: "GET",
      requestUri: "/prod/inputDeviceTransfers",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputDeviceTransfers": [toTransferringInputDeviceSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputDevices(
    {abortSignal, ...params}: RequestConfig & ListInputDevicesRequest = {},
  ): Promise<ListInputDevicesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputDevices",
      method: "GET",
      requestUri: "/prod/inputDevices",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputDevices": [toInputDeviceSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputSecurityGroups(
    {abortSignal, ...params}: RequestConfig & ListInputSecurityGroupsRequest = {},
  ): Promise<ListInputSecurityGroupsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputSecurityGroups",
      method: "GET",
      requestUri: "/prod/inputSecurityGroups",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "InputSecurityGroups": [toInputSecurityGroup],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listInputs(
    {abortSignal, ...params}: RequestConfig & ListInputsRequest = {},
  ): Promise<ListInputsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInputs",
      method: "GET",
      requestUri: "/prod/inputs",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Inputs": [toInput],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMultiplexPrograms(
    {abortSignal, ...params}: RequestConfig & ListMultiplexProgramsRequest,
  ): Promise<ListMultiplexProgramsResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMultiplexPrograms",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexPrograms": [toMultiplexProgramSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMultiplexes(
    {abortSignal, ...params}: RequestConfig & ListMultiplexesRequest = {},
  ): Promise<ListMultiplexesResponse> {
    const query = new URLSearchParams;
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListMultiplexes",
      method: "GET",
      requestUri: "/prod/multiplexes",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplexes": [toMultiplexSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listOfferings(
    {abortSignal, ...params}: RequestConfig & ListOfferingsRequest = {},
  ): Promise<ListOfferingsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelClass"] != null) query.set("channelClass", params["ChannelClass"]?.toString() ?? "");
    if (params["ChannelConfiguration"] != null) query.set("channelConfiguration", params["ChannelConfiguration"]?.toString() ?? "");
    if (params["Codec"] != null) query.set("codec", params["Codec"]?.toString() ?? "");
    if (params["Duration"] != null) query.set("duration", params["Duration"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["MaximumBitrate"] != null) query.set("maximumBitrate", params["MaximumBitrate"]?.toString() ?? "");
    if (params["MaximumFramerate"] != null) query.set("maximumFramerate", params["MaximumFramerate"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Resolution"] != null) query.set("resolution", params["Resolution"]?.toString() ?? "");
    if (params["ResourceType"] != null) query.set("resourceType", params["ResourceType"]?.toString() ?? "");
    if (params["SpecialFeature"] != null) query.set("specialFeature", params["SpecialFeature"]?.toString() ?? "");
    if (params["VideoQuality"] != null) query.set("videoQuality", params["VideoQuality"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOfferings",
      method: "GET",
      requestUri: "/prod/offerings",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Offerings": [toOffering],
      },
    }, await resp.json());
  }

  async listReservations(
    {abortSignal, ...params}: RequestConfig & ListReservationsRequest = {},
  ): Promise<ListReservationsResponse> {
    const query = new URLSearchParams;
    if (params["ChannelClass"] != null) query.set("channelClass", params["ChannelClass"]?.toString() ?? "");
    if (params["Codec"] != null) query.set("codec", params["Codec"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxResults", params["MaxResults"]?.toString() ?? "");
    if (params["MaximumBitrate"] != null) query.set("maximumBitrate", params["MaximumBitrate"]?.toString() ?? "");
    if (params["MaximumFramerate"] != null) query.set("maximumFramerate", params["MaximumFramerate"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nextToken", params["NextToken"]?.toString() ?? "");
    if (params["Resolution"] != null) query.set("resolution", params["Resolution"]?.toString() ?? "");
    if (params["ResourceType"] != null) query.set("resourceType", params["ResourceType"]?.toString() ?? "");
    if (params["SpecialFeature"] != null) query.set("specialFeature", params["SpecialFeature"]?.toString() ?? "");
    if (params["VideoQuality"] != null) query.set("videoQuality", params["VideoQuality"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListReservations",
      method: "GET",
      requestUri: "/prod/reservations",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "Reservations": [toReservation],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/prod/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async purchaseOffering(
    {abortSignal, ...params}: RequestConfig & PurchaseOfferingRequest,
  ): Promise<PurchaseOfferingResponse> {
    const body: jsonP.JSONObject = {
      count: params["Count"],
      name: params["Name"],
      requestId: params["RequestId"] ?? generateIdemptToken(),
      start: params["Start"],
      tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PurchaseOffering",
      requestUri: cmnP.encodePath`/prod/offerings/${params["OfferingId"]}/purchase`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  async rejectInputDeviceTransfer(
    {abortSignal, ...params}: RequestConfig & RejectInputDeviceTransferRequest,
  ): Promise<RejectInputDeviceTransferResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "RejectInputDeviceTransfer",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/reject`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startChannel(
    {abortSignal, ...params}: RequestConfig & StartChannelRequest,
  ): Promise<StartChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartChannel",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/start`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async startMultiplex(
    {abortSignal, ...params}: RequestConfig & StartMultiplexRequest,
  ): Promise<StartMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StartMultiplex",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/start`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async stopChannel(
    {abortSignal, ...params}: RequestConfig & StopChannelRequest,
  ): Promise<StopChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopChannel",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/stop`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "CdiInputSpecification": toCdiInputSpecification,
        "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
        "Destinations": [toOutputDestination],
        "EgressEndpoints": [toChannelEgressEndpoint],
        "EncoderSettings": toEncoderSettings,
        "Id": "s",
        "InputAttachments": [toInputAttachment],
        "InputSpecification": toInputSpecification,
        "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
        "Name": "s",
        "PipelineDetails": [toPipelineDetail],
        "PipelinesRunningCount": "n",
        "RoleArn": "s",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "Vpc": toVpcOutputSettings,
      },
    }, await resp.json());
  }

  async stopMultiplex(
    {abortSignal, ...params}: RequestConfig & StopMultiplexRequest,
  ): Promise<StopMultiplexResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "StopMultiplex",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/stop`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "AvailabilityZones": ["s"],
        "Destinations": [toMultiplexOutputDestination],
        "Id": "s",
        "MultiplexSettings": toMultiplexSettings,
        "Name": "s",
        "PipelinesRunningCount": "n",
        "ProgramCount": "n",
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async transferInputDevice(
    {abortSignal, ...params}: RequestConfig & TransferInputDeviceRequest,
  ): Promise<TransferInputDeviceResponse> {
    const body: jsonP.JSONObject = {
      targetCustomerId: params["TargetCustomerId"],
      transferMessage: params["TransferMessage"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TransferInputDevice",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}/transfer`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateChannel(
    {abortSignal, ...params}: RequestConfig & UpdateChannelRequest,
  ): Promise<UpdateChannelResponse> {
    const body: jsonP.JSONObject = {
      cdiInputSpecification: fromCdiInputSpecification(params["CdiInputSpecification"]),
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
      encoderSettings: fromEncoderSettings(params["EncoderSettings"]),
      inputAttachments: params["InputAttachments"]?.map(x => fromInputAttachment(x)),
      inputSpecification: fromInputSpecification(params["InputSpecification"]),
      logLevel: params["LogLevel"],
      name: params["Name"],
      roleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async updateChannelClass(
    {abortSignal, ...params}: RequestConfig & UpdateChannelClassRequest,
  ): Promise<UpdateChannelClassResponse> {
    const body: jsonP.JSONObject = {
      channelClass: params["ChannelClass"],
      destinations: params["Destinations"]?.map(x => fromOutputDestination(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateChannelClass",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/channels/${params["ChannelId"]}/channelClass`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Channel": toChannel,
      },
    }, await resp.json());
  }

  async updateInput(
    {abortSignal, ...params}: RequestConfig & UpdateInputRequest,
  ): Promise<UpdateInputResponse> {
    const body: jsonP.JSONObject = {
      destinations: params["Destinations"]?.map(x => fromInputDestinationRequest(x)),
      inputDevices: params["InputDevices"]?.map(x => fromInputDeviceRequest(x)),
      inputSecurityGroups: params["InputSecurityGroups"],
      mediaConnectFlows: params["MediaConnectFlows"]?.map(x => fromMediaConnectFlowRequest(x)),
      name: params["Name"],
      roleArn: params["RoleArn"],
      sources: params["Sources"]?.map(x => fromInputSourceRequest(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInput",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputs/${params["InputId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Input": toInput,
      },
    }, await resp.json());
  }

  async updateInputDevice(
    {abortSignal, ...params}: RequestConfig & UpdateInputDeviceRequest,
  ): Promise<UpdateInputDeviceResponse> {
    const body: jsonP.JSONObject = {
      hdDeviceSettings: fromInputDeviceConfigurableSettings(params["HdDeviceSettings"]),
      name: params["Name"],
      uhdDeviceSettings: fromInputDeviceConfigurableSettings(params["UhdDeviceSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInputDevice",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputDevices/${params["InputDeviceId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Arn": "s",
        "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceConnectionState>(x),
        "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceSettingsSyncState>(x),
        "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceUpdateStatus>(x),
        "HdDeviceSettings": toInputDeviceHdSettings,
        "Id": "s",
        "MacAddress": "s",
        "Name": "s",
        "NetworkSettings": toInputDeviceNetworkSettings,
        "SerialNumber": "s",
        "Type": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceType>(x),
        "UhdDeviceSettings": toInputDeviceUhdSettings,
      },
    }, await resp.json());
  }

  async updateInputSecurityGroup(
    {abortSignal, ...params}: RequestConfig & UpdateInputSecurityGroupRequest,
  ): Promise<UpdateInputSecurityGroupResponse> {
    const body: jsonP.JSONObject = {
      tags: params["Tags"],
      whitelistRules: params["WhitelistRules"]?.map(x => fromInputWhitelistRuleCidr(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateInputSecurityGroup",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/inputSecurityGroups/${params["InputSecurityGroupId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityGroup": toInputSecurityGroup,
      },
    }, await resp.json());
  }

  async updateMultiplex(
    {abortSignal, ...params}: RequestConfig & UpdateMultiplexRequest,
  ): Promise<UpdateMultiplexResponse> {
    const body: jsonP.JSONObject = {
      multiplexSettings: fromMultiplexSettings(params["MultiplexSettings"]),
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMultiplex",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Multiplex": toMultiplex,
      },
    }, await resp.json());
  }

  async updateMultiplexProgram(
    {abortSignal, ...params}: RequestConfig & UpdateMultiplexProgramRequest,
  ): Promise<UpdateMultiplexProgramResponse> {
    const body: jsonP.JSONObject = {
      multiplexProgramSettings: fromMultiplexProgramSettings(params["MultiplexProgramSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMultiplexProgram",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/multiplexes/${params["MultiplexId"]}/programs/${params["ProgramName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MultiplexProgram": toMultiplexProgram,
      },
    }, await resp.json());
  }

  async updateReservation(
    {abortSignal, ...params}: RequestConfig & UpdateReservationRequest,
  ): Promise<UpdateReservationResponse> {
    const body: jsonP.JSONObject = {
      name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateReservation",
      method: "PUT",
      requestUri: cmnP.encodePath`/prod/reservations/${params["ReservationId"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Reservation": toReservation,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until a channel has been created
   * Checks state up to 5 times, 3 seconds apart (about 1 minutes max wait time).
   */
  async waitForChannelCreated(
    params: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelCreated';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "CREATING") continue;
        if (field === "CREATE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel is running
   * Checks state up to 120 times, 5 seconds apart (about 10 minutes max wait time).
   */
  async waitForChannelRunning(
    params: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelRunning';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "RUNNING") return resp;
        if (field === "STARTING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel has is stopped
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForChannelStopped(
    params: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "STOPPING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a channel has been deleted
   * Checks state up to 84 times, 5 seconds apart (about 7 minutes max wait time).
   */
  async waitForChannelDeleted(
    params: RequestConfig & DescribeChannelRequest,
  ): Promise<DescribeChannelResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ChannelDeleted';
    for (let i = 0; i < 84; i++) {
      try {
        const resp = await this.describeChannel(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been attached
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForInputAttached(
    params: RequestConfig & DescribeInputRequest,
  ): Promise<DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputAttached';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "ATTACHED") return resp;
        if (field === "DETACHED") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been detached
   * Checks state up to 84 times, 5 seconds apart (about 7 minutes max wait time).
   */
  async waitForInputDetached(
    params: RequestConfig & DescribeInputRequest,
  ): Promise<DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputDetached';
    for (let i = 0; i < 84; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "DETACHED") return resp;
        if (field === "CREATING") continue;
        if (field === "ATTACHED") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an input has been deleted
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForInputDeleted(
    params: RequestConfig & DescribeInputRequest,
  ): Promise<DescribeInputResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InputDeleted';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeInput(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has been created
   * Checks state up to 5 times, 3 seconds apart (about 1 minutes max wait time).
   */
  async waitForMultiplexCreated(
    params: RequestConfig & DescribeMultiplexRequest,
  ): Promise<DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexCreated';
    for (let i = 0; i < 5; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "CREATING") continue;
        if (field === "CREATE_FAILED") throw new Error(errMessage);
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 3000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex is running
   * Checks state up to 120 times, 5 seconds apart (about 10 minutes max wait time).
   */
  async waitForMultiplexRunning(
    params: RequestConfig & DescribeMultiplexRequest,
  ): Promise<DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexRunning';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "RUNNING") return resp;
        if (field === "STARTING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has is stopped
   * Checks state up to 28 times, 5 seconds apart (about 3 minutes max wait time).
   */
  async waitForMultiplexStopped(
    params: RequestConfig & DescribeMultiplexRequest,
  ): Promise<DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexStopped';
    for (let i = 0; i < 28; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "IDLE") return resp;
        if (field === "STOPPING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a multiplex has been deleted
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForMultiplexDeleted(
    params: RequestConfig & DescribeMultiplexRequest,
  ): Promise<DescribeMultiplexResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state MultiplexDeleted';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.describeMultiplex(params);
        const field = resp?.State;
        if (field === "DELETED") return resp;
        if (field === "DELETING") continue;
      } catch (err) {
        if (!["Http500"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AcceptInputDeviceTransferRequest {
  InputDeviceId: string;
}

// refs: 1 - tags: named, input
export interface BatchDeleteRequest {
  ChannelIds?: string[] | null;
  InputIds?: string[] | null;
  InputSecurityGroupIds?: string[] | null;
  MultiplexIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface BatchStartRequest {
  ChannelIds?: string[] | null;
  MultiplexIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface BatchStopRequest {
  ChannelIds?: string[] | null;
  MultiplexIds?: string[] | null;
}

// refs: 1 - tags: named, input
export interface BatchUpdateScheduleRequest {
  ChannelId: string;
  Creates?: BatchScheduleActionCreateRequest | null;
  Deletes?: BatchScheduleActionDeleteRequest | null;
}

// refs: 1 - tags: named, input
export interface CancelInputDeviceTransferRequest {
  InputDeviceId: string;
}

// refs: 1 - tags: named, input
export interface CreateChannelRequest {
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EncoderSettings?: EncoderSettings | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  RequestId?: string | null;
  Reserved?: string | null;
  RoleArn?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}

// refs: 1 - tags: named, input
export interface CreateInputRequest {
  Destinations?: InputDestinationRequest[] | null;
  InputDevices?: InputDeviceSettings[] | null;
  InputSecurityGroups?: string[] | null;
  MediaConnectFlows?: MediaConnectFlowRequest[] | null;
  Name?: string | null;
  RequestId?: string | null;
  RoleArn?: string | null;
  Sources?: InputSourceRequest[] | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Type?: InputType | null;
  Vpc?: InputVpcRequest | null;
}

// refs: 1 - tags: named, input
export interface CreateInputSecurityGroupRequest {
  Tags?: { [key: string]: string | null | undefined } | null;
  WhitelistRules?: InputWhitelistRuleCidr[] | null;
}

// refs: 1 - tags: named, input
export interface CreateMultiplexRequest {
  AvailabilityZones: string[];
  MultiplexSettings: MultiplexSettings;
  Name: string;
  RequestId: string;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateMultiplexProgramRequest {
  MultiplexId: string;
  MultiplexProgramSettings: MultiplexProgramSettings;
  ProgramName: string;
  RequestId: string;
}

// refs: 1 - tags: named, input
export interface CreateTagsRequest {
  ResourceArn: string;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface DeleteChannelRequest {
  ChannelId: string;
}

// refs: 1 - tags: named, input
export interface DeleteInputRequest {
  InputId: string;
}

// refs: 1 - tags: named, input
export interface DeleteInputSecurityGroupRequest {
  InputSecurityGroupId: string;
}

// refs: 1 - tags: named, input
export interface DeleteMultiplexRequest {
  MultiplexId: string;
}

// refs: 1 - tags: named, input
export interface DeleteMultiplexProgramRequest {
  MultiplexId: string;
  ProgramName: string;
}

// refs: 1 - tags: named, input
export interface DeleteReservationRequest {
  ReservationId: string;
}

// refs: 1 - tags: named, input
export interface DeleteScheduleRequest {
  ChannelId: string;
}

// refs: 1 - tags: named, input
export interface DeleteTagsRequest {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface DescribeChannelRequest {
  ChannelId: string;
}

// refs: 1 - tags: named, input
export interface DescribeInputRequest {
  InputId: string;
}

// refs: 1 - tags: named, input
export interface DescribeInputDeviceRequest {
  InputDeviceId: string;
}

// refs: 1 - tags: named, input
export interface DescribeInputDeviceThumbnailRequest {
  InputDeviceId: string;
  Accept: AcceptHeader;
}

// refs: 1 - tags: named, input
export interface DescribeInputSecurityGroupRequest {
  InputSecurityGroupId: string;
}

// refs: 1 - tags: named, input
export interface DescribeMultiplexRequest {
  MultiplexId: string;
}

// refs: 1 - tags: named, input
export interface DescribeMultiplexProgramRequest {
  MultiplexId: string;
  ProgramName: string;
}

// refs: 1 - tags: named, input
export interface DescribeOfferingRequest {
  OfferingId: string;
}

// refs: 1 - tags: named, input
export interface DescribeReservationRequest {
  ReservationId: string;
}

// refs: 1 - tags: named, input
export interface DescribeScheduleRequest {
  ChannelId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListChannelsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInputDeviceTransfersRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  TransferType: string;
}

// refs: 1 - tags: named, input
export interface ListInputDevicesRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInputSecurityGroupsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInputsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListMultiplexProgramsRequest {
  MaxResults?: number | null;
  MultiplexId: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListMultiplexesRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListOfferingsRequest {
  ChannelClass?: string | null;
  ChannelConfiguration?: string | null;
  Codec?: string | null;
  Duration?: string | null;
  MaxResults?: number | null;
  MaximumBitrate?: string | null;
  MaximumFramerate?: string | null;
  NextToken?: string | null;
  Resolution?: string | null;
  ResourceType?: string | null;
  SpecialFeature?: string | null;
  VideoQuality?: string | null;
}

// refs: 1 - tags: named, input
export interface ListReservationsRequest {
  ChannelClass?: string | null;
  Codec?: string | null;
  MaxResults?: number | null;
  MaximumBitrate?: string | null;
  MaximumFramerate?: string | null;
  NextToken?: string | null;
  Resolution?: string | null;
  ResourceType?: string | null;
  SpecialFeature?: string | null;
  VideoQuality?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface PurchaseOfferingRequest {
  Count: number;
  Name?: string | null;
  OfferingId: string;
  RequestId?: string | null;
  Start?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface RejectInputDeviceTransferRequest {
  InputDeviceId: string;
}

// refs: 1 - tags: named, input
export interface StartChannelRequest {
  ChannelId: string;
}

// refs: 1 - tags: named, input
export interface StartMultiplexRequest {
  MultiplexId: string;
}

// refs: 1 - tags: named, input
export interface StopChannelRequest {
  ChannelId: string;
}

// refs: 1 - tags: named, input
export interface StopMultiplexRequest {
  MultiplexId: string;
}

// refs: 1 - tags: named, input
export interface TransferInputDeviceRequest {
  InputDeviceId: string;
  TargetCustomerId?: string | null;
  TransferMessage?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateChannelRequest {
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelId: string;
  Destinations?: OutputDestination[] | null;
  EncoderSettings?: EncoderSettings | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  RoleArn?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateChannelClassRequest {
  ChannelClass: ChannelClass;
  ChannelId: string;
  Destinations?: OutputDestination[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateInputRequest {
  Destinations?: InputDestinationRequest[] | null;
  InputDevices?: InputDeviceRequest[] | null;
  InputId: string;
  InputSecurityGroups?: string[] | null;
  MediaConnectFlows?: MediaConnectFlowRequest[] | null;
  Name?: string | null;
  RoleArn?: string | null;
  Sources?: InputSourceRequest[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateInputDeviceRequest {
  HdDeviceSettings?: InputDeviceConfigurableSettings | null;
  InputDeviceId: string;
  Name?: string | null;
  UhdDeviceSettings?: InputDeviceConfigurableSettings | null;
}

// refs: 1 - tags: named, input
export interface UpdateInputSecurityGroupRequest {
  InputSecurityGroupId: string;
  Tags?: { [key: string]: string | null | undefined } | null;
  WhitelistRules?: InputWhitelistRuleCidr[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateMultiplexRequest {
  MultiplexId: string;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateMultiplexProgramRequest {
  MultiplexId: string;
  MultiplexProgramSettings?: MultiplexProgramSettings | null;
  ProgramName: string;
}

// refs: 1 - tags: named, input
export interface UpdateReservationRequest {
  Name?: string | null;
  ReservationId: string;
}

// refs: 1 - tags: named, output
export interface AcceptInputDeviceTransferResponse {
}

// refs: 1 - tags: named, output
export interface BatchDeleteResponse {
  Failed?: BatchFailedResultModel[] | null;
  Successful?: BatchSuccessfulResultModel[] | null;
}

// refs: 1 - tags: named, output
export interface BatchStartResponse {
  Failed?: BatchFailedResultModel[] | null;
  Successful?: BatchSuccessfulResultModel[] | null;
}

// refs: 1 - tags: named, output
export interface BatchStopResponse {
  Failed?: BatchFailedResultModel[] | null;
  Successful?: BatchSuccessfulResultModel[] | null;
}

// refs: 1 - tags: named, output
export interface BatchUpdateScheduleResponse {
  Creates?: BatchScheduleActionCreateResult | null;
  Deletes?: BatchScheduleActionDeleteResult | null;
}

// refs: 1 - tags: named, output
export interface CancelInputDeviceTransferResponse {
}

// refs: 1 - tags: named, output
export interface CreateChannelResponse {
  Channel?: Channel | null;
}

// refs: 1 - tags: named, output
export interface CreateInputResponse {
  Input?: Input | null;
}

// refs: 1 - tags: named, output
export interface CreateInputSecurityGroupResponse {
  SecurityGroup?: InputSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface CreateMultiplexResponse {
  Multiplex?: Multiplex | null;
}

// refs: 1 - tags: named, output
export interface CreateMultiplexProgramResponse {
  MultiplexProgram?: MultiplexProgram | null;
}

// refs: 1 - tags: named, output
export interface DeleteChannelResponse {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  EncoderSettings?: EncoderSettings | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelineDetails?: PipelineDetail[] | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}

// refs: 1 - tags: named, output
export interface DeleteInputResponse {
}

// refs: 1 - tags: named, output
export interface DeleteInputSecurityGroupResponse {
}

// refs: 1 - tags: named, output
export interface DeleteMultiplexResponse {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Destinations?: MultiplexOutputDestination[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DeleteMultiplexProgramResponse {
  ChannelId?: string | null;
  MultiplexProgramSettings?: MultiplexProgramSettings | null;
  PacketIdentifiersMap?: MultiplexProgramPacketIdentifiersMap | null;
  PipelineDetails?: MultiplexProgramPipelineDetail[] | null;
  ProgramName?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteReservationResponse {
  Arn?: string | null;
  Count?: number | null;
  CurrencyCode?: string | null;
  Duration?: number | null;
  DurationUnits?: OfferingDurationUnits | null;
  End?: string | null;
  FixedPrice?: number | null;
  Name?: string | null;
  OfferingDescription?: string | null;
  OfferingId?: string | null;
  OfferingType?: OfferingType | null;
  Region?: string | null;
  ReservationId?: string | null;
  ResourceSpecification?: ReservationResourceSpecification | null;
  Start?: string | null;
  State?: ReservationState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  UsagePrice?: number | null;
}

// refs: 1 - tags: named, output
export interface DeleteScheduleResponse {
}

// refs: 1 - tags: named, output
export interface DescribeChannelResponse {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  EncoderSettings?: EncoderSettings | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelineDetails?: PipelineDetail[] | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}

// refs: 1 - tags: named, output
export interface DescribeInputResponse {
  Arn?: string | null;
  AttachedChannels?: string[] | null;
  Destinations?: InputDestination[] | null;
  Id?: string | null;
  InputClass?: InputClass | null;
  InputDevices?: InputDeviceSettings[] | null;
  InputSourceType?: InputSourceType | null;
  MediaConnectFlows?: MediaConnectFlow[] | null;
  Name?: string | null;
  RoleArn?: string | null;
  SecurityGroups?: string[] | null;
  Sources?: InputSource[] | null;
  State?: InputState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Type?: InputType | null;
}

// refs: 1 - tags: named, output
export interface DescribeInputDeviceResponse {
  Arn?: string | null;
  ConnectionState?: InputDeviceConnectionState | null;
  DeviceSettingsSyncState?: DeviceSettingsSyncState | null;
  DeviceUpdateStatus?: DeviceUpdateStatus | null;
  HdDeviceSettings?: InputDeviceHdSettings | null;
  Id?: string | null;
  MacAddress?: string | null;
  Name?: string | null;
  NetworkSettings?: InputDeviceNetworkSettings | null;
  SerialNumber?: string | null;
  Type?: InputDeviceType | null;
  UhdDeviceSettings?: InputDeviceUhdSettings | null;
}

// refs: 1 - tags: named, output
export interface DescribeInputDeviceThumbnailResponse {
  Body?: Uint8Array | string | null;
  ContentType?: ContentType | null;
  ContentLength?: number | null;
  ETag?: string | null;
  LastModified?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeInputSecurityGroupResponse {
  Arn?: string | null;
  Id?: string | null;
  Inputs?: string[] | null;
  State?: InputSecurityGroupState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  WhitelistRules?: InputWhitelistRule[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeMultiplexResponse {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Destinations?: MultiplexOutputDestination[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DescribeMultiplexProgramResponse {
  ChannelId?: string | null;
  MultiplexProgramSettings?: MultiplexProgramSettings | null;
  PacketIdentifiersMap?: MultiplexProgramPacketIdentifiersMap | null;
  PipelineDetails?: MultiplexProgramPipelineDetail[] | null;
  ProgramName?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeOfferingResponse {
  Arn?: string | null;
  CurrencyCode?: string | null;
  Duration?: number | null;
  DurationUnits?: OfferingDurationUnits | null;
  FixedPrice?: number | null;
  OfferingDescription?: string | null;
  OfferingId?: string | null;
  OfferingType?: OfferingType | null;
  Region?: string | null;
  ResourceSpecification?: ReservationResourceSpecification | null;
  UsagePrice?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeReservationResponse {
  Arn?: string | null;
  Count?: number | null;
  CurrencyCode?: string | null;
  Duration?: number | null;
  DurationUnits?: OfferingDurationUnits | null;
  End?: string | null;
  FixedPrice?: number | null;
  Name?: string | null;
  OfferingDescription?: string | null;
  OfferingId?: string | null;
  OfferingType?: OfferingType | null;
  Region?: string | null;
  ReservationId?: string | null;
  ResourceSpecification?: ReservationResourceSpecification | null;
  Start?: string | null;
  State?: ReservationState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  UsagePrice?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeScheduleResponse {
  NextToken?: string | null;
  ScheduleActions?: ScheduleAction[] | null;
}

// refs: 1 - tags: named, output
export interface ListChannelsResponse {
  Channels?: ChannelSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInputDeviceTransfersResponse {
  InputDeviceTransfers?: TransferringInputDeviceSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInputDevicesResponse {
  InputDevices?: InputDeviceSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInputSecurityGroupsResponse {
  InputSecurityGroups?: InputSecurityGroup[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListInputsResponse {
  Inputs?: Input[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMultiplexProgramsResponse {
  MultiplexPrograms?: MultiplexProgramSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMultiplexesResponse {
  Multiplexes?: MultiplexSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListOfferingsResponse {
  NextToken?: string | null;
  Offerings?: Offering[] | null;
}

// refs: 1 - tags: named, output
export interface ListReservationsResponse {
  NextToken?: string | null;
  Reservations?: Reservation[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface PurchaseOfferingResponse {
  Reservation?: Reservation | null;
}

// refs: 1 - tags: named, output
export interface RejectInputDeviceTransferResponse {
}

// refs: 1 - tags: named, output
export interface StartChannelResponse {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  EncoderSettings?: EncoderSettings | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelineDetails?: PipelineDetail[] | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}

// refs: 1 - tags: named, output
export interface StartMultiplexResponse {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Destinations?: MultiplexOutputDestination[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface StopChannelResponse {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  EncoderSettings?: EncoderSettings | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelineDetails?: PipelineDetail[] | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}

// refs: 1 - tags: named, output
export interface StopMultiplexResponse {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Destinations?: MultiplexOutputDestination[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface TransferInputDeviceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateChannelResponse {
  Channel?: Channel | null;
}

// refs: 1 - tags: named, output
export interface UpdateChannelClassResponse {
  Channel?: Channel | null;
}

// refs: 1 - tags: named, output
export interface UpdateInputResponse {
  Input?: Input | null;
}

// refs: 1 - tags: named, output
export interface UpdateInputDeviceResponse {
  Arn?: string | null;
  ConnectionState?: InputDeviceConnectionState | null;
  DeviceSettingsSyncState?: DeviceSettingsSyncState | null;
  DeviceUpdateStatus?: DeviceUpdateStatus | null;
  HdDeviceSettings?: InputDeviceHdSettings | null;
  Id?: string | null;
  MacAddress?: string | null;
  Name?: string | null;
  NetworkSettings?: InputDeviceNetworkSettings | null;
  SerialNumber?: string | null;
  Type?: InputDeviceType | null;
  UhdDeviceSettings?: InputDeviceUhdSettings | null;
}

// refs: 1 - tags: named, output
export interface UpdateInputSecurityGroupResponse {
  SecurityGroup?: InputSecurityGroup | null;
}

// refs: 1 - tags: named, output
export interface UpdateMultiplexResponse {
  Multiplex?: Multiplex | null;
}

// refs: 1 - tags: named, output
export interface UpdateMultiplexProgramResponse {
  MultiplexProgram?: MultiplexProgram | null;
}

// refs: 1 - tags: named, output
export interface UpdateReservationResponse {
  Reservation?: Reservation | null;
}

// refs: 1 - tags: input, named, interface
export interface BatchScheduleActionCreateRequest {
  ScheduleActions: ScheduleAction[];
}
function fromBatchScheduleActionCreateRequest(input?: BatchScheduleActionCreateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scheduleActions: input["ScheduleActions"]?.map(x => fromScheduleAction(x)),
  }
}

// refs: 4 - tags: input, named, interface, output
export interface ScheduleAction {
  ActionName: string;
  ScheduleActionSettings: ScheduleActionSettings;
  ScheduleActionStartSettings: ScheduleActionStartSettings;
}
function fromScheduleAction(input?: ScheduleAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionName: input["ActionName"],
    scheduleActionSettings: fromScheduleActionSettings(input["ScheduleActionSettings"]),
    scheduleActionStartSettings: fromScheduleActionStartSettings(input["ScheduleActionStartSettings"]),
  }
}
function toScheduleAction(root: jsonP.JSONValue): ScheduleAction {
  return jsonP.readObj({
    required: {
      "ActionName": "s",
      "ScheduleActionSettings": toScheduleActionSettings,
      "ScheduleActionStartSettings": toScheduleActionStartSettings,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ScheduleActionSettings {
  HlsId3SegmentTaggingSettings?: HlsId3SegmentTaggingScheduleActionSettings | null;
  HlsTimedMetadataSettings?: HlsTimedMetadataScheduleActionSettings | null;
  InputPrepareSettings?: InputPrepareScheduleActionSettings | null;
  InputSwitchSettings?: InputSwitchScheduleActionSettings | null;
  PauseStateSettings?: PauseStateScheduleActionSettings | null;
  Scte35ReturnToNetworkSettings?: Scte35ReturnToNetworkScheduleActionSettings | null;
  Scte35SpliceInsertSettings?: Scte35SpliceInsertScheduleActionSettings | null;
  Scte35TimeSignalSettings?: Scte35TimeSignalScheduleActionSettings | null;
  StaticImageActivateSettings?: StaticImageActivateScheduleActionSettings | null;
  StaticImageDeactivateSettings?: StaticImageDeactivateScheduleActionSettings | null;
}
function fromScheduleActionSettings(input?: ScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsId3SegmentTaggingSettings: fromHlsId3SegmentTaggingScheduleActionSettings(input["HlsId3SegmentTaggingSettings"]),
    hlsTimedMetadataSettings: fromHlsTimedMetadataScheduleActionSettings(input["HlsTimedMetadataSettings"]),
    inputPrepareSettings: fromInputPrepareScheduleActionSettings(input["InputPrepareSettings"]),
    inputSwitchSettings: fromInputSwitchScheduleActionSettings(input["InputSwitchSettings"]),
    pauseStateSettings: fromPauseStateScheduleActionSettings(input["PauseStateSettings"]),
    scte35ReturnToNetworkSettings: fromScte35ReturnToNetworkScheduleActionSettings(input["Scte35ReturnToNetworkSettings"]),
    scte35SpliceInsertSettings: fromScte35SpliceInsertScheduleActionSettings(input["Scte35SpliceInsertSettings"]),
    scte35TimeSignalSettings: fromScte35TimeSignalScheduleActionSettings(input["Scte35TimeSignalSettings"]),
    staticImageActivateSettings: fromStaticImageActivateScheduleActionSettings(input["StaticImageActivateSettings"]),
    staticImageDeactivateSettings: fromStaticImageDeactivateScheduleActionSettings(input["StaticImageDeactivateSettings"]),
  }
}
function toScheduleActionSettings(root: jsonP.JSONValue): ScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsId3SegmentTaggingSettings": toHlsId3SegmentTaggingScheduleActionSettings,
      "HlsTimedMetadataSettings": toHlsTimedMetadataScheduleActionSettings,
      "InputPrepareSettings": toInputPrepareScheduleActionSettings,
      "InputSwitchSettings": toInputSwitchScheduleActionSettings,
      "PauseStateSettings": toPauseStateScheduleActionSettings,
      "Scte35ReturnToNetworkSettings": toScte35ReturnToNetworkScheduleActionSettings,
      "Scte35SpliceInsertSettings": toScte35SpliceInsertScheduleActionSettings,
      "Scte35TimeSignalSettings": toScte35TimeSignalScheduleActionSettings,
      "StaticImageActivateSettings": toStaticImageActivateScheduleActionSettings,
      "StaticImageDeactivateSettings": toStaticImageDeactivateScheduleActionSettings,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface HlsId3SegmentTaggingScheduleActionSettings {
  Tag: string;
}
function fromHlsId3SegmentTaggingScheduleActionSettings(input?: HlsId3SegmentTaggingScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tag: input["Tag"],
  }
}
function toHlsId3SegmentTaggingScheduleActionSettings(root: jsonP.JSONValue): HlsId3SegmentTaggingScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Tag": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface HlsTimedMetadataScheduleActionSettings {
  Id3: string;
}
function fromHlsTimedMetadataScheduleActionSettings(input?: HlsTimedMetadataScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id3: input["Id3"],
  }
}
function toHlsTimedMetadataScheduleActionSettings(root: jsonP.JSONValue): HlsTimedMetadataScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Id3": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface InputPrepareScheduleActionSettings {
  InputAttachmentNameReference?: string | null;
  InputClippingSettings?: InputClippingSettings | null;
  UrlPath?: string[] | null;
}
function fromInputPrepareScheduleActionSettings(input?: InputPrepareScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputAttachmentNameReference: input["InputAttachmentNameReference"],
    inputClippingSettings: fromInputClippingSettings(input["InputClippingSettings"]),
    urlPath: input["UrlPath"],
  }
}
function toInputPrepareScheduleActionSettings(root: jsonP.JSONValue): InputPrepareScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputAttachmentNameReference": "s",
      "InputClippingSettings": toInputClippingSettings,
      "UrlPath": ["s"],
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface InputClippingSettings {
  InputTimecodeSource: InputTimecodeSource;
  StartTimecode?: StartTimecode | null;
  StopTimecode?: StopTimecode | null;
}
function fromInputClippingSettings(input?: InputClippingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputTimecodeSource: input["InputTimecodeSource"],
    startTimecode: fromStartTimecode(input["StartTimecode"]),
    stopTimecode: fromStopTimecode(input["StopTimecode"]),
  }
}
function toInputClippingSettings(root: jsonP.JSONValue): InputClippingSettings {
  return jsonP.readObj({
    required: {
      "InputTimecodeSource": (x: jsonP.JSONValue) => cmnP.readEnum<InputTimecodeSource>(x),
    },
    optional: {
      "StartTimecode": toStartTimecode,
      "StopTimecode": toStopTimecode,
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type InputTimecodeSource =
| "ZEROBASED"
| "EMBEDDED"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface StartTimecode {
  Timecode?: string | null;
}
function fromStartTimecode(input?: StartTimecode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    timecode: input["Timecode"],
  }
}
function toStartTimecode(root: jsonP.JSONValue): StartTimecode {
  return jsonP.readObj({
    required: {},
    optional: {
      "Timecode": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface StopTimecode {
  LastFrameClippingBehavior?: LastFrameClippingBehavior | null;
  Timecode?: string | null;
}
function fromStopTimecode(input?: StopTimecode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    lastFrameClippingBehavior: input["LastFrameClippingBehavior"],
    timecode: input["Timecode"],
  }
}
function toStopTimecode(root: jsonP.JSONValue): StopTimecode {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastFrameClippingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<LastFrameClippingBehavior>(x),
      "Timecode": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type LastFrameClippingBehavior =
| "EXCLUDE_LAST_FRAME"
| "INCLUDE_LAST_FRAME"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface InputSwitchScheduleActionSettings {
  InputAttachmentNameReference: string;
  InputClippingSettings?: InputClippingSettings | null;
  UrlPath?: string[] | null;
}
function fromInputSwitchScheduleActionSettings(input?: InputSwitchScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputAttachmentNameReference: input["InputAttachmentNameReference"],
    inputClippingSettings: fromInputClippingSettings(input["InputClippingSettings"]),
    urlPath: input["UrlPath"],
  }
}
function toInputSwitchScheduleActionSettings(root: jsonP.JSONValue): InputSwitchScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "InputAttachmentNameReference": "s",
    },
    optional: {
      "InputClippingSettings": toInputClippingSettings,
      "UrlPath": ["s"],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PauseStateScheduleActionSettings {
  Pipelines?: PipelinePauseStateSettings[] | null;
}
function fromPauseStateScheduleActionSettings(input?: PauseStateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pipelines: input["Pipelines"]?.map(x => fromPipelinePauseStateSettings(x)),
  }
}
function toPauseStateScheduleActionSettings(root: jsonP.JSONValue): PauseStateScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pipelines": [toPipelinePauseStateSettings],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PipelinePauseStateSettings {
  PipelineId: PipelineId;
}
function fromPipelinePauseStateSettings(input?: PipelinePauseStateSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pipelineId: input["PipelineId"],
  }
}
function toPipelinePauseStateSettings(root: jsonP.JSONValue): PipelinePauseStateSettings {
  return jsonP.readObj({
    required: {
      "PipelineId": (x: jsonP.JSONValue) => cmnP.readEnum<PipelineId>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type PipelineId =
| "PIPELINE_0"
| "PIPELINE_1"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface Scte35ReturnToNetworkScheduleActionSettings {
  SpliceEventId: number;
}
function fromScte35ReturnToNetworkScheduleActionSettings(input?: Scte35ReturnToNetworkScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    spliceEventId: input["SpliceEventId"],
  }
}
function toScte35ReturnToNetworkScheduleActionSettings(root: jsonP.JSONValue): Scte35ReturnToNetworkScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "SpliceEventId": "n",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35SpliceInsertScheduleActionSettings {
  Duration?: number | null;
  SpliceEventId: number;
}
function fromScte35SpliceInsertScheduleActionSettings(input?: Scte35SpliceInsertScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    spliceEventId: input["SpliceEventId"],
  }
}
function toScte35SpliceInsertScheduleActionSettings(root: jsonP.JSONValue): Scte35SpliceInsertScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "SpliceEventId": "n",
    },
    optional: {
      "Duration": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35TimeSignalScheduleActionSettings {
  Scte35Descriptors: Scte35Descriptor[];
}
function fromScte35TimeSignalScheduleActionSettings(input?: Scte35TimeSignalScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35Descriptors: input["Scte35Descriptors"]?.map(x => fromScte35Descriptor(x)),
  }
}
function toScte35TimeSignalScheduleActionSettings(root: jsonP.JSONValue): Scte35TimeSignalScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Scte35Descriptors": [toScte35Descriptor],
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35Descriptor {
  Scte35DescriptorSettings: Scte35DescriptorSettings;
}
function fromScte35Descriptor(input?: Scte35Descriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35DescriptorSettings: fromScte35DescriptorSettings(input["Scte35DescriptorSettings"]),
  }
}
function toScte35Descriptor(root: jsonP.JSONValue): Scte35Descriptor {
  return jsonP.readObj({
    required: {
      "Scte35DescriptorSettings": toScte35DescriptorSettings,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35DescriptorSettings {
  SegmentationDescriptorScte35DescriptorSettings: Scte35SegmentationDescriptor;
}
function fromScte35DescriptorSettings(input?: Scte35DescriptorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    segmentationDescriptorScte35DescriptorSettings: fromScte35SegmentationDescriptor(input["SegmentationDescriptorScte35DescriptorSettings"]),
  }
}
function toScte35DescriptorSettings(root: jsonP.JSONValue): Scte35DescriptorSettings {
  return jsonP.readObj({
    required: {
      "SegmentationDescriptorScte35DescriptorSettings": toScte35SegmentationDescriptor,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35SegmentationDescriptor {
  DeliveryRestrictions?: Scte35DeliveryRestrictions | null;
  SegmentNum?: number | null;
  SegmentationCancelIndicator: Scte35SegmentationCancelIndicator;
  SegmentationDuration?: number | null;
  SegmentationEventId: number;
  SegmentationTypeId?: number | null;
  SegmentationUpid?: string | null;
  SegmentationUpidType?: number | null;
  SegmentsExpected?: number | null;
  SubSegmentNum?: number | null;
  SubSegmentsExpected?: number | null;
}
function fromScte35SegmentationDescriptor(input?: Scte35SegmentationDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    deliveryRestrictions: fromScte35DeliveryRestrictions(input["DeliveryRestrictions"]),
    segmentNum: input["SegmentNum"],
    segmentationCancelIndicator: input["SegmentationCancelIndicator"],
    segmentationDuration: input["SegmentationDuration"],
    segmentationEventId: input["SegmentationEventId"],
    segmentationTypeId: input["SegmentationTypeId"],
    segmentationUpid: input["SegmentationUpid"],
    segmentationUpidType: input["SegmentationUpidType"],
    segmentsExpected: input["SegmentsExpected"],
    subSegmentNum: input["SubSegmentNum"],
    subSegmentsExpected: input["SubSegmentsExpected"],
  }
}
function toScte35SegmentationDescriptor(root: jsonP.JSONValue): Scte35SegmentationDescriptor {
  return jsonP.readObj({
    required: {
      "SegmentationCancelIndicator": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35SegmentationCancelIndicator>(x),
      "SegmentationEventId": "n",
    },
    optional: {
      "DeliveryRestrictions": toScte35DeliveryRestrictions,
      "SegmentNum": "n",
      "SegmentationDuration": "n",
      "SegmentationTypeId": "n",
      "SegmentationUpid": "s",
      "SegmentationUpidType": "n",
      "SegmentsExpected": "n",
      "SubSegmentNum": "n",
      "SubSegmentsExpected": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface Scte35DeliveryRestrictions {
  ArchiveAllowedFlag: Scte35ArchiveAllowedFlag;
  DeviceRestrictions: Scte35DeviceRestrictions;
  NoRegionalBlackoutFlag: Scte35NoRegionalBlackoutFlag;
  WebDeliveryAllowedFlag: Scte35WebDeliveryAllowedFlag;
}
function fromScte35DeliveryRestrictions(input?: Scte35DeliveryRestrictions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveAllowedFlag: input["ArchiveAllowedFlag"],
    deviceRestrictions: input["DeviceRestrictions"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35DeliveryRestrictions(root: jsonP.JSONValue): Scte35DeliveryRestrictions {
  return jsonP.readObj({
    required: {
      "ArchiveAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35ArchiveAllowedFlag>(x),
      "DeviceRestrictions": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35DeviceRestrictions>(x),
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35NoRegionalBlackoutFlag>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35WebDeliveryAllowedFlag>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type Scte35ArchiveAllowedFlag =
| "ARCHIVE_NOT_ALLOWED"
| "ARCHIVE_ALLOWED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Scte35DeviceRestrictions =
| "NONE"
| "RESTRICT_GROUP0"
| "RESTRICT_GROUP1"
| "RESTRICT_GROUP2"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Scte35NoRegionalBlackoutFlag =
| "REGIONAL_BLACKOUT"
| "NO_REGIONAL_BLACKOUT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Scte35WebDeliveryAllowedFlag =
| "WEB_DELIVERY_NOT_ALLOWED"
| "WEB_DELIVERY_ALLOWED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type Scte35SegmentationCancelIndicator =
| "SEGMENTATION_EVENT_NOT_CANCELED"
| "SEGMENTATION_EVENT_CANCELED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface StaticImageActivateScheduleActionSettings {
  Duration?: number | null;
  FadeIn?: number | null;
  FadeOut?: number | null;
  Height?: number | null;
  Image: InputLocation;
  ImageX?: number | null;
  ImageY?: number | null;
  Layer?: number | null;
  Opacity?: number | null;
  Width?: number | null;
}
function fromStaticImageActivateScheduleActionSettings(input?: StaticImageActivateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    duration: input["Duration"],
    fadeIn: input["FadeIn"],
    fadeOut: input["FadeOut"],
    height: input["Height"],
    image: fromInputLocation(input["Image"]),
    imageX: input["ImageX"],
    imageY: input["ImageY"],
    layer: input["Layer"],
    opacity: input["Opacity"],
    width: input["Width"],
  }
}
function toStaticImageActivateScheduleActionSettings(root: jsonP.JSONValue): StaticImageActivateScheduleActionSettings {
  return jsonP.readObj({
    required: {
      "Image": toInputLocation,
    },
    optional: {
      "Duration": "n",
      "FadeIn": "n",
      "FadeOut": "n",
      "Height": "n",
      "ImageX": "n",
      "ImageY": "n",
      "Layer": "n",
      "Opacity": "n",
      "Width": "n",
    },
  }, root);
}

// refs: 76 - tags: input, named, interface, output
export interface InputLocation {
  PasswordParam?: string | null;
  Uri: string;
  Username?: string | null;
}
function fromInputLocation(input?: InputLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    uri: input["Uri"],
    username: input["Username"],
  }
}
function toInputLocation(root: jsonP.JSONValue): InputLocation {
  return jsonP.readObj({
    required: {
      "Uri": "s",
    },
    optional: {
      "PasswordParam": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface StaticImageDeactivateScheduleActionSettings {
  FadeOut?: number | null;
  Layer?: number | null;
}
function fromStaticImageDeactivateScheduleActionSettings(input?: StaticImageDeactivateScheduleActionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fadeOut: input["FadeOut"],
    layer: input["Layer"],
  }
}
function toStaticImageDeactivateScheduleActionSettings(root: jsonP.JSONValue): StaticImageDeactivateScheduleActionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FadeOut": "n",
      "Layer": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ScheduleActionStartSettings {
  FixedModeScheduleActionStartSettings?: FixedModeScheduleActionStartSettings | null;
  FollowModeScheduleActionStartSettings?: FollowModeScheduleActionStartSettings | null;
  ImmediateModeScheduleActionStartSettings?: ImmediateModeScheduleActionStartSettings | null;
}
function fromScheduleActionStartSettings(input?: ScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fixedModeScheduleActionStartSettings: fromFixedModeScheduleActionStartSettings(input["FixedModeScheduleActionStartSettings"]),
    followModeScheduleActionStartSettings: fromFollowModeScheduleActionStartSettings(input["FollowModeScheduleActionStartSettings"]),
    immediateModeScheduleActionStartSettings: fromImmediateModeScheduleActionStartSettings(input["ImmediateModeScheduleActionStartSettings"]),
  }
}
function toScheduleActionStartSettings(root: jsonP.JSONValue): ScheduleActionStartSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FixedModeScheduleActionStartSettings": toFixedModeScheduleActionStartSettings,
      "FollowModeScheduleActionStartSettings": toFollowModeScheduleActionStartSettings,
      "ImmediateModeScheduleActionStartSettings": toImmediateModeScheduleActionStartSettings,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FixedModeScheduleActionStartSettings {
  Time: string;
}
function fromFixedModeScheduleActionStartSettings(input?: FixedModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    time: input["Time"],
  }
}
function toFixedModeScheduleActionStartSettings(root: jsonP.JSONValue): FixedModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {
      "Time": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FollowModeScheduleActionStartSettings {
  FollowPoint: FollowPoint;
  ReferenceActionName: string;
}
function fromFollowModeScheduleActionStartSettings(input?: FollowModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    followPoint: input["FollowPoint"],
    referenceActionName: input["ReferenceActionName"],
  }
}
function toFollowModeScheduleActionStartSettings(root: jsonP.JSONValue): FollowModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {
      "FollowPoint": (x: jsonP.JSONValue) => cmnP.readEnum<FollowPoint>(x),
      "ReferenceActionName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type FollowPoint =
| "END"
| "START"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ImmediateModeScheduleActionStartSettings {
}
function fromImmediateModeScheduleActionStartSettings(input?: ImmediateModeScheduleActionStartSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toImmediateModeScheduleActionStartSettings(root: jsonP.JSONValue): ImmediateModeScheduleActionStartSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface BatchScheduleActionDeleteRequest {
  ActionNames: string[];
}
function fromBatchScheduleActionDeleteRequest(input?: BatchScheduleActionDeleteRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    actionNames: input["ActionNames"],
  }
}

// refs: 10 - tags: input, named, interface, output
export interface CdiInputSpecification {
  Resolution?: CdiInputResolution | null;
}
function fromCdiInputSpecification(input?: CdiInputSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    resolution: input["Resolution"],
  }
}
function toCdiInputSpecification(root: jsonP.JSONValue): CdiInputSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<CdiInputResolution>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type CdiInputResolution =
| "SD"
| "HD"
| "FHD"
| "UHD"
| cmnP.UnexpectedEnumValue;

// refs: 17 - tags: input, named, enum, output
export type ChannelClass =
| "STANDARD"
| "SINGLE_PIPELINE"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface OutputDestination {
  Id?: string | null;
  MediaPackageSettings?: MediaPackageOutputDestinationSettings[] | null;
  MultiplexSettings?: MultiplexProgramChannelDestinationSettings | null;
  Settings?: OutputDestinationSettings[] | null;
}
function fromOutputDestination(input?: OutputDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
    mediaPackageSettings: input["MediaPackageSettings"]?.map(x => fromMediaPackageOutputDestinationSettings(x)),
    multiplexSettings: fromMultiplexProgramChannelDestinationSettings(input["MultiplexSettings"]),
    settings: input["Settings"]?.map(x => fromOutputDestinationSettings(x)),
  }
}
function toOutputDestination(root: jsonP.JSONValue): OutputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "MediaPackageSettings": [toMediaPackageOutputDestinationSettings],
      "MultiplexSettings": toMultiplexProgramChannelDestinationSettings,
      "Settings": [toOutputDestinationSettings],
    },
  }, root);
}

// refs: 11 - tags: input, named, interface, output
export interface MediaPackageOutputDestinationSettings {
  ChannelId?: string | null;
}
function fromMediaPackageOutputDestinationSettings(input?: MediaPackageOutputDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelId: input["ChannelId"],
  }
}
function toMediaPackageOutputDestinationSettings(root: jsonP.JSONValue): MediaPackageOutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
    },
  }, root);
}

// refs: 11 - tags: input, named, interface, output
export interface MultiplexProgramChannelDestinationSettings {
  MultiplexId?: string | null;
  ProgramName?: string | null;
}
function fromMultiplexProgramChannelDestinationSettings(input?: MultiplexProgramChannelDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    multiplexId: input["MultiplexId"],
    programName: input["ProgramName"],
  }
}
function toMultiplexProgramChannelDestinationSettings(root: jsonP.JSONValue): MultiplexProgramChannelDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MultiplexId": "s",
      "ProgramName": "s",
    },
  }, root);
}

// refs: 11 - tags: input, named, interface, output
export interface OutputDestinationSettings {
  PasswordParam?: string | null;
  StreamName?: string | null;
  Url?: string | null;
  Username?: string | null;
}
function fromOutputDestinationSettings(input?: OutputDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    streamName: input["StreamName"],
    url: input["Url"],
    username: input["Username"],
  }
}
function toOutputDestinationSettings(root: jsonP.JSONValue): OutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PasswordParam": "s",
      "StreamName": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface EncoderSettings {
  AudioDescriptions: AudioDescription[];
  AvailBlanking?: AvailBlanking | null;
  AvailConfiguration?: AvailConfiguration | null;
  BlackoutSlate?: BlackoutSlate | null;
  CaptionDescriptions?: CaptionDescription[] | null;
  FeatureActivations?: FeatureActivations | null;
  GlobalConfiguration?: GlobalConfiguration | null;
  NielsenConfiguration?: NielsenConfiguration | null;
  OutputGroups: OutputGroup[];
  TimecodeConfig: TimecodeConfig;
  VideoDescriptions: VideoDescription[];
}
function fromEncoderSettings(input?: EncoderSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptions: input["AudioDescriptions"]?.map(x => fromAudioDescription(x)),
    availBlanking: fromAvailBlanking(input["AvailBlanking"]),
    availConfiguration: fromAvailConfiguration(input["AvailConfiguration"]),
    blackoutSlate: fromBlackoutSlate(input["BlackoutSlate"]),
    captionDescriptions: input["CaptionDescriptions"]?.map(x => fromCaptionDescription(x)),
    featureActivations: fromFeatureActivations(input["FeatureActivations"]),
    globalConfiguration: fromGlobalConfiguration(input["GlobalConfiguration"]),
    nielsenConfiguration: fromNielsenConfiguration(input["NielsenConfiguration"]),
    outputGroups: input["OutputGroups"]?.map(x => fromOutputGroup(x)),
    timecodeConfig: fromTimecodeConfig(input["TimecodeConfig"]),
    videoDescriptions: input["VideoDescriptions"]?.map(x => fromVideoDescription(x)),
  }
}
function toEncoderSettings(root: jsonP.JSONValue): EncoderSettings {
  return jsonP.readObj({
    required: {
      "AudioDescriptions": [toAudioDescription],
      "OutputGroups": [toOutputGroup],
      "TimecodeConfig": toTimecodeConfig,
      "VideoDescriptions": [toVideoDescription],
    },
    optional: {
      "AvailBlanking": toAvailBlanking,
      "AvailConfiguration": toAvailConfiguration,
      "BlackoutSlate": toBlackoutSlate,
      "CaptionDescriptions": [toCaptionDescription],
      "FeatureActivations": toFeatureActivations,
      "GlobalConfiguration": toGlobalConfiguration,
      "NielsenConfiguration": toNielsenConfiguration,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AudioDescription {
  AudioNormalizationSettings?: AudioNormalizationSettings | null;
  AudioSelectorName: string;
  AudioType?: AudioType | null;
  AudioTypeControl?: AudioDescriptionAudioTypeControl | null;
  CodecSettings?: AudioCodecSettings | null;
  LanguageCode?: string | null;
  LanguageCodeControl?: AudioDescriptionLanguageCodeControl | null;
  Name: string;
  RemixSettings?: RemixSettings | null;
  StreamName?: string | null;
}
function fromAudioDescription(input?: AudioDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioNormalizationSettings: fromAudioNormalizationSettings(input["AudioNormalizationSettings"]),
    audioSelectorName: input["AudioSelectorName"],
    audioType: input["AudioType"],
    audioTypeControl: input["AudioTypeControl"],
    codecSettings: fromAudioCodecSettings(input["CodecSettings"]),
    languageCode: input["LanguageCode"],
    languageCodeControl: input["LanguageCodeControl"],
    name: input["Name"],
    remixSettings: fromRemixSettings(input["RemixSettings"]),
    streamName: input["StreamName"],
  }
}
function toAudioDescription(root: jsonP.JSONValue): AudioDescription {
  return jsonP.readObj({
    required: {
      "AudioSelectorName": "s",
      "Name": "s",
    },
    optional: {
      "AudioNormalizationSettings": toAudioNormalizationSettings,
      "AudioType": (x: jsonP.JSONValue) => cmnP.readEnum<AudioType>(x),
      "AudioTypeControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioDescriptionAudioTypeControl>(x),
      "CodecSettings": toAudioCodecSettings,
      "LanguageCode": "s",
      "LanguageCodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioDescriptionLanguageCodeControl>(x),
      "RemixSettings": toRemixSettings,
      "StreamName": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AudioNormalizationSettings {
  Algorithm?: AudioNormalizationAlgorithm | null;
  AlgorithmControl?: AudioNormalizationAlgorithmControl | null;
  TargetLkfs?: number | null;
}
function fromAudioNormalizationSettings(input?: AudioNormalizationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    algorithm: input["Algorithm"],
    algorithmControl: input["AlgorithmControl"],
    targetLkfs: input["TargetLkfs"],
  }
}
function toAudioNormalizationSettings(root: jsonP.JSONValue): AudioNormalizationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Algorithm": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationAlgorithm>(x),
      "AlgorithmControl": (x: jsonP.JSONValue) => cmnP.readEnum<AudioNormalizationAlgorithmControl>(x),
      "TargetLkfs": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type AudioNormalizationAlgorithm =
| "ITU_1770_1"
| "ITU_1770_2"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AudioNormalizationAlgorithmControl =
| "CORRECT_AUDIO"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AudioType =
| "CLEAN_EFFECTS"
| "HEARING_IMPAIRED"
| "UNDEFINED"
| "VISUAL_IMPAIRED_COMMENTARY"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AudioDescriptionAudioTypeControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface AudioCodecSettings {
  AacSettings?: AacSettings | null;
  Ac3Settings?: Ac3Settings | null;
  Eac3Settings?: Eac3Settings | null;
  Mp2Settings?: Mp2Settings | null;
  PassThroughSettings?: PassThroughSettings | null;
  WavSettings?: WavSettings | null;
}
function fromAudioCodecSettings(input?: AudioCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aacSettings: fromAacSettings(input["AacSettings"]),
    ac3Settings: fromAc3Settings(input["Ac3Settings"]),
    eac3Settings: fromEac3Settings(input["Eac3Settings"]),
    mp2Settings: fromMp2Settings(input["Mp2Settings"]),
    passThroughSettings: fromPassThroughSettings(input["PassThroughSettings"]),
    wavSettings: fromWavSettings(input["WavSettings"]),
  }
}
function toAudioCodecSettings(root: jsonP.JSONValue): AudioCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AacSettings": toAacSettings,
      "Ac3Settings": toAc3Settings,
      "Eac3Settings": toEac3Settings,
      "Mp2Settings": toMp2Settings,
      "PassThroughSettings": toPassThroughSettings,
      "WavSettings": toWavSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AacSettings {
  Bitrate?: number | null;
  CodingMode?: AacCodingMode | null;
  InputType?: AacInputType | null;
  Profile?: AacProfile | null;
  RateControlMode?: AacRateControlMode | null;
  RawFormat?: AacRawFormat | null;
  SampleRate?: number | null;
  Spec?: AacSpec | null;
  VbrQuality?: AacVbrQuality | null;
}
function fromAacSettings(input?: AacSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    codingMode: input["CodingMode"],
    inputType: input["InputType"],
    profile: input["Profile"],
    rateControlMode: input["RateControlMode"],
    rawFormat: input["RawFormat"],
    sampleRate: input["SampleRate"],
    spec: input["Spec"],
    vbrQuality: input["VbrQuality"],
  }
}
function toAacSettings(root: jsonP.JSONValue): AacSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<AacCodingMode>(x),
      "InputType": (x: jsonP.JSONValue) => cmnP.readEnum<AacInputType>(x),
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<AacProfile>(x),
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<AacRateControlMode>(x),
      "RawFormat": (x: jsonP.JSONValue) => cmnP.readEnum<AacRawFormat>(x),
      "SampleRate": "n",
      "Spec": (x: jsonP.JSONValue) => cmnP.readEnum<AacSpec>(x),
      "VbrQuality": (x: jsonP.JSONValue) => cmnP.readEnum<AacVbrQuality>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type AacCodingMode =
| "AD_RECEIVER_MIX"
| "CODING_MODE_1_0"
| "CODING_MODE_1_1"
| "CODING_MODE_2_0"
| "CODING_MODE_5_1"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacInputType =
| "BROADCASTER_MIXED_AD"
| "NORMAL"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacProfile =
| "HEV1"
| "HEV2"
| "LC"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacRateControlMode =
| "CBR"
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacRawFormat =
| "LATM_LOAS"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacSpec =
| "MPEG2"
| "MPEG4"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AacVbrQuality =
| "HIGH"
| "LOW"
| "MEDIUM_HIGH"
| "MEDIUM_LOW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Ac3Settings {
  Bitrate?: number | null;
  BitstreamMode?: Ac3BitstreamMode | null;
  CodingMode?: Ac3CodingMode | null;
  Dialnorm?: number | null;
  DrcProfile?: Ac3DrcProfile | null;
  LfeFilter?: Ac3LfeFilter | null;
  MetadataControl?: Ac3MetadataControl | null;
}
function fromAc3Settings(input?: Ac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dialnorm: input["Dialnorm"],
    drcProfile: input["DrcProfile"],
    lfeFilter: input["LfeFilter"],
    metadataControl: input["MetadataControl"],
  }
}
function toAc3Settings(root: jsonP.JSONValue): Ac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3CodingMode>(x),
      "Dialnorm": "n",
      "DrcProfile": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3DrcProfile>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3LfeFilter>(x),
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<Ac3MetadataControl>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Ac3BitstreamMode =
| "COMMENTARY"
| "COMPLETE_MAIN"
| "DIALOGUE"
| "EMERGENCY"
| "HEARING_IMPAIRED"
| "MUSIC_AND_EFFECTS"
| "VISUALLY_IMPAIRED"
| "VOICE_OVER"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Ac3CodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_1_1"
| "CODING_MODE_2_0"
| "CODING_MODE_3_2_LFE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Ac3DrcProfile =
| "FILM_STANDARD"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Ac3LfeFilter =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Ac3MetadataControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Eac3Settings {
  AttenuationControl?: Eac3AttenuationControl | null;
  Bitrate?: number | null;
  BitstreamMode?: Eac3BitstreamMode | null;
  CodingMode?: Eac3CodingMode | null;
  DcFilter?: Eac3DcFilter | null;
  Dialnorm?: number | null;
  DrcLine?: Eac3DrcLine | null;
  DrcRf?: Eac3DrcRf | null;
  LfeControl?: Eac3LfeControl | null;
  LfeFilter?: Eac3LfeFilter | null;
  LoRoCenterMixLevel?: number | null;
  LoRoSurroundMixLevel?: number | null;
  LtRtCenterMixLevel?: number | null;
  LtRtSurroundMixLevel?: number | null;
  MetadataControl?: Eac3MetadataControl | null;
  PassthroughControl?: Eac3PassthroughControl | null;
  PhaseControl?: Eac3PhaseControl | null;
  StereoDownmix?: Eac3StereoDownmix | null;
  SurroundExMode?: Eac3SurroundExMode | null;
  SurroundMode?: Eac3SurroundMode | null;
}
function fromEac3Settings(input?: Eac3Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    attenuationControl: input["AttenuationControl"],
    bitrate: input["Bitrate"],
    bitstreamMode: input["BitstreamMode"],
    codingMode: input["CodingMode"],
    dcFilter: input["DcFilter"],
    dialnorm: input["Dialnorm"],
    drcLine: input["DrcLine"],
    drcRf: input["DrcRf"],
    lfeControl: input["LfeControl"],
    lfeFilter: input["LfeFilter"],
    loRoCenterMixLevel: input["LoRoCenterMixLevel"],
    loRoSurroundMixLevel: input["LoRoSurroundMixLevel"],
    ltRtCenterMixLevel: input["LtRtCenterMixLevel"],
    ltRtSurroundMixLevel: input["LtRtSurroundMixLevel"],
    metadataControl: input["MetadataControl"],
    passthroughControl: input["PassthroughControl"],
    phaseControl: input["PhaseControl"],
    stereoDownmix: input["StereoDownmix"],
    surroundExMode: input["SurroundExMode"],
    surroundMode: input["SurroundMode"],
  }
}
function toEac3Settings(root: jsonP.JSONValue): Eac3Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AttenuationControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3AttenuationControl>(x),
      "Bitrate": "n",
      "BitstreamMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3BitstreamMode>(x),
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3CodingMode>(x),
      "DcFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DcFilter>(x),
      "Dialnorm": "n",
      "DrcLine": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DrcLine>(x),
      "DrcRf": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3DrcRf>(x),
      "LfeControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3LfeControl>(x),
      "LfeFilter": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3LfeFilter>(x),
      "LoRoCenterMixLevel": "n",
      "LoRoSurroundMixLevel": "n",
      "LtRtCenterMixLevel": "n",
      "LtRtSurroundMixLevel": "n",
      "MetadataControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3MetadataControl>(x),
      "PassthroughControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3PassthroughControl>(x),
      "PhaseControl": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3PhaseControl>(x),
      "StereoDownmix": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3StereoDownmix>(x),
      "SurroundExMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3SurroundExMode>(x),
      "SurroundMode": (x: jsonP.JSONValue) => cmnP.readEnum<Eac3SurroundMode>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Eac3AttenuationControl =
| "ATTENUATE_3_DB"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3BitstreamMode =
| "COMMENTARY"
| "COMPLETE_MAIN"
| "EMERGENCY"
| "HEARING_IMPAIRED"
| "VISUALLY_IMPAIRED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3CodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_2_0"
| "CODING_MODE_3_2"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3DcFilter =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3DrcLine =
| "FILM_LIGHT"
| "FILM_STANDARD"
| "MUSIC_LIGHT"
| "MUSIC_STANDARD"
| "NONE"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3DrcRf =
| "FILM_LIGHT"
| "FILM_STANDARD"
| "MUSIC_LIGHT"
| "MUSIC_STANDARD"
| "NONE"
| "SPEECH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3LfeControl =
| "LFE"
| "NO_LFE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3LfeFilter =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3MetadataControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3PassthroughControl =
| "NO_PASSTHROUGH"
| "WHEN_POSSIBLE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3PhaseControl =
| "NO_SHIFT"
| "SHIFT_90_DEGREES"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3StereoDownmix =
| "DPL2"
| "LO_RO"
| "LT_RT"
| "NOT_INDICATED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3SurroundExMode =
| "DISABLED"
| "ENABLED"
| "NOT_INDICATED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Eac3SurroundMode =
| "DISABLED"
| "ENABLED"
| "NOT_INDICATED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Mp2Settings {
  Bitrate?: number | null;
  CodingMode?: Mp2CodingMode | null;
  SampleRate?: number | null;
}
function fromMp2Settings(input?: Mp2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitrate: input["Bitrate"],
    codingMode: input["CodingMode"],
    sampleRate: input["SampleRate"],
  }
}
function toMp2Settings(root: jsonP.JSONValue): Mp2Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bitrate": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<Mp2CodingMode>(x),
      "SampleRate": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Mp2CodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_2_0"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface PassThroughSettings {
}
function fromPassThroughSettings(input?: PassThroughSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toPassThroughSettings(root: jsonP.JSONValue): PassThroughSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface WavSettings {
  BitDepth?: number | null;
  CodingMode?: WavCodingMode | null;
  SampleRate?: number | null;
}
function fromWavSettings(input?: WavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bitDepth: input["BitDepth"],
    codingMode: input["CodingMode"],
    sampleRate: input["SampleRate"],
  }
}
function toWavSettings(root: jsonP.JSONValue): WavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BitDepth": "n",
      "CodingMode": (x: jsonP.JSONValue) => cmnP.readEnum<WavCodingMode>(x),
      "SampleRate": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type WavCodingMode =
| "CODING_MODE_1_0"
| "CODING_MODE_2_0"
| "CODING_MODE_4_0"
| "CODING_MODE_8_0"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AudioDescriptionLanguageCodeControl =
| "FOLLOW_INPUT"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface RemixSettings {
  ChannelMappings: AudioChannelMapping[];
  ChannelsIn?: number | null;
  ChannelsOut?: number | null;
}
function fromRemixSettings(input?: RemixSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    channelMappings: input["ChannelMappings"]?.map(x => fromAudioChannelMapping(x)),
    channelsIn: input["ChannelsIn"],
    channelsOut: input["ChannelsOut"],
  }
}
function toRemixSettings(root: jsonP.JSONValue): RemixSettings {
  return jsonP.readObj({
    required: {
      "ChannelMappings": [toAudioChannelMapping],
    },
    optional: {
      "ChannelsIn": "n",
      "ChannelsOut": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AudioChannelMapping {
  InputChannelLevels: InputChannelLevel[];
  OutputChannel: number;
}
function fromAudioChannelMapping(input?: AudioChannelMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputChannelLevels: input["InputChannelLevels"]?.map(x => fromInputChannelLevel(x)),
    outputChannel: input["OutputChannel"],
  }
}
function toAudioChannelMapping(root: jsonP.JSONValue): AudioChannelMapping {
  return jsonP.readObj({
    required: {
      "InputChannelLevels": [toInputChannelLevel],
      "OutputChannel": "n",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface InputChannelLevel {
  Gain: number;
  InputChannel: number;
}
function fromInputChannelLevel(input?: InputChannelLevel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    gain: input["Gain"],
    inputChannel: input["InputChannel"],
  }
}
function toInputChannelLevel(root: jsonP.JSONValue): InputChannelLevel {
  return jsonP.readObj({
    required: {
      "Gain": "n",
      "InputChannel": "n",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AvailBlanking {
  AvailBlankingImage?: InputLocation | null;
  State?: AvailBlankingState | null;
}
function fromAvailBlanking(input?: AvailBlanking | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availBlankingImage: fromInputLocation(input["AvailBlankingImage"]),
    state: input["State"],
  }
}
function toAvailBlanking(root: jsonP.JSONValue): AvailBlanking {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailBlankingImage": toInputLocation,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<AvailBlankingState>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type AvailBlankingState =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface AvailConfiguration {
  AvailSettings?: AvailSettings | null;
}
function fromAvailConfiguration(input?: AvailConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    availSettings: fromAvailSettings(input["AvailSettings"]),
  }
}
function toAvailConfiguration(root: jsonP.JSONValue): AvailConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailSettings": toAvailSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AvailSettings {
  Scte35SpliceInsert?: Scte35SpliceInsert | null;
  Scte35TimeSignalApos?: Scte35TimeSignalApos | null;
}
function fromAvailSettings(input?: AvailSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scte35SpliceInsert: fromScte35SpliceInsert(input["Scte35SpliceInsert"]),
    scte35TimeSignalApos: fromScte35TimeSignalApos(input["Scte35TimeSignalApos"]),
  }
}
function toAvailSettings(root: jsonP.JSONValue): AvailSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Scte35SpliceInsert": toScte35SpliceInsert,
      "Scte35TimeSignalApos": toScte35TimeSignalApos,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Scte35SpliceInsert {
  AdAvailOffset?: number | null;
  NoRegionalBlackoutFlag?: Scte35SpliceInsertNoRegionalBlackoutBehavior | null;
  WebDeliveryAllowedFlag?: Scte35SpliceInsertWebDeliveryAllowedBehavior | null;
}
function fromScte35SpliceInsert(input?: Scte35SpliceInsert | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35SpliceInsert(root: jsonP.JSONValue): Scte35SpliceInsert {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35SpliceInsertNoRegionalBlackoutBehavior>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35SpliceInsertWebDeliveryAllowedBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Scte35SpliceInsertNoRegionalBlackoutBehavior =
| "FOLLOW"
| "IGNORE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Scte35SpliceInsertWebDeliveryAllowedBehavior =
| "FOLLOW"
| "IGNORE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Scte35TimeSignalApos {
  AdAvailOffset?: number | null;
  NoRegionalBlackoutFlag?: Scte35AposNoRegionalBlackoutBehavior | null;
  WebDeliveryAllowedFlag?: Scte35AposWebDeliveryAllowedBehavior | null;
}
function fromScte35TimeSignalApos(input?: Scte35TimeSignalApos | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adAvailOffset: input["AdAvailOffset"],
    noRegionalBlackoutFlag: input["NoRegionalBlackoutFlag"],
    webDeliveryAllowedFlag: input["WebDeliveryAllowedFlag"],
  }
}
function toScte35TimeSignalApos(root: jsonP.JSONValue): Scte35TimeSignalApos {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdAvailOffset": "n",
      "NoRegionalBlackoutFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35AposNoRegionalBlackoutBehavior>(x),
      "WebDeliveryAllowedFlag": (x: jsonP.JSONValue) => cmnP.readEnum<Scte35AposWebDeliveryAllowedBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Scte35AposNoRegionalBlackoutBehavior =
| "FOLLOW"
| "IGNORE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Scte35AposWebDeliveryAllowedBehavior =
| "FOLLOW"
| "IGNORE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface BlackoutSlate {
  BlackoutSlateImage?: InputLocation | null;
  NetworkEndBlackout?: BlackoutSlateNetworkEndBlackout | null;
  NetworkEndBlackoutImage?: InputLocation | null;
  NetworkId?: string | null;
  State?: BlackoutSlateState | null;
}
function fromBlackoutSlate(input?: BlackoutSlate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackoutSlateImage: fromInputLocation(input["BlackoutSlateImage"]),
    networkEndBlackout: input["NetworkEndBlackout"],
    networkEndBlackoutImage: fromInputLocation(input["NetworkEndBlackoutImage"]),
    networkId: input["NetworkId"],
    state: input["State"],
  }
}
function toBlackoutSlate(root: jsonP.JSONValue): BlackoutSlate {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackoutSlateImage": toInputLocation,
      "NetworkEndBlackout": (x: jsonP.JSONValue) => cmnP.readEnum<BlackoutSlateNetworkEndBlackout>(x),
      "NetworkEndBlackoutImage": toInputLocation,
      "NetworkId": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<BlackoutSlateState>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type BlackoutSlateNetworkEndBlackout =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BlackoutSlateState =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface CaptionDescription {
  CaptionSelectorName: string;
  DestinationSettings?: CaptionDestinationSettings | null;
  LanguageCode?: string | null;
  LanguageDescription?: string | null;
  Name: string;
}
function fromCaptionDescription(input?: CaptionDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionSelectorName: input["CaptionSelectorName"],
    destinationSettings: fromCaptionDestinationSettings(input["DestinationSettings"]),
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
    name: input["Name"],
  }
}
function toCaptionDescription(root: jsonP.JSONValue): CaptionDescription {
  return jsonP.readObj({
    required: {
      "CaptionSelectorName": "s",
      "Name": "s",
    },
    optional: {
      "DestinationSettings": toCaptionDestinationSettings,
      "LanguageCode": "s",
      "LanguageDescription": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface CaptionDestinationSettings {
  AribDestinationSettings?: AribDestinationSettings | null;
  BurnInDestinationSettings?: BurnInDestinationSettings | null;
  DvbSubDestinationSettings?: DvbSubDestinationSettings | null;
  EbuTtDDestinationSettings?: EbuTtDDestinationSettings | null;
  EmbeddedDestinationSettings?: EmbeddedDestinationSettings | null;
  EmbeddedPlusScte20DestinationSettings?: EmbeddedPlusScte20DestinationSettings | null;
  RtmpCaptionInfoDestinationSettings?: RtmpCaptionInfoDestinationSettings | null;
  Scte20PlusEmbeddedDestinationSettings?: Scte20PlusEmbeddedDestinationSettings | null;
  Scte27DestinationSettings?: Scte27DestinationSettings | null;
  SmpteTtDestinationSettings?: SmpteTtDestinationSettings | null;
  TeletextDestinationSettings?: TeletextDestinationSettings | null;
  TtmlDestinationSettings?: TtmlDestinationSettings | null;
  WebvttDestinationSettings?: WebvttDestinationSettings | null;
}
function fromCaptionDestinationSettings(input?: CaptionDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    aribDestinationSettings: fromAribDestinationSettings(input["AribDestinationSettings"]),
    burnInDestinationSettings: fromBurnInDestinationSettings(input["BurnInDestinationSettings"]),
    dvbSubDestinationSettings: fromDvbSubDestinationSettings(input["DvbSubDestinationSettings"]),
    ebuTtDDestinationSettings: fromEbuTtDDestinationSettings(input["EbuTtDDestinationSettings"]),
    embeddedDestinationSettings: fromEmbeddedDestinationSettings(input["EmbeddedDestinationSettings"]),
    embeddedPlusScte20DestinationSettings: fromEmbeddedPlusScte20DestinationSettings(input["EmbeddedPlusScte20DestinationSettings"]),
    rtmpCaptionInfoDestinationSettings: fromRtmpCaptionInfoDestinationSettings(input["RtmpCaptionInfoDestinationSettings"]),
    scte20PlusEmbeddedDestinationSettings: fromScte20PlusEmbeddedDestinationSettings(input["Scte20PlusEmbeddedDestinationSettings"]),
    scte27DestinationSettings: fromScte27DestinationSettings(input["Scte27DestinationSettings"]),
    smpteTtDestinationSettings: fromSmpteTtDestinationSettings(input["SmpteTtDestinationSettings"]),
    teletextDestinationSettings: fromTeletextDestinationSettings(input["TeletextDestinationSettings"]),
    ttmlDestinationSettings: fromTtmlDestinationSettings(input["TtmlDestinationSettings"]),
    webvttDestinationSettings: fromWebvttDestinationSettings(input["WebvttDestinationSettings"]),
  }
}
function toCaptionDestinationSettings(root: jsonP.JSONValue): CaptionDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AribDestinationSettings": toAribDestinationSettings,
      "BurnInDestinationSettings": toBurnInDestinationSettings,
      "DvbSubDestinationSettings": toDvbSubDestinationSettings,
      "EbuTtDDestinationSettings": toEbuTtDDestinationSettings,
      "EmbeddedDestinationSettings": toEmbeddedDestinationSettings,
      "EmbeddedPlusScte20DestinationSettings": toEmbeddedPlusScte20DestinationSettings,
      "RtmpCaptionInfoDestinationSettings": toRtmpCaptionInfoDestinationSettings,
      "Scte20PlusEmbeddedDestinationSettings": toScte20PlusEmbeddedDestinationSettings,
      "Scte27DestinationSettings": toScte27DestinationSettings,
      "SmpteTtDestinationSettings": toSmpteTtDestinationSettings,
      "TeletextDestinationSettings": toTeletextDestinationSettings,
      "TtmlDestinationSettings": toTtmlDestinationSettings,
      "WebvttDestinationSettings": toWebvttDestinationSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AribDestinationSettings {
}
function fromAribDestinationSettings(input?: AribDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAribDestinationSettings(root: jsonP.JSONValue): AribDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface BurnInDestinationSettings {
  Alignment?: BurnInAlignment | null;
  BackgroundColor?: BurnInBackgroundColor | null;
  BackgroundOpacity?: number | null;
  Font?: InputLocation | null;
  FontColor?: BurnInFontColor | null;
  FontOpacity?: number | null;
  FontResolution?: number | null;
  FontSize?: string | null;
  OutlineColor?: BurnInOutlineColor | null;
  OutlineSize?: number | null;
  ShadowColor?: BurnInShadowColor | null;
  ShadowOpacity?: number | null;
  ShadowXOffset?: number | null;
  ShadowYOffset?: number | null;
  TeletextGridControl?: BurnInTeletextGridControl | null;
  XPosition?: number | null;
  YPosition?: number | null;
}
function fromBurnInDestinationSettings(input?: BurnInDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    font: fromInputLocation(input["Font"]),
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextGridControl: input["TeletextGridControl"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toBurnInDestinationSettings(root: jsonP.JSONValue): BurnInDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "Font": toInputLocation,
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontSize": "s",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextGridControl": (x: jsonP.JSONValue) => cmnP.readEnum<BurnInTeletextGridControl>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type BurnInAlignment =
| "CENTERED"
| "LEFT"
| "SMART"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BurnInBackgroundColor =
| "BLACK"
| "NONE"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BurnInFontColor =
| "BLACK"
| "BLUE"
| "GREEN"
| "RED"
| "WHITE"
| "YELLOW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BurnInOutlineColor =
| "BLACK"
| "BLUE"
| "GREEN"
| "RED"
| "WHITE"
| "YELLOW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BurnInShadowColor =
| "BLACK"
| "NONE"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type BurnInTeletextGridControl =
| "FIXED"
| "SCALED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface DvbSubDestinationSettings {
  Alignment?: DvbSubDestinationAlignment | null;
  BackgroundColor?: DvbSubDestinationBackgroundColor | null;
  BackgroundOpacity?: number | null;
  Font?: InputLocation | null;
  FontColor?: DvbSubDestinationFontColor | null;
  FontOpacity?: number | null;
  FontResolution?: number | null;
  FontSize?: string | null;
  OutlineColor?: DvbSubDestinationOutlineColor | null;
  OutlineSize?: number | null;
  ShadowColor?: DvbSubDestinationShadowColor | null;
  ShadowOpacity?: number | null;
  ShadowXOffset?: number | null;
  ShadowYOffset?: number | null;
  TeletextGridControl?: DvbSubDestinationTeletextGridControl | null;
  XPosition?: number | null;
  YPosition?: number | null;
}
function fromDvbSubDestinationSettings(input?: DvbSubDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    alignment: input["Alignment"],
    backgroundColor: input["BackgroundColor"],
    backgroundOpacity: input["BackgroundOpacity"],
    font: fromInputLocation(input["Font"]),
    fontColor: input["FontColor"],
    fontOpacity: input["FontOpacity"],
    fontResolution: input["FontResolution"],
    fontSize: input["FontSize"],
    outlineColor: input["OutlineColor"],
    outlineSize: input["OutlineSize"],
    shadowColor: input["ShadowColor"],
    shadowOpacity: input["ShadowOpacity"],
    shadowXOffset: input["ShadowXOffset"],
    shadowYOffset: input["ShadowYOffset"],
    teletextGridControl: input["TeletextGridControl"],
    xPosition: input["XPosition"],
    yPosition: input["YPosition"],
  }
}
function toDvbSubDestinationSettings(root: jsonP.JSONValue): DvbSubDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alignment": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationAlignment>(x),
      "BackgroundColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationBackgroundColor>(x),
      "BackgroundOpacity": "n",
      "Font": toInputLocation,
      "FontColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationFontColor>(x),
      "FontOpacity": "n",
      "FontResolution": "n",
      "FontSize": "s",
      "OutlineColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationOutlineColor>(x),
      "OutlineSize": "n",
      "ShadowColor": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationShadowColor>(x),
      "ShadowOpacity": "n",
      "ShadowXOffset": "n",
      "ShadowYOffset": "n",
      "TeletextGridControl": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSubDestinationTeletextGridControl>(x),
      "XPosition": "n",
      "YPosition": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationAlignment =
| "CENTERED"
| "LEFT"
| "SMART"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationBackgroundColor =
| "BLACK"
| "NONE"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationFontColor =
| "BLACK"
| "BLUE"
| "GREEN"
| "RED"
| "WHITE"
| "YELLOW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationOutlineColor =
| "BLACK"
| "BLUE"
| "GREEN"
| "RED"
| "WHITE"
| "YELLOW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationShadowColor =
| "BLACK"
| "NONE"
| "WHITE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type DvbSubDestinationTeletextGridControl =
| "FIXED"
| "SCALED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface EbuTtDDestinationSettings {
  FillLineGap?: EbuTtDFillLineGapControl | null;
  FontFamily?: string | null;
  StyleControl?: EbuTtDDestinationStyleControl | null;
}
function fromEbuTtDDestinationSettings(input?: EbuTtDDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fillLineGap: input["FillLineGap"],
    fontFamily: input["FontFamily"],
    styleControl: input["StyleControl"],
  }
}
function toEbuTtDDestinationSettings(root: jsonP.JSONValue): EbuTtDDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FillLineGap": (x: jsonP.JSONValue) => cmnP.readEnum<EbuTtDFillLineGapControl>(x),
      "FontFamily": "s",
      "StyleControl": (x: jsonP.JSONValue) => cmnP.readEnum<EbuTtDDestinationStyleControl>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type EbuTtDFillLineGapControl =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type EbuTtDDestinationStyleControl =
| "EXCLUDE"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface EmbeddedDestinationSettings {
}
function fromEmbeddedDestinationSettings(input?: EmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toEmbeddedDestinationSettings(root: jsonP.JSONValue): EmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface EmbeddedPlusScte20DestinationSettings {
}
function fromEmbeddedPlusScte20DestinationSettings(input?: EmbeddedPlusScte20DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toEmbeddedPlusScte20DestinationSettings(root: jsonP.JSONValue): EmbeddedPlusScte20DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface RtmpCaptionInfoDestinationSettings {
}
function fromRtmpCaptionInfoDestinationSettings(input?: RtmpCaptionInfoDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRtmpCaptionInfoDestinationSettings(root: jsonP.JSONValue): RtmpCaptionInfoDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Scte20PlusEmbeddedDestinationSettings {
}
function fromScte20PlusEmbeddedDestinationSettings(input?: Scte20PlusEmbeddedDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toScte20PlusEmbeddedDestinationSettings(root: jsonP.JSONValue): Scte20PlusEmbeddedDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Scte27DestinationSettings {
}
function fromScte27DestinationSettings(input?: Scte27DestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toScte27DestinationSettings(root: jsonP.JSONValue): Scte27DestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface SmpteTtDestinationSettings {
}
function fromSmpteTtDestinationSettings(input?: SmpteTtDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toSmpteTtDestinationSettings(root: jsonP.JSONValue): SmpteTtDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface TeletextDestinationSettings {
}
function fromTeletextDestinationSettings(input?: TeletextDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toTeletextDestinationSettings(root: jsonP.JSONValue): TeletextDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface TtmlDestinationSettings {
  StyleControl?: TtmlDestinationStyleControl | null;
}
function fromTtmlDestinationSettings(input?: TtmlDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    styleControl: input["StyleControl"],
  }
}
function toTtmlDestinationSettings(root: jsonP.JSONValue): TtmlDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StyleControl": (x: jsonP.JSONValue) => cmnP.readEnum<TtmlDestinationStyleControl>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type TtmlDestinationStyleControl =
| "PASSTHROUGH"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface WebvttDestinationSettings {
}
function fromWebvttDestinationSettings(input?: WebvttDestinationSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toWebvttDestinationSettings(root: jsonP.JSONValue): WebvttDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface FeatureActivations {
  InputPrepareScheduleActions?: FeatureActivationsInputPrepareScheduleActions | null;
}
function fromFeatureActivations(input?: FeatureActivations | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputPrepareScheduleActions: input["InputPrepareScheduleActions"],
  }
}
function toFeatureActivations(root: jsonP.JSONValue): FeatureActivations {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputPrepareScheduleActions": (x: jsonP.JSONValue) => cmnP.readEnum<FeatureActivationsInputPrepareScheduleActions>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type FeatureActivationsInputPrepareScheduleActions =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface GlobalConfiguration {
  InitialAudioGain?: number | null;
  InputEndAction?: GlobalConfigurationInputEndAction | null;
  InputLossBehavior?: InputLossBehavior | null;
  OutputLockingMode?: GlobalConfigurationOutputLockingMode | null;
  OutputTimingSource?: GlobalConfigurationOutputTimingSource | null;
  SupportLowFramerateInputs?: GlobalConfigurationLowFramerateInputs | null;
}
function fromGlobalConfiguration(input?: GlobalConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    initialAudioGain: input["InitialAudioGain"],
    inputEndAction: input["InputEndAction"],
    inputLossBehavior: fromInputLossBehavior(input["InputLossBehavior"]),
    outputLockingMode: input["OutputLockingMode"],
    outputTimingSource: input["OutputTimingSource"],
    supportLowFramerateInputs: input["SupportLowFramerateInputs"],
  }
}
function toGlobalConfiguration(root: jsonP.JSONValue): GlobalConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "InitialAudioGain": "n",
      "InputEndAction": (x: jsonP.JSONValue) => cmnP.readEnum<GlobalConfigurationInputEndAction>(x),
      "InputLossBehavior": toInputLossBehavior,
      "OutputLockingMode": (x: jsonP.JSONValue) => cmnP.readEnum<GlobalConfigurationOutputLockingMode>(x),
      "OutputTimingSource": (x: jsonP.JSONValue) => cmnP.readEnum<GlobalConfigurationOutputTimingSource>(x),
      "SupportLowFramerateInputs": (x: jsonP.JSONValue) => cmnP.readEnum<GlobalConfigurationLowFramerateInputs>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type GlobalConfigurationInputEndAction =
| "NONE"
| "SWITCH_AND_LOOP_INPUTS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface InputLossBehavior {
  BlackFrameMsec?: number | null;
  InputLossImageColor?: string | null;
  InputLossImageSlate?: InputLocation | null;
  InputLossImageType?: InputLossImageType | null;
  RepeatFrameMsec?: number | null;
}
function fromInputLossBehavior(input?: InputLossBehavior | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackFrameMsec: input["BlackFrameMsec"],
    inputLossImageColor: input["InputLossImageColor"],
    inputLossImageSlate: fromInputLocation(input["InputLossImageSlate"]),
    inputLossImageType: input["InputLossImageType"],
    repeatFrameMsec: input["RepeatFrameMsec"],
  }
}
function toInputLossBehavior(root: jsonP.JSONValue): InputLossBehavior {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackFrameMsec": "n",
      "InputLossImageColor": "s",
      "InputLossImageSlate": toInputLocation,
      "InputLossImageType": (x: jsonP.JSONValue) => cmnP.readEnum<InputLossImageType>(x),
      "RepeatFrameMsec": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type InputLossImageType =
| "COLOR"
| "SLATE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type GlobalConfigurationOutputLockingMode =
| "EPOCH_LOCKING"
| "PIPELINE_LOCKING"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type GlobalConfigurationOutputTimingSource =
| "INPUT_CLOCK"
| "SYSTEM_CLOCK"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type GlobalConfigurationLowFramerateInputs =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface NielsenConfiguration {
  DistributorId?: string | null;
  NielsenPcmToId3Tagging?: NielsenPcmToId3TaggingState | null;
}
function fromNielsenConfiguration(input?: NielsenConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    distributorId: input["DistributorId"],
    nielsenPcmToId3Tagging: input["NielsenPcmToId3Tagging"],
  }
}
function toNielsenConfiguration(root: jsonP.JSONValue): NielsenConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "DistributorId": "s",
      "NielsenPcmToId3Tagging": (x: jsonP.JSONValue) => cmnP.readEnum<NielsenPcmToId3TaggingState>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type NielsenPcmToId3TaggingState =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface OutputGroup {
  Name?: string | null;
  OutputGroupSettings: OutputGroupSettings;
  Outputs: Output[];
}
function fromOutputGroup(input?: OutputGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    outputGroupSettings: fromOutputGroupSettings(input["OutputGroupSettings"]),
    outputs: input["Outputs"]?.map(x => fromOutput(x)),
  }
}
function toOutputGroup(root: jsonP.JSONValue): OutputGroup {
  return jsonP.readObj({
    required: {
      "OutputGroupSettings": toOutputGroupSettings,
      "Outputs": [toOutput],
    },
    optional: {
      "Name": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface OutputGroupSettings {
  ArchiveGroupSettings?: ArchiveGroupSettings | null;
  FrameCaptureGroupSettings?: FrameCaptureGroupSettings | null;
  HlsGroupSettings?: HlsGroupSettings | null;
  MediaPackageGroupSettings?: MediaPackageGroupSettings | null;
  MsSmoothGroupSettings?: MsSmoothGroupSettings | null;
  MultiplexGroupSettings?: MultiplexGroupSettings | null;
  RtmpGroupSettings?: RtmpGroupSettings | null;
  UdpGroupSettings?: UdpGroupSettings | null;
}
function fromOutputGroupSettings(input?: OutputGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveGroupSettings: fromArchiveGroupSettings(input["ArchiveGroupSettings"]),
    frameCaptureGroupSettings: fromFrameCaptureGroupSettings(input["FrameCaptureGroupSettings"]),
    hlsGroupSettings: fromHlsGroupSettings(input["HlsGroupSettings"]),
    mediaPackageGroupSettings: fromMediaPackageGroupSettings(input["MediaPackageGroupSettings"]),
    msSmoothGroupSettings: fromMsSmoothGroupSettings(input["MsSmoothGroupSettings"]),
    multiplexGroupSettings: fromMultiplexGroupSettings(input["MultiplexGroupSettings"]),
    rtmpGroupSettings: fromRtmpGroupSettings(input["RtmpGroupSettings"]),
    udpGroupSettings: fromUdpGroupSettings(input["UdpGroupSettings"]),
  }
}
function toOutputGroupSettings(root: jsonP.JSONValue): OutputGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchiveGroupSettings": toArchiveGroupSettings,
      "FrameCaptureGroupSettings": toFrameCaptureGroupSettings,
      "HlsGroupSettings": toHlsGroupSettings,
      "MediaPackageGroupSettings": toMediaPackageGroupSettings,
      "MsSmoothGroupSettings": toMsSmoothGroupSettings,
      "MultiplexGroupSettings": toMultiplexGroupSettings,
      "RtmpGroupSettings": toRtmpGroupSettings,
      "UdpGroupSettings": toUdpGroupSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface ArchiveGroupSettings {
  Destination: OutputLocationRef;
  RolloverInterval?: number | null;
}
function fromArchiveGroupSettings(input?: ArchiveGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
    rolloverInterval: input["RolloverInterval"],
  }
}
function toArchiveGroupSettings(root: jsonP.JSONValue): ArchiveGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "RolloverInterval": "n",
    },
  }, root);
}

// refs: 72 - tags: input, named, interface, output
export interface OutputLocationRef {
  DestinationRefId?: string | null;
}
function fromOutputLocationRef(input?: OutputLocationRef | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinationRefId: input["DestinationRefId"],
  }
}
function toOutputLocationRef(root: jsonP.JSONValue): OutputLocationRef {
  return jsonP.readObj({
    required: {},
    optional: {
      "DestinationRefId": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface FrameCaptureGroupSettings {
  Destination: OutputLocationRef;
}
function fromFrameCaptureGroupSettings(input?: FrameCaptureGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toFrameCaptureGroupSettings(root: jsonP.JSONValue): FrameCaptureGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface HlsGroupSettings {
  AdMarkers?: HlsAdMarkers[] | null;
  BaseUrlContent?: string | null;
  BaseUrlContent1?: string | null;
  BaseUrlManifest?: string | null;
  BaseUrlManifest1?: string | null;
  CaptionLanguageMappings?: CaptionLanguageMapping[] | null;
  CaptionLanguageSetting?: HlsCaptionLanguageSetting | null;
  ClientCache?: HlsClientCache | null;
  CodecSpecification?: HlsCodecSpecification | null;
  ConstantIv?: string | null;
  Destination: OutputLocationRef;
  DirectoryStructure?: HlsDirectoryStructure | null;
  DiscontinuityTags?: HlsDiscontinuityTags | null;
  EncryptionType?: HlsEncryptionType | null;
  HlsCdnSettings?: HlsCdnSettings | null;
  HlsId3SegmentTagging?: HlsId3SegmentTaggingState | null;
  IFrameOnlyPlaylists?: IFrameOnlyPlaylistType | null;
  IncompleteSegmentBehavior?: HlsIncompleteSegmentBehavior | null;
  IndexNSegments?: number | null;
  InputLossAction?: InputLossActionForHlsOut | null;
  IvInManifest?: HlsIvInManifest | null;
  IvSource?: HlsIvSource | null;
  KeepSegments?: number | null;
  KeyFormat?: string | null;
  KeyFormatVersions?: string | null;
  KeyProviderSettings?: KeyProviderSettings | null;
  ManifestCompression?: HlsManifestCompression | null;
  ManifestDurationFormat?: HlsManifestDurationFormat | null;
  MinSegmentLength?: number | null;
  Mode?: HlsMode | null;
  OutputSelection?: HlsOutputSelection | null;
  ProgramDateTime?: HlsProgramDateTime | null;
  ProgramDateTimePeriod?: number | null;
  RedundantManifest?: HlsRedundantManifest | null;
  SegmentLength?: number | null;
  SegmentationMode?: HlsSegmentationMode | null;
  SegmentsPerSubdirectory?: number | null;
  StreamInfResolution?: HlsStreamInfResolution | null;
  TimedMetadataId3Frame?: HlsTimedMetadataId3Frame | null;
  TimedMetadataId3Period?: number | null;
  TimestampDeltaMilliseconds?: number | null;
  TsFileMode?: HlsTsFileMode | null;
}
function fromHlsGroupSettings(input?: HlsGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    baseUrlContent: input["BaseUrlContent"],
    baseUrlContent1: input["BaseUrlContent1"],
    baseUrlManifest: input["BaseUrlManifest"],
    baseUrlManifest1: input["BaseUrlManifest1"],
    captionLanguageMappings: input["CaptionLanguageMappings"]?.map(x => fromCaptionLanguageMapping(x)),
    captionLanguageSetting: input["CaptionLanguageSetting"],
    clientCache: input["ClientCache"],
    codecSpecification: input["CodecSpecification"],
    constantIv: input["ConstantIv"],
    destination: fromOutputLocationRef(input["Destination"]),
    directoryStructure: input["DirectoryStructure"],
    discontinuityTags: input["DiscontinuityTags"],
    encryptionType: input["EncryptionType"],
    hlsCdnSettings: fromHlsCdnSettings(input["HlsCdnSettings"]),
    hlsId3SegmentTagging: input["HlsId3SegmentTagging"],
    iFrameOnlyPlaylists: input["IFrameOnlyPlaylists"],
    incompleteSegmentBehavior: input["IncompleteSegmentBehavior"],
    indexNSegments: input["IndexNSegments"],
    inputLossAction: input["InputLossAction"],
    ivInManifest: input["IvInManifest"],
    ivSource: input["IvSource"],
    keepSegments: input["KeepSegments"],
    keyFormat: input["KeyFormat"],
    keyFormatVersions: input["KeyFormatVersions"],
    keyProviderSettings: fromKeyProviderSettings(input["KeyProviderSettings"]),
    manifestCompression: input["ManifestCompression"],
    manifestDurationFormat: input["ManifestDurationFormat"],
    minSegmentLength: input["MinSegmentLength"],
    mode: input["Mode"],
    outputSelection: input["OutputSelection"],
    programDateTime: input["ProgramDateTime"],
    programDateTimePeriod: input["ProgramDateTimePeriod"],
    redundantManifest: input["RedundantManifest"],
    segmentLength: input["SegmentLength"],
    segmentationMode: input["SegmentationMode"],
    segmentsPerSubdirectory: input["SegmentsPerSubdirectory"],
    streamInfResolution: input["StreamInfResolution"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
    timestampDeltaMilliseconds: input["TimestampDeltaMilliseconds"],
    tsFileMode: input["TsFileMode"],
  }
}
function toHlsGroupSettings(root: jsonP.JSONValue): HlsGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<HlsAdMarkers>(x)],
      "BaseUrlContent": "s",
      "BaseUrlContent1": "s",
      "BaseUrlManifest": "s",
      "BaseUrlManifest1": "s",
      "CaptionLanguageMappings": [toCaptionLanguageMapping],
      "CaptionLanguageSetting": (x: jsonP.JSONValue) => cmnP.readEnum<HlsCaptionLanguageSetting>(x),
      "ClientCache": (x: jsonP.JSONValue) => cmnP.readEnum<HlsClientCache>(x),
      "CodecSpecification": (x: jsonP.JSONValue) => cmnP.readEnum<HlsCodecSpecification>(x),
      "ConstantIv": "s",
      "DirectoryStructure": (x: jsonP.JSONValue) => cmnP.readEnum<HlsDirectoryStructure>(x),
      "DiscontinuityTags": (x: jsonP.JSONValue) => cmnP.readEnum<HlsDiscontinuityTags>(x),
      "EncryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<HlsEncryptionType>(x),
      "HlsCdnSettings": toHlsCdnSettings,
      "HlsId3SegmentTagging": (x: jsonP.JSONValue) => cmnP.readEnum<HlsId3SegmentTaggingState>(x),
      "IFrameOnlyPlaylists": (x: jsonP.JSONValue) => cmnP.readEnum<IFrameOnlyPlaylistType>(x),
      "IncompleteSegmentBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<HlsIncompleteSegmentBehavior>(x),
      "IndexNSegments": "n",
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<InputLossActionForHlsOut>(x),
      "IvInManifest": (x: jsonP.JSONValue) => cmnP.readEnum<HlsIvInManifest>(x),
      "IvSource": (x: jsonP.JSONValue) => cmnP.readEnum<HlsIvSource>(x),
      "KeepSegments": "n",
      "KeyFormat": "s",
      "KeyFormatVersions": "s",
      "KeyProviderSettings": toKeyProviderSettings,
      "ManifestCompression": (x: jsonP.JSONValue) => cmnP.readEnum<HlsManifestCompression>(x),
      "ManifestDurationFormat": (x: jsonP.JSONValue) => cmnP.readEnum<HlsManifestDurationFormat>(x),
      "MinSegmentLength": "n",
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<HlsMode>(x),
      "OutputSelection": (x: jsonP.JSONValue) => cmnP.readEnum<HlsOutputSelection>(x),
      "ProgramDateTime": (x: jsonP.JSONValue) => cmnP.readEnum<HlsProgramDateTime>(x),
      "ProgramDateTimePeriod": "n",
      "RedundantManifest": (x: jsonP.JSONValue) => cmnP.readEnum<HlsRedundantManifest>(x),
      "SegmentLength": "n",
      "SegmentationMode": (x: jsonP.JSONValue) => cmnP.readEnum<HlsSegmentationMode>(x),
      "SegmentsPerSubdirectory": "n",
      "StreamInfResolution": (x: jsonP.JSONValue) => cmnP.readEnum<HlsStreamInfResolution>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<HlsTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
      "TimestampDeltaMilliseconds": "n",
      "TsFileMode": (x: jsonP.JSONValue) => cmnP.readEnum<HlsTsFileMode>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsAdMarkers =
| "ADOBE"
| "ELEMENTAL"
| "ELEMENTAL_SCTE35"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface CaptionLanguageMapping {
  CaptionChannel: number;
  LanguageCode: string;
  LanguageDescription: string;
}
function fromCaptionLanguageMapping(input?: CaptionLanguageMapping | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captionChannel: input["CaptionChannel"],
    languageCode: input["LanguageCode"],
    languageDescription: input["LanguageDescription"],
  }
}
function toCaptionLanguageMapping(root: jsonP.JSONValue): CaptionLanguageMapping {
  return jsonP.readObj({
    required: {
      "CaptionChannel": "n",
      "LanguageCode": "s",
      "LanguageDescription": "s",
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsCaptionLanguageSetting =
| "INSERT"
| "NONE"
| "OMIT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsClientCache =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsCodecSpecification =
| "RFC_4281"
| "RFC_6381"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsDirectoryStructure =
| "SINGLE_DIRECTORY"
| "SUBDIRECTORY_PER_STREAM"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsDiscontinuityTags =
| "INSERT"
| "NEVER_INSERT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsEncryptionType =
| "AES128"
| "SAMPLE_AES"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface HlsCdnSettings {
  HlsAkamaiSettings?: HlsAkamaiSettings | null;
  HlsBasicPutSettings?: HlsBasicPutSettings | null;
  HlsMediaStoreSettings?: HlsMediaStoreSettings | null;
  HlsWebdavSettings?: HlsWebdavSettings | null;
}
function fromHlsCdnSettings(input?: HlsCdnSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsAkamaiSettings: fromHlsAkamaiSettings(input["HlsAkamaiSettings"]),
    hlsBasicPutSettings: fromHlsBasicPutSettings(input["HlsBasicPutSettings"]),
    hlsMediaStoreSettings: fromHlsMediaStoreSettings(input["HlsMediaStoreSettings"]),
    hlsWebdavSettings: fromHlsWebdavSettings(input["HlsWebdavSettings"]),
  }
}
function toHlsCdnSettings(root: jsonP.JSONValue): HlsCdnSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsAkamaiSettings": toHlsAkamaiSettings,
      "HlsBasicPutSettings": toHlsBasicPutSettings,
      "HlsMediaStoreSettings": toHlsMediaStoreSettings,
      "HlsWebdavSettings": toHlsWebdavSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface HlsAkamaiSettings {
  ConnectionRetryInterval?: number | null;
  FilecacheDuration?: number | null;
  HttpTransferMode?: HlsAkamaiHttpTransferMode | null;
  NumRetries?: number | null;
  RestartDelay?: number | null;
  Salt?: string | null;
  Token?: string | null;
}
function fromHlsAkamaiSettings(input?: HlsAkamaiSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    httpTransferMode: input["HttpTransferMode"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
    salt: input["Salt"],
    token: input["Token"],
  }
}
function toHlsAkamaiSettings(root: jsonP.JSONValue): HlsAkamaiSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "HttpTransferMode": (x: jsonP.JSONValue) => cmnP.readEnum<HlsAkamaiHttpTransferMode>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
      "Salt": "s",
      "Token": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsAkamaiHttpTransferMode =
| "CHUNKED"
| "NON_CHUNKED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface HlsBasicPutSettings {
  ConnectionRetryInterval?: number | null;
  FilecacheDuration?: number | null;
  NumRetries?: number | null;
  RestartDelay?: number | null;
}
function fromHlsBasicPutSettings(input?: HlsBasicPutSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsBasicPutSettings(root: jsonP.JSONValue): HlsBasicPutSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface HlsMediaStoreSettings {
  ConnectionRetryInterval?: number | null;
  FilecacheDuration?: number | null;
  MediaStoreStorageClass?: HlsMediaStoreStorageClass | null;
  NumRetries?: number | null;
  RestartDelay?: number | null;
}
function fromHlsMediaStoreSettings(input?: HlsMediaStoreSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    mediaStoreStorageClass: input["MediaStoreStorageClass"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsMediaStoreSettings(root: jsonP.JSONValue): HlsMediaStoreSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "MediaStoreStorageClass": (x: jsonP.JSONValue) => cmnP.readEnum<HlsMediaStoreStorageClass>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsMediaStoreStorageClass =
| "TEMPORAL"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface HlsWebdavSettings {
  ConnectionRetryInterval?: number | null;
  FilecacheDuration?: number | null;
  HttpTransferMode?: HlsWebdavHttpTransferMode | null;
  NumRetries?: number | null;
  RestartDelay?: number | null;
}
function fromHlsWebdavSettings(input?: HlsWebdavSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    connectionRetryInterval: input["ConnectionRetryInterval"],
    filecacheDuration: input["FilecacheDuration"],
    httpTransferMode: input["HttpTransferMode"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
  }
}
function toHlsWebdavSettings(root: jsonP.JSONValue): HlsWebdavSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionRetryInterval": "n",
      "FilecacheDuration": "n",
      "HttpTransferMode": (x: jsonP.JSONValue) => cmnP.readEnum<HlsWebdavHttpTransferMode>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsWebdavHttpTransferMode =
| "CHUNKED"
| "NON_CHUNKED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsId3SegmentTaggingState =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type IFrameOnlyPlaylistType =
| "DISABLED"
| "STANDARD"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsIncompleteSegmentBehavior =
| "AUTO"
| "SUPPRESS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type InputLossActionForHlsOut =
| "EMIT_OUTPUT"
| "PAUSE_OUTPUT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsIvInManifest =
| "EXCLUDE"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsIvSource =
| "EXPLICIT"
| "FOLLOWS_SEGMENT_NUMBER"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface KeyProviderSettings {
  StaticKeySettings?: StaticKeySettings | null;
}
function fromKeyProviderSettings(input?: KeyProviderSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    staticKeySettings: fromStaticKeySettings(input["StaticKeySettings"]),
  }
}
function toKeyProviderSettings(root: jsonP.JSONValue): KeyProviderSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "StaticKeySettings": toStaticKeySettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface StaticKeySettings {
  KeyProviderServer?: InputLocation | null;
  StaticKeyValue: string;
}
function fromStaticKeySettings(input?: StaticKeySettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    keyProviderServer: fromInputLocation(input["KeyProviderServer"]),
    staticKeyValue: input["StaticKeyValue"],
  }
}
function toStaticKeySettings(root: jsonP.JSONValue): StaticKeySettings {
  return jsonP.readObj({
    required: {
      "StaticKeyValue": "s",
    },
    optional: {
      "KeyProviderServer": toInputLocation,
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsManifestCompression =
| "GZIP"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsManifestDurationFormat =
| "FLOATING_POINT"
| "INTEGER"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsMode =
| "LIVE"
| "VOD"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsOutputSelection =
| "MANIFESTS_AND_SEGMENTS"
| "SEGMENTS_ONLY"
| "VARIANT_MANIFESTS_AND_SEGMENTS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsProgramDateTime =
| "EXCLUDE"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsRedundantManifest =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsSegmentationMode =
| "USE_INPUT_SEGMENTATION"
| "USE_SEGMENT_DURATION"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsStreamInfResolution =
| "EXCLUDE"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsTimedMetadataId3Frame =
| "NONE"
| "PRIV"
| "TDRL"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type HlsTsFileMode =
| "SEGMENTED_FILES"
| "SINGLE_FILE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface MediaPackageGroupSettings {
  Destination: OutputLocationRef;
}
function fromMediaPackageGroupSettings(input?: MediaPackageGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toMediaPackageGroupSettings(root: jsonP.JSONValue): MediaPackageGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface MsSmoothGroupSettings {
  AcquisitionPointId?: string | null;
  AudioOnlyTimecodeControl?: SmoothGroupAudioOnlyTimecodeControl | null;
  CertificateMode?: SmoothGroupCertificateMode | null;
  ConnectionRetryInterval?: number | null;
  Destination: OutputLocationRef;
  EventId?: string | null;
  EventIdMode?: SmoothGroupEventIdMode | null;
  EventStopBehavior?: SmoothGroupEventStopBehavior | null;
  FilecacheDuration?: number | null;
  FragmentLength?: number | null;
  InputLossAction?: InputLossActionForMsSmoothOut | null;
  NumRetries?: number | null;
  RestartDelay?: number | null;
  SegmentationMode?: SmoothGroupSegmentationMode | null;
  SendDelayMs?: number | null;
  SparseTrackType?: SmoothGroupSparseTrackType | null;
  StreamManifestBehavior?: SmoothGroupStreamManifestBehavior | null;
  TimestampOffset?: string | null;
  TimestampOffsetMode?: SmoothGroupTimestampOffsetMode | null;
}
function fromMsSmoothGroupSettings(input?: MsSmoothGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    acquisitionPointId: input["AcquisitionPointId"],
    audioOnlyTimecodeControl: input["AudioOnlyTimecodeControl"],
    certificateMode: input["CertificateMode"],
    connectionRetryInterval: input["ConnectionRetryInterval"],
    destination: fromOutputLocationRef(input["Destination"]),
    eventId: input["EventId"],
    eventIdMode: input["EventIdMode"],
    eventStopBehavior: input["EventStopBehavior"],
    filecacheDuration: input["FilecacheDuration"],
    fragmentLength: input["FragmentLength"],
    inputLossAction: input["InputLossAction"],
    numRetries: input["NumRetries"],
    restartDelay: input["RestartDelay"],
    segmentationMode: input["SegmentationMode"],
    sendDelayMs: input["SendDelayMs"],
    sparseTrackType: input["SparseTrackType"],
    streamManifestBehavior: input["StreamManifestBehavior"],
    timestampOffset: input["TimestampOffset"],
    timestampOffsetMode: input["TimestampOffsetMode"],
  }
}
function toMsSmoothGroupSettings(root: jsonP.JSONValue): MsSmoothGroupSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "AcquisitionPointId": "s",
      "AudioOnlyTimecodeControl": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupAudioOnlyTimecodeControl>(x),
      "CertificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupCertificateMode>(x),
      "ConnectionRetryInterval": "n",
      "EventId": "s",
      "EventIdMode": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupEventIdMode>(x),
      "EventStopBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupEventStopBehavior>(x),
      "FilecacheDuration": "n",
      "FragmentLength": "n",
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<InputLossActionForMsSmoothOut>(x),
      "NumRetries": "n",
      "RestartDelay": "n",
      "SegmentationMode": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupSegmentationMode>(x),
      "SendDelayMs": "n",
      "SparseTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupSparseTrackType>(x),
      "StreamManifestBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupStreamManifestBehavior>(x),
      "TimestampOffset": "s",
      "TimestampOffsetMode": (x: jsonP.JSONValue) => cmnP.readEnum<SmoothGroupTimestampOffsetMode>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupAudioOnlyTimecodeControl =
| "PASSTHROUGH"
| "USE_CONFIGURED_CLOCK"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupCertificateMode =
| "SELF_SIGNED"
| "VERIFY_AUTHENTICITY"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupEventIdMode =
| "NO_EVENT_ID"
| "USE_CONFIGURED"
| "USE_TIMESTAMP"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupEventStopBehavior =
| "NONE"
| "SEND_EOS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type InputLossActionForMsSmoothOut =
| "EMIT_OUTPUT"
| "PAUSE_OUTPUT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupSegmentationMode =
| "USE_INPUT_SEGMENTATION"
| "USE_SEGMENT_DURATION"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupSparseTrackType =
| "NONE"
| "SCTE_35"
| "SCTE_35_WITHOUT_SEGMENTATION"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupStreamManifestBehavior =
| "DO_NOT_SEND"
| "SEND"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type SmoothGroupTimestampOffsetMode =
| "USE_CONFIGURED_OFFSET"
| "USE_EVENT_START_DATE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface MultiplexGroupSettings {
}
function fromMultiplexGroupSettings(input?: MultiplexGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toMultiplexGroupSettings(root: jsonP.JSONValue): MultiplexGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface RtmpGroupSettings {
  AdMarkers?: RtmpAdMarkers[] | null;
  AuthenticationScheme?: AuthenticationScheme | null;
  CacheFullBehavior?: RtmpCacheFullBehavior | null;
  CacheLength?: number | null;
  CaptionData?: RtmpCaptionData | null;
  InputLossAction?: InputLossActionForRtmpOut | null;
  RestartDelay?: number | null;
}
function fromRtmpGroupSettings(input?: RtmpGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adMarkers: input["AdMarkers"],
    authenticationScheme: input["AuthenticationScheme"],
    cacheFullBehavior: input["CacheFullBehavior"],
    cacheLength: input["CacheLength"],
    captionData: input["CaptionData"],
    inputLossAction: input["InputLossAction"],
    restartDelay: input["RestartDelay"],
  }
}
function toRtmpGroupSettings(root: jsonP.JSONValue): RtmpGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdMarkers": [(x: jsonP.JSONValue) => cmnP.readEnum<RtmpAdMarkers>(x)],
      "AuthenticationScheme": (x: jsonP.JSONValue) => cmnP.readEnum<AuthenticationScheme>(x),
      "CacheFullBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<RtmpCacheFullBehavior>(x),
      "CacheLength": "n",
      "CaptionData": (x: jsonP.JSONValue) => cmnP.readEnum<RtmpCaptionData>(x),
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<InputLossActionForRtmpOut>(x),
      "RestartDelay": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type RtmpAdMarkers =
| "ON_CUE_POINT_SCTE35"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AuthenticationScheme =
| "AKAMAI"
| "COMMON"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type RtmpCacheFullBehavior =
| "DISCONNECT_IMMEDIATELY"
| "WAIT_FOR_SERVER"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type RtmpCaptionData =
| "ALL"
| "FIELD1_608"
| "FIELD1_AND_FIELD2_608"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type InputLossActionForRtmpOut =
| "EMIT_OUTPUT"
| "PAUSE_OUTPUT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface UdpGroupSettings {
  InputLossAction?: InputLossActionForUdpOut | null;
  TimedMetadataId3Frame?: UdpTimedMetadataId3Frame | null;
  TimedMetadataId3Period?: number | null;
}
function fromUdpGroupSettings(input?: UdpGroupSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputLossAction: input["InputLossAction"],
    timedMetadataId3Frame: input["TimedMetadataId3Frame"],
    timedMetadataId3Period: input["TimedMetadataId3Period"],
  }
}
function toUdpGroupSettings(root: jsonP.JSONValue): UdpGroupSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputLossAction": (x: jsonP.JSONValue) => cmnP.readEnum<InputLossActionForUdpOut>(x),
      "TimedMetadataId3Frame": (x: jsonP.JSONValue) => cmnP.readEnum<UdpTimedMetadataId3Frame>(x),
      "TimedMetadataId3Period": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type InputLossActionForUdpOut =
| "DROP_PROGRAM"
| "DROP_TS"
| "EMIT_PROGRAM"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type UdpTimedMetadataId3Frame =
| "NONE"
| "PRIV"
| "TDRL"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Output {
  AudioDescriptionNames?: string[] | null;
  CaptionDescriptionNames?: string[] | null;
  OutputName?: string | null;
  OutputSettings: OutputSettings;
  VideoDescriptionName?: string | null;
}
function fromOutput(input?: Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioDescriptionNames: input["AudioDescriptionNames"],
    captionDescriptionNames: input["CaptionDescriptionNames"],
    outputName: input["OutputName"],
    outputSettings: fromOutputSettings(input["OutputSettings"]),
    videoDescriptionName: input["VideoDescriptionName"],
  }
}
function toOutput(root: jsonP.JSONValue): Output {
  return jsonP.readObj({
    required: {
      "OutputSettings": toOutputSettings,
    },
    optional: {
      "AudioDescriptionNames": ["s"],
      "CaptionDescriptionNames": ["s"],
      "OutputName": "s",
      "VideoDescriptionName": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface OutputSettings {
  ArchiveOutputSettings?: ArchiveOutputSettings | null;
  FrameCaptureOutputSettings?: FrameCaptureOutputSettings | null;
  HlsOutputSettings?: HlsOutputSettings | null;
  MediaPackageOutputSettings?: MediaPackageOutputSettings | null;
  MsSmoothOutputSettings?: MsSmoothOutputSettings | null;
  MultiplexOutputSettings?: MultiplexOutputSettings | null;
  RtmpOutputSettings?: RtmpOutputSettings | null;
  UdpOutputSettings?: UdpOutputSettings | null;
}
function fromOutputSettings(input?: OutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    archiveOutputSettings: fromArchiveOutputSettings(input["ArchiveOutputSettings"]),
    frameCaptureOutputSettings: fromFrameCaptureOutputSettings(input["FrameCaptureOutputSettings"]),
    hlsOutputSettings: fromHlsOutputSettings(input["HlsOutputSettings"]),
    mediaPackageOutputSettings: fromMediaPackageOutputSettings(input["MediaPackageOutputSettings"]),
    msSmoothOutputSettings: fromMsSmoothOutputSettings(input["MsSmoothOutputSettings"]),
    multiplexOutputSettings: fromMultiplexOutputSettings(input["MultiplexOutputSettings"]),
    rtmpOutputSettings: fromRtmpOutputSettings(input["RtmpOutputSettings"]),
    udpOutputSettings: fromUdpOutputSettings(input["UdpOutputSettings"]),
  }
}
function toOutputSettings(root: jsonP.JSONValue): OutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArchiveOutputSettings": toArchiveOutputSettings,
      "FrameCaptureOutputSettings": toFrameCaptureOutputSettings,
      "HlsOutputSettings": toHlsOutputSettings,
      "MediaPackageOutputSettings": toMediaPackageOutputSettings,
      "MsSmoothOutputSettings": toMsSmoothOutputSettings,
      "MultiplexOutputSettings": toMultiplexOutputSettings,
      "RtmpOutputSettings": toRtmpOutputSettings,
      "UdpOutputSettings": toUdpOutputSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface ArchiveOutputSettings {
  ContainerSettings: ArchiveContainerSettings;
  Extension?: string | null;
  NameModifier?: string | null;
}
function fromArchiveOutputSettings(input?: ArchiveOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    containerSettings: fromArchiveContainerSettings(input["ContainerSettings"]),
    extension: input["Extension"],
    nameModifier: input["NameModifier"],
  }
}
function toArchiveOutputSettings(root: jsonP.JSONValue): ArchiveOutputSettings {
  return jsonP.readObj({
    required: {
      "ContainerSettings": toArchiveContainerSettings,
    },
    optional: {
      "Extension": "s",
      "NameModifier": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface ArchiveContainerSettings {
  M2tsSettings?: M2tsSettings | null;
  RawSettings?: RawSettings | null;
}
function fromArchiveContainerSettings(input?: ArchiveContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
    rawSettings: fromRawSettings(input["RawSettings"]),
  }
}
function toArchiveContainerSettings(root: jsonP.JSONValue): ArchiveContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "M2tsSettings": toM2tsSettings,
      "RawSettings": toRawSettings,
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface M2tsSettings {
  AbsentInputAudioBehavior?: M2tsAbsentInputAudioBehavior | null;
  Arib?: M2tsArib | null;
  AribCaptionsPid?: string | null;
  AribCaptionsPidControl?: M2tsAribCaptionsPidControl | null;
  AudioBufferModel?: M2tsAudioBufferModel | null;
  AudioFramesPerPes?: number | null;
  AudioPids?: string | null;
  AudioStreamType?: M2tsAudioStreamType | null;
  Bitrate?: number | null;
  BufferModel?: M2tsBufferModel | null;
  CcDescriptor?: M2tsCcDescriptor | null;
  DvbNitSettings?: DvbNitSettings | null;
  DvbSdtSettings?: DvbSdtSettings | null;
  DvbSubPids?: string | null;
  DvbTdtSettings?: DvbTdtSettings | null;
  DvbTeletextPid?: string | null;
  Ebif?: M2tsEbifControl | null;
  EbpAudioInterval?: M2tsAudioInterval | null;
  EbpLookaheadMs?: number | null;
  EbpPlacement?: M2tsEbpPlacement | null;
  EcmPid?: string | null;
  EsRateInPes?: M2tsEsRateInPes | null;
  EtvPlatformPid?: string | null;
  EtvSignalPid?: string | null;
  FragmentTime?: number | null;
  Klv?: M2tsKlv | null;
  KlvDataPids?: string | null;
  NielsenId3Behavior?: M2tsNielsenId3Behavior | null;
  NullPacketBitrate?: number | null;
  PatInterval?: number | null;
  PcrControl?: M2tsPcrControl | null;
  PcrPeriod?: number | null;
  PcrPid?: string | null;
  PmtInterval?: number | null;
  PmtPid?: string | null;
  ProgramNum?: number | null;
  RateMode?: M2tsRateMode | null;
  Scte27Pids?: string | null;
  Scte35Control?: M2tsScte35Control | null;
  Scte35Pid?: string | null;
  SegmentationMarkers?: M2tsSegmentationMarkers | null;
  SegmentationStyle?: M2tsSegmentationStyle | null;
  SegmentationTime?: number | null;
  TimedMetadataBehavior?: M2tsTimedMetadataBehavior | null;
  TimedMetadataPid?: string | null;
  TransportStreamId?: number | null;
  VideoPid?: string | null;
}
function fromM2tsSettings(input?: M2tsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    absentInputAudioBehavior: input["AbsentInputAudioBehavior"],
    arib: input["Arib"],
    aribCaptionsPid: input["AribCaptionsPid"],
    aribCaptionsPidControl: input["AribCaptionsPidControl"],
    audioBufferModel: input["AudioBufferModel"],
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    audioStreamType: input["AudioStreamType"],
    bitrate: input["Bitrate"],
    bufferModel: input["BufferModel"],
    ccDescriptor: input["CcDescriptor"],
    dvbNitSettings: fromDvbNitSettings(input["DvbNitSettings"]),
    dvbSdtSettings: fromDvbSdtSettings(input["DvbSdtSettings"]),
    dvbSubPids: input["DvbSubPids"],
    dvbTdtSettings: fromDvbTdtSettings(input["DvbTdtSettings"]),
    dvbTeletextPid: input["DvbTeletextPid"],
    ebif: input["Ebif"],
    ebpAudioInterval: input["EbpAudioInterval"],
    ebpLookaheadMs: input["EbpLookaheadMs"],
    ebpPlacement: input["EbpPlacement"],
    ecmPid: input["EcmPid"],
    esRateInPes: input["EsRateInPes"],
    etvPlatformPid: input["EtvPlatformPid"],
    etvSignalPid: input["EtvSignalPid"],
    fragmentTime: input["FragmentTime"],
    klv: input["Klv"],
    klvDataPids: input["KlvDataPids"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    nullPacketBitrate: input["NullPacketBitrate"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPeriod: input["PcrPeriod"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    programNum: input["ProgramNum"],
    rateMode: input["RateMode"],
    scte27Pids: input["Scte27Pids"],
    scte35Control: input["Scte35Control"],
    scte35Pid: input["Scte35Pid"],
    segmentationMarkers: input["SegmentationMarkers"],
    segmentationStyle: input["SegmentationStyle"],
    segmentationTime: input["SegmentationTime"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM2tsSettings(root: jsonP.JSONValue): M2tsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AbsentInputAudioBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAbsentInputAudioBehavior>(x),
      "Arib": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsArib>(x),
      "AribCaptionsPid": "s",
      "AribCaptionsPidControl": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAribCaptionsPidControl>(x),
      "AudioBufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAudioBufferModel>(x),
      "AudioFramesPerPes": "n",
      "AudioPids": "s",
      "AudioStreamType": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAudioStreamType>(x),
      "Bitrate": "n",
      "BufferModel": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsBufferModel>(x),
      "CcDescriptor": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsCcDescriptor>(x),
      "DvbNitSettings": toDvbNitSettings,
      "DvbSdtSettings": toDvbSdtSettings,
      "DvbSubPids": "s",
      "DvbTdtSettings": toDvbTdtSettings,
      "DvbTeletextPid": "s",
      "Ebif": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEbifControl>(x),
      "EbpAudioInterval": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsAudioInterval>(x),
      "EbpLookaheadMs": "n",
      "EbpPlacement": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEbpPlacement>(x),
      "EcmPid": "s",
      "EsRateInPes": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsEsRateInPes>(x),
      "EtvPlatformPid": "s",
      "EtvSignalPid": "s",
      "FragmentTime": "n",
      "Klv": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsKlv>(x),
      "KlvDataPids": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsNielsenId3Behavior>(x),
      "NullPacketBitrate": "n",
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsPcrControl>(x),
      "PcrPeriod": "n",
      "PcrPid": "s",
      "PmtInterval": "n",
      "PmtPid": "s",
      "ProgramNum": "n",
      "RateMode": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsRateMode>(x),
      "Scte27Pids": "s",
      "Scte35Control": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsScte35Control>(x),
      "Scte35Pid": "s",
      "SegmentationMarkers": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsSegmentationMarkers>(x),
      "SegmentationStyle": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsSegmentationStyle>(x),
      "SegmentationTime": "n",
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<M2tsTimedMetadataBehavior>(x),
      "TimedMetadataPid": "s",
      "TransportStreamId": "n",
      "VideoPid": "s",
    },
  }, root);
}

// refs: 18 - tags: input, named, enum, output
export type M2tsAbsentInputAudioBehavior =
| "DROP"
| "ENCODE_SILENCE"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsArib =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsAribCaptionsPidControl =
| "AUTO"
| "USE_CONFIGURED"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsAudioBufferModel =
| "ATSC"
| "DVB"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsAudioStreamType =
| "ATSC"
| "DVB"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsBufferModel =
| "MULTIPLEX"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsCcDescriptor =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, interface, output
export interface DvbNitSettings {
  NetworkId: number;
  NetworkName: string;
  RepInterval?: number | null;
}
function fromDvbNitSettings(input?: DvbNitSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    networkId: input["NetworkId"],
    networkName: input["NetworkName"],
    repInterval: input["RepInterval"],
  }
}
function toDvbNitSettings(root: jsonP.JSONValue): DvbNitSettings {
  return jsonP.readObj({
    required: {
      "NetworkId": "n",
      "NetworkName": "s",
    },
    optional: {
      "RepInterval": "n",
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface DvbSdtSettings {
  OutputSdt?: DvbSdtOutputSdt | null;
  RepInterval?: number | null;
  ServiceName?: string | null;
  ServiceProviderName?: string | null;
}
function fromDvbSdtSettings(input?: DvbSdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    outputSdt: input["OutputSdt"],
    repInterval: input["RepInterval"],
    serviceName: input["ServiceName"],
    serviceProviderName: input["ServiceProviderName"],
  }
}
function toDvbSdtSettings(root: jsonP.JSONValue): DvbSdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputSdt": (x: jsonP.JSONValue) => cmnP.readEnum<DvbSdtOutputSdt>(x),
      "RepInterval": "n",
      "ServiceName": "s",
      "ServiceProviderName": "s",
    },
  }, root);
}

// refs: 18 - tags: input, named, enum, output
export type DvbSdtOutputSdt =
| "SDT_FOLLOW"
| "SDT_FOLLOW_IF_PRESENT"
| "SDT_MANUAL"
| "SDT_NONE"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, interface, output
export interface DvbTdtSettings {
  RepInterval?: number | null;
}
function fromDvbTdtSettings(input?: DvbTdtSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repInterval: input["RepInterval"],
  }
}
function toDvbTdtSettings(root: jsonP.JSONValue): DvbTdtSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "RepInterval": "n",
    },
  }, root);
}

// refs: 18 - tags: input, named, enum, output
export type M2tsEbifControl =
| "NONE"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsAudioInterval =
| "VIDEO_AND_FIXED_INTERVALS"
| "VIDEO_INTERVAL"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsEbpPlacement =
| "VIDEO_AND_AUDIO_PIDS"
| "VIDEO_PID"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsEsRateInPes =
| "EXCLUDE"
| "INCLUDE"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsKlv =
| "NONE"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsNielsenId3Behavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsPcrControl =
| "CONFIGURED_PCR_PERIOD"
| "PCR_EVERY_PES_PACKET"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsRateMode =
| "CBR"
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsScte35Control =
| "NONE"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsSegmentationMarkers =
| "EBP"
| "EBP_LEGACY"
| "NONE"
| "PSI_SEGSTART"
| "RAI_ADAPT"
| "RAI_SEGSTART"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsSegmentationStyle =
| "MAINTAIN_CADENCE"
| "RESET_CADENCE"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type M2tsTimedMetadataBehavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface RawSettings {
}
function fromRawSettings(input?: RawSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRawSettings(root: jsonP.JSONValue): RawSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface FrameCaptureOutputSettings {
  NameModifier?: string | null;
}
function fromFrameCaptureOutputSettings(input?: FrameCaptureOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    nameModifier: input["NameModifier"],
  }
}
function toFrameCaptureOutputSettings(root: jsonP.JSONValue): FrameCaptureOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NameModifier": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface HlsOutputSettings {
  H265PackagingType?: HlsH265PackagingType | null;
  HlsSettings: HlsSettings;
  NameModifier?: string | null;
  SegmentModifier?: string | null;
}
function fromHlsOutputSettings(input?: HlsOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    h265PackagingType: input["H265PackagingType"],
    hlsSettings: fromHlsSettings(input["HlsSettings"]),
    nameModifier: input["NameModifier"],
    segmentModifier: input["SegmentModifier"],
  }
}
function toHlsOutputSettings(root: jsonP.JSONValue): HlsOutputSettings {
  return jsonP.readObj({
    required: {
      "HlsSettings": toHlsSettings,
    },
    optional: {
      "H265PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<HlsH265PackagingType>(x),
      "NameModifier": "s",
      "SegmentModifier": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type HlsH265PackagingType =
| "HEV1"
| "HVC1"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface HlsSettings {
  AudioOnlyHlsSettings?: AudioOnlyHlsSettings | null;
  Fmp4HlsSettings?: Fmp4HlsSettings | null;
  FrameCaptureHlsSettings?: FrameCaptureHlsSettings | null;
  StandardHlsSettings?: StandardHlsSettings | null;
}
function fromHlsSettings(input?: HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioOnlyHlsSettings: fromAudioOnlyHlsSettings(input["AudioOnlyHlsSettings"]),
    fmp4HlsSettings: fromFmp4HlsSettings(input["Fmp4HlsSettings"]),
    frameCaptureHlsSettings: fromFrameCaptureHlsSettings(input["FrameCaptureHlsSettings"]),
    standardHlsSettings: fromStandardHlsSettings(input["StandardHlsSettings"]),
  }
}
function toHlsSettings(root: jsonP.JSONValue): HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioOnlyHlsSettings": toAudioOnlyHlsSettings,
      "Fmp4HlsSettings": toFmp4HlsSettings,
      "FrameCaptureHlsSettings": toFrameCaptureHlsSettings,
      "StandardHlsSettings": toStandardHlsSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface AudioOnlyHlsSettings {
  AudioGroupId?: string | null;
  AudioOnlyImage?: InputLocation | null;
  AudioTrackType?: AudioOnlyHlsTrackType | null;
  SegmentType?: AudioOnlyHlsSegmentType | null;
}
function fromAudioOnlyHlsSettings(input?: AudioOnlyHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioGroupId: input["AudioGroupId"],
    audioOnlyImage: fromInputLocation(input["AudioOnlyImage"]),
    audioTrackType: input["AudioTrackType"],
    segmentType: input["SegmentType"],
  }
}
function toAudioOnlyHlsSettings(root: jsonP.JSONValue): AudioOnlyHlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioGroupId": "s",
      "AudioOnlyImage": toInputLocation,
      "AudioTrackType": (x: jsonP.JSONValue) => cmnP.readEnum<AudioOnlyHlsTrackType>(x),
      "SegmentType": (x: jsonP.JSONValue) => cmnP.readEnum<AudioOnlyHlsSegmentType>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type AudioOnlyHlsTrackType =
| "ALTERNATE_AUDIO_AUTO_SELECT"
| "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT"
| "ALTERNATE_AUDIO_NOT_AUTO_SELECT"
| "AUDIO_ONLY_VARIANT_STREAM"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type AudioOnlyHlsSegmentType =
| "AAC"
| "FMP4"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Fmp4HlsSettings {
  AudioRenditionSets?: string | null;
  NielsenId3Behavior?: Fmp4NielsenId3Behavior | null;
  TimedMetadataBehavior?: Fmp4TimedMetadataBehavior | null;
}
function fromFmp4HlsSettings(input?: Fmp4HlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioRenditionSets: input["AudioRenditionSets"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
  }
}
function toFmp4HlsSettings(root: jsonP.JSONValue): Fmp4HlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioRenditionSets": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<Fmp4NielsenId3Behavior>(x),
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<Fmp4TimedMetadataBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Fmp4NielsenId3Behavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Fmp4TimedMetadataBehavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface FrameCaptureHlsSettings {
}
function fromFrameCaptureHlsSettings(input?: FrameCaptureHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toFrameCaptureHlsSettings(root: jsonP.JSONValue): FrameCaptureHlsSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface StandardHlsSettings {
  AudioRenditionSets?: string | null;
  M3u8Settings: M3u8Settings;
}
function fromStandardHlsSettings(input?: StandardHlsSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioRenditionSets: input["AudioRenditionSets"],
    m3u8Settings: fromM3u8Settings(input["M3u8Settings"]),
  }
}
function toStandardHlsSettings(root: jsonP.JSONValue): StandardHlsSettings {
  return jsonP.readObj({
    required: {
      "M3u8Settings": toM3u8Settings,
    },
    optional: {
      "AudioRenditionSets": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface M3u8Settings {
  AudioFramesPerPes?: number | null;
  AudioPids?: string | null;
  EcmPid?: string | null;
  NielsenId3Behavior?: M3u8NielsenId3Behavior | null;
  PatInterval?: number | null;
  PcrControl?: M3u8PcrControl | null;
  PcrPeriod?: number | null;
  PcrPid?: string | null;
  PmtInterval?: number | null;
  PmtPid?: string | null;
  ProgramNum?: number | null;
  Scte35Behavior?: M3u8Scte35Behavior | null;
  Scte35Pid?: string | null;
  TimedMetadataBehavior?: M3u8TimedMetadataBehavior | null;
  TimedMetadataPid?: string | null;
  TransportStreamId?: number | null;
  VideoPid?: string | null;
}
function fromM3u8Settings(input?: M3u8Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioFramesPerPes: input["AudioFramesPerPes"],
    audioPids: input["AudioPids"],
    ecmPid: input["EcmPid"],
    nielsenId3Behavior: input["NielsenId3Behavior"],
    patInterval: input["PatInterval"],
    pcrControl: input["PcrControl"],
    pcrPeriod: input["PcrPeriod"],
    pcrPid: input["PcrPid"],
    pmtInterval: input["PmtInterval"],
    pmtPid: input["PmtPid"],
    programNum: input["ProgramNum"],
    scte35Behavior: input["Scte35Behavior"],
    scte35Pid: input["Scte35Pid"],
    timedMetadataBehavior: input["TimedMetadataBehavior"],
    timedMetadataPid: input["TimedMetadataPid"],
    transportStreamId: input["TransportStreamId"],
    videoPid: input["VideoPid"],
  }
}
function toM3u8Settings(root: jsonP.JSONValue): M3u8Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioFramesPerPes": "n",
      "AudioPids": "s",
      "EcmPid": "s",
      "NielsenId3Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8NielsenId3Behavior>(x),
      "PatInterval": "n",
      "PcrControl": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8PcrControl>(x),
      "PcrPeriod": "n",
      "PcrPid": "s",
      "PmtInterval": "n",
      "PmtPid": "s",
      "ProgramNum": "n",
      "Scte35Behavior": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8Scte35Behavior>(x),
      "Scte35Pid": "s",
      "TimedMetadataBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<M3u8TimedMetadataBehavior>(x),
      "TimedMetadataPid": "s",
      "TransportStreamId": "n",
      "VideoPid": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type M3u8NielsenId3Behavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type M3u8PcrControl =
| "CONFIGURED_PCR_PERIOD"
| "PCR_EVERY_PES_PACKET"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type M3u8Scte35Behavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type M3u8TimedMetadataBehavior =
| "NO_PASSTHROUGH"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface MediaPackageOutputSettings {
}
function fromMediaPackageOutputSettings(input?: MediaPackageOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toMediaPackageOutputSettings(root: jsonP.JSONValue): MediaPackageOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface MsSmoothOutputSettings {
  H265PackagingType?: MsSmoothH265PackagingType | null;
  NameModifier?: string | null;
}
function fromMsSmoothOutputSettings(input?: MsSmoothOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    h265PackagingType: input["H265PackagingType"],
    nameModifier: input["NameModifier"],
  }
}
function toMsSmoothOutputSettings(root: jsonP.JSONValue): MsSmoothOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "H265PackagingType": (x: jsonP.JSONValue) => cmnP.readEnum<MsSmoothH265PackagingType>(x),
      "NameModifier": "s",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type MsSmoothH265PackagingType =
| "HEV1"
| "HVC1"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface MultiplexOutputSettings {
  Destination: OutputLocationRef;
}
function fromMultiplexOutputSettings(input?: MultiplexOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destination: fromOutputLocationRef(input["Destination"]),
  }
}
function toMultiplexOutputSettings(root: jsonP.JSONValue): MultiplexOutputSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface RtmpOutputSettings {
  CertificateMode?: RtmpOutputCertificateMode | null;
  ConnectionRetryInterval?: number | null;
  Destination: OutputLocationRef;
  NumRetries?: number | null;
}
function fromRtmpOutputSettings(input?: RtmpOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    certificateMode: input["CertificateMode"],
    connectionRetryInterval: input["ConnectionRetryInterval"],
    destination: fromOutputLocationRef(input["Destination"]),
    numRetries: input["NumRetries"],
  }
}
function toRtmpOutputSettings(root: jsonP.JSONValue): RtmpOutputSettings {
  return jsonP.readObj({
    required: {
      "Destination": toOutputLocationRef,
    },
    optional: {
      "CertificateMode": (x: jsonP.JSONValue) => cmnP.readEnum<RtmpOutputCertificateMode>(x),
      "ConnectionRetryInterval": "n",
      "NumRetries": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type RtmpOutputCertificateMode =
| "SELF_SIGNED"
| "VERIFY_AUTHENTICITY"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface UdpOutputSettings {
  BufferMsec?: number | null;
  ContainerSettings: UdpContainerSettings;
  Destination: OutputLocationRef;
  FecOutputSettings?: FecOutputSettings | null;
}
function fromUdpOutputSettings(input?: UdpOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bufferMsec: input["BufferMsec"],
    containerSettings: fromUdpContainerSettings(input["ContainerSettings"]),
    destination: fromOutputLocationRef(input["Destination"]),
    fecOutputSettings: fromFecOutputSettings(input["FecOutputSettings"]),
  }
}
function toUdpOutputSettings(root: jsonP.JSONValue): UdpOutputSettings {
  return jsonP.readObj({
    required: {
      "ContainerSettings": toUdpContainerSettings,
      "Destination": toOutputLocationRef,
    },
    optional: {
      "BufferMsec": "n",
      "FecOutputSettings": toFecOutputSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface UdpContainerSettings {
  M2tsSettings?: M2tsSettings | null;
}
function fromUdpContainerSettings(input?: UdpContainerSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    m2tsSettings: fromM2tsSettings(input["M2tsSettings"]),
  }
}
function toUdpContainerSettings(root: jsonP.JSONValue): UdpContainerSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "M2tsSettings": toM2tsSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface FecOutputSettings {
  ColumnDepth?: number | null;
  IncludeFec?: FecOutputIncludeFec | null;
  RowLength?: number | null;
}
function fromFecOutputSettings(input?: FecOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    columnDepth: input["ColumnDepth"],
    includeFec: input["IncludeFec"],
    rowLength: input["RowLength"],
  }
}
function toFecOutputSettings(root: jsonP.JSONValue): FecOutputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnDepth": "n",
      "IncludeFec": (x: jsonP.JSONValue) => cmnP.readEnum<FecOutputIncludeFec>(x),
      "RowLength": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type FecOutputIncludeFec =
| "COLUMN"
| "COLUMN_AND_ROW"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface TimecodeConfig {
  Source: TimecodeConfigSource;
  SyncThreshold?: number | null;
}
function fromTimecodeConfig(input?: TimecodeConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    source: input["Source"],
    syncThreshold: input["SyncThreshold"],
  }
}
function toTimecodeConfig(root: jsonP.JSONValue): TimecodeConfig {
  return jsonP.readObj({
    required: {
      "Source": (x: jsonP.JSONValue) => cmnP.readEnum<TimecodeConfigSource>(x),
    },
    optional: {
      "SyncThreshold": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type TimecodeConfigSource =
| "EMBEDDED"
| "SYSTEMCLOCK"
| "ZEROBASED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface VideoDescription {
  CodecSettings?: VideoCodecSettings | null;
  Height?: number | null;
  Name: string;
  RespondToAfd?: VideoDescriptionRespondToAfd | null;
  ScalingBehavior?: VideoDescriptionScalingBehavior | null;
  Sharpness?: number | null;
  Width?: number | null;
}
function fromVideoDescription(input?: VideoDescription | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codecSettings: fromVideoCodecSettings(input["CodecSettings"]),
    height: input["Height"],
    name: input["Name"],
    respondToAfd: input["RespondToAfd"],
    scalingBehavior: input["ScalingBehavior"],
    sharpness: input["Sharpness"],
    width: input["Width"],
  }
}
function toVideoDescription(root: jsonP.JSONValue): VideoDescription {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CodecSettings": toVideoCodecSettings,
      "Height": "n",
      "RespondToAfd": (x: jsonP.JSONValue) => cmnP.readEnum<VideoDescriptionRespondToAfd>(x),
      "ScalingBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<VideoDescriptionScalingBehavior>(x),
      "Sharpness": "n",
      "Width": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface VideoCodecSettings {
  FrameCaptureSettings?: FrameCaptureSettings | null;
  H264Settings?: H264Settings | null;
  H265Settings?: H265Settings | null;
  Mpeg2Settings?: Mpeg2Settings | null;
}
function fromVideoCodecSettings(input?: VideoCodecSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    frameCaptureSettings: fromFrameCaptureSettings(input["FrameCaptureSettings"]),
    h264Settings: fromH264Settings(input["H264Settings"]),
    h265Settings: fromH265Settings(input["H265Settings"]),
    mpeg2Settings: fromMpeg2Settings(input["Mpeg2Settings"]),
  }
}
function toVideoCodecSettings(root: jsonP.JSONValue): VideoCodecSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "FrameCaptureSettings": toFrameCaptureSettings,
      "H264Settings": toH264Settings,
      "H265Settings": toH265Settings,
      "Mpeg2Settings": toMpeg2Settings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface FrameCaptureSettings {
  CaptureInterval?: number | null;
  CaptureIntervalUnits?: FrameCaptureIntervalUnit | null;
}
function fromFrameCaptureSettings(input?: FrameCaptureSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    captureInterval: input["CaptureInterval"],
    captureIntervalUnits: input["CaptureIntervalUnits"],
  }
}
function toFrameCaptureSettings(root: jsonP.JSONValue): FrameCaptureSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "CaptureInterval": "n",
      "CaptureIntervalUnits": (x: jsonP.JSONValue) => cmnP.readEnum<FrameCaptureIntervalUnit>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type FrameCaptureIntervalUnit =
| "MILLISECONDS"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface H264Settings {
  AdaptiveQuantization?: H264AdaptiveQuantization | null;
  AfdSignaling?: AfdSignaling | null;
  Bitrate?: number | null;
  BufFillPct?: number | null;
  BufSize?: number | null;
  ColorMetadata?: H264ColorMetadata | null;
  ColorSpaceSettings?: H264ColorSpaceSettings | null;
  EntropyEncoding?: H264EntropyEncoding | null;
  FilterSettings?: H264FilterSettings | null;
  FixedAfd?: FixedAfd | null;
  FlickerAq?: H264FlickerAq | null;
  ForceFieldPictures?: H264ForceFieldPictures | null;
  FramerateControl?: H264FramerateControl | null;
  FramerateDenominator?: number | null;
  FramerateNumerator?: number | null;
  GopBReference?: H264GopBReference | null;
  GopClosedCadence?: number | null;
  GopNumBFrames?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: H264GopSizeUnits | null;
  Level?: H264Level | null;
  LookAheadRateControl?: H264LookAheadRateControl | null;
  MaxBitrate?: number | null;
  MinIInterval?: number | null;
  NumRefFrames?: number | null;
  ParControl?: H264ParControl | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  Profile?: H264Profile | null;
  QualityLevel?: H264QualityLevel | null;
  QvbrQualityLevel?: number | null;
  RateControlMode?: H264RateControlMode | null;
  ScanType?: H264ScanType | null;
  SceneChangeDetect?: H264SceneChangeDetect | null;
  Slices?: number | null;
  Softness?: number | null;
  SpatialAq?: H264SpatialAq | null;
  SubgopLength?: H264SubGopLength | null;
  Syntax?: H264Syntax | null;
  TemporalAq?: H264TemporalAq | null;
  TimecodeInsertion?: H264TimecodeInsertionBehavior | null;
}
function fromH264Settings(input?: H264Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    bitrate: input["Bitrate"],
    bufFillPct: input["BufFillPct"],
    bufSize: input["BufSize"],
    colorMetadata: input["ColorMetadata"],
    colorSpaceSettings: fromH264ColorSpaceSettings(input["ColorSpaceSettings"]),
    entropyEncoding: input["EntropyEncoding"],
    filterSettings: fromH264FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    flickerAq: input["FlickerAq"],
    forceFieldPictures: input["ForceFieldPictures"],
    framerateControl: input["FramerateControl"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopBReference: input["GopBReference"],
    gopClosedCadence: input["GopClosedCadence"],
    gopNumBFrames: input["GopNumBFrames"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    level: input["Level"],
    lookAheadRateControl: input["LookAheadRateControl"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    numRefFrames: input["NumRefFrames"],
    parControl: input["ParControl"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    profile: input["Profile"],
    qualityLevel: input["QualityLevel"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    rateControlMode: input["RateControlMode"],
    scanType: input["ScanType"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    softness: input["Softness"],
    spatialAq: input["SpatialAq"],
    subgopLength: input["SubgopLength"],
    syntax: input["Syntax"],
    temporalAq: input["TemporalAq"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toH264Settings(root: jsonP.JSONValue): H264Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H264AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<AfdSignaling>(x),
      "Bitrate": "n",
      "BufFillPct": "n",
      "BufSize": "n",
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<H264ColorMetadata>(x),
      "ColorSpaceSettings": toH264ColorSpaceSettings,
      "EntropyEncoding": (x: jsonP.JSONValue) => cmnP.readEnum<H264EntropyEncoding>(x),
      "FilterSettings": toH264FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<FixedAfd>(x),
      "FlickerAq": (x: jsonP.JSONValue) => cmnP.readEnum<H264FlickerAq>(x),
      "ForceFieldPictures": (x: jsonP.JSONValue) => cmnP.readEnum<H264ForceFieldPictures>(x),
      "FramerateControl": (x: jsonP.JSONValue) => cmnP.readEnum<H264FramerateControl>(x),
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
      "GopBReference": (x: jsonP.JSONValue) => cmnP.readEnum<H264GopBReference>(x),
      "GopClosedCadence": "n",
      "GopNumBFrames": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<H264GopSizeUnits>(x),
      "Level": (x: jsonP.JSONValue) => cmnP.readEnum<H264Level>(x),
      "LookAheadRateControl": (x: jsonP.JSONValue) => cmnP.readEnum<H264LookAheadRateControl>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "NumRefFrames": "n",
      "ParControl": (x: jsonP.JSONValue) => cmnP.readEnum<H264ParControl>(x),
      "ParDenominator": "n",
      "ParNumerator": "n",
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<H264Profile>(x),
      "QualityLevel": (x: jsonP.JSONValue) => cmnP.readEnum<H264QualityLevel>(x),
      "QvbrQualityLevel": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<H264RateControlMode>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<H264ScanType>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<H264SceneChangeDetect>(x),
      "Slices": "n",
      "Softness": "n",
      "SpatialAq": (x: jsonP.JSONValue) => cmnP.readEnum<H264SpatialAq>(x),
      "SubgopLength": (x: jsonP.JSONValue) => cmnP.readEnum<H264SubGopLength>(x),
      "Syntax": (x: jsonP.JSONValue) => cmnP.readEnum<H264Syntax>(x),
      "TemporalAq": (x: jsonP.JSONValue) => cmnP.readEnum<H264TemporalAq>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<H264TimecodeInsertionBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type H264AdaptiveQuantization =
| "HIGH"
| "HIGHER"
| "LOW"
| "MAX"
| "MEDIUM"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 27 - tags: input, named, enum, output
export type AfdSignaling =
| "AUTO"
| "FIXED"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264ColorMetadata =
| "IGNORE"
| "INSERT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface H264ColorSpaceSettings {
  ColorSpacePassthroughSettings?: ColorSpacePassthroughSettings | null;
  Rec601Settings?: Rec601Settings | null;
  Rec709Settings?: Rec709Settings | null;
}
function fromH264ColorSpaceSettings(input?: H264ColorSpaceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpacePassthroughSettings: fromColorSpacePassthroughSettings(input["ColorSpacePassthroughSettings"]),
    rec601Settings: fromRec601Settings(input["Rec601Settings"]),
    rec709Settings: fromRec709Settings(input["Rec709Settings"]),
  }
}
function toH264ColorSpaceSettings(root: jsonP.JSONValue): H264ColorSpaceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpacePassthroughSettings": toColorSpacePassthroughSettings,
      "Rec601Settings": toRec601Settings,
      "Rec709Settings": toRec709Settings,
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface ColorSpacePassthroughSettings {
}
function fromColorSpacePassthroughSettings(input?: ColorSpacePassthroughSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toColorSpacePassthroughSettings(root: jsonP.JSONValue): ColorSpacePassthroughSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface Rec601Settings {
}
function fromRec601Settings(input?: Rec601Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRec601Settings(root: jsonP.JSONValue): Rec601Settings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface Rec709Settings {
}
function fromRec709Settings(input?: Rec709Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toRec709Settings(root: jsonP.JSONValue): Rec709Settings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type H264EntropyEncoding =
| "CABAC"
| "CAVLC"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface H264FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings | null;
}
function fromH264FilterSettings(input?: H264FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toH264FilterSettings(root: jsonP.JSONValue): H264FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

// refs: 27 - tags: input, named, interface, output
export interface TemporalFilterSettings {
  PostFilterSharpening?: TemporalFilterPostFilterSharpening | null;
  Strength?: TemporalFilterStrength | null;
}
function fromTemporalFilterSettings(input?: TemporalFilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    postFilterSharpening: input["PostFilterSharpening"],
    strength: input["Strength"],
  }
}
function toTemporalFilterSettings(root: jsonP.JSONValue): TemporalFilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PostFilterSharpening": (x: jsonP.JSONValue) => cmnP.readEnum<TemporalFilterPostFilterSharpening>(x),
      "Strength": (x: jsonP.JSONValue) => cmnP.readEnum<TemporalFilterStrength>(x),
    },
  }, root);
}

// refs: 27 - tags: input, named, enum, output
export type TemporalFilterPostFilterSharpening =
| "AUTO"
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 27 - tags: input, named, enum, output
export type TemporalFilterStrength =
| "AUTO"
| "STRENGTH_1"
| "STRENGTH_2"
| "STRENGTH_3"
| "STRENGTH_4"
| "STRENGTH_5"
| "STRENGTH_6"
| "STRENGTH_7"
| "STRENGTH_8"
| "STRENGTH_9"
| "STRENGTH_10"
| "STRENGTH_11"
| "STRENGTH_12"
| "STRENGTH_13"
| "STRENGTH_14"
| "STRENGTH_15"
| "STRENGTH_16"
| cmnP.UnexpectedEnumValue;

// refs: 27 - tags: input, named, enum, output
export type FixedAfd =
| "AFD_0000"
| "AFD_0010"
| "AFD_0011"
| "AFD_0100"
| "AFD_1000"
| "AFD_1001"
| "AFD_1010"
| "AFD_1011"
| "AFD_1101"
| "AFD_1110"
| "AFD_1111"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264FlickerAq =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264ForceFieldPictures =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264FramerateControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264GopBReference =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264Level =
| "H264_LEVEL_1"
| "H264_LEVEL_1_1"
| "H264_LEVEL_1_2"
| "H264_LEVEL_1_3"
| "H264_LEVEL_2"
| "H264_LEVEL_2_1"
| "H264_LEVEL_2_2"
| "H264_LEVEL_3"
| "H264_LEVEL_3_1"
| "H264_LEVEL_3_2"
| "H264_LEVEL_4"
| "H264_LEVEL_4_1"
| "H264_LEVEL_4_2"
| "H264_LEVEL_5"
| "H264_LEVEL_5_1"
| "H264_LEVEL_5_2"
| "H264_LEVEL_AUTO"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264LookAheadRateControl =
| "HIGH"
| "LOW"
| "MEDIUM"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264ParControl =
| "INITIALIZE_FROM_SOURCE"
| "SPECIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264Profile =
| "BASELINE"
| "HIGH"
| "HIGH_10BIT"
| "HIGH_422"
| "HIGH_422_10BIT"
| "MAIN"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264QualityLevel =
| "ENHANCED_QUALITY"
| "STANDARD_QUALITY"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264RateControlMode =
| "CBR"
| "MULTIPLEX"
| "QVBR"
| "VBR"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264ScanType =
| "INTERLACED"
| "PROGRESSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264SceneChangeDetect =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264SpatialAq =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264SubGopLength =
| "DYNAMIC"
| "FIXED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264Syntax =
| "DEFAULT"
| "RP2027"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264TemporalAq =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H264TimecodeInsertionBehavior =
| "DISABLED"
| "PIC_TIMING_SEI"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface H265Settings {
  AdaptiveQuantization?: H265AdaptiveQuantization | null;
  AfdSignaling?: AfdSignaling | null;
  AlternativeTransferFunction?: H265AlternativeTransferFunction | null;
  Bitrate?: number | null;
  BufSize?: number | null;
  ColorMetadata?: H265ColorMetadata | null;
  ColorSpaceSettings?: H265ColorSpaceSettings | null;
  FilterSettings?: H265FilterSettings | null;
  FixedAfd?: FixedAfd | null;
  FlickerAq?: H265FlickerAq | null;
  FramerateDenominator: number;
  FramerateNumerator: number;
  GopClosedCadence?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: H265GopSizeUnits | null;
  Level?: H265Level | null;
  LookAheadRateControl?: H265LookAheadRateControl | null;
  MaxBitrate?: number | null;
  MinIInterval?: number | null;
  ParDenominator?: number | null;
  ParNumerator?: number | null;
  Profile?: H265Profile | null;
  QvbrQualityLevel?: number | null;
  RateControlMode?: H265RateControlMode | null;
  ScanType?: H265ScanType | null;
  SceneChangeDetect?: H265SceneChangeDetect | null;
  Slices?: number | null;
  Tier?: H265Tier | null;
  TimecodeInsertion?: H265TimecodeInsertionBehavior | null;
}
function fromH265Settings(input?: H265Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    alternativeTransferFunction: input["AlternativeTransferFunction"],
    bitrate: input["Bitrate"],
    bufSize: input["BufSize"],
    colorMetadata: input["ColorMetadata"],
    colorSpaceSettings: fromH265ColorSpaceSettings(input["ColorSpaceSettings"]),
    filterSettings: fromH265FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    flickerAq: input["FlickerAq"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    level: input["Level"],
    lookAheadRateControl: input["LookAheadRateControl"],
    maxBitrate: input["MaxBitrate"],
    minIInterval: input["MinIInterval"],
    parDenominator: input["ParDenominator"],
    parNumerator: input["ParNumerator"],
    profile: input["Profile"],
    qvbrQualityLevel: input["QvbrQualityLevel"],
    rateControlMode: input["RateControlMode"],
    scanType: input["ScanType"],
    sceneChangeDetect: input["SceneChangeDetect"],
    slices: input["Slices"],
    tier: input["Tier"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toH265Settings(root: jsonP.JSONValue): H265Settings {
  return jsonP.readObj({
    required: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<H265AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<AfdSignaling>(x),
      "AlternativeTransferFunction": (x: jsonP.JSONValue) => cmnP.readEnum<H265AlternativeTransferFunction>(x),
      "Bitrate": "n",
      "BufSize": "n",
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<H265ColorMetadata>(x),
      "ColorSpaceSettings": toH265ColorSpaceSettings,
      "FilterSettings": toH265FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<FixedAfd>(x),
      "FlickerAq": (x: jsonP.JSONValue) => cmnP.readEnum<H265FlickerAq>(x),
      "GopClosedCadence": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<H265GopSizeUnits>(x),
      "Level": (x: jsonP.JSONValue) => cmnP.readEnum<H265Level>(x),
      "LookAheadRateControl": (x: jsonP.JSONValue) => cmnP.readEnum<H265LookAheadRateControl>(x),
      "MaxBitrate": "n",
      "MinIInterval": "n",
      "ParDenominator": "n",
      "ParNumerator": "n",
      "Profile": (x: jsonP.JSONValue) => cmnP.readEnum<H265Profile>(x),
      "QvbrQualityLevel": "n",
      "RateControlMode": (x: jsonP.JSONValue) => cmnP.readEnum<H265RateControlMode>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<H265ScanType>(x),
      "SceneChangeDetect": (x: jsonP.JSONValue) => cmnP.readEnum<H265SceneChangeDetect>(x),
      "Slices": "n",
      "Tier": (x: jsonP.JSONValue) => cmnP.readEnum<H265Tier>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<H265TimecodeInsertionBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type H265AdaptiveQuantization =
| "HIGH"
| "HIGHER"
| "LOW"
| "MAX"
| "MEDIUM"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265AlternativeTransferFunction =
| "INSERT"
| "OMIT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265ColorMetadata =
| "IGNORE"
| "INSERT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface H265ColorSpaceSettings {
  ColorSpacePassthroughSettings?: ColorSpacePassthroughSettings | null;
  Hdr10Settings?: Hdr10Settings | null;
  Rec601Settings?: Rec601Settings | null;
  Rec709Settings?: Rec709Settings | null;
}
function fromH265ColorSpaceSettings(input?: H265ColorSpaceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpacePassthroughSettings: fromColorSpacePassthroughSettings(input["ColorSpacePassthroughSettings"]),
    hdr10Settings: fromHdr10Settings(input["Hdr10Settings"]),
    rec601Settings: fromRec601Settings(input["Rec601Settings"]),
    rec709Settings: fromRec709Settings(input["Rec709Settings"]),
  }
}
function toH265ColorSpaceSettings(root: jsonP.JSONValue): H265ColorSpaceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpacePassthroughSettings": toColorSpacePassthroughSettings,
      "Hdr10Settings": toHdr10Settings,
      "Rec601Settings": toRec601Settings,
      "Rec709Settings": toRec709Settings,
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface Hdr10Settings {
  MaxCll?: number | null;
  MaxFall?: number | null;
}
function fromHdr10Settings(input?: Hdr10Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maxCll: input["MaxCll"],
    maxFall: input["MaxFall"],
  }
}
function toHdr10Settings(root: jsonP.JSONValue): Hdr10Settings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCll": "n",
      "MaxFall": "n",
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface H265FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings | null;
}
function fromH265FilterSettings(input?: H265FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toH265FilterSettings(root: jsonP.JSONValue): H265FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type H265FlickerAq =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265Level =
| "H265_LEVEL_1"
| "H265_LEVEL_2"
| "H265_LEVEL_2_1"
| "H265_LEVEL_3"
| "H265_LEVEL_3_1"
| "H265_LEVEL_4"
| "H265_LEVEL_4_1"
| "H265_LEVEL_5"
| "H265_LEVEL_5_1"
| "H265_LEVEL_5_2"
| "H265_LEVEL_6"
| "H265_LEVEL_6_1"
| "H265_LEVEL_6_2"
| "H265_LEVEL_AUTO"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265LookAheadRateControl =
| "HIGH"
| "LOW"
| "MEDIUM"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265Profile =
| "MAIN"
| "MAIN_10BIT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265RateControlMode =
| "CBR"
| "MULTIPLEX"
| "QVBR"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265ScanType =
| "INTERLACED"
| "PROGRESSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265SceneChangeDetect =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265Tier =
| "HIGH"
| "MAIN"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type H265TimecodeInsertionBehavior =
| "DISABLED"
| "PIC_TIMING_SEI"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Mpeg2Settings {
  AdaptiveQuantization?: Mpeg2AdaptiveQuantization | null;
  AfdSignaling?: AfdSignaling | null;
  ColorMetadata?: Mpeg2ColorMetadata | null;
  ColorSpace?: Mpeg2ColorSpace | null;
  DisplayAspectRatio?: Mpeg2DisplayRatio | null;
  FilterSettings?: Mpeg2FilterSettings | null;
  FixedAfd?: FixedAfd | null;
  FramerateDenominator: number;
  FramerateNumerator: number;
  GopClosedCadence?: number | null;
  GopNumBFrames?: number | null;
  GopSize?: number | null;
  GopSizeUnits?: Mpeg2GopSizeUnits | null;
  ScanType?: Mpeg2ScanType | null;
  SubgopLength?: Mpeg2SubGopLength | null;
  TimecodeInsertion?: Mpeg2TimecodeInsertionBehavior | null;
}
function fromMpeg2Settings(input?: Mpeg2Settings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    adaptiveQuantization: input["AdaptiveQuantization"],
    afdSignaling: input["AfdSignaling"],
    colorMetadata: input["ColorMetadata"],
    colorSpace: input["ColorSpace"],
    displayAspectRatio: input["DisplayAspectRatio"],
    filterSettings: fromMpeg2FilterSettings(input["FilterSettings"]),
    fixedAfd: input["FixedAfd"],
    framerateDenominator: input["FramerateDenominator"],
    framerateNumerator: input["FramerateNumerator"],
    gopClosedCadence: input["GopClosedCadence"],
    gopNumBFrames: input["GopNumBFrames"],
    gopSize: input["GopSize"],
    gopSizeUnits: input["GopSizeUnits"],
    scanType: input["ScanType"],
    subgopLength: input["SubgopLength"],
    timecodeInsertion: input["TimecodeInsertion"],
  }
}
function toMpeg2Settings(root: jsonP.JSONValue): Mpeg2Settings {
  return jsonP.readObj({
    required: {
      "FramerateDenominator": "n",
      "FramerateNumerator": "n",
    },
    optional: {
      "AdaptiveQuantization": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2AdaptiveQuantization>(x),
      "AfdSignaling": (x: jsonP.JSONValue) => cmnP.readEnum<AfdSignaling>(x),
      "ColorMetadata": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2ColorMetadata>(x),
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2ColorSpace>(x),
      "DisplayAspectRatio": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2DisplayRatio>(x),
      "FilterSettings": toMpeg2FilterSettings,
      "FixedAfd": (x: jsonP.JSONValue) => cmnP.readEnum<FixedAfd>(x),
      "GopClosedCadence": "n",
      "GopNumBFrames": "n",
      "GopSize": "n",
      "GopSizeUnits": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2GopSizeUnits>(x),
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2ScanType>(x),
      "SubgopLength": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2SubGopLength>(x),
      "TimecodeInsertion": (x: jsonP.JSONValue) => cmnP.readEnum<Mpeg2TimecodeInsertionBehavior>(x),
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Mpeg2AdaptiveQuantization =
| "AUTO"
| "HIGH"
| "LOW"
| "MEDIUM"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2ColorMetadata =
| "IGNORE"
| "INSERT"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2ColorSpace =
| "AUTO"
| "PASSTHROUGH"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2DisplayRatio =
| "DISPLAYRATIO16X9"
| "DISPLAYRATIO4X3"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface Mpeg2FilterSettings {
  TemporalFilterSettings?: TemporalFilterSettings | null;
}
function fromMpeg2FilterSettings(input?: Mpeg2FilterSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    temporalFilterSettings: fromTemporalFilterSettings(input["TemporalFilterSettings"]),
  }
}
function toMpeg2FilterSettings(root: jsonP.JSONValue): Mpeg2FilterSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "TemporalFilterSettings": toTemporalFilterSettings,
    },
  }, root);
}

// refs: 9 - tags: input, named, enum, output
export type Mpeg2GopSizeUnits =
| "FRAMES"
| "SECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2ScanType =
| "INTERLACED"
| "PROGRESSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2SubGopLength =
| "DYNAMIC"
| "FIXED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type Mpeg2TimecodeInsertionBehavior =
| "DISABLED"
| "GOP_TIMECODE"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type VideoDescriptionRespondToAfd =
| "NONE"
| "PASSTHROUGH"
| "RESPOND"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type VideoDescriptionScalingBehavior =
| "DEFAULT"
| "STRETCH_TO_OUTPUT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface InputAttachment {
  AutomaticInputFailoverSettings?: AutomaticInputFailoverSettings | null;
  InputAttachmentName?: string | null;
  InputId?: string | null;
  InputSettings?: InputSettings | null;
}
function fromInputAttachment(input?: InputAttachment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    automaticInputFailoverSettings: fromAutomaticInputFailoverSettings(input["AutomaticInputFailoverSettings"]),
    inputAttachmentName: input["InputAttachmentName"],
    inputId: input["InputId"],
    inputSettings: fromInputSettings(input["InputSettings"]),
  }
}
function toInputAttachment(root: jsonP.JSONValue): InputAttachment {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutomaticInputFailoverSettings": toAutomaticInputFailoverSettings,
      "InputAttachmentName": "s",
      "InputId": "s",
      "InputSettings": toInputSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AutomaticInputFailoverSettings {
  ErrorClearTimeMsec?: number | null;
  FailoverConditions?: FailoverCondition[] | null;
  InputPreference?: InputPreference | null;
  SecondaryInputId: string;
}
function fromAutomaticInputFailoverSettings(input?: AutomaticInputFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    errorClearTimeMsec: input["ErrorClearTimeMsec"],
    failoverConditions: input["FailoverConditions"]?.map(x => fromFailoverCondition(x)),
    inputPreference: input["InputPreference"],
    secondaryInputId: input["SecondaryInputId"],
  }
}
function toAutomaticInputFailoverSettings(root: jsonP.JSONValue): AutomaticInputFailoverSettings {
  return jsonP.readObj({
    required: {
      "SecondaryInputId": "s",
    },
    optional: {
      "ErrorClearTimeMsec": "n",
      "FailoverConditions": [toFailoverCondition],
      "InputPreference": (x: jsonP.JSONValue) => cmnP.readEnum<InputPreference>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface FailoverCondition {
  FailoverConditionSettings?: FailoverConditionSettings | null;
}
function fromFailoverCondition(input?: FailoverCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    failoverConditionSettings: fromFailoverConditionSettings(input["FailoverConditionSettings"]),
  }
}
function toFailoverCondition(root: jsonP.JSONValue): FailoverCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "FailoverConditionSettings": toFailoverConditionSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface FailoverConditionSettings {
  AudioSilenceSettings?: AudioSilenceFailoverSettings | null;
  InputLossSettings?: InputLossFailoverSettings | null;
  VideoBlackSettings?: VideoBlackFailoverSettings | null;
}
function fromFailoverConditionSettings(input?: FailoverConditionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSilenceSettings: fromAudioSilenceFailoverSettings(input["AudioSilenceSettings"]),
    inputLossSettings: fromInputLossFailoverSettings(input["InputLossSettings"]),
    videoBlackSettings: fromVideoBlackFailoverSettings(input["VideoBlackSettings"]),
  }
}
function toFailoverConditionSettings(root: jsonP.JSONValue): FailoverConditionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSilenceSettings": toAudioSilenceFailoverSettings,
      "InputLossSettings": toInputLossFailoverSettings,
      "VideoBlackSettings": toVideoBlackFailoverSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioSilenceFailoverSettings {
  AudioSelectorName: string;
  AudioSilenceThresholdMsec?: number | null;
}
function fromAudioSilenceFailoverSettings(input?: AudioSilenceFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectorName: input["AudioSelectorName"],
    audioSilenceThresholdMsec: input["AudioSilenceThresholdMsec"],
  }
}
function toAudioSilenceFailoverSettings(root: jsonP.JSONValue): AudioSilenceFailoverSettings {
  return jsonP.readObj({
    required: {
      "AudioSelectorName": "s",
    },
    optional: {
      "AudioSilenceThresholdMsec": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface InputLossFailoverSettings {
  InputLossThresholdMsec?: number | null;
}
function fromInputLossFailoverSettings(input?: InputLossFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    inputLossThresholdMsec: input["InputLossThresholdMsec"],
  }
}
function toInputLossFailoverSettings(root: jsonP.JSONValue): InputLossFailoverSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputLossThresholdMsec": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface VideoBlackFailoverSettings {
  BlackDetectThreshold?: number | null;
  VideoBlackThresholdMsec?: number | null;
}
function fromVideoBlackFailoverSettings(input?: VideoBlackFailoverSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    blackDetectThreshold: input["BlackDetectThreshold"],
    videoBlackThresholdMsec: input["VideoBlackThresholdMsec"],
  }
}
function toVideoBlackFailoverSettings(root: jsonP.JSONValue): VideoBlackFailoverSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlackDetectThreshold": "n",
      "VideoBlackThresholdMsec": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputPreference =
| "EQUAL_INPUT_PREFERENCE"
| "PRIMARY_INPUT_PREFERRED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface InputSettings {
  AudioSelectors?: AudioSelector[] | null;
  CaptionSelectors?: CaptionSelector[] | null;
  DeblockFilter?: InputDeblockFilter | null;
  DenoiseFilter?: InputDenoiseFilter | null;
  FilterStrength?: number | null;
  InputFilter?: InputFilter | null;
  NetworkInputSettings?: NetworkInputSettings | null;
  Smpte2038DataPreference?: Smpte2038DataPreference | null;
  SourceEndBehavior?: InputSourceEndBehavior | null;
  VideoSelector?: VideoSelector | null;
}
function fromInputSettings(input?: InputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioSelectors: input["AudioSelectors"]?.map(x => fromAudioSelector(x)),
    captionSelectors: input["CaptionSelectors"]?.map(x => fromCaptionSelector(x)),
    deblockFilter: input["DeblockFilter"],
    denoiseFilter: input["DenoiseFilter"],
    filterStrength: input["FilterStrength"],
    inputFilter: input["InputFilter"],
    networkInputSettings: fromNetworkInputSettings(input["NetworkInputSettings"]),
    smpte2038DataPreference: input["Smpte2038DataPreference"],
    sourceEndBehavior: input["SourceEndBehavior"],
    videoSelector: fromVideoSelector(input["VideoSelector"]),
  }
}
function toInputSettings(root: jsonP.JSONValue): InputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioSelectors": [toAudioSelector],
      "CaptionSelectors": [toCaptionSelector],
      "DeblockFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeblockFilter>(x),
      "DenoiseFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputDenoiseFilter>(x),
      "FilterStrength": "n",
      "InputFilter": (x: jsonP.JSONValue) => cmnP.readEnum<InputFilter>(x),
      "NetworkInputSettings": toNetworkInputSettings,
      "Smpte2038DataPreference": (x: jsonP.JSONValue) => cmnP.readEnum<Smpte2038DataPreference>(x),
      "SourceEndBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<InputSourceEndBehavior>(x),
      "VideoSelector": toVideoSelector,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioSelector {
  Name: string;
  SelectorSettings?: AudioSelectorSettings | null;
}
function fromAudioSelector(input?: AudioSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["Name"],
    selectorSettings: fromAudioSelectorSettings(input["SelectorSettings"]),
  }
}
function toAudioSelector(root: jsonP.JSONValue): AudioSelector {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "SelectorSettings": toAudioSelectorSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioSelectorSettings {
  AudioLanguageSelection?: AudioLanguageSelection | null;
  AudioPidSelection?: AudioPidSelection | null;
  AudioTrackSelection?: AudioTrackSelection | null;
}
function fromAudioSelectorSettings(input?: AudioSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    audioLanguageSelection: fromAudioLanguageSelection(input["AudioLanguageSelection"]),
    audioPidSelection: fromAudioPidSelection(input["AudioPidSelection"]),
    audioTrackSelection: fromAudioTrackSelection(input["AudioTrackSelection"]),
  }
}
function toAudioSelectorSettings(root: jsonP.JSONValue): AudioSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioLanguageSelection": toAudioLanguageSelection,
      "AudioPidSelection": toAudioPidSelection,
      "AudioTrackSelection": toAudioTrackSelection,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioLanguageSelection {
  LanguageCode: string;
  LanguageSelectionPolicy?: AudioLanguageSelectionPolicy | null;
}
function fromAudioLanguageSelection(input?: AudioLanguageSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    languageCode: input["LanguageCode"],
    languageSelectionPolicy: input["LanguageSelectionPolicy"],
  }
}
function toAudioLanguageSelection(root: jsonP.JSONValue): AudioLanguageSelection {
  return jsonP.readObj({
    required: {
      "LanguageCode": "s",
    },
    optional: {
      "LanguageSelectionPolicy": (x: jsonP.JSONValue) => cmnP.readEnum<AudioLanguageSelectionPolicy>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type AudioLanguageSelectionPolicy =
| "LOOSE"
| "STRICT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface AudioPidSelection {
  Pid: number;
}
function fromAudioPidSelection(input?: AudioPidSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toAudioPidSelection(root: jsonP.JSONValue): AudioPidSelection {
  return jsonP.readObj({
    required: {
      "Pid": "n",
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioTrackSelection {
  Tracks: AudioTrack[];
}
function fromAudioTrackSelection(input?: AudioTrackSelection | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tracks: input["Tracks"]?.map(x => fromAudioTrack(x)),
  }
}
function toAudioTrackSelection(root: jsonP.JSONValue): AudioTrackSelection {
  return jsonP.readObj({
    required: {
      "Tracks": [toAudioTrack],
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AudioTrack {
  Track: number;
}
function fromAudioTrack(input?: AudioTrack | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    track: input["Track"],
  }
}
function toAudioTrack(root: jsonP.JSONValue): AudioTrack {
  return jsonP.readObj({
    required: {
      "Track": "n",
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CaptionSelector {
  LanguageCode?: string | null;
  Name: string;
  SelectorSettings?: CaptionSelectorSettings | null;
}
function fromCaptionSelector(input?: CaptionSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    languageCode: input["LanguageCode"],
    name: input["Name"],
    selectorSettings: fromCaptionSelectorSettings(input["SelectorSettings"]),
  }
}
function toCaptionSelector(root: jsonP.JSONValue): CaptionSelector {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "LanguageCode": "s",
      "SelectorSettings": toCaptionSelectorSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface CaptionSelectorSettings {
  AncillarySourceSettings?: AncillarySourceSettings | null;
  AribSourceSettings?: AribSourceSettings | null;
  DvbSubSourceSettings?: DvbSubSourceSettings | null;
  EmbeddedSourceSettings?: EmbeddedSourceSettings | null;
  Scte20SourceSettings?: Scte20SourceSettings | null;
  Scte27SourceSettings?: Scte27SourceSettings | null;
  TeletextSourceSettings?: TeletextSourceSettings | null;
}
function fromCaptionSelectorSettings(input?: CaptionSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ancillarySourceSettings: fromAncillarySourceSettings(input["AncillarySourceSettings"]),
    aribSourceSettings: fromAribSourceSettings(input["AribSourceSettings"]),
    dvbSubSourceSettings: fromDvbSubSourceSettings(input["DvbSubSourceSettings"]),
    embeddedSourceSettings: fromEmbeddedSourceSettings(input["EmbeddedSourceSettings"]),
    scte20SourceSettings: fromScte20SourceSettings(input["Scte20SourceSettings"]),
    scte27SourceSettings: fromScte27SourceSettings(input["Scte27SourceSettings"]),
    teletextSourceSettings: fromTeletextSourceSettings(input["TeletextSourceSettings"]),
  }
}
function toCaptionSelectorSettings(root: jsonP.JSONValue): CaptionSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "AncillarySourceSettings": toAncillarySourceSettings,
      "AribSourceSettings": toAribSourceSettings,
      "DvbSubSourceSettings": toDvbSubSourceSettings,
      "EmbeddedSourceSettings": toEmbeddedSourceSettings,
      "Scte20SourceSettings": toScte20SourceSettings,
      "Scte27SourceSettings": toScte27SourceSettings,
      "TeletextSourceSettings": toTeletextSourceSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AncillarySourceSettings {
  SourceAncillaryChannelNumber?: number | null;
}
function fromAncillarySourceSettings(input?: AncillarySourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    sourceAncillaryChannelNumber: input["SourceAncillaryChannelNumber"],
  }
}
function toAncillarySourceSettings(root: jsonP.JSONValue): AncillarySourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceAncillaryChannelNumber": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface AribSourceSettings {
}
function fromAribSourceSettings(input?: AribSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAribSourceSettings(root: jsonP.JSONValue): AribSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface DvbSubSourceSettings {
  Pid?: number | null;
}
function fromDvbSubSourceSettings(input?: DvbSubSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toDvbSubSourceSettings(root: jsonP.JSONValue): DvbSubSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface EmbeddedSourceSettings {
  Convert608To708?: EmbeddedConvert608To708 | null;
  Scte20Detection?: EmbeddedScte20Detection | null;
  Source608ChannelNumber?: number | null;
  Source608TrackNumber?: number | null;
}
function fromEmbeddedSourceSettings(input?: EmbeddedSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    scte20Detection: input["Scte20Detection"],
    source608ChannelNumber: input["Source608ChannelNumber"],
    source608TrackNumber: input["Source608TrackNumber"],
  }
}
function toEmbeddedSourceSettings(root: jsonP.JSONValue): EmbeddedSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<EmbeddedConvert608To708>(x),
      "Scte20Detection": (x: jsonP.JSONValue) => cmnP.readEnum<EmbeddedScte20Detection>(x),
      "Source608ChannelNumber": "n",
      "Source608TrackNumber": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type EmbeddedConvert608To708 =
| "DISABLED"
| "UPCONVERT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type EmbeddedScte20Detection =
| "AUTO"
| "OFF"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Scte20SourceSettings {
  Convert608To708?: Scte20Convert608To708 | null;
  Source608ChannelNumber?: number | null;
}
function fromScte20SourceSettings(input?: Scte20SourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    convert608To708: input["Convert608To708"],
    source608ChannelNumber: input["Source608ChannelNumber"],
  }
}
function toScte20SourceSettings(root: jsonP.JSONValue): Scte20SourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Convert608To708": (x: jsonP.JSONValue) => cmnP.readEnum<Scte20Convert608To708>(x),
      "Source608ChannelNumber": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type Scte20Convert608To708 =
| "DISABLED"
| "UPCONVERT"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface Scte27SourceSettings {
  Pid?: number | null;
}
function fromScte27SourceSettings(input?: Scte27SourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toScte27SourceSettings(root: jsonP.JSONValue): Scte27SourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface TeletextSourceSettings {
  PageNumber?: string | null;
}
function fromTeletextSourceSettings(input?: TeletextSourceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pageNumber: input["PageNumber"],
  }
}
function toTeletextSourceSettings(root: jsonP.JSONValue): TeletextSourceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "PageNumber": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputDeblockFilter =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputDenoiseFilter =
| "DISABLED"
| "ENABLED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputFilter =
| "AUTO"
| "DISABLED"
| "FORCED"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface NetworkInputSettings {
  HlsInputSettings?: HlsInputSettings | null;
  ServerValidation?: NetworkInputServerValidation | null;
}
function fromNetworkInputSettings(input?: NetworkInputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    hlsInputSettings: fromHlsInputSettings(input["HlsInputSettings"]),
    serverValidation: input["ServerValidation"],
  }
}
function toNetworkInputSettings(root: jsonP.JSONValue): NetworkInputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "HlsInputSettings": toHlsInputSettings,
      "ServerValidation": (x: jsonP.JSONValue) => cmnP.readEnum<NetworkInputServerValidation>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface HlsInputSettings {
  Bandwidth?: number | null;
  BufferSegments?: number | null;
  Retries?: number | null;
  RetryInterval?: number | null;
}
function fromHlsInputSettings(input?: HlsInputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    bandwidth: input["Bandwidth"],
    bufferSegments: input["BufferSegments"],
    retries: input["Retries"],
    retryInterval: input["RetryInterval"],
  }
}
function toHlsInputSettings(root: jsonP.JSONValue): HlsInputSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Bandwidth": "n",
      "BufferSegments": "n",
      "Retries": "n",
      "RetryInterval": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type NetworkInputServerValidation =
| "CHECK_CRYPTOGRAPHY_AND_VALIDATE_NAME"
| "CHECK_CRYPTOGRAPHY_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type Smpte2038DataPreference =
| "IGNORE"
| "PREFER"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputSourceEndBehavior =
| "CONTINUE"
| "LOOP"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface VideoSelector {
  ColorSpace?: VideoSelectorColorSpace | null;
  ColorSpaceUsage?: VideoSelectorColorSpaceUsage | null;
  SelectorSettings?: VideoSelectorSettings | null;
}
function fromVideoSelector(input?: VideoSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    colorSpace: input["ColorSpace"],
    colorSpaceUsage: input["ColorSpaceUsage"],
    selectorSettings: fromVideoSelectorSettings(input["SelectorSettings"]),
  }
}
function toVideoSelector(root: jsonP.JSONValue): VideoSelector {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColorSpace": (x: jsonP.JSONValue) => cmnP.readEnum<VideoSelectorColorSpace>(x),
      "ColorSpaceUsage": (x: jsonP.JSONValue) => cmnP.readEnum<VideoSelectorColorSpaceUsage>(x),
      "SelectorSettings": toVideoSelectorSettings,
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type VideoSelectorColorSpace =
| "FOLLOW"
| "REC_601"
| "REC_709"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type VideoSelectorColorSpaceUsage =
| "FALLBACK"
| "FORCE"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface VideoSelectorSettings {
  VideoSelectorPid?: VideoSelectorPid | null;
  VideoSelectorProgramId?: VideoSelectorProgramId | null;
}
function fromVideoSelectorSettings(input?: VideoSelectorSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    videoSelectorPid: fromVideoSelectorPid(input["VideoSelectorPid"]),
    videoSelectorProgramId: fromVideoSelectorProgramId(input["VideoSelectorProgramId"]),
  }
}
function toVideoSelectorSettings(root: jsonP.JSONValue): VideoSelectorSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "VideoSelectorPid": toVideoSelectorPid,
      "VideoSelectorProgramId": toVideoSelectorProgramId,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface VideoSelectorPid {
  Pid?: number | null;
}
function fromVideoSelectorPid(input?: VideoSelectorPid | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pid: input["Pid"],
  }
}
function toVideoSelectorPid(root: jsonP.JSONValue): VideoSelectorPid {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pid": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface VideoSelectorProgramId {
  ProgramId?: number | null;
}
function fromVideoSelectorProgramId(input?: VideoSelectorProgramId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    programId: input["ProgramId"],
  }
}
function toVideoSelectorProgramId(root: jsonP.JSONValue): VideoSelectorProgramId {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProgramId": "n",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface InputSpecification {
  Codec?: InputCodec | null;
  MaximumBitrate?: InputMaximumBitrate | null;
  Resolution?: InputResolution | null;
}
function fromInputSpecification(input?: InputSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    codec: input["Codec"],
    maximumBitrate: input["MaximumBitrate"],
    resolution: input["Resolution"],
  }
}
function toInputSpecification(root: jsonP.JSONValue): InputSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<InputCodec>(x),
      "MaximumBitrate": (x: jsonP.JSONValue) => cmnP.readEnum<InputMaximumBitrate>(x),
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<InputResolution>(x),
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type InputCodec =
| "MPEG2"
| "AVC"
| "HEVC"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputMaximumBitrate =
| "MAX_10_MBPS"
| "MAX_20_MBPS"
| "MAX_50_MBPS"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type InputResolution =
| "SD"
| "HD"
| "UHD"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type LogLevel =
| "ERROR"
| "WARNING"
| "INFO"
| "DEBUG"
| "DISABLED"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, interface, output
export interface VpcOutputSettings {
  PublicAddressAllocationIds?: string[] | null;
  SecurityGroupIds?: string[] | null;
  SubnetIds: string[];
}
function fromVpcOutputSettings(input?: VpcOutputSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    publicAddressAllocationIds: input["PublicAddressAllocationIds"],
    securityGroupIds: input["SecurityGroupIds"],
    subnetIds: input["SubnetIds"],
  }
}
function toVpcOutputSettings(root: jsonP.JSONValue): VpcOutputSettings {
  return jsonP.readObj({
    required: {
      "SubnetIds": ["s"],
    },
    optional: {
      "PublicAddressAllocationIds": ["s"],
      "SecurityGroupIds": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface InputDestinationRequest {
  StreamName?: string | null;
}
function fromInputDestinationRequest(input?: InputDestinationRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    streamName: input["StreamName"],
  }
}

// refs: 5 - tags: input, named, interface, output
export interface InputDeviceSettings {
  Id?: string | null;
}
function fromInputDeviceSettings(input?: InputDeviceSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
  }
}
function toInputDeviceSettings(root: jsonP.JSONValue): InputDeviceSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface MediaConnectFlowRequest {
  FlowArn?: string | null;
}
function fromMediaConnectFlowRequest(input?: MediaConnectFlowRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    flowArn: input["FlowArn"],
  }
}

// refs: 2 - tags: input, named, interface
export interface InputSourceRequest {
  PasswordParam?: string | null;
  Url?: string | null;
  Username?: string | null;
}
function fromInputSourceRequest(input?: InputSourceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    passwordParam: input["PasswordParam"],
    url: input["Url"],
    username: input["Username"],
  }
}

// refs: 5 - tags: input, named, enum, output
export type InputType =
| "UDP_PUSH"
| "RTP_PUSH"
| "RTMP_PUSH"
| "RTMP_PULL"
| "URL_PULL"
| "MP4_FILE"
| "MEDIACONNECT"
| "INPUT_DEVICE"
| "AWS_CDI"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface InputVpcRequest {
  SecurityGroupIds?: string[] | null;
  SubnetIds: string[];
}
function fromInputVpcRequest(input?: InputVpcRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    securityGroupIds: input["SecurityGroupIds"],
    subnetIds: input["SubnetIds"],
  }
}

// refs: 2 - tags: input, named, interface
export interface InputWhitelistRuleCidr {
  Cidr?: string | null;
}
function fromInputWhitelistRuleCidr(input?: InputWhitelistRuleCidr | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    cidr: input["Cidr"],
  }
}

// refs: 8 - tags: input, named, interface, output
export interface MultiplexSettings {
  MaximumVideoBufferDelayMilliseconds?: number | null;
  TransportStreamBitrate: number;
  TransportStreamId: number;
  TransportStreamReservedBitrate?: number | null;
}
function fromMultiplexSettings(input?: MultiplexSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumVideoBufferDelayMilliseconds: input["MaximumVideoBufferDelayMilliseconds"],
    transportStreamBitrate: input["TransportStreamBitrate"],
    transportStreamId: input["TransportStreamId"],
    transportStreamReservedBitrate: input["TransportStreamReservedBitrate"],
  }
}
function toMultiplexSettings(root: jsonP.JSONValue): MultiplexSettings {
  return jsonP.readObj({
    required: {
      "TransportStreamBitrate": "n",
      "TransportStreamId": "n",
    },
    optional: {
      "MaximumVideoBufferDelayMilliseconds": "n",
      "TransportStreamReservedBitrate": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MultiplexProgramSettings {
  PreferredChannelPipeline?: PreferredChannelPipeline | null;
  ProgramNumber: number;
  ServiceDescriptor?: MultiplexProgramServiceDescriptor | null;
  VideoSettings?: MultiplexVideoSettings | null;
}
function fromMultiplexProgramSettings(input?: MultiplexProgramSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    preferredChannelPipeline: input["PreferredChannelPipeline"],
    programNumber: input["ProgramNumber"],
    serviceDescriptor: fromMultiplexProgramServiceDescriptor(input["ServiceDescriptor"]),
    videoSettings: fromMultiplexVideoSettings(input["VideoSettings"]),
  }
}
function toMultiplexProgramSettings(root: jsonP.JSONValue): MultiplexProgramSettings {
  return jsonP.readObj({
    required: {
      "ProgramNumber": "n",
    },
    optional: {
      "PreferredChannelPipeline": (x: jsonP.JSONValue) => cmnP.readEnum<PreferredChannelPipeline>(x),
      "ServiceDescriptor": toMultiplexProgramServiceDescriptor,
      "VideoSettings": toMultiplexVideoSettings,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type PreferredChannelPipeline =
| "CURRENTLY_ACTIVE"
| "PIPELINE_0"
| "PIPELINE_1"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface MultiplexProgramServiceDescriptor {
  ProviderName: string;
  ServiceName: string;
}
function fromMultiplexProgramServiceDescriptor(input?: MultiplexProgramServiceDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    providerName: input["ProviderName"],
    serviceName: input["ServiceName"],
  }
}
function toMultiplexProgramServiceDescriptor(root: jsonP.JSONValue): MultiplexProgramServiceDescriptor {
  return jsonP.readObj({
    required: {
      "ProviderName": "s",
      "ServiceName": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MultiplexVideoSettings {
  ConstantBitrate?: number | null;
  StatmuxSettings?: MultiplexStatmuxVideoSettings | null;
}
function fromMultiplexVideoSettings(input?: MultiplexVideoSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    constantBitrate: input["ConstantBitrate"],
    statmuxSettings: fromMultiplexStatmuxVideoSettings(input["StatmuxSettings"]),
  }
}
function toMultiplexVideoSettings(root: jsonP.JSONValue): MultiplexVideoSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstantBitrate": "n",
      "StatmuxSettings": toMultiplexStatmuxVideoSettings,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface MultiplexStatmuxVideoSettings {
  MaximumBitrate?: number | null;
  MinimumBitrate?: number | null;
  Priority?: number | null;
}
function fromMultiplexStatmuxVideoSettings(input?: MultiplexStatmuxVideoSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    maximumBitrate: input["MaximumBitrate"],
    minimumBitrate: input["MinimumBitrate"],
    priority: input["Priority"],
  }
}
function toMultiplexStatmuxVideoSettings(root: jsonP.JSONValue): MultiplexStatmuxVideoSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaximumBitrate": "n",
      "MinimumBitrate": "n",
      "Priority": "n",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type AcceptHeader =
| "image/jpeg"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface InputDeviceRequest {
  Id?: string | null;
}
function fromInputDeviceRequest(input?: InputDeviceRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["Id"],
  }
}

// refs: 2 - tags: input, named, interface
export interface InputDeviceConfigurableSettings {
  ConfiguredInput?: InputDeviceConfiguredInput | null;
  MaxBitrate?: number | null;
}
function fromInputDeviceConfigurableSettings(input?: InputDeviceConfigurableSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    configuredInput: input["ConfiguredInput"],
    maxBitrate: input["MaxBitrate"],
  }
}

// refs: 8 - tags: input, named, enum, output
export type InputDeviceConfiguredInput =
| "AUTO"
| "HDMI"
| "SDI"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface BatchFailedResultModel {
  Arn?: string | null;
  Code?: string | null;
  Id?: string | null;
  Message?: string | null;
}
function toBatchFailedResultModel(root: jsonP.JSONValue): BatchFailedResultModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Code": "s",
      "Id": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface BatchSuccessfulResultModel {
  Arn?: string | null;
  Id?: string | null;
  State?: string | null;
}
function toBatchSuccessfulResultModel(root: jsonP.JSONValue): BatchSuccessfulResultModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Id": "s",
      "State": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchScheduleActionCreateResult {
  ScheduleActions: ScheduleAction[];
}
function toBatchScheduleActionCreateResult(root: jsonP.JSONValue): BatchScheduleActionCreateResult {
  return jsonP.readObj({
    required: {
      "ScheduleActions": [toScheduleAction],
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchScheduleActionDeleteResult {
  ScheduleActions: ScheduleAction[];
}
function toBatchScheduleActionDeleteResult(root: jsonP.JSONValue): BatchScheduleActionDeleteResult {
  return jsonP.readObj({
    required: {
      "ScheduleActions": [toScheduleAction],
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Channel {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  EncoderSettings?: EncoderSettings | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelineDetails?: PipelineDetail[] | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}
function toChannel(root: jsonP.JSONValue): Channel {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CdiInputSpecification": toCdiInputSpecification,
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
      "Destinations": [toOutputDestination],
      "EgressEndpoints": [toChannelEgressEndpoint],
      "EncoderSettings": toEncoderSettings,
      "Id": "s",
      "InputAttachments": [toInputAttachment],
      "InputSpecification": toInputSpecification,
      "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
      "Name": "s",
      "PipelineDetails": [toPipelineDetail],
      "PipelinesRunningCount": "n",
      "RoleArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Vpc": toVpcOutputSettings,
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface ChannelEgressEndpoint {
  SourceIp?: string | null;
}
function toChannelEgressEndpoint(root: jsonP.JSONValue): ChannelEgressEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceIp": "s",
    },
  }, root);
}

// refs: 7 - tags: output, named, interface
export interface PipelineDetail {
  ActiveInputAttachmentName?: string | null;
  ActiveInputSwitchActionName?: string | null;
  PipelineId?: string | null;
}
function toPipelineDetail(root: jsonP.JSONValue): PipelineDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInputAttachmentName": "s",
      "ActiveInputSwitchActionName": "s",
      "PipelineId": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, enum
export type ChannelState =
| "CREATING"
| "CREATE_FAILED"
| "IDLE"
| "STARTING"
| "RUNNING"
| "RECOVERING"
| "STOPPING"
| "DELETING"
| "DELETED"
| "UPDATING"
| "UPDATE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Input {
  Arn?: string | null;
  AttachedChannels?: string[] | null;
  Destinations?: InputDestination[] | null;
  Id?: string | null;
  InputClass?: InputClass | null;
  InputDevices?: InputDeviceSettings[] | null;
  InputSourceType?: InputSourceType | null;
  MediaConnectFlows?: MediaConnectFlow[] | null;
  Name?: string | null;
  RoleArn?: string | null;
  SecurityGroups?: string[] | null;
  Sources?: InputSource[] | null;
  State?: InputState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Type?: InputType | null;
}
function toInput(root: jsonP.JSONValue): Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AttachedChannels": ["s"],
      "Destinations": [toInputDestination],
      "Id": "s",
      "InputClass": (x: jsonP.JSONValue) => cmnP.readEnum<InputClass>(x),
      "InputDevices": [toInputDeviceSettings],
      "InputSourceType": (x: jsonP.JSONValue) => cmnP.readEnum<InputSourceType>(x),
      "MediaConnectFlows": [toMediaConnectFlow],
      "Name": "s",
      "RoleArn": "s",
      "SecurityGroups": ["s"],
      "Sources": [toInputSource],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InputState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<InputType>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface InputDestination {
  Ip?: string | null;
  Port?: string | null;
  Url?: string | null;
  Vpc?: InputDestinationVpc | null;
}
function toInputDestination(root: jsonP.JSONValue): InputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "Ip": "s",
      "Port": "s",
      "Url": "s",
      "Vpc": toInputDestinationVpc,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface InputDestinationVpc {
  AvailabilityZone?: string | null;
  NetworkInterfaceId?: string | null;
}
function toInputDestinationVpc(root: jsonP.JSONValue): InputDestinationVpc {
  return jsonP.readObj({
    required: {},
    optional: {
      "AvailabilityZone": "s",
      "NetworkInterfaceId": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type InputClass =
| "STANDARD"
| "SINGLE_PIPELINE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type InputSourceType =
| "STATIC"
| "DYNAMIC"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface MediaConnectFlow {
  FlowArn?: string | null;
}
function toMediaConnectFlow(root: jsonP.JSONValue): MediaConnectFlow {
  return jsonP.readObj({
    required: {},
    optional: {
      "FlowArn": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface InputSource {
  PasswordParam?: string | null;
  Url?: string | null;
  Username?: string | null;
}
function toInputSource(root: jsonP.JSONValue): InputSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "PasswordParam": "s",
      "Url": "s",
      "Username": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type InputState =
| "CREATING"
| "DETACHED"
| "ATTACHED"
| "DELETING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InputSecurityGroup {
  Arn?: string | null;
  Id?: string | null;
  Inputs?: string[] | null;
  State?: InputSecurityGroupState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  WhitelistRules?: InputWhitelistRule[] | null;
}
function toInputSecurityGroup(root: jsonP.JSONValue): InputSecurityGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Id": "s",
      "Inputs": ["s"],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<InputSecurityGroupState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "WhitelistRules": [toInputWhitelistRule],
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type InputSecurityGroupState =
| "IDLE"
| "IN_USE"
| "UPDATING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface InputWhitelistRule {
  Cidr?: string | null;
}
function toInputWhitelistRule(root: jsonP.JSONValue): InputWhitelistRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "Cidr": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Multiplex {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Destinations?: MultiplexOutputDestination[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettings | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toMultiplex(root: jsonP.JSONValue): Multiplex {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AvailabilityZones": ["s"],
      "Destinations": [toMultiplexOutputDestination],
      "Id": "s",
      "MultiplexSettings": toMultiplexSettings,
      "Name": "s",
      "PipelinesRunningCount": "n",
      "ProgramCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface MultiplexOutputDestination {
  MediaConnectSettings?: MultiplexMediaConnectOutputDestinationSettings | null;
}
function toMultiplexOutputDestination(root: jsonP.JSONValue): MultiplexOutputDestination {
  return jsonP.readObj({
    required: {},
    optional: {
      "MediaConnectSettings": toMultiplexMediaConnectOutputDestinationSettings,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface MultiplexMediaConnectOutputDestinationSettings {
  EntitlementArn?: string | null;
}
function toMultiplexMediaConnectOutputDestinationSettings(root: jsonP.JSONValue): MultiplexMediaConnectOutputDestinationSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EntitlementArn": "s",
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type MultiplexState =
| "CREATING"
| "CREATE_FAILED"
| "IDLE"
| "STARTING"
| "RUNNING"
| "RECOVERING"
| "STOPPING"
| "DELETING"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MultiplexProgram {
  ChannelId?: string | null;
  MultiplexProgramSettings?: MultiplexProgramSettings | null;
  PacketIdentifiersMap?: MultiplexProgramPacketIdentifiersMap | null;
  PipelineDetails?: MultiplexProgramPipelineDetail[] | null;
  ProgramName?: string | null;
}
function toMultiplexProgram(root: jsonP.JSONValue): MultiplexProgram {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
      "MultiplexProgramSettings": toMultiplexProgramSettings,
      "PacketIdentifiersMap": toMultiplexProgramPacketIdentifiersMap,
      "PipelineDetails": [toMultiplexProgramPipelineDetail],
      "ProgramName": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface MultiplexProgramPacketIdentifiersMap {
  AudioPids?: number[] | null;
  DvbSubPids?: number[] | null;
  DvbTeletextPid?: number | null;
  EtvPlatformPid?: number | null;
  EtvSignalPid?: number | null;
  KlvDataPids?: number[] | null;
  PcrPid?: number | null;
  PmtPid?: number | null;
  PrivateMetadataPid?: number | null;
  Scte27Pids?: number[] | null;
  Scte35Pid?: number | null;
  TimedMetadataPid?: number | null;
  VideoPid?: number | null;
}
function toMultiplexProgramPacketIdentifiersMap(root: jsonP.JSONValue): MultiplexProgramPacketIdentifiersMap {
  return jsonP.readObj({
    required: {},
    optional: {
      "AudioPids": ["n"],
      "DvbSubPids": ["n"],
      "DvbTeletextPid": "n",
      "EtvPlatformPid": "n",
      "EtvSignalPid": "n",
      "KlvDataPids": ["n"],
      "PcrPid": "n",
      "PmtPid": "n",
      "PrivateMetadataPid": "n",
      "Scte27Pids": ["n"],
      "Scte35Pid": "n",
      "TimedMetadataPid": "n",
      "VideoPid": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface MultiplexProgramPipelineDetail {
  ActiveChannelPipeline?: string | null;
  PipelineId?: string | null;
}
function toMultiplexProgramPipelineDetail(root: jsonP.JSONValue): MultiplexProgramPipelineDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveChannelPipeline": "s",
      "PipelineId": "s",
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type OfferingDurationUnits =
| "MONTHS"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type OfferingType =
| "NO_UPFRONT"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, interface
export interface ReservationResourceSpecification {
  ChannelClass?: ChannelClass | null;
  Codec?: ReservationCodec | null;
  MaximumBitrate?: ReservationMaximumBitrate | null;
  MaximumFramerate?: ReservationMaximumFramerate | null;
  Resolution?: ReservationResolution | null;
  ResourceType?: ReservationResourceType | null;
  SpecialFeature?: ReservationSpecialFeature | null;
  VideoQuality?: ReservationVideoQuality | null;
}
function toReservationResourceSpecification(root: jsonP.JSONValue): ReservationResourceSpecification {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
      "Codec": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationCodec>(x),
      "MaximumBitrate": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationMaximumBitrate>(x),
      "MaximumFramerate": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationMaximumFramerate>(x),
      "Resolution": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationResolution>(x),
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationResourceType>(x),
      "SpecialFeature": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationSpecialFeature>(x),
      "VideoQuality": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationVideoQuality>(x),
    },
  }, root);
}

// refs: 7 - tags: output, named, enum
export type ReservationCodec =
| "MPEG2"
| "AVC"
| "HEVC"
| "AUDIO"
| "LINK"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationMaximumBitrate =
| "MAX_10_MBPS"
| "MAX_20_MBPS"
| "MAX_50_MBPS"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationMaximumFramerate =
| "MAX_30_FPS"
| "MAX_60_FPS"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationResolution =
| "SD"
| "HD"
| "FHD"
| "UHD"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationResourceType =
| "INPUT"
| "OUTPUT"
| "MULTIPLEX"
| "CHANNEL"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationSpecialFeature =
| "ADVANCED_AUDIO"
| "AUDIO_NORMALIZATION"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: output, named, enum
export type ReservationVideoQuality =
| "STANDARD"
| "ENHANCED"
| "PREMIUM"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, enum
export type ReservationState =
| "ACTIVE"
| "EXPIRED"
| "CANCELED"
| "DELETED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type InputDeviceConnectionState =
| "DISCONNECTED"
| "CONNECTED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type DeviceSettingsSyncState =
| "SYNCED"
| "SYNCING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type DeviceUpdateStatus =
| "UP_TO_DATE"
| "NOT_UP_TO_DATE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InputDeviceHdSettings {
  ActiveInput?: InputDeviceActiveInput | null;
  ConfiguredInput?: InputDeviceConfiguredInput | null;
  DeviceState?: InputDeviceState | null;
  Framerate?: number | null;
  Height?: number | null;
  MaxBitrate?: number | null;
  ScanType?: InputDeviceScanType | null;
  Width?: number | null;
}
function toInputDeviceHdSettings(root: jsonP.JSONValue): InputDeviceHdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInput": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceActiveInput>(x),
      "ConfiguredInput": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceConfiguredInput>(x),
      "DeviceState": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceState>(x),
      "Framerate": "n",
      "Height": "n",
      "MaxBitrate": "n",
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceScanType>(x),
      "Width": "n",
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type InputDeviceActiveInput =
| "HDMI"
| "SDI"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, enum
export type InputDeviceState =
| "IDLE"
| "STREAMING"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, enum
export type InputDeviceScanType =
| "INTERLACED"
| "PROGRESSIVE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InputDeviceNetworkSettings {
  DnsAddresses?: string[] | null;
  Gateway?: string | null;
  IpAddress?: string | null;
  IpScheme?: InputDeviceIpScheme | null;
  SubnetMask?: string | null;
}
function toInputDeviceNetworkSettings(root: jsonP.JSONValue): InputDeviceNetworkSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DnsAddresses": ["s"],
      "Gateway": "s",
      "IpAddress": "s",
      "IpScheme": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceIpScheme>(x),
      "SubnetMask": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type InputDeviceIpScheme =
| "STATIC"
| "DHCP"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type InputDeviceType =
| "HD"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface InputDeviceUhdSettings {
  ActiveInput?: InputDeviceActiveInput | null;
  ConfiguredInput?: InputDeviceConfiguredInput | null;
  DeviceState?: InputDeviceState | null;
  Framerate?: number | null;
  Height?: number | null;
  MaxBitrate?: number | null;
  ScanType?: InputDeviceScanType | null;
  Width?: number | null;
}
function toInputDeviceUhdSettings(root: jsonP.JSONValue): InputDeviceUhdSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActiveInput": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceActiveInput>(x),
      "ConfiguredInput": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceConfiguredInput>(x),
      "DeviceState": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceState>(x),
      "Framerate": "n",
      "Height": "n",
      "MaxBitrate": "n",
      "ScanType": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceScanType>(x),
      "Width": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type ContentType =
| "image/jpeg"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ChannelSummary {
  Arn?: string | null;
  CdiInputSpecification?: CdiInputSpecification | null;
  ChannelClass?: ChannelClass | null;
  Destinations?: OutputDestination[] | null;
  EgressEndpoints?: ChannelEgressEndpoint[] | null;
  Id?: string | null;
  InputAttachments?: InputAttachment[] | null;
  InputSpecification?: InputSpecification | null;
  LogLevel?: LogLevel | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  RoleArn?: string | null;
  State?: ChannelState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Vpc?: VpcOutputSettings | null;
}
function toChannelSummary(root: jsonP.JSONValue): ChannelSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CdiInputSpecification": toCdiInputSpecification,
      "ChannelClass": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelClass>(x),
      "Destinations": [toOutputDestination],
      "EgressEndpoints": [toChannelEgressEndpoint],
      "Id": "s",
      "InputAttachments": [toInputAttachment],
      "InputSpecification": toInputSpecification,
      "LogLevel": (x: jsonP.JSONValue) => cmnP.readEnum<LogLevel>(x),
      "Name": "s",
      "PipelinesRunningCount": "n",
      "RoleArn": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ChannelState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "Vpc": toVpcOutputSettings,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TransferringInputDeviceSummary {
  Id?: string | null;
  Message?: string | null;
  TargetCustomerId?: string | null;
  TransferType?: InputDeviceTransferType | null;
}
function toTransferringInputDeviceSummary(root: jsonP.JSONValue): TransferringInputDeviceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Message": "s",
      "TargetCustomerId": "s",
      "TransferType": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceTransferType>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type InputDeviceTransferType =
| "OUTGOING"
| "INCOMING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface InputDeviceSummary {
  Arn?: string | null;
  ConnectionState?: InputDeviceConnectionState | null;
  DeviceSettingsSyncState?: DeviceSettingsSyncState | null;
  DeviceUpdateStatus?: DeviceUpdateStatus | null;
  HdDeviceSettings?: InputDeviceHdSettings | null;
  Id?: string | null;
  MacAddress?: string | null;
  Name?: string | null;
  NetworkSettings?: InputDeviceNetworkSettings | null;
  SerialNumber?: string | null;
  Type?: InputDeviceType | null;
  UhdDeviceSettings?: InputDeviceUhdSettings | null;
}
function toInputDeviceSummary(root: jsonP.JSONValue): InputDeviceSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "ConnectionState": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceConnectionState>(x),
      "DeviceSettingsSyncState": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceSettingsSyncState>(x),
      "DeviceUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<DeviceUpdateStatus>(x),
      "HdDeviceSettings": toInputDeviceHdSettings,
      "Id": "s",
      "MacAddress": "s",
      "Name": "s",
      "NetworkSettings": toInputDeviceNetworkSettings,
      "SerialNumber": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<InputDeviceType>(x),
      "UhdDeviceSettings": toInputDeviceUhdSettings,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MultiplexProgramSummary {
  ChannelId?: string | null;
  ProgramName?: string | null;
}
function toMultiplexProgramSummary(root: jsonP.JSONValue): MultiplexProgramSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ChannelId": "s",
      "ProgramName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MultiplexSummary {
  Arn?: string | null;
  AvailabilityZones?: string[] | null;
  Id?: string | null;
  MultiplexSettings?: MultiplexSettingsSummary | null;
  Name?: string | null;
  PipelinesRunningCount?: number | null;
  ProgramCount?: number | null;
  State?: MultiplexState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}
function toMultiplexSummary(root: jsonP.JSONValue): MultiplexSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "AvailabilityZones": ["s"],
      "Id": "s",
      "MultiplexSettings": toMultiplexSettingsSummary,
      "Name": "s",
      "PipelinesRunningCount": "n",
      "ProgramCount": "n",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<MultiplexState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MultiplexSettingsSummary {
  TransportStreamBitrate?: number | null;
}
function toMultiplexSettingsSummary(root: jsonP.JSONValue): MultiplexSettingsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransportStreamBitrate": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Offering {
  Arn?: string | null;
  CurrencyCode?: string | null;
  Duration?: number | null;
  DurationUnits?: OfferingDurationUnits | null;
  FixedPrice?: number | null;
  OfferingDescription?: string | null;
  OfferingId?: string | null;
  OfferingType?: OfferingType | null;
  Region?: string | null;
  ResourceSpecification?: ReservationResourceSpecification | null;
  UsagePrice?: number | null;
}
function toOffering(root: jsonP.JSONValue): Offering {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingDurationUnits>(x),
      "FixedPrice": "n",
      "OfferingDescription": "s",
      "OfferingId": "s",
      "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingType>(x),
      "Region": "s",
      "ResourceSpecification": toReservationResourceSpecification,
      "UsagePrice": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Reservation {
  Arn?: string | null;
  Count?: number | null;
  CurrencyCode?: string | null;
  Duration?: number | null;
  DurationUnits?: OfferingDurationUnits | null;
  End?: string | null;
  FixedPrice?: number | null;
  Name?: string | null;
  OfferingDescription?: string | null;
  OfferingId?: string | null;
  OfferingType?: OfferingType | null;
  Region?: string | null;
  ReservationId?: string | null;
  ResourceSpecification?: ReservationResourceSpecification | null;
  Start?: string | null;
  State?: ReservationState | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  UsagePrice?: number | null;
}
function toReservation(root: jsonP.JSONValue): Reservation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Count": "n",
      "CurrencyCode": "s",
      "Duration": "n",
      "DurationUnits": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingDurationUnits>(x),
      "End": "s",
      "FixedPrice": "n",
      "Name": "s",
      "OfferingDescription": "s",
      "OfferingId": "s",
      "OfferingType": (x: jsonP.JSONValue) => cmnP.readEnum<OfferingType>(x),
      "Region": "s",
      "ReservationId": "s",
      "ResourceSpecification": toReservationResourceSpecification,
      "Start": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ReservationState>(x),
      "Tags": x => jsonP.readMap(String, String, x),
      "UsagePrice": "n",
    },
  }, root);
}
