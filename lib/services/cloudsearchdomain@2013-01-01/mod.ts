// Autogenerated API client for: Amazon CloudSearch Domain

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CloudSearchDomain {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudSearchDomain.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-01-01",
    "endpointPrefix": "cloudsearchdomain",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "Amazon CloudSearch Domain",
    "serviceId": "CloudSearch Domain",
    "signatureVersion": "v4",
    "signingName": "cloudsearch",
    "uid": "cloudsearchdomain-2013-01-01"
  };

  async search(
    {abortSignal, ...params}: RequestConfig & SearchRequest,
  ): Promise<SearchResponse> {
    const query = new URLSearchParams;
    if (params["cursor"] != null) query.set("cursor", params["cursor"]?.toString() ?? "");
    if (params["expr"] != null) query.set("expr", params["expr"]?.toString() ?? "");
    if (params["facet"] != null) query.set("facet", params["facet"]?.toString() ?? "");
    if (params["filterQuery"] != null) query.set("fq", params["filterQuery"]?.toString() ?? "");
    if (params["highlight"] != null) query.set("highlight", params["highlight"]?.toString() ?? "");
    if (params["partial"] != null) query.set("partial", params["partial"]?.toString() ?? "");
    query.set("q", params["query"]?.toString() ?? "");
    if (params["queryOptions"] != null) query.set("q.options", params["queryOptions"]?.toString() ?? "");
    if (params["queryParser"] != null) query.set("q.parser", params["queryParser"]?.toString() ?? "");
    if (params["return"] != null) query.set("return", params["return"]?.toString() ?? "");
    if (params["size"] != null) query.set("size", params["size"]?.toString() ?? "");
    if (params["sort"] != null) query.set("sort", params["sort"]?.toString() ?? "");
    if (params["start"] != null) query.set("start", params["start"]?.toString() ?? "");
    if (params["stats"] != null) query.set("stats", params["stats"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "Search",
      method: "GET",
      requestUri: "/2013-01-01/search?format=sdk&pretty=true",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": toSearchStatus,
        "hits": toHits,
        "facets": x => jsonP.readMap(String, toBucketInfo, x),
        "stats": x => jsonP.readMap(String, toFieldStats, x),
      },
    }, await resp.json());
  }

  async suggest(
    {abortSignal, ...params}: RequestConfig & SuggestRequest,
  ): Promise<SuggestResponse> {
    const query = new URLSearchParams;
    query.set("q", params["query"]?.toString() ?? "");
    query.set("suggester", params["suggester"]?.toString() ?? "");
    if (params["size"] != null) query.set("size", params["size"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "Suggest",
      method: "GET",
      requestUri: "/2013-01-01/suggest?format=sdk&pretty=true",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": toSuggestStatus,
        "suggest": toSuggestModel,
      },
    }, await resp.json());
  }

  async uploadDocuments(
    {abortSignal, ...params}: RequestConfig & UploadDocumentsRequest,
  ): Promise<UploadDocumentsResponse> {
    const body = typeof params["documents"] === 'string' ? new TextEncoder().encode(params["documents"]) : params["documents"];
    const headers = new Headers;
    headers.append("Content-Type", params["contentType"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UploadDocuments",
      requestUri: "/2013-01-01/documents/batch?format=sdk",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": "s",
        "adds": "n",
        "deletes": "n",
        "warnings": [toDocumentServiceWarning],
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface SearchRequest {
  cursor?: string | null;
  expr?: string | null;
  facet?: string | null;
  filterQuery?: string | null;
  highlight?: string | null;
  partial?: boolean | null;
  query: string;
  queryOptions?: string | null;
  queryParser?: QueryParser | null;
  return?: string | null;
  size?: number | null;
  sort?: string | null;
  start?: number | null;
  stats?: string | null;
}

// refs: 1 - tags: named, input
export interface SuggestRequest {
  query: string;
  suggester: string;
  size?: number | null;
}

// refs: 1 - tags: named, input
export interface UploadDocumentsRequest {
  documents: Uint8Array | string;
  contentType: ContentType;
}

// refs: 1 - tags: named, output
export interface SearchResponse {
  status?: SearchStatus | null;
  hits?: Hits | null;
  facets?: { [key: string]: BucketInfo | null | undefined } | null;
  stats?: { [key: string]: FieldStats | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface SuggestResponse {
  status?: SuggestStatus | null;
  suggest?: SuggestModel | null;
}

// refs: 1 - tags: named, output
export interface UploadDocumentsResponse {
  status?: string | null;
  adds?: number | null;
  deletes?: number | null;
  warnings?: DocumentServiceWarning[] | null;
}

// refs: 1 - tags: input, named, enum
export type QueryParser =
| "simple"
| "structured"
| "lucene"
| "dismax"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ContentType =
| "application/json"
| "application/xml"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SearchStatus {
  timems?: number | null;
  rid?: string | null;
}
function toSearchStatus(root: jsonP.JSONValue): SearchStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "timems": "n",
      "rid": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Hits {
  found?: number | null;
  start?: number | null;
  cursor?: string | null;
  hit?: Hit[] | null;
}
function toHits(root: jsonP.JSONValue): Hits {
  return jsonP.readObj({
    required: {},
    optional: {
      "found": "n",
      "start": "n",
      "cursor": "s",
      "hit": [toHit],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Hit {
  id?: string | null;
  fields?: { [key: string]: string[] | null | undefined } | null;
  exprs?: { [key: string]: string | null | undefined } | null;
  highlights?: { [key: string]: string | null | undefined } | null;
}
function toHit(root: jsonP.JSONValue): Hit {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "fields": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "exprs": x => jsonP.readMap(String, String, x),
      "highlights": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BucketInfo {
  buckets?: Bucket[] | null;
}
function toBucketInfo(root: jsonP.JSONValue): BucketInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "buckets": [toBucket],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Bucket {
  value?: string | null;
  count?: number | null;
}
function toBucket(root: jsonP.JSONValue): Bucket {
  return jsonP.readObj({
    required: {},
    optional: {
      "value": "s",
      "count": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FieldStats {
  min?: string | null;
  max?: string | null;
  count?: number | null;
  missing?: number | null;
  sum?: number | null;
  sumOfSquares?: number | null;
  mean?: string | null;
  stddev?: number | null;
}
function toFieldStats(root: jsonP.JSONValue): FieldStats {
  return jsonP.readObj({
    required: {},
    optional: {
      "min": "s",
      "max": "s",
      "count": "n",
      "missing": "n",
      "sum": "n",
      "sumOfSquares": "n",
      "mean": "s",
      "stddev": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SuggestStatus {
  timems?: number | null;
  rid?: string | null;
}
function toSuggestStatus(root: jsonP.JSONValue): SuggestStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "timems": "n",
      "rid": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SuggestModel {
  query?: string | null;
  found?: number | null;
  suggestions?: SuggestionMatch[] | null;
}
function toSuggestModel(root: jsonP.JSONValue): SuggestModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "query": "s",
      "found": "n",
      "suggestions": [toSuggestionMatch],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SuggestionMatch {
  suggestion?: string | null;
  score?: number | null;
  id?: string | null;
}
function toSuggestionMatch(root: jsonP.JSONValue): SuggestionMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "suggestion": "s",
      "score": "n",
      "id": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DocumentServiceWarning {
  message?: string | null;
}
function toDocumentServiceWarning(root: jsonP.JSONValue): DocumentServiceWarning {
  return jsonP.readObj({
    required: {},
    optional: {
      "message": "s",
    },
  }, root);
}
