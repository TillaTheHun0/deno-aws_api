// Autogenerated API client for: Amazon CloudSearch

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class CloudSearch {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudSearch.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-01-01",
    "endpointPrefix": "cloudsearch",
    "protocol": "query",
    "serviceFullName": "Amazon CloudSearch",
    "serviceId": "CloudSearch",
    "signatureVersion": "v4",
    "uid": "cloudsearch-2013-01-01",
    "xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2013-01-01/"
  };

  async buildSuggesters(
    {abortSignal, ...params}: RequestConfig & s.BuildSuggestersRequest,
  ): Promise<s.BuildSuggestersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BuildSuggesters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "BuildSuggestersResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<s.CreateDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async defineAnalysisScheme(
    {abortSignal, ...params}: RequestConfig & s.DefineAnalysisSchemeRequest,
  ): Promise<s.DefineAnalysisSchemeResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    AnalysisScheme_Serialize(body, prefix+"AnalysisScheme", params["AnalysisScheme"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineAnalysisScheme",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineAnalysisSchemeResult");
    return {
      AnalysisScheme: xml.first("AnalysisScheme", true, AnalysisSchemeStatus_Parse),
    };
  }

  async defineExpression(
    {abortSignal, ...params}: RequestConfig & s.DefineExpressionRequest,
  ): Promise<s.DefineExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    Expression_Serialize(body, prefix+"Expression", params["Expression"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineExpression",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineExpressionResult");
    return {
      Expression: xml.first("Expression", true, ExpressionStatus_Parse),
    };
  }

  async defineIndexField(
    {abortSignal, ...params}: RequestConfig & s.DefineIndexFieldRequest,
  ): Promise<s.DefineIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    IndexField_Serialize(body, prefix+"IndexField", params["IndexField"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineIndexField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async defineSuggester(
    {abortSignal, ...params}: RequestConfig & s.DefineSuggesterRequest,
  ): Promise<s.DefineSuggesterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    Suggester_Serialize(body, prefix+"Suggester", params["Suggester"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineSuggester",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DefineSuggesterResult");
    return {
      Suggester: xml.first("Suggester", true, SuggesterStatus_Parse),
    };
  }

  async deleteAnalysisScheme(
    {abortSignal, ...params}: RequestConfig & s.DeleteAnalysisSchemeRequest,
  ): Promise<s.DeleteAnalysisSchemeResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AnalysisSchemeName", (params["AnalysisSchemeName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnalysisScheme",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteAnalysisSchemeResult");
    return {
      AnalysisScheme: xml.first("AnalysisScheme", true, AnalysisSchemeStatus_Parse),
    };
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<s.DeleteDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async deleteExpression(
    {abortSignal, ...params}: RequestConfig & s.DeleteExpressionRequest,
  ): Promise<s.DeleteExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ExpressionName", (params["ExpressionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteExpression",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteExpressionResult");
    return {
      Expression: xml.first("Expression", true, ExpressionStatus_Parse),
    };
  }

  async deleteIndexField(
    {abortSignal, ...params}: RequestConfig & s.DeleteIndexFieldRequest,
  ): Promise<s.DeleteIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIndexField",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async deleteSuggester(
    {abortSignal, ...params}: RequestConfig & s.DeleteSuggesterRequest,
  ): Promise<s.DeleteSuggesterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"SuggesterName", (params["SuggesterName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSuggester",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeleteSuggesterResult");
    return {
      Suggester: xml.first("Suggester", true, SuggesterStatus_Parse),
    };
  }

  async describeAnalysisSchemes(
    {abortSignal, ...params}: RequestConfig & s.DescribeAnalysisSchemesRequest,
  ): Promise<s.DescribeAnalysisSchemesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["AnalysisSchemeNames"]) qsP.appendList(body, prefix+"AnalysisSchemeNames", params["AnalysisSchemeNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAnalysisSchemes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAnalysisSchemesResult");
    return {
      AnalysisSchemes: xml.getList("AnalysisSchemes", "member").map(AnalysisSchemeStatus_Parse),
    };
  }

  async describeAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeAvailabilityOptionsRequest,
  ): Promise<s.DescribeAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async describeDomainEndpointOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainEndpointOptionsRequest,
  ): Promise<s.DescribeDomainEndpointOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomainEndpointOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDomainEndpointOptionsResult");
    return {
      DomainEndpointOptions: xml.first("DomainEndpointOptions", false, DomainEndpointOptionsStatus_Parse),
    };
  }

  async describeDomains(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainsRequest = {},
  ): Promise<s.DescribeDomainsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DomainNames"]) qsP.appendList(body, prefix+"DomainNames", params["DomainNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomains",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeDomainsResult");
    return {
      DomainStatusList: xml.getList("DomainStatusList", "member").map(DomainStatus_Parse),
    };
  }

  async describeExpressions(
    {abortSignal, ...params}: RequestConfig & s.DescribeExpressionsRequest,
  ): Promise<s.DescribeExpressionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["ExpressionNames"]) qsP.appendList(body, prefix+"ExpressionNames", params["ExpressionNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExpressions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeExpressionsResult");
    return {
      Expressions: xml.getList("Expressions", "member").map(ExpressionStatus_Parse),
    };
  }

  async describeIndexFields(
    {abortSignal, ...params}: RequestConfig & s.DescribeIndexFieldsRequest,
  ): Promise<s.DescribeIndexFieldsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["FieldNames"]) qsP.appendList(body, prefix+"FieldNames", params["FieldNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIndexFields",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeIndexFieldsResult");
    return {
      IndexFields: xml.getList("IndexFields", "member").map(IndexFieldStatus_Parse),
    };
  }

  async describeScalingParameters(
    {abortSignal, ...params}: RequestConfig & s.DescribeScalingParametersRequest,
  ): Promise<s.DescribeScalingParametersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeScalingParametersResult");
    return {
      ScalingParameters: xml.first("ScalingParameters", true, ScalingParametersStatus_Parse),
    };
  }

  async describeServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & s.DescribeServiceAccessPoliciesRequest,
  ): Promise<s.DescribeServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceAccessPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async describeSuggesters(
    {abortSignal, ...params}: RequestConfig & s.DescribeSuggestersRequest,
  ): Promise<s.DescribeSuggestersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["SuggesterNames"]) qsP.appendList(body, prefix+"SuggesterNames", params["SuggesterNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSuggesters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeSuggestersResult");
    return {
      Suggesters: xml.getList("Suggesters", "member").map(SuggesterStatus_Parse),
    };
  }

  async indexDocuments(
    {abortSignal, ...params}: RequestConfig & s.IndexDocumentsRequest,
  ): Promise<s.IndexDocumentsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IndexDocuments",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "IndexDocumentsResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async listDomainNames(
    {abortSignal}: RequestConfig = {},
  ): Promise<s.ListDomainNamesResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListDomainNames",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListDomainNamesResult");
    return {
      DomainNames: xmlP.readXmlMap(xml.getList("DomainNames", "entry"), x => x.content ?? '', {}),
    };
  }

  async updateAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateAvailabilityOptionsRequest,
  ): Promise<s.UpdateAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAvailabilityOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async updateDomainEndpointOptions(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainEndpointOptionsRequest,
  ): Promise<s.UpdateDomainEndpointOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    DomainEndpointOptions_Serialize(body, prefix+"DomainEndpointOptions", params["DomainEndpointOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainEndpointOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateDomainEndpointOptionsResult");
    return {
      DomainEndpointOptions: xml.first("DomainEndpointOptions", false, DomainEndpointOptionsStatus_Parse),
    };
  }

  async updateScalingParameters(
    {abortSignal, ...params}: RequestConfig & s.UpdateScalingParametersRequest,
  ): Promise<s.UpdateScalingParametersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    ScalingParameters_Serialize(body, prefix+"ScalingParameters", params["ScalingParameters"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateScalingParameters",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateScalingParametersResult");
    return {
      ScalingParameters: xml.first("ScalingParameters", true, ScalingParametersStatus_Parse),
    };
  }

  async updateServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & s.UpdateServiceAccessPoliciesRequest,
  ): Promise<s.UpdateServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AccessPolicies", (params["AccessPolicies"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceAccessPolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

}

function AnalysisScheme_Serialize(body: URLSearchParams, prefix: string, params: s.AnalysisScheme) {
    body.append(prefix+".AnalysisSchemeName", (params["AnalysisSchemeName"] ?? '').toString());
    body.append(prefix+".AnalysisSchemeLanguage", (params["AnalysisSchemeLanguage"] ?? '').toString());
    if (params["AnalysisOptions"] != null) AnalysisOptions_Serialize(body, prefix+".AnalysisOptions", params["AnalysisOptions"]);
}
function AnalysisScheme_Parse(node: xmlP.XmlNode): s.AnalysisScheme {
  return {
    ...node.strings({
      required: {"AnalysisSchemeName":true},
    }),
    AnalysisSchemeLanguage: node.first("AnalysisSchemeLanguage", true, x => (x.content ?? '') as s.AnalysisSchemeLanguage),
    AnalysisOptions: node.first("AnalysisOptions", false, AnalysisOptions_Parse),
  };
}

function AnalysisOptions_Serialize(body: URLSearchParams, prefix: string, params: s.AnalysisOptions) {
    if ("Synonyms" in params) body.append(prefix+".Synonyms", (params["Synonyms"] ?? '').toString());
    if ("Stopwords" in params) body.append(prefix+".Stopwords", (params["Stopwords"] ?? '').toString());
    if ("StemmingDictionary" in params) body.append(prefix+".StemmingDictionary", (params["StemmingDictionary"] ?? '').toString());
    if ("JapaneseTokenizationDictionary" in params) body.append(prefix+".JapaneseTokenizationDictionary", (params["JapaneseTokenizationDictionary"] ?? '').toString());
    if ("AlgorithmicStemming" in params) body.append(prefix+".AlgorithmicStemming", (params["AlgorithmicStemming"] ?? '').toString());
}
function AnalysisOptions_Parse(node: xmlP.XmlNode): s.AnalysisOptions {
  return {
    ...node.strings({
      optional: {"Synonyms":true,"Stopwords":true,"StemmingDictionary":true,"JapaneseTokenizationDictionary":true},
    }),
    AlgorithmicStemming: node.first("AlgorithmicStemming", false, x => (x.content ?? '') as s.AlgorithmicStemming),
  };
}

function Expression_Serialize(body: URLSearchParams, prefix: string, params: s.Expression) {
    body.append(prefix+".ExpressionName", (params["ExpressionName"] ?? '').toString());
    body.append(prefix+".ExpressionValue", (params["ExpressionValue"] ?? '').toString());
}
function Expression_Parse(node: xmlP.XmlNode): s.Expression {
  return node.strings({
    required: {"ExpressionName":true,"ExpressionValue":true},
  });
}

function IndexField_Serialize(body: URLSearchParams, prefix: string, params: s.IndexField) {
    body.append(prefix+".IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    body.append(prefix+".IndexFieldType", (params["IndexFieldType"] ?? '').toString());
    if (params["IntOptions"] != null) IntOptions_Serialize(body, prefix+".IntOptions", params["IntOptions"]);
    if (params["DoubleOptions"] != null) DoubleOptions_Serialize(body, prefix+".DoubleOptions", params["DoubleOptions"]);
    if (params["LiteralOptions"] != null) LiteralOptions_Serialize(body, prefix+".LiteralOptions", params["LiteralOptions"]);
    if (params["TextOptions"] != null) TextOptions_Serialize(body, prefix+".TextOptions", params["TextOptions"]);
    if (params["DateOptions"] != null) DateOptions_Serialize(body, prefix+".DateOptions", params["DateOptions"]);
    if (params["LatLonOptions"] != null) LatLonOptions_Serialize(body, prefix+".LatLonOptions", params["LatLonOptions"]);
    if (params["IntArrayOptions"] != null) IntArrayOptions_Serialize(body, prefix+".IntArrayOptions", params["IntArrayOptions"]);
    if (params["DoubleArrayOptions"] != null) DoubleArrayOptions_Serialize(body, prefix+".DoubleArrayOptions", params["DoubleArrayOptions"]);
    if (params["LiteralArrayOptions"] != null) LiteralArrayOptions_Serialize(body, prefix+".LiteralArrayOptions", params["LiteralArrayOptions"]);
    if (params["TextArrayOptions"] != null) TextArrayOptions_Serialize(body, prefix+".TextArrayOptions", params["TextArrayOptions"]);
    if (params["DateArrayOptions"] != null) DateArrayOptions_Serialize(body, prefix+".DateArrayOptions", params["DateArrayOptions"]);
}
function IndexField_Parse(node: xmlP.XmlNode): s.IndexField {
  return {
    ...node.strings({
      required: {"IndexFieldName":true},
    }),
    IndexFieldType: node.first("IndexFieldType", true, x => (x.content ?? '') as s.IndexFieldType),
    IntOptions: node.first("IntOptions", false, IntOptions_Parse),
    DoubleOptions: node.first("DoubleOptions", false, DoubleOptions_Parse),
    LiteralOptions: node.first("LiteralOptions", false, LiteralOptions_Parse),
    TextOptions: node.first("TextOptions", false, TextOptions_Parse),
    DateOptions: node.first("DateOptions", false, DateOptions_Parse),
    LatLonOptions: node.first("LatLonOptions", false, LatLonOptions_Parse),
    IntArrayOptions: node.first("IntArrayOptions", false, IntArrayOptions_Parse),
    DoubleArrayOptions: node.first("DoubleArrayOptions", false, DoubleArrayOptions_Parse),
    LiteralArrayOptions: node.first("LiteralArrayOptions", false, LiteralArrayOptions_Parse),
    TextArrayOptions: node.first("TextArrayOptions", false, TextArrayOptions_Parse),
    DateArrayOptions: node.first("DateArrayOptions", false, DateArrayOptions_Parse),
  };
}

function IntOptions_Serialize(body: URLSearchParams, prefix: string, params: s.IntOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function IntOptions_Parse(node: xmlP.XmlNode): s.IntOptions {
  return {
    ...node.strings({
      optional: {"SourceField":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

function DoubleOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DoubleOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function DoubleOptions_Parse(node: xmlP.XmlNode): s.DoubleOptions {
  return {
    ...node.strings({
      optional: {"SourceField":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseFloat(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

function LiteralOptions_Serialize(body: URLSearchParams, prefix: string, params: s.LiteralOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function LiteralOptions_Parse(node: xmlP.XmlNode): s.LiteralOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

function TextOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TextOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
    if ("HighlightEnabled" in params) body.append(prefix+".HighlightEnabled", (params["HighlightEnabled"] ?? '').toString());
    if ("AnalysisScheme" in params) body.append(prefix+".AnalysisScheme", (params["AnalysisScheme"] ?? '').toString());
}
function TextOptions_Parse(node: xmlP.XmlNode): s.TextOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true,"AnalysisScheme":true},
    }),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
    HighlightEnabled: node.first("HighlightEnabled", false, x => x.content === 'true'),
  };
}

function DateOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DateOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function DateOptions_Parse(node: xmlP.XmlNode): s.DateOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

function LatLonOptions_Serialize(body: URLSearchParams, prefix: string, params: s.LatLonOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function LatLonOptions_Parse(node: xmlP.XmlNode): s.LatLonOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

function IntArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.IntArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function IntArrayOptions_Parse(node: xmlP.XmlNode): s.IntArrayOptions {
  return {
    ...node.strings({
      optional: {"SourceFields":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

function DoubleArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DoubleArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function DoubleArrayOptions_Parse(node: xmlP.XmlNode): s.DoubleArrayOptions {
  return {
    ...node.strings({
      optional: {"SourceFields":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseFloat(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

function LiteralArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.LiteralArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function LiteralArrayOptions_Parse(node: xmlP.XmlNode): s.LiteralArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

function TextArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.TextArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("HighlightEnabled" in params) body.append(prefix+".HighlightEnabled", (params["HighlightEnabled"] ?? '').toString());
    if ("AnalysisScheme" in params) body.append(prefix+".AnalysisScheme", (params["AnalysisScheme"] ?? '').toString());
}
function TextArrayOptions_Parse(node: xmlP.XmlNode): s.TextArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true,"AnalysisScheme":true},
    }),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    HighlightEnabled: node.first("HighlightEnabled", false, x => x.content === 'true'),
  };
}

function DateArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DateArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function DateArrayOptions_Parse(node: xmlP.XmlNode): s.DateArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

function Suggester_Serialize(body: URLSearchParams, prefix: string, params: s.Suggester) {
    body.append(prefix+".SuggesterName", (params["SuggesterName"] ?? '').toString());
    DocumentSuggesterOptions_Serialize(body, prefix+".DocumentSuggesterOptions", params["DocumentSuggesterOptions"]);
}
function Suggester_Parse(node: xmlP.XmlNode): s.Suggester {
  return {
    ...node.strings({
      required: {"SuggesterName":true},
    }),
    DocumentSuggesterOptions: node.first("DocumentSuggesterOptions", true, DocumentSuggesterOptions_Parse),
  };
}

function DocumentSuggesterOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DocumentSuggesterOptions) {
    body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FuzzyMatching" in params) body.append(prefix+".FuzzyMatching", (params["FuzzyMatching"] ?? '').toString());
    if ("SortExpression" in params) body.append(prefix+".SortExpression", (params["SortExpression"] ?? '').toString());
}
function DocumentSuggesterOptions_Parse(node: xmlP.XmlNode): s.DocumentSuggesterOptions {
  return {
    ...node.strings({
      required: {"SourceField":true},
      optional: {"SortExpression":true},
    }),
    FuzzyMatching: node.first("FuzzyMatching", false, x => (x.content ?? '') as s.SuggesterFuzzyMatching),
  };
}

function DomainEndpointOptions_Serialize(body: URLSearchParams, prefix: string, params: s.DomainEndpointOptions) {
    if ("EnforceHTTPS" in params) body.append(prefix+".EnforceHTTPS", (params["EnforceHTTPS"] ?? '').toString());
    if ("TLSSecurityPolicy" in params) body.append(prefix+".TLSSecurityPolicy", (params["TLSSecurityPolicy"] ?? '').toString());
}
function DomainEndpointOptions_Parse(node: xmlP.XmlNode): s.DomainEndpointOptions {
  return {
    EnforceHTTPS: node.first("EnforceHTTPS", false, x => x.content === 'true'),
    TLSSecurityPolicy: node.first("TLSSecurityPolicy", false, x => (x.content ?? '') as s.TLSSecurityPolicy),
  };
}

function ScalingParameters_Serialize(body: URLSearchParams, prefix: string, params: s.ScalingParameters) {
    if ("DesiredInstanceType" in params) body.append(prefix+".DesiredInstanceType", (params["DesiredInstanceType"] ?? '').toString());
    if ("DesiredReplicationCount" in params) body.append(prefix+".DesiredReplicationCount", (params["DesiredReplicationCount"] ?? '').toString());
    if ("DesiredPartitionCount" in params) body.append(prefix+".DesiredPartitionCount", (params["DesiredPartitionCount"] ?? '').toString());
}
function ScalingParameters_Parse(node: xmlP.XmlNode): s.ScalingParameters {
  return {
    DesiredInstanceType: node.first("DesiredInstanceType", false, x => (x.content ?? '') as s.PartitionInstanceType),
    DesiredReplicationCount: node.first("DesiredReplicationCount", false, x => parseInt(x.content ?? '0')),
    DesiredPartitionCount: node.first("DesiredPartitionCount", false, x => parseInt(x.content ?? '0')),
  };
}

function DomainStatus_Parse(node: xmlP.XmlNode): s.DomainStatus {
  return {
    ...node.strings({
      required: {"DomainId":true,"DomainName":true},
      optional: {"ARN":true,"SearchInstanceType":true},
    }),
    Created: node.first("Created", false, x => x.content === 'true'),
    Deleted: node.first("Deleted", false, x => x.content === 'true'),
    DocService: node.first("DocService", false, ServiceEndpoint_Parse),
    SearchService: node.first("SearchService", false, ServiceEndpoint_Parse),
    RequiresIndexDocuments: node.first("RequiresIndexDocuments", true, x => x.content === 'true'),
    Processing: node.first("Processing", false, x => x.content === 'true'),
    SearchPartitionCount: node.first("SearchPartitionCount", false, x => parseInt(x.content ?? '0')),
    SearchInstanceCount: node.first("SearchInstanceCount", false, x => parseInt(x.content ?? '0')),
    Limits: node.first("Limits", false, Limits_Parse),
  };
}

function ServiceEndpoint_Parse(node: xmlP.XmlNode): s.ServiceEndpoint {
  return node.strings({
    optional: {"Endpoint":true},
  });
}

function Limits_Parse(node: xmlP.XmlNode): s.Limits {
  return {
    MaximumReplicationCount: node.first("MaximumReplicationCount", true, x => parseInt(x.content ?? '0')),
    MaximumPartitionCount: node.first("MaximumPartitionCount", true, x => parseInt(x.content ?? '0')),
  };
}

function AnalysisSchemeStatus_Parse(node: xmlP.XmlNode): s.AnalysisSchemeStatus {
  return {
    Options: node.first("Options", true, AnalysisScheme_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function OptionStatus_Parse(node: xmlP.XmlNode): s.OptionStatus {
  return {
    CreationDate: node.first("CreationDate", true, x => xmlP.parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", true, x => xmlP.parseTimestamp(x.content)),
    UpdateVersion: node.first("UpdateVersion", false, x => parseInt(x.content ?? '0')),
    State: node.first("State", true, x => (x.content ?? '') as s.OptionState),
    PendingDeletion: node.first("PendingDeletion", false, x => x.content === 'true'),
  };
}

function ExpressionStatus_Parse(node: xmlP.XmlNode): s.ExpressionStatus {
  return {
    Options: node.first("Options", true, Expression_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function IndexFieldStatus_Parse(node: xmlP.XmlNode): s.IndexFieldStatus {
  return {
    Options: node.first("Options", true, IndexField_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function SuggesterStatus_Parse(node: xmlP.XmlNode): s.SuggesterStatus {
  return {
    Options: node.first("Options", true, Suggester_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function AvailabilityOptionsStatus_Parse(node: xmlP.XmlNode): s.AvailabilityOptionsStatus {
  return {
    Options: node.first("Options", true, x => x.content === 'true'),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function DomainEndpointOptionsStatus_Parse(node: xmlP.XmlNode): s.DomainEndpointOptionsStatus {
  return {
    Options: node.first("Options", true, DomainEndpointOptions_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function ScalingParametersStatus_Parse(node: xmlP.XmlNode): s.ScalingParametersStatus {
  return {
    Options: node.first("Options", true, ScalingParameters_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

function AccessPoliciesStatus_Parse(node: xmlP.XmlNode): s.AccessPoliciesStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}
