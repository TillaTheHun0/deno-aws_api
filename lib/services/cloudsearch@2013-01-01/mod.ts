// Autogenerated API client for: Amazon CloudSearch

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { readXmlResult, readXmlMap, parseTimestamp, XmlNode } from '../../encoding/xml.ts';
import * as prt from "../../encoding/querystring.ts";

export default class CloudSearch {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudSearch.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2013-01-01",
    "endpointPrefix": "cloudsearch",
    "protocol": "query",
    "serviceFullName": "Amazon CloudSearch",
    "serviceId": "CloudSearch",
    "signatureVersion": "v4",
    "uid": "cloudsearch-2013-01-01",
    "xmlNamespace": "http://cloudsearch.amazonaws.com/doc/2013-01-01/"
  };

  async buildSuggesters(
    {abortSignal, ...params}: RequestConfig & BuildSuggestersRequest,
  ): Promise<BuildSuggestersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BuildSuggesters",
    });
    const xml = readXmlResult(await resp.text(), "BuildSuggestersResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & CreateDomainRequest,
  ): Promise<CreateDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    const xml = readXmlResult(await resp.text(), "CreateDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async defineAnalysisScheme(
    {abortSignal, ...params}: RequestConfig & DefineAnalysisSchemeRequest,
  ): Promise<DefineAnalysisSchemeResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    AnalysisScheme_Serialize(body, prefix+"AnalysisScheme", params["AnalysisScheme"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineAnalysisScheme",
    });
    const xml = readXmlResult(await resp.text(), "DefineAnalysisSchemeResult");
    return {
      AnalysisScheme: xml.first("AnalysisScheme", true, AnalysisSchemeStatus_Parse),
    };
  }

  async defineExpression(
    {abortSignal, ...params}: RequestConfig & DefineExpressionRequest,
  ): Promise<DefineExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    Expression_Serialize(body, prefix+"Expression", params["Expression"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineExpression",
    });
    const xml = readXmlResult(await resp.text(), "DefineExpressionResult");
    return {
      Expression: xml.first("Expression", true, ExpressionStatus_Parse),
    };
  }

  async defineIndexField(
    {abortSignal, ...params}: RequestConfig & DefineIndexFieldRequest,
  ): Promise<DefineIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    IndexField_Serialize(body, prefix+"IndexField", params["IndexField"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineIndexField",
    });
    const xml = readXmlResult(await resp.text(), "DefineIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async defineSuggester(
    {abortSignal, ...params}: RequestConfig & DefineSuggesterRequest,
  ): Promise<DefineSuggesterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    Suggester_Serialize(body, prefix+"Suggester", params["Suggester"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DefineSuggester",
    });
    const xml = readXmlResult(await resp.text(), "DefineSuggesterResult");
    return {
      Suggester: xml.first("Suggester", true, SuggesterStatus_Parse),
    };
  }

  async deleteAnalysisScheme(
    {abortSignal, ...params}: RequestConfig & DeleteAnalysisSchemeRequest,
  ): Promise<DeleteAnalysisSchemeResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AnalysisSchemeName", (params["AnalysisSchemeName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAnalysisScheme",
    });
    const xml = readXmlResult(await resp.text(), "DeleteAnalysisSchemeResult");
    return {
      AnalysisScheme: xml.first("AnalysisScheme", true, AnalysisSchemeStatus_Parse),
    };
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & DeleteDomainRequest,
  ): Promise<DeleteDomainResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
    const xml = readXmlResult(await resp.text(), "DeleteDomainResult");
    return {
      DomainStatus: xml.first("DomainStatus", false, DomainStatus_Parse),
    };
  }

  async deleteExpression(
    {abortSignal, ...params}: RequestConfig & DeleteExpressionRequest,
  ): Promise<DeleteExpressionResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"ExpressionName", (params["ExpressionName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteExpression",
    });
    const xml = readXmlResult(await resp.text(), "DeleteExpressionResult");
    return {
      Expression: xml.first("Expression", true, ExpressionStatus_Parse),
    };
  }

  async deleteIndexField(
    {abortSignal, ...params}: RequestConfig & DeleteIndexFieldRequest,
  ): Promise<DeleteIndexFieldResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIndexField",
    });
    const xml = readXmlResult(await resp.text(), "DeleteIndexFieldResult");
    return {
      IndexField: xml.first("IndexField", true, IndexFieldStatus_Parse),
    };
  }

  async deleteSuggester(
    {abortSignal, ...params}: RequestConfig & DeleteSuggesterRequest,
  ): Promise<DeleteSuggesterResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"SuggesterName", (params["SuggesterName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSuggester",
    });
    const xml = readXmlResult(await resp.text(), "DeleteSuggesterResult");
    return {
      Suggester: xml.first("Suggester", true, SuggesterStatus_Parse),
    };
  }

  async describeAnalysisSchemes(
    {abortSignal, ...params}: RequestConfig & DescribeAnalysisSchemesRequest,
  ): Promise<DescribeAnalysisSchemesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["AnalysisSchemeNames"]) prt.appendList(body, prefix+"AnalysisSchemeNames", params["AnalysisSchemeNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAnalysisSchemes",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAnalysisSchemesResult");
    return {
      AnalysisSchemes: xml.getList("AnalysisSchemes", "member").map(AnalysisSchemeStatus_Parse),
    };
  }

  async describeAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & DescribeAvailabilityOptionsRequest,
  ): Promise<DescribeAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAvailabilityOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async describeDomainEndpointOptions(
    {abortSignal, ...params}: RequestConfig & DescribeDomainEndpointOptionsRequest,
  ): Promise<DescribeDomainEndpointOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomainEndpointOptions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDomainEndpointOptionsResult");
    return {
      DomainEndpointOptions: xml.first("DomainEndpointOptions", false, DomainEndpointOptionsStatus_Parse),
    };
  }

  async describeDomains(
    {abortSignal, ...params}: RequestConfig & DescribeDomainsRequest = {},
  ): Promise<DescribeDomainsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["DomainNames"]) prt.appendList(body, prefix+"DomainNames", params["DomainNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomains",
    });
    const xml = readXmlResult(await resp.text(), "DescribeDomainsResult");
    return {
      DomainStatusList: xml.getList("DomainStatusList", "member").map(DomainStatus_Parse),
    };
  }

  async describeExpressions(
    {abortSignal, ...params}: RequestConfig & DescribeExpressionsRequest,
  ): Promise<DescribeExpressionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["ExpressionNames"]) prt.appendList(body, prefix+"ExpressionNames", params["ExpressionNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExpressions",
    });
    const xml = readXmlResult(await resp.text(), "DescribeExpressionsResult");
    return {
      Expressions: xml.getList("Expressions", "member").map(ExpressionStatus_Parse),
    };
  }

  async describeIndexFields(
    {abortSignal, ...params}: RequestConfig & DescribeIndexFieldsRequest,
  ): Promise<DescribeIndexFieldsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["FieldNames"]) prt.appendList(body, prefix+"FieldNames", params["FieldNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeIndexFields",
    });
    const xml = readXmlResult(await resp.text(), "DescribeIndexFieldsResult");
    return {
      IndexFields: xml.getList("IndexFields", "member").map(IndexFieldStatus_Parse),
    };
  }

  async describeScalingParameters(
    {abortSignal, ...params}: RequestConfig & DescribeScalingParametersRequest,
  ): Promise<DescribeScalingParametersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeScalingParameters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeScalingParametersResult");
    return {
      ScalingParameters: xml.first("ScalingParameters", true, ScalingParametersStatus_Parse),
    };
  }

  async describeServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & DescribeServiceAccessPoliciesRequest,
  ): Promise<DescribeServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeServiceAccessPolicies",
    });
    const xml = readXmlResult(await resp.text(), "DescribeServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

  async describeSuggesters(
    {abortSignal, ...params}: RequestConfig & DescribeSuggestersRequest,
  ): Promise<DescribeSuggestersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    if (params["SuggesterNames"]) prt.appendList(body, prefix+"SuggesterNames", params["SuggesterNames"], {"entryPrefix":".member."})
    if ("Deployed" in params) body.append(prefix+"Deployed", (params["Deployed"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSuggesters",
    });
    const xml = readXmlResult(await resp.text(), "DescribeSuggestersResult");
    return {
      Suggesters: xml.getList("Suggesters", "member").map(SuggesterStatus_Parse),
    };
  }

  async indexDocuments(
    {abortSignal, ...params}: RequestConfig & IndexDocumentsRequest,
  ): Promise<IndexDocumentsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "IndexDocuments",
    });
    const xml = readXmlResult(await resp.text(), "IndexDocumentsResult");
    return {
      FieldNames: xml.getList("FieldNames", "member").map(x => x.content ?? ''),
    };
  }

  async listDomainNames(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<ListDomainNamesResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListDomainNames",
    });
    const xml = readXmlResult(await resp.text(), "ListDomainNamesResult");
    return {
      DomainNames: readXmlMap(xml.getList("DomainNames", "entry"), x => x.content ?? '', {}),
    };
  }

  async updateAvailabilityOptions(
    {abortSignal, ...params}: RequestConfig & UpdateAvailabilityOptionsRequest,
  ): Promise<UpdateAvailabilityOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"MultiAZ", (params["MultiAZ"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAvailabilityOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateAvailabilityOptionsResult");
    return {
      AvailabilityOptions: xml.first("AvailabilityOptions", false, AvailabilityOptionsStatus_Parse),
    };
  }

  async updateDomainEndpointOptions(
    {abortSignal, ...params}: RequestConfig & UpdateDomainEndpointOptionsRequest,
  ): Promise<UpdateDomainEndpointOptionsResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    DomainEndpointOptions_Serialize(body, prefix+"DomainEndpointOptions", params["DomainEndpointOptions"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomainEndpointOptions",
    });
    const xml = readXmlResult(await resp.text(), "UpdateDomainEndpointOptionsResult");
    return {
      DomainEndpointOptions: xml.first("DomainEndpointOptions", false, DomainEndpointOptionsStatus_Parse),
    };
  }

  async updateScalingParameters(
    {abortSignal, ...params}: RequestConfig & UpdateScalingParametersRequest,
  ): Promise<UpdateScalingParametersResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    ScalingParameters_Serialize(body, prefix+"ScalingParameters", params["ScalingParameters"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateScalingParameters",
    });
    const xml = readXmlResult(await resp.text(), "UpdateScalingParametersResult");
    return {
      ScalingParameters: xml.first("ScalingParameters", true, ScalingParametersStatus_Parse),
    };
  }

  async updateServiceAccessPolicies(
    {abortSignal, ...params}: RequestConfig & UpdateServiceAccessPoliciesRequest,
  ): Promise<UpdateServiceAccessPoliciesResponse> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"DomainName", (params["DomainName"] ?? '').toString());
    body.append(prefix+"AccessPolicies", (params["AccessPolicies"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateServiceAccessPolicies",
    });
    const xml = readXmlResult(await resp.text(), "UpdateServiceAccessPoliciesResult");
    return {
      AccessPolicies: xml.first("AccessPolicies", true, AccessPoliciesStatus_Parse),
    };
  }

}

// refs: 1 - tags: named, input
export interface BuildSuggestersRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface CreateDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DefineAnalysisSchemeRequest {
  DomainName: string;
  AnalysisScheme: AnalysisScheme;
}

// refs: 1 - tags: named, input
export interface DefineExpressionRequest {
  DomainName: string;
  Expression: Expression;
}

// refs: 1 - tags: named, input
export interface DefineIndexFieldRequest {
  DomainName: string;
  IndexField: IndexField;
}

// refs: 1 - tags: named, input
export interface DefineSuggesterRequest {
  DomainName: string;
  Suggester: Suggester;
}

// refs: 1 - tags: named, input
export interface DeleteAnalysisSchemeRequest {
  DomainName: string;
  AnalysisSchemeName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDomainRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DeleteExpressionRequest {
  DomainName: string;
  ExpressionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteIndexFieldRequest {
  DomainName: string;
  IndexFieldName: string;
}

// refs: 1 - tags: named, input
export interface DeleteSuggesterRequest {
  DomainName: string;
  SuggesterName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAnalysisSchemesRequest {
  DomainName: string;
  AnalysisSchemeNames?: string[] | null;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeAvailabilityOptionsRequest {
  DomainName: string;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDomainEndpointOptionsRequest {
  DomainName: string;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeDomainsRequest {
  DomainNames?: string[] | null;
}

// refs: 1 - tags: named, input
export interface DescribeExpressionsRequest {
  DomainName: string;
  ExpressionNames?: string[] | null;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeIndexFieldsRequest {
  DomainName: string;
  FieldNames?: string[] | null;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeScalingParametersRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface DescribeServiceAccessPoliciesRequest {
  DomainName: string;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface DescribeSuggestersRequest {
  DomainName: string;
  SuggesterNames?: string[] | null;
  Deployed?: boolean | null;
}

// refs: 1 - tags: named, input
export interface IndexDocumentsRequest {
  DomainName: string;
}

// refs: 1 - tags: named, input
export interface UpdateAvailabilityOptionsRequest {
  DomainName: string;
  MultiAZ: boolean;
}

// refs: 1 - tags: named, input
export interface UpdateDomainEndpointOptionsRequest {
  DomainName: string;
  DomainEndpointOptions: DomainEndpointOptions;
}

// refs: 1 - tags: named, input
export interface UpdateScalingParametersRequest {
  DomainName: string;
  ScalingParameters: ScalingParameters;
}

// refs: 1 - tags: named, input
export interface UpdateServiceAccessPoliciesRequest {
  DomainName: string;
  AccessPolicies: string;
}

// refs: 1 - tags: named, output
export interface BuildSuggestersResponse {
  FieldNames: string[];
}

// refs: 1 - tags: named, output
export interface CreateDomainResponse {
  DomainStatus?: DomainStatus | null;
}

// refs: 1 - tags: named, output
export interface DefineAnalysisSchemeResponse {
  AnalysisScheme: AnalysisSchemeStatus;
}

// refs: 1 - tags: named, output
export interface DefineExpressionResponse {
  Expression: ExpressionStatus;
}

// refs: 1 - tags: named, output
export interface DefineIndexFieldResponse {
  IndexField: IndexFieldStatus;
}

// refs: 1 - tags: named, output
export interface DefineSuggesterResponse {
  Suggester: SuggesterStatus;
}

// refs: 1 - tags: named, output
export interface DeleteAnalysisSchemeResponse {
  AnalysisScheme: AnalysisSchemeStatus;
}

// refs: 1 - tags: named, output
export interface DeleteDomainResponse {
  DomainStatus?: DomainStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteExpressionResponse {
  Expression: ExpressionStatus;
}

// refs: 1 - tags: named, output
export interface DeleteIndexFieldResponse {
  IndexField: IndexFieldStatus;
}

// refs: 1 - tags: named, output
export interface DeleteSuggesterResponse {
  Suggester: SuggesterStatus;
}

// refs: 1 - tags: named, output
export interface DescribeAnalysisSchemesResponse {
  AnalysisSchemes: AnalysisSchemeStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeAvailabilityOptionsResponse {
  AvailabilityOptions?: AvailabilityOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface DescribeDomainEndpointOptionsResponse {
  DomainEndpointOptions?: DomainEndpointOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface DescribeDomainsResponse {
  DomainStatusList: DomainStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeExpressionsResponse {
  Expressions: ExpressionStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeIndexFieldsResponse {
  IndexFields: IndexFieldStatus[];
}

// refs: 1 - tags: named, output
export interface DescribeScalingParametersResponse {
  ScalingParameters: ScalingParametersStatus;
}

// refs: 1 - tags: named, output
export interface DescribeServiceAccessPoliciesResponse {
  AccessPolicies: AccessPoliciesStatus;
}

// refs: 1 - tags: named, output
export interface DescribeSuggestersResponse {
  Suggesters: SuggesterStatus[];
}

// refs: 1 - tags: named, output
export interface IndexDocumentsResponse {
  FieldNames: string[];
}

// refs: 1 - tags: named, output
export interface ListDomainNamesResponse {
  DomainNames: { [key: string]: string };
}

// refs: 1 - tags: named, output
export interface UpdateAvailabilityOptionsResponse {
  AvailabilityOptions?: AvailabilityOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface UpdateDomainEndpointOptionsResponse {
  DomainEndpointOptions?: DomainEndpointOptionsStatus | null;
}

// refs: 1 - tags: named, output
export interface UpdateScalingParametersResponse {
  ScalingParameters: ScalingParametersStatus;
}

// refs: 1 - tags: named, output
export interface UpdateServiceAccessPoliciesResponse {
  AccessPolicies: AccessPoliciesStatus;
}

// refs: 4 - tags: input, named, interface, output
export interface AnalysisScheme {
  AnalysisSchemeName: string;
  AnalysisSchemeLanguage: AnalysisSchemeLanguage;
  AnalysisOptions?: AnalysisOptions | null;
}
function AnalysisScheme_Serialize(body: URLSearchParams, prefix: string, params: AnalysisScheme) {
    body.append(prefix+".AnalysisSchemeName", (params["AnalysisSchemeName"] ?? '').toString());
    body.append(prefix+".AnalysisSchemeLanguage", (params["AnalysisSchemeLanguage"] ?? '').toString());
    if (params["AnalysisOptions"] != null) AnalysisOptions_Serialize(body, prefix+".AnalysisOptions", params["AnalysisOptions"]);
}
function AnalysisScheme_Parse(node: XmlNode): AnalysisScheme {
  return {
    ...node.strings({
      required: {"AnalysisSchemeName":true},
    }),
    AnalysisSchemeLanguage: node.first("AnalysisSchemeLanguage", true, x => (x.content ?? '') as AnalysisSchemeLanguage),
    AnalysisOptions: node.first("AnalysisOptions", false, AnalysisOptions_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type AnalysisSchemeLanguage =
| "ar"
| "bg"
| "ca"
| "cs"
| "da"
| "de"
| "el"
| "en"
| "es"
| "eu"
| "fa"
| "fi"
| "fr"
| "ga"
| "gl"
| "he"
| "hi"
| "hu"
| "hy"
| "id"
| "it"
| "ja"
| "ko"
| "lv"
| "mul"
| "nl"
| "no"
| "pt"
| "ro"
| "ru"
| "sv"
| "th"
| "tr"
| "zh-Hans"
| "zh-Hant"
;



// refs: 4 - tags: input, named, interface, output
export interface AnalysisOptions {
  Synonyms?: string | null;
  Stopwords?: string | null;
  StemmingDictionary?: string | null;
  JapaneseTokenizationDictionary?: string | null;
  AlgorithmicStemming?: AlgorithmicStemming | null;
}
function AnalysisOptions_Serialize(body: URLSearchParams, prefix: string, params: AnalysisOptions) {
    if ("Synonyms" in params) body.append(prefix+".Synonyms", (params["Synonyms"] ?? '').toString());
    if ("Stopwords" in params) body.append(prefix+".Stopwords", (params["Stopwords"] ?? '').toString());
    if ("StemmingDictionary" in params) body.append(prefix+".StemmingDictionary", (params["StemmingDictionary"] ?? '').toString());
    if ("JapaneseTokenizationDictionary" in params) body.append(prefix+".JapaneseTokenizationDictionary", (params["JapaneseTokenizationDictionary"] ?? '').toString());
    if ("AlgorithmicStemming" in params) body.append(prefix+".AlgorithmicStemming", (params["AlgorithmicStemming"] ?? '').toString());
}
function AnalysisOptions_Parse(node: XmlNode): AnalysisOptions {
  return {
    ...node.strings({
      optional: {"Synonyms":true,"Stopwords":true,"StemmingDictionary":true,"JapaneseTokenizationDictionary":true},
    }),
    AlgorithmicStemming: node.first("AlgorithmicStemming", false, x => (x.content ?? '') as AlgorithmicStemming),
  };
}

// refs: 4 - tags: input, named, enum, output
export type AlgorithmicStemming =
| "none"
| "minimal"
| "light"
| "full"
;



// refs: 4 - tags: input, named, interface, output
export interface Expression {
  ExpressionName: string;
  ExpressionValue: string;
}
function Expression_Serialize(body: URLSearchParams, prefix: string, params: Expression) {
    body.append(prefix+".ExpressionName", (params["ExpressionName"] ?? '').toString());
    body.append(prefix+".ExpressionValue", (params["ExpressionValue"] ?? '').toString());
}
function Expression_Parse(node: XmlNode): Expression {
  return node.strings({
    required: {"ExpressionName":true,"ExpressionValue":true},
  });
}

// refs: 4 - tags: input, named, interface, output
export interface IndexField {
  IndexFieldName: string;
  IndexFieldType: IndexFieldType;
  IntOptions?: IntOptions | null;
  DoubleOptions?: DoubleOptions | null;
  LiteralOptions?: LiteralOptions | null;
  TextOptions?: TextOptions | null;
  DateOptions?: DateOptions | null;
  LatLonOptions?: LatLonOptions | null;
  IntArrayOptions?: IntArrayOptions | null;
  DoubleArrayOptions?: DoubleArrayOptions | null;
  LiteralArrayOptions?: LiteralArrayOptions | null;
  TextArrayOptions?: TextArrayOptions | null;
  DateArrayOptions?: DateArrayOptions | null;
}
function IndexField_Serialize(body: URLSearchParams, prefix: string, params: IndexField) {
    body.append(prefix+".IndexFieldName", (params["IndexFieldName"] ?? '').toString());
    body.append(prefix+".IndexFieldType", (params["IndexFieldType"] ?? '').toString());
    if (params["IntOptions"] != null) IntOptions_Serialize(body, prefix+".IntOptions", params["IntOptions"]);
    if (params["DoubleOptions"] != null) DoubleOptions_Serialize(body, prefix+".DoubleOptions", params["DoubleOptions"]);
    if (params["LiteralOptions"] != null) LiteralOptions_Serialize(body, prefix+".LiteralOptions", params["LiteralOptions"]);
    if (params["TextOptions"] != null) TextOptions_Serialize(body, prefix+".TextOptions", params["TextOptions"]);
    if (params["DateOptions"] != null) DateOptions_Serialize(body, prefix+".DateOptions", params["DateOptions"]);
    if (params["LatLonOptions"] != null) LatLonOptions_Serialize(body, prefix+".LatLonOptions", params["LatLonOptions"]);
    if (params["IntArrayOptions"] != null) IntArrayOptions_Serialize(body, prefix+".IntArrayOptions", params["IntArrayOptions"]);
    if (params["DoubleArrayOptions"] != null) DoubleArrayOptions_Serialize(body, prefix+".DoubleArrayOptions", params["DoubleArrayOptions"]);
    if (params["LiteralArrayOptions"] != null) LiteralArrayOptions_Serialize(body, prefix+".LiteralArrayOptions", params["LiteralArrayOptions"]);
    if (params["TextArrayOptions"] != null) TextArrayOptions_Serialize(body, prefix+".TextArrayOptions", params["TextArrayOptions"]);
    if (params["DateArrayOptions"] != null) DateArrayOptions_Serialize(body, prefix+".DateArrayOptions", params["DateArrayOptions"]);
}
function IndexField_Parse(node: XmlNode): IndexField {
  return {
    ...node.strings({
      required: {"IndexFieldName":true},
    }),
    IndexFieldType: node.first("IndexFieldType", true, x => (x.content ?? '') as IndexFieldType),
    IntOptions: node.first("IntOptions", false, IntOptions_Parse),
    DoubleOptions: node.first("DoubleOptions", false, DoubleOptions_Parse),
    LiteralOptions: node.first("LiteralOptions", false, LiteralOptions_Parse),
    TextOptions: node.first("TextOptions", false, TextOptions_Parse),
    DateOptions: node.first("DateOptions", false, DateOptions_Parse),
    LatLonOptions: node.first("LatLonOptions", false, LatLonOptions_Parse),
    IntArrayOptions: node.first("IntArrayOptions", false, IntArrayOptions_Parse),
    DoubleArrayOptions: node.first("DoubleArrayOptions", false, DoubleArrayOptions_Parse),
    LiteralArrayOptions: node.first("LiteralArrayOptions", false, LiteralArrayOptions_Parse),
    TextArrayOptions: node.first("TextArrayOptions", false, TextArrayOptions_Parse),
    DateArrayOptions: node.first("DateArrayOptions", false, DateArrayOptions_Parse),
  };
}

// refs: 4 - tags: input, named, enum, output
export type IndexFieldType =
| "int"
| "double"
| "literal"
| "text"
| "date"
| "latlon"
| "int-array"
| "double-array"
| "literal-array"
| "text-array"
| "date-array"
;



// refs: 4 - tags: input, named, interface, output
export interface IntOptions {
  DefaultValue?: number | null;
  SourceField?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
}
function IntOptions_Serialize(body: URLSearchParams, prefix: string, params: IntOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function IntOptions_Parse(node: XmlNode): IntOptions {
  return {
    ...node.strings({
      optional: {"SourceField":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface DoubleOptions {
  DefaultValue?: number | null;
  SourceField?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
}
function DoubleOptions_Serialize(body: URLSearchParams, prefix: string, params: DoubleOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function DoubleOptions_Parse(node: XmlNode): DoubleOptions {
  return {
    ...node.strings({
      optional: {"SourceField":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseFloat(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface LiteralOptions {
  DefaultValue?: string | null;
  SourceField?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
}
function LiteralOptions_Serialize(body: URLSearchParams, prefix: string, params: LiteralOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function LiteralOptions_Parse(node: XmlNode): LiteralOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface TextOptions {
  DefaultValue?: string | null;
  SourceField?: string | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
  HighlightEnabled?: boolean | null;
  AnalysisScheme?: string | null;
}
function TextOptions_Serialize(body: URLSearchParams, prefix: string, params: TextOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
    if ("HighlightEnabled" in params) body.append(prefix+".HighlightEnabled", (params["HighlightEnabled"] ?? '').toString());
    if ("AnalysisScheme" in params) body.append(prefix+".AnalysisScheme", (params["AnalysisScheme"] ?? '').toString());
}
function TextOptions_Parse(node: XmlNode): TextOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true,"AnalysisScheme":true},
    }),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
    HighlightEnabled: node.first("HighlightEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface DateOptions {
  DefaultValue?: string | null;
  SourceField?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
}
function DateOptions_Serialize(body: URLSearchParams, prefix: string, params: DateOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function DateOptions_Parse(node: XmlNode): DateOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface LatLonOptions {
  DefaultValue?: string | null;
  SourceField?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
  SortEnabled?: boolean | null;
}
function LatLonOptions_Serialize(body: URLSearchParams, prefix: string, params: LatLonOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceField" in params) body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("SortEnabled" in params) body.append(prefix+".SortEnabled", (params["SortEnabled"] ?? '').toString());
}
function LatLonOptions_Parse(node: XmlNode): LatLonOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceField":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    SortEnabled: node.first("SortEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface IntArrayOptions {
  DefaultValue?: number | null;
  SourceFields?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
}
function IntArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: IntArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function IntArrayOptions_Parse(node: XmlNode): IntArrayOptions {
  return {
    ...node.strings({
      optional: {"SourceFields":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseInt(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface DoubleArrayOptions {
  DefaultValue?: number | null;
  SourceFields?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
}
function DoubleArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: DoubleArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function DoubleArrayOptions_Parse(node: XmlNode): DoubleArrayOptions {
  return {
    ...node.strings({
      optional: {"SourceFields":true},
    }),
    DefaultValue: node.first("DefaultValue", false, x => parseFloat(x.content ?? '0')),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface LiteralArrayOptions {
  DefaultValue?: string | null;
  SourceFields?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
}
function LiteralArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: LiteralArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function LiteralArrayOptions_Parse(node: XmlNode): LiteralArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface TextArrayOptions {
  DefaultValue?: string | null;
  SourceFields?: string | null;
  ReturnEnabled?: boolean | null;
  HighlightEnabled?: boolean | null;
  AnalysisScheme?: string | null;
}
function TextArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: TextArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
    if ("HighlightEnabled" in params) body.append(prefix+".HighlightEnabled", (params["HighlightEnabled"] ?? '').toString());
    if ("AnalysisScheme" in params) body.append(prefix+".AnalysisScheme", (params["AnalysisScheme"] ?? '').toString());
}
function TextArrayOptions_Parse(node: XmlNode): TextArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true,"AnalysisScheme":true},
    }),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
    HighlightEnabled: node.first("HighlightEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface DateArrayOptions {
  DefaultValue?: string | null;
  SourceFields?: string | null;
  FacetEnabled?: boolean | null;
  SearchEnabled?: boolean | null;
  ReturnEnabled?: boolean | null;
}
function DateArrayOptions_Serialize(body: URLSearchParams, prefix: string, params: DateArrayOptions) {
    if ("DefaultValue" in params) body.append(prefix+".DefaultValue", (params["DefaultValue"] ?? '').toString());
    if ("SourceFields" in params) body.append(prefix+".SourceFields", (params["SourceFields"] ?? '').toString());
    if ("FacetEnabled" in params) body.append(prefix+".FacetEnabled", (params["FacetEnabled"] ?? '').toString());
    if ("SearchEnabled" in params) body.append(prefix+".SearchEnabled", (params["SearchEnabled"] ?? '').toString());
    if ("ReturnEnabled" in params) body.append(prefix+".ReturnEnabled", (params["ReturnEnabled"] ?? '').toString());
}
function DateArrayOptions_Parse(node: XmlNode): DateArrayOptions {
  return {
    ...node.strings({
      optional: {"DefaultValue":true,"SourceFields":true},
    }),
    FacetEnabled: node.first("FacetEnabled", false, x => x.content === 'true'),
    SearchEnabled: node.first("SearchEnabled", false, x => x.content === 'true'),
    ReturnEnabled: node.first("ReturnEnabled", false, x => x.content === 'true'),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface Suggester {
  SuggesterName: string;
  DocumentSuggesterOptions: DocumentSuggesterOptions;
}
function Suggester_Serialize(body: URLSearchParams, prefix: string, params: Suggester) {
    body.append(prefix+".SuggesterName", (params["SuggesterName"] ?? '').toString());
    DocumentSuggesterOptions_Serialize(body, prefix+".DocumentSuggesterOptions", params["DocumentSuggesterOptions"]);
}
function Suggester_Parse(node: XmlNode): Suggester {
  return {
    ...node.strings({
      required: {"SuggesterName":true},
    }),
    DocumentSuggesterOptions: node.first("DocumentSuggesterOptions", true, DocumentSuggesterOptions_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface DocumentSuggesterOptions {
  SourceField: string;
  FuzzyMatching?: SuggesterFuzzyMatching | null;
  SortExpression?: string | null;
}
function DocumentSuggesterOptions_Serialize(body: URLSearchParams, prefix: string, params: DocumentSuggesterOptions) {
    body.append(prefix+".SourceField", (params["SourceField"] ?? '').toString());
    if ("FuzzyMatching" in params) body.append(prefix+".FuzzyMatching", (params["FuzzyMatching"] ?? '').toString());
    if ("SortExpression" in params) body.append(prefix+".SortExpression", (params["SortExpression"] ?? '').toString());
}
function DocumentSuggesterOptions_Parse(node: XmlNode): DocumentSuggesterOptions {
  return {
    ...node.strings({
      required: {"SourceField":true},
      optional: {"SortExpression":true},
    }),
    FuzzyMatching: node.first("FuzzyMatching", false, x => (x.content ?? '') as SuggesterFuzzyMatching),
  };
}

// refs: 4 - tags: input, named, enum, output
export type SuggesterFuzzyMatching =
| "none"
| "low"
| "high"
;



// refs: 3 - tags: input, named, interface, output
export interface DomainEndpointOptions {
  EnforceHTTPS?: boolean | null;
  TLSSecurityPolicy?: TLSSecurityPolicy | null;
}
function DomainEndpointOptions_Serialize(body: URLSearchParams, prefix: string, params: DomainEndpointOptions) {
    if ("EnforceHTTPS" in params) body.append(prefix+".EnforceHTTPS", (params["EnforceHTTPS"] ?? '').toString());
    if ("TLSSecurityPolicy" in params) body.append(prefix+".TLSSecurityPolicy", (params["TLSSecurityPolicy"] ?? '').toString());
}
function DomainEndpointOptions_Parse(node: XmlNode): DomainEndpointOptions {
  return {
    EnforceHTTPS: node.first("EnforceHTTPS", false, x => x.content === 'true'),
    TLSSecurityPolicy: node.first("TLSSecurityPolicy", false, x => (x.content ?? '') as TLSSecurityPolicy),
  };
}

// refs: 3 - tags: input, named, enum, output
export type TLSSecurityPolicy =
| "Policy-Min-TLS-1-0-2019-07"
| "Policy-Min-TLS-1-2-2019-07"
;



// refs: 3 - tags: input, named, interface, output
export interface ScalingParameters {
  DesiredInstanceType?: PartitionInstanceType | null;
  DesiredReplicationCount?: number | null;
  DesiredPartitionCount?: number | null;
}
function ScalingParameters_Serialize(body: URLSearchParams, prefix: string, params: ScalingParameters) {
    if ("DesiredInstanceType" in params) body.append(prefix+".DesiredInstanceType", (params["DesiredInstanceType"] ?? '').toString());
    if ("DesiredReplicationCount" in params) body.append(prefix+".DesiredReplicationCount", (params["DesiredReplicationCount"] ?? '').toString());
    if ("DesiredPartitionCount" in params) body.append(prefix+".DesiredPartitionCount", (params["DesiredPartitionCount"] ?? '').toString());
}
function ScalingParameters_Parse(node: XmlNode): ScalingParameters {
  return {
    DesiredInstanceType: node.first("DesiredInstanceType", false, x => (x.content ?? '') as PartitionInstanceType),
    DesiredReplicationCount: node.first("DesiredReplicationCount", false, x => parseInt(x.content ?? '0')),
    DesiredPartitionCount: node.first("DesiredPartitionCount", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: input, named, enum, output
export type PartitionInstanceType =
| "search.m1.small"
| "search.m1.large"
| "search.m2.xlarge"
| "search.m2.2xlarge"
| "search.m3.medium"
| "search.m3.large"
| "search.m3.xlarge"
| "search.m3.2xlarge"
;



// refs: 3 - tags: output, named, interface
export interface DomainStatus {
  DomainId: string;
  DomainName: string;
  ARN?: string | null;
  Created?: boolean | null;
  Deleted?: boolean | null;
  DocService?: ServiceEndpoint | null;
  SearchService?: ServiceEndpoint | null;
  RequiresIndexDocuments: boolean;
  Processing?: boolean | null;
  SearchInstanceType?: string | null;
  SearchPartitionCount?: number | null;
  SearchInstanceCount?: number | null;
  Limits?: Limits | null;
}
function DomainStatus_Parse(node: XmlNode): DomainStatus {
  return {
    ...node.strings({
      required: {"DomainId":true,"DomainName":true},
      optional: {"ARN":true,"SearchInstanceType":true},
    }),
    Created: node.first("Created", false, x => x.content === 'true'),
    Deleted: node.first("Deleted", false, x => x.content === 'true'),
    DocService: node.first("DocService", false, ServiceEndpoint_Parse),
    SearchService: node.first("SearchService", false, ServiceEndpoint_Parse),
    RequiresIndexDocuments: node.first("RequiresIndexDocuments", true, x => x.content === 'true'),
    Processing: node.first("Processing", false, x => x.content === 'true'),
    SearchPartitionCount: node.first("SearchPartitionCount", false, x => parseInt(x.content ?? '0')),
    SearchInstanceCount: node.first("SearchInstanceCount", false, x => parseInt(x.content ?? '0')),
    Limits: node.first("Limits", false, Limits_Parse),
  };
}

// refs: 6 - tags: output, named, interface
export interface ServiceEndpoint {
  Endpoint?: string | null;
}
function ServiceEndpoint_Parse(node: XmlNode): ServiceEndpoint {
  return node.strings({
    optional: {"Endpoint":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface Limits {
  MaximumReplicationCount: number;
  MaximumPartitionCount: number;
}
function Limits_Parse(node: XmlNode): Limits {
  return {
    MaximumReplicationCount: node.first("MaximumReplicationCount", true, x => parseInt(x.content ?? '0')),
    MaximumPartitionCount: node.first("MaximumPartitionCount", true, x => parseInt(x.content ?? '0')),
  };
}

// refs: 3 - tags: output, named, interface
export interface AnalysisSchemeStatus {
  Options: AnalysisScheme;
  Status: OptionStatus;
}
function AnalysisSchemeStatus_Parse(node: XmlNode): AnalysisSchemeStatus {
  return {
    Options: node.first("Options", true, AnalysisScheme_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 20 - tags: output, named, interface
export interface OptionStatus {
  CreationDate: Date | number;
  UpdateDate: Date | number;
  UpdateVersion?: number | null;
  State: OptionState;
  PendingDeletion?: boolean | null;
}
function OptionStatus_Parse(node: XmlNode): OptionStatus {
  return {
    CreationDate: node.first("CreationDate", true, x => parseTimestamp(x.content)),
    UpdateDate: node.first("UpdateDate", true, x => parseTimestamp(x.content)),
    UpdateVersion: node.first("UpdateVersion", false, x => parseInt(x.content ?? '0')),
    State: node.first("State", true, x => (x.content ?? '') as OptionState),
    PendingDeletion: node.first("PendingDeletion", false, x => x.content === 'true'),
  };
}

// refs: 20 - tags: output, named, enum
export type OptionState =
| "RequiresIndexDocuments"
| "Processing"
| "Active"
| "FailedToValidate"
;


// refs: 3 - tags: output, named, interface
export interface ExpressionStatus {
  Options: Expression;
  Status: OptionStatus;
}
function ExpressionStatus_Parse(node: XmlNode): ExpressionStatus {
  return {
    Options: node.first("Options", true, Expression_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface IndexFieldStatus {
  Options: IndexField;
  Status: OptionStatus;
}
function IndexFieldStatus_Parse(node: XmlNode): IndexFieldStatus {
  return {
    Options: node.first("Options", true, IndexField_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface SuggesterStatus {
  Options: Suggester;
  Status: OptionStatus;
}
function SuggesterStatus_Parse(node: XmlNode): SuggesterStatus {
  return {
    Options: node.first("Options", true, Suggester_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface AvailabilityOptionsStatus {
  Options: boolean;
  Status: OptionStatus;
}
function AvailabilityOptionsStatus_Parse(node: XmlNode): AvailabilityOptionsStatus {
  return {
    Options: node.first("Options", true, x => x.content === 'true'),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface DomainEndpointOptionsStatus {
  Options: DomainEndpointOptions;
  Status: OptionStatus;
}
function DomainEndpointOptionsStatus_Parse(node: XmlNode): DomainEndpointOptionsStatus {
  return {
    Options: node.first("Options", true, DomainEndpointOptions_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface ScalingParametersStatus {
  Options: ScalingParameters;
  Status: OptionStatus;
}
function ScalingParametersStatus_Parse(node: XmlNode): ScalingParametersStatus {
  return {
    Options: node.first("Options", true, ScalingParameters_Parse),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface AccessPoliciesStatus {
  Options: string;
  Status: OptionStatus;
}
function AccessPoliciesStatus_Parse(node: XmlNode): AccessPoliciesStatus {
  return {
    ...node.strings({
      required: {"Options":true},
    }),
    Status: node.first("Status", true, OptionStatus_Parse),
  };
}
