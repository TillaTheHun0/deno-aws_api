// Autogenerated API client for: AWS CodePipeline

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class CodePipeline {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodePipeline.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-07-09",
    "endpointPrefix": "codepipeline",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "CodePipeline",
    "serviceFullName": "AWS CodePipeline",
    "serviceId": "CodePipeline",
    "signatureVersion": "v4",
    "targetPrefix": "CodePipeline_20150709",
    "uid": "codepipeline-2015-07-09"
  };

  async acknowledgeJob(
    {abortSignal, ...params}: RequestConfig & s.AcknowledgeJobInput,
  ): Promise<s.AcknowledgeJobOutput> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      nonce: params["nonce"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcknowledgeJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async acknowledgeThirdPartyJob(
    {abortSignal, ...params}: RequestConfig & s.AcknowledgeThirdPartyJobInput,
  ): Promise<s.AcknowledgeThirdPartyJobOutput> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      nonce: params["nonce"],
      clientToken: params["clientToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AcknowledgeThirdPartyJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      },
    }, await resp.json());
  }

  async createCustomActionType(
    {abortSignal, ...params}: RequestConfig & s.CreateCustomActionTypeInput,
  ): Promise<s.CreateCustomActionTypeOutput> {
    const body: jsonP.JSONObject = {
      category: params["category"],
      provider: params["provider"],
      version: params["version"],
      settings: fromActionTypeSettings(params["settings"]),
      configurationProperties: params["configurationProperties"]?.map(x => fromActionConfigurationProperty(x)),
      inputArtifactDetails: fromArtifactDetails(params["inputArtifactDetails"]),
      outputArtifactDetails: fromArtifactDetails(params["outputArtifactDetails"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCustomActionType",
    });
    return jsonP.readObj({
      required: {
        "actionType": toActionType,
      },
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & s.CreatePipelineInput,
  ): Promise<s.CreatePipelineOutput> {
    const body: jsonP.JSONObject = {
      pipeline: fromPipelineDeclaration(params["pipeline"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipeline": toPipelineDeclaration,
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async deleteCustomActionType(
    {abortSignal, ...params}: RequestConfig & s.DeleteCustomActionTypeInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      category: params["category"],
      provider: params["provider"],
      version: params["version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCustomActionType",
    });
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeletePipelineInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePipeline",
    });
  }

  async deleteWebhook(
    {abortSignal, ...params}: RequestConfig & s.DeleteWebhookInput,
  ): Promise<s.DeleteWebhookOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deregisterWebhookWithThirdParty(
    {abortSignal, ...params}: RequestConfig & s.DeregisterWebhookWithThirdPartyInput = {},
  ): Promise<s.DeregisterWebhookWithThirdPartyOutput> {
    const body: jsonP.JSONObject = {
      webhookName: params["webhookName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterWebhookWithThirdParty",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disableStageTransition(
    {abortSignal, ...params}: RequestConfig & s.DisableStageTransitionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      stageName: params["stageName"],
      transitionType: params["transitionType"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableStageTransition",
    });
  }

  async enableStageTransition(
    {abortSignal, ...params}: RequestConfig & s.EnableStageTransitionInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      stageName: params["stageName"],
      transitionType: params["transitionType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableStageTransition",
    });
  }

  async getJobDetails(
    {abortSignal, ...params}: RequestConfig & s.GetJobDetailsInput,
  ): Promise<s.GetJobDetailsOutput> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobDetails": toJobDetails,
      },
    }, await resp.json());
  }

  async getPipeline(
    {abortSignal, ...params}: RequestConfig & s.GetPipelineInput,
  ): Promise<s.GetPipelineOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      version: params["version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipeline": toPipelineDeclaration,
        "metadata": toPipelineMetadata,
      },
    }, await resp.json());
  }

  async getPipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.GetPipelineExecutionInput,
  ): Promise<s.GetPipelineExecutionOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      pipelineExecutionId: params["pipelineExecutionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineExecution": toPipelineExecution,
      },
    }, await resp.json());
  }

  async getPipelineState(
    {abortSignal, ...params}: RequestConfig & s.GetPipelineStateInput,
  ): Promise<s.GetPipelineStateOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPipelineState",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineName": "s",
        "pipelineVersion": "n",
        "stageStates": [toStageState],
        "created": "d",
        "updated": "d",
      },
    }, await resp.json());
  }

  async getThirdPartyJobDetails(
    {abortSignal, ...params}: RequestConfig & s.GetThirdPartyJobDetailsInput,
  ): Promise<s.GetThirdPartyJobDetailsOutput> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      clientToken: params["clientToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetThirdPartyJobDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobDetails": toThirdPartyJobDetails,
      },
    }, await resp.json());
  }

  async listActionExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListActionExecutionsInput,
  ): Promise<s.ListActionExecutionsOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      filter: fromActionExecutionFilter(params["filter"]),
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListActionExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "actionExecutionDetails": [toActionExecutionDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listActionTypes(
    {abortSignal, ...params}: RequestConfig & s.ListActionTypesInput = {},
  ): Promise<s.ListActionTypesOutput> {
    const body: jsonP.JSONObject = {
      actionOwnerFilter: params["actionOwnerFilter"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListActionTypes",
    });
    return jsonP.readObj({
      required: {
        "actionTypes": [toActionType],
      },
      optional: {
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelineExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListPipelineExecutionsInput,
  ): Promise<s.ListPipelineExecutionsOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelineExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineExecutionSummaries": [toPipelineExecutionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & s.ListPipelinesInput = {},
  ): Promise<s.ListPipelinesOutput> {
    const body: jsonP.JSONObject = {
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelines": [toPipelineSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceInput,
  ): Promise<s.ListTagsForResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listWebhooks(
    {abortSignal, ...params}: RequestConfig & s.ListWebhooksInput = {},
  ): Promise<s.ListWebhooksOutput> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWebhooks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhooks": [toListWebhookItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async pollForJobs(
    {abortSignal, ...params}: RequestConfig & s.PollForJobsInput,
  ): Promise<s.PollForJobsOutput> {
    const body: jsonP.JSONObject = {
      actionTypeId: fromActionTypeId(params["actionTypeId"]),
      maxBatchSize: params["maxBatchSize"],
      queryParam: params["queryParam"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PollForJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toJob],
      },
    }, await resp.json());
  }

  async pollForThirdPartyJobs(
    {abortSignal, ...params}: RequestConfig & s.PollForThirdPartyJobsInput,
  ): Promise<s.PollForThirdPartyJobsOutput> {
    const body: jsonP.JSONObject = {
      actionTypeId: fromActionTypeId(params["actionTypeId"]),
      maxBatchSize: params["maxBatchSize"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PollForThirdPartyJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "jobs": [toThirdPartyJob],
      },
    }, await resp.json());
  }

  async putActionRevision(
    {abortSignal, ...params}: RequestConfig & s.PutActionRevisionInput,
  ): Promise<s.PutActionRevisionOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      stageName: params["stageName"],
      actionName: params["actionName"],
      actionRevision: fromActionRevision(params["actionRevision"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutActionRevision",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "newRevision": "b",
        "pipelineExecutionId": "s",
      },
    }, await resp.json());
  }

  async putApprovalResult(
    {abortSignal, ...params}: RequestConfig & s.PutApprovalResultInput,
  ): Promise<s.PutApprovalResultOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      stageName: params["stageName"],
      actionName: params["actionName"],
      result: fromApprovalResult(params["result"]),
      token: params["token"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutApprovalResult",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "approvedAt": "d",
      },
    }, await resp.json());
  }

  async putJobFailureResult(
    {abortSignal, ...params}: RequestConfig & s.PutJobFailureResultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      failureDetails: fromFailureDetails(params["failureDetails"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutJobFailureResult",
    });
  }

  async putJobSuccessResult(
    {abortSignal, ...params}: RequestConfig & s.PutJobSuccessResultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      currentRevision: fromCurrentRevision(params["currentRevision"]),
      continuationToken: params["continuationToken"],
      executionDetails: fromExecutionDetails(params["executionDetails"]),
      outputVariables: params["outputVariables"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutJobSuccessResult",
    });
  }

  async putThirdPartyJobFailureResult(
    {abortSignal, ...params}: RequestConfig & s.PutThirdPartyJobFailureResultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      clientToken: params["clientToken"],
      failureDetails: fromFailureDetails(params["failureDetails"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutThirdPartyJobFailureResult",
    });
  }

  async putThirdPartyJobSuccessResult(
    {abortSignal, ...params}: RequestConfig & s.PutThirdPartyJobSuccessResultInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      jobId: params["jobId"],
      clientToken: params["clientToken"],
      currentRevision: fromCurrentRevision(params["currentRevision"]),
      continuationToken: params["continuationToken"],
      executionDetails: fromExecutionDetails(params["executionDetails"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutThirdPartyJobSuccessResult",
    });
  }

  async putWebhook(
    {abortSignal, ...params}: RequestConfig & s.PutWebhookInput,
  ): Promise<s.PutWebhookOutput> {
    const body: jsonP.JSONObject = {
      webhook: fromWebhookDefinition(params["webhook"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutWebhook",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "webhook": toListWebhookItem,
      },
    }, await resp.json());
  }

  async registerWebhookWithThirdParty(
    {abortSignal, ...params}: RequestConfig & s.RegisterWebhookWithThirdPartyInput = {},
  ): Promise<s.RegisterWebhookWithThirdPartyOutput> {
    const body: jsonP.JSONObject = {
      webhookName: params["webhookName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterWebhookWithThirdParty",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async retryStageExecution(
    {abortSignal, ...params}: RequestConfig & s.RetryStageExecutionInput,
  ): Promise<s.RetryStageExecutionOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      stageName: params["stageName"],
      pipelineExecutionId: params["pipelineExecutionId"],
      retryMode: params["retryMode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetryStageExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineExecutionId": "s",
      },
    }, await resp.json());
  }

  async startPipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.StartPipelineExecutionInput,
  ): Promise<s.StartPipelineExecutionOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      clientRequestToken: params["clientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineExecutionId": "s",
      },
    }, await resp.json());
  }

  async stopPipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.StopPipelineExecutionInput,
  ): Promise<s.StopPipelineExecutionOutput> {
    const body: jsonP.JSONObject = {
      pipelineName: params["pipelineName"],
      pipelineExecutionId: params["pipelineExecutionId"],
      abandon: params["abandon"],
      reason: params["reason"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopPipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineExecutionId": "s",
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceInput,
  ): Promise<s.TagResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceInput,
  ): Promise<s.UntagResourceOutput> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineInput,
  ): Promise<s.UpdatePipelineOutput> {
    const body: jsonP.JSONObject = {
      pipeline: fromPipelineDeclaration(params["pipeline"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipeline": toPipelineDeclaration,
      },
    }, await resp.json());
  }

}

function fromActionTypeSettings(input?: s.ActionTypeSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    thirdPartyConfigurationUrl: input["thirdPartyConfigurationUrl"],
    entityUrlTemplate: input["entityUrlTemplate"],
    executionUrlTemplate: input["executionUrlTemplate"],
    revisionUrlTemplate: input["revisionUrlTemplate"],
  }
}
function toActionTypeSettings(root: jsonP.JSONValue): s.ActionTypeSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "thirdPartyConfigurationUrl": "s",
      "entityUrlTemplate": "s",
      "executionUrlTemplate": "s",
      "revisionUrlTemplate": "s",
    },
  }, root);
}

function fromActionConfigurationProperty(input?: s.ActionConfigurationProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    required: input["required"],
    key: input["key"],
    secret: input["secret"],
    queryable: input["queryable"],
    description: input["description"],
    type: input["type"],
  }
}
function toActionConfigurationProperty(root: jsonP.JSONValue): s.ActionConfigurationProperty {
  return jsonP.readObj({
    required: {
      "name": "s",
      "required": "b",
      "key": "b",
      "secret": "b",
    },
    optional: {
      "queryable": "b",
      "description": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionConfigurationPropertyType>(x),
    },
  }, root);
}

function fromArtifactDetails(input?: s.ArtifactDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    minimumCount: input["minimumCount"],
    maximumCount: input["maximumCount"],
  }
}
function toArtifactDetails(root: jsonP.JSONValue): s.ArtifactDetails {
  return jsonP.readObj({
    required: {
      "minimumCount": "n",
      "maximumCount": "n",
    },
    optional: {},
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromPipelineDeclaration(input?: s.PipelineDeclaration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    roleArn: input["roleArn"],
    artifactStore: fromArtifactStore(input["artifactStore"]),
    artifactStores: jsonP.serializeMap(input["artifactStores"], x => fromArtifactStore(x)),
    stages: input["stages"]?.map(x => fromStageDeclaration(x)),
    version: input["version"],
  }
}
function toPipelineDeclaration(root: jsonP.JSONValue): s.PipelineDeclaration {
  return jsonP.readObj({
    required: {
      "name": "s",
      "roleArn": "s",
      "stages": [toStageDeclaration],
    },
    optional: {
      "artifactStore": toArtifactStore,
      "artifactStores": x => jsonP.readMap(String, toArtifactStore, x),
      "version": "n",
    },
  }, root);
}

function fromArtifactStore(input?: s.ArtifactStore | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    location: input["location"],
    encryptionKey: fromEncryptionKey(input["encryptionKey"]),
  }
}
function toArtifactStore(root: jsonP.JSONValue): s.ArtifactStore {
  return jsonP.readObj({
    required: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactStoreType>(x),
      "location": "s",
    },
    optional: {
      "encryptionKey": toEncryptionKey,
    },
  }, root);
}

function fromEncryptionKey(input?: s.EncryptionKey | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    type: input["type"],
  }
}
function toEncryptionKey(root: jsonP.JSONValue): s.EncryptionKey {
  return jsonP.readObj({
    required: {
      "id": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionKeyType>(x),
    },
    optional: {},
  }, root);
}

function fromStageDeclaration(input?: s.StageDeclaration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    blockers: input["blockers"]?.map(x => fromBlockerDeclaration(x)),
    actions: input["actions"]?.map(x => fromActionDeclaration(x)),
  }
}
function toStageDeclaration(root: jsonP.JSONValue): s.StageDeclaration {
  return jsonP.readObj({
    required: {
      "name": "s",
      "actions": [toActionDeclaration],
    },
    optional: {
      "blockers": [toBlockerDeclaration],
    },
  }, root);
}

function fromBlockerDeclaration(input?: s.BlockerDeclaration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    type: input["type"],
  }
}
function toBlockerDeclaration(root: jsonP.JSONValue): s.BlockerDeclaration {
  return jsonP.readObj({
    required: {
      "name": "s",
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.BlockerType>(x),
    },
    optional: {},
  }, root);
}

function fromActionDeclaration(input?: s.ActionDeclaration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    actionTypeId: fromActionTypeId(input["actionTypeId"]),
    runOrder: input["runOrder"],
    configuration: input["configuration"],
    outputArtifacts: input["outputArtifacts"]?.map(x => fromOutputArtifact(x)),
    inputArtifacts: input["inputArtifacts"]?.map(x => fromInputArtifact(x)),
    roleArn: input["roleArn"],
    region: input["region"],
    namespace: input["namespace"],
  }
}
function toActionDeclaration(root: jsonP.JSONValue): s.ActionDeclaration {
  return jsonP.readObj({
    required: {
      "name": "s",
      "actionTypeId": toActionTypeId,
    },
    optional: {
      "runOrder": "n",
      "configuration": x => jsonP.readMap(String, String, x),
      "outputArtifacts": [toOutputArtifact],
      "inputArtifacts": [toInputArtifact],
      "roleArn": "s",
      "region": "s",
      "namespace": "s",
    },
  }, root);
}

function fromActionTypeId(input?: s.ActionTypeId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    category: input["category"],
    owner: input["owner"],
    provider: input["provider"],
    version: input["version"],
  }
}
function toActionTypeId(root: jsonP.JSONValue): s.ActionTypeId {
  return jsonP.readObj({
    required: {
      "category": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionCategory>(x),
      "owner": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionOwner>(x),
      "provider": "s",
      "version": "s",
    },
    optional: {},
  }, root);
}

function fromOutputArtifact(input?: s.OutputArtifact | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toOutputArtifact(root: jsonP.JSONValue): s.OutputArtifact {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromInputArtifact(input?: s.InputArtifact | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
  }
}
function toInputArtifact(root: jsonP.JSONValue): s.InputArtifact {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {},
  }, root);
}

function fromActionExecutionFilter(input?: s.ActionExecutionFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    pipelineExecutionId: input["pipelineExecutionId"],
  }
}

function fromActionRevision(input?: s.ActionRevision | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    revisionId: input["revisionId"],
    revisionChangeId: input["revisionChangeId"],
    created: jsonP.serializeDate_unixTimestamp(input["created"]),
  }
}
function toActionRevision(root: jsonP.JSONValue): s.ActionRevision {
  return jsonP.readObj({
    required: {
      "revisionId": "s",
      "revisionChangeId": "s",
      "created": "d",
    },
    optional: {},
  }, root);
}

function fromApprovalResult(input?: s.ApprovalResult | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    summary: input["summary"],
    status: input["status"],
  }
}

function fromFailureDetails(input?: s.FailureDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    message: input["message"],
    externalExecutionId: input["externalExecutionId"],
  }
}

function fromCurrentRevision(input?: s.CurrentRevision | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    revision: input["revision"],
    changeIdentifier: input["changeIdentifier"],
    created: jsonP.serializeDate_unixTimestamp(input["created"]),
    revisionSummary: input["revisionSummary"],
  }
}

function fromExecutionDetails(input?: s.ExecutionDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    summary: input["summary"],
    externalExecutionId: input["externalExecutionId"],
    percentComplete: input["percentComplete"],
  }
}

function fromWebhookDefinition(input?: s.WebhookDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    targetPipeline: input["targetPipeline"],
    targetAction: input["targetAction"],
    filters: input["filters"]?.map(x => fromWebhookFilterRule(x)),
    authentication: input["authentication"],
    authenticationConfiguration: fromWebhookAuthConfiguration(input["authenticationConfiguration"]),
  }
}
function toWebhookDefinition(root: jsonP.JSONValue): s.WebhookDefinition {
  return jsonP.readObj({
    required: {
      "name": "s",
      "targetPipeline": "s",
      "targetAction": "s",
      "filters": [toWebhookFilterRule],
      "authentication": (x: jsonP.JSONValue) => cmnP.readEnum<s.WebhookAuthenticationType>(x),
      "authenticationConfiguration": toWebhookAuthConfiguration,
    },
    optional: {},
  }, root);
}

function fromWebhookFilterRule(input?: s.WebhookFilterRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    jsonPath: input["jsonPath"],
    matchEquals: input["matchEquals"],
  }
}
function toWebhookFilterRule(root: jsonP.JSONValue): s.WebhookFilterRule {
  return jsonP.readObj({
    required: {
      "jsonPath": "s",
    },
    optional: {
      "matchEquals": "s",
    },
  }, root);
}

function fromWebhookAuthConfiguration(input?: s.WebhookAuthConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AllowedIPRange: input["AllowedIPRange"],
    SecretToken: input["SecretToken"],
  }
}
function toWebhookAuthConfiguration(root: jsonP.JSONValue): s.WebhookAuthConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AllowedIPRange": "s",
      "SecretToken": "s",
    },
  }, root);
}

function toActionType(root: jsonP.JSONValue): s.ActionType {
  return jsonP.readObj({
    required: {
      "id": toActionTypeId,
      "inputArtifactDetails": toArtifactDetails,
      "outputArtifactDetails": toArtifactDetails,
    },
    optional: {
      "settings": toActionTypeSettings,
      "actionConfigurationProperties": [toActionConfigurationProperty],
    },
  }, root);
}

function toJobDetails(root: jsonP.JSONValue): s.JobDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "data": toJobData,
      "accountId": "s",
    },
  }, root);
}

function toJobData(root: jsonP.JSONValue): s.JobData {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionTypeId": toActionTypeId,
      "actionConfiguration": toActionConfiguration,
      "pipelineContext": toPipelineContext,
      "inputArtifacts": [toArtifact],
      "outputArtifacts": [toArtifact],
      "artifactCredentials": toAWSSessionCredentials,
      "continuationToken": "s",
      "encryptionKey": toEncryptionKey,
    },
  }, root);
}

function toActionConfiguration(root: jsonP.JSONValue): s.ActionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "configuration": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toPipelineContext(root: jsonP.JSONValue): s.PipelineContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineName": "s",
      "stage": toStageContext,
      "action": toActionContext,
      "pipelineArn": "s",
      "pipelineExecutionId": "s",
    },
  }, root);
}

function toStageContext(root: jsonP.JSONValue): s.StageContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
    },
  }, root);
}

function toActionContext(root: jsonP.JSONValue): s.ActionContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "actionExecutionId": "s",
    },
  }, root);
}

function toArtifact(root: jsonP.JSONValue): s.Artifact {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "revision": "s",
      "location": toArtifactLocation,
    },
  }, root);
}

function toArtifactLocation(root: jsonP.JSONValue): s.ArtifactLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactLocationType>(x),
      "s3Location": toS3ArtifactLocation,
    },
  }, root);
}

function toS3ArtifactLocation(root: jsonP.JSONValue): s.S3ArtifactLocation {
  return jsonP.readObj({
    required: {
      "bucketName": "s",
      "objectKey": "s",
    },
    optional: {},
  }, root);
}

function toAWSSessionCredentials(root: jsonP.JSONValue): s.AWSSessionCredentials {
  return jsonP.readObj({
    required: {
      "accessKeyId": "s",
      "secretAccessKey": "s",
      "sessionToken": "s",
    },
    optional: {},
  }, root);
}

function toPipelineMetadata(root: jsonP.JSONValue): s.PipelineMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineArn": "s",
      "created": "d",
      "updated": "d",
    },
  }, root);
}

function toPipelineExecution(root: jsonP.JSONValue): s.PipelineExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineName": "s",
      "pipelineVersion": "n",
      "pipelineExecutionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStatus>(x),
      "statusSummary": "s",
      "artifactRevisions": [toArtifactRevision],
    },
  }, root);
}

function toArtifactRevision(root: jsonP.JSONValue): s.ArtifactRevision {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "revisionId": "s",
      "revisionChangeIdentifier": "s",
      "revisionSummary": "s",
      "created": "d",
      "revisionUrl": "s",
    },
  }, root);
}

function toStageState(root: jsonP.JSONValue): s.StageState {
  return jsonP.readObj({
    required: {},
    optional: {
      "stageName": "s",
      "inboundExecution": toStageExecution,
      "inboundTransitionState": toTransitionState,
      "actionStates": [toActionState],
      "latestExecution": toStageExecution,
    },
  }, root);
}

function toStageExecution(root: jsonP.JSONValue): s.StageExecution {
  return jsonP.readObj({
    required: {
      "pipelineExecutionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.StageExecutionStatus>(x),
    },
    optional: {},
  }, root);
}

function toTransitionState(root: jsonP.JSONValue): s.TransitionState {
  return jsonP.readObj({
    required: {},
    optional: {
      "enabled": "b",
      "lastChangedBy": "s",
      "lastChangedAt": "d",
      "disabledReason": "s",
    },
  }, root);
}

function toActionState(root: jsonP.JSONValue): s.ActionState {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionName": "s",
      "currentRevision": toActionRevision,
      "latestExecution": toActionExecution,
      "entityUrl": "s",
      "revisionUrl": "s",
    },
  }, root);
}

function toActionExecution(root: jsonP.JSONValue): s.ActionExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionExecutionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionExecutionStatus>(x),
      "summary": "s",
      "lastStatusChange": "d",
      "token": "s",
      "lastUpdatedBy": "s",
      "externalExecutionId": "s",
      "externalExecutionUrl": "s",
      "percentComplete": "n",
      "errorDetails": toErrorDetails,
    },
  }, root);
}

function toErrorDetails(root: jsonP.JSONValue): s.ErrorDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "code": "s",
      "message": "s",
    },
  }, root);
}

function toThirdPartyJobDetails(root: jsonP.JSONValue): s.ThirdPartyJobDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "data": toThirdPartyJobData,
      "nonce": "s",
    },
  }, root);
}

function toThirdPartyJobData(root: jsonP.JSONValue): s.ThirdPartyJobData {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionTypeId": toActionTypeId,
      "actionConfiguration": toActionConfiguration,
      "pipelineContext": toPipelineContext,
      "inputArtifacts": [toArtifact],
      "outputArtifacts": [toArtifact],
      "artifactCredentials": toAWSSessionCredentials,
      "continuationToken": "s",
      "encryptionKey": toEncryptionKey,
    },
  }, root);
}

function toActionExecutionDetail(root: jsonP.JSONValue): s.ActionExecutionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineExecutionId": "s",
      "actionExecutionId": "s",
      "pipelineVersion": "n",
      "stageName": "s",
      "actionName": "s",
      "startTime": "d",
      "lastUpdateTime": "d",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionExecutionStatus>(x),
      "input": toActionExecutionInput,
      "output": toActionExecutionOutput,
    },
  }, root);
}

function toActionExecutionInput(root: jsonP.JSONValue): s.ActionExecutionInput {
  return jsonP.readObj({
    required: {},
    optional: {
      "actionTypeId": toActionTypeId,
      "configuration": x => jsonP.readMap(String, String, x),
      "resolvedConfiguration": x => jsonP.readMap(String, String, x),
      "roleArn": "s",
      "region": "s",
      "inputArtifacts": [toArtifactDetail],
      "namespace": "s",
    },
  }, root);
}

function toArtifactDetail(root: jsonP.JSONValue): s.ArtifactDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "s3location": toS3Location,
    },
  }, root);
}

function toS3Location(root: jsonP.JSONValue): s.S3Location {
  return jsonP.readObj({
    required: {},
    optional: {
      "bucket": "s",
      "key": "s",
    },
  }, root);
}

function toActionExecutionOutput(root: jsonP.JSONValue): s.ActionExecutionOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "outputArtifacts": [toArtifactDetail],
      "executionResult": toActionExecutionResult,
      "outputVariables": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toActionExecutionResult(root: jsonP.JSONValue): s.ActionExecutionResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "externalExecutionId": "s",
      "externalExecutionSummary": "s",
      "externalExecutionUrl": "s",
    },
  }, root);
}

function toPipelineExecutionSummary(root: jsonP.JSONValue): s.PipelineExecutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "pipelineExecutionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStatus>(x),
      "startTime": "d",
      "lastUpdateTime": "d",
      "sourceRevisions": [toSourceRevision],
      "trigger": toExecutionTrigger,
      "stopTrigger": toStopExecutionTrigger,
    },
  }, root);
}

function toSourceRevision(root: jsonP.JSONValue): s.SourceRevision {
  return jsonP.readObj({
    required: {
      "actionName": "s",
    },
    optional: {
      "revisionId": "s",
      "revisionSummary": "s",
      "revisionUrl": "s",
    },
  }, root);
}

function toExecutionTrigger(root: jsonP.JSONValue): s.ExecutionTrigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "triggerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TriggerType>(x),
      "triggerDetail": "s",
    },
  }, root);
}

function toStopExecutionTrigger(root: jsonP.JSONValue): s.StopExecutionTrigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "reason": "s",
    },
  }, root);
}

function toPipelineSummary(root: jsonP.JSONValue): s.PipelineSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "version": "n",
      "created": "d",
      "updated": "d",
    },
  }, root);
}

function toListWebhookItem(root: jsonP.JSONValue): s.ListWebhookItem {
  return jsonP.readObj({
    required: {
      "definition": toWebhookDefinition,
      "url": "s",
    },
    optional: {
      "errorMessage": "s",
      "errorCode": "s",
      "lastTriggered": "d",
      "arn": "s",
      "tags": [toTag],
    },
  }, root);
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "data": toJobData,
      "nonce": "s",
      "accountId": "s",
    },
  }, root);
}

function toThirdPartyJob(root: jsonP.JSONValue): s.ThirdPartyJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "clientId": "s",
      "jobId": "s",
    },
  }, root);
}
