// Autogenerated API client for: AWS Elastic Beanstalk

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as qsP from "../../encoding/querystring.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class ElasticBeanstalk {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ElasticBeanstalk.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2010-12-01",
    "endpointPrefix": "elasticbeanstalk",
    "protocol": "query",
    "serviceAbbreviation": "Elastic Beanstalk",
    "serviceFullName": "AWS Elastic Beanstalk",
    "serviceId": "Elastic Beanstalk",
    "signatureVersion": "v4",
    "uid": "elasticbeanstalk-2010-12-01",
    "xmlNamespace": "http://elasticbeanstalk.amazonaws.com/docs/2010-12-01/"
  };

  async abortEnvironmentUpdate(
    {abortSignal, ...params}: RequestConfig & s.AbortEnvironmentUpdateMessage = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AbortEnvironmentUpdate",
    });
  }

  async applyEnvironmentManagedAction(
    {abortSignal, ...params}: RequestConfig & s.ApplyEnvironmentManagedActionRequest,
  ): Promise<s.ApplyEnvironmentManagedActionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    body.append(prefix+"ActionId", (params["ActionId"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ApplyEnvironmentManagedAction",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ApplyEnvironmentManagedActionResult");
    return {
      ...xml.strings({
        optional: {"ActionId":true,"ActionDescription":true,"Status":true},
      }),
      ActionType: xml.first("ActionType", false, x => (x.content ?? '') as s.ActionType),
    };
  }

  async associateEnvironmentOperationsRole(
    {abortSignal, ...params}: RequestConfig & s.AssociateEnvironmentOperationsRoleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    body.append(prefix+"OperationsRole", (params["OperationsRole"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateEnvironmentOperationsRole",
    });
  }

  async checkDNSAvailability(
    {abortSignal, ...params}: RequestConfig & s.CheckDNSAvailabilityMessage,
  ): Promise<s.CheckDNSAvailabilityResultMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"CNAMEPrefix", (params["CNAMEPrefix"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CheckDNSAvailability",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CheckDNSAvailabilityResult");
    return {
      ...xml.strings({
        optional: {"FullyQualifiedCNAME":true},
      }),
      Available: xml.first("Available", false, x => x.content === 'true'),
    };
  }

  async composeEnvironments(
    {abortSignal, ...params}: RequestConfig & s.ComposeEnvironmentsMessage = {},
  ): Promise<s.EnvironmentDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if (params["VersionLabels"]) qsP.appendList(body, prefix+"VersionLabels", params["VersionLabels"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ComposeEnvironments",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ComposeEnvironmentsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Environments: xml.getList("Environments", "member").map(EnvironmentDescription_Parse),
    };
  }

  async createApplication(
    {abortSignal, ...params}: RequestConfig & s.CreateApplicationMessage,
  ): Promise<s.ApplicationDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["ResourceLifecycleConfig"] != null) ApplicationResourceLifecycleConfig_Serialize(body, prefix+"ResourceLifecycleConfig", params["ResourceLifecycleConfig"]);
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplication",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateApplicationResult");
    return {
      Application: xml.first("Application", false, ApplicationDescription_Parse),
    };
  }

  async createApplicationVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateApplicationVersionMessage,
  ): Promise<s.ApplicationVersionDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["SourceBuildInformation"] != null) SourceBuildInformation_Serialize(body, prefix+"SourceBuildInformation", params["SourceBuildInformation"]);
    if (params["SourceBundle"] != null) S3Location_Serialize(body, prefix+"SourceBundle", params["SourceBundle"]);
    if (params["BuildConfiguration"] != null) BuildConfiguration_Serialize(body, prefix+"BuildConfiguration", params["BuildConfiguration"]);
    if ("AutoCreateApplication" in params) body.append(prefix+"AutoCreateApplication", (params["AutoCreateApplication"] ?? '').toString());
    if ("Process" in params) body.append(prefix+"Process", (params["Process"] ?? '').toString());
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApplicationVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateApplicationVersionResult");
    return {
      ApplicationVersion: xml.first("ApplicationVersion", false, ApplicationVersionDescription_Parse),
    };
  }

  async createConfigurationTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateConfigurationTemplateMessage,
  ): Promise<s.ConfigurationSettingsDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("SolutionStackName" in params) body.append(prefix+"SolutionStackName", (params["SolutionStackName"] ?? '').toString());
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    if (params["SourceConfiguration"] != null) SourceConfiguration_Serialize(body, prefix+"SourceConfiguration", params["SourceConfiguration"]);
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConfigurationTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateConfigurationTemplateResult");
    return ConfigurationSettingsDescription_Parse(xml);
  }

  async createEnvironment(
    {abortSignal, ...params}: RequestConfig & s.CreateEnvironmentMessage,
  ): Promise<s.EnvironmentDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if ("CNAMEPrefix" in params) body.append(prefix+"CNAMEPrefix", (params["CNAMEPrefix"] ?? '').toString());
    if (params["Tier"] != null) EnvironmentTier_Serialize(body, prefix+"Tier", params["Tier"]);
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if ("VersionLabel" in params) body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("SolutionStackName" in params) body.append(prefix+"SolutionStackName", (params["SolutionStackName"] ?? '').toString());
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    if (params["OptionsToRemove"]) qsP.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"appender":OptionSpecification_Serialize,"entryPrefix":".member."})
    if ("OperationsRole" in params) body.append(prefix+"OperationsRole", (params["OperationsRole"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEnvironment",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateEnvironmentResult");
    return EnvironmentDescription_Parse(xml);
  }

  async createPlatformVersion(
    {abortSignal, ...params}: RequestConfig & s.CreatePlatformVersionRequest,
  ): Promise<s.CreatePlatformVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"PlatformName", (params["PlatformName"] ?? '').toString());
    body.append(prefix+"PlatformVersion", (params["PlatformVersion"] ?? '').toString());
    S3Location_Serialize(body, prefix+"PlatformDefinitionBundle", params["PlatformDefinitionBundle"]);
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    if (params["Tags"]) qsP.appendList(body, prefix+"Tags", params["Tags"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePlatformVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreatePlatformVersionResult");
    return {
      PlatformSummary: xml.first("PlatformSummary", false, PlatformSummary_Parse),
      Builder: xml.first("Builder", false, Builder_Parse),
    };
  }

  async createStorageLocation(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.CreateStorageLocationResultMessage> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "CreateStorageLocation",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "CreateStorageLocationResult");
    return xml.strings({
      optional: {"S3Bucket":true},
    });
  }

  async deleteApplication(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("TerminateEnvByForce" in params) body.append(prefix+"TerminateEnvByForce", (params["TerminateEnvByForce"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplication",
    });
  }

  async deleteApplicationVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteApplicationVersionMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("DeleteSourceBundle" in params) body.append(prefix+"DeleteSourceBundle", (params["DeleteSourceBundle"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApplicationVersion",
    });
  }

  async deleteConfigurationTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteConfigurationTemplateMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConfigurationTemplate",
    });
  }

  async deleteEnvironmentConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteEnvironmentConfigurationMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEnvironmentConfiguration",
    });
  }

  async deletePlatformVersion(
    {abortSignal, ...params}: RequestConfig & s.DeletePlatformVersionRequest = {},
  ): Promise<s.DeletePlatformVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePlatformVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DeletePlatformVersionResult");
    return {
      PlatformSummary: xml.first("PlatformSummary", false, PlatformSummary_Parse),
    };
  }

  async describeAccountAttributes(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.DescribeAccountAttributesResult> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeAccountAttributes",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeAccountAttributesResult");
    return {
      ResourceQuotas: xml.first("ResourceQuotas", false, ResourceQuotas_Parse),
    };
  }

  async describeApplicationVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeApplicationVersionsMessage = {},
  ): Promise<s.ApplicationVersionDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if (params["VersionLabels"]) qsP.appendList(body, prefix+"VersionLabels", params["VersionLabels"], {"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApplicationVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeApplicationVersionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ApplicationVersions: xml.getList("ApplicationVersions", "member").map(ApplicationVersionDescription_Parse),
    };
  }

  async describeApplications(
    {abortSignal, ...params}: RequestConfig & s.DescribeApplicationsMessage = {},
  ): Promise<s.ApplicationDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["ApplicationNames"]) qsP.appendList(body, prefix+"ApplicationNames", params["ApplicationNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApplications",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeApplicationsResult");
    return {
      Applications: xml.getList("Applications", "member").map(ApplicationDescription_Parse),
    };
  }

  async describeConfigurationOptions(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationOptionsMessage = {},
  ): Promise<s.ConfigurationOptionsDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("SolutionStackName" in params) body.append(prefix+"SolutionStackName", (params["SolutionStackName"] ?? '').toString());
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    if (params["Options"]) qsP.appendList(body, prefix+"Options", params["Options"], {"appender":OptionSpecification_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConfigurationOptions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeConfigurationOptionsResult");
    return {
      ...xml.strings({
        optional: {"SolutionStackName":true,"PlatformArn":true},
      }),
      Options: xml.getList("Options", "member").map(ConfigurationOptionDescription_Parse),
    };
  }

  async describeConfigurationSettings(
    {abortSignal, ...params}: RequestConfig & s.DescribeConfigurationSettingsMessage,
  ): Promise<s.ConfigurationSettingsDescriptions> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeConfigurationSettings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeConfigurationSettingsResult");
    return {
      ConfigurationSettings: xml.getList("ConfigurationSettings", "member").map(ConfigurationSettingsDescription_Parse),
    };
  }

  async describeEnvironmentHealth(
    {abortSignal, ...params}: RequestConfig & s.DescribeEnvironmentHealthRequest = {},
  ): Promise<s.DescribeEnvironmentHealthResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeNames", params["AttributeNames"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEnvironmentHealth",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEnvironmentHealthResult");
    return {
      ...xml.strings({
        optional: {"EnvironmentName":true,"HealthStatus":true,"Color":true},
      }),
      Status: xml.first("Status", false, x => (x.content ?? '') as s.EnvironmentHealth),
      Causes: xml.getList("Causes", "member").map(x => x.content ?? ''),
      ApplicationMetrics: xml.first("ApplicationMetrics", false, ApplicationMetrics_Parse),
      InstancesHealth: xml.first("InstancesHealth", false, InstanceHealthSummary_Parse),
      RefreshedAt: xml.first("RefreshedAt", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describeEnvironmentManagedActionHistory(
    {abortSignal, ...params}: RequestConfig & s.DescribeEnvironmentManagedActionHistoryRequest = {},
  ): Promise<s.DescribeEnvironmentManagedActionHistoryResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    if ("MaxItems" in params) body.append(prefix+"MaxItems", (params["MaxItems"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEnvironmentManagedActionHistory",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEnvironmentManagedActionHistoryResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      ManagedActionHistoryItems: xml.getList("ManagedActionHistoryItems", "member").map(ManagedActionHistoryItem_Parse),
    };
  }

  async describeEnvironmentManagedActions(
    {abortSignal, ...params}: RequestConfig & s.DescribeEnvironmentManagedActionsRequest = {},
  ): Promise<s.DescribeEnvironmentManagedActionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("Status" in params) body.append(prefix+"Status", (params["Status"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEnvironmentManagedActions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEnvironmentManagedActionsResult");
    return {
      ManagedActions: xml.getList("ManagedActions", "member").map(ManagedAction_Parse),
    };
  }

  async describeEnvironmentResources(
    {abortSignal, ...params}: RequestConfig & s.DescribeEnvironmentResourcesMessage = {},
  ): Promise<s.EnvironmentResourceDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEnvironmentResources",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEnvironmentResourcesResult");
    return {
      EnvironmentResources: xml.first("EnvironmentResources", false, EnvironmentResourceDescription_Parse),
    };
  }

  async describeEnvironments(
    {abortSignal, ...params}: RequestConfig & s.DescribeEnvironmentsMessage = {},
  ): Promise<s.EnvironmentDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("VersionLabel" in params) body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if (params["EnvironmentIds"]) qsP.appendList(body, prefix+"EnvironmentIds", params["EnvironmentIds"], {"entryPrefix":".member."})
    if (params["EnvironmentNames"]) qsP.appendList(body, prefix+"EnvironmentNames", params["EnvironmentNames"], {"entryPrefix":".member."})
    if ("IncludeDeleted" in params) body.append(prefix+"IncludeDeleted", (params["IncludeDeleted"] ?? '').toString());
    if ("IncludedDeletedBackTo" in params) body.append(prefix+"IncludedDeletedBackTo", qsP.encodeDate_iso8601(params["IncludedDeletedBackTo"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEnvironments",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEnvironmentsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Environments: xml.getList("Environments", "member").map(EnvironmentDescription_Parse),
    };
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsMessage = {},
  ): Promise<s.EventDescriptionsMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("VersionLabel" in params) body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    if ("RequestId" in params) body.append(prefix+"RequestId", (params["RequestId"] ?? '').toString());
    if ("Severity" in params) body.append(prefix+"Severity", (params["Severity"] ?? '').toString());
    if ("StartTime" in params) body.append(prefix+"StartTime", qsP.encodeDate_iso8601(params["StartTime"]));
    if ("EndTime" in params) body.append(prefix+"EndTime", qsP.encodeDate_iso8601(params["EndTime"]));
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeEventsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      Events: xml.getList("Events", "member").map(EventDescription_Parse),
    };
  }

  async describeInstancesHealth(
    {abortSignal, ...params}: RequestConfig & s.DescribeInstancesHealthRequest = {},
  ): Promise<s.DescribeInstancesHealthResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if (params["AttributeNames"]) qsP.appendList(body, prefix+"AttributeNames", params["AttributeNames"], {"entryPrefix":".member."})
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeInstancesHealth",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribeInstancesHealthResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      InstanceHealthList: xml.getList("InstanceHealthList", "member").map(SingleInstanceHealth_Parse),
      RefreshedAt: xml.first("RefreshedAt", false, x => xmlP.parseTimestamp(x.content)),
    };
  }

  async describePlatformVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribePlatformVersionRequest = {},
  ): Promise<s.DescribePlatformVersionResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePlatformVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "DescribePlatformVersionResult");
    return {
      PlatformDescription: xml.first("PlatformDescription", false, PlatformDescription_Parse),
    };
  }

  async disassociateEnvironmentOperationsRole(
    {abortSignal, ...params}: RequestConfig & s.DisassociateEnvironmentOperationsRoleMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateEnvironmentOperationsRole",
    });
  }

  async listAvailableSolutionStacks(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.ListAvailableSolutionStacksResultMessage> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListAvailableSolutionStacks",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListAvailableSolutionStacksResult");
    return {
      SolutionStacks: xml.getList("SolutionStacks", "member").map(x => x.content ?? ''),
      SolutionStackDetails: xml.getList("SolutionStackDetails", "member").map(SolutionStackDescription_Parse),
    };
  }

  async listPlatformBranches(
    {abortSignal, ...params}: RequestConfig & s.ListPlatformBranchesRequest = {},
  ): Promise<s.ListPlatformBranchesResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":SearchFilter_Serialize,"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPlatformBranches",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListPlatformBranchesResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      PlatformBranchSummaryList: xml.getList("PlatformBranchSummaryList", "member").map(PlatformBranchSummary_Parse),
    };
  }

  async listPlatformVersions(
    {abortSignal, ...params}: RequestConfig & s.ListPlatformVersionsRequest = {},
  ): Promise<s.ListPlatformVersionsResult> {
    const body = new URLSearchParams;
    const prefix = '';
    if (params["Filters"]) qsP.appendList(body, prefix+"Filters", params["Filters"], {"appender":PlatformFilter_Serialize,"entryPrefix":".member."})
    if ("MaxRecords" in params) body.append(prefix+"MaxRecords", (params["MaxRecords"] ?? '').toString());
    if ("NextToken" in params) body.append(prefix+"NextToken", (params["NextToken"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPlatformVersions",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListPlatformVersionsResult");
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      PlatformSummaryList: xml.getList("PlatformSummaryList", "member").map(PlatformSummary_Parse),
    };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceMessage,
  ): Promise<s.ResourceTagsDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceArn", (params["ResourceArn"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ListTagsForResourceResult");
    return {
      ...xml.strings({
        optional: {"ResourceArn":true},
      }),
      ResourceTags: xml.getList("ResourceTags", "member").map(Tag_Parse),
    };
  }

  async rebuildEnvironment(
    {abortSignal, ...params}: RequestConfig & s.RebuildEnvironmentMessage = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RebuildEnvironment",
    });
  }

  async requestEnvironmentInfo(
    {abortSignal, ...params}: RequestConfig & s.RequestEnvironmentInfoMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    body.append(prefix+"InfoType", (params["InfoType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RequestEnvironmentInfo",
    });
  }

  async restartAppServer(
    {abortSignal, ...params}: RequestConfig & s.RestartAppServerMessage = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RestartAppServer",
    });
  }

  async retrieveEnvironmentInfo(
    {abortSignal, ...params}: RequestConfig & s.RetrieveEnvironmentInfoMessage,
  ): Promise<s.RetrieveEnvironmentInfoResultMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    body.append(prefix+"InfoType", (params["InfoType"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RetrieveEnvironmentInfo",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "RetrieveEnvironmentInfoResult");
    return {
      EnvironmentInfo: xml.getList("EnvironmentInfo", "member").map(EnvironmentInfoDescription_Parse),
    };
  }

  async swapEnvironmentCNAMEs(
    {abortSignal, ...params}: RequestConfig & s.SwapEnvironmentCNAMEsMessage = {},
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("SourceEnvironmentId" in params) body.append(prefix+"SourceEnvironmentId", (params["SourceEnvironmentId"] ?? '').toString());
    if ("SourceEnvironmentName" in params) body.append(prefix+"SourceEnvironmentName", (params["SourceEnvironmentName"] ?? '').toString());
    if ("DestinationEnvironmentId" in params) body.append(prefix+"DestinationEnvironmentId", (params["DestinationEnvironmentId"] ?? '').toString());
    if ("DestinationEnvironmentName" in params) body.append(prefix+"DestinationEnvironmentName", (params["DestinationEnvironmentName"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SwapEnvironmentCNAMEs",
    });
  }

  async terminateEnvironment(
    {abortSignal, ...params}: RequestConfig & s.TerminateEnvironmentMessage = {},
  ): Promise<s.EnvironmentDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("TerminateResources" in params) body.append(prefix+"TerminateResources", (params["TerminateResources"] ?? '').toString());
    if ("ForceTerminate" in params) body.append(prefix+"ForceTerminate", (params["ForceTerminate"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TerminateEnvironment",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "TerminateEnvironmentResult");
    return EnvironmentDescription_Parse(xml);
  }

  async updateApplication(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationMessage,
  ): Promise<s.ApplicationDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplication",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateApplicationResult");
    return {
      Application: xml.first("Application", false, ApplicationDescription_Parse),
    };
  }

  async updateApplicationResourceLifecycle(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationResourceLifecycleMessage,
  ): Promise<s.ApplicationResourceLifecycleDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    ApplicationResourceLifecycleConfig_Serialize(body, prefix+"ResourceLifecycleConfig", params["ResourceLifecycleConfig"]);
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplicationResourceLifecycle",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateApplicationResourceLifecycleResult");
    return {
      ...xml.strings({
        optional: {"ApplicationName":true},
      }),
      ResourceLifecycleConfig: xml.first("ResourceLifecycleConfig", false, ApplicationResourceLifecycleConfig_Parse),
    };
  }

  async updateApplicationVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationVersionMessage,
  ): Promise<s.ApplicationVersionDescriptionMessage> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplicationVersion",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateApplicationVersionResult");
    return {
      ApplicationVersion: xml.first("ApplicationVersion", false, ApplicationVersionDescription_Parse),
    };
  }

  async updateConfigurationTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateConfigurationTemplateMessage,
  ): Promise<s.ConfigurationSettingsDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    if (params["OptionsToRemove"]) qsP.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"appender":OptionSpecification_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConfigurationTemplate",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateConfigurationTemplateResult");
    return ConfigurationSettingsDescription_Parse(xml);
  }

  async updateEnvironment(
    {abortSignal, ...params}: RequestConfig & s.UpdateEnvironmentMessage = {},
  ): Promise<s.EnvironmentDescription> {
    const body = new URLSearchParams;
    const prefix = '';
    if ("ApplicationName" in params) body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("EnvironmentId" in params) body.append(prefix+"EnvironmentId", (params["EnvironmentId"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if ("GroupName" in params) body.append(prefix+"GroupName", (params["GroupName"] ?? '').toString());
    if ("Description" in params) body.append(prefix+"Description", (params["Description"] ?? '').toString());
    if (params["Tier"] != null) EnvironmentTier_Serialize(body, prefix+"Tier", params["Tier"]);
    if ("VersionLabel" in params) body.append(prefix+"VersionLabel", (params["VersionLabel"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("SolutionStackName" in params) body.append(prefix+"SolutionStackName", (params["SolutionStackName"] ?? '').toString());
    if ("PlatformArn" in params) body.append(prefix+"PlatformArn", (params["PlatformArn"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    if (params["OptionsToRemove"]) qsP.appendList(body, prefix+"OptionsToRemove", params["OptionsToRemove"], {"appender":OptionSpecification_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEnvironment",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "UpdateEnvironmentResult");
    return EnvironmentDescription_Parse(xml);
  }

  async updateTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.UpdateTagsForResourceMessage,
  ): Promise<void> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ResourceArn", (params["ResourceArn"] ?? '').toString());
    if (params["TagsToAdd"]) qsP.appendList(body, prefix+"TagsToAdd", params["TagsToAdd"], {"appender":Tag_Serialize,"entryPrefix":".member."})
    if (params["TagsToRemove"]) qsP.appendList(body, prefix+"TagsToRemove", params["TagsToRemove"], {"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTagsForResource",
    });
  }

  async validateConfigurationSettings(
    {abortSignal, ...params}: RequestConfig & s.ValidateConfigurationSettingsMessage,
  ): Promise<s.ConfigurationSettingsValidationMessages> {
    const body = new URLSearchParams;
    const prefix = '';
    body.append(prefix+"ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+"TemplateName", (params["TemplateName"] ?? '').toString());
    if ("EnvironmentName" in params) body.append(prefix+"EnvironmentName", (params["EnvironmentName"] ?? '').toString());
    if (params["OptionSettings"]) qsP.appendList(body, prefix+"OptionSettings", params["OptionSettings"], {"appender":ConfigurationOptionSetting_Serialize,"entryPrefix":".member."})
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidateConfigurationSettings",
    });
    const xml = xmlP.readXmlResult(await resp.text(), "ValidateConfigurationSettingsResult");
    return {
      Messages: xml.getList("Messages", "member").map(ValidationMessage_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 20 seconds apart (about 7 minutes max wait time). */
  async waitForEnvironmentExists(
    params: RequestConfig & s.DescribeEnvironmentsMessage,
  ): Promise<s.EnvironmentDescriptionsMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EnvironmentExists';
    for (let i = 0; i < 20; i++) {
      const resp = await this.describeEnvironments(params);
      const field = resp?.Environments?.flatMap(x => x?.Status);
      if (field?.every(x => x === "Ready")) return resp;
      if (field?.every(x => x === "Launching")) continue;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 20 seconds apart (about 7 minutes max wait time). */
  async waitForEnvironmentUpdated(
    params: RequestConfig & s.DescribeEnvironmentsMessage,
  ): Promise<s.EnvironmentDescriptionsMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EnvironmentUpdated';
    for (let i = 0; i < 20; i++) {
      const resp = await this.describeEnvironments(params);
      const field = resp?.Environments?.flatMap(x => x?.Status);
      if (field?.every(x => x === "Ready")) return resp;
      if (field?.every(x => x === "Updating")) continue;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 20 seconds apart (about 7 minutes max wait time). */
  async waitForEnvironmentTerminated(
    params: RequestConfig & s.DescribeEnvironmentsMessage,
  ): Promise<s.EnvironmentDescriptionsMessage> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EnvironmentTerminated';
    for (let i = 0; i < 20; i++) {
      const resp = await this.describeEnvironments(params);
      const field = resp?.Environments?.flatMap(x => x?.Status);
      if (field?.every(x => x === "Terminated")) return resp;
      if (field?.every(x => x === "Terminating")) continue;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

}

function ConfigurationSettingsDescription_Parse(node: xmlP.XmlNode): s.ConfigurationSettingsDescription {
  return {
    ...node.strings({
      optional: {"SolutionStackName":true,"PlatformArn":true,"ApplicationName":true,"TemplateName":true,"Description":true,"EnvironmentName":true},
    }),
    DeploymentStatus: node.first("DeploymentStatus", false, x => (x.content ?? '') as s.ConfigurationDeploymentStatus),
    DateCreated: node.first("DateCreated", false, x => xmlP.parseTimestamp(x.content)),
    DateUpdated: node.first("DateUpdated", false, x => xmlP.parseTimestamp(x.content)),
    OptionSettings: node.getList("OptionSettings", "member").map(ConfigurationOptionSetting_Parse),
  };
}

function EnvironmentDescription_Parse(node: xmlP.XmlNode): s.EnvironmentDescription {
  return {
    ...node.strings({
      optional: {"EnvironmentName":true,"EnvironmentId":true,"ApplicationName":true,"VersionLabel":true,"SolutionStackName":true,"PlatformArn":true,"TemplateName":true,"Description":true,"EndpointURL":true,"CNAME":true,"EnvironmentArn":true,"OperationsRole":true},
    }),
    DateCreated: node.first("DateCreated", false, x => xmlP.parseTimestamp(x.content)),
    DateUpdated: node.first("DateUpdated", false, x => xmlP.parseTimestamp(x.content)),
    Status: node.first("Status", false, x => (x.content ?? '') as s.EnvironmentStatus),
    AbortableOperationInProgress: node.first("AbortableOperationInProgress", false, x => x.content === 'true'),
    Health: node.first("Health", false, x => (x.content ?? '') as s.EnvironmentHealth),
    HealthStatus: node.first("HealthStatus", false, x => (x.content ?? '') as s.EnvironmentHealthStatus),
    Resources: node.first("Resources", false, EnvironmentResourcesDescription_Parse),
    Tier: node.first("Tier", false, EnvironmentTier_Parse),
    EnvironmentLinks: node.getList("EnvironmentLinks", "member").map(EnvironmentLink_Parse),
  };
}

function ApplicationResourceLifecycleConfig_Serialize(body: URLSearchParams, prefix: string, params: s.ApplicationResourceLifecycleConfig) {
    if ("ServiceRole" in params) body.append(prefix+".ServiceRole", (params["ServiceRole"] ?? '').toString());
    if (params["VersionLifecycleConfig"] != null) ApplicationVersionLifecycleConfig_Serialize(body, prefix+".VersionLifecycleConfig", params["VersionLifecycleConfig"]);
}
function ApplicationResourceLifecycleConfig_Parse(node: xmlP.XmlNode): s.ApplicationResourceLifecycleConfig {
  return {
    ...node.strings({
      optional: {"ServiceRole":true},
    }),
    VersionLifecycleConfig: node.first("VersionLifecycleConfig", false, ApplicationVersionLifecycleConfig_Parse),
  };
}

function ApplicationVersionLifecycleConfig_Serialize(body: URLSearchParams, prefix: string, params: s.ApplicationVersionLifecycleConfig) {
    if (params["MaxCountRule"] != null) MaxCountRule_Serialize(body, prefix+".MaxCountRule", params["MaxCountRule"]);
    if (params["MaxAgeRule"] != null) MaxAgeRule_Serialize(body, prefix+".MaxAgeRule", params["MaxAgeRule"]);
}
function ApplicationVersionLifecycleConfig_Parse(node: xmlP.XmlNode): s.ApplicationVersionLifecycleConfig {
  return {
    MaxCountRule: node.first("MaxCountRule", false, MaxCountRule_Parse),
    MaxAgeRule: node.first("MaxAgeRule", false, MaxAgeRule_Parse),
  };
}

function MaxCountRule_Serialize(body: URLSearchParams, prefix: string, params: s.MaxCountRule) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("MaxCount" in params) body.append(prefix+".MaxCount", (params["MaxCount"] ?? '').toString());
    if ("DeleteSourceFromS3" in params) body.append(prefix+".DeleteSourceFromS3", (params["DeleteSourceFromS3"] ?? '').toString());
}
function MaxCountRule_Parse(node: xmlP.XmlNode): s.MaxCountRule {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    MaxCount: node.first("MaxCount", false, x => parseInt(x.content ?? '0')),
    DeleteSourceFromS3: node.first("DeleteSourceFromS3", false, x => x.content === 'true'),
  };
}

function MaxAgeRule_Serialize(body: URLSearchParams, prefix: string, params: s.MaxAgeRule) {
    body.append(prefix+".Enabled", (params["Enabled"] ?? '').toString());
    if ("MaxAgeInDays" in params) body.append(prefix+".MaxAgeInDays", (params["MaxAgeInDays"] ?? '').toString());
    if ("DeleteSourceFromS3" in params) body.append(prefix+".DeleteSourceFromS3", (params["DeleteSourceFromS3"] ?? '').toString());
}
function MaxAgeRule_Parse(node: xmlP.XmlNode): s.MaxAgeRule {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    MaxAgeInDays: node.first("MaxAgeInDays", false, x => parseInt(x.content ?? '0')),
    DeleteSourceFromS3: node.first("DeleteSourceFromS3", false, x => x.content === 'true'),
  };
}

function Tag_Serialize(body: URLSearchParams, prefix: string, params: s.Tag) {
    if ("Key" in params) body.append(prefix+".Key", (params["Key"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function SourceBuildInformation_Serialize(body: URLSearchParams, prefix: string, params: s.SourceBuildInformation) {
    body.append(prefix+".SourceType", (params["SourceType"] ?? '').toString());
    body.append(prefix+".SourceRepository", (params["SourceRepository"] ?? '').toString());
    body.append(prefix+".SourceLocation", (params["SourceLocation"] ?? '').toString());
}
function SourceBuildInformation_Parse(node: xmlP.XmlNode): s.SourceBuildInformation {
  return {
    ...node.strings({
      required: {"SourceLocation":true},
    }),
    SourceType: node.first("SourceType", true, x => (x.content ?? '') as s.SourceType),
    SourceRepository: node.first("SourceRepository", true, x => (x.content ?? '') as s.SourceRepository),
  };
}

function S3Location_Serialize(body: URLSearchParams, prefix: string, params: s.S3Location) {
    if ("S3Bucket" in params) body.append(prefix+".S3Bucket", (params["S3Bucket"] ?? '').toString());
    if ("S3Key" in params) body.append(prefix+".S3Key", (params["S3Key"] ?? '').toString());
}
function S3Location_Parse(node: xmlP.XmlNode): s.S3Location {
  return node.strings({
    optional: {"S3Bucket":true,"S3Key":true},
  });
}

function BuildConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.BuildConfiguration) {
    if ("ArtifactName" in params) body.append(prefix+".ArtifactName", (params["ArtifactName"] ?? '').toString());
    body.append(prefix+".CodeBuildServiceRole", (params["CodeBuildServiceRole"] ?? '').toString());
    if ("ComputeType" in params) body.append(prefix+".ComputeType", (params["ComputeType"] ?? '').toString());
    body.append(prefix+".Image", (params["Image"] ?? '').toString());
    if ("TimeoutInMinutes" in params) body.append(prefix+".TimeoutInMinutes", (params["TimeoutInMinutes"] ?? '').toString());
}

function SourceConfiguration_Serialize(body: URLSearchParams, prefix: string, params: s.SourceConfiguration) {
    if ("ApplicationName" in params) body.append(prefix+".ApplicationName", (params["ApplicationName"] ?? '').toString());
    if ("TemplateName" in params) body.append(prefix+".TemplateName", (params["TemplateName"] ?? '').toString());
}

function ConfigurationOptionSetting_Serialize(body: URLSearchParams, prefix: string, params: s.ConfigurationOptionSetting) {
    if ("ResourceName" in params) body.append(prefix+".ResourceName", (params["ResourceName"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if ("OptionName" in params) body.append(prefix+".OptionName", (params["OptionName"] ?? '').toString());
    if ("Value" in params) body.append(prefix+".Value", (params["Value"] ?? '').toString());
}
function ConfigurationOptionSetting_Parse(node: xmlP.XmlNode): s.ConfigurationOptionSetting {
  return node.strings({
    optional: {"ResourceName":true,"Namespace":true,"OptionName":true,"Value":true},
  });
}

function EnvironmentTier_Serialize(body: URLSearchParams, prefix: string, params: s.EnvironmentTier) {
    if ("Name" in params) body.append(prefix+".Name", (params["Name"] ?? '').toString());
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Version" in params) body.append(prefix+".Version", (params["Version"] ?? '').toString());
}
function EnvironmentTier_Parse(node: xmlP.XmlNode): s.EnvironmentTier {
  return node.strings({
    optional: {"Name":true,"Type":true,"Version":true},
  });
}

function OptionSpecification_Serialize(body: URLSearchParams, prefix: string, params: s.OptionSpecification) {
    if ("ResourceName" in params) body.append(prefix+".ResourceName", (params["ResourceName"] ?? '').toString());
    if ("Namespace" in params) body.append(prefix+".Namespace", (params["Namespace"] ?? '').toString());
    if ("OptionName" in params) body.append(prefix+".OptionName", (params["OptionName"] ?? '').toString());
}

function SearchFilter_Serialize(body: URLSearchParams, prefix: string, params: s.SearchFilter) {
    if ("Attribute" in params) body.append(prefix+".Attribute", (params["Attribute"] ?? '').toString());
    if ("Operator" in params) body.append(prefix+".Operator", (params["Operator"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

function PlatformFilter_Serialize(body: URLSearchParams, prefix: string, params: s.PlatformFilter) {
    if ("Type" in params) body.append(prefix+".Type", (params["Type"] ?? '').toString());
    if ("Operator" in params) body.append(prefix+".Operator", (params["Operator"] ?? '').toString());
    if (params["Values"]) qsP.appendList(body, prefix+".Values", params["Values"], {"entryPrefix":".member."})
}

function EnvironmentResourcesDescription_Parse(node: xmlP.XmlNode): s.EnvironmentResourcesDescription {
  return {
    LoadBalancer: node.first("LoadBalancer", false, LoadBalancerDescription_Parse),
  };
}

function LoadBalancerDescription_Parse(node: xmlP.XmlNode): s.LoadBalancerDescription {
  return {
    ...node.strings({
      optional: {"LoadBalancerName":true,"Domain":true},
    }),
    Listeners: node.getList("Listeners", "member").map(Listener_Parse),
  };
}

function Listener_Parse(node: xmlP.XmlNode): s.Listener {
  return {
    ...node.strings({
      optional: {"Protocol":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
  };
}

function EnvironmentLink_Parse(node: xmlP.XmlNode): s.EnvironmentLink {
  return node.strings({
    optional: {"LinkName":true,"EnvironmentName":true},
  });
}

function ApplicationDescription_Parse(node: xmlP.XmlNode): s.ApplicationDescription {
  return {
    ...node.strings({
      optional: {"ApplicationArn":true,"ApplicationName":true,"Description":true},
    }),
    DateCreated: node.first("DateCreated", false, x => xmlP.parseTimestamp(x.content)),
    DateUpdated: node.first("DateUpdated", false, x => xmlP.parseTimestamp(x.content)),
    Versions: node.getList("Versions", "member").map(x => x.content ?? ''),
    ConfigurationTemplates: node.getList("ConfigurationTemplates", "member").map(x => x.content ?? ''),
    ResourceLifecycleConfig: node.first("ResourceLifecycleConfig", false, ApplicationResourceLifecycleConfig_Parse),
  };
}

function ApplicationVersionDescription_Parse(node: xmlP.XmlNode): s.ApplicationVersionDescription {
  return {
    ...node.strings({
      optional: {"ApplicationVersionArn":true,"ApplicationName":true,"Description":true,"VersionLabel":true,"BuildArn":true},
    }),
    SourceBuildInformation: node.first("SourceBuildInformation", false, SourceBuildInformation_Parse),
    SourceBundle: node.first("SourceBundle", false, S3Location_Parse),
    DateCreated: node.first("DateCreated", false, x => xmlP.parseTimestamp(x.content)),
    DateUpdated: node.first("DateUpdated", false, x => xmlP.parseTimestamp(x.content)),
    Status: node.first("Status", false, x => (x.content ?? '') as s.ApplicationVersionStatus),
  };
}

function PlatformSummary_Parse(node: xmlP.XmlNode): s.PlatformSummary {
  return {
    ...node.strings({
      optional: {"PlatformArn":true,"PlatformOwner":true,"PlatformCategory":true,"OperatingSystemName":true,"OperatingSystemVersion":true,"PlatformLifecycleState":true,"PlatformVersion":true,"PlatformBranchName":true,"PlatformBranchLifecycleState":true},
    }),
    PlatformStatus: node.first("PlatformStatus", false, x => (x.content ?? '') as s.PlatformStatus),
    SupportedTierList: node.getList("SupportedTierList", "member").map(x => x.content ?? ''),
    SupportedAddonList: node.getList("SupportedAddonList", "member").map(x => x.content ?? ''),
  };
}

function Builder_Parse(node: xmlP.XmlNode): s.Builder {
  return node.strings({
    optional: {"ARN":true},
  });
}

function ResourceQuotas_Parse(node: xmlP.XmlNode): s.ResourceQuotas {
  return {
    ApplicationQuota: node.first("ApplicationQuota", false, ResourceQuota_Parse),
    ApplicationVersionQuota: node.first("ApplicationVersionQuota", false, ResourceQuota_Parse),
    EnvironmentQuota: node.first("EnvironmentQuota", false, ResourceQuota_Parse),
    ConfigurationTemplateQuota: node.first("ConfigurationTemplateQuota", false, ResourceQuota_Parse),
    CustomPlatformQuota: node.first("CustomPlatformQuota", false, ResourceQuota_Parse),
  };
}

function ResourceQuota_Parse(node: xmlP.XmlNode): s.ResourceQuota {
  return {
    Maximum: node.first("Maximum", false, x => parseInt(x.content ?? '0')),
  };
}

function ConfigurationOptionDescription_Parse(node: xmlP.XmlNode): s.ConfigurationOptionDescription {
  return {
    ...node.strings({
      optional: {"Namespace":true,"Name":true,"DefaultValue":true,"ChangeSeverity":true},
    }),
    UserDefined: node.first("UserDefined", false, x => x.content === 'true'),
    ValueType: node.first("ValueType", false, x => (x.content ?? '') as s.ConfigurationOptionValueType),
    ValueOptions: node.getList("ValueOptions", "member").map(x => x.content ?? ''),
    MinValue: node.first("MinValue", false, x => parseInt(x.content ?? '0')),
    MaxValue: node.first("MaxValue", false, x => parseInt(x.content ?? '0')),
    MaxLength: node.first("MaxLength", false, x => parseInt(x.content ?? '0')),
    Regex: node.first("Regex", false, OptionRestrictionRegex_Parse),
  };
}

function OptionRestrictionRegex_Parse(node: xmlP.XmlNode): s.OptionRestrictionRegex {
  return node.strings({
    optional: {"Pattern":true,"Label":true},
  });
}

function ApplicationMetrics_Parse(node: xmlP.XmlNode): s.ApplicationMetrics {
  return {
    Duration: node.first("Duration", false, x => parseInt(x.content ?? '0')),
    RequestCount: node.first("RequestCount", false, x => parseInt(x.content ?? '0')),
    StatusCodes: node.first("StatusCodes", false, StatusCodes_Parse),
    Latency: node.first("Latency", false, Latency_Parse),
  };
}

function StatusCodes_Parse(node: xmlP.XmlNode): s.StatusCodes {
  return {
    Status2xx: node.first("Status2xx", false, x => parseInt(x.content ?? '0')),
    Status3xx: node.first("Status3xx", false, x => parseInt(x.content ?? '0')),
    Status4xx: node.first("Status4xx", false, x => parseInt(x.content ?? '0')),
    Status5xx: node.first("Status5xx", false, x => parseInt(x.content ?? '0')),
  };
}

function Latency_Parse(node: xmlP.XmlNode): s.Latency {
  return {
    P999: node.first("P999", false, x => parseFloat(x.content ?? '0')),
    P99: node.first("P99", false, x => parseFloat(x.content ?? '0')),
    P95: node.first("P95", false, x => parseFloat(x.content ?? '0')),
    P90: node.first("P90", false, x => parseFloat(x.content ?? '0')),
    P85: node.first("P85", false, x => parseFloat(x.content ?? '0')),
    P75: node.first("P75", false, x => parseFloat(x.content ?? '0')),
    P50: node.first("P50", false, x => parseFloat(x.content ?? '0')),
    P10: node.first("P10", false, x => parseFloat(x.content ?? '0')),
  };
}

function InstanceHealthSummary_Parse(node: xmlP.XmlNode): s.InstanceHealthSummary {
  return {
    NoData: node.first("NoData", false, x => parseInt(x.content ?? '0')),
    Unknown: node.first("Unknown", false, x => parseInt(x.content ?? '0')),
    Pending: node.first("Pending", false, x => parseInt(x.content ?? '0')),
    Ok: node.first("Ok", false, x => parseInt(x.content ?? '0')),
    Info: node.first("Info", false, x => parseInt(x.content ?? '0')),
    Warning: node.first("Warning", false, x => parseInt(x.content ?? '0')),
    Degraded: node.first("Degraded", false, x => parseInt(x.content ?? '0')),
    Severe: node.first("Severe", false, x => parseInt(x.content ?? '0')),
  };
}

function ManagedActionHistoryItem_Parse(node: xmlP.XmlNode): s.ManagedActionHistoryItem {
  return {
    ...node.strings({
      optional: {"ActionId":true,"ActionDescription":true,"FailureDescription":true},
    }),
    ActionType: node.first("ActionType", false, x => (x.content ?? '') as s.ActionType),
    FailureType: node.first("FailureType", false, x => (x.content ?? '') as s.FailureType),
    Status: node.first("Status", false, x => (x.content ?? '') as s.ActionHistoryStatus),
    ExecutedTime: node.first("ExecutedTime", false, x => xmlP.parseTimestamp(x.content)),
    FinishedTime: node.first("FinishedTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ManagedAction_Parse(node: xmlP.XmlNode): s.ManagedAction {
  return {
    ...node.strings({
      optional: {"ActionId":true,"ActionDescription":true},
    }),
    ActionType: node.first("ActionType", false, x => (x.content ?? '') as s.ActionType),
    Status: node.first("Status", false, x => (x.content ?? '') as s.ActionStatus),
    WindowStartTime: node.first("WindowStartTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function EnvironmentResourceDescription_Parse(node: xmlP.XmlNode): s.EnvironmentResourceDescription {
  return {
    ...node.strings({
      optional: {"EnvironmentName":true},
    }),
    AutoScalingGroups: node.getList("AutoScalingGroups", "member").map(AutoScalingGroup_Parse),
    Instances: node.getList("Instances", "member").map(Instance_Parse),
    LaunchConfigurations: node.getList("LaunchConfigurations", "member").map(LaunchConfiguration_Parse),
    LaunchTemplates: node.getList("LaunchTemplates", "member").map(LaunchTemplate_Parse),
    LoadBalancers: node.getList("LoadBalancers", "member").map(LoadBalancer_Parse),
    Triggers: node.getList("Triggers", "member").map(Trigger_Parse),
    Queues: node.getList("Queues", "member").map(Queue_Parse),
  };
}

function AutoScalingGroup_Parse(node: xmlP.XmlNode): s.AutoScalingGroup {
  return node.strings({
    optional: {"Name":true},
  });
}

function Instance_Parse(node: xmlP.XmlNode): s.Instance {
  return node.strings({
    optional: {"Id":true},
  });
}

function LaunchConfiguration_Parse(node: xmlP.XmlNode): s.LaunchConfiguration {
  return node.strings({
    optional: {"Name":true},
  });
}

function LaunchTemplate_Parse(node: xmlP.XmlNode): s.LaunchTemplate {
  return node.strings({
    optional: {"Id":true},
  });
}

function LoadBalancer_Parse(node: xmlP.XmlNode): s.LoadBalancer {
  return node.strings({
    optional: {"Name":true},
  });
}

function Trigger_Parse(node: xmlP.XmlNode): s.Trigger {
  return node.strings({
    optional: {"Name":true},
  });
}

function Queue_Parse(node: xmlP.XmlNode): s.Queue {
  return node.strings({
    optional: {"Name":true,"URL":true},
  });
}

function EventDescription_Parse(node: xmlP.XmlNode): s.EventDescription {
  return {
    ...node.strings({
      optional: {"Message":true,"ApplicationName":true,"VersionLabel":true,"TemplateName":true,"EnvironmentName":true,"PlatformArn":true,"RequestId":true},
    }),
    EventDate: node.first("EventDate", false, x => xmlP.parseTimestamp(x.content)),
    Severity: node.first("Severity", false, x => (x.content ?? '') as s.EventSeverity),
  };
}

function SingleInstanceHealth_Parse(node: xmlP.XmlNode): s.SingleInstanceHealth {
  return {
    ...node.strings({
      optional: {"InstanceId":true,"HealthStatus":true,"Color":true,"AvailabilityZone":true,"InstanceType":true},
    }),
    Causes: node.getList("Causes", "member").map(x => x.content ?? ''),
    LaunchedAt: node.first("LaunchedAt", false, x => xmlP.parseTimestamp(x.content)),
    ApplicationMetrics: node.first("ApplicationMetrics", false, ApplicationMetrics_Parse),
    System: node.first("System", false, SystemStatus_Parse),
    Deployment: node.first("Deployment", false, Deployment_Parse),
  };
}

function SystemStatus_Parse(node: xmlP.XmlNode): s.SystemStatus {
  return {
    CPUUtilization: node.first("CPUUtilization", false, CPUUtilization_Parse),
    LoadAverage: node.getList("LoadAverage", "member").map(x => parseFloat(x.content ?? '0')),
  };
}

function CPUUtilization_Parse(node: xmlP.XmlNode): s.CPUUtilization {
  return {
    User: node.first("User", false, x => parseFloat(x.content ?? '0')),
    Nice: node.first("Nice", false, x => parseFloat(x.content ?? '0')),
    System: node.first("System", false, x => parseFloat(x.content ?? '0')),
    Idle: node.first("Idle", false, x => parseFloat(x.content ?? '0')),
    IOWait: node.first("IOWait", false, x => parseFloat(x.content ?? '0')),
    IRQ: node.first("IRQ", false, x => parseFloat(x.content ?? '0')),
    SoftIRQ: node.first("SoftIRQ", false, x => parseFloat(x.content ?? '0')),
    Privileged: node.first("Privileged", false, x => parseFloat(x.content ?? '0')),
  };
}

function Deployment_Parse(node: xmlP.XmlNode): s.Deployment {
  return {
    ...node.strings({
      optional: {"VersionLabel":true,"Status":true},
    }),
    DeploymentId: node.first("DeploymentId", false, x => parseInt(x.content ?? '0')),
    DeploymentTime: node.first("DeploymentTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function PlatformDescription_Parse(node: xmlP.XmlNode): s.PlatformDescription {
  return {
    ...node.strings({
      optional: {"PlatformArn":true,"PlatformOwner":true,"PlatformName":true,"PlatformVersion":true,"SolutionStackName":true,"PlatformCategory":true,"Description":true,"Maintainer":true,"OperatingSystemName":true,"OperatingSystemVersion":true,"PlatformLifecycleState":true,"PlatformBranchName":true,"PlatformBranchLifecycleState":true},
    }),
    PlatformStatus: node.first("PlatformStatus", false, x => (x.content ?? '') as s.PlatformStatus),
    DateCreated: node.first("DateCreated", false, x => xmlP.parseTimestamp(x.content)),
    DateUpdated: node.first("DateUpdated", false, x => xmlP.parseTimestamp(x.content)),
    ProgrammingLanguages: node.getList("ProgrammingLanguages", "member").map(PlatformProgrammingLanguage_Parse),
    Frameworks: node.getList("Frameworks", "member").map(PlatformFramework_Parse),
    CustomAmiList: node.getList("CustomAmiList", "member").map(CustomAmi_Parse),
    SupportedTierList: node.getList("SupportedTierList", "member").map(x => x.content ?? ''),
    SupportedAddonList: node.getList("SupportedAddonList", "member").map(x => x.content ?? ''),
  };
}

function PlatformProgrammingLanguage_Parse(node: xmlP.XmlNode): s.PlatformProgrammingLanguage {
  return node.strings({
    optional: {"Name":true,"Version":true},
  });
}

function PlatformFramework_Parse(node: xmlP.XmlNode): s.PlatformFramework {
  return node.strings({
    optional: {"Name":true,"Version":true},
  });
}

function CustomAmi_Parse(node: xmlP.XmlNode): s.CustomAmi {
  return node.strings({
    optional: {"VirtualizationType":true,"ImageId":true},
  });
}

function SolutionStackDescription_Parse(node: xmlP.XmlNode): s.SolutionStackDescription {
  return {
    ...node.strings({
      optional: {"SolutionStackName":true},
    }),
    PermittedFileTypes: node.getList("PermittedFileTypes", "member").map(x => x.content ?? ''),
  };
}

function PlatformBranchSummary_Parse(node: xmlP.XmlNode): s.PlatformBranchSummary {
  return {
    ...node.strings({
      optional: {"PlatformName":true,"BranchName":true,"LifecycleState":true},
    }),
    BranchOrder: node.first("BranchOrder", false, x => parseInt(x.content ?? '0')),
    SupportedTierList: node.getList("SupportedTierList", "member").map(x => x.content ?? ''),
  };
}

function EnvironmentInfoDescription_Parse(node: xmlP.XmlNode): s.EnvironmentInfoDescription {
  return {
    ...node.strings({
      optional: {"Ec2InstanceId":true,"Message":true},
    }),
    InfoType: node.first("InfoType", false, x => (x.content ?? '') as s.EnvironmentInfoType),
    SampleTimestamp: node.first("SampleTimestamp", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function ValidationMessage_Parse(node: xmlP.XmlNode): s.ValidationMessage {
  return {
    ...node.strings({
      optional: {"Message":true,"Namespace":true,"OptionName":true},
    }),
    Severity: node.first("Severity", false, x => (x.content ?? '') as s.ValidationSeverity),
  };
}
