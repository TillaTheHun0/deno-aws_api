// Autogenerated API client for: AWS WAFV2

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class WAFV2 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(WAFV2.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-07-29",
    "endpointPrefix": "wafv2",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "WAFV2",
    "serviceFullName": "AWS WAFV2",
    "serviceId": "WAFV2",
    "signatureVersion": "v4",
    "targetPrefix": "AWSWAF_20190729",
    "uid": "wafv2-2019-07-29"
  };

  async associateWebACL(
    {abortSignal, ...params}: RequestConfig & s.AssociateWebACLRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      WebACLArn: params["WebACLArn"],
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateWebACL",
    });
    await resp.text();
  }

  async checkCapacity(
    {abortSignal, ...params}: RequestConfig & s.CheckCapacityRequest,
  ): Promise<s.CheckCapacityResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      Rules: params["Rules"]?.map(x => fromRule(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CheckCapacity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Capacity": "n",
      },
    }, await resp.json());
  }

  async createIPSet(
    {abortSignal, ...params}: RequestConfig & s.CreateIPSetRequest,
  ): Promise<s.CreateIPSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Description: params["Description"],
      IPAddressVersion: params["IPAddressVersion"],
      Addresses: params["Addresses"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIPSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Summary": toIPSetSummary,
      },
    }, await resp.json());
  }

  async createRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & s.CreateRegexPatternSetRequest,
  ): Promise<s.CreateRegexPatternSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Description: params["Description"],
      RegularExpressionList: params["RegularExpressionList"]?.map(x => fromRegex(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRegexPatternSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Summary": toRegexPatternSetSummary,
      },
    }, await resp.json());
  }

  async createRuleGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateRuleGroupRequest,
  ): Promise<s.CreateRuleGroupResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Capacity: params["Capacity"],
      Description: params["Description"],
      Rules: params["Rules"]?.map(x => fromRule(x)),
      VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRuleGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Summary": toRuleGroupSummary,
      },
    }, await resp.json());
  }

  async createWebACL(
    {abortSignal, ...params}: RequestConfig & s.CreateWebACLRequest,
  ): Promise<s.CreateWebACLResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      DefaultAction: fromDefaultAction(params["DefaultAction"]),
      Description: params["Description"],
      Rules: params["Rules"]?.map(x => fromRule(x)),
      VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWebACL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Summary": toWebACLSummary,
      },
    }, await resp.json());
  }

  async deleteFirewallManagerRuleGroups(
    {abortSignal, ...params}: RequestConfig & s.DeleteFirewallManagerRuleGroupsRequest,
  ): Promise<s.DeleteFirewallManagerRuleGroupsResponse> {
    const body: jsonP.JSONObject = {
      WebACLArn: params["WebACLArn"],
      WebACLLockToken: params["WebACLLockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFirewallManagerRuleGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextWebACLLockToken": "s",
      },
    }, await resp.json());
  }

  async deleteIPSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteIPSetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIPSet",
    });
    await resp.text();
  }

  async deleteLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteLoggingConfigurationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoggingConfiguration",
    });
    await resp.text();
  }

  async deletePermissionPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeletePermissionPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePermissionPolicy",
    });
    await resp.text();
  }

  async deleteRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & s.DeleteRegexPatternSetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRegexPatternSet",
    });
    await resp.text();
  }

  async deleteRuleGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteRuleGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRuleGroup",
    });
    await resp.text();
  }

  async deleteWebACL(
    {abortSignal, ...params}: RequestConfig & s.DeleteWebACLRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWebACL",
    });
    await resp.text();
  }

  async describeManagedRuleGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeManagedRuleGroupRequest,
  ): Promise<s.DescribeManagedRuleGroupResponse> {
    const body: jsonP.JSONObject = {
      VendorName: params["VendorName"],
      Name: params["Name"],
      Scope: params["Scope"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeManagedRuleGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Capacity": "n",
        "Rules": [toRuleSummary],
      },
    }, await resp.json());
  }

  async disassociateWebACL(
    {abortSignal, ...params}: RequestConfig & s.DisassociateWebACLRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateWebACL",
    });
    await resp.text();
  }

  async getIPSet(
    {abortSignal, ...params}: RequestConfig & s.GetIPSetRequest,
  ): Promise<s.GetIPSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIPSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "IPSet": toIPSet,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetLoggingConfigurationRequest,
  ): Promise<s.GetLoggingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoggingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LoggingConfiguration": toLoggingConfiguration,
      },
    }, await resp.json());
  }

  async getPermissionPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetPermissionPolicyRequest,
  ): Promise<s.GetPermissionPolicyResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPermissionPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async getRateBasedStatementManagedKeys(
    {abortSignal, ...params}: RequestConfig & s.GetRateBasedStatementManagedKeysRequest,
  ): Promise<s.GetRateBasedStatementManagedKeysResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      WebACLName: params["WebACLName"],
      WebACLId: params["WebACLId"],
      RuleName: params["RuleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRateBasedStatementManagedKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ManagedKeysIPV4": toRateBasedStatementManagedKeysIPSet,
        "ManagedKeysIPV6": toRateBasedStatementManagedKeysIPSet,
      },
    }, await resp.json());
  }

  async getRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & s.GetRegexPatternSetRequest,
  ): Promise<s.GetRegexPatternSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegexPatternSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegexPatternSet": toRegexPatternSet,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getRuleGroup(
    {abortSignal, ...params}: RequestConfig & s.GetRuleGroupRequest,
  ): Promise<s.GetRuleGroupResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRuleGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RuleGroup": toRuleGroup,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getSampledRequests(
    {abortSignal, ...params}: RequestConfig & s.GetSampledRequestsRequest,
  ): Promise<s.GetSampledRequestsResponse> {
    const body: jsonP.JSONObject = {
      WebAclArn: params["WebAclArn"],
      RuleMetricName: params["RuleMetricName"],
      Scope: params["Scope"],
      TimeWindow: fromTimeWindow(params["TimeWindow"]),
      MaxItems: params["MaxItems"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSampledRequests",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SampledRequests": [toSampledHTTPRequest],
        "PopulationSize": "n",
        "TimeWindow": toTimeWindow,
      },
    }, await resp.json());
  }

  async getWebACL(
    {abortSignal, ...params}: RequestConfig & s.GetWebACLRequest,
  ): Promise<s.GetWebACLResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWebACL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WebACL": toWebACL,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getWebACLForResource(
    {abortSignal, ...params}: RequestConfig & s.GetWebACLForResourceRequest,
  ): Promise<s.GetWebACLForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWebACLForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WebACL": toWebACL,
      },
    }, await resp.json());
  }

  async listAvailableManagedRuleGroups(
    {abortSignal, ...params}: RequestConfig & s.ListAvailableManagedRuleGroupsRequest,
  ): Promise<s.ListAvailableManagedRuleGroupsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAvailableManagedRuleGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "ManagedRuleGroups": [toManagedRuleGroupSummary],
      },
    }, await resp.json());
  }

  async listIPSets(
    {abortSignal, ...params}: RequestConfig & s.ListIPSetsRequest,
  ): Promise<s.ListIPSetsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIPSets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "IPSets": [toIPSetSummary],
      },
    }, await resp.json());
  }

  async listLoggingConfigurations(
    {abortSignal, ...params}: RequestConfig & s.ListLoggingConfigurationsRequest = {},
  ): Promise<s.ListLoggingConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLoggingConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LoggingConfigurations": [toLoggingConfiguration],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listRegexPatternSets(
    {abortSignal, ...params}: RequestConfig & s.ListRegexPatternSetsRequest,
  ): Promise<s.ListRegexPatternSetsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRegexPatternSets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "RegexPatternSets": [toRegexPatternSetSummary],
      },
    }, await resp.json());
  }

  async listResourcesForWebACL(
    {abortSignal, ...params}: RequestConfig & s.ListResourcesForWebACLRequest,
  ): Promise<s.ListResourcesForWebACLResponse> {
    const body: jsonP.JSONObject = {
      WebACLArn: params["WebACLArn"],
      ResourceType: params["ResourceType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourcesForWebACL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ResourceArns": ["s"],
      },
    }, await resp.json());
  }

  async listRuleGroups(
    {abortSignal, ...params}: RequestConfig & s.ListRuleGroupsRequest,
  ): Promise<s.ListRuleGroupsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRuleGroups",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "RuleGroups": [toRuleGroupSummary],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "TagInfoForResource": toTagInfoForResource,
      },
    }, await resp.json());
  }

  async listWebACLs(
    {abortSignal, ...params}: RequestConfig & s.ListWebACLsRequest,
  ): Promise<s.ListWebACLsResponse> {
    const body: jsonP.JSONObject = {
      Scope: params["Scope"],
      NextMarker: params["NextMarker"],
      Limit: params["Limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWebACLs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "WebACLs": [toWebACLSummary],
      },
    }, await resp.json());
  }

  async putLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & s.PutLoggingConfigurationRequest,
  ): Promise<s.PutLoggingConfigurationResponse> {
    const body: jsonP.JSONObject = {
      LoggingConfiguration: fromLoggingConfiguration(params["LoggingConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLoggingConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LoggingConfiguration": toLoggingConfiguration,
      },
    }, await resp.json());
  }

  async putPermissionPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutPermissionPolicyRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Policy: params["Policy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPermissionPolicy",
    });
    await resp.text();
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    await resp.text();
  }

  async updateIPSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateIPSetRequest,
  ): Promise<s.UpdateIPSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      Description: params["Description"],
      Addresses: params["Addresses"],
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIPSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & s.UpdateRegexPatternSetRequest,
  ): Promise<s.UpdateRegexPatternSetResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      Description: params["Description"],
      RegularExpressionList: params["RegularExpressionList"]?.map(x => fromRegex(x)),
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRegexPatternSet",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateRuleGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateRuleGroupRequest,
  ): Promise<s.UpdateRuleGroupResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      Description: params["Description"],
      Rules: params["Rules"]?.map(x => fromRule(x)),
      VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuleGroup",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateWebACL(
    {abortSignal, ...params}: RequestConfig & s.UpdateWebACLRequest,
  ): Promise<s.UpdateWebACLResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Scope: params["Scope"],
      Id: params["Id"],
      DefaultAction: fromDefaultAction(params["DefaultAction"]),
      Description: params["Description"],
      Rules: params["Rules"]?.map(x => fromRule(x)),
      VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
      LockToken: params["LockToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWebACL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

}

function fromRule(input?: s.Rule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Priority: input["Priority"],
    Statement: fromStatement(input["Statement"]),
    Action: fromRuleAction(input["Action"]),
    OverrideAction: fromOverrideAction(input["OverrideAction"]),
    VisibilityConfig: fromVisibilityConfig(input["VisibilityConfig"]),
  }
}
function toRule(root: jsonP.JSONValue): s.Rule {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Priority": "n",
      "Statement": toStatement,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Action": toRuleAction,
      "OverrideAction": toOverrideAction,
    },
  }, root);
}

function fromStatement(input?: s.Statement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ByteMatchStatement: fromByteMatchStatement(input["ByteMatchStatement"]),
    SqliMatchStatement: fromSqliMatchStatement(input["SqliMatchStatement"]),
    XssMatchStatement: fromXssMatchStatement(input["XssMatchStatement"]),
    SizeConstraintStatement: fromSizeConstraintStatement(input["SizeConstraintStatement"]),
    GeoMatchStatement: fromGeoMatchStatement(input["GeoMatchStatement"]),
    RuleGroupReferenceStatement: fromRuleGroupReferenceStatement(input["RuleGroupReferenceStatement"]),
    IPSetReferenceStatement: fromIPSetReferenceStatement(input["IPSetReferenceStatement"]),
    RegexPatternSetReferenceStatement: fromRegexPatternSetReferenceStatement(input["RegexPatternSetReferenceStatement"]),
    RateBasedStatement: fromRateBasedStatement(input["RateBasedStatement"]),
    AndStatement: fromAndStatement(input["AndStatement"]),
    OrStatement: fromOrStatement(input["OrStatement"]),
    NotStatement: fromNotStatement(input["NotStatement"]),
    ManagedRuleGroupStatement: fromManagedRuleGroupStatement(input["ManagedRuleGroupStatement"]),
  }
}
function toStatement(root: jsonP.JSONValue): s.Statement {
  return jsonP.readObj({
    required: {},
    optional: {
      "ByteMatchStatement": toByteMatchStatement,
      "SqliMatchStatement": toSqliMatchStatement,
      "XssMatchStatement": toXssMatchStatement,
      "SizeConstraintStatement": toSizeConstraintStatement,
      "GeoMatchStatement": toGeoMatchStatement,
      "RuleGroupReferenceStatement": toRuleGroupReferenceStatement,
      "IPSetReferenceStatement": toIPSetReferenceStatement,
      "RegexPatternSetReferenceStatement": toRegexPatternSetReferenceStatement,
      "RateBasedStatement": toRateBasedStatement,
      "AndStatement": toAndStatement,
      "OrStatement": toOrStatement,
      "NotStatement": toNotStatement,
      "ManagedRuleGroupStatement": toManagedRuleGroupStatement,
    },
  }, root);
}

function fromByteMatchStatement(input?: s.ByteMatchStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SearchString: serializeBlob(input["SearchString"]),
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
    PositionalConstraint: input["PositionalConstraint"],
  }
}
function toByteMatchStatement(root: jsonP.JSONValue): s.ByteMatchStatement {
  return jsonP.readObj({
    required: {
      "SearchString": "a",
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
      "PositionalConstraint": (x: jsonP.JSONValue) => cmnP.readEnum<s.PositionalConstraint>(x),
    },
    optional: {},
  }, root);
}

function fromFieldToMatch(input?: s.FieldToMatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SingleHeader: fromSingleHeader(input["SingleHeader"]),
    SingleQueryArgument: fromSingleQueryArgument(input["SingleQueryArgument"]),
    AllQueryArguments: fromAllQueryArguments(input["AllQueryArguments"]),
    UriPath: fromUriPath(input["UriPath"]),
    QueryString: fromQueryString(input["QueryString"]),
    Body: fromBody(input["Body"]),
    Method: fromMethod(input["Method"]),
    JsonBody: fromJsonBody(input["JsonBody"]),
  }
}
function toFieldToMatch(root: jsonP.JSONValue): s.FieldToMatch {
  return jsonP.readObj({
    required: {},
    optional: {
      "SingleHeader": toSingleHeader,
      "SingleQueryArgument": toSingleQueryArgument,
      "AllQueryArguments": toAllQueryArguments,
      "UriPath": toUriPath,
      "QueryString": toQueryString,
      "Body": toBody,
      "Method": toMethod,
      "JsonBody": toJsonBody,
    },
  }, root);
}

function fromSingleHeader(input?: s.SingleHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
  }
}
function toSingleHeader(root: jsonP.JSONValue): s.SingleHeader {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

function fromSingleQueryArgument(input?: s.SingleQueryArgument | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
  }
}
function toSingleQueryArgument(root: jsonP.JSONValue): s.SingleQueryArgument {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

function fromAllQueryArguments(input?: s.AllQueryArguments | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAllQueryArguments(root: jsonP.JSONValue): s.AllQueryArguments {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromUriPath(input?: s.UriPath | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toUriPath(root: jsonP.JSONValue): s.UriPath {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromQueryString(input?: s.QueryString | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toQueryString(root: jsonP.JSONValue): s.QueryString {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromBody(input?: s.Body | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toBody(root: jsonP.JSONValue): s.Body {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromMethod(input?: s.Method | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toMethod(root: jsonP.JSONValue): s.Method {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromJsonBody(input?: s.JsonBody | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MatchPattern: fromJsonMatchPattern(input["MatchPattern"]),
    MatchScope: input["MatchScope"],
    InvalidFallbackBehavior: input["InvalidFallbackBehavior"],
  }
}
function toJsonBody(root: jsonP.JSONValue): s.JsonBody {
  return jsonP.readObj({
    required: {
      "MatchPattern": toJsonMatchPattern,
      "MatchScope": (x: jsonP.JSONValue) => cmnP.readEnum<s.JsonMatchScope>(x),
    },
    optional: {
      "InvalidFallbackBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.BodyParsingFallbackBehavior>(x),
    },
  }, root);
}

function fromJsonMatchPattern(input?: s.JsonMatchPattern | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    All: fromAll(input["All"]),
    IncludedPaths: input["IncludedPaths"],
  }
}
function toJsonMatchPattern(root: jsonP.JSONValue): s.JsonMatchPattern {
  return jsonP.readObj({
    required: {},
    optional: {
      "All": toAll,
      "IncludedPaths": ["s"],
    },
  }, root);
}

function fromAll(input?: s.All | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAll(root: jsonP.JSONValue): s.All {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromTextTransformation(input?: s.TextTransformation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Priority: input["Priority"],
    Type: input["Type"],
  }
}
function toTextTransformation(root: jsonP.JSONValue): s.TextTransformation {
  return jsonP.readObj({
    required: {
      "Priority": "n",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TextTransformationType>(x),
    },
    optional: {},
  }, root);
}

function fromSqliMatchStatement(input?: s.SqliMatchStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toSqliMatchStatement(root: jsonP.JSONValue): s.SqliMatchStatement {
  return jsonP.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

function fromXssMatchStatement(input?: s.XssMatchStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toXssMatchStatement(root: jsonP.JSONValue): s.XssMatchStatement {
  return jsonP.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

function fromSizeConstraintStatement(input?: s.SizeConstraintStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    ComparisonOperator: input["ComparisonOperator"],
    Size: input["Size"],
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toSizeConstraintStatement(root: jsonP.JSONValue): s.SizeConstraintStatement {
  return jsonP.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "ComparisonOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.ComparisonOperator>(x),
      "Size": "n",
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

function fromGeoMatchStatement(input?: s.GeoMatchStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CountryCodes: input["CountryCodes"],
    ForwardedIPConfig: fromForwardedIPConfig(input["ForwardedIPConfig"]),
  }
}
function toGeoMatchStatement(root: jsonP.JSONValue): s.GeoMatchStatement {
  return jsonP.readObj({
    required: {},
    optional: {
      "CountryCodes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.CountryCode>(x)],
      "ForwardedIPConfig": toForwardedIPConfig,
    },
  }, root);
}

function fromForwardedIPConfig(input?: s.ForwardedIPConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HeaderName: input["HeaderName"],
    FallbackBehavior: input["FallbackBehavior"],
  }
}
function toForwardedIPConfig(root: jsonP.JSONValue): s.ForwardedIPConfig {
  return jsonP.readObj({
    required: {
      "HeaderName": "s",
      "FallbackBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FallbackBehavior>(x),
    },
    optional: {},
  }, root);
}

function fromRuleGroupReferenceStatement(input?: s.RuleGroupReferenceStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ARN: input["ARN"],
    ExcludedRules: input["ExcludedRules"]?.map(x => fromExcludedRule(x)),
  }
}
function toRuleGroupReferenceStatement(root: jsonP.JSONValue): s.RuleGroupReferenceStatement {
  return jsonP.readObj({
    required: {
      "ARN": "s",
    },
    optional: {
      "ExcludedRules": [toExcludedRule],
    },
  }, root);
}

function fromExcludedRule(input?: s.ExcludedRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
  }
}
function toExcludedRule(root: jsonP.JSONValue): s.ExcludedRule {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

function fromIPSetReferenceStatement(input?: s.IPSetReferenceStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ARN: input["ARN"],
    IPSetForwardedIPConfig: fromIPSetForwardedIPConfig(input["IPSetForwardedIPConfig"]),
  }
}
function toIPSetReferenceStatement(root: jsonP.JSONValue): s.IPSetReferenceStatement {
  return jsonP.readObj({
    required: {
      "ARN": "s",
    },
    optional: {
      "IPSetForwardedIPConfig": toIPSetForwardedIPConfig,
    },
  }, root);
}

function fromIPSetForwardedIPConfig(input?: s.IPSetForwardedIPConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HeaderName: input["HeaderName"],
    FallbackBehavior: input["FallbackBehavior"],
    Position: input["Position"],
  }
}
function toIPSetForwardedIPConfig(root: jsonP.JSONValue): s.IPSetForwardedIPConfig {
  return jsonP.readObj({
    required: {
      "HeaderName": "s",
      "FallbackBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.FallbackBehavior>(x),
      "Position": (x: jsonP.JSONValue) => cmnP.readEnum<s.ForwardedIPPosition>(x),
    },
    optional: {},
  }, root);
}

function fromRegexPatternSetReferenceStatement(input?: s.RegexPatternSetReferenceStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ARN: input["ARN"],
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toRegexPatternSetReferenceStatement(root: jsonP.JSONValue): s.RegexPatternSetReferenceStatement {
  return jsonP.readObj({
    required: {
      "ARN": "s",
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

function fromRateBasedStatement(input?: s.RateBasedStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Limit: input["Limit"],
    AggregateKeyType: input["AggregateKeyType"],
    ScopeDownStatement: fromStatement(input["ScopeDownStatement"]),
    ForwardedIPConfig: fromForwardedIPConfig(input["ForwardedIPConfig"]),
  }
}
function toRateBasedStatement(root: jsonP.JSONValue): s.RateBasedStatement {
  return jsonP.readObj({
    required: {
      "Limit": "n",
      "AggregateKeyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RateBasedStatementAggregateKeyType>(x),
    },
    optional: {
      "ScopeDownStatement": toStatement,
      "ForwardedIPConfig": toForwardedIPConfig,
    },
  }, root);
}

function fromAndStatement(input?: s.AndStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statements: input["Statements"]?.map(x => fromStatement(x)),
  }
}
function toAndStatement(root: jsonP.JSONValue): s.AndStatement {
  return jsonP.readObj({
    required: {
      "Statements": [toStatement],
    },
    optional: {},
  }, root);
}

function fromOrStatement(input?: s.OrStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statements: input["Statements"]?.map(x => fromStatement(x)),
  }
}
function toOrStatement(root: jsonP.JSONValue): s.OrStatement {
  return jsonP.readObj({
    required: {
      "Statements": [toStatement],
    },
    optional: {},
  }, root);
}

function fromNotStatement(input?: s.NotStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statement: fromStatement(input["Statement"]),
  }
}
function toNotStatement(root: jsonP.JSONValue): s.NotStatement {
  return jsonP.readObj({
    required: {
      "Statement": toStatement,
    },
    optional: {},
  }, root);
}

function fromManagedRuleGroupStatement(input?: s.ManagedRuleGroupStatement | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VendorName: input["VendorName"],
    Name: input["Name"],
    ExcludedRules: input["ExcludedRules"]?.map(x => fromExcludedRule(x)),
  }
}
function toManagedRuleGroupStatement(root: jsonP.JSONValue): s.ManagedRuleGroupStatement {
  return jsonP.readObj({
    required: {
      "VendorName": "s",
      "Name": "s",
    },
    optional: {
      "ExcludedRules": [toExcludedRule],
    },
  }, root);
}

function fromRuleAction(input?: s.RuleAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Block: fromBlockAction(input["Block"]),
    Allow: fromAllowAction(input["Allow"]),
    Count: fromCountAction(input["Count"]),
  }
}
function toRuleAction(root: jsonP.JSONValue): s.RuleAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Block": toBlockAction,
      "Allow": toAllowAction,
      "Count": toCountAction,
    },
  }, root);
}

function fromBlockAction(input?: s.BlockAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toBlockAction(root: jsonP.JSONValue): s.BlockAction {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromAllowAction(input?: s.AllowAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toAllowAction(root: jsonP.JSONValue): s.AllowAction {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromCountAction(input?: s.CountAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toCountAction(root: jsonP.JSONValue): s.CountAction {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromOverrideAction(input?: s.OverrideAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Count: fromCountAction(input["Count"]),
    None: fromNoneAction(input["None"]),
  }
}
function toOverrideAction(root: jsonP.JSONValue): s.OverrideAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Count": toCountAction,
      "None": toNoneAction,
    },
  }, root);
}

function fromNoneAction(input?: s.NoneAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
  }
}
function toNoneAction(root: jsonP.JSONValue): s.NoneAction {
  return jsonP.readObj({
    required: {},
    optional: {},
  }, root);
}

function fromVisibilityConfig(input?: s.VisibilityConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SampledRequestsEnabled: input["SampledRequestsEnabled"],
    CloudWatchMetricsEnabled: input["CloudWatchMetricsEnabled"],
    MetricName: input["MetricName"],
  }
}
function toVisibilityConfig(root: jsonP.JSONValue): s.VisibilityConfig {
  return jsonP.readObj({
    required: {
      "SampledRequestsEnabled": "b",
      "CloudWatchMetricsEnabled": "b",
      "MetricName": "s",
    },
    optional: {},
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromRegex(input?: s.Regex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegexString: input["RegexString"],
  }
}
function toRegex(root: jsonP.JSONValue): s.Regex {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegexString": "s",
    },
  }, root);
}

function fromDefaultAction(input?: s.DefaultAction | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Block: fromBlockAction(input["Block"]),
    Allow: fromAllowAction(input["Allow"]),
  }
}
function toDefaultAction(root: jsonP.JSONValue): s.DefaultAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "Block": toBlockAction,
      "Allow": toAllowAction,
    },
  }, root);
}

function fromTimeWindow(input?: s.TimeWindow | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTime: jsonP.serializeDate_unixTimestamp(input["StartTime"]),
    EndTime: jsonP.serializeDate_unixTimestamp(input["EndTime"]),
  }
}
function toTimeWindow(root: jsonP.JSONValue): s.TimeWindow {
  return jsonP.readObj({
    required: {
      "StartTime": "d",
      "EndTime": "d",
    },
    optional: {},
  }, root);
}

function fromLoggingConfiguration(input?: s.LoggingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceArn: input["ResourceArn"],
    LogDestinationConfigs: input["LogDestinationConfigs"],
    RedactedFields: input["RedactedFields"]?.map(x => fromFieldToMatch(x)),
    ManagedByFirewallManager: input["ManagedByFirewallManager"],
  }
}
function toLoggingConfiguration(root: jsonP.JSONValue): s.LoggingConfiguration {
  return jsonP.readObj({
    required: {
      "ResourceArn": "s",
      "LogDestinationConfigs": ["s"],
    },
    optional: {
      "RedactedFields": [toFieldToMatch],
      "ManagedByFirewallManager": "b",
    },
  }, root);
}

function toIPSetSummary(root: jsonP.JSONValue): s.IPSetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

function toRegexPatternSetSummary(root: jsonP.JSONValue): s.RegexPatternSetSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

function toRuleGroupSummary(root: jsonP.JSONValue): s.RuleGroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

function toWebACLSummary(root: jsonP.JSONValue): s.WebACLSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

function toRuleSummary(root: jsonP.JSONValue): s.RuleSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Action": toRuleAction,
    },
  }, root);
}

function toIPSet(root: jsonP.JSONValue): s.IPSet {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "IPAddressVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.IPAddressVersion>(x),
      "Addresses": ["s"],
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

function toRateBasedStatementManagedKeysIPSet(root: jsonP.JSONValue): s.RateBasedStatementManagedKeysIPSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "IPAddressVersion": (x: jsonP.JSONValue) => cmnP.readEnum<s.IPAddressVersion>(x),
      "Addresses": ["s"],
    },
  }, root);
}

function toRegexPatternSet(root: jsonP.JSONValue): s.RegexPatternSet {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "Description": "s",
      "RegularExpressionList": [toRegex],
    },
  }, root);
}

function toRuleGroup(root: jsonP.JSONValue): s.RuleGroup {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "Capacity": "n",
      "ARN": "s",
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Description": "s",
      "Rules": [toRule],
    },
  }, root);
}

function toSampledHTTPRequest(root: jsonP.JSONValue): s.SampledHTTPRequest {
  return jsonP.readObj({
    required: {
      "Request": toHTTPRequest,
      "Weight": "n",
    },
    optional: {
      "Timestamp": "d",
      "Action": "s",
      "RuleNameWithinRuleGroup": "s",
    },
  }, root);
}

function toHTTPRequest(root: jsonP.JSONValue): s.HTTPRequest {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientIP": "s",
      "Country": "s",
      "URI": "s",
      "Method": "s",
      "HTTPVersion": "s",
      "Headers": [toHTTPHeader],
    },
  }, root);
}

function toHTTPHeader(root: jsonP.JSONValue): s.HTTPHeader {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Value": "s",
    },
  }, root);
}

function toWebACL(root: jsonP.JSONValue): s.WebACL {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "DefaultAction": toDefaultAction,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Description": "s",
      "Rules": [toRule],
      "Capacity": "n",
      "PreProcessFirewallManagerRuleGroups": [toFirewallManagerRuleGroup],
      "PostProcessFirewallManagerRuleGroups": [toFirewallManagerRuleGroup],
      "ManagedByFirewallManager": "b",
    },
  }, root);
}

function toFirewallManagerRuleGroup(root: jsonP.JSONValue): s.FirewallManagerRuleGroup {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Priority": "n",
      "FirewallManagerStatement": toFirewallManagerStatement,
      "OverrideAction": toOverrideAction,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {},
  }, root);
}

function toFirewallManagerStatement(root: jsonP.JSONValue): s.FirewallManagerStatement {
  return jsonP.readObj({
    required: {},
    optional: {
      "ManagedRuleGroupStatement": toManagedRuleGroupStatement,
      "RuleGroupReferenceStatement": toRuleGroupReferenceStatement,
    },
  }, root);
}

function toManagedRuleGroupSummary(root: jsonP.JSONValue): s.ManagedRuleGroupSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "VendorName": "s",
      "Name": "s",
      "Description": "s",
    },
  }, root);
}

function toTagInfoForResource(root: jsonP.JSONValue): s.TagInfoForResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "TagList": [toTag],
    },
  }, root);
}
