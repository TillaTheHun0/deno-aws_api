// Autogenerated API client for: AWS WAFV2

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class WAFV2 {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(WAFV2.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2019-07-29",
    "endpointPrefix": "wafv2",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "WAFV2",
    "serviceFullName": "AWS WAFV2",
    "serviceId": "WAFV2",
    "signatureVersion": "v4",
    "targetPrefix": "AWSWAF_20190729",
    "uid": "wafv2-2019-07-29"
  };

  async associateWebACL(
    {abortSignal, ...params}: RequestConfig & AssociateWebACLRequest,
  ): Promise<AssociateWebACLResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async checkCapacity(
    {abortSignal, ...params}: RequestConfig & CheckCapacityRequest,
  ): Promise<CheckCapacityResponse> {
    const body: JSONObject = {...params,
    Rules: params["Rules"]?.map(x => fromRule(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CheckCapacity",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Capacity": "n",
      },
    }, await resp.json());
  }

  async createIPSet(
    {abortSignal, ...params}: RequestConfig & CreateIPSetRequest,
  ): Promise<CreateIPSetResponse> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateIPSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Summary": toIPSetSummary,
      },
    }, await resp.json());
  }

  async createRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & CreateRegexPatternSetRequest,
  ): Promise<CreateRegexPatternSetResponse> {
    const body: JSONObject = {...params,
    RegularExpressionList: params["RegularExpressionList"]?.map(x => fromRegex(x)),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRegexPatternSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Summary": toRegexPatternSetSummary,
      },
    }, await resp.json());
  }

  async createRuleGroup(
    {abortSignal, ...params}: RequestConfig & CreateRuleGroupRequest,
  ): Promise<CreateRuleGroupResponse> {
    const body: JSONObject = {...params,
    Rules: params["Rules"]?.map(x => fromRule(x)),
    VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRuleGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Summary": toRuleGroupSummary,
      },
    }, await resp.json());
  }

  async createWebACL(
    {abortSignal, ...params}: RequestConfig & CreateWebACLRequest,
  ): Promise<CreateWebACLResponse> {
    const body: JSONObject = {...params,
    DefaultAction: fromDefaultAction(params["DefaultAction"]),
    Rules: params["Rules"]?.map(x => fromRule(x)),
    VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Summary": toWebACLSummary,
      },
    }, await resp.json());
  }

  async deleteFirewallManagerRuleGroups(
    {abortSignal, ...params}: RequestConfig & DeleteFirewallManagerRuleGroupsRequest,
  ): Promise<DeleteFirewallManagerRuleGroupsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFirewallManagerRuleGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextWebACLLockToken": "s",
      },
    }, await resp.json());
  }

  async deleteIPSet(
    {abortSignal, ...params}: RequestConfig & DeleteIPSetRequest,
  ): Promise<DeleteIPSetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteIPSet",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteLoggingConfigurationRequest,
  ): Promise<DeleteLoggingConfigurationResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLoggingConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePermissionPolicy(
    {abortSignal, ...params}: RequestConfig & DeletePermissionPolicyRequest,
  ): Promise<DeletePermissionPolicyResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePermissionPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & DeleteRegexPatternSetRequest,
  ): Promise<DeleteRegexPatternSetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRegexPatternSet",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRuleGroup(
    {abortSignal, ...params}: RequestConfig & DeleteRuleGroupRequest,
  ): Promise<DeleteRuleGroupResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRuleGroup",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWebACL(
    {abortSignal, ...params}: RequestConfig & DeleteWebACLRequest,
  ): Promise<DeleteWebACLResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeManagedRuleGroup(
    {abortSignal, ...params}: RequestConfig & DescribeManagedRuleGroupRequest,
  ): Promise<DescribeManagedRuleGroupResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeManagedRuleGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Capacity": "n",
        "Rules": [toRuleSummary],
      },
    }, await resp.json());
  }

  async disassociateWebACL(
    {abortSignal, ...params}: RequestConfig & DisassociateWebACLRequest,
  ): Promise<DisassociateWebACLResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getIPSet(
    {abortSignal, ...params}: RequestConfig & GetIPSetRequest,
  ): Promise<GetIPSetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetIPSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "IPSet": toIPSet,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & GetLoggingConfigurationRequest,
  ): Promise<GetLoggingConfigurationResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLoggingConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {
        "LoggingConfiguration": toLoggingConfiguration,
      },
    }, await resp.json());
  }

  async getPermissionPolicy(
    {abortSignal, ...params}: RequestConfig & GetPermissionPolicyRequest,
  ): Promise<GetPermissionPolicyResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPermissionPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {
        "Policy": "s",
      },
    }, await resp.json());
  }

  async getRateBasedStatementManagedKeys(
    {abortSignal, ...params}: RequestConfig & GetRateBasedStatementManagedKeysRequest,
  ): Promise<GetRateBasedStatementManagedKeysResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRateBasedStatementManagedKeys",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ManagedKeysIPV4": toRateBasedStatementManagedKeysIPSet,
        "ManagedKeysIPV6": toRateBasedStatementManagedKeysIPSet,
      },
    }, await resp.json());
  }

  async getRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & GetRegexPatternSetRequest,
  ): Promise<GetRegexPatternSetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegexPatternSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "RegexPatternSet": toRegexPatternSet,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getRuleGroup(
    {abortSignal, ...params}: RequestConfig & GetRuleGroupRequest,
  ): Promise<GetRuleGroupResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRuleGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "RuleGroup": toRuleGroup,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getSampledRequests(
    {abortSignal, ...params}: RequestConfig & GetSampledRequestsRequest,
  ): Promise<GetSampledRequestsResponse> {
    const body: JSONObject = {...params,
    TimeWindow: fromTimeWindow(params["TimeWindow"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSampledRequests",
    });
    return prt.readObj({
      required: {},
      optional: {
        "SampledRequests": [toSampledHTTPRequest],
        "PopulationSize": "n",
        "TimeWindow": toTimeWindow,
      },
    }, await resp.json());
  }

  async getWebACL(
    {abortSignal, ...params}: RequestConfig & GetWebACLRequest,
  ): Promise<GetWebACLResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {
        "WebACL": toWebACL,
        "LockToken": "s",
      },
    }, await resp.json());
  }

  async getWebACLForResource(
    {abortSignal, ...params}: RequestConfig & GetWebACLForResourceRequest,
  ): Promise<GetWebACLForResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWebACLForResource",
    });
    return prt.readObj({
      required: {},
      optional: {
        "WebACL": toWebACL,
      },
    }, await resp.json());
  }

  async listAvailableManagedRuleGroups(
    {abortSignal, ...params}: RequestConfig & ListAvailableManagedRuleGroupsRequest,
  ): Promise<ListAvailableManagedRuleGroupsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAvailableManagedRuleGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "ManagedRuleGroups": [toManagedRuleGroupSummary],
      },
    }, await resp.json());
  }

  async listIPSets(
    {abortSignal, ...params}: RequestConfig & ListIPSetsRequest,
  ): Promise<ListIPSetsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListIPSets",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "IPSets": [toIPSetSummary],
      },
    }, await resp.json());
  }

  async listLoggingConfigurations(
    {abortSignal, ...params}: RequestConfig & ListLoggingConfigurationsRequest = {},
  ): Promise<ListLoggingConfigurationsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLoggingConfigurations",
    });
    return prt.readObj({
      required: {},
      optional: {
        "LoggingConfigurations": [toLoggingConfiguration],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listRegexPatternSets(
    {abortSignal, ...params}: RequestConfig & ListRegexPatternSetsRequest,
  ): Promise<ListRegexPatternSetsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRegexPatternSets",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "RegexPatternSets": [toRegexPatternSetSummary],
      },
    }, await resp.json());
  }

  async listResourcesForWebACL(
    {abortSignal, ...params}: RequestConfig & ListResourcesForWebACLRequest,
  ): Promise<ListResourcesForWebACLResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListResourcesForWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {
        "ResourceArns": ["s"],
      },
    }, await resp.json());
  }

  async listRuleGroups(
    {abortSignal, ...params}: RequestConfig & ListRuleGroupsRequest,
  ): Promise<ListRuleGroupsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRuleGroups",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "RuleGroups": [toRuleGroupSummary],
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "TagInfoForResource": toTagInfoForResource,
      },
    }, await resp.json());
  }

  async listWebACLs(
    {abortSignal, ...params}: RequestConfig & ListWebACLsRequest,
  ): Promise<ListWebACLsResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWebACLs",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "WebACLs": [toWebACLSummary],
      },
    }, await resp.json());
  }

  async putLoggingConfiguration(
    {abortSignal, ...params}: RequestConfig & PutLoggingConfigurationRequest,
  ): Promise<PutLoggingConfigurationResponse> {
    const body: JSONObject = {...params,
    LoggingConfiguration: fromLoggingConfiguration(params["LoggingConfiguration"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLoggingConfiguration",
    });
    return prt.readObj({
      required: {},
      optional: {
        "LoggingConfiguration": toLoggingConfiguration,
      },
    }, await resp.json());
  }

  async putPermissionPolicy(
    {abortSignal, ...params}: RequestConfig & PutPermissionPolicyRequest,
  ): Promise<PutPermissionPolicyResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPermissionPolicy",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: JSONObject = {...params,
    Tags: params["Tags"]?.map(x => fromTag(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return prt.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateIPSet(
    {abortSignal, ...params}: RequestConfig & UpdateIPSetRequest,
  ): Promise<UpdateIPSetResponse> {
    const body: JSONObject = {...params,
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateIPSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateRegexPatternSet(
    {abortSignal, ...params}: RequestConfig & UpdateRegexPatternSetRequest,
  ): Promise<UpdateRegexPatternSetResponse> {
    const body: JSONObject = {...params,
    RegularExpressionList: params["RegularExpressionList"]?.map(x => fromRegex(x)),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRegexPatternSet",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateRuleGroup(
    {abortSignal, ...params}: RequestConfig & UpdateRuleGroupRequest,
  ): Promise<UpdateRuleGroupResponse> {
    const body: JSONObject = {...params,
    Rules: params["Rules"]?.map(x => fromRule(x)),
    VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuleGroup",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

  async updateWebACL(
    {abortSignal, ...params}: RequestConfig & UpdateWebACLRequest,
  ): Promise<UpdateWebACLResponse> {
    const body: JSONObject = {...params,
    DefaultAction: fromDefaultAction(params["DefaultAction"]),
    Rules: params["Rules"]?.map(x => fromRule(x)),
    VisibilityConfig: fromVisibilityConfig(params["VisibilityConfig"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWebACL",
    });
    return prt.readObj({
      required: {},
      optional: {
        "NextLockToken": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AssociateWebACLRequest {
  WebACLArn: string;
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface CheckCapacityRequest {
  Scope: Scope;
  Rules: Rule[];
}

// refs: 1 - tags: named, input
export interface CreateIPSetRequest {
  Name: string;
  Scope: Scope;
  Description?: string | null;
  IPAddressVersion: IPAddressVersion;
  Addresses: string[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateRegexPatternSetRequest {
  Name: string;
  Scope: Scope;
  Description?: string | null;
  RegularExpressionList: Regex[];
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateRuleGroupRequest {
  Name: string;
  Scope: Scope;
  Capacity: number;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateWebACLRequest {
  Name: string;
  Scope: Scope;
  DefaultAction: DefaultAction;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteFirewallManagerRuleGroupsRequest {
  WebACLArn: string;
  WebACLLockToken: string;
}

// refs: 1 - tags: named, input
export interface DeleteIPSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface DeleteLoggingConfigurationRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface DeletePermissionPolicyRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface DeleteRegexPatternSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface DeleteRuleGroupRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface DeleteWebACLRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface DescribeManagedRuleGroupRequest {
  VendorName: string;
  Name: string;
  Scope: Scope;
}

// refs: 1 - tags: named, input
export interface DisassociateWebACLRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface GetIPSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetLoggingConfigurationRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface GetPermissionPolicyRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface GetRateBasedStatementManagedKeysRequest {
  Scope: Scope;
  WebACLName: string;
  WebACLId: string;
  RuleName: string;
}

// refs: 1 - tags: named, input
export interface GetRegexPatternSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetRuleGroupRequest {
  Name: string;
  Scope: Scope;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetSampledRequestsRequest {
  WebAclArn: string;
  RuleMetricName: string;
  Scope: Scope;
  TimeWindow: TimeWindow;
  MaxItems: number;
}

// refs: 1 - tags: named, input
export interface GetWebACLRequest {
  Name: string;
  Scope: Scope;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetWebACLForResourceRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface ListAvailableManagedRuleGroupsRequest {
  Scope: Scope;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListIPSetsRequest {
  Scope: Scope;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListLoggingConfigurationsRequest {
  Scope?: Scope | null;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListRegexPatternSetsRequest {
  Scope: Scope;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListResourcesForWebACLRequest {
  WebACLArn: string;
  ResourceType?: ResourceType | null;
}

// refs: 1 - tags: named, input
export interface ListRuleGroupsRequest {
  Scope: Scope;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  NextMarker?: string | null;
  Limit?: number | null;
  ResourceARN: string;
}

// refs: 1 - tags: named, input
export interface ListWebACLsRequest {
  Scope: Scope;
  NextMarker?: string | null;
  Limit?: number | null;
}

// refs: 1 - tags: named, input
export interface PutLoggingConfigurationRequest {
  LoggingConfiguration: LoggingConfiguration;
}

// refs: 1 - tags: named, input
export interface PutPermissionPolicyRequest {
  ResourceArn: string;
  Policy: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateIPSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  Description?: string | null;
  Addresses: string[];
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface UpdateRegexPatternSetRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  Description?: string | null;
  RegularExpressionList: Regex[];
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface UpdateRuleGroupRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
  LockToken: string;
}

// refs: 1 - tags: named, input
export interface UpdateWebACLRequest {
  Name: string;
  Scope: Scope;
  Id: string;
  DefaultAction: DefaultAction;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
  LockToken: string;
}

// refs: 1 - tags: named, output
export interface AssociateWebACLResponse {
}

// refs: 1 - tags: named, output
export interface CheckCapacityResponse {
  Capacity?: number | null;
}

// refs: 1 - tags: named, output
export interface CreateIPSetResponse {
  Summary?: IPSetSummary | null;
}

// refs: 1 - tags: named, output
export interface CreateRegexPatternSetResponse {
  Summary?: RegexPatternSetSummary | null;
}

// refs: 1 - tags: named, output
export interface CreateRuleGroupResponse {
  Summary?: RuleGroupSummary | null;
}

// refs: 1 - tags: named, output
export interface CreateWebACLResponse {
  Summary?: WebACLSummary | null;
}

// refs: 1 - tags: named, output
export interface DeleteFirewallManagerRuleGroupsResponse {
  NextWebACLLockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteIPSetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteLoggingConfigurationResponse {
}

// refs: 1 - tags: named, output
export interface DeletePermissionPolicyResponse {
}

// refs: 1 - tags: named, output
export interface DeleteRegexPatternSetResponse {
}

// refs: 1 - tags: named, output
export interface DeleteRuleGroupResponse {
}

// refs: 1 - tags: named, output
export interface DeleteWebACLResponse {
}

// refs: 1 - tags: named, output
export interface DescribeManagedRuleGroupResponse {
  Capacity?: number | null;
  Rules?: RuleSummary[] | null;
}

// refs: 1 - tags: named, output
export interface DisassociateWebACLResponse {
}

// refs: 1 - tags: named, output
export interface GetIPSetResponse {
  IPSet?: IPSet | null;
  LockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetLoggingConfigurationResponse {
  LoggingConfiguration?: LoggingConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetPermissionPolicyResponse {
  Policy?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRateBasedStatementManagedKeysResponse {
  ManagedKeysIPV4?: RateBasedStatementManagedKeysIPSet | null;
  ManagedKeysIPV6?: RateBasedStatementManagedKeysIPSet | null;
}

// refs: 1 - tags: named, output
export interface GetRegexPatternSetResponse {
  RegexPatternSet?: RegexPatternSet | null;
  LockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRuleGroupResponse {
  RuleGroup?: RuleGroup | null;
  LockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSampledRequestsResponse {
  SampledRequests?: SampledHTTPRequest[] | null;
  PopulationSize?: number | null;
  TimeWindow?: TimeWindow | null;
}

// refs: 1 - tags: named, output
export interface GetWebACLResponse {
  WebACL?: WebACL | null;
  LockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetWebACLForResourceResponse {
  WebACL?: WebACL | null;
}

// refs: 1 - tags: named, output
export interface ListAvailableManagedRuleGroupsResponse {
  NextMarker?: string | null;
  ManagedRuleGroups?: ManagedRuleGroupSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListIPSetsResponse {
  NextMarker?: string | null;
  IPSets?: IPSetSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListLoggingConfigurationsResponse {
  LoggingConfigurations?: LoggingConfiguration[] | null;
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRegexPatternSetsResponse {
  NextMarker?: string | null;
  RegexPatternSets?: RegexPatternSetSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListResourcesForWebACLResponse {
  ResourceArns?: string[] | null;
}

// refs: 1 - tags: named, output
export interface ListRuleGroupsResponse {
  NextMarker?: string | null;
  RuleGroups?: RuleGroupSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  NextMarker?: string | null;
  TagInfoForResource?: TagInfoForResource | null;
}

// refs: 1 - tags: named, output
export interface ListWebACLsResponse {
  NextMarker?: string | null;
  WebACLs?: WebACLSummary[] | null;
}

// refs: 1 - tags: named, output
export interface PutLoggingConfigurationResponse {
  LoggingConfiguration?: LoggingConfiguration | null;
}

// refs: 1 - tags: named, output
export interface PutPermissionPolicyResponse {
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateIPSetResponse {
  NextLockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateRegexPatternSetResponse {
  NextLockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateRuleGroupResponse {
  NextLockToken?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateWebACLResponse {
  NextLockToken?: string | null;
}

// refs: 26 - tags: input, named, enum
export type Scope =
| "CLOUDFRONT"
| "REGIONAL"
;


// refs: 8 - tags: input, named, interface, output
export interface Rule {
  Name: string;
  Priority: number;
  Statement: Statement;
  Action?: RuleAction | null;
  OverrideAction?: OverrideAction | null;
  VisibilityConfig: VisibilityConfig;
}
function fromRule(input?: Rule | null): JSONValue {
  if (!input) return input;
  return {...input,
    Statement: fromStatement(input["Statement"]),
    Action: fromRuleAction(input["Action"]),
    OverrideAction: fromOverrideAction(input["OverrideAction"]),
    VisibilityConfig: fromVisibilityConfig(input["VisibilityConfig"]),
  }
}
function toRule(root: JSONValue): Rule {
  return prt.readObj({
    required: {
      "Name": "s",
      "Priority": "n",
      "Statement": toStatement,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Action": toRuleAction,
      "OverrideAction": toOverrideAction,
    },
  }, root);
}

// refs: 40 - tags: input, named, interface, recursed, output
export interface Statement {
  ByteMatchStatement?: ByteMatchStatement | null;
  SqliMatchStatement?: SqliMatchStatement | null;
  XssMatchStatement?: XssMatchStatement | null;
  SizeConstraintStatement?: SizeConstraintStatement | null;
  GeoMatchStatement?: GeoMatchStatement | null;
  RuleGroupReferenceStatement?: RuleGroupReferenceStatement | null;
  IPSetReferenceStatement?: IPSetReferenceStatement | null;
  RegexPatternSetReferenceStatement?: RegexPatternSetReferenceStatement | null;
  RateBasedStatement?: RateBasedStatement | null;
  AndStatement?: AndStatement | null;
  OrStatement?: OrStatement | null;
  NotStatement?: NotStatement | null;
  ManagedRuleGroupStatement?: ManagedRuleGroupStatement | null;
}
function fromStatement(input?: Statement | null): JSONValue {
  if (!input) return input;
  return {...input,
    ByteMatchStatement: fromByteMatchStatement(input["ByteMatchStatement"]),
    SqliMatchStatement: fromSqliMatchStatement(input["SqliMatchStatement"]),
    XssMatchStatement: fromXssMatchStatement(input["XssMatchStatement"]),
    SizeConstraintStatement: fromSizeConstraintStatement(input["SizeConstraintStatement"]),
    GeoMatchStatement: fromGeoMatchStatement(input["GeoMatchStatement"]),
    RuleGroupReferenceStatement: fromRuleGroupReferenceStatement(input["RuleGroupReferenceStatement"]),
    IPSetReferenceStatement: fromIPSetReferenceStatement(input["IPSetReferenceStatement"]),
    RegexPatternSetReferenceStatement: fromRegexPatternSetReferenceStatement(input["RegexPatternSetReferenceStatement"]),
    RateBasedStatement: fromRateBasedStatement(input["RateBasedStatement"]),
    AndStatement: fromAndStatement(input["AndStatement"]),
    OrStatement: fromOrStatement(input["OrStatement"]),
    NotStatement: fromNotStatement(input["NotStatement"]),
    ManagedRuleGroupStatement: fromManagedRuleGroupStatement(input["ManagedRuleGroupStatement"]),
  }
}
function toStatement(root: JSONValue): Statement {
  return prt.readObj({
    required: {},
    optional: {
      "ByteMatchStatement": toByteMatchStatement,
      "SqliMatchStatement": toSqliMatchStatement,
      "XssMatchStatement": toXssMatchStatement,
      "SizeConstraintStatement": toSizeConstraintStatement,
      "GeoMatchStatement": toGeoMatchStatement,
      "RuleGroupReferenceStatement": toRuleGroupReferenceStatement,
      "IPSetReferenceStatement": toIPSetReferenceStatement,
      "RegexPatternSetReferenceStatement": toRegexPatternSetReferenceStatement,
      "RateBasedStatement": toRateBasedStatement,
      "AndStatement": toAndStatement,
      "OrStatement": toOrStatement,
      "NotStatement": toNotStatement,
      "ManagedRuleGroupStatement": toManagedRuleGroupStatement,
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface ByteMatchStatement {
  SearchString: Uint8Array | string;
  FieldToMatch: FieldToMatch;
  TextTransformations: TextTransformation[];
  PositionalConstraint: PositionalConstraint;
}
function fromByteMatchStatement(input?: ByteMatchStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    SearchString: prt.serializeBlob(input["SearchString"]),
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toByteMatchStatement(root: JSONValue): ByteMatchStatement {
  return prt.readObj({
    required: {
      "SearchString": "a",
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
      "PositionalConstraint": toPositionalConstraint,
    },
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface FieldToMatch {
  SingleHeader?: SingleHeader | null;
  SingleQueryArgument?: SingleQueryArgument | null;
  AllQueryArguments?: AllQueryArguments | null;
  UriPath?: UriPath | null;
  QueryString?: QueryString | null;
  Body?: Body | null;
  Method?: Method | null;
}
function fromFieldToMatch(input?: FieldToMatch | null): JSONValue {
  if (!input) return input;
  return {...input,
    SingleHeader: fromSingleHeader(input["SingleHeader"]),
    SingleQueryArgument: fromSingleQueryArgument(input["SingleQueryArgument"]),
    AllQueryArguments: fromAllQueryArguments(input["AllQueryArguments"]),
    UriPath: fromUriPath(input["UriPath"]),
    QueryString: fromQueryString(input["QueryString"]),
    Body: fromBody(input["Body"]),
    Method: fromMethod(input["Method"]),
  }
}
function toFieldToMatch(root: JSONValue): FieldToMatch {
  return prt.readObj({
    required: {},
    optional: {
      "SingleHeader": toSingleHeader,
      "SingleQueryArgument": toSingleQueryArgument,
      "AllQueryArguments": toAllQueryArguments,
      "UriPath": toUriPath,
      "QueryString": toQueryString,
      "Body": toBody,
      "Method": toMethod,
    },
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface SingleHeader {
  Name: string;
}
function fromSingleHeader(input?: SingleHeader | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSingleHeader(root: JSONValue): SingleHeader {
  return prt.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface SingleQueryArgument {
  Name: string;
}
function fromSingleQueryArgument(input?: SingleQueryArgument | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toSingleQueryArgument(root: JSONValue): SingleQueryArgument {
  return prt.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface AllQueryArguments {
}
function fromAllQueryArguments(input?: AllQueryArguments | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toAllQueryArguments(root: JSONValue): AllQueryArguments {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface UriPath {
}
function fromUriPath(input?: UriPath | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toUriPath(root: JSONValue): UriPath {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface QueryString {
}
function fromQueryString(input?: QueryString | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toQueryString(root: JSONValue): QueryString {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface Body {
}
function fromBody(input?: Body | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toBody(root: JSONValue): Body {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 44 - tags: input, named, interface, output
export interface Method {
}
function fromMethod(input?: Method | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toMethod(root: JSONValue): Method {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 40 - tags: input, named, interface, output
export interface TextTransformation {
  Priority: number;
  Type: TextTransformationType;
}
function fromTextTransformation(input?: TextTransformation | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTextTransformation(root: JSONValue): TextTransformation {
  return prt.readObj({
    required: {
      "Priority": "n",
      "Type": toTextTransformationType,
    },
    optional: {},
  }, root);
}

// refs: 40 - tags: input, named, enum, output
export type TextTransformationType =
| "NONE"
| "COMPRESS_WHITE_SPACE"
| "HTML_ENTITY_DECODE"
| "LOWERCASE"
| "CMD_LINE"
| "URL_DECODE"
;

function toTextTransformationType(root: JSONValue): TextTransformationType | null {
  return ( false
    || root == "NONE"
    || root == "COMPRESS_WHITE_SPACE"
    || root == "HTML_ENTITY_DECODE"
    || root == "LOWERCASE"
    || root == "CMD_LINE"
    || root == "URL_DECODE"
  ) ? root : null;
}

// refs: 8 - tags: input, named, enum, output
export type PositionalConstraint =
| "EXACTLY"
| "STARTS_WITH"
| "ENDS_WITH"
| "CONTAINS"
| "CONTAINS_WORD"
;

function toPositionalConstraint(root: JSONValue): PositionalConstraint | null {
  return ( false
    || root == "EXACTLY"
    || root == "STARTS_WITH"
    || root == "ENDS_WITH"
    || root == "CONTAINS"
    || root == "CONTAINS_WORD"
  ) ? root : null;
}

// refs: 8 - tags: input, named, interface, output
export interface SqliMatchStatement {
  FieldToMatch: FieldToMatch;
  TextTransformations: TextTransformation[];
}
function fromSqliMatchStatement(input?: SqliMatchStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toSqliMatchStatement(root: JSONValue): SqliMatchStatement {
  return prt.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface XssMatchStatement {
  FieldToMatch: FieldToMatch;
  TextTransformations: TextTransformation[];
}
function fromXssMatchStatement(input?: XssMatchStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toXssMatchStatement(root: JSONValue): XssMatchStatement {
  return prt.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface SizeConstraintStatement {
  FieldToMatch: FieldToMatch;
  ComparisonOperator: ComparisonOperator;
  Size: number;
  TextTransformations: TextTransformation[];
}
function fromSizeConstraintStatement(input?: SizeConstraintStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toSizeConstraintStatement(root: JSONValue): SizeConstraintStatement {
  return prt.readObj({
    required: {
      "FieldToMatch": toFieldToMatch,
      "ComparisonOperator": toComparisonOperator,
      "Size": "n",
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type ComparisonOperator =
| "EQ"
| "NE"
| "LE"
| "LT"
| "GE"
| "GT"
;

function toComparisonOperator(root: JSONValue): ComparisonOperator | null {
  return ( false
    || root == "EQ"
    || root == "NE"
    || root == "LE"
    || root == "LT"
    || root == "GE"
    || root == "GT"
  ) ? root : null;
}

// refs: 8 - tags: input, named, interface, output
export interface GeoMatchStatement {
  CountryCodes?: CountryCode[] | null;
  ForwardedIPConfig?: ForwardedIPConfig | null;
}
function fromGeoMatchStatement(input?: GeoMatchStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    ForwardedIPConfig: fromForwardedIPConfig(input["ForwardedIPConfig"]),
  }
}
function toGeoMatchStatement(root: JSONValue): GeoMatchStatement {
  return prt.readObj({
    required: {},
    optional: {
      "CountryCodes": [toCountryCode],
      "ForwardedIPConfig": toForwardedIPConfig,
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type CountryCode =
| "AF"
| "AX"
| "AL"
| "DZ"
| "AS"
| "AD"
| "AO"
| "AI"
| "AQ"
| "AG"
| "AR"
| "AM"
| "AW"
| "AU"
| "AT"
| "AZ"
| "BS"
| "BH"
| "BD"
| "BB"
| "BY"
| "BE"
| "BZ"
| "BJ"
| "BM"
| "BT"
| "BO"
| "BQ"
| "BA"
| "BW"
| "BV"
| "BR"
| "IO"
| "BN"
| "BG"
| "BF"
| "BI"
| "KH"
| "CM"
| "CA"
| "CV"
| "KY"
| "CF"
| "TD"
| "CL"
| "CN"
| "CX"
| "CC"
| "CO"
| "KM"
| "CG"
| "CD"
| "CK"
| "CR"
| "CI"
| "HR"
| "CU"
| "CW"
| "CY"
| "CZ"
| "DK"
| "DJ"
| "DM"
| "DO"
| "EC"
| "EG"
| "SV"
| "GQ"
| "ER"
| "EE"
| "ET"
| "FK"
| "FO"
| "FJ"
| "FI"
| "FR"
| "GF"
| "PF"
| "TF"
| "GA"
| "GM"
| "GE"
| "DE"
| "GH"
| "GI"
| "GR"
| "GL"
| "GD"
| "GP"
| "GU"
| "GT"
| "GG"
| "GN"
| "GW"
| "GY"
| "HT"
| "HM"
| "VA"
| "HN"
| "HK"
| "HU"
| "IS"
| "IN"
| "ID"
| "IR"
| "IQ"
| "IE"
| "IM"
| "IL"
| "IT"
| "JM"
| "JP"
| "JE"
| "JO"
| "KZ"
| "KE"
| "KI"
| "KP"
| "KR"
| "KW"
| "KG"
| "LA"
| "LV"
| "LB"
| "LS"
| "LR"
| "LY"
| "LI"
| "LT"
| "LU"
| "MO"
| "MK"
| "MG"
| "MW"
| "MY"
| "MV"
| "ML"
| "MT"
| "MH"
| "MQ"
| "MR"
| "MU"
| "YT"
| "MX"
| "FM"
| "MD"
| "MC"
| "MN"
| "ME"
| "MS"
| "MA"
| "MZ"
| "MM"
| "NA"
| "NR"
| "NP"
| "NL"
| "NC"
| "NZ"
| "NI"
| "NE"
| "NG"
| "NU"
| "NF"
| "MP"
| "NO"
| "OM"
| "PK"
| "PW"
| "PS"
| "PA"
| "PG"
| "PY"
| "PE"
| "PH"
| "PN"
| "PL"
| "PT"
| "PR"
| "QA"
| "RE"
| "RO"
| "RU"
| "RW"
| "BL"
| "SH"
| "KN"
| "LC"
| "MF"
| "PM"
| "VC"
| "WS"
| "SM"
| "ST"
| "SA"
| "SN"
| "RS"
| "SC"
| "SL"
| "SG"
| "SX"
| "SK"
| "SI"
| "SB"
| "SO"
| "ZA"
| "GS"
| "SS"
| "ES"
| "LK"
| "SD"
| "SR"
| "SJ"
| "SZ"
| "SE"
| "CH"
| "SY"
| "TW"
| "TJ"
| "TZ"
| "TH"
| "TL"
| "TG"
| "TK"
| "TO"
| "TT"
| "TN"
| "TR"
| "TM"
| "TC"
| "TV"
| "UG"
| "UA"
| "AE"
| "GB"
| "US"
| "UM"
| "UY"
| "UZ"
| "VU"
| "VE"
| "VN"
| "VG"
| "VI"
| "WF"
| "EH"
| "YE"
| "ZM"
| "ZW"
;

function toCountryCode(root: JSONValue): CountryCode | null {
  return ( false
    || root == "AF"
    || root == "AX"
    || root == "AL"
    || root == "DZ"
    || root == "AS"
    || root == "AD"
    || root == "AO"
    || root == "AI"
    || root == "AQ"
    || root == "AG"
    || root == "AR"
    || root == "AM"
    || root == "AW"
    || root == "AU"
    || root == "AT"
    || root == "AZ"
    || root == "BS"
    || root == "BH"
    || root == "BD"
    || root == "BB"
    || root == "BY"
    || root == "BE"
    || root == "BZ"
    || root == "BJ"
    || root == "BM"
    || root == "BT"
    || root == "BO"
    || root == "BQ"
    || root == "BA"
    || root == "BW"
    || root == "BV"
    || root == "BR"
    || root == "IO"
    || root == "BN"
    || root == "BG"
    || root == "BF"
    || root == "BI"
    || root == "KH"
    || root == "CM"
    || root == "CA"
    || root == "CV"
    || root == "KY"
    || root == "CF"
    || root == "TD"
    || root == "CL"
    || root == "CN"
    || root == "CX"
    || root == "CC"
    || root == "CO"
    || root == "KM"
    || root == "CG"
    || root == "CD"
    || root == "CK"
    || root == "CR"
    || root == "CI"
    || root == "HR"
    || root == "CU"
    || root == "CW"
    || root == "CY"
    || root == "CZ"
    || root == "DK"
    || root == "DJ"
    || root == "DM"
    || root == "DO"
    || root == "EC"
    || root == "EG"
    || root == "SV"
    || root == "GQ"
    || root == "ER"
    || root == "EE"
    || root == "ET"
    || root == "FK"
    || root == "FO"
    || root == "FJ"
    || root == "FI"
    || root == "FR"
    || root == "GF"
    || root == "PF"
    || root == "TF"
    || root == "GA"
    || root == "GM"
    || root == "GE"
    || root == "DE"
    || root == "GH"
    || root == "GI"
    || root == "GR"
    || root == "GL"
    || root == "GD"
    || root == "GP"
    || root == "GU"
    || root == "GT"
    || root == "GG"
    || root == "GN"
    || root == "GW"
    || root == "GY"
    || root == "HT"
    || root == "HM"
    || root == "VA"
    || root == "HN"
    || root == "HK"
    || root == "HU"
    || root == "IS"
    || root == "IN"
    || root == "ID"
    || root == "IR"
    || root == "IQ"
    || root == "IE"
    || root == "IM"
    || root == "IL"
    || root == "IT"
    || root == "JM"
    || root == "JP"
    || root == "JE"
    || root == "JO"
    || root == "KZ"
    || root == "KE"
    || root == "KI"
    || root == "KP"
    || root == "KR"
    || root == "KW"
    || root == "KG"
    || root == "LA"
    || root == "LV"
    || root == "LB"
    || root == "LS"
    || root == "LR"
    || root == "LY"
    || root == "LI"
    || root == "LT"
    || root == "LU"
    || root == "MO"
    || root == "MK"
    || root == "MG"
    || root == "MW"
    || root == "MY"
    || root == "MV"
    || root == "ML"
    || root == "MT"
    || root == "MH"
    || root == "MQ"
    || root == "MR"
    || root == "MU"
    || root == "YT"
    || root == "MX"
    || root == "FM"
    || root == "MD"
    || root == "MC"
    || root == "MN"
    || root == "ME"
    || root == "MS"
    || root == "MA"
    || root == "MZ"
    || root == "MM"
    || root == "NA"
    || root == "NR"
    || root == "NP"
    || root == "NL"
    || root == "NC"
    || root == "NZ"
    || root == "NI"
    || root == "NE"
    || root == "NG"
    || root == "NU"
    || root == "NF"
    || root == "MP"
    || root == "NO"
    || root == "OM"
    || root == "PK"
    || root == "PW"
    || root == "PS"
    || root == "PA"
    || root == "PG"
    || root == "PY"
    || root == "PE"
    || root == "PH"
    || root == "PN"
    || root == "PL"
    || root == "PT"
    || root == "PR"
    || root == "QA"
    || root == "RE"
    || root == "RO"
    || root == "RU"
    || root == "RW"
    || root == "BL"
    || root == "SH"
    || root == "KN"
    || root == "LC"
    || root == "MF"
    || root == "PM"
    || root == "VC"
    || root == "WS"
    || root == "SM"
    || root == "ST"
    || root == "SA"
    || root == "SN"
    || root == "RS"
    || root == "SC"
    || root == "SL"
    || root == "SG"
    || root == "SX"
    || root == "SK"
    || root == "SI"
    || root == "SB"
    || root == "SO"
    || root == "ZA"
    || root == "GS"
    || root == "SS"
    || root == "ES"
    || root == "LK"
    || root == "SD"
    || root == "SR"
    || root == "SJ"
    || root == "SZ"
    || root == "SE"
    || root == "CH"
    || root == "SY"
    || root == "TW"
    || root == "TJ"
    || root == "TZ"
    || root == "TH"
    || root == "TL"
    || root == "TG"
    || root == "TK"
    || root == "TO"
    || root == "TT"
    || root == "TN"
    || root == "TR"
    || root == "TM"
    || root == "TC"
    || root == "TV"
    || root == "UG"
    || root == "UA"
    || root == "AE"
    || root == "GB"
    || root == "US"
    || root == "UM"
    || root == "UY"
    || root == "UZ"
    || root == "VU"
    || root == "VE"
    || root == "VN"
    || root == "VG"
    || root == "VI"
    || root == "WF"
    || root == "EH"
    || root == "YE"
    || root == "ZM"
    || root == "ZW"
  ) ? root : null;
}

// refs: 16 - tags: input, named, interface, output
export interface ForwardedIPConfig {
  HeaderName: string;
  FallbackBehavior: FallbackBehavior;
}
function fromForwardedIPConfig(input?: ForwardedIPConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toForwardedIPConfig(root: JSONValue): ForwardedIPConfig {
  return prt.readObj({
    required: {
      "HeaderName": "s",
      "FallbackBehavior": toFallbackBehavior,
    },
    optional: {},
  }, root);
}

// refs: 24 - tags: input, named, enum, output
export type FallbackBehavior =
| "MATCH"
| "NO_MATCH"
;

function toFallbackBehavior(root: JSONValue): FallbackBehavior | null {
  return ( false
    || root == "MATCH"
    || root == "NO_MATCH"
  ) ? root : null;
}

// refs: 12 - tags: input, named, interface, output
export interface RuleGroupReferenceStatement {
  ARN: string;
  ExcludedRules?: ExcludedRule[] | null;
}
function fromRuleGroupReferenceStatement(input?: RuleGroupReferenceStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    ExcludedRules: input["ExcludedRules"]?.map(x => fromExcludedRule(x)),
  }
}
function toRuleGroupReferenceStatement(root: JSONValue): RuleGroupReferenceStatement {
  return prt.readObj({
    required: {
      "ARN": "s",
    },
    optional: {
      "ExcludedRules": [toExcludedRule],
    },
  }, root);
}

// refs: 24 - tags: input, named, interface, output
export interface ExcludedRule {
  Name: string;
}
function fromExcludedRule(input?: ExcludedRule | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toExcludedRule(root: JSONValue): ExcludedRule {
  return prt.readObj({
    required: {
      "Name": "s",
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface IPSetReferenceStatement {
  ARN: string;
  IPSetForwardedIPConfig?: IPSetForwardedIPConfig | null;
}
function fromIPSetReferenceStatement(input?: IPSetReferenceStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    IPSetForwardedIPConfig: fromIPSetForwardedIPConfig(input["IPSetForwardedIPConfig"]),
  }
}
function toIPSetReferenceStatement(root: JSONValue): IPSetReferenceStatement {
  return prt.readObj({
    required: {
      "ARN": "s",
    },
    optional: {
      "IPSetForwardedIPConfig": toIPSetForwardedIPConfig,
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface IPSetForwardedIPConfig {
  HeaderName: string;
  FallbackBehavior: FallbackBehavior;
  Position: ForwardedIPPosition;
}
function fromIPSetForwardedIPConfig(input?: IPSetForwardedIPConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toIPSetForwardedIPConfig(root: JSONValue): IPSetForwardedIPConfig {
  return prt.readObj({
    required: {
      "HeaderName": "s",
      "FallbackBehavior": toFallbackBehavior,
      "Position": toForwardedIPPosition,
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type ForwardedIPPosition =
| "FIRST"
| "LAST"
| "ANY"
;

function toForwardedIPPosition(root: JSONValue): ForwardedIPPosition | null {
  return ( false
    || root == "FIRST"
    || root == "LAST"
    || root == "ANY"
  ) ? root : null;
}

// refs: 8 - tags: input, named, interface, output
export interface RegexPatternSetReferenceStatement {
  ARN: string;
  FieldToMatch: FieldToMatch;
  TextTransformations: TextTransformation[];
}
function fromRegexPatternSetReferenceStatement(input?: RegexPatternSetReferenceStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    FieldToMatch: fromFieldToMatch(input["FieldToMatch"]),
    TextTransformations: input["TextTransformations"]?.map(x => fromTextTransformation(x)),
  }
}
function toRegexPatternSetReferenceStatement(root: JSONValue): RegexPatternSetReferenceStatement {
  return prt.readObj({
    required: {
      "ARN": "s",
      "FieldToMatch": toFieldToMatch,
      "TextTransformations": [toTextTransformation],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, recursive, output
export interface RateBasedStatement {
  Limit: number;
  AggregateKeyType: RateBasedStatementAggregateKeyType;
  ScopeDownStatement?: Statement | null;
  ForwardedIPConfig?: ForwardedIPConfig | null;
}
function fromRateBasedStatement(input?: RateBasedStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    ScopeDownStatement: fromStatement(input["ScopeDownStatement"]),
    ForwardedIPConfig: fromForwardedIPConfig(input["ForwardedIPConfig"]),
  }
}
function toRateBasedStatement(root: JSONValue): RateBasedStatement {
  return prt.readObj({
    required: {
      "Limit": "n",
      "AggregateKeyType": toRateBasedStatementAggregateKeyType,
    },
    optional: {
      "ScopeDownStatement": toStatement,
      "ForwardedIPConfig": toForwardedIPConfig,
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type RateBasedStatementAggregateKeyType =
| "IP"
| "FORWARDED_IP"
;

function toRateBasedStatementAggregateKeyType(root: JSONValue): RateBasedStatementAggregateKeyType | null {
  return ( false
    || root == "IP"
    || root == "FORWARDED_IP"
  ) ? root : null;
}

// refs: 8 - tags: input, named, interface, output
export interface AndStatement {
  Statements: Statement[];
}
function fromAndStatement(input?: AndStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    Statements: input["Statements"]?.map(x => fromStatement(x)),
  }
}
function toAndStatement(root: JSONValue): AndStatement {
  return prt.readObj({
    required: {
      "Statements": [toStatement],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface OrStatement {
  Statements: Statement[];
}
function fromOrStatement(input?: OrStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    Statements: input["Statements"]?.map(x => fromStatement(x)),
  }
}
function toOrStatement(root: JSONValue): OrStatement {
  return prt.readObj({
    required: {
      "Statements": [toStatement],
    },
    optional: {},
  }, root);
}

// refs: 8 - tags: input, named, interface, recursive, output
export interface NotStatement {
  Statement: Statement;
}
function fromNotStatement(input?: NotStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    Statement: fromStatement(input["Statement"]),
  }
}
function toNotStatement(root: JSONValue): NotStatement {
  return prt.readObj({
    required: {
      "Statement": toStatement,
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface ManagedRuleGroupStatement {
  VendorName: string;
  Name: string;
  ExcludedRules?: ExcludedRule[] | null;
}
function fromManagedRuleGroupStatement(input?: ManagedRuleGroupStatement | null): JSONValue {
  if (!input) return input;
  return {...input,
    ExcludedRules: input["ExcludedRules"]?.map(x => fromExcludedRule(x)),
  }
}
function toManagedRuleGroupStatement(root: JSONValue): ManagedRuleGroupStatement {
  return prt.readObj({
    required: {
      "VendorName": "s",
      "Name": "s",
    },
    optional: {
      "ExcludedRules": [toExcludedRule],
    },
  }, root);
}

// refs: 9 - tags: input, named, interface, output
export interface RuleAction {
  Block?: BlockAction | null;
  Allow?: AllowAction | null;
  Count?: CountAction | null;
}
function fromRuleAction(input?: RuleAction | null): JSONValue {
  if (!input) return input;
  return {...input,
    Block: fromBlockAction(input["Block"]),
    Allow: fromAllowAction(input["Allow"]),
    Count: fromCountAction(input["Count"]),
  }
}
function toRuleAction(root: JSONValue): RuleAction {
  return prt.readObj({
    required: {},
    optional: {
      "Block": toBlockAction,
      "Allow": toAllowAction,
      "Count": toCountAction,
    },
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface BlockAction {
}
function fromBlockAction(input?: BlockAction | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toBlockAction(root: JSONValue): BlockAction {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 13 - tags: input, named, interface, output
export interface AllowAction {
}
function fromAllowAction(input?: AllowAction | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toAllowAction(root: JSONValue): AllowAction {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 21 - tags: input, named, interface, output
export interface CountAction {
}
function fromCountAction(input?: CountAction | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toCountAction(root: JSONValue): CountAction {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface OverrideAction {
  Count?: CountAction | null;
  None?: NoneAction | null;
}
function fromOverrideAction(input?: OverrideAction | null): JSONValue {
  if (!input) return input;
  return {...input,
    Count: fromCountAction(input["Count"]),
    None: fromNoneAction(input["None"]),
  }
}
function toOverrideAction(root: JSONValue): OverrideAction {
  return prt.readObj({
    required: {},
    optional: {
      "Count": toCountAction,
      "None": toNoneAction,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface NoneAction {
}
function fromNoneAction(input?: NoneAction | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toNoneAction(root: JSONValue): NoneAction {
  return prt.readObj({
    required: {},
    optional: {},
  }, root);
}

// refs: 19 - tags: input, named, interface, output
export interface VisibilityConfig {
  SampledRequestsEnabled: boolean;
  CloudWatchMetricsEnabled: boolean;
  MetricName: string;
}
function fromVisibilityConfig(input?: VisibilityConfig | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toVisibilityConfig(root: JSONValue): VisibilityConfig {
  return prt.readObj({
    required: {
      "SampledRequestsEnabled": "b",
      "CloudWatchMetricsEnabled": "b",
      "MetricName": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type IPAddressVersion =
| "IPV4"
| "IPV6"
;

function toIPAddressVersion(root: JSONValue): IPAddressVersion | null {
  return ( false
    || root == "IPV4"
    || root == "IPV6"
  ) ? root : null;
}

// refs: 6 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toTag(root: JSONValue): Tag {
  return prt.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface Regex {
  RegexString?: string | null;
}
function fromRegex(input?: Regex | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}
function toRegex(root: JSONValue): Regex {
  return prt.readObj({
    required: {},
    optional: {
      "RegexString": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DefaultAction {
  Block?: BlockAction | null;
  Allow?: AllowAction | null;
}
function fromDefaultAction(input?: DefaultAction | null): JSONValue {
  if (!input) return input;
  return {...input,
    Block: fromBlockAction(input["Block"]),
    Allow: fromAllowAction(input["Allow"]),
  }
}
function toDefaultAction(root: JSONValue): DefaultAction {
  return prt.readObj({
    required: {},
    optional: {
      "Block": toBlockAction,
      "Allow": toAllowAction,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TimeWindow {
  StartTime: Date | number;
  EndTime: Date | number;
}
function fromTimeWindow(input?: TimeWindow | null): JSONValue {
  if (!input) return input;
  return {...input,
    StartTime: prt.serializeDate_unixTimestamp(input["StartTime"]),
    EndTime: prt.serializeDate_unixTimestamp(input["EndTime"]),
  }
}
function toTimeWindow(root: JSONValue): TimeWindow {
  return prt.readObj({
    required: {
      "StartTime": "d",
      "EndTime": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, enum
export type ResourceType =
| "APPLICATION_LOAD_BALANCER"
| "API_GATEWAY"
| "APPSYNC"
;


// refs: 4 - tags: input, named, interface, output
export interface LoggingConfiguration {
  ResourceArn: string;
  LogDestinationConfigs: string[];
  RedactedFields?: FieldToMatch[] | null;
  ManagedByFirewallManager?: boolean | null;
}
function fromLoggingConfiguration(input?: LoggingConfiguration | null): JSONValue {
  if (!input) return input;
  return {...input,
    RedactedFields: input["RedactedFields"]?.map(x => fromFieldToMatch(x)),
  }
}
function toLoggingConfiguration(root: JSONValue): LoggingConfiguration {
  return prt.readObj({
    required: {
      "ResourceArn": "s",
      "LogDestinationConfigs": ["s"],
    },
    optional: {
      "RedactedFields": [toFieldToMatch],
      "ManagedByFirewallManager": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface IPSetSummary {
  Name?: string | null;
  Id?: string | null;
  Description?: string | null;
  LockToken?: string | null;
  ARN?: string | null;
}
function toIPSetSummary(root: JSONValue): IPSetSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RegexPatternSetSummary {
  Name?: string | null;
  Id?: string | null;
  Description?: string | null;
  LockToken?: string | null;
  ARN?: string | null;
}
function toRegexPatternSetSummary(root: JSONValue): RegexPatternSetSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RuleGroupSummary {
  Name?: string | null;
  Id?: string | null;
  Description?: string | null;
  LockToken?: string | null;
  ARN?: string | null;
}
function toRuleGroupSummary(root: JSONValue): RuleGroupSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface WebACLSummary {
  Name?: string | null;
  Id?: string | null;
  Description?: string | null;
  LockToken?: string | null;
  ARN?: string | null;
}
function toWebACLSummary(root: JSONValue): WebACLSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "Description": "s",
      "LockToken": "s",
      "ARN": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RuleSummary {
  Name?: string | null;
  Action?: RuleAction | null;
}
function toRuleSummary(root: JSONValue): RuleSummary {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Action": toRuleAction,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface IPSet {
  Name: string;
  Id: string;
  ARN: string;
  Description?: string | null;
  IPAddressVersion: IPAddressVersion;
  Addresses: string[];
}
function toIPSet(root: JSONValue): IPSet {
  return prt.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "IPAddressVersion": toIPAddressVersion,
      "Addresses": ["s"],
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RateBasedStatementManagedKeysIPSet {
  IPAddressVersion?: IPAddressVersion | null;
  Addresses?: string[] | null;
}
function toRateBasedStatementManagedKeysIPSet(root: JSONValue): RateBasedStatementManagedKeysIPSet {
  return prt.readObj({
    required: {},
    optional: {
      "IPAddressVersion": toIPAddressVersion,
      "Addresses": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RegexPatternSet {
  Name?: string | null;
  Id?: string | null;
  ARN?: string | null;
  Description?: string | null;
  RegularExpressionList?: Regex[] | null;
}
function toRegexPatternSet(root: JSONValue): RegexPatternSet {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "Description": "s",
      "RegularExpressionList": [toRegex],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RuleGroup {
  Name: string;
  Id: string;
  Capacity: number;
  ARN: string;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
}
function toRuleGroup(root: JSONValue): RuleGroup {
  return prt.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "Capacity": "n",
      "ARN": "s",
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Description": "s",
      "Rules": [toRule],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SampledHTTPRequest {
  Request: HTTPRequest;
  Weight: number;
  Timestamp?: Date | number | null;
  Action?: string | null;
  RuleNameWithinRuleGroup?: string | null;
}
function toSampledHTTPRequest(root: JSONValue): SampledHTTPRequest {
  return prt.readObj({
    required: {
      "Request": toHTTPRequest,
      "Weight": "n",
    },
    optional: {
      "Timestamp": "d",
      "Action": "s",
      "RuleNameWithinRuleGroup": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HTTPRequest {
  ClientIP?: string | null;
  Country?: string | null;
  URI?: string | null;
  Method?: string | null;
  HTTPVersion?: string | null;
  Headers?: HTTPHeader[] | null;
}
function toHTTPRequest(root: JSONValue): HTTPRequest {
  return prt.readObj({
    required: {},
    optional: {
      "ClientIP": "s",
      "Country": "s",
      "URI": "s",
      "Method": "s",
      "HTTPVersion": "s",
      "Headers": [toHTTPHeader],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HTTPHeader {
  Name?: string | null;
  Value?: string | null;
}
function toHTTPHeader(root: JSONValue): HTTPHeader {
  return prt.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Value": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface WebACL {
  Name: string;
  Id: string;
  ARN: string;
  DefaultAction: DefaultAction;
  Description?: string | null;
  Rules?: Rule[] | null;
  VisibilityConfig: VisibilityConfig;
  Capacity?: number | null;
  PreProcessFirewallManagerRuleGroups?: FirewallManagerRuleGroup[] | null;
  PostProcessFirewallManagerRuleGroups?: FirewallManagerRuleGroup[] | null;
  ManagedByFirewallManager?: boolean | null;
}
function toWebACL(root: JSONValue): WebACL {
  return prt.readObj({
    required: {
      "Name": "s",
      "Id": "s",
      "ARN": "s",
      "DefaultAction": toDefaultAction,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {
      "Description": "s",
      "Rules": [toRule],
      "Capacity": "n",
      "PreProcessFirewallManagerRuleGroups": [toFirewallManagerRuleGroup],
      "PostProcessFirewallManagerRuleGroups": [toFirewallManagerRuleGroup],
      "ManagedByFirewallManager": "b",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface FirewallManagerRuleGroup {
  Name: string;
  Priority: number;
  FirewallManagerStatement: FirewallManagerStatement;
  OverrideAction: OverrideAction;
  VisibilityConfig: VisibilityConfig;
}
function toFirewallManagerRuleGroup(root: JSONValue): FirewallManagerRuleGroup {
  return prt.readObj({
    required: {
      "Name": "s",
      "Priority": "n",
      "FirewallManagerStatement": toFirewallManagerStatement,
      "OverrideAction": toOverrideAction,
      "VisibilityConfig": toVisibilityConfig,
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface FirewallManagerStatement {
  ManagedRuleGroupStatement?: ManagedRuleGroupStatement | null;
  RuleGroupReferenceStatement?: RuleGroupReferenceStatement | null;
}
function toFirewallManagerStatement(root: JSONValue): FirewallManagerStatement {
  return prt.readObj({
    required: {},
    optional: {
      "ManagedRuleGroupStatement": toManagedRuleGroupStatement,
      "RuleGroupReferenceStatement": toRuleGroupReferenceStatement,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ManagedRuleGroupSummary {
  VendorName?: string | null;
  Name?: string | null;
  Description?: string | null;
}
function toManagedRuleGroupSummary(root: JSONValue): ManagedRuleGroupSummary {
  return prt.readObj({
    required: {},
    optional: {
      "VendorName": "s",
      "Name": "s",
      "Description": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TagInfoForResource {
  ResourceARN?: string | null;
  TagList?: Tag[] | null;
}
function toTagInfoForResource(root: JSONValue): TagInfoForResource {
  return prt.readObj({
    required: {},
    optional: {
      "ResourceARN": "s",
      "TagList": [toTag],
    },
  }, root);
}
