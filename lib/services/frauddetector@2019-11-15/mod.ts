// Autogenerated API client for: Amazon Fraud Detector

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class FraudDetector {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(FraudDetector.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2019-11-15",
    "endpointPrefix": "frauddetector",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Fraud Detector",
    "serviceId": "FraudDetector",
    "signatureVersion": "v4",
    "targetPrefix": "AWSHawksNestServiceFacade",
    "uid": "frauddetector-2019-11-15"
  };

  async batchCreateVariable(
    {abortSignal, ...params}: RequestConfig & s.BatchCreateVariableRequest,
  ): Promise<s.BatchCreateVariableResult> {
    const body: jsonP.JSONObject = {
      variableEntries: params["variableEntries"]?.map(x => fromVariableEntry(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCreateVariable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "errors": [toBatchCreateVariableError],
      },
    }, await resp.json());
  }

  async batchGetVariable(
    {abortSignal, ...params}: RequestConfig & s.BatchGetVariableRequest,
  ): Promise<s.BatchGetVariableResult> {
    const body: jsonP.JSONObject = {
      names: params["names"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetVariable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "variables": [toVariable],
        "errors": [toBatchGetVariableError],
      },
    }, await resp.json());
  }

  async createDetectorVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateDetectorVersionRequest,
  ): Promise<s.CreateDetectorVersionResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      description: params["description"],
      externalModelEndpoints: params["externalModelEndpoints"],
      rules: params["rules"]?.map(x => fromRule(x)),
      modelVersions: params["modelVersions"]?.map(x => fromModelVersion(x)),
      ruleExecutionMode: params["ruleExecutionMode"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDetectorVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detectorId": "s",
        "detectorVersionId": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetectorVersionStatus>(x),
      },
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & s.CreateModelRequest,
  ): Promise<s.CreateModelResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      description: params["description"],
      eventTypeName: params["eventTypeName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createModelVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateModelVersionRequest,
  ): Promise<s.CreateModelVersionResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      trainingDataSource: params["trainingDataSource"],
      trainingDataSchema: fromTrainingDataSchema(params["trainingDataSchema"]),
      externalEventsDetail: fromExternalEventsDetail(params["externalEventsDetail"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "modelId": "s",
        "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
        "modelVersionNumber": "s",
        "status": "s",
      },
    }, await resp.json());
  }

  async createRule(
    {abortSignal, ...params}: RequestConfig & s.CreateRuleRequest,
  ): Promise<s.CreateRuleResult> {
    const body: jsonP.JSONObject = {
      ruleId: params["ruleId"],
      detectorId: params["detectorId"],
      description: params["description"],
      expression: params["expression"],
      language: params["language"],
      outcomes: params["outcomes"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "rule": toRule,
      },
    }, await resp.json());
  }

  async createVariable(
    {abortSignal, ...params}: RequestConfig & s.CreateVariableRequest,
  ): Promise<s.CreateVariableResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      dataType: params["dataType"],
      dataSource: params["dataSource"],
      defaultValue: params["defaultValue"],
      description: params["description"],
      variableType: params["variableType"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVariable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDetector(
    {abortSignal, ...params}: RequestConfig & s.DeleteDetectorRequest,
  ): Promise<s.DeleteDetectorResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDetector",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDetectorVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteDetectorVersionRequest,
  ): Promise<s.DeleteDetectorVersionResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDetectorVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEntityType(
    {abortSignal, ...params}: RequestConfig & s.DeleteEntityTypeRequest,
  ): Promise<s.DeleteEntityTypeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEntityType",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEvent(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventRequest,
  ): Promise<s.DeleteEventResult> {
    const body: jsonP.JSONObject = {
      eventId: params["eventId"],
      eventTypeName: params["eventTypeName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEvent",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteEventType(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventTypeRequest,
  ): Promise<s.DeleteEventTypeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEventType",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteExternalModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteExternalModelRequest,
  ): Promise<s.DeleteExternalModelResult> {
    const body: jsonP.JSONObject = {
      modelEndpoint: params["modelEndpoint"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteExternalModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteLabel(
    {abortSignal, ...params}: RequestConfig & s.DeleteLabelRequest,
  ): Promise<s.DeleteLabelResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteLabel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelRequest,
  ): Promise<s.DeleteModelResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteModelVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelVersionRequest,
  ): Promise<s.DeleteModelVersionResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      modelVersionNumber: params["modelVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteOutcome(
    {abortSignal, ...params}: RequestConfig & s.DeleteOutcomeRequest,
  ): Promise<s.DeleteOutcomeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteOutcome",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRule(
    {abortSignal, ...params}: RequestConfig & s.DeleteRuleRequest,
  ): Promise<s.DeleteRuleResult> {
    const body: jsonP.JSONObject = {
      rule: fromRule(params["rule"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteVariable(
    {abortSignal, ...params}: RequestConfig & s.DeleteVariableRequest,
  ): Promise<s.DeleteVariableResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteVariable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async describeDetector(
    {abortSignal, ...params}: RequestConfig & s.DescribeDetectorRequest,
  ): Promise<s.DescribeDetectorResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDetector",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detectorId": "s",
        "detectorVersionSummaries": [toDetectorVersionSummary],
        "nextToken": "s",
        "arn": "s",
      },
    }, await resp.json());
  }

  async describeModelVersions(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelVersionsRequest = {},
  ): Promise<s.DescribeModelVersionsResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelVersionNumber: params["modelVersionNumber"],
      modelType: params["modelType"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "modelVersionDetails": [toModelVersionDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getDetectorVersion(
    {abortSignal, ...params}: RequestConfig & s.GetDetectorVersionRequest,
  ): Promise<s.GetDetectorVersionResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDetectorVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detectorId": "s",
        "detectorVersionId": "s",
        "description": "s",
        "externalModelEndpoints": ["s"],
        "modelVersions": [toModelVersion],
        "rules": [toRule],
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetectorVersionStatus>(x),
        "lastUpdatedTime": "s",
        "createdTime": "s",
        "ruleExecutionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleExecutionMode>(x),
        "arn": "s",
      },
    }, await resp.json());
  }

  async getDetectors(
    {abortSignal, ...params}: RequestConfig & s.GetDetectorsRequest = {},
  ): Promise<s.GetDetectorsResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDetectors",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "detectors": [toDetector],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getEntityTypes(
    {abortSignal, ...params}: RequestConfig & s.GetEntityTypesRequest = {},
  ): Promise<s.GetEntityTypesResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEntityTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entityTypes": [toEntityType],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getEventPrediction(
    {abortSignal, ...params}: RequestConfig & s.GetEventPredictionRequest,
  ): Promise<s.GetEventPredictionResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
      eventId: params["eventId"],
      eventTypeName: params["eventTypeName"],
      entities: params["entities"]?.map(x => fromEntity(x)),
      eventTimestamp: params["eventTimestamp"],
      eventVariables: params["eventVariables"],
      externalModelEndpointDataBlobs: jsonP.serializeMap(params["externalModelEndpointDataBlobs"], x => fromModelEndpointDataBlob(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEventPrediction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "modelScores": [toModelScores],
        "ruleResults": [toRuleResult],
      },
    }, await resp.json());
  }

  async getEventTypes(
    {abortSignal, ...params}: RequestConfig & s.GetEventTypesRequest = {},
  ): Promise<s.GetEventTypesResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetEventTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTypes": [toEventType],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getExternalModels(
    {abortSignal, ...params}: RequestConfig & s.GetExternalModelsRequest = {},
  ): Promise<s.GetExternalModelsResult> {
    const body: jsonP.JSONObject = {
      modelEndpoint: params["modelEndpoint"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetExternalModels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "externalModels": [toExternalModel],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getKMSEncryptionKey(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.GetKMSEncryptionKeyResult> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetKMSEncryptionKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "kmsKey": toKMSKey,
      },
    }, await resp.json());
  }

  async getLabels(
    {abortSignal, ...params}: RequestConfig & s.GetLabelsRequest = {},
  ): Promise<s.GetLabelsResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetLabels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "labels": [toLabel],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getModelVersion(
    {abortSignal, ...params}: RequestConfig & s.GetModelVersionRequest,
  ): Promise<s.GetModelVersionResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      modelVersionNumber: params["modelVersionNumber"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetModelVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "modelId": "s",
        "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
        "modelVersionNumber": "s",
        "trainingDataSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingDataSourceEnum>(x),
        "trainingDataSchema": toTrainingDataSchema,
        "externalEventsDetail": toExternalEventsDetail,
        "status": "s",
        "arn": "s",
      },
    }, await resp.json());
  }

  async getModels(
    {abortSignal, ...params}: RequestConfig & s.GetModelsRequest = {},
  ): Promise<s.GetModelsResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetModels",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "nextToken": "s",
        "models": [toModel],
      },
    }, await resp.json());
  }

  async getOutcomes(
    {abortSignal, ...params}: RequestConfig & s.GetOutcomesRequest = {},
  ): Promise<s.GetOutcomesResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetOutcomes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "outcomes": [toOutcome],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getRules(
    {abortSignal, ...params}: RequestConfig & s.GetRulesRequest,
  ): Promise<s.GetRulesResult> {
    const body: jsonP.JSONObject = {
      ruleId: params["ruleId"],
      detectorId: params["detectorId"],
      ruleVersion: params["ruleVersion"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRules",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ruleDetails": [toRuleDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getVariables(
    {abortSignal, ...params}: RequestConfig & s.GetVariablesRequest = {},
  ): Promise<s.GetVariablesResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetVariables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "variables": [toVariable],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const body: jsonP.JSONObject = {
      resourceARN: params["resourceARN"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async putDetector(
    {abortSignal, ...params}: RequestConfig & s.PutDetectorRequest,
  ): Promise<s.PutDetectorResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      description: params["description"],
      eventTypeName: params["eventTypeName"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDetector",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putEntityType(
    {abortSignal, ...params}: RequestConfig & s.PutEntityTypeRequest,
  ): Promise<s.PutEntityTypeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEntityType",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putEventType(
    {abortSignal, ...params}: RequestConfig & s.PutEventTypeRequest,
  ): Promise<s.PutEventTypeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      eventVariables: params["eventVariables"],
      labels: params["labels"],
      entityTypes: params["entityTypes"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEventType",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putExternalModel(
    {abortSignal, ...params}: RequestConfig & s.PutExternalModelRequest,
  ): Promise<s.PutExternalModelResult> {
    const body: jsonP.JSONObject = {
      modelEndpoint: params["modelEndpoint"],
      modelSource: params["modelSource"],
      invokeModelEndpointRoleArn: params["invokeModelEndpointRoleArn"],
      inputConfiguration: fromModelInputConfiguration(params["inputConfiguration"]),
      outputConfiguration: fromModelOutputConfiguration(params["outputConfiguration"]),
      modelEndpointStatus: params["modelEndpointStatus"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutExternalModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putKMSEncryptionKey(
    {abortSignal, ...params}: RequestConfig & s.PutKMSEncryptionKeyRequest,
  ): Promise<s.PutKMSEncryptionKeyResult> {
    const body: jsonP.JSONObject = {
      kmsEncryptionKeyArn: params["kmsEncryptionKeyArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutKMSEncryptionKey",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putLabel(
    {abortSignal, ...params}: RequestConfig & s.PutLabelRequest,
  ): Promise<s.PutLabelResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutLabel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putOutcome(
    {abortSignal, ...params}: RequestConfig & s.PutOutcomeRequest,
  ): Promise<s.PutOutcomeResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      description: params["description"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutOutcome",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResult> {
    const body: jsonP.JSONObject = {
      resourceARN: params["resourceARN"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResult> {
    const body: jsonP.JSONObject = {
      resourceARN: params["resourceARN"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDetectorVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateDetectorVersionRequest,
  ): Promise<s.UpdateDetectorVersionResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
      externalModelEndpoints: params["externalModelEndpoints"],
      rules: params["rules"]?.map(x => fromRule(x)),
      description: params["description"],
      modelVersions: params["modelVersions"]?.map(x => fromModelVersion(x)),
      ruleExecutionMode: params["ruleExecutionMode"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDetectorVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDetectorVersionMetadata(
    {abortSignal, ...params}: RequestConfig & s.UpdateDetectorVersionMetadataRequest,
  ): Promise<s.UpdateDetectorVersionMetadataResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDetectorVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDetectorVersionStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdateDetectorVersionStatusRequest,
  ): Promise<s.UpdateDetectorVersionStatusResult> {
    const body: jsonP.JSONObject = {
      detectorId: params["detectorId"],
      detectorVersionId: params["detectorVersionId"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDetectorVersionStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateModel(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelRequest,
  ): Promise<s.UpdateModelResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModel",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateModelVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelVersionRequest,
  ): Promise<s.UpdateModelVersionResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      majorVersionNumber: params["majorVersionNumber"],
      externalEventsDetail: fromExternalEventsDetail(params["externalEventsDetail"]),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModelVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "modelId": "s",
        "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
        "modelVersionNumber": "s",
        "status": "s",
      },
    }, await resp.json());
  }

  async updateModelVersionStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelVersionStatusRequest,
  ): Promise<s.UpdateModelVersionStatusResult> {
    const body: jsonP.JSONObject = {
      modelId: params["modelId"],
      modelType: params["modelType"],
      modelVersionNumber: params["modelVersionNumber"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModelVersionStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateRuleMetadata(
    {abortSignal, ...params}: RequestConfig & s.UpdateRuleMetadataRequest,
  ): Promise<s.UpdateRuleMetadataResult> {
    const body: jsonP.JSONObject = {
      rule: fromRule(params["rule"]),
      description: params["description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuleMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateRuleVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateRuleVersionRequest,
  ): Promise<s.UpdateRuleVersionResult> {
    const body: jsonP.JSONObject = {
      rule: fromRule(params["rule"]),
      description: params["description"],
      expression: params["expression"],
      language: params["language"],
      outcomes: params["outcomes"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRuleVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "rule": toRule,
      },
    }, await resp.json());
  }

  async updateVariable(
    {abortSignal, ...params}: RequestConfig & s.UpdateVariableRequest,
  ): Promise<s.UpdateVariableResult> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      defaultValue: params["defaultValue"],
      description: params["description"],
      variableType: params["variableType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVariable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

}

function fromVariableEntry(input?: s.VariableEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    name: input["name"],
    dataType: input["dataType"],
    dataSource: input["dataSource"],
    defaultValue: input["defaultValue"],
    description: input["description"],
    variableType: input["variableType"],
  }
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromRule(input?: s.Rule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    detectorId: input["detectorId"],
    ruleId: input["ruleId"],
    ruleVersion: input["ruleVersion"],
  }
}
function toRule(root: jsonP.JSONValue): s.Rule {
  return jsonP.readObj({
    required: {
      "detectorId": "s",
      "ruleId": "s",
      "ruleVersion": "s",
    },
    optional: {},
  }, root);
}

function fromModelVersion(input?: s.ModelVersion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    modelId: input["modelId"],
    modelType: input["modelType"],
    modelVersionNumber: input["modelVersionNumber"],
    arn: input["arn"],
  }
}
function toModelVersion(root: jsonP.JSONValue): s.ModelVersion {
  return jsonP.readObj({
    required: {
      "modelId": "s",
      "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
      "modelVersionNumber": "s",
    },
    optional: {
      "arn": "s",
    },
  }, root);
}

function fromTrainingDataSchema(input?: s.TrainingDataSchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    modelVariables: input["modelVariables"],
    labelSchema: fromLabelSchema(input["labelSchema"]),
  }
}
function toTrainingDataSchema(root: jsonP.JSONValue): s.TrainingDataSchema {
  return jsonP.readObj({
    required: {
      "modelVariables": ["s"],
      "labelSchema": toLabelSchema,
    },
    optional: {},
  }, root);
}

function fromLabelSchema(input?: s.LabelSchema | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    labelMapper: input["labelMapper"],
  }
}
function toLabelSchema(root: jsonP.JSONValue): s.LabelSchema {
  return jsonP.readObj({
    required: {
      "labelMapper": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
    },
    optional: {},
  }, root);
}

function fromExternalEventsDetail(input?: s.ExternalEventsDetail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    dataLocation: input["dataLocation"],
    dataAccessRoleArn: input["dataAccessRoleArn"],
  }
}
function toExternalEventsDetail(root: jsonP.JSONValue): s.ExternalEventsDetail {
  return jsonP.readObj({
    required: {
      "dataLocation": "s",
      "dataAccessRoleArn": "s",
    },
    optional: {},
  }, root);
}

function fromEntity(input?: s.Entity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    entityType: input["entityType"],
    entityId: input["entityId"],
  }
}

function fromModelEndpointDataBlob(input?: s.ModelEndpointDataBlob | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    byteBuffer: jsonP.serializeBlob(input["byteBuffer"]),
    contentType: input["contentType"],
  }
}

function fromModelInputConfiguration(input?: s.ModelInputConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventTypeName: input["eventTypeName"],
    format: input["format"],
    useEventVariables: input["useEventVariables"],
    jsonInputTemplate: input["jsonInputTemplate"],
    csvInputTemplate: input["csvInputTemplate"],
  }
}
function toModelInputConfiguration(root: jsonP.JSONValue): s.ModelInputConfiguration {
  return jsonP.readObj({
    required: {
      "useEventVariables": "b",
    },
    optional: {
      "eventTypeName": "s",
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelInputDataFormat>(x),
      "jsonInputTemplate": "s",
      "csvInputTemplate": "s",
    },
  }, root);
}

function fromModelOutputConfiguration(input?: s.ModelOutputConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    format: input["format"],
    jsonKeyToVariableMap: input["jsonKeyToVariableMap"],
    csvIndexToVariableMap: input["csvIndexToVariableMap"],
  }
}
function toModelOutputConfiguration(root: jsonP.JSONValue): s.ModelOutputConfiguration {
  return jsonP.readObj({
    required: {
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelOutputDataFormat>(x),
    },
    optional: {
      "jsonKeyToVariableMap": x => jsonP.readMap(String, String, x),
      "csvIndexToVariableMap": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toBatchCreateVariableError(root: jsonP.JSONValue): s.BatchCreateVariableError {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "code": "n",
      "message": "s",
    },
  }, root);
}

function toVariable(root: jsonP.JSONValue): s.Variable {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "dataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataType>(x),
      "dataSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataSource>(x),
      "defaultValue": "s",
      "description": "s",
      "variableType": "s",
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toBatchGetVariableError(root: jsonP.JSONValue): s.BatchGetVariableError {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "code": "n",
      "message": "s",
    },
  }, root);
}

function toDetectorVersionSummary(root: jsonP.JSONValue): s.DetectorVersionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "detectorVersionId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetectorVersionStatus>(x),
      "description": "s",
      "lastUpdatedTime": "s",
    },
  }, root);
}

function toModelVersionDetail(root: jsonP.JSONValue): s.ModelVersionDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "modelId": "s",
      "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
      "modelVersionNumber": "s",
      "status": "s",
      "trainingDataSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingDataSourceEnum>(x),
      "trainingDataSchema": toTrainingDataSchema,
      "externalEventsDetail": toExternalEventsDetail,
      "trainingResult": toTrainingResult,
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toTrainingResult(root: jsonP.JSONValue): s.TrainingResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "dataValidationMetrics": toDataValidationMetrics,
      "trainingMetrics": toTrainingMetrics,
    },
  }, root);
}

function toDataValidationMetrics(root: jsonP.JSONValue): s.DataValidationMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "fileLevelMessages": [toFileValidationMessage],
      "fieldLevelMessages": [toFieldValidationMessage],
    },
  }, root);
}

function toFileValidationMessage(root: jsonP.JSONValue): s.FileValidationMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "title": "s",
      "content": "s",
      "type": "s",
    },
  }, root);
}

function toFieldValidationMessage(root: jsonP.JSONValue): s.FieldValidationMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "fieldName": "s",
      "identifier": "s",
      "title": "s",
      "content": "s",
      "type": "s",
    },
  }, root);
}

function toTrainingMetrics(root: jsonP.JSONValue): s.TrainingMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "auc": "n",
      "metricDataPoints": [toMetricDataPoint],
    },
  }, root);
}

function toMetricDataPoint(root: jsonP.JSONValue): s.MetricDataPoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "fpr": "n",
      "precision": "n",
      "tpr": "n",
      "threshold": "n",
    },
  }, root);
}

function toDetector(root: jsonP.JSONValue): s.Detector {
  return jsonP.readObj({
    required: {},
    optional: {
      "detectorId": "s",
      "description": "s",
      "eventTypeName": "s",
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toEntityType(root: jsonP.JSONValue): s.EntityType {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toModelScores(root: jsonP.JSONValue): s.ModelScores {
  return jsonP.readObj({
    required: {},
    optional: {
      "modelVersion": toModelVersion,
      "scores": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toRuleResult(root: jsonP.JSONValue): s.RuleResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "ruleId": "s",
      "outcomes": ["s"],
    },
  }, root);
}

function toEventType(root: jsonP.JSONValue): s.EventType {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "eventVariables": ["s"],
      "labels": ["s"],
      "entityTypes": ["s"],
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toExternalModel(root: jsonP.JSONValue): s.ExternalModel {
  return jsonP.readObj({
    required: {},
    optional: {
      "modelEndpoint": "s",
      "modelSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelSource>(x),
      "invokeModelEndpointRoleArn": "s",
      "inputConfiguration": toModelInputConfiguration,
      "outputConfiguration": toModelOutputConfiguration,
      "modelEndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelEndpointStatus>(x),
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toKMSKey(root: jsonP.JSONValue): s.KMSKey {
  return jsonP.readObj({
    required: {},
    optional: {
      "kmsEncryptionKeyArn": "s",
    },
  }, root);
}

function toLabel(root: jsonP.JSONValue): s.Label {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toModel(root: jsonP.JSONValue): s.Model {
  return jsonP.readObj({
    required: {},
    optional: {
      "modelId": "s",
      "modelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelTypeEnum>(x),
      "description": "s",
      "eventTypeName": "s",
      "createdTime": "s",
      "lastUpdatedTime": "s",
      "arn": "s",
    },
  }, root);
}

function toOutcome(root: jsonP.JSONValue): s.Outcome {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}

function toRuleDetail(root: jsonP.JSONValue): s.RuleDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ruleId": "s",
      "description": "s",
      "detectorId": "s",
      "ruleVersion": "s",
      "expression": "s",
      "language": (x: jsonP.JSONValue) => cmnP.readEnum<s.Language>(x),
      "outcomes": ["s"],
      "lastUpdatedTime": "s",
      "createdTime": "s",
      "arn": "s",
    },
  }, root);
}
