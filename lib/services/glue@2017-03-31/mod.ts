// Autogenerated API client for: AWS Glue

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Glue {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Glue.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-03-31",
    "endpointPrefix": "glue",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Glue",
    "serviceId": "Glue",
    "signatureVersion": "v4",
    "targetPrefix": "AWSGlue",
    "uid": "glue-2017-03-31"
  };

  async batchCreatePartition(
    {abortSignal, ...params}: RequestConfig & BatchCreatePartitionRequest,
  ): Promise<BatchCreatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionInputList: params["PartitionInputList"]?.map(x => fromPartitionInput(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCreatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toPartitionError],
      },
    }, await resp.json());
  }

  async batchDeleteConnection(
    {abortSignal, ...params}: RequestConfig & BatchDeleteConnectionRequest,
  ): Promise<BatchDeleteConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionNameList: params["ConnectionNameList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Succeeded": ["s"],
        "Errors": x => jsonP.readMap(String, toErrorDetail, x),
      },
    }, await resp.json());
  }

  async batchDeletePartition(
    {abortSignal, ...params}: RequestConfig & BatchDeletePartitionRequest,
  ): Promise<BatchDeletePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionsToDelete: params["PartitionsToDelete"]?.map(x => fromPartitionValueList(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeletePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toPartitionError],
      },
    }, await resp.json());
  }

  async batchDeleteTable(
    {abortSignal, ...params}: RequestConfig & BatchDeleteTableRequest,
  ): Promise<BatchDeleteTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TablesToDelete: params["TablesToDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toTableError],
      },
    }, await resp.json());
  }

  async batchDeleteTableVersion(
    {abortSignal, ...params}: RequestConfig & BatchDeleteTableVersionRequest,
  ): Promise<BatchDeleteTableVersionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionIds: params["VersionIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteTableVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toTableVersionError],
      },
    }, await resp.json());
  }

  async batchGetCrawlers(
    {abortSignal, ...params}: RequestConfig & BatchGetCrawlersRequest,
  ): Promise<BatchGetCrawlersResponse> {
    const body: jsonP.JSONObject = {
      CrawlerNames: params["CrawlerNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawlers": [toCrawler],
        "CrawlersNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetDevEndpoints(
    {abortSignal, ...params}: RequestConfig & BatchGetDevEndpointsRequest,
  ): Promise<BatchGetDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      DevEndpointNames: params["DevEndpointNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoints": [toDevEndpoint],
        "DevEndpointsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetJobs(
    {abortSignal, ...params}: RequestConfig & BatchGetJobsRequest,
  ): Promise<BatchGetJobsResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "JobsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetPartition(
    {abortSignal, ...params}: RequestConfig & BatchGetPartitionRequest,
  ): Promise<BatchGetPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionsToGet: params["PartitionsToGet"]?.map(x => fromPartitionValueList(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partitions": [toPartition],
        "UnprocessedKeys": [toPartitionValueList],
      },
    }, await resp.json());
  }

  async batchGetTriggers(
    {abortSignal, ...params}: RequestConfig & BatchGetTriggersRequest,
  ): Promise<BatchGetTriggersResponse> {
    const body: jsonP.JSONObject = {
      TriggerNames: params["TriggerNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Triggers": [toTrigger],
        "TriggersNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetWorkflows(
    {abortSignal, ...params}: RequestConfig & BatchGetWorkflowsRequest,
  ): Promise<BatchGetWorkflowsResponse> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetWorkflows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflows": [toWorkflow],
        "MissingWorkflows": ["s"],
      },
    }, await resp.json());
  }

  async batchStopJobRun(
    {abortSignal, ...params}: RequestConfig & BatchStopJobRunRequest,
  ): Promise<BatchStopJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobRunIds: params["JobRunIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStopJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SuccessfulSubmissions": [toBatchStopJobRunSuccessfulSubmission],
        "Errors": [toBatchStopJobRunError],
      },
    }, await resp.json());
  }

  async batchUpdatePartition(
    {abortSignal, ...params}: RequestConfig & BatchUpdatePartitionRequest,
  ): Promise<BatchUpdatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      Entries: params["Entries"]?.map(x => fromBatchUpdatePartitionRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toBatchUpdatePartitionFailureEntry],
      },
    }, await resp.json());
  }

  async cancelMLTaskRun(
    {abortSignal, ...params}: RequestConfig & CancelMLTaskRunRequest,
  ): Promise<CancelMLTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      TaskRunId: params["TaskRunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelMLTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "TaskRunId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TaskStatusType>(x),
      },
    }, await resp.json());
  }

  async checkSchemaVersionValidity(
    {abortSignal, ...params}: RequestConfig & CheckSchemaVersionValidityInput,
  ): Promise<CheckSchemaVersionValidityResponse> {
    const body: jsonP.JSONObject = {
      DataFormat: params["DataFormat"],
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CheckSchemaVersionValidity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Valid": "b",
        "Error": "s",
      },
    }, await resp.json());
  }

  async createClassifier(
    {abortSignal, ...params}: RequestConfig & CreateClassifierRequest = {},
  ): Promise<CreateClassifierResponse> {
    const body: jsonP.JSONObject = {
      GrokClassifier: fromCreateGrokClassifierRequest(params["GrokClassifier"]),
      XMLClassifier: fromCreateXMLClassifierRequest(params["XMLClassifier"]),
      JsonClassifier: fromCreateJsonClassifierRequest(params["JsonClassifier"]),
      CsvClassifier: fromCreateCsvClassifierRequest(params["CsvClassifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createConnection(
    {abortSignal, ...params}: RequestConfig & CreateConnectionRequest,
  ): Promise<CreateConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionInput: fromConnectionInput(params["ConnectionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createCrawler(
    {abortSignal, ...params}: RequestConfig & CreateCrawlerRequest,
  ): Promise<CreateCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Role: params["Role"],
      DatabaseName: params["DatabaseName"],
      Description: params["Description"],
      Targets: fromCrawlerTargets(params["Targets"]),
      Schedule: params["Schedule"],
      Classifiers: params["Classifiers"],
      TablePrefix: params["TablePrefix"],
      SchemaChangePolicy: fromSchemaChangePolicy(params["SchemaChangePolicy"]),
      RecrawlPolicy: fromRecrawlPolicy(params["RecrawlPolicy"]),
      LineageConfiguration: fromLineageConfiguration(params["LineageConfiguration"]),
      Configuration: params["Configuration"],
      CrawlerSecurityConfiguration: params["CrawlerSecurityConfiguration"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createDatabase(
    {abortSignal, ...params}: RequestConfig & CreateDatabaseRequest,
  ): Promise<CreateDatabaseResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseInput: fromDatabaseInput(params["DatabaseInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createDevEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateDevEndpointRequest,
  ): Promise<CreateDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      RoleArn: params["RoleArn"],
      SecurityGroupIds: params["SecurityGroupIds"],
      SubnetId: params["SubnetId"],
      PublicKey: params["PublicKey"],
      PublicKeys: params["PublicKeys"],
      NumberOfNodes: params["NumberOfNodes"],
      WorkerType: params["WorkerType"],
      GlueVersion: params["GlueVersion"],
      NumberOfWorkers: params["NumberOfWorkers"],
      ExtraPythonLibsS3Path: params["ExtraPythonLibsS3Path"],
      ExtraJarsS3Path: params["ExtraJarsS3Path"],
      SecurityConfiguration: params["SecurityConfiguration"],
      Tags: params["Tags"],
      Arguments: params["Arguments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EndpointName": "s",
        "Status": "s",
        "SecurityGroupIds": ["s"],
        "SubnetId": "s",
        "RoleArn": "s",
        "YarnEndpointAddress": "s",
        "ZeppelinRemoteSparkInterpreterPort": "n",
        "NumberOfNodes": "n",
        "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
        "GlueVersion": "s",
        "NumberOfWorkers": "n",
        "AvailabilityZone": "s",
        "VpcId": "s",
        "ExtraPythonLibsS3Path": "s",
        "ExtraJarsS3Path": "s",
        "FailureReason": "s",
        "SecurityConfiguration": "s",
        "CreatedTimestamp": "d",
        "Arguments": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & CreateJobRequest,
  ): Promise<CreateJobResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      LogUri: params["LogUri"],
      Role: params["Role"],
      ExecutionProperty: fromExecutionProperty(params["ExecutionProperty"]),
      Command: fromJobCommand(params["Command"]),
      DefaultArguments: params["DefaultArguments"],
      NonOverridableArguments: params["NonOverridableArguments"],
      Connections: fromConnectionsList(params["Connections"]),
      MaxRetries: params["MaxRetries"],
      AllocatedCapacity: params["AllocatedCapacity"],
      Timeout: params["Timeout"],
      MaxCapacity: params["MaxCapacity"],
      SecurityConfiguration: params["SecurityConfiguration"],
      Tags: params["Tags"],
      NotificationProperty: fromNotificationProperty(params["NotificationProperty"]),
      GlueVersion: params["GlueVersion"],
      NumberOfWorkers: params["NumberOfWorkers"],
      WorkerType: params["WorkerType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async createMLTransform(
    {abortSignal, ...params}: RequestConfig & CreateMLTransformRequest,
  ): Promise<CreateMLTransformResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      InputRecordTables: params["InputRecordTables"]?.map(x => fromGlueTable(x)),
      Parameters: fromTransformParameters(params["Parameters"]),
      Role: params["Role"],
      GlueVersion: params["GlueVersion"],
      MaxCapacity: params["MaxCapacity"],
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
      Timeout: params["Timeout"],
      MaxRetries: params["MaxRetries"],
      Tags: params["Tags"],
      TransformEncryption: fromTransformEncryption(params["TransformEncryption"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async createPartition(
    {abortSignal, ...params}: RequestConfig & CreatePartitionRequest,
  ): Promise<CreatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionInput: fromPartitionInput(params["PartitionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createPartitionIndex(
    {abortSignal, ...params}: RequestConfig & CreatePartitionIndexRequest,
  ): Promise<CreatePartitionIndexResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionIndex: fromPartitionIndex(params["PartitionIndex"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePartitionIndex",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createRegistry(
    {abortSignal, ...params}: RequestConfig & CreateRegistryInput,
  ): Promise<CreateRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryName: params["RegistryName"],
      Description: params["Description"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryArn": "s",
        "RegistryName": "s",
        "Description": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & CreateSchemaInput,
  ): Promise<CreateSchemaResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      SchemaName: params["SchemaName"],
      DataFormat: params["DataFormat"],
      Compatibility: params["Compatibility"],
      Description: params["Description"],
      Tags: params["Tags"],
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "SchemaName": "s",
        "SchemaArn": "s",
        "Description": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<DataFormat>(x),
        "Compatibility": (x: jsonP.JSONValue) => cmnP.readEnum<Compatibility>(x),
        "SchemaCheckpoint": "n",
        "LatestSchemaVersion": "n",
        "NextSchemaVersion": "n",
        "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaStatus>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "SchemaVersionId": "s",
        "SchemaVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaVersionStatus>(x),
      },
    }, await resp.json());
  }

  async createScript(
    {abortSignal, ...params}: RequestConfig & CreateScriptRequest = {},
  ): Promise<CreateScriptResponse> {
    const body: jsonP.JSONObject = {
      DagNodes: params["DagNodes"]?.map(x => fromCodeGenNode(x)),
      DagEdges: params["DagEdges"]?.map(x => fromCodeGenEdge(x)),
      Language: params["Language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PythonScript": "s",
        "ScalaCode": "s",
      },
    }, await resp.json());
  }

  async createSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & CreateSecurityConfigurationRequest,
  ): Promise<CreateSecurityConfigurationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EncryptionConfiguration: fromEncryptionConfiguration(params["EncryptionConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "CreatedTimestamp": "d",
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & CreateTableRequest,
  ): Promise<CreateTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableInput: fromTableInput(params["TableInput"]),
      PartitionIndexes: params["PartitionIndexes"]?.map(x => fromPartitionIndex(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createTrigger(
    {abortSignal, ...params}: RequestConfig & CreateTriggerRequest,
  ): Promise<CreateTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      WorkflowName: params["WorkflowName"],
      Type: params["Type"],
      Schedule: params["Schedule"],
      Predicate: fromPredicate(params["Predicate"]),
      Actions: params["Actions"]?.map(x => fromAction(x)),
      Description: params["Description"],
      StartOnCreation: params["StartOnCreation"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async createUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & CreateUserDefinedFunctionRequest,
  ): Promise<CreateUserDefinedFunctionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionInput: fromUserDefinedFunctionInput(params["FunctionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserDefinedFunction",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createWorkflow(
    {abortSignal, ...params}: RequestConfig & CreateWorkflowRequest,
  ): Promise<CreateWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      DefaultRunProperties: params["DefaultRunProperties"],
      Tags: params["Tags"],
      MaxConcurrentRuns: params["MaxConcurrentRuns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteClassifier(
    {abortSignal, ...params}: RequestConfig & DeleteClassifierRequest,
  ): Promise<DeleteClassifierResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & DeleteColumnStatisticsForPartitionRequest,
  ): Promise<DeleteColumnStatisticsForPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnName: params["ColumnName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteColumnStatisticsForPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & DeleteColumnStatisticsForTableRequest,
  ): Promise<DeleteColumnStatisticsForTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnName: params["ColumnName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteColumnStatisticsForTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteConnection(
    {abortSignal, ...params}: RequestConfig & DeleteConnectionRequest,
  ): Promise<DeleteConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionName: params["ConnectionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteCrawler(
    {abortSignal, ...params}: RequestConfig & DeleteCrawlerRequest,
  ): Promise<DeleteCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDatabase(
    {abortSignal, ...params}: RequestConfig & DeleteDatabaseRequest,
  ): Promise<DeleteDatabaseResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteDevEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteDevEndpointRequest,
  ): Promise<DeleteDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteJob(
    {abortSignal, ...params}: RequestConfig & DeleteJobRequest,
  ): Promise<DeleteJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobName": "s",
      },
    }, await resp.json());
  }

  async deleteMLTransform(
    {abortSignal, ...params}: RequestConfig & DeleteMLTransformRequest,
  ): Promise<DeleteMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async deletePartition(
    {abortSignal, ...params}: RequestConfig & DeletePartitionRequest,
  ): Promise<DeletePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePartitionIndex(
    {abortSignal, ...params}: RequestConfig & DeletePartitionIndexRequest,
  ): Promise<DeletePartitionIndexResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      IndexName: params["IndexName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePartitionIndex",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteRegistry(
    {abortSignal, ...params}: RequestConfig & DeleteRegistryInput,
  ): Promise<DeleteRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<RegistryStatus>(x),
      },
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & DeleteResourcePolicyRequest = {},
  ): Promise<DeleteResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      PolicyHashCondition: params["PolicyHashCondition"],
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & DeleteSchemaInput,
  ): Promise<DeleteSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaStatus>(x),
      },
    }, await resp.json());
  }

  async deleteSchemaVersions(
    {abortSignal, ...params}: RequestConfig & DeleteSchemaVersionsInput,
  ): Promise<DeleteSchemaVersionsResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      Versions: params["Versions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchemaVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionErrors": [toSchemaVersionErrorItem],
      },
    }, await resp.json());
  }

  async deleteSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & DeleteSecurityConfigurationRequest,
  ): Promise<DeleteSecurityConfigurationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & DeleteTableRequest,
  ): Promise<DeleteTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTableVersion(
    {abortSignal, ...params}: RequestConfig & DeleteTableVersionRequest,
  ): Promise<DeleteTableVersionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionId: params["VersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTableVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTrigger(
    {abortSignal, ...params}: RequestConfig & DeleteTriggerRequest,
  ): Promise<DeleteTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & DeleteUserDefinedFunctionRequest,
  ): Promise<DeleteUserDefinedFunctionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserDefinedFunction",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWorkflow(
    {abortSignal, ...params}: RequestConfig & DeleteWorkflowRequest,
  ): Promise<DeleteWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async getCatalogImportStatus(
    {abortSignal, ...params}: RequestConfig & GetCatalogImportStatusRequest = {},
  ): Promise<GetCatalogImportStatusResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCatalogImportStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImportStatus": toCatalogImportStatus,
      },
    }, await resp.json());
  }

  async getClassifier(
    {abortSignal, ...params}: RequestConfig & GetClassifierRequest,
  ): Promise<GetClassifierResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Classifier": toClassifier,
      },
    }, await resp.json());
  }

  async getClassifiers(
    {abortSignal, ...params}: RequestConfig & GetClassifiersRequest = {},
  ): Promise<GetClassifiersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClassifiers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Classifiers": [toClassifier],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & GetColumnStatisticsForPartitionRequest,
  ): Promise<GetColumnStatisticsForPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnNames: params["ColumnNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetColumnStatisticsForPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ColumnStatisticsList": [toColumnStatistics],
        "Errors": [toColumnError],
      },
    }, await resp.json());
  }

  async getColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & GetColumnStatisticsForTableRequest,
  ): Promise<GetColumnStatisticsForTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnNames: params["ColumnNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetColumnStatisticsForTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ColumnStatisticsList": [toColumnStatistics],
        "Errors": [toColumnError],
      },
    }, await resp.json());
  }

  async getConnection(
    {abortSignal, ...params}: RequestConfig & GetConnectionRequest,
  ): Promise<GetConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      HidePassword: params["HidePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  async getConnections(
    {abortSignal, ...params}: RequestConfig & GetConnectionsRequest = {},
  ): Promise<GetConnectionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Filter: fromGetConnectionsFilter(params["Filter"]),
      HidePassword: params["HidePassword"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConnectionList": [toConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getCrawler(
    {abortSignal, ...params}: RequestConfig & GetCrawlerRequest,
  ): Promise<GetCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawler": toCrawler,
      },
    }, await resp.json());
  }

  async getCrawlerMetrics(
    {abortSignal, ...params}: RequestConfig & GetCrawlerMetricsRequest = {},
  ): Promise<GetCrawlerMetricsResponse> {
    const body: jsonP.JSONObject = {
      CrawlerNameList: params["CrawlerNameList"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawlerMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrawlerMetricsList": [toCrawlerMetrics],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getCrawlers(
    {abortSignal, ...params}: RequestConfig & GetCrawlersRequest = {},
  ): Promise<GetCrawlersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawlers": [toCrawler],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDataCatalogEncryptionSettings(
    {abortSignal, ...params}: RequestConfig & GetDataCatalogEncryptionSettingsRequest = {},
  ): Promise<GetDataCatalogEncryptionSettingsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataCatalogEncryptionSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataCatalogEncryptionSettings": toDataCatalogEncryptionSettings,
      },
    }, await resp.json());
  }

  async getDatabase(
    {abortSignal, ...params}: RequestConfig & GetDatabaseRequest,
  ): Promise<GetDatabaseResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Database": toDatabase,
      },
    }, await resp.json());
  }

  async getDatabases(
    {abortSignal, ...params}: RequestConfig & GetDatabasesRequest = {},
  ): Promise<GetDatabasesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ResourceShareType: params["ResourceShareType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDatabases",
    });
    return jsonP.readObj({
      required: {
        "DatabaseList": [toDatabase],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDataflowGraph(
    {abortSignal, ...params}: RequestConfig & GetDataflowGraphRequest = {},
  ): Promise<GetDataflowGraphResponse> {
    const body: jsonP.JSONObject = {
      PythonScript: params["PythonScript"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataflowGraph",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DagNodes": [toCodeGenNode],
        "DagEdges": [toCodeGenEdge],
      },
    }, await resp.json());
  }

  async getDevEndpoint(
    {abortSignal, ...params}: RequestConfig & GetDevEndpointRequest,
  ): Promise<GetDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoint": toDevEndpoint,
      },
    }, await resp.json());
  }

  async getDevEndpoints(
    {abortSignal, ...params}: RequestConfig & GetDevEndpointsRequest = {},
  ): Promise<GetDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoints": [toDevEndpoint],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getJob(
    {abortSignal, ...params}: RequestConfig & GetJobRequest,
  ): Promise<GetJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async getJobBookmark(
    {abortSignal, ...params}: RequestConfig & GetJobBookmarkRequest,
  ): Promise<GetJobBookmarkResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobBookmark",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobBookmarkEntry": toJobBookmarkEntry,
      },
    }, await resp.json());
  }

  async getJobRun(
    {abortSignal, ...params}: RequestConfig & GetJobRunRequest,
  ): Promise<GetJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
      PredecessorsIncluded: params["PredecessorsIncluded"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRun": toJobRun,
      },
    }, await resp.json());
  }

  async getJobRuns(
    {abortSignal, ...params}: RequestConfig & GetJobRunsRequest,
  ): Promise<GetJobRunsResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRuns": [toJobRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getJobs(
    {abortSignal, ...params}: RequestConfig & GetJobsRequest = {},
  ): Promise<GetJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMLTaskRun(
    {abortSignal, ...params}: RequestConfig & GetMLTaskRunRequest,
  ): Promise<GetMLTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      TaskRunId: params["TaskRunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "TaskRunId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TaskStatusType>(x),
        "LogGroupName": "s",
        "Properties": toTaskRunProperties,
        "ErrorString": "s",
        "StartedOn": "d",
        "LastModifiedOn": "d",
        "CompletedOn": "d",
        "ExecutionTime": "n",
      },
    }, await resp.json());
  }

  async getMLTaskRuns(
    {abortSignal, ...params}: RequestConfig & GetMLTaskRunsRequest,
  ): Promise<GetMLTaskRunsResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTaskRunFilterCriteria(params["Filter"]),
      Sort: fromTaskRunSortCriteria(params["Sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTaskRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRuns": [toTaskRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMLTransform(
    {abortSignal, ...params}: RequestConfig & GetMLTransformRequest,
  ): Promise<GetMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "Name": "s",
        "Description": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TransformStatusType>(x),
        "CreatedOn": "d",
        "LastModifiedOn": "d",
        "InputRecordTables": [toGlueTable],
        "Parameters": toTransformParameters,
        "EvaluationMetrics": toEvaluationMetrics,
        "LabelCount": "n",
        "Schema": [toSchemaColumn],
        "Role": "s",
        "GlueVersion": "s",
        "MaxCapacity": "n",
        "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
        "NumberOfWorkers": "n",
        "Timeout": "n",
        "MaxRetries": "n",
        "TransformEncryption": toTransformEncryption,
      },
    }, await resp.json());
  }

  async getMLTransforms(
    {abortSignal, ...params}: RequestConfig & GetMLTransformsRequest = {},
  ): Promise<GetMLTransformsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTransformFilterCriteria(params["Filter"]),
      Sort: fromTransformSortCriteria(params["Sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTransforms",
    });
    return jsonP.readObj({
      required: {
        "Transforms": [toMLTransform],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMapping(
    {abortSignal, ...params}: RequestConfig & GetMappingRequest,
  ): Promise<GetMappingResponse> {
    const body: jsonP.JSONObject = {
      Source: fromCatalogEntry(params["Source"]),
      Sinks: params["Sinks"]?.map(x => fromCatalogEntry(x)),
      Location: fromLocation(params["Location"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMapping",
    });
    return jsonP.readObj({
      required: {
        "Mapping": [toMappingEntry],
      },
      optional: {},
    }, await resp.json());
  }

  async getPartition(
    {abortSignal, ...params}: RequestConfig & GetPartitionRequest,
  ): Promise<GetPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partition": toPartition,
      },
    }, await resp.json());
  }

  async getPartitionIndexes(
    {abortSignal, ...params}: RequestConfig & GetPartitionIndexesRequest,
  ): Promise<GetPartitionIndexesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartitionIndexes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PartitionIndexDescriptorList": [toPartitionIndexDescriptor],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getPartitions(
    {abortSignal, ...params}: RequestConfig & GetPartitionsRequest,
  ): Promise<GetPartitionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      Expression: params["Expression"],
      NextToken: params["NextToken"],
      Segment: fromSegment(params["Segment"]),
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partitions": [toPartition],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getPlan(
    {abortSignal, ...params}: RequestConfig & GetPlanRequest,
  ): Promise<GetPlanResponse> {
    const body: jsonP.JSONObject = {
      Mapping: params["Mapping"]?.map(x => fromMappingEntry(x)),
      Source: fromCatalogEntry(params["Source"]),
      Sinks: params["Sinks"]?.map(x => fromCatalogEntry(x)),
      Location: fromLocation(params["Location"]),
      Language: params["Language"],
      AdditionalPlanOptionsMap: params["AdditionalPlanOptionsMap"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPlan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PythonScript": "s",
        "ScalaCode": "s",
      },
    }, await resp.json());
  }

  async getRegistry(
    {abortSignal, ...params}: RequestConfig & GetRegistryInput,
  ): Promise<GetRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "Description": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<RegistryStatus>(x),
        "CreatedTime": "s",
        "UpdatedTime": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicies(
    {abortSignal, ...params}: RequestConfig & GetResourcePoliciesRequest = {},
  ): Promise<GetResourcePoliciesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GetResourcePoliciesResponseList": [toGluePolicy],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & GetResourcePolicyRequest = {},
  ): Promise<GetResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyInJson": "s",
        "PolicyHash": "s",
        "CreateTime": "d",
        "UpdateTime": "d",
      },
    }, await resp.json());
  }

  async getSchema(
    {abortSignal, ...params}: RequestConfig & GetSchemaInput,
  ): Promise<GetSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "SchemaName": "s",
        "SchemaArn": "s",
        "Description": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<DataFormat>(x),
        "Compatibility": (x: jsonP.JSONValue) => cmnP.readEnum<Compatibility>(x),
        "SchemaCheckpoint": "n",
        "LatestSchemaVersion": "n",
        "NextSchemaVersion": "n",
        "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaStatus>(x),
        "CreatedTime": "s",
        "UpdatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaByDefinition(
    {abortSignal, ...params}: RequestConfig & GetSchemaByDefinitionInput,
  ): Promise<GetSchemaByDefinitionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaByDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "SchemaArn": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<DataFormat>(x),
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaVersionStatus>(x),
        "CreatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaVersion(
    {abortSignal, ...params}: RequestConfig & GetSchemaVersionInput = {},
  ): Promise<GetSchemaVersionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionId: params["SchemaVersionId"],
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "SchemaDefinition": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<DataFormat>(x),
        "SchemaArn": "s",
        "VersionNumber": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaVersionStatus>(x),
        "CreatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaVersionsDiff(
    {abortSignal, ...params}: RequestConfig & GetSchemaVersionsDiffInput,
  ): Promise<GetSchemaVersionsDiffResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      FirstSchemaVersionNumber: fromSchemaVersionNumber(params["FirstSchemaVersionNumber"]),
      SecondSchemaVersionNumber: fromSchemaVersionNumber(params["SecondSchemaVersionNumber"]),
      SchemaDiffType: params["SchemaDiffType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaVersionsDiff",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Diff": "s",
      },
    }, await resp.json());
  }

  async getSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & GetSecurityConfigurationRequest,
  ): Promise<GetSecurityConfigurationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfiguration": toSecurityConfiguration,
      },
    }, await resp.json());
  }

  async getSecurityConfigurations(
    {abortSignal, ...params}: RequestConfig & GetSecurityConfigurationsRequest = {},
  ): Promise<GetSecurityConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecurityConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfigurations": [toSecurityConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTable(
    {abortSignal, ...params}: RequestConfig & GetTableRequest,
  ): Promise<GetTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTable,
      },
    }, await resp.json());
  }

  async getTableVersion(
    {abortSignal, ...params}: RequestConfig & GetTableVersionRequest,
  ): Promise<GetTableVersionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionId: params["VersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTableVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableVersion": toTableVersion,
      },
    }, await resp.json());
  }

  async getTableVersions(
    {abortSignal, ...params}: RequestConfig & GetTableVersionsRequest,
  ): Promise<GetTableVersionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTableVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableVersions": [toTableVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTables(
    {abortSignal, ...params}: RequestConfig & GetTablesRequest,
  ): Promise<GetTablesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Expression: params["Expression"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableList": [toTable],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & GetTagsRequest,
  ): Promise<GetTagsResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getTrigger(
    {abortSignal, ...params}: RequestConfig & GetTriggerRequest,
  ): Promise<GetTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Trigger": toTrigger,
      },
    }, await resp.json());
  }

  async getTriggers(
    {abortSignal, ...params}: RequestConfig & GetTriggersRequest = {},
  ): Promise<GetTriggersResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      DependentJobName: params["DependentJobName"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Triggers": [toTrigger],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & GetUserDefinedFunctionRequest,
  ): Promise<GetUserDefinedFunctionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserDefinedFunction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserDefinedFunction": toUserDefinedFunction,
      },
    }, await resp.json());
  }

  async getUserDefinedFunctions(
    {abortSignal, ...params}: RequestConfig & GetUserDefinedFunctionsRequest,
  ): Promise<GetUserDefinedFunctionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Pattern: params["Pattern"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserDefinedFunctions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserDefinedFunctions": [toUserDefinedFunction],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getWorkflow(
    {abortSignal, ...params}: RequestConfig & GetWorkflowRequest,
  ): Promise<GetWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflow": toWorkflow,
      },
    }, await resp.json());
  }

  async getWorkflowRun(
    {abortSignal, ...params}: RequestConfig & GetWorkflowRunRequest,
  ): Promise<GetWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Run": toWorkflowRun,
      },
    }, await resp.json());
  }

  async getWorkflowRunProperties(
    {abortSignal, ...params}: RequestConfig & GetWorkflowRunPropertiesRequest,
  ): Promise<GetWorkflowRunPropertiesResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRunProperties",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunProperties": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getWorkflowRuns(
    {abortSignal, ...params}: RequestConfig & GetWorkflowRunsRequest,
  ): Promise<GetWorkflowRunsResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      IncludeGraph: params["IncludeGraph"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Runs": [toWorkflowRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async importCatalogToGlue(
    {abortSignal, ...params}: RequestConfig & ImportCatalogToGlueRequest = {},
  ): Promise<ImportCatalogToGlueResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCatalogToGlue",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async listCrawlers(
    {abortSignal, ...params}: RequestConfig & ListCrawlersRequest = {},
  ): Promise<ListCrawlersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrawlerNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDevEndpoints(
    {abortSignal, ...params}: RequestConfig & ListDevEndpointsRequest = {},
  ): Promise<ListDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpointNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & ListJobsRequest = {},
  ): Promise<ListJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMLTransforms(
    {abortSignal, ...params}: RequestConfig & ListMLTransformsRequest = {},
  ): Promise<ListMLTransformsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTransformFilterCriteria(params["Filter"]),
      Sort: fromTransformSortCriteria(params["Sort"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMLTransforms",
    });
    return jsonP.readObj({
      required: {
        "TransformIds": ["s"],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRegistries(
    {abortSignal, ...params}: RequestConfig & ListRegistriesInput = {},
  ): Promise<ListRegistriesResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRegistries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Registries": [toRegistryListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemaVersions(
    {abortSignal, ...params}: RequestConfig & ListSchemaVersionsInput,
  ): Promise<ListSchemaVersionsResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemaVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Schemas": [toSchemaVersionListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemas(
    {abortSignal, ...params}: RequestConfig & ListSchemasInput = {},
  ): Promise<ListSchemasResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Schemas": [toSchemaListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTriggers(
    {abortSignal, ...params}: RequestConfig & ListTriggersRequest = {},
  ): Promise<ListTriggersResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      DependentJobName: params["DependentJobName"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TriggerNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkflows(
    {abortSignal, ...params}: RequestConfig & ListWorkflowsRequest = {},
  ): Promise<ListWorkflowsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkflows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflows": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putDataCatalogEncryptionSettings(
    {abortSignal, ...params}: RequestConfig & PutDataCatalogEncryptionSettingsRequest,
  ): Promise<PutDataCatalogEncryptionSettingsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DataCatalogEncryptionSettings: fromDataCatalogEncryptionSettings(params["DataCatalogEncryptionSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDataCatalogEncryptionSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & PutResourcePolicyRequest,
  ): Promise<PutResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      PolicyInJson: params["PolicyInJson"],
      ResourceArn: params["ResourceArn"],
      PolicyHashCondition: params["PolicyHashCondition"],
      PolicyExistsCondition: params["PolicyExistsCondition"],
      EnableHybrid: params["EnableHybrid"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyHash": "s",
      },
    }, await resp.json());
  }

  async putSchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & PutSchemaVersionMetadataInput,
  ): Promise<PutSchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataKeyValue: fromMetadataKeyValuePair(params["MetadataKeyValue"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
        "LatestVersion": "b",
        "VersionNumber": "n",
        "SchemaVersionId": "s",
        "MetadataKey": "s",
        "MetadataValue": "s",
      },
    }, await resp.json());
  }

  async putWorkflowRunProperties(
    {abortSignal, ...params}: RequestConfig & PutWorkflowRunPropertiesRequest,
  ): Promise<PutWorkflowRunPropertiesResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      RunProperties: params["RunProperties"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutWorkflowRunProperties",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async querySchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & QuerySchemaVersionMetadataInput = {},
  ): Promise<QuerySchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataList: params["MetadataList"]?.map(x => fromMetadataKeyValuePair(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "QuerySchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MetadataInfoMap": x => jsonP.readMap(String, toMetadataInfo, x),
        "SchemaVersionId": "s",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async registerSchemaVersion(
    {abortSignal, ...params}: RequestConfig & RegisterSchemaVersionInput,
  ): Promise<RegisterSchemaVersionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterSchemaVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "VersionNumber": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaVersionStatus>(x),
      },
    }, await resp.json());
  }

  async removeSchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & RemoveSchemaVersionMetadataInput,
  ): Promise<RemoveSchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataKeyValue: fromMetadataKeyValuePair(params["MetadataKeyValue"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveSchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
        "LatestVersion": "b",
        "VersionNumber": "n",
        "SchemaVersionId": "s",
        "MetadataKey": "s",
        "MetadataValue": "s",
      },
    }, await resp.json());
  }

  async resetJobBookmark(
    {abortSignal, ...params}: RequestConfig & ResetJobBookmarkRequest,
  ): Promise<ResetJobBookmarkResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetJobBookmark",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobBookmarkEntry": toJobBookmarkEntry,
      },
    }, await resp.json());
  }

  async resumeWorkflowRun(
    {abortSignal, ...params}: RequestConfig & ResumeWorkflowRunRequest,
  ): Promise<ResumeWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      NodeIds: params["NodeIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunId": "s",
        "NodeIds": ["s"],
      },
    }, await resp.json());
  }

  async searchTables(
    {abortSignal, ...params}: RequestConfig & SearchTablesRequest = {},
  ): Promise<SearchTablesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromPropertyPredicate(x)),
      SearchText: params["SearchText"],
      SortCriteria: params["SortCriteria"]?.map(x => fromSortCriterion(x)),
      MaxResults: params["MaxResults"],
      ResourceShareType: params["ResourceShareType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "TableList": [toTable],
      },
    }, await resp.json());
  }

  async startCrawler(
    {abortSignal, ...params}: RequestConfig & StartCrawlerRequest,
  ): Promise<StartCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & StartCrawlerScheduleRequest,
  ): Promise<StartCrawlerScheduleResponse> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartCrawlerSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async startExportLabelsTaskRun(
    {abortSignal, ...params}: RequestConfig & StartExportLabelsTaskRunRequest,
  ): Promise<StartExportLabelsTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      OutputS3Path: params["OutputS3Path"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartExportLabelsTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startImportLabelsTaskRun(
    {abortSignal, ...params}: RequestConfig & StartImportLabelsTaskRunRequest,
  ): Promise<StartImportLabelsTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      InputS3Path: params["InputS3Path"],
      ReplaceAllLabels: params["ReplaceAllLabels"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImportLabelsTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startJobRun(
    {abortSignal, ...params}: RequestConfig & StartJobRunRequest,
  ): Promise<StartJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobRunId: params["JobRunId"],
      Arguments: params["Arguments"],
      AllocatedCapacity: params["AllocatedCapacity"],
      Timeout: params["Timeout"],
      MaxCapacity: params["MaxCapacity"],
      SecurityConfiguration: params["SecurityConfiguration"],
      NotificationProperty: fromNotificationProperty(params["NotificationProperty"]),
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRunId": "s",
      },
    }, await resp.json());
  }

  async startMLEvaluationTaskRun(
    {abortSignal, ...params}: RequestConfig & StartMLEvaluationTaskRunRequest,
  ): Promise<StartMLEvaluationTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMLEvaluationTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startMLLabelingSetGenerationTaskRun(
    {abortSignal, ...params}: RequestConfig & StartMLLabelingSetGenerationTaskRunRequest,
  ): Promise<StartMLLabelingSetGenerationTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      OutputS3Path: params["OutputS3Path"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMLLabelingSetGenerationTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startTrigger(
    {abortSignal, ...params}: RequestConfig & StartTriggerRequest,
  ): Promise<StartTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async startWorkflowRun(
    {abortSignal, ...params}: RequestConfig & StartWorkflowRunRequest,
  ): Promise<StartWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunId": "s",
      },
    }, await resp.json());
  }

  async stopCrawler(
    {abortSignal, ...params}: RequestConfig & StopCrawlerRequest,
  ): Promise<StopCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & StopCrawlerScheduleRequest,
  ): Promise<StopCrawlerScheduleResponse> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCrawlerSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async stopTrigger(
    {abortSignal, ...params}: RequestConfig & StopTriggerRequest,
  ): Promise<StopTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async stopWorkflowRun(
    {abortSignal, ...params}: RequestConfig & StopWorkflowRunRequest,
  ): Promise<StopWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagsToAdd: params["TagsToAdd"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagsToRemove: params["TagsToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateClassifier(
    {abortSignal, ...params}: RequestConfig & UpdateClassifierRequest = {},
  ): Promise<UpdateClassifierResponse> {
    const body: jsonP.JSONObject = {
      GrokClassifier: fromUpdateGrokClassifierRequest(params["GrokClassifier"]),
      XMLClassifier: fromUpdateXMLClassifierRequest(params["XMLClassifier"]),
      JsonClassifier: fromUpdateJsonClassifierRequest(params["JsonClassifier"]),
      CsvClassifier: fromUpdateCsvClassifierRequest(params["CsvClassifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & UpdateColumnStatisticsForPartitionRequest,
  ): Promise<UpdateColumnStatisticsForPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnStatisticsList: params["ColumnStatisticsList"]?.map(x => fromColumnStatistics(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateColumnStatisticsForPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toColumnStatisticsError],
      },
    }, await resp.json());
  }

  async updateColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & UpdateColumnStatisticsForTableRequest,
  ): Promise<UpdateColumnStatisticsForTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnStatisticsList: params["ColumnStatisticsList"]?.map(x => fromColumnStatistics(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateColumnStatisticsForTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toColumnStatisticsError],
      },
    }, await resp.json());
  }

  async updateConnection(
    {abortSignal, ...params}: RequestConfig & UpdateConnectionRequest,
  ): Promise<UpdateConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      ConnectionInput: fromConnectionInput(params["ConnectionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateCrawler(
    {abortSignal, ...params}: RequestConfig & UpdateCrawlerRequest,
  ): Promise<UpdateCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Role: params["Role"],
      DatabaseName: params["DatabaseName"],
      Description: params["Description"],
      Targets: fromCrawlerTargets(params["Targets"]),
      Schedule: params["Schedule"],
      Classifiers: params["Classifiers"],
      TablePrefix: params["TablePrefix"],
      SchemaChangePolicy: fromSchemaChangePolicy(params["SchemaChangePolicy"]),
      RecrawlPolicy: fromRecrawlPolicy(params["RecrawlPolicy"]),
      LineageConfiguration: fromLineageConfiguration(params["LineageConfiguration"]),
      Configuration: params["Configuration"],
      CrawlerSecurityConfiguration: params["CrawlerSecurityConfiguration"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & UpdateCrawlerScheduleRequest,
  ): Promise<UpdateCrawlerScheduleResponse> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
      Schedule: params["Schedule"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCrawlerSchedule",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDatabase(
    {abortSignal, ...params}: RequestConfig & UpdateDatabaseRequest,
  ): Promise<UpdateDatabaseResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      DatabaseInput: fromDatabaseInput(params["DatabaseInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDevEndpoint(
    {abortSignal, ...params}: RequestConfig & UpdateDevEndpointRequest,
  ): Promise<UpdateDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      PublicKey: params["PublicKey"],
      AddPublicKeys: params["AddPublicKeys"],
      DeletePublicKeys: params["DeletePublicKeys"],
      CustomLibraries: fromDevEndpointCustomLibraries(params["CustomLibraries"]),
      UpdateEtlLibraries: params["UpdateEtlLibraries"],
      DeleteArguments: params["DeleteArguments"],
      AddArguments: params["AddArguments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateJob(
    {abortSignal, ...params}: RequestConfig & UpdateJobRequest,
  ): Promise<UpdateJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobUpdate: fromJobUpdate(params["JobUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobName": "s",
      },
    }, await resp.json());
  }

  async updateMLTransform(
    {abortSignal, ...params}: RequestConfig & UpdateMLTransformRequest,
  ): Promise<UpdateMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      Name: params["Name"],
      Description: params["Description"],
      Parameters: fromTransformParameters(params["Parameters"]),
      Role: params["Role"],
      GlueVersion: params["GlueVersion"],
      MaxCapacity: params["MaxCapacity"],
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
      Timeout: params["Timeout"],
      MaxRetries: params["MaxRetries"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async updatePartition(
    {abortSignal, ...params}: RequestConfig & UpdatePartitionRequest,
  ): Promise<UpdatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValueList: params["PartitionValueList"],
      PartitionInput: fromPartitionInput(params["PartitionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateRegistry(
    {abortSignal, ...params}: RequestConfig & UpdateRegistryInput,
  ): Promise<UpdateRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
      },
    }, await resp.json());
  }

  async updateSchema(
    {abortSignal, ...params}: RequestConfig & UpdateSchemaInput,
  ): Promise<UpdateSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      Compatibility: params["Compatibility"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & UpdateTableRequest,
  ): Promise<UpdateTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableInput: fromTableInput(params["TableInput"]),
      SkipArchive: params["SkipArchive"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateTrigger(
    {abortSignal, ...params}: RequestConfig & UpdateTriggerRequest,
  ): Promise<UpdateTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TriggerUpdate: fromTriggerUpdate(params["TriggerUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Trigger": toTrigger,
      },
    }, await resp.json());
  }

  async updateUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & UpdateUserDefinedFunctionRequest,
  ): Promise<UpdateUserDefinedFunctionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
      FunctionInput: fromUserDefinedFunctionInput(params["FunctionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserDefinedFunction",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateWorkflow(
    {abortSignal, ...params}: RequestConfig & UpdateWorkflowRequest,
  ): Promise<UpdateWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      DefaultRunProperties: params["DefaultRunProperties"],
      MaxConcurrentRuns: params["MaxConcurrentRuns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface BatchCreatePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionInputList: PartitionInput[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteConnectionRequest {
  CatalogId?: string | null;
  ConnectionNameList: string[];
}

// refs: 1 - tags: named, input
export interface BatchDeletePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionsToDelete: PartitionValueList[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TablesToDelete: string[];
}

// refs: 1 - tags: named, input
export interface BatchDeleteTableVersionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  VersionIds: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetCrawlersRequest {
  CrawlerNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetDevEndpointsRequest {
  DevEndpointNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetJobsRequest {
  JobNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetPartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionsToGet: PartitionValueList[];
}

// refs: 1 - tags: named, input
export interface BatchGetTriggersRequest {
  TriggerNames: string[];
}

// refs: 1 - tags: named, input
export interface BatchGetWorkflowsRequest {
  Names: string[];
  IncludeGraph?: boolean | null;
}

// refs: 1 - tags: named, input
export interface BatchStopJobRunRequest {
  JobName: string;
  JobRunIds: string[];
}

// refs: 1 - tags: named, input
export interface BatchUpdatePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  Entries: BatchUpdatePartitionRequestEntry[];
}

// refs: 1 - tags: named, input
export interface CancelMLTaskRunRequest {
  TransformId: string;
  TaskRunId: string;
}

// refs: 1 - tags: named, input
export interface CheckSchemaVersionValidityInput {
  DataFormat: DataFormat;
  SchemaDefinition: string;
}

// refs: 1 - tags: named, input
export interface CreateClassifierRequest {
  GrokClassifier?: CreateGrokClassifierRequest | null;
  XMLClassifier?: CreateXMLClassifierRequest | null;
  JsonClassifier?: CreateJsonClassifierRequest | null;
  CsvClassifier?: CreateCsvClassifierRequest | null;
}

// refs: 1 - tags: named, input
export interface CreateConnectionRequest {
  CatalogId?: string | null;
  ConnectionInput: ConnectionInput;
}

// refs: 1 - tags: named, input
export interface CreateCrawlerRequest {
  Name: string;
  Role: string;
  DatabaseName?: string | null;
  Description?: string | null;
  Targets: CrawlerTargets;
  Schedule?: string | null;
  Classifiers?: string[] | null;
  TablePrefix?: string | null;
  SchemaChangePolicy?: SchemaChangePolicy | null;
  RecrawlPolicy?: RecrawlPolicy | null;
  LineageConfiguration?: LineageConfiguration | null;
  Configuration?: string | null;
  CrawlerSecurityConfiguration?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateDatabaseRequest {
  CatalogId?: string | null;
  DatabaseInput: DatabaseInput;
}

// refs: 1 - tags: named, input
export interface CreateDevEndpointRequest {
  EndpointName: string;
  RoleArn: string;
  SecurityGroupIds?: string[] | null;
  SubnetId?: string | null;
  PublicKey?: string | null;
  PublicKeys?: string[] | null;
  NumberOfNodes?: number | null;
  WorkerType?: WorkerType | null;
  GlueVersion?: string | null;
  NumberOfWorkers?: number | null;
  ExtraPythonLibsS3Path?: string | null;
  ExtraJarsS3Path?: string | null;
  SecurityConfiguration?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateJobRequest {
  Name: string;
  Description?: string | null;
  LogUri?: string | null;
  Role: string;
  ExecutionProperty?: ExecutionProperty | null;
  Command: JobCommand;
  DefaultArguments?: { [key: string]: string | null | undefined } | null;
  NonOverridableArguments?: { [key: string]: string | null | undefined } | null;
  Connections?: ConnectionsList | null;
  MaxRetries?: number | null;
  AllocatedCapacity?: number | null;
  Timeout?: number | null;
  MaxCapacity?: number | null;
  SecurityConfiguration?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  NotificationProperty?: NotificationProperty | null;
  GlueVersion?: string | null;
  NumberOfWorkers?: number | null;
  WorkerType?: WorkerType | null;
}

// refs: 1 - tags: named, input
export interface CreateMLTransformRequest {
  Name: string;
  Description?: string | null;
  InputRecordTables: GlueTable[];
  Parameters: TransformParameters;
  Role: string;
  GlueVersion?: string | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  Timeout?: number | null;
  MaxRetries?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  TransformEncryption?: TransformEncryption | null;
}

// refs: 1 - tags: named, input
export interface CreatePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionInput: PartitionInput;
}

// refs: 1 - tags: named, input
export interface CreatePartitionIndexRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionIndex: PartitionIndex;
}

// refs: 1 - tags: named, input
export interface CreateRegistryInput {
  RegistryName: string;
  Description?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateSchemaInput {
  RegistryId?: RegistryId | null;
  SchemaName: string;
  DataFormat: DataFormat;
  Compatibility?: Compatibility | null;
  Description?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  SchemaDefinition?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateScriptRequest {
  DagNodes?: CodeGenNode[] | null;
  DagEdges?: CodeGenEdge[] | null;
  Language?: Language | null;
}

// refs: 1 - tags: named, input
export interface CreateSecurityConfigurationRequest {
  Name: string;
  EncryptionConfiguration: EncryptionConfiguration;
}

// refs: 1 - tags: named, input
export interface CreateTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableInput: TableInput;
  PartitionIndexes?: PartitionIndex[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTriggerRequest {
  Name: string;
  WorkflowName?: string | null;
  Type: TriggerType;
  Schedule?: string | null;
  Predicate?: Predicate | null;
  Actions: Action[];
  Description?: string | null;
  StartOnCreation?: boolean | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface CreateUserDefinedFunctionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  FunctionInput: UserDefinedFunctionInput;
}

// refs: 1 - tags: named, input
export interface CreateWorkflowRequest {
  Name: string;
  Description?: string | null;
  DefaultRunProperties?: { [key: string]: string | null | undefined } | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  MaxConcurrentRuns?: number | null;
}

// refs: 1 - tags: named, input
export interface DeleteClassifierRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteColumnStatisticsForPartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValues: string[];
  ColumnName: string;
}

// refs: 1 - tags: named, input
export interface DeleteColumnStatisticsForTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  ColumnName: string;
}

// refs: 1 - tags: named, input
export interface DeleteConnectionRequest {
  CatalogId?: string | null;
  ConnectionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCrawlerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteDatabaseRequest {
  CatalogId?: string | null;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteDevEndpointRequest {
  EndpointName: string;
}

// refs: 1 - tags: named, input
export interface DeleteJobRequest {
  JobName: string;
}

// refs: 1 - tags: named, input
export interface DeleteMLTransformRequest {
  TransformId: string;
}

// refs: 1 - tags: named, input
export interface DeletePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValues: string[];
}

// refs: 1 - tags: named, input
export interface DeletePartitionIndexRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  IndexName: string;
}

// refs: 1 - tags: named, input
export interface DeleteRegistryInput {
  RegistryId: RegistryId;
}

// refs: 1 - tags: named, input
export interface DeleteResourcePolicyRequest {
  PolicyHashCondition?: string | null;
  ResourceArn?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteSchemaInput {
  SchemaId: SchemaId;
}

// refs: 1 - tags: named, input
export interface DeleteSchemaVersionsInput {
  SchemaId: SchemaId;
  Versions: string;
}

// refs: 1 - tags: named, input
export interface DeleteSecurityConfigurationRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteTableVersionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  VersionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteTriggerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserDefinedFunctionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  FunctionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteWorkflowRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetCatalogImportStatusRequest {
  CatalogId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetClassifierRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetClassifiersRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetColumnStatisticsForPartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValues: string[];
  ColumnNames: string[];
}

// refs: 1 - tags: named, input
export interface GetColumnStatisticsForTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  ColumnNames: string[];
}

// refs: 1 - tags: named, input
export interface GetConnectionRequest {
  CatalogId?: string | null;
  Name: string;
  HidePassword?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetConnectionsRequest {
  CatalogId?: string | null;
  Filter?: GetConnectionsFilter | null;
  HidePassword?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetCrawlerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetCrawlerMetricsRequest {
  CrawlerNameList?: string[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCrawlersRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetDataCatalogEncryptionSettingsRequest {
  CatalogId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetDatabaseRequest {
  CatalogId?: string | null;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetDatabasesRequest {
  CatalogId?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  ResourceShareType?: ResourceShareType | null;
}

// refs: 1 - tags: named, input
export interface GetDataflowGraphRequest {
  PythonScript?: string | null;
}

// refs: 1 - tags: named, input
export interface GetDevEndpointRequest {
  EndpointName: string;
}

// refs: 1 - tags: named, input
export interface GetDevEndpointsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetJobRequest {
  JobName: string;
}

// refs: 1 - tags: named, input
export interface GetJobBookmarkRequest {
  JobName: string;
  RunId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetJobRunRequest {
  JobName: string;
  RunId: string;
  PredecessorsIncluded?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetJobRunsRequest {
  JobName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetMLTaskRunRequest {
  TransformId: string;
  TaskRunId: string;
}

// refs: 1 - tags: named, input
export interface GetMLTaskRunsRequest {
  TransformId: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  Filter?: TaskRunFilterCriteria | null;
  Sort?: TaskRunSortCriteria | null;
}

// refs: 1 - tags: named, input
export interface GetMLTransformRequest {
  TransformId: string;
}

// refs: 1 - tags: named, input
export interface GetMLTransformsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filter?: TransformFilterCriteria | null;
  Sort?: TransformSortCriteria | null;
}

// refs: 1 - tags: named, input
export interface GetMappingRequest {
  Source: CatalogEntry;
  Sinks?: CatalogEntry[] | null;
  Location?: Location | null;
}

// refs: 1 - tags: named, input
export interface GetPartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValues: string[];
}

// refs: 1 - tags: named, input
export interface GetPartitionIndexesRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPartitionsRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  Expression?: string | null;
  NextToken?: string | null;
  Segment?: Segment | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetPlanRequest {
  Mapping: MappingEntry[];
  Source: CatalogEntry;
  Sinks?: CatalogEntry[] | null;
  Location?: Location | null;
  Language?: Language | null;
  AdditionalPlanOptionsMap?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface GetRegistryInput {
  RegistryId: RegistryId;
}

// refs: 1 - tags: named, input
export interface GetResourcePoliciesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetResourcePolicyRequest {
  ResourceArn?: string | null;
}

// refs: 1 - tags: named, input
export interface GetSchemaInput {
  SchemaId: SchemaId;
}

// refs: 1 - tags: named, input
export interface GetSchemaByDefinitionInput {
  SchemaId: SchemaId;
  SchemaDefinition: string;
}

// refs: 1 - tags: named, input
export interface GetSchemaVersionInput {
  SchemaId?: SchemaId | null;
  SchemaVersionId?: string | null;
  SchemaVersionNumber?: SchemaVersionNumber | null;
}

// refs: 1 - tags: named, input
export interface GetSchemaVersionsDiffInput {
  SchemaId: SchemaId;
  FirstSchemaVersionNumber: SchemaVersionNumber;
  SecondSchemaVersionNumber: SchemaVersionNumber;
  SchemaDiffType: SchemaDiffType;
}

// refs: 1 - tags: named, input
export interface GetSecurityConfigurationRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetSecurityConfigurationsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetTableVersionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  VersionId?: string | null;
}

// refs: 1 - tags: named, input
export interface GetTableVersionsRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetTablesRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  Expression?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetTagsRequest {
  ResourceArn: string;
}

// refs: 1 - tags: named, input
export interface GetTriggerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetTriggersRequest {
  NextToken?: string | null;
  DependentJobName?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetUserDefinedFunctionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  FunctionName: string;
}

// refs: 1 - tags: named, input
export interface GetUserDefinedFunctionsRequest {
  CatalogId?: string | null;
  DatabaseName?: string | null;
  Pattern: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface GetWorkflowRequest {
  Name: string;
  IncludeGraph?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetWorkflowRunRequest {
  Name: string;
  RunId: string;
  IncludeGraph?: boolean | null;
}

// refs: 1 - tags: named, input
export interface GetWorkflowRunPropertiesRequest {
  Name: string;
  RunId: string;
}

// refs: 1 - tags: named, input
export interface GetWorkflowRunsRequest {
  Name: string;
  IncludeGraph?: boolean | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ImportCatalogToGlueRequest {
  CatalogId?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCrawlersRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListDevEndpointsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListMLTransformsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  Filter?: TransformFilterCriteria | null;
  Sort?: TransformSortCriteria | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListRegistriesInput {
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSchemaVersionsInput {
  SchemaId: SchemaId;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListSchemasInput {
  RegistryId?: RegistryId | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTriggersRequest {
  NextToken?: string | null;
  DependentJobName?: string | null;
  MaxResults?: number | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface ListWorkflowsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface PutDataCatalogEncryptionSettingsRequest {
  CatalogId?: string | null;
  DataCatalogEncryptionSettings: DataCatalogEncryptionSettings;
}

// refs: 1 - tags: named, input
export interface PutResourcePolicyRequest {
  PolicyInJson: string;
  ResourceArn?: string | null;
  PolicyHashCondition?: string | null;
  PolicyExistsCondition?: ExistCondition | null;
  EnableHybrid?: EnableHybridValues | null;
}

// refs: 1 - tags: named, input
export interface PutSchemaVersionMetadataInput {
  SchemaId?: SchemaId | null;
  SchemaVersionNumber?: SchemaVersionNumber | null;
  SchemaVersionId?: string | null;
  MetadataKeyValue: MetadataKeyValuePair;
}

// refs: 1 - tags: named, input
export interface PutWorkflowRunPropertiesRequest {
  Name: string;
  RunId: string;
  RunProperties: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface QuerySchemaVersionMetadataInput {
  SchemaId?: SchemaId | null;
  SchemaVersionNumber?: SchemaVersionNumber | null;
  SchemaVersionId?: string | null;
  MetadataList?: MetadataKeyValuePair[] | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface RegisterSchemaVersionInput {
  SchemaId: SchemaId;
  SchemaDefinition: string;
}

// refs: 1 - tags: named, input
export interface RemoveSchemaVersionMetadataInput {
  SchemaId?: SchemaId | null;
  SchemaVersionNumber?: SchemaVersionNumber | null;
  SchemaVersionId?: string | null;
  MetadataKeyValue: MetadataKeyValuePair;
}

// refs: 1 - tags: named, input
export interface ResetJobBookmarkRequest {
  JobName: string;
  RunId?: string | null;
}

// refs: 1 - tags: named, input
export interface ResumeWorkflowRunRequest {
  Name: string;
  RunId: string;
  NodeIds: string[];
}

// refs: 1 - tags: named, input
export interface SearchTablesRequest {
  CatalogId?: string | null;
  NextToken?: string | null;
  Filters?: PropertyPredicate[] | null;
  SearchText?: string | null;
  SortCriteria?: SortCriterion[] | null;
  MaxResults?: number | null;
  ResourceShareType?: ResourceShareType | null;
}

// refs: 1 - tags: named, input
export interface StartCrawlerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StartCrawlerScheduleRequest {
  CrawlerName: string;
}

// refs: 1 - tags: named, input
export interface StartExportLabelsTaskRunRequest {
  TransformId: string;
  OutputS3Path: string;
}

// refs: 1 - tags: named, input
export interface StartImportLabelsTaskRunRequest {
  TransformId: string;
  InputS3Path: string;
  ReplaceAllLabels?: boolean | null;
}

// refs: 1 - tags: named, input
export interface StartJobRunRequest {
  JobName: string;
  JobRunId?: string | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
  AllocatedCapacity?: number | null;
  Timeout?: number | null;
  MaxCapacity?: number | null;
  SecurityConfiguration?: string | null;
  NotificationProperty?: NotificationProperty | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
}

// refs: 1 - tags: named, input
export interface StartMLEvaluationTaskRunRequest {
  TransformId: string;
}

// refs: 1 - tags: named, input
export interface StartMLLabelingSetGenerationTaskRunRequest {
  TransformId: string;
  OutputS3Path: string;
}

// refs: 1 - tags: named, input
export interface StartTriggerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StartWorkflowRunRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StopCrawlerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StopCrawlerScheduleRequest {
  CrawlerName: string;
}

// refs: 1 - tags: named, input
export interface StopTriggerRequest {
  Name: string;
}

// refs: 1 - tags: named, input
export interface StopWorkflowRunRequest {
  Name: string;
  RunId: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceArn: string;
  TagsToAdd: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceArn: string;
  TagsToRemove: string[];
}

// refs: 1 - tags: named, input
export interface UpdateClassifierRequest {
  GrokClassifier?: UpdateGrokClassifierRequest | null;
  XMLClassifier?: UpdateXMLClassifierRequest | null;
  JsonClassifier?: UpdateJsonClassifierRequest | null;
  CsvClassifier?: UpdateCsvClassifierRequest | null;
}

// refs: 1 - tags: named, input
export interface UpdateColumnStatisticsForPartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValues: string[];
  ColumnStatisticsList: ColumnStatistics[];
}

// refs: 1 - tags: named, input
export interface UpdateColumnStatisticsForTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  ColumnStatisticsList: ColumnStatistics[];
}

// refs: 1 - tags: named, input
export interface UpdateConnectionRequest {
  CatalogId?: string | null;
  Name: string;
  ConnectionInput: ConnectionInput;
}

// refs: 1 - tags: named, input
export interface UpdateCrawlerRequest {
  Name: string;
  Role?: string | null;
  DatabaseName?: string | null;
  Description?: string | null;
  Targets?: CrawlerTargets | null;
  Schedule?: string | null;
  Classifiers?: string[] | null;
  TablePrefix?: string | null;
  SchemaChangePolicy?: SchemaChangePolicy | null;
  RecrawlPolicy?: RecrawlPolicy | null;
  LineageConfiguration?: LineageConfiguration | null;
  Configuration?: string | null;
  CrawlerSecurityConfiguration?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateCrawlerScheduleRequest {
  CrawlerName: string;
  Schedule?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateDatabaseRequest {
  CatalogId?: string | null;
  Name: string;
  DatabaseInput: DatabaseInput;
}

// refs: 1 - tags: named, input
export interface UpdateDevEndpointRequest {
  EndpointName: string;
  PublicKey?: string | null;
  AddPublicKeys?: string[] | null;
  DeletePublicKeys?: string[] | null;
  CustomLibraries?: DevEndpointCustomLibraries | null;
  UpdateEtlLibraries?: boolean | null;
  DeleteArguments?: string[] | null;
  AddArguments?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, input
export interface UpdateJobRequest {
  JobName: string;
  JobUpdate: JobUpdate;
}

// refs: 1 - tags: named, input
export interface UpdateMLTransformRequest {
  TransformId: string;
  Name?: string | null;
  Description?: string | null;
  Parameters?: TransformParameters | null;
  Role?: string | null;
  GlueVersion?: string | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  Timeout?: number | null;
  MaxRetries?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdatePartitionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableName: string;
  PartitionValueList: string[];
  PartitionInput: PartitionInput;
}

// refs: 1 - tags: named, input
export interface UpdateRegistryInput {
  RegistryId: RegistryId;
  Description: string;
}

// refs: 1 - tags: named, input
export interface UpdateSchemaInput {
  SchemaId: SchemaId;
  SchemaVersionNumber?: SchemaVersionNumber | null;
  Compatibility?: Compatibility | null;
  Description?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateTableRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  TableInput: TableInput;
  SkipArchive?: boolean | null;
}

// refs: 1 - tags: named, input
export interface UpdateTriggerRequest {
  Name: string;
  TriggerUpdate: TriggerUpdate;
}

// refs: 1 - tags: named, input
export interface UpdateUserDefinedFunctionRequest {
  CatalogId?: string | null;
  DatabaseName: string;
  FunctionName: string;
  FunctionInput: UserDefinedFunctionInput;
}

// refs: 1 - tags: named, input
export interface UpdateWorkflowRequest {
  Name: string;
  Description?: string | null;
  DefaultRunProperties?: { [key: string]: string | null | undefined } | null;
  MaxConcurrentRuns?: number | null;
}

// refs: 1 - tags: named, output
export interface BatchCreatePartitionResponse {
  Errors?: PartitionError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteConnectionResponse {
  Succeeded?: string[] | null;
  Errors?: { [key: string]: ErrorDetail | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface BatchDeletePartitionResponse {
  Errors?: PartitionError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteTableResponse {
  Errors?: TableError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchDeleteTableVersionResponse {
  Errors?: TableVersionError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetCrawlersResponse {
  Crawlers?: Crawler[] | null;
  CrawlersNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetDevEndpointsResponse {
  DevEndpoints?: DevEndpoint[] | null;
  DevEndpointsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetJobsResponse {
  Jobs?: Job[] | null;
  JobsNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetPartitionResponse {
  Partitions?: Partition[] | null;
  UnprocessedKeys?: PartitionValueList[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetTriggersResponse {
  Triggers?: Trigger[] | null;
  TriggersNotFound?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchGetWorkflowsResponse {
  Workflows?: Workflow[] | null;
  MissingWorkflows?: string[] | null;
}

// refs: 1 - tags: named, output
export interface BatchStopJobRunResponse {
  SuccessfulSubmissions?: BatchStopJobRunSuccessfulSubmission[] | null;
  Errors?: BatchStopJobRunError[] | null;
}

// refs: 1 - tags: named, output
export interface BatchUpdatePartitionResponse {
  Errors?: BatchUpdatePartitionFailureEntry[] | null;
}

// refs: 1 - tags: named, output
export interface CancelMLTaskRunResponse {
  TransformId?: string | null;
  TaskRunId?: string | null;
  Status?: TaskStatusType | null;
}

// refs: 1 - tags: named, output
export interface CheckSchemaVersionValidityResponse {
  Valid?: boolean | null;
  Error?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateClassifierResponse {
}

// refs: 1 - tags: named, output
export interface CreateConnectionResponse {
}

// refs: 1 - tags: named, output
export interface CreateCrawlerResponse {
}

// refs: 1 - tags: named, output
export interface CreateDatabaseResponse {
}

// refs: 1 - tags: named, output
export interface CreateDevEndpointResponse {
  EndpointName?: string | null;
  Status?: string | null;
  SecurityGroupIds?: string[] | null;
  SubnetId?: string | null;
  RoleArn?: string | null;
  YarnEndpointAddress?: string | null;
  ZeppelinRemoteSparkInterpreterPort?: number | null;
  NumberOfNodes?: number | null;
  WorkerType?: WorkerType | null;
  GlueVersion?: string | null;
  NumberOfWorkers?: number | null;
  AvailabilityZone?: string | null;
  VpcId?: string | null;
  ExtraPythonLibsS3Path?: string | null;
  ExtraJarsS3Path?: string | null;
  FailureReason?: string | null;
  SecurityConfiguration?: string | null;
  CreatedTimestamp?: Date | number | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateJobResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateMLTransformResponse {
  TransformId?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePartitionResponse {
}

// refs: 1 - tags: named, output
export interface CreatePartitionIndexResponse {
}

// refs: 1 - tags: named, output
export interface CreateRegistryResponse {
  RegistryArn?: string | null;
  RegistryName?: string | null;
  Description?: string | null;
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateSchemaResponse {
  RegistryName?: string | null;
  RegistryArn?: string | null;
  SchemaName?: string | null;
  SchemaArn?: string | null;
  Description?: string | null;
  DataFormat?: DataFormat | null;
  Compatibility?: Compatibility | null;
  SchemaCheckpoint?: number | null;
  LatestSchemaVersion?: number | null;
  NextSchemaVersion?: number | null;
  SchemaStatus?: SchemaStatus | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  SchemaVersionId?: string | null;
  SchemaVersionStatus?: SchemaVersionStatus | null;
}

// refs: 1 - tags: named, output
export interface CreateScriptResponse {
  PythonScript?: string | null;
  ScalaCode?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateSecurityConfigurationResponse {
  Name?: string | null;
  CreatedTimestamp?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface CreateTableResponse {
}

// refs: 1 - tags: named, output
export interface CreateTriggerResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateUserDefinedFunctionResponse {
}

// refs: 1 - tags: named, output
export interface CreateWorkflowResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteClassifierResponse {
}

// refs: 1 - tags: named, output
export interface DeleteColumnStatisticsForPartitionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteColumnStatisticsForTableResponse {
}

// refs: 1 - tags: named, output
export interface DeleteConnectionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteCrawlerResponse {
}

// refs: 1 - tags: named, output
export interface DeleteDatabaseResponse {
}

// refs: 1 - tags: named, output
export interface DeleteDevEndpointResponse {
}

// refs: 1 - tags: named, output
export interface DeleteJobResponse {
  JobName?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteMLTransformResponse {
  TransformId?: string | null;
}

// refs: 1 - tags: named, output
export interface DeletePartitionResponse {
}

// refs: 1 - tags: named, output
export interface DeletePartitionIndexResponse {
}

// refs: 1 - tags: named, output
export interface DeleteRegistryResponse {
  RegistryName?: string | null;
  RegistryArn?: string | null;
  Status?: RegistryStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteResourcePolicyResponse {
}

// refs: 1 - tags: named, output
export interface DeleteSchemaResponse {
  SchemaArn?: string | null;
  SchemaName?: string | null;
  Status?: SchemaStatus | null;
}

// refs: 1 - tags: named, output
export interface DeleteSchemaVersionsResponse {
  SchemaVersionErrors?: SchemaVersionErrorItem[] | null;
}

// refs: 1 - tags: named, output
export interface DeleteSecurityConfigurationResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTableResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTableVersionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTriggerResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteUserDefinedFunctionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteWorkflowResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCatalogImportStatusResponse {
  ImportStatus?: CatalogImportStatus | null;
}

// refs: 1 - tags: named, output
export interface GetClassifierResponse {
  Classifier?: Classifier | null;
}

// refs: 1 - tags: named, output
export interface GetClassifiersResponse {
  Classifiers?: Classifier[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetColumnStatisticsForPartitionResponse {
  ColumnStatisticsList?: ColumnStatistics[] | null;
  Errors?: ColumnError[] | null;
}

// refs: 1 - tags: named, output
export interface GetColumnStatisticsForTableResponse {
  ColumnStatisticsList?: ColumnStatistics[] | null;
  Errors?: ColumnError[] | null;
}

// refs: 1 - tags: named, output
export interface GetConnectionResponse {
  Connection?: Connection | null;
}

// refs: 1 - tags: named, output
export interface GetConnectionsResponse {
  ConnectionList?: Connection[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCrawlerResponse {
  Crawler?: Crawler | null;
}

// refs: 1 - tags: named, output
export interface GetCrawlerMetricsResponse {
  CrawlerMetricsList?: CrawlerMetrics[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCrawlersResponse {
  Crawlers?: Crawler[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDataCatalogEncryptionSettingsResponse {
  DataCatalogEncryptionSettings?: DataCatalogEncryptionSettings | null;
}

// refs: 1 - tags: named, output
export interface GetDatabaseResponse {
  Database?: Database | null;
}

// refs: 1 - tags: named, output
export interface GetDatabasesResponse {
  DatabaseList: Database[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDataflowGraphResponse {
  DagNodes?: CodeGenNode[] | null;
  DagEdges?: CodeGenEdge[] | null;
}

// refs: 1 - tags: named, output
export interface GetDevEndpointResponse {
  DevEndpoint?: DevEndpoint | null;
}

// refs: 1 - tags: named, output
export interface GetDevEndpointsResponse {
  DevEndpoints?: DevEndpoint[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetJobResponse {
  Job?: Job | null;
}

// refs: 1 - tags: named, output
export interface GetJobBookmarkResponse {
  JobBookmarkEntry?: JobBookmarkEntry | null;
}

// refs: 1 - tags: named, output
export interface GetJobRunResponse {
  JobRun?: JobRun | null;
}

// refs: 1 - tags: named, output
export interface GetJobRunsResponse {
  JobRuns?: JobRun[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetJobsResponse {
  Jobs?: Job[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMLTaskRunResponse {
  TransformId?: string | null;
  TaskRunId?: string | null;
  Status?: TaskStatusType | null;
  LogGroupName?: string | null;
  Properties?: TaskRunProperties | null;
  ErrorString?: string | null;
  StartedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  CompletedOn?: Date | number | null;
  ExecutionTime?: number | null;
}

// refs: 1 - tags: named, output
export interface GetMLTaskRunsResponse {
  TaskRuns?: TaskRun[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMLTransformResponse {
  TransformId?: string | null;
  Name?: string | null;
  Description?: string | null;
  Status?: TransformStatusType | null;
  CreatedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  InputRecordTables?: GlueTable[] | null;
  Parameters?: TransformParameters | null;
  EvaluationMetrics?: EvaluationMetrics | null;
  LabelCount?: number | null;
  Schema?: SchemaColumn[] | null;
  Role?: string | null;
  GlueVersion?: string | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  Timeout?: number | null;
  MaxRetries?: number | null;
  TransformEncryption?: TransformEncryption | null;
}

// refs: 1 - tags: named, output
export interface GetMLTransformsResponse {
  Transforms: MLTransform[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMappingResponse {
  Mapping: MappingEntry[];
}

// refs: 1 - tags: named, output
export interface GetPartitionResponse {
  Partition?: Partition | null;
}

// refs: 1 - tags: named, output
export interface GetPartitionIndexesResponse {
  PartitionIndexDescriptorList?: PartitionIndexDescriptor[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPartitionsResponse {
  Partitions?: Partition[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPlanResponse {
  PythonScript?: string | null;
  ScalaCode?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRegistryResponse {
  RegistryName?: string | null;
  RegistryArn?: string | null;
  Description?: string | null;
  Status?: RegistryStatus | null;
  CreatedTime?: string | null;
  UpdatedTime?: string | null;
}

// refs: 1 - tags: named, output
export interface GetResourcePoliciesResponse {
  GetResourcePoliciesResponseList?: GluePolicy[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetResourcePolicyResponse {
  PolicyInJson?: string | null;
  PolicyHash?: string | null;
  CreateTime?: Date | number | null;
  UpdateTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetSchemaResponse {
  RegistryName?: string | null;
  RegistryArn?: string | null;
  SchemaName?: string | null;
  SchemaArn?: string | null;
  Description?: string | null;
  DataFormat?: DataFormat | null;
  Compatibility?: Compatibility | null;
  SchemaCheckpoint?: number | null;
  LatestSchemaVersion?: number | null;
  NextSchemaVersion?: number | null;
  SchemaStatus?: SchemaStatus | null;
  CreatedTime?: string | null;
  UpdatedTime?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSchemaByDefinitionResponse {
  SchemaVersionId?: string | null;
  SchemaArn?: string | null;
  DataFormat?: DataFormat | null;
  Status?: SchemaVersionStatus | null;
  CreatedTime?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSchemaVersionResponse {
  SchemaVersionId?: string | null;
  SchemaDefinition?: string | null;
  DataFormat?: DataFormat | null;
  SchemaArn?: string | null;
  VersionNumber?: number | null;
  Status?: SchemaVersionStatus | null;
  CreatedTime?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSchemaVersionsDiffResponse {
  Diff?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSecurityConfigurationResponse {
  SecurityConfiguration?: SecurityConfiguration | null;
}

// refs: 1 - tags: named, output
export interface GetSecurityConfigurationsResponse {
  SecurityConfigurations?: SecurityConfiguration[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTableResponse {
  Table?: Table | null;
}

// refs: 1 - tags: named, output
export interface GetTableVersionResponse {
  TableVersion?: TableVersion | null;
}

// refs: 1 - tags: named, output
export interface GetTableVersionsResponse {
  TableVersions?: TableVersion[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTablesResponse {
  TableList?: Table[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetTagsResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface GetTriggerResponse {
  Trigger?: Trigger | null;
}

// refs: 1 - tags: named, output
export interface GetTriggersResponse {
  Triggers?: Trigger[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetUserDefinedFunctionResponse {
  UserDefinedFunction?: UserDefinedFunction | null;
}

// refs: 1 - tags: named, output
export interface GetUserDefinedFunctionsResponse {
  UserDefinedFunctions?: UserDefinedFunction[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetWorkflowResponse {
  Workflow?: Workflow | null;
}

// refs: 1 - tags: named, output
export interface GetWorkflowRunResponse {
  Run?: WorkflowRun | null;
}

// refs: 1 - tags: named, output
export interface GetWorkflowRunPropertiesResponse {
  RunProperties?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface GetWorkflowRunsResponse {
  Runs?: WorkflowRun[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ImportCatalogToGlueResponse {
}

// refs: 1 - tags: named, output
export interface ListCrawlersResponse {
  CrawlerNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDevEndpointsResponse {
  DevEndpointNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListJobsResponse {
  JobNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMLTransformsResponse {
  TransformIds: string[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRegistriesResponse {
  Registries?: RegistryListItem[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSchemaVersionsResponse {
  Schemas?: SchemaVersionListItem[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSchemasResponse {
  Schemas?: SchemaListItem[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTriggersResponse {
  TriggerNames?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListWorkflowsResponse {
  Workflows?: string[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutDataCatalogEncryptionSettingsResponse {
}

// refs: 1 - tags: named, output
export interface PutResourcePolicyResponse {
  PolicyHash?: string | null;
}

// refs: 1 - tags: named, output
export interface PutSchemaVersionMetadataResponse {
  SchemaArn?: string | null;
  SchemaName?: string | null;
  RegistryName?: string | null;
  LatestVersion?: boolean | null;
  VersionNumber?: number | null;
  SchemaVersionId?: string | null;
  MetadataKey?: string | null;
  MetadataValue?: string | null;
}

// refs: 1 - tags: named, output
export interface PutWorkflowRunPropertiesResponse {
}

// refs: 1 - tags: named, output
export interface QuerySchemaVersionMetadataResponse {
  MetadataInfoMap?: { [key: string]: MetadataInfo | null | undefined } | null;
  SchemaVersionId?: string | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface RegisterSchemaVersionResponse {
  SchemaVersionId?: string | null;
  VersionNumber?: number | null;
  Status?: SchemaVersionStatus | null;
}

// refs: 1 - tags: named, output
export interface RemoveSchemaVersionMetadataResponse {
  SchemaArn?: string | null;
  SchemaName?: string | null;
  RegistryName?: string | null;
  LatestVersion?: boolean | null;
  VersionNumber?: number | null;
  SchemaVersionId?: string | null;
  MetadataKey?: string | null;
  MetadataValue?: string | null;
}

// refs: 1 - tags: named, output
export interface ResetJobBookmarkResponse {
  JobBookmarkEntry?: JobBookmarkEntry | null;
}

// refs: 1 - tags: named, output
export interface ResumeWorkflowRunResponse {
  RunId?: string | null;
  NodeIds?: string[] | null;
}

// refs: 1 - tags: named, output
export interface SearchTablesResponse {
  NextToken?: string | null;
  TableList?: Table[] | null;
}

// refs: 1 - tags: named, output
export interface StartCrawlerResponse {
}

// refs: 1 - tags: named, output
export interface StartCrawlerScheduleResponse {
}

// refs: 1 - tags: named, output
export interface StartExportLabelsTaskRunResponse {
  TaskRunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartImportLabelsTaskRunResponse {
  TaskRunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartJobRunResponse {
  JobRunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartMLEvaluationTaskRunResponse {
  TaskRunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartMLLabelingSetGenerationTaskRunResponse {
  TaskRunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartTriggerResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface StartWorkflowRunResponse {
  RunId?: string | null;
}

// refs: 1 - tags: named, output
export interface StopCrawlerResponse {
}

// refs: 1 - tags: named, output
export interface StopCrawlerScheduleResponse {
}

// refs: 1 - tags: named, output
export interface StopTriggerResponse {
  Name?: string | null;
}

// refs: 1 - tags: named, output
export interface StopWorkflowRunResponse {
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateClassifierResponse {
}

// refs: 1 - tags: named, output
export interface UpdateColumnStatisticsForPartitionResponse {
  Errors?: ColumnStatisticsError[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateColumnStatisticsForTableResponse {
  Errors?: ColumnStatisticsError[] | null;
}

// refs: 1 - tags: named, output
export interface UpdateConnectionResponse {
}

// refs: 1 - tags: named, output
export interface UpdateCrawlerResponse {
}

// refs: 1 - tags: named, output
export interface UpdateCrawlerScheduleResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDatabaseResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDevEndpointResponse {
}

// refs: 1 - tags: named, output
export interface UpdateJobResponse {
  JobName?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateMLTransformResponse {
  TransformId?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdatePartitionResponse {
}

// refs: 1 - tags: named, output
export interface UpdateRegistryResponse {
  RegistryName?: string | null;
  RegistryArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateSchemaResponse {
  SchemaArn?: string | null;
  SchemaName?: string | null;
  RegistryName?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateTableResponse {
}

// refs: 1 - tags: named, output
export interface UpdateTriggerResponse {
  Trigger?: Trigger | null;
}

// refs: 1 - tags: named, output
export interface UpdateUserDefinedFunctionResponse {
}

// refs: 1 - tags: named, output
export interface UpdateWorkflowResponse {
  Name?: string | null;
}

// refs: 4 - tags: input, named, interface
export interface PartitionInput {
  Values?: string[] | null;
  LastAccessTime?: Date | number | null;
  StorageDescriptor?: StorageDescriptor | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  LastAnalyzedTime?: Date | number | null;
}
function fromPartitionInput(input?: PartitionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
    LastAccessTime: jsonP.serializeDate_unixTimestamp(input["LastAccessTime"]),
    StorageDescriptor: fromStorageDescriptor(input["StorageDescriptor"]),
    Parameters: input["Parameters"],
    LastAnalyzedTime: jsonP.serializeDate_unixTimestamp(input["LastAnalyzedTime"]),
  }
}

// refs: 14 - tags: input, named, interface, output
export interface StorageDescriptor {
  Columns?: Column[] | null;
  Location?: string | null;
  InputFormat?: string | null;
  OutputFormat?: string | null;
  Compressed?: boolean | null;
  NumberOfBuckets?: number | null;
  SerdeInfo?: SerDeInfo | null;
  BucketColumns?: string[] | null;
  SortColumns?: Order[] | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  SkewedInfo?: SkewedInfo | null;
  StoredAsSubDirectories?: boolean | null;
  SchemaReference?: SchemaReference | null;
}
function fromStorageDescriptor(input?: StorageDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Columns: input["Columns"]?.map(x => fromColumn(x)),
    Location: input["Location"],
    InputFormat: input["InputFormat"],
    OutputFormat: input["OutputFormat"],
    Compressed: input["Compressed"],
    NumberOfBuckets: input["NumberOfBuckets"],
    SerdeInfo: fromSerDeInfo(input["SerdeInfo"]),
    BucketColumns: input["BucketColumns"],
    SortColumns: input["SortColumns"]?.map(x => fromOrder(x)),
    Parameters: input["Parameters"],
    SkewedInfo: fromSkewedInfo(input["SkewedInfo"]),
    StoredAsSubDirectories: input["StoredAsSubDirectories"],
    SchemaReference: fromSchemaReference(input["SchemaReference"]),
  }
}
function toStorageDescriptor(root: jsonP.JSONValue): StorageDescriptor {
  return jsonP.readObj({
    required: {},
    optional: {
      "Columns": [toColumn],
      "Location": "s",
      "InputFormat": "s",
      "OutputFormat": "s",
      "Compressed": "b",
      "NumberOfBuckets": "n",
      "SerdeInfo": toSerDeInfo,
      "BucketColumns": ["s"],
      "SortColumns": [toOrder],
      "Parameters": x => jsonP.readMap(String, String, x),
      "SkewedInfo": toSkewedInfo,
      "StoredAsSubDirectories": "b",
      "SchemaReference": toSchemaReference,
    },
  }, root);
}

// refs: 21 - tags: input, named, interface, output
export interface Column {
  Name: string;
  Type?: string | null;
  Comment?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
}
function fromColumn(input?: Column | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    Comment: input["Comment"],
    Parameters: input["Parameters"],
  }
}
function toColumn(root: jsonP.JSONValue): Column {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Type": "s",
      "Comment": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface SerDeInfo {
  Name?: string | null;
  SerializationLibrary?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
}
function fromSerDeInfo(input?: SerDeInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    SerializationLibrary: input["SerializationLibrary"],
    Parameters: input["Parameters"],
  }
}
function toSerDeInfo(root: jsonP.JSONValue): SerDeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "SerializationLibrary": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface Order {
  Column: string;
  SortOrder: number;
}
function fromOrder(input?: Order | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortOrder: input["SortOrder"],
  }
}
function toOrder(root: jsonP.JSONValue): Order {
  return jsonP.readObj({
    required: {
      "Column": "s",
      "SortOrder": "n",
    },
    optional: {},
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface SkewedInfo {
  SkewedColumnNames?: string[] | null;
  SkewedColumnValues?: string[] | null;
  SkewedColumnValueLocationMaps?: { [key: string]: string | null | undefined } | null;
}
function fromSkewedInfo(input?: SkewedInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SkewedColumnNames: input["SkewedColumnNames"],
    SkewedColumnValues: input["SkewedColumnValues"],
    SkewedColumnValueLocationMaps: input["SkewedColumnValueLocationMaps"],
  }
}
function toSkewedInfo(root: jsonP.JSONValue): SkewedInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "SkewedColumnNames": ["s"],
      "SkewedColumnValues": ["s"],
      "SkewedColumnValueLocationMaps": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 14 - tags: input, named, interface, output
export interface SchemaReference {
  SchemaId?: SchemaId | null;
  SchemaVersionId?: string | null;
  SchemaVersionNumber?: number | null;
}
function fromSchemaReference(input?: SchemaReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaId: fromSchemaId(input["SchemaId"]),
    SchemaVersionId: input["SchemaVersionId"],
    SchemaVersionNumber: input["SchemaVersionNumber"],
  }
}
function toSchemaReference(root: jsonP.JSONValue): SchemaReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaId": toSchemaId,
      "SchemaVersionId": "s",
      "SchemaVersionNumber": "n",
    },
  }, root);
}

// refs: 26 - tags: input, named, interface, output
export interface SchemaId {
  SchemaArn?: string | null;
  SchemaName?: string | null;
  RegistryName?: string | null;
}
function fromSchemaId(input?: SchemaId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    SchemaName: input["SchemaName"],
    RegistryName: input["RegistryName"],
  }
}
function toSchemaId(root: jsonP.JSONValue): SchemaId {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "SchemaName": "s",
      "RegistryName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PartitionValueList {
  Values: string[];
}
function fromPartitionValueList(input?: PartitionValueList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
  }
}
function toPartitionValueList(root: jsonP.JSONValue): PartitionValueList {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface BatchUpdatePartitionRequestEntry {
  PartitionValueList: string[];
  PartitionInput: PartitionInput;
}
function fromBatchUpdatePartitionRequestEntry(input?: BatchUpdatePartitionRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PartitionValueList: input["PartitionValueList"],
    PartitionInput: fromPartitionInput(input["PartitionInput"]),
  }
}

// refs: 6 - tags: input, named, enum, output
export type DataFormat =
| "AVRO"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface CreateGrokClassifierRequest {
  Classification: string;
  Name: string;
  GrokPattern: string;
  CustomPatterns?: string | null;
}
function fromCreateGrokClassifierRequest(input?: CreateGrokClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Name: input["Name"],
    GrokPattern: input["GrokPattern"],
    CustomPatterns: input["CustomPatterns"],
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateXMLClassifierRequest {
  Classification: string;
  Name: string;
  RowTag?: string | null;
}
function fromCreateXMLClassifierRequest(input?: CreateXMLClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Name: input["Name"],
    RowTag: input["RowTag"],
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateJsonClassifierRequest {
  Name: string;
  JsonPath: string;
}
function fromCreateJsonClassifierRequest(input?: CreateJsonClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    JsonPath: input["JsonPath"],
  }
}

// refs: 1 - tags: input, named, interface
export interface CreateCsvClassifierRequest {
  Name: string;
  Delimiter?: string | null;
  QuoteSymbol?: string | null;
  ContainsHeader?: CsvHeaderOption | null;
  Header?: string[] | null;
  DisableValueTrimming?: boolean | null;
  AllowSingleColumn?: boolean | null;
}
function fromCreateCsvClassifierRequest(input?: CreateCsvClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Delimiter: input["Delimiter"],
    QuoteSymbol: input["QuoteSymbol"],
    ContainsHeader: input["ContainsHeader"],
    Header: input["Header"],
    DisableValueTrimming: input["DisableValueTrimming"],
    AllowSingleColumn: input["AllowSingleColumn"],
  }
}

// refs: 4 - tags: input, named, enum, output
export type CsvHeaderOption =
| "UNKNOWN"
| "PRESENT"
| "ABSENT"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface ConnectionInput {
  Name: string;
  Description?: string | null;
  ConnectionType: ConnectionType;
  MatchCriteria?: string[] | null;
  ConnectionProperties: { [key in ConnectionPropertyKey]: string | null | undefined };
  PhysicalConnectionRequirements?: PhysicalConnectionRequirements | null;
}
function fromConnectionInput(input?: ConnectionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    ConnectionType: input["ConnectionType"],
    MatchCriteria: input["MatchCriteria"],
    ConnectionProperties: input["ConnectionProperties"],
    PhysicalConnectionRequirements: fromPhysicalConnectionRequirements(input["PhysicalConnectionRequirements"]),
  }
}

// refs: 5 - tags: input, named, enum, output
export type ConnectionType =
| "JDBC"
| "SFTP"
| "MONGODB"
| "KAFKA"
| "NETWORK"
| "MARKETPLACE"
| "CUSTOM"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ConnectionPropertyKey =
| "HOST"
| "PORT"
| "USERNAME"
| "PASSWORD"
| "ENCRYPTED_PASSWORD"
| "JDBC_DRIVER_JAR_URI"
| "JDBC_DRIVER_CLASS_NAME"
| "JDBC_ENGINE"
| "JDBC_ENGINE_VERSION"
| "CONFIG_FILES"
| "INSTANCE_ID"
| "JDBC_CONNECTION_URL"
| "JDBC_ENFORCE_SSL"
| "CUSTOM_JDBC_CERT"
| "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
| "CUSTOM_JDBC_CERT_STRING"
| "CONNECTION_URL"
| "KAFKA_BOOTSTRAP_SERVERS"
| "KAFKA_SSL_ENABLED"
| "KAFKA_CUSTOM_CERT"
| "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
| "SECRET_ID"
| "CONNECTOR_URL"
| "CONNECTOR_TYPE"
| "CONNECTOR_CLASS_NAME"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface PhysicalConnectionRequirements {
  SubnetId?: string | null;
  SecurityGroupIdList?: string[] | null;
  AvailabilityZone?: string | null;
}
function fromPhysicalConnectionRequirements(input?: PhysicalConnectionRequirements | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetId: input["SubnetId"],
    SecurityGroupIdList: input["SecurityGroupIdList"],
    AvailabilityZone: input["AvailabilityZone"],
  }
}
function toPhysicalConnectionRequirements(root: jsonP.JSONValue): PhysicalConnectionRequirements {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetId": "s",
      "SecurityGroupIdList": ["s"],
      "AvailabilityZone": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface CrawlerTargets {
  S3Targets?: S3Target[] | null;
  JdbcTargets?: JdbcTarget[] | null;
  MongoDBTargets?: MongoDBTarget[] | null;
  DynamoDBTargets?: DynamoDBTarget[] | null;
  CatalogTargets?: CatalogTarget[] | null;
}
function fromCrawlerTargets(input?: CrawlerTargets | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Targets: input["S3Targets"]?.map(x => fromS3Target(x)),
    JdbcTargets: input["JdbcTargets"]?.map(x => fromJdbcTarget(x)),
    MongoDBTargets: input["MongoDBTargets"]?.map(x => fromMongoDBTarget(x)),
    DynamoDBTargets: input["DynamoDBTargets"]?.map(x => fromDynamoDBTarget(x)),
    CatalogTargets: input["CatalogTargets"]?.map(x => fromCatalogTarget(x)),
  }
}
function toCrawlerTargets(root: jsonP.JSONValue): CrawlerTargets {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Targets": [toS3Target],
      "JdbcTargets": [toJdbcTarget],
      "MongoDBTargets": [toMongoDBTarget],
      "DynamoDBTargets": [toDynamoDBTarget],
      "CatalogTargets": [toCatalogTarget],
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface S3Target {
  Path?: string | null;
  Exclusions?: string[] | null;
  ConnectionName?: string | null;
}
function fromS3Target(input?: S3Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    Exclusions: input["Exclusions"],
    ConnectionName: input["ConnectionName"],
  }
}
function toS3Target(root: jsonP.JSONValue): S3Target {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "Exclusions": ["s"],
      "ConnectionName": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface JdbcTarget {
  ConnectionName?: string | null;
  Path?: string | null;
  Exclusions?: string[] | null;
}
function fromJdbcTarget(input?: JdbcTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectionName: input["ConnectionName"],
    Path: input["Path"],
    Exclusions: input["Exclusions"],
  }
}
function toJdbcTarget(root: jsonP.JSONValue): JdbcTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionName": "s",
      "Path": "s",
      "Exclusions": ["s"],
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface MongoDBTarget {
  ConnectionName?: string | null;
  Path?: string | null;
  ScanAll?: boolean | null;
}
function fromMongoDBTarget(input?: MongoDBTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectionName: input["ConnectionName"],
    Path: input["Path"],
    ScanAll: input["ScanAll"],
  }
}
function toMongoDBTarget(root: jsonP.JSONValue): MongoDBTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionName": "s",
      "Path": "s",
      "ScanAll": "b",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface DynamoDBTarget {
  Path?: string | null;
  scanAll?: boolean | null;
  scanRate?: number | null;
}
function fromDynamoDBTarget(input?: DynamoDBTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    scanAll: input["scanAll"],
    scanRate: input["scanRate"],
  }
}
function toDynamoDBTarget(root: jsonP.JSONValue): DynamoDBTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "scanAll": "b",
      "scanRate": "n",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface CatalogTarget {
  DatabaseName: string;
  Tables: string[];
}
function fromCatalogTarget(input?: CatalogTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Tables: input["Tables"],
  }
}
function toCatalogTarget(root: jsonP.JSONValue): CatalogTarget {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "Tables": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface SchemaChangePolicy {
  UpdateBehavior?: UpdateBehavior | null;
  DeleteBehavior?: DeleteBehavior | null;
}
function fromSchemaChangePolicy(input?: SchemaChangePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UpdateBehavior: input["UpdateBehavior"],
    DeleteBehavior: input["DeleteBehavior"],
  }
}
function toSchemaChangePolicy(root: jsonP.JSONValue): SchemaChangePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpdateBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<UpdateBehavior>(x),
      "DeleteBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<DeleteBehavior>(x),
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type UpdateBehavior =
| "LOG"
| "UPDATE_IN_DATABASE"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, enum, output
export type DeleteBehavior =
| "LOG"
| "DELETE_FROM_DATABASE"
| "DEPRECATE_IN_DATABASE"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface RecrawlPolicy {
  RecrawlBehavior?: RecrawlBehavior | null;
}
function fromRecrawlPolicy(input?: RecrawlPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecrawlBehavior: input["RecrawlBehavior"],
  }
}
function toRecrawlPolicy(root: jsonP.JSONValue): RecrawlPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecrawlBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<RecrawlBehavior>(x),
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type RecrawlBehavior =
| "CRAWL_EVERYTHING"
| "CRAWL_NEW_FOLDERS_ONLY"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface LineageConfiguration {
  CrawlerLineageSettings?: CrawlerLineageSettings | null;
}
function fromLineageConfiguration(input?: LineageConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CrawlerLineageSettings: input["CrawlerLineageSettings"],
  }
}
function toLineageConfiguration(root: jsonP.JSONValue): LineageConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CrawlerLineageSettings": (x: jsonP.JSONValue) => cmnP.readEnum<CrawlerLineageSettings>(x),
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type CrawlerLineageSettings =
| "ENABLE"
| "DISABLE"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface DatabaseInput {
  Name: string;
  Description?: string | null;
  LocationUri?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  CreateTableDefaultPermissions?: PrincipalPermissions[] | null;
  TargetDatabase?: DatabaseIdentifier | null;
}
function fromDatabaseInput(input?: DatabaseInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    LocationUri: input["LocationUri"],
    Parameters: input["Parameters"],
    CreateTableDefaultPermissions: input["CreateTableDefaultPermissions"]?.map(x => fromPrincipalPermissions(x)),
    TargetDatabase: fromDatabaseIdentifier(input["TargetDatabase"]),
  }
}

// refs: 4 - tags: input, named, interface, output
export interface PrincipalPermissions {
  Principal?: DataLakePrincipal | null;
  Permissions?: Permission[] | null;
}
function fromPrincipalPermissions(input?: PrincipalPermissions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principal: fromDataLakePrincipal(input["Principal"]),
    Permissions: input["Permissions"],
  }
}
function toPrincipalPermissions(root: jsonP.JSONValue): PrincipalPermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Principal": toDataLakePrincipal,
      "Permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<Permission>(x)],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DataLakePrincipal {
  DataLakePrincipalIdentifier?: string | null;
}
function fromDataLakePrincipal(input?: DataLakePrincipal | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLakePrincipalIdentifier: input["DataLakePrincipalIdentifier"],
  }
}
function toDataLakePrincipal(root: jsonP.JSONValue): DataLakePrincipal {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataLakePrincipalIdentifier": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type Permission =
| "ALL"
| "SELECT"
| "ALTER"
| "DROP"
| "DELETE"
| "INSERT"
| "CREATE_DATABASE"
| "CREATE_TABLE"
| "DATA_LOCATION_ACCESS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface DatabaseIdentifier {
  CatalogId?: string | null;
  DatabaseName?: string | null;
}
function fromDatabaseIdentifier(input?: DatabaseIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
  }
}
function toDatabaseIdentifier(root: jsonP.JSONValue): DatabaseIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "CatalogId": "s",
      "DatabaseName": "s",
    },
  }, root);
}

// refs: 23 - tags: input, named, enum, output
export type WorkerType =
| "Standard"
| "G.1X"
| "G.2X"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface ExecutionProperty {
  MaxConcurrentRuns?: number | null;
}
function fromExecutionProperty(input?: ExecutionProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxConcurrentRuns: input["MaxConcurrentRuns"],
  }
}
function toExecutionProperty(root: jsonP.JSONValue): ExecutionProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxConcurrentRuns": "n",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface JobCommand {
  Name?: string | null;
  ScriptLocation?: string | null;
  PythonVersion?: string | null;
}
function fromJobCommand(input?: JobCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ScriptLocation: input["ScriptLocation"],
    PythonVersion: input["PythonVersion"],
  }
}
function toJobCommand(root: jsonP.JSONValue): JobCommand {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ScriptLocation": "s",
      "PythonVersion": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface ConnectionsList {
  Connections?: string[] | null;
}
function fromConnectionsList(input?: ConnectionsList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Connections: input["Connections"],
  }
}
function toConnectionsList(root: jsonP.JSONValue): ConnectionsList {
  return jsonP.readObj({
    required: {},
    optional: {
      "Connections": ["s"],
    },
  }, root);
}

// refs: 26 - tags: input, named, interface, output
export interface NotificationProperty {
  NotifyDelayAfter?: number | null;
}
function fromNotificationProperty(input?: NotificationProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotifyDelayAfter: input["NotifyDelayAfter"],
  }
}
function toNotificationProperty(root: jsonP.JSONValue): NotificationProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotifyDelayAfter": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface GlueTable {
  DatabaseName: string;
  TableName: string;
  CatalogId?: string | null;
  ConnectionName?: string | null;
}
function fromGlueTable(input?: GlueTable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    CatalogId: input["CatalogId"],
    ConnectionName: input["ConnectionName"],
  }
}
function toGlueTable(root: jsonP.JSONValue): GlueTable {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "TableName": "s",
    },
    optional: {
      "CatalogId": "s",
      "ConnectionName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface TransformParameters {
  TransformType: TransformType;
  FindMatchesParameters?: FindMatchesParameters | null;
}
function fromTransformParameters(input?: TransformParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TransformType: input["TransformType"],
    FindMatchesParameters: fromFindMatchesParameters(input["FindMatchesParameters"]),
  }
}
function toTransformParameters(root: jsonP.JSONValue): TransformParameters {
  return jsonP.readObj({
    required: {
      "TransformType": (x: jsonP.JSONValue) => cmnP.readEnum<TransformType>(x),
    },
    optional: {
      "FindMatchesParameters": toFindMatchesParameters,
    },
  }, root);
}

// refs: 8 - tags: input, named, enum, output
export type TransformType =
| "FIND_MATCHES"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface FindMatchesParameters {
  PrimaryKeyColumnName?: string | null;
  PrecisionRecallTradeoff?: number | null;
  AccuracyCostTradeoff?: number | null;
  EnforceProvidedLabels?: boolean | null;
}
function fromFindMatchesParameters(input?: FindMatchesParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrimaryKeyColumnName: input["PrimaryKeyColumnName"],
    PrecisionRecallTradeoff: input["PrecisionRecallTradeoff"],
    AccuracyCostTradeoff: input["AccuracyCostTradeoff"],
    EnforceProvidedLabels: input["EnforceProvidedLabels"],
  }
}
function toFindMatchesParameters(root: jsonP.JSONValue): FindMatchesParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryKeyColumnName": "s",
      "PrecisionRecallTradeoff": "n",
      "AccuracyCostTradeoff": "n",
      "EnforceProvidedLabels": "b",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface TransformEncryption {
  MlUserDataEncryption?: MLUserDataEncryption | null;
  TaskRunSecurityConfigurationName?: string | null;
}
function fromTransformEncryption(input?: TransformEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MlUserDataEncryption: fromMLUserDataEncryption(input["MlUserDataEncryption"]),
    TaskRunSecurityConfigurationName: input["TaskRunSecurityConfigurationName"],
  }
}
function toTransformEncryption(root: jsonP.JSONValue): TransformEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "MlUserDataEncryption": toMLUserDataEncryption,
      "TaskRunSecurityConfigurationName": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MLUserDataEncryption {
  MlUserDataEncryptionMode: MLUserDataEncryptionModeString;
  KmsKeyId?: string | null;
}
function fromMLUserDataEncryption(input?: MLUserDataEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MlUserDataEncryptionMode: input["MlUserDataEncryptionMode"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toMLUserDataEncryption(root: jsonP.JSONValue): MLUserDataEncryption {
  return jsonP.readObj({
    required: {
      "MlUserDataEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<MLUserDataEncryptionModeString>(x),
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type MLUserDataEncryptionModeString =
| "DISABLED"
| "SSE-KMS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface PartitionIndex {
  Keys: string[];
  IndexName: string;
}
function fromPartitionIndex(input?: PartitionIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"],
    IndexName: input["IndexName"],
  }
}

// refs: 5 - tags: input, named, interface
export interface RegistryId {
  RegistryName?: string | null;
  RegistryArn?: string | null;
}
function fromRegistryId(input?: RegistryId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegistryName: input["RegistryName"],
    RegistryArn: input["RegistryArn"],
  }
}

// refs: 4 - tags: input, named, enum, output
export type Compatibility =
| "NONE"
| "DISABLED"
| "BACKWARD"
| "BACKWARD_ALL"
| "FORWARD"
| "FORWARD_ALL"
| "FULL"
| "FULL_ALL"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface CodeGenNode {
  Id: string;
  NodeType: string;
  Args: CodeGenNodeArg[];
  LineNumber?: number | null;
}
function fromCodeGenNode(input?: CodeGenNode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    NodeType: input["NodeType"],
    Args: input["Args"]?.map(x => fromCodeGenNodeArg(x)),
    LineNumber: input["LineNumber"],
  }
}
function toCodeGenNode(root: jsonP.JSONValue): CodeGenNode {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "NodeType": "s",
      "Args": [toCodeGenNodeArg],
    },
    optional: {
      "LineNumber": "n",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface CodeGenNodeArg {
  Name: string;
  Value: string;
  Param?: boolean | null;
}
function fromCodeGenNodeArg(input?: CodeGenNodeArg | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
    Param: input["Param"],
  }
}
function toCodeGenNodeArg(root: jsonP.JSONValue): CodeGenNodeArg {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Value": "s",
    },
    optional: {
      "Param": "b",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface CodeGenEdge {
  Source: string;
  Target: string;
  TargetParameter?: string | null;
}
function fromCodeGenEdge(input?: CodeGenEdge | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Source: input["Source"],
    Target: input["Target"],
    TargetParameter: input["TargetParameter"],
  }
}
function toCodeGenEdge(root: jsonP.JSONValue): CodeGenEdge {
  return jsonP.readObj({
    required: {
      "Source": "s",
      "Target": "s",
    },
    optional: {
      "TargetParameter": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum
export type Language =
| "PYTHON"
| "SCALA"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface EncryptionConfiguration {
  S3Encryption?: S3Encryption[] | null;
  CloudWatchEncryption?: CloudWatchEncryption | null;
  JobBookmarksEncryption?: JobBookmarksEncryption | null;
}
function fromEncryptionConfiguration(input?: EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Encryption: input["S3Encryption"]?.map(x => fromS3Encryption(x)),
    CloudWatchEncryption: fromCloudWatchEncryption(input["CloudWatchEncryption"]),
    JobBookmarksEncryption: fromJobBookmarksEncryption(input["JobBookmarksEncryption"]),
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): EncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Encryption": [toS3Encryption],
      "CloudWatchEncryption": toCloudWatchEncryption,
      "JobBookmarksEncryption": toJobBookmarksEncryption,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface S3Encryption {
  S3EncryptionMode?: S3EncryptionMode | null;
  KmsKeyArn?: string | null;
}
function fromS3Encryption(input?: S3Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3EncryptionMode: input["S3EncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3Encryption(root: jsonP.JSONValue): S3Encryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<S3EncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type S3EncryptionMode =
| "DISABLED"
| "SSE-KMS"
| "SSE-S3"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface CloudWatchEncryption {
  CloudWatchEncryptionMode?: CloudWatchEncryptionMode | null;
  KmsKeyArn?: string | null;
}
function fromCloudWatchEncryption(input?: CloudWatchEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchEncryptionMode: input["CloudWatchEncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toCloudWatchEncryption(root: jsonP.JSONValue): CloudWatchEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<CloudWatchEncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type CloudWatchEncryptionMode =
| "DISABLED"
| "SSE-KMS"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface JobBookmarksEncryption {
  JobBookmarksEncryptionMode?: JobBookmarksEncryptionMode | null;
  KmsKeyArn?: string | null;
}
function fromJobBookmarksEncryption(input?: JobBookmarksEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobBookmarksEncryptionMode: input["JobBookmarksEncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toJobBookmarksEncryption(root: jsonP.JSONValue): JobBookmarksEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobBookmarksEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<JobBookmarksEncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type JobBookmarksEncryptionMode =
| "DISABLED"
| "CSE-KMS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface TableInput {
  Name: string;
  Description?: string | null;
  Owner?: string | null;
  LastAccessTime?: Date | number | null;
  LastAnalyzedTime?: Date | number | null;
  Retention?: number | null;
  StorageDescriptor?: StorageDescriptor | null;
  PartitionKeys?: Column[] | null;
  ViewOriginalText?: string | null;
  ViewExpandedText?: string | null;
  TableType?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  TargetTable?: TableIdentifier | null;
}
function fromTableInput(input?: TableInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Owner: input["Owner"],
    LastAccessTime: jsonP.serializeDate_unixTimestamp(input["LastAccessTime"]),
    LastAnalyzedTime: jsonP.serializeDate_unixTimestamp(input["LastAnalyzedTime"]),
    Retention: input["Retention"],
    StorageDescriptor: fromStorageDescriptor(input["StorageDescriptor"]),
    PartitionKeys: input["PartitionKeys"]?.map(x => fromColumn(x)),
    ViewOriginalText: input["ViewOriginalText"],
    ViewExpandedText: input["ViewExpandedText"],
    TableType: input["TableType"],
    Parameters: input["Parameters"],
    TargetTable: fromTableIdentifier(input["TargetTable"]),
  }
}

// refs: 7 - tags: input, named, interface, output
export interface TableIdentifier {
  CatalogId?: string | null;
  DatabaseName?: string | null;
  Name?: string | null;
}
function fromTableIdentifier(input?: TableIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    Name: input["Name"],
  }
}
function toTableIdentifier(root: jsonP.JSONValue): TableIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "CatalogId": "s",
      "DatabaseName": "s",
      "Name": "s",
    },
  }, root);
}

// refs: 11 - tags: input, named, enum, output
export type TriggerType =
| "SCHEDULED"
| "CONDITIONAL"
| "ON_DEMAND"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface Predicate {
  Logical?: Logical | null;
  Conditions?: Condition[] | null;
}
function fromPredicate(input?: Predicate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Logical: input["Logical"],
    Conditions: input["Conditions"]?.map(x => fromCondition(x)),
  }
}
function toPredicate(root: jsonP.JSONValue): Predicate {
  return jsonP.readObj({
    required: {},
    optional: {
      "Logical": (x: jsonP.JSONValue) => cmnP.readEnum<Logical>(x),
      "Conditions": [toCondition],
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type Logical =
| "AND"
| "ANY"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface Condition {
  LogicalOperator?: LogicalOperator | null;
  JobName?: string | null;
  State?: JobRunState | null;
  CrawlerName?: string | null;
  CrawlState?: CrawlState | null;
}
function fromCondition(input?: Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogicalOperator: input["LogicalOperator"],
    JobName: input["JobName"],
    State: input["State"],
    CrawlerName: input["CrawlerName"],
    CrawlState: input["CrawlState"],
  }
}
function toCondition(root: jsonP.JSONValue): Condition {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogicalOperator": (x: jsonP.JSONValue) => cmnP.readEnum<LogicalOperator>(x),
      "JobName": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<JobRunState>(x),
      "CrawlerName": "s",
      "CrawlState": (x: jsonP.JSONValue) => cmnP.readEnum<CrawlState>(x),
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type LogicalOperator =
| "EQUALS"
| cmnP.UnexpectedEnumValue;

// refs: 20 - tags: input, named, enum, output
export type JobRunState =
| "STARTING"
| "RUNNING"
| "STOPPING"
| "STOPPED"
| "SUCCEEDED"
| "FAILED"
| "TIMEOUT"
| cmnP.UnexpectedEnumValue;

// refs: 18 - tags: input, named, enum, output
export type CrawlState =
| "RUNNING"
| "CANCELLING"
| "CANCELLED"
| "SUCCEEDED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 12 - tags: input, named, interface, output
export interface Action {
  JobName?: string | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
  Timeout?: number | null;
  SecurityConfiguration?: string | null;
  NotificationProperty?: NotificationProperty | null;
  CrawlerName?: string | null;
}
function fromAction(input?: Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    Arguments: input["Arguments"],
    Timeout: input["Timeout"],
    SecurityConfiguration: input["SecurityConfiguration"],
    NotificationProperty: fromNotificationProperty(input["NotificationProperty"]),
    CrawlerName: input["CrawlerName"],
  }
}
function toAction(root: jsonP.JSONValue): Action {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "Arguments": x => jsonP.readMap(String, String, x),
      "Timeout": "n",
      "SecurityConfiguration": "s",
      "NotificationProperty": toNotificationProperty,
      "CrawlerName": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface UserDefinedFunctionInput {
  FunctionName?: string | null;
  ClassName?: string | null;
  OwnerName?: string | null;
  OwnerType?: PrincipalType | null;
  ResourceUris?: ResourceUri[] | null;
}
function fromUserDefinedFunctionInput(input?: UserDefinedFunctionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FunctionName: input["FunctionName"],
    ClassName: input["ClassName"],
    OwnerName: input["OwnerName"],
    OwnerType: input["OwnerType"],
    ResourceUris: input["ResourceUris"]?.map(x => fromResourceUri(x)),
  }
}

// refs: 4 - tags: input, named, enum, output
export type PrincipalType =
| "USER"
| "ROLE"
| "GROUP"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface ResourceUri {
  ResourceType?: ResourceType | null;
  Uri?: string | null;
}
function fromResourceUri(input?: ResourceUri | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceType: input["ResourceType"],
    Uri: input["Uri"],
  }
}
function toResourceUri(root: jsonP.JSONValue): ResourceUri {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<ResourceType>(x),
      "Uri": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type ResourceType =
| "JAR"
| "FILE"
| "ARCHIVE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface GetConnectionsFilter {
  MatchCriteria?: string[] | null;
  ConnectionType?: ConnectionType | null;
}
function fromGetConnectionsFilter(input?: GetConnectionsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MatchCriteria: input["MatchCriteria"],
    ConnectionType: input["ConnectionType"],
  }
}

// refs: 2 - tags: input, named, enum
export type ResourceShareType =
| "FOREIGN"
| "ALL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TaskRunFilterCriteria {
  TaskRunType?: TaskType | null;
  Status?: TaskStatusType | null;
  StartedBefore?: Date | number | null;
  StartedAfter?: Date | number | null;
}
function fromTaskRunFilterCriteria(input?: TaskRunFilterCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TaskRunType: input["TaskRunType"],
    Status: input["Status"],
    StartedBefore: jsonP.serializeDate_unixTimestamp(input["StartedBefore"]),
    StartedAfter: jsonP.serializeDate_unixTimestamp(input["StartedAfter"]),
  }
}

// refs: 3 - tags: input, named, enum, output
export type TaskType =
| "EVALUATION"
| "LABELING_SET_GENERATION"
| "IMPORT_LABELS"
| "EXPORT_LABELS"
| "FIND_MATCHES"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type TaskStatusType =
| "STARTING"
| "RUNNING"
| "STOPPING"
| "STOPPED"
| "SUCCEEDED"
| "FAILED"
| "TIMEOUT"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TaskRunSortCriteria {
  Column: TaskRunSortColumnType;
  SortDirection: SortDirectionType;
}
function fromTaskRunSortCriteria(input?: TaskRunSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortDirection: input["SortDirection"],
  }
}

// refs: 1 - tags: input, named, enum
export type TaskRunSortColumnType =
| "TASK_RUN_TYPE"
| "STATUS"
| "STARTED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum
export type SortDirectionType =
| "DESCENDING"
| "ASCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface TransformFilterCriteria {
  Name?: string | null;
  TransformType?: TransformType | null;
  Status?: TransformStatusType | null;
  GlueVersion?: string | null;
  CreatedBefore?: Date | number | null;
  CreatedAfter?: Date | number | null;
  LastModifiedBefore?: Date | number | null;
  LastModifiedAfter?: Date | number | null;
  Schema?: SchemaColumn[] | null;
}
function fromTransformFilterCriteria(input?: TransformFilterCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    TransformType: input["TransformType"],
    Status: input["Status"],
    GlueVersion: input["GlueVersion"],
    CreatedBefore: jsonP.serializeDate_unixTimestamp(input["CreatedBefore"]),
    CreatedAfter: jsonP.serializeDate_unixTimestamp(input["CreatedAfter"]),
    LastModifiedBefore: jsonP.serializeDate_unixTimestamp(input["LastModifiedBefore"]),
    LastModifiedAfter: jsonP.serializeDate_unixTimestamp(input["LastModifiedAfter"]),
    Schema: input["Schema"]?.map(x => fromSchemaColumn(x)),
  }
}

// refs: 4 - tags: input, named, enum, output
export type TransformStatusType =
| "NOT_READY"
| "READY"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface SchemaColumn {
  Name?: string | null;
  DataType?: string | null;
}
function fromSchemaColumn(input?: SchemaColumn | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    DataType: input["DataType"],
  }
}
function toSchemaColumn(root: jsonP.JSONValue): SchemaColumn {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DataType": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface TransformSortCriteria {
  Column: TransformSortColumnType;
  SortDirection: SortDirectionType;
}
function fromTransformSortCriteria(input?: TransformSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortDirection: input["SortDirection"],
  }
}

// refs: 2 - tags: input, named, enum
export type TransformSortColumnType =
| "NAME"
| "TRANSFORM_TYPE"
| "STATUS"
| "CREATED"
| "LAST_MODIFIED"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface
export interface CatalogEntry {
  DatabaseName: string;
  TableName: string;
}
function fromCatalogEntry(input?: CatalogEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
  }
}

// refs: 2 - tags: input, named, interface
export interface Location {
  Jdbc?: CodeGenNodeArg[] | null;
  S3?: CodeGenNodeArg[] | null;
  DynamoDB?: CodeGenNodeArg[] | null;
}
function fromLocation(input?: Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Jdbc: input["Jdbc"]?.map(x => fromCodeGenNodeArg(x)),
    S3: input["S3"]?.map(x => fromCodeGenNodeArg(x)),
    DynamoDB: input["DynamoDB"]?.map(x => fromCodeGenNodeArg(x)),
  }
}

// refs: 1 - tags: input, named, interface
export interface Segment {
  SegmentNumber: number;
  TotalSegments: number;
}
function fromSegment(input?: Segment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SegmentNumber: input["SegmentNumber"],
    TotalSegments: input["TotalSegments"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface MappingEntry {
  SourceTable?: string | null;
  SourcePath?: string | null;
  SourceType?: string | null;
  TargetTable?: string | null;
  TargetPath?: string | null;
  TargetType?: string | null;
}
function fromMappingEntry(input?: MappingEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceTable: input["SourceTable"],
    SourcePath: input["SourcePath"],
    SourceType: input["SourceType"],
    TargetTable: input["TargetTable"],
    TargetPath: input["TargetPath"],
    TargetType: input["TargetType"],
  }
}
function toMappingEntry(root: jsonP.JSONValue): MappingEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceTable": "s",
      "SourcePath": "s",
      "SourceType": "s",
      "TargetTable": "s",
      "TargetPath": "s",
      "TargetType": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, interface
export interface SchemaVersionNumber {
  LatestVersion?: boolean | null;
  VersionNumber?: number | null;
}
function fromSchemaVersionNumber(input?: SchemaVersionNumber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LatestVersion: input["LatestVersion"],
    VersionNumber: input["VersionNumber"],
  }
}

// refs: 1 - tags: input, named, enum
export type SchemaDiffType =
| "SYNTAX_DIFF"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface DataCatalogEncryptionSettings {
  EncryptionAtRest?: EncryptionAtRest | null;
  ConnectionPasswordEncryption?: ConnectionPasswordEncryption | null;
}
function fromDataCatalogEncryptionSettings(input?: DataCatalogEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionAtRest: fromEncryptionAtRest(input["EncryptionAtRest"]),
    ConnectionPasswordEncryption: fromConnectionPasswordEncryption(input["ConnectionPasswordEncryption"]),
  }
}
function toDataCatalogEncryptionSettings(root: jsonP.JSONValue): DataCatalogEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionAtRest": toEncryptionAtRest,
      "ConnectionPasswordEncryption": toConnectionPasswordEncryption,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface EncryptionAtRest {
  CatalogEncryptionMode: CatalogEncryptionMode;
  SseAwsKmsKeyId?: string | null;
}
function fromEncryptionAtRest(input?: EncryptionAtRest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogEncryptionMode: input["CatalogEncryptionMode"],
    SseAwsKmsKeyId: input["SseAwsKmsKeyId"],
  }
}
function toEncryptionAtRest(root: jsonP.JSONValue): EncryptionAtRest {
  return jsonP.readObj({
    required: {
      "CatalogEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<CatalogEncryptionMode>(x),
    },
    optional: {
      "SseAwsKmsKeyId": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type CatalogEncryptionMode =
| "DISABLED"
| "SSE-KMS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ConnectionPasswordEncryption {
  ReturnConnectionPasswordEncrypted: boolean;
  AwsKmsKeyId?: string | null;
}
function fromConnectionPasswordEncryption(input?: ConnectionPasswordEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReturnConnectionPasswordEncrypted: input["ReturnConnectionPasswordEncrypted"],
    AwsKmsKeyId: input["AwsKmsKeyId"],
  }
}
function toConnectionPasswordEncryption(root: jsonP.JSONValue): ConnectionPasswordEncryption {
  return jsonP.readObj({
    required: {
      "ReturnConnectionPasswordEncrypted": "b",
    },
    optional: {
      "AwsKmsKeyId": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type ExistCondition =
| "MUST_EXIST"
| "NOT_EXIST"
| "NONE"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type EnableHybridValues =
| "TRUE"
| "FALSE"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface
export interface MetadataKeyValuePair {
  MetadataKey?: string | null;
  MetadataValue?: string | null;
}
function fromMetadataKeyValuePair(input?: MetadataKeyValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetadataKey: input["MetadataKey"],
    MetadataValue: input["MetadataValue"],
  }
}

// refs: 1 - tags: input, named, interface
export interface PropertyPredicate {
  Key?: string | null;
  Value?: string | null;
  Comparator?: Comparator | null;
}
function fromPropertyPredicate(input?: PropertyPredicate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Comparator: input["Comparator"],
  }
}

// refs: 1 - tags: input, named, enum
export type Comparator =
| "EQUALS"
| "GREATER_THAN"
| "LESS_THAN"
| "GREATER_THAN_EQUALS"
| "LESS_THAN_EQUALS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SortCriterion {
  FieldName?: string | null;
  Sort?: Sort | null;
}
function fromSortCriterion(input?: SortCriterion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FieldName: input["FieldName"],
    Sort: input["Sort"],
  }
}

// refs: 1 - tags: input, named, enum
export type Sort =
| "ASC"
| "DESC"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface UpdateGrokClassifierRequest {
  Name: string;
  Classification?: string | null;
  GrokPattern?: string | null;
  CustomPatterns?: string | null;
}
function fromUpdateGrokClassifierRequest(input?: UpdateGrokClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Classification: input["Classification"],
    GrokPattern: input["GrokPattern"],
    CustomPatterns: input["CustomPatterns"],
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateXMLClassifierRequest {
  Name: string;
  Classification?: string | null;
  RowTag?: string | null;
}
function fromUpdateXMLClassifierRequest(input?: UpdateXMLClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Classification: input["Classification"],
    RowTag: input["RowTag"],
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateJsonClassifierRequest {
  Name: string;
  JsonPath?: string | null;
}
function fromUpdateJsonClassifierRequest(input?: UpdateJsonClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    JsonPath: input["JsonPath"],
  }
}

// refs: 1 - tags: input, named, interface
export interface UpdateCsvClassifierRequest {
  Name: string;
  Delimiter?: string | null;
  QuoteSymbol?: string | null;
  ContainsHeader?: CsvHeaderOption | null;
  Header?: string[] | null;
  DisableValueTrimming?: boolean | null;
  AllowSingleColumn?: boolean | null;
}
function fromUpdateCsvClassifierRequest(input?: UpdateCsvClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Delimiter: input["Delimiter"],
    QuoteSymbol: input["QuoteSymbol"],
    ContainsHeader: input["ContainsHeader"],
    Header: input["Header"],
    DisableValueTrimming: input["DisableValueTrimming"],
    AllowSingleColumn: input["AllowSingleColumn"],
  }
}

// refs: 6 - tags: input, named, interface, output
export interface ColumnStatistics {
  ColumnName: string;
  ColumnType: string;
  AnalyzedTime: Date | number;
  StatisticsData: ColumnStatisticsData;
}
function fromColumnStatistics(input?: ColumnStatistics | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    ColumnType: input["ColumnType"],
    AnalyzedTime: jsonP.serializeDate_unixTimestamp(input["AnalyzedTime"]),
    StatisticsData: fromColumnStatisticsData(input["StatisticsData"]),
  }
}
function toColumnStatistics(root: jsonP.JSONValue): ColumnStatistics {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "ColumnType": "s",
      "AnalyzedTime": "d",
      "StatisticsData": toColumnStatisticsData,
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ColumnStatisticsData {
  Type: ColumnStatisticsType;
  BooleanColumnStatisticsData?: BooleanColumnStatisticsData | null;
  DateColumnStatisticsData?: DateColumnStatisticsData | null;
  DecimalColumnStatisticsData?: DecimalColumnStatisticsData | null;
  DoubleColumnStatisticsData?: DoubleColumnStatisticsData | null;
  LongColumnStatisticsData?: LongColumnStatisticsData | null;
  StringColumnStatisticsData?: StringColumnStatisticsData | null;
  BinaryColumnStatisticsData?: BinaryColumnStatisticsData | null;
}
function fromColumnStatisticsData(input?: ColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    BooleanColumnStatisticsData: fromBooleanColumnStatisticsData(input["BooleanColumnStatisticsData"]),
    DateColumnStatisticsData: fromDateColumnStatisticsData(input["DateColumnStatisticsData"]),
    DecimalColumnStatisticsData: fromDecimalColumnStatisticsData(input["DecimalColumnStatisticsData"]),
    DoubleColumnStatisticsData: fromDoubleColumnStatisticsData(input["DoubleColumnStatisticsData"]),
    LongColumnStatisticsData: fromLongColumnStatisticsData(input["LongColumnStatisticsData"]),
    StringColumnStatisticsData: fromStringColumnStatisticsData(input["StringColumnStatisticsData"]),
    BinaryColumnStatisticsData: fromBinaryColumnStatisticsData(input["BinaryColumnStatisticsData"]),
  }
}
function toColumnStatisticsData(root: jsonP.JSONValue): ColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<ColumnStatisticsType>(x),
    },
    optional: {
      "BooleanColumnStatisticsData": toBooleanColumnStatisticsData,
      "DateColumnStatisticsData": toDateColumnStatisticsData,
      "DecimalColumnStatisticsData": toDecimalColumnStatisticsData,
      "DoubleColumnStatisticsData": toDoubleColumnStatisticsData,
      "LongColumnStatisticsData": toLongColumnStatisticsData,
      "StringColumnStatisticsData": toStringColumnStatisticsData,
      "BinaryColumnStatisticsData": toBinaryColumnStatisticsData,
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ColumnStatisticsType =
| "BOOLEAN"
| "DATE"
| "DECIMAL"
| "DOUBLE"
| "LONG"
| "STRING"
| "BINARY"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface BooleanColumnStatisticsData {
  NumberOfTrues: number;
  NumberOfFalses: number;
  NumberOfNulls: number;
}
function fromBooleanColumnStatisticsData(input?: BooleanColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NumberOfTrues: input["NumberOfTrues"],
    NumberOfFalses: input["NumberOfFalses"],
    NumberOfNulls: input["NumberOfNulls"],
  }
}
function toBooleanColumnStatisticsData(root: jsonP.JSONValue): BooleanColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfTrues": "n",
      "NumberOfFalses": "n",
      "NumberOfNulls": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DateColumnStatisticsData {
  MinimumValue?: Date | number | null;
  MaximumValue?: Date | number | null;
  NumberOfNulls: number;
  NumberOfDistinctValues: number;
}
function fromDateColumnStatisticsData(input?: DateColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: jsonP.serializeDate_unixTimestamp(input["MinimumValue"]),
    MaximumValue: jsonP.serializeDate_unixTimestamp(input["MaximumValue"]),
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDateColumnStatisticsData(root: jsonP.JSONValue): DateColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "d",
      "MaximumValue": "d",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DecimalColumnStatisticsData {
  MinimumValue?: DecimalNumber | null;
  MaximumValue?: DecimalNumber | null;
  NumberOfNulls: number;
  NumberOfDistinctValues: number;
}
function fromDecimalColumnStatisticsData(input?: DecimalColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: fromDecimalNumber(input["MinimumValue"]),
    MaximumValue: fromDecimalNumber(input["MaximumValue"]),
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDecimalColumnStatisticsData(root: jsonP.JSONValue): DecimalColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": toDecimalNumber,
      "MaximumValue": toDecimalNumber,
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface DecimalNumber {
  UnscaledValue: Uint8Array | string;
  Scale: number;
}
function fromDecimalNumber(input?: DecimalNumber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UnscaledValue: jsonP.serializeBlob(input["UnscaledValue"]),
    Scale: input["Scale"],
  }
}
function toDecimalNumber(root: jsonP.JSONValue): DecimalNumber {
  return jsonP.readObj({
    required: {
      "UnscaledValue": "a",
      "Scale": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface DoubleColumnStatisticsData {
  MinimumValue?: number | null;
  MaximumValue?: number | null;
  NumberOfNulls: number;
  NumberOfDistinctValues: number;
}
function fromDoubleColumnStatisticsData(input?: DoubleColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: input["MinimumValue"],
    MaximumValue: input["MaximumValue"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDoubleColumnStatisticsData(root: jsonP.JSONValue): DoubleColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "n",
      "MaximumValue": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface LongColumnStatisticsData {
  MinimumValue?: number | null;
  MaximumValue?: number | null;
  NumberOfNulls: number;
  NumberOfDistinctValues: number;
}
function fromLongColumnStatisticsData(input?: LongColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: input["MinimumValue"],
    MaximumValue: input["MaximumValue"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toLongColumnStatisticsData(root: jsonP.JSONValue): LongColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "n",
      "MaximumValue": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface StringColumnStatisticsData {
  MaximumLength: number;
  AverageLength: number;
  NumberOfNulls: number;
  NumberOfDistinctValues: number;
}
function fromStringColumnStatisticsData(input?: StringColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumLength: input["MaximumLength"],
    AverageLength: input["AverageLength"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toStringColumnStatisticsData(root: jsonP.JSONValue): StringColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "MaximumLength": "n",
      "AverageLength": "n",
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface BinaryColumnStatisticsData {
  MaximumLength: number;
  AverageLength: number;
  NumberOfNulls: number;
}
function fromBinaryColumnStatisticsData(input?: BinaryColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumLength: input["MaximumLength"],
    AverageLength: input["AverageLength"],
    NumberOfNulls: input["NumberOfNulls"],
  }
}
function toBinaryColumnStatisticsData(root: jsonP.JSONValue): BinaryColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "MaximumLength": "n",
      "AverageLength": "n",
      "NumberOfNulls": "n",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface DevEndpointCustomLibraries {
  ExtraPythonLibsS3Path?: string | null;
  ExtraJarsS3Path?: string | null;
}
function fromDevEndpointCustomLibraries(input?: DevEndpointCustomLibraries | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExtraPythonLibsS3Path: input["ExtraPythonLibsS3Path"],
    ExtraJarsS3Path: input["ExtraJarsS3Path"],
  }
}

// refs: 1 - tags: input, named, interface
export interface JobUpdate {
  Description?: string | null;
  LogUri?: string | null;
  Role?: string | null;
  ExecutionProperty?: ExecutionProperty | null;
  Command?: JobCommand | null;
  DefaultArguments?: { [key: string]: string | null | undefined } | null;
  NonOverridableArguments?: { [key: string]: string | null | undefined } | null;
  Connections?: ConnectionsList | null;
  MaxRetries?: number | null;
  AllocatedCapacity?: number | null;
  Timeout?: number | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  SecurityConfiguration?: string | null;
  NotificationProperty?: NotificationProperty | null;
  GlueVersion?: string | null;
}
function fromJobUpdate(input?: JobUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Description: input["Description"],
    LogUri: input["LogUri"],
    Role: input["Role"],
    ExecutionProperty: fromExecutionProperty(input["ExecutionProperty"]),
    Command: fromJobCommand(input["Command"]),
    DefaultArguments: input["DefaultArguments"],
    NonOverridableArguments: input["NonOverridableArguments"],
    Connections: fromConnectionsList(input["Connections"]),
    MaxRetries: input["MaxRetries"],
    AllocatedCapacity: input["AllocatedCapacity"],
    Timeout: input["Timeout"],
    MaxCapacity: input["MaxCapacity"],
    WorkerType: input["WorkerType"],
    NumberOfWorkers: input["NumberOfWorkers"],
    SecurityConfiguration: input["SecurityConfiguration"],
    NotificationProperty: fromNotificationProperty(input["NotificationProperty"]),
    GlueVersion: input["GlueVersion"],
  }
}

// refs: 1 - tags: input, named, interface
export interface TriggerUpdate {
  Name?: string | null;
  Description?: string | null;
  Schedule?: string | null;
  Actions?: Action[] | null;
  Predicate?: Predicate | null;
}
function fromTriggerUpdate(input?: TriggerUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Schedule: input["Schedule"],
    Actions: input["Actions"]?.map(x => fromAction(x)),
    Predicate: fromPredicate(input["Predicate"]),
  }
}

// refs: 2 - tags: output, named, interface
export interface PartitionError {
  PartitionValues?: string[] | null;
  ErrorDetail?: ErrorDetail | null;
}
function toPartitionError(root: jsonP.JSONValue): PartitionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "PartitionValues": ["s"],
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

// refs: 11 - tags: output, named, interface
export interface ErrorDetail {
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function toErrorDetail(root: jsonP.JSONValue): ErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TableError {
  TableName?: string | null;
  ErrorDetail?: ErrorDetail | null;
}
function toTableError(root: jsonP.JSONValue): TableError {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TableVersionError {
  TableName?: string | null;
  VersionId?: string | null;
  ErrorDetail?: ErrorDetail | null;
}
function toTableVersionError(root: jsonP.JSONValue): TableVersionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "VersionId": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Crawler {
  Name?: string | null;
  Role?: string | null;
  Targets?: CrawlerTargets | null;
  DatabaseName?: string | null;
  Description?: string | null;
  Classifiers?: string[] | null;
  RecrawlPolicy?: RecrawlPolicy | null;
  SchemaChangePolicy?: SchemaChangePolicy | null;
  LineageConfiguration?: LineageConfiguration | null;
  State?: CrawlerState | null;
  TablePrefix?: string | null;
  Schedule?: Schedule | null;
  CrawlElapsedTime?: number | null;
  CreationTime?: Date | number | null;
  LastUpdated?: Date | number | null;
  LastCrawl?: LastCrawlInfo | null;
  Version?: number | null;
  Configuration?: string | null;
  CrawlerSecurityConfiguration?: string | null;
}
function toCrawler(root: jsonP.JSONValue): Crawler {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Role": "s",
      "Targets": toCrawlerTargets,
      "DatabaseName": "s",
      "Description": "s",
      "Classifiers": ["s"],
      "RecrawlPolicy": toRecrawlPolicy,
      "SchemaChangePolicy": toSchemaChangePolicy,
      "LineageConfiguration": toLineageConfiguration,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<CrawlerState>(x),
      "TablePrefix": "s",
      "Schedule": toSchedule,
      "CrawlElapsedTime": "n",
      "CreationTime": "d",
      "LastUpdated": "d",
      "LastCrawl": toLastCrawlInfo,
      "Version": "n",
      "Configuration": "s",
      "CrawlerSecurityConfiguration": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type CrawlerState =
| "READY"
| "RUNNING"
| "STOPPING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Schedule {
  ScheduleExpression?: string | null;
  State?: ScheduleState | null;
}
function toSchedule(root: jsonP.JSONValue): Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScheduleExpression": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<ScheduleState>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ScheduleState =
| "SCHEDULED"
| "NOT_SCHEDULED"
| "TRANSITIONING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface LastCrawlInfo {
  Status?: LastCrawlStatus | null;
  ErrorMessage?: string | null;
  LogGroup?: string | null;
  LogStream?: string | null;
  MessagePrefix?: string | null;
  StartTime?: Date | number | null;
}
function toLastCrawlInfo(root: jsonP.JSONValue): LastCrawlInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<LastCrawlStatus>(x),
      "ErrorMessage": "s",
      "LogGroup": "s",
      "LogStream": "s",
      "MessagePrefix": "s",
      "StartTime": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type LastCrawlStatus =
| "SUCCEEDED"
| "CANCELLED"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface DevEndpoint {
  EndpointName?: string | null;
  RoleArn?: string | null;
  SecurityGroupIds?: string[] | null;
  SubnetId?: string | null;
  YarnEndpointAddress?: string | null;
  PrivateAddress?: string | null;
  ZeppelinRemoteSparkInterpreterPort?: number | null;
  PublicAddress?: string | null;
  Status?: string | null;
  WorkerType?: WorkerType | null;
  GlueVersion?: string | null;
  NumberOfWorkers?: number | null;
  NumberOfNodes?: number | null;
  AvailabilityZone?: string | null;
  VpcId?: string | null;
  ExtraPythonLibsS3Path?: string | null;
  ExtraJarsS3Path?: string | null;
  FailureReason?: string | null;
  LastUpdateStatus?: string | null;
  CreatedTimestamp?: Date | number | null;
  LastModifiedTimestamp?: Date | number | null;
  PublicKey?: string | null;
  PublicKeys?: string[] | null;
  SecurityConfiguration?: string | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
}
function toDevEndpoint(root: jsonP.JSONValue): DevEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointName": "s",
      "RoleArn": "s",
      "SecurityGroupIds": ["s"],
      "SubnetId": "s",
      "YarnEndpointAddress": "s",
      "PrivateAddress": "s",
      "ZeppelinRemoteSparkInterpreterPort": "n",
      "PublicAddress": "s",
      "Status": "s",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
      "GlueVersion": "s",
      "NumberOfWorkers": "n",
      "NumberOfNodes": "n",
      "AvailabilityZone": "s",
      "VpcId": "s",
      "ExtraPythonLibsS3Path": "s",
      "ExtraJarsS3Path": "s",
      "FailureReason": "s",
      "LastUpdateStatus": "s",
      "CreatedTimestamp": "d",
      "LastModifiedTimestamp": "d",
      "PublicKey": "s",
      "PublicKeys": ["s"],
      "SecurityConfiguration": "s",
      "Arguments": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Job {
  Name?: string | null;
  Description?: string | null;
  LogUri?: string | null;
  Role?: string | null;
  CreatedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  ExecutionProperty?: ExecutionProperty | null;
  Command?: JobCommand | null;
  DefaultArguments?: { [key: string]: string | null | undefined } | null;
  NonOverridableArguments?: { [key: string]: string | null | undefined } | null;
  Connections?: ConnectionsList | null;
  MaxRetries?: number | null;
  AllocatedCapacity?: number | null;
  Timeout?: number | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  SecurityConfiguration?: string | null;
  NotificationProperty?: NotificationProperty | null;
  GlueVersion?: string | null;
}
function toJob(root: jsonP.JSONValue): Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "LogUri": "s",
      "Role": "s",
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "ExecutionProperty": toExecutionProperty,
      "Command": toJobCommand,
      "DefaultArguments": x => jsonP.readMap(String, String, x),
      "NonOverridableArguments": x => jsonP.readMap(String, String, x),
      "Connections": toConnectionsList,
      "MaxRetries": "n",
      "AllocatedCapacity": "n",
      "Timeout": "n",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
      "NumberOfWorkers": "n",
      "SecurityConfiguration": "s",
      "NotificationProperty": toNotificationProperty,
      "GlueVersion": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Partition {
  Values?: string[] | null;
  DatabaseName?: string | null;
  TableName?: string | null;
  CreationTime?: Date | number | null;
  LastAccessTime?: Date | number | null;
  StorageDescriptor?: StorageDescriptor | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  LastAnalyzedTime?: Date | number | null;
  CatalogId?: string | null;
}
function toPartition(root: jsonP.JSONValue): Partition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Values": ["s"],
      "DatabaseName": "s",
      "TableName": "s",
      "CreationTime": "d",
      "LastAccessTime": "d",
      "StorageDescriptor": toStorageDescriptor,
      "Parameters": x => jsonP.readMap(String, String, x),
      "LastAnalyzedTime": "d",
      "CatalogId": "s",
    },
  }, root);
}

// refs: 10 - tags: output, named, interface
export interface Trigger {
  Name?: string | null;
  WorkflowName?: string | null;
  Id?: string | null;
  Type?: TriggerType | null;
  State?: TriggerState | null;
  Description?: string | null;
  Schedule?: string | null;
  Actions?: Action[] | null;
  Predicate?: Predicate | null;
}
function toTrigger(root: jsonP.JSONValue): Trigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "WorkflowName": "s",
      "Id": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<TriggerType>(x),
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<TriggerState>(x),
      "Description": "s",
      "Schedule": "s",
      "Actions": [toAction],
      "Predicate": toPredicate,
    },
  }, root);
}

// refs: 10 - tags: output, named, enum
export type TriggerState =
| "CREATING"
| "CREATED"
| "ACTIVATING"
| "ACTIVATED"
| "DEACTIVATING"
| "DEACTIVATED"
| "DELETING"
| "UPDATING"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface Workflow {
  Name?: string | null;
  Description?: string | null;
  DefaultRunProperties?: { [key: string]: string | null | undefined } | null;
  CreatedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  LastRun?: WorkflowRun | null;
  Graph?: WorkflowGraph | null;
  MaxConcurrentRuns?: number | null;
}
function toWorkflow(root: jsonP.JSONValue): Workflow {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "DefaultRunProperties": x => jsonP.readMap(String, String, x),
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "LastRun": toWorkflowRun,
      "Graph": toWorkflowGraph,
      "MaxConcurrentRuns": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface WorkflowRun {
  Name?: string | null;
  WorkflowRunId?: string | null;
  PreviousRunId?: string | null;
  WorkflowRunProperties?: { [key: string]: string | null | undefined } | null;
  StartedOn?: Date | number | null;
  CompletedOn?: Date | number | null;
  Status?: WorkflowRunStatus | null;
  ErrorMessage?: string | null;
  Statistics?: WorkflowRunStatistics | null;
  Graph?: WorkflowGraph | null;
}
function toWorkflowRun(root: jsonP.JSONValue): WorkflowRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "WorkflowRunId": "s",
      "PreviousRunId": "s",
      "WorkflowRunProperties": x => jsonP.readMap(String, String, x),
      "StartedOn": "d",
      "CompletedOn": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<WorkflowRunStatus>(x),
      "ErrorMessage": "s",
      "Statistics": toWorkflowRunStatistics,
      "Graph": toWorkflowGraph,
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type WorkflowRunStatus =
| "RUNNING"
| "COMPLETED"
| "STOPPING"
| "STOPPED"
| "ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface WorkflowRunStatistics {
  TotalActions?: number | null;
  TimeoutActions?: number | null;
  FailedActions?: number | null;
  StoppedActions?: number | null;
  SucceededActions?: number | null;
  RunningActions?: number | null;
}
function toWorkflowRunStatistics(root: jsonP.JSONValue): WorkflowRunStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalActions": "n",
      "TimeoutActions": "n",
      "FailedActions": "n",
      "StoppedActions": "n",
      "SucceededActions": "n",
      "RunningActions": "n",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface WorkflowGraph {
  Nodes?: Node[] | null;
  Edges?: Edge[] | null;
}
function toWorkflowGraph(root: jsonP.JSONValue): WorkflowGraph {
  return jsonP.readObj({
    required: {},
    optional: {
      "Nodes": [toNode],
      "Edges": [toEdge],
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Node {
  Type?: NodeType | null;
  Name?: string | null;
  UniqueId?: string | null;
  TriggerDetails?: TriggerNodeDetails | null;
  JobDetails?: JobNodeDetails | null;
  CrawlerDetails?: CrawlerNodeDetails | null;
}
function toNode(root: jsonP.JSONValue): Node {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<NodeType>(x),
      "Name": "s",
      "UniqueId": "s",
      "TriggerDetails": toTriggerNodeDetails,
      "JobDetails": toJobNodeDetails,
      "CrawlerDetails": toCrawlerNodeDetails,
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type NodeType =
| "CRAWLER"
| "JOB"
| "TRIGGER"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface TriggerNodeDetails {
  Trigger?: Trigger | null;
}
function toTriggerNodeDetails(root: jsonP.JSONValue): TriggerNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Trigger": toTrigger,
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface JobNodeDetails {
  JobRuns?: JobRun[] | null;
}
function toJobNodeDetails(root: jsonP.JSONValue): JobNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobRuns": [toJobRun],
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface JobRun {
  Id?: string | null;
  Attempt?: number | null;
  PreviousRunId?: string | null;
  TriggerName?: string | null;
  JobName?: string | null;
  StartedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  CompletedOn?: Date | number | null;
  JobRunState?: JobRunState | null;
  Arguments?: { [key: string]: string | null | undefined } | null;
  ErrorMessage?: string | null;
  PredecessorRuns?: Predecessor[] | null;
  AllocatedCapacity?: number | null;
  ExecutionTime?: number | null;
  Timeout?: number | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  SecurityConfiguration?: string | null;
  LogGroupName?: string | null;
  NotificationProperty?: NotificationProperty | null;
  GlueVersion?: string | null;
}
function toJobRun(root: jsonP.JSONValue): JobRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Attempt": "n",
      "PreviousRunId": "s",
      "TriggerName": "s",
      "JobName": "s",
      "StartedOn": "d",
      "LastModifiedOn": "d",
      "CompletedOn": "d",
      "JobRunState": (x: jsonP.JSONValue) => cmnP.readEnum<JobRunState>(x),
      "Arguments": x => jsonP.readMap(String, String, x),
      "ErrorMessage": "s",
      "PredecessorRuns": [toPredecessor],
      "AllocatedCapacity": "n",
      "ExecutionTime": "n",
      "Timeout": "n",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
      "NumberOfWorkers": "n",
      "SecurityConfiguration": "s",
      "LogGroupName": "s",
      "NotificationProperty": toNotificationProperty,
      "GlueVersion": "s",
    },
  }, root);
}

// refs: 8 - tags: output, named, interface
export interface Predecessor {
  JobName?: string | null;
  RunId?: string | null;
}
function toPredecessor(root: jsonP.JSONValue): Predecessor {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "RunId": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface CrawlerNodeDetails {
  Crawls?: Crawl[] | null;
}
function toCrawlerNodeDetails(root: jsonP.JSONValue): CrawlerNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Crawls": [toCrawl],
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Crawl {
  State?: CrawlState | null;
  StartedOn?: Date | number | null;
  CompletedOn?: Date | number | null;
  ErrorMessage?: string | null;
  LogGroup?: string | null;
  LogStream?: string | null;
}
function toCrawl(root: jsonP.JSONValue): Crawl {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<CrawlState>(x),
      "StartedOn": "d",
      "CompletedOn": "d",
      "ErrorMessage": "s",
      "LogGroup": "s",
      "LogStream": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface Edge {
  SourceId?: string | null;
  DestinationId?: string | null;
}
function toEdge(root: jsonP.JSONValue): Edge {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceId": "s",
      "DestinationId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchStopJobRunSuccessfulSubmission {
  JobName?: string | null;
  JobRunId?: string | null;
}
function toBatchStopJobRunSuccessfulSubmission(root: jsonP.JSONValue): BatchStopJobRunSuccessfulSubmission {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "JobRunId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchStopJobRunError {
  JobName?: string | null;
  JobRunId?: string | null;
  ErrorDetail?: ErrorDetail | null;
}
function toBatchStopJobRunError(root: jsonP.JSONValue): BatchStopJobRunError {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "JobRunId": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface BatchUpdatePartitionFailureEntry {
  PartitionValueList?: string[] | null;
  ErrorDetail?: ErrorDetail | null;
}
function toBatchUpdatePartitionFailureEntry(root: jsonP.JSONValue): BatchUpdatePartitionFailureEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "PartitionValueList": ["s"],
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type SchemaStatus =
| "AVAILABLE"
| "PENDING"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, enum
export type SchemaVersionStatus =
| "AVAILABLE"
| "PENDING"
| "FAILURE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, enum
export type RegistryStatus =
| "AVAILABLE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface SchemaVersionErrorItem {
  VersionNumber?: number | null;
  ErrorDetails?: ErrorDetails | null;
}
function toSchemaVersionErrorItem(root: jsonP.JSONValue): SchemaVersionErrorItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionNumber": "n",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ErrorDetails {
  ErrorCode?: string | null;
  ErrorMessage?: string | null;
}
function toErrorDetails(root: jsonP.JSONValue): ErrorDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CatalogImportStatus {
  ImportCompleted?: boolean | null;
  ImportTime?: Date | number | null;
  ImportedBy?: string | null;
}
function toCatalogImportStatus(root: jsonP.JSONValue): CatalogImportStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ImportCompleted": "b",
      "ImportTime": "d",
      "ImportedBy": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Classifier {
  GrokClassifier?: GrokClassifier | null;
  XMLClassifier?: XMLClassifier | null;
  JsonClassifier?: JsonClassifier | null;
  CsvClassifier?: CsvClassifier | null;
}
function toClassifier(root: jsonP.JSONValue): Classifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "GrokClassifier": toGrokClassifier,
      "XMLClassifier": toXMLClassifier,
      "JsonClassifier": toJsonClassifier,
      "CsvClassifier": toCsvClassifier,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface GrokClassifier {
  Name: string;
  Classification: string;
  CreationTime?: Date | number | null;
  LastUpdated?: Date | number | null;
  Version?: number | null;
  GrokPattern: string;
  CustomPatterns?: string | null;
}
function toGrokClassifier(root: jsonP.JSONValue): GrokClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Classification": "s",
      "GrokPattern": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "CustomPatterns": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface XMLClassifier {
  Name: string;
  Classification: string;
  CreationTime?: Date | number | null;
  LastUpdated?: Date | number | null;
  Version?: number | null;
  RowTag?: string | null;
}
function toXMLClassifier(root: jsonP.JSONValue): XMLClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Classification": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "RowTag": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface JsonClassifier {
  Name: string;
  CreationTime?: Date | number | null;
  LastUpdated?: Date | number | null;
  Version?: number | null;
  JsonPath: string;
}
function toJsonClassifier(root: jsonP.JSONValue): JsonClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "JsonPath": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface CsvClassifier {
  Name: string;
  CreationTime?: Date | number | null;
  LastUpdated?: Date | number | null;
  Version?: number | null;
  Delimiter?: string | null;
  QuoteSymbol?: string | null;
  ContainsHeader?: CsvHeaderOption | null;
  Header?: string[] | null;
  DisableValueTrimming?: boolean | null;
  AllowSingleColumn?: boolean | null;
}
function toCsvClassifier(root: jsonP.JSONValue): CsvClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "Delimiter": "s",
      "QuoteSymbol": "s",
      "ContainsHeader": (x: jsonP.JSONValue) => cmnP.readEnum<CsvHeaderOption>(x),
      "Header": ["s"],
      "DisableValueTrimming": "b",
      "AllowSingleColumn": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ColumnError {
  ColumnName?: string | null;
  Error?: ErrorDetail | null;
}
function toColumnError(root: jsonP.JSONValue): ColumnError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnName": "s",
      "Error": toErrorDetail,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Connection {
  Name?: string | null;
  Description?: string | null;
  ConnectionType?: ConnectionType | null;
  MatchCriteria?: string[] | null;
  ConnectionProperties?: { [key in ConnectionPropertyKey]: string | null | undefined } | null;
  PhysicalConnectionRequirements?: PhysicalConnectionRequirements | null;
  CreationTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
  LastUpdatedBy?: string | null;
}
function toConnection(root: jsonP.JSONValue): Connection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<ConnectionType>(x),
      "MatchCriteria": ["s"],
      "ConnectionProperties": x => jsonP.readMap(x => cmnP.readEnumReq<ConnectionPropertyKey>(x), String, x),
      "PhysicalConnectionRequirements": toPhysicalConnectionRequirements,
      "CreationTime": "d",
      "LastUpdatedTime": "d",
      "LastUpdatedBy": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CrawlerMetrics {
  CrawlerName?: string | null;
  TimeLeftSeconds?: number | null;
  StillEstimating?: boolean | null;
  LastRuntimeSeconds?: number | null;
  MedianRuntimeSeconds?: number | null;
  TablesCreated?: number | null;
  TablesUpdated?: number | null;
  TablesDeleted?: number | null;
}
function toCrawlerMetrics(root: jsonP.JSONValue): CrawlerMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "CrawlerName": "s",
      "TimeLeftSeconds": "n",
      "StillEstimating": "b",
      "LastRuntimeSeconds": "n",
      "MedianRuntimeSeconds": "n",
      "TablesCreated": "n",
      "TablesUpdated": "n",
      "TablesDeleted": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface Database {
  Name: string;
  Description?: string | null;
  LocationUri?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  CreateTime?: Date | number | null;
  CreateTableDefaultPermissions?: PrincipalPermissions[] | null;
  TargetDatabase?: DatabaseIdentifier | null;
  CatalogId?: string | null;
}
function toDatabase(root: jsonP.JSONValue): Database {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Description": "s",
      "LocationUri": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
      "CreateTime": "d",
      "CreateTableDefaultPermissions": [toPrincipalPermissions],
      "TargetDatabase": toDatabaseIdentifier,
      "CatalogId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface JobBookmarkEntry {
  JobName?: string | null;
  Version?: number | null;
  Run?: number | null;
  Attempt?: number | null;
  PreviousRunId?: string | null;
  RunId?: string | null;
  JobBookmark?: string | null;
}
function toJobBookmarkEntry(root: jsonP.JSONValue): JobBookmarkEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "Version": "n",
      "Run": "n",
      "Attempt": "n",
      "PreviousRunId": "s",
      "RunId": "s",
      "JobBookmark": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TaskRunProperties {
  TaskType?: TaskType | null;
  ImportLabelsTaskRunProperties?: ImportLabelsTaskRunProperties | null;
  ExportLabelsTaskRunProperties?: ExportLabelsTaskRunProperties | null;
  LabelingSetGenerationTaskRunProperties?: LabelingSetGenerationTaskRunProperties | null;
  FindMatchesTaskRunProperties?: FindMatchesTaskRunProperties | null;
}
function toTaskRunProperties(root: jsonP.JSONValue): TaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<TaskType>(x),
      "ImportLabelsTaskRunProperties": toImportLabelsTaskRunProperties,
      "ExportLabelsTaskRunProperties": toExportLabelsTaskRunProperties,
      "LabelingSetGenerationTaskRunProperties": toLabelingSetGenerationTaskRunProperties,
      "FindMatchesTaskRunProperties": toFindMatchesTaskRunProperties,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ImportLabelsTaskRunProperties {
  InputS3Path?: string | null;
  Replace?: boolean | null;
}
function toImportLabelsTaskRunProperties(root: jsonP.JSONValue): ImportLabelsTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputS3Path": "s",
      "Replace": "b",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ExportLabelsTaskRunProperties {
  OutputS3Path?: string | null;
}
function toExportLabelsTaskRunProperties(root: jsonP.JSONValue): ExportLabelsTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputS3Path": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LabelingSetGenerationTaskRunProperties {
  OutputS3Path?: string | null;
}
function toLabelingSetGenerationTaskRunProperties(root: jsonP.JSONValue): LabelingSetGenerationTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputS3Path": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FindMatchesTaskRunProperties {
  JobId?: string | null;
  JobName?: string | null;
  JobRunId?: string | null;
}
function toFindMatchesTaskRunProperties(root: jsonP.JSONValue): FindMatchesTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobRunId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TaskRun {
  TransformId?: string | null;
  TaskRunId?: string | null;
  Status?: TaskStatusType | null;
  LogGroupName?: string | null;
  Properties?: TaskRunProperties | null;
  ErrorString?: string | null;
  StartedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  CompletedOn?: Date | number | null;
  ExecutionTime?: number | null;
}
function toTaskRun(root: jsonP.JSONValue): TaskRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformId": "s",
      "TaskRunId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TaskStatusType>(x),
      "LogGroupName": "s",
      "Properties": toTaskRunProperties,
      "ErrorString": "s",
      "StartedOn": "d",
      "LastModifiedOn": "d",
      "CompletedOn": "d",
      "ExecutionTime": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface EvaluationMetrics {
  TransformType: TransformType;
  FindMatchesMetrics?: FindMatchesMetrics | null;
}
function toEvaluationMetrics(root: jsonP.JSONValue): EvaluationMetrics {
  return jsonP.readObj({
    required: {
      "TransformType": (x: jsonP.JSONValue) => cmnP.readEnum<TransformType>(x),
    },
    optional: {
      "FindMatchesMetrics": toFindMatchesMetrics,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FindMatchesMetrics {
  AreaUnderPRCurve?: number | null;
  Precision?: number | null;
  Recall?: number | null;
  F1?: number | null;
  ConfusionMatrix?: ConfusionMatrix | null;
  ColumnImportances?: ColumnImportance[] | null;
}
function toFindMatchesMetrics(root: jsonP.JSONValue): FindMatchesMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "AreaUnderPRCurve": "n",
      "Precision": "n",
      "Recall": "n",
      "F1": "n",
      "ConfusionMatrix": toConfusionMatrix,
      "ColumnImportances": [toColumnImportance],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ConfusionMatrix {
  NumTruePositives?: number | null;
  NumFalsePositives?: number | null;
  NumTrueNegatives?: number | null;
  NumFalseNegatives?: number | null;
}
function toConfusionMatrix(root: jsonP.JSONValue): ConfusionMatrix {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumTruePositives": "n",
      "NumFalsePositives": "n",
      "NumTrueNegatives": "n",
      "NumFalseNegatives": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ColumnImportance {
  ColumnName?: string | null;
  Importance?: number | null;
}
function toColumnImportance(root: jsonP.JSONValue): ColumnImportance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnName": "s",
      "Importance": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MLTransform {
  TransformId?: string | null;
  Name?: string | null;
  Description?: string | null;
  Status?: TransformStatusType | null;
  CreatedOn?: Date | number | null;
  LastModifiedOn?: Date | number | null;
  InputRecordTables?: GlueTable[] | null;
  Parameters?: TransformParameters | null;
  EvaluationMetrics?: EvaluationMetrics | null;
  LabelCount?: number | null;
  Schema?: SchemaColumn[] | null;
  Role?: string | null;
  GlueVersion?: string | null;
  MaxCapacity?: number | null;
  WorkerType?: WorkerType | null;
  NumberOfWorkers?: number | null;
  Timeout?: number | null;
  MaxRetries?: number | null;
  TransformEncryption?: TransformEncryption | null;
}
function toMLTransform(root: jsonP.JSONValue): MLTransform {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformId": "s",
      "Name": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<TransformStatusType>(x),
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "InputRecordTables": [toGlueTable],
      "Parameters": toTransformParameters,
      "EvaluationMetrics": toEvaluationMetrics,
      "LabelCount": "n",
      "Schema": [toSchemaColumn],
      "Role": "s",
      "GlueVersion": "s",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<WorkerType>(x),
      "NumberOfWorkers": "n",
      "Timeout": "n",
      "MaxRetries": "n",
      "TransformEncryption": toTransformEncryption,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PartitionIndexDescriptor {
  IndexName: string;
  Keys: KeySchemaElement[];
  IndexStatus: PartitionIndexStatus;
  BackfillErrors?: BackfillError[] | null;
}
function toPartitionIndexDescriptor(root: jsonP.JSONValue): PartitionIndexDescriptor {
  return jsonP.readObj({
    required: {
      "IndexName": "s",
      "Keys": [toKeySchemaElement],
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<PartitionIndexStatus>(x),
    },
    optional: {
      "BackfillErrors": [toBackfillError],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface KeySchemaElement {
  Name: string;
  Type: string;
}
function toKeySchemaElement(root: jsonP.JSONValue): KeySchemaElement {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, enum
export type PartitionIndexStatus =
| "CREATING"
| "ACTIVE"
| "DELETING"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface BackfillError {
  Code?: BackfillErrorCode | null;
  Partitions?: PartitionValueList[] | null;
}
function toBackfillError(root: jsonP.JSONValue): BackfillError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<BackfillErrorCode>(x),
      "Partitions": [toPartitionValueList],
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type BackfillErrorCode =
| "ENCRYPTED_PARTITION_ERROR"
| "INTERNAL_ERROR"
| "INVALID_PARTITION_TYPE_DATA_ERROR"
| "MISSING_PARTITION_VALUE_ERROR"
| "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface GluePolicy {
  PolicyInJson?: string | null;
  PolicyHash?: string | null;
  CreateTime?: Date | number | null;
  UpdateTime?: Date | number | null;
}
function toGluePolicy(root: jsonP.JSONValue): GluePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyInJson": "s",
      "PolicyHash": "s",
      "CreateTime": "d",
      "UpdateTime": "d",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SecurityConfiguration {
  Name?: string | null;
  CreatedTimeStamp?: Date | number | null;
  EncryptionConfiguration?: EncryptionConfiguration | null;
}
function toSecurityConfiguration(root: jsonP.JSONValue): SecurityConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CreatedTimeStamp": "d",
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
  }, root);
}

// refs: 5 - tags: output, named, interface
export interface Table {
  Name: string;
  DatabaseName?: string | null;
  Description?: string | null;
  Owner?: string | null;
  CreateTime?: Date | number | null;
  UpdateTime?: Date | number | null;
  LastAccessTime?: Date | number | null;
  LastAnalyzedTime?: Date | number | null;
  Retention?: number | null;
  StorageDescriptor?: StorageDescriptor | null;
  PartitionKeys?: Column[] | null;
  ViewOriginalText?: string | null;
  ViewExpandedText?: string | null;
  TableType?: string | null;
  Parameters?: { [key: string]: string | null | undefined } | null;
  CreatedBy?: string | null;
  IsRegisteredWithLakeFormation?: boolean | null;
  TargetTable?: TableIdentifier | null;
  CatalogId?: string | null;
}
function toTable(root: jsonP.JSONValue): Table {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "DatabaseName": "s",
      "Description": "s",
      "Owner": "s",
      "CreateTime": "d",
      "UpdateTime": "d",
      "LastAccessTime": "d",
      "LastAnalyzedTime": "d",
      "Retention": "n",
      "StorageDescriptor": toStorageDescriptor,
      "PartitionKeys": [toColumn],
      "ViewOriginalText": "s",
      "ViewExpandedText": "s",
      "TableType": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
      "CreatedBy": "s",
      "IsRegisteredWithLakeFormation": "b",
      "TargetTable": toTableIdentifier,
      "CatalogId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TableVersion {
  Table?: Table | null;
  VersionId?: string | null;
}
function toTableVersion(root: jsonP.JSONValue): TableVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Table": toTable,
      "VersionId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface UserDefinedFunction {
  FunctionName?: string | null;
  DatabaseName?: string | null;
  ClassName?: string | null;
  OwnerName?: string | null;
  OwnerType?: PrincipalType | null;
  CreateTime?: Date | number | null;
  ResourceUris?: ResourceUri[] | null;
  CatalogId?: string | null;
}
function toUserDefinedFunction(root: jsonP.JSONValue): UserDefinedFunction {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionName": "s",
      "DatabaseName": "s",
      "ClassName": "s",
      "OwnerName": "s",
      "OwnerType": (x: jsonP.JSONValue) => cmnP.readEnum<PrincipalType>(x),
      "CreateTime": "d",
      "ResourceUris": [toResourceUri],
      "CatalogId": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RegistryListItem {
  RegistryName?: string | null;
  RegistryArn?: string | null;
  Description?: string | null;
  Status?: RegistryStatus | null;
  CreatedTime?: string | null;
  UpdatedTime?: string | null;
}
function toRegistryListItem(root: jsonP.JSONValue): RegistryListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegistryName": "s",
      "RegistryArn": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<RegistryStatus>(x),
      "CreatedTime": "s",
      "UpdatedTime": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SchemaVersionListItem {
  SchemaArn?: string | null;
  SchemaVersionId?: string | null;
  VersionNumber?: number | null;
  Status?: SchemaVersionStatus | null;
  CreatedTime?: string | null;
}
function toSchemaVersionListItem(root: jsonP.JSONValue): SchemaVersionListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "SchemaVersionId": "s",
      "VersionNumber": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaVersionStatus>(x),
      "CreatedTime": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SchemaListItem {
  RegistryName?: string | null;
  SchemaName?: string | null;
  SchemaArn?: string | null;
  Description?: string | null;
  SchemaStatus?: SchemaStatus | null;
  CreatedTime?: string | null;
  UpdatedTime?: string | null;
}
function toSchemaListItem(root: jsonP.JSONValue): SchemaListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegistryName": "s",
      "SchemaName": "s",
      "SchemaArn": "s",
      "Description": "s",
      "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SchemaStatus>(x),
      "CreatedTime": "s",
      "UpdatedTime": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MetadataInfo {
  MetadataValue?: string | null;
  CreatedTime?: string | null;
}
function toMetadataInfo(root: jsonP.JSONValue): MetadataInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetadataValue": "s",
      "CreatedTime": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ColumnStatisticsError {
  ColumnStatistics?: ColumnStatistics | null;
  Error?: ErrorDetail | null;
}
function toColumnStatisticsError(root: jsonP.JSONValue): ColumnStatisticsError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnStatistics": toColumnStatistics,
      "Error": toErrorDetail,
    },
  }, root);
}
