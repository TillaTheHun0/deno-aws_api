// Autogenerated API client for: AWS Glue

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Glue {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Glue.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-03-31",
    "endpointPrefix": "glue",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "AWS Glue",
    "serviceId": "Glue",
    "signatureVersion": "v4",
    "targetPrefix": "AWSGlue",
    "uid": "glue-2017-03-31"
  };

  async batchCreatePartition(
    {abortSignal, ...params}: RequestConfig & s.BatchCreatePartitionRequest,
  ): Promise<s.BatchCreatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionInputList: params["PartitionInputList"]?.map(x => fromPartitionInput(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchCreatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toPartitionError],
      },
    }, await resp.json());
  }

  async batchDeleteConnection(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteConnectionRequest,
  ): Promise<s.BatchDeleteConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionNameList: params["ConnectionNameList"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Succeeded": ["s"],
        "Errors": x => jsonP.readMap(String, toErrorDetail, x),
      },
    }, await resp.json());
  }

  async batchDeletePartition(
    {abortSignal, ...params}: RequestConfig & s.BatchDeletePartitionRequest,
  ): Promise<s.BatchDeletePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionsToDelete: params["PartitionsToDelete"]?.map(x => fromPartitionValueList(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeletePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toPartitionError],
      },
    }, await resp.json());
  }

  async batchDeleteTable(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteTableRequest,
  ): Promise<s.BatchDeleteTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TablesToDelete: params["TablesToDelete"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toTableError],
      },
    }, await resp.json());
  }

  async batchDeleteTableVersion(
    {abortSignal, ...params}: RequestConfig & s.BatchDeleteTableVersionRequest,
  ): Promise<s.BatchDeleteTableVersionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionIds: params["VersionIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchDeleteTableVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toTableVersionError],
      },
    }, await resp.json());
  }

  async batchGetCrawlers(
    {abortSignal, ...params}: RequestConfig & s.BatchGetCrawlersRequest,
  ): Promise<s.BatchGetCrawlersResponse> {
    const body: jsonP.JSONObject = {
      CrawlerNames: params["CrawlerNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawlers": [toCrawler],
        "CrawlersNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetDevEndpoints(
    {abortSignal, ...params}: RequestConfig & s.BatchGetDevEndpointsRequest,
  ): Promise<s.BatchGetDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      DevEndpointNames: params["DevEndpointNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoints": [toDevEndpoint],
        "DevEndpointsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetJobs(
    {abortSignal, ...params}: RequestConfig & s.BatchGetJobsRequest,
  ): Promise<s.BatchGetJobsResponse> {
    const body: jsonP.JSONObject = {
      JobNames: params["JobNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "JobsNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetPartition(
    {abortSignal, ...params}: RequestConfig & s.BatchGetPartitionRequest,
  ): Promise<s.BatchGetPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionsToGet: params["PartitionsToGet"]?.map(x => fromPartitionValueList(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partitions": [toPartition],
        "UnprocessedKeys": [toPartitionValueList],
      },
    }, await resp.json());
  }

  async batchGetTriggers(
    {abortSignal, ...params}: RequestConfig & s.BatchGetTriggersRequest,
  ): Promise<s.BatchGetTriggersResponse> {
    const body: jsonP.JSONObject = {
      TriggerNames: params["TriggerNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Triggers": [toTrigger],
        "TriggersNotFound": ["s"],
      },
    }, await resp.json());
  }

  async batchGetWorkflows(
    {abortSignal, ...params}: RequestConfig & s.BatchGetWorkflowsRequest,
  ): Promise<s.BatchGetWorkflowsResponse> {
    const body: jsonP.JSONObject = {
      Names: params["Names"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchGetWorkflows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflows": [toWorkflow],
        "MissingWorkflows": ["s"],
      },
    }, await resp.json());
  }

  async batchStopJobRun(
    {abortSignal, ...params}: RequestConfig & s.BatchStopJobRunRequest,
  ): Promise<s.BatchStopJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobRunIds: params["JobRunIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchStopJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SuccessfulSubmissions": [toBatchStopJobRunSuccessfulSubmission],
        "Errors": [toBatchStopJobRunError],
      },
    }, await resp.json());
  }

  async batchUpdatePartition(
    {abortSignal, ...params}: RequestConfig & s.BatchUpdatePartitionRequest,
  ): Promise<s.BatchUpdatePartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      Entries: params["Entries"]?.map(x => fromBatchUpdatePartitionRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "BatchUpdatePartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toBatchUpdatePartitionFailureEntry],
      },
    }, await resp.json());
  }

  async cancelMLTaskRun(
    {abortSignal, ...params}: RequestConfig & s.CancelMLTaskRunRequest,
  ): Promise<s.CancelMLTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      TaskRunId: params["TaskRunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CancelMLTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "TaskRunId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskStatusType>(x),
      },
    }, await resp.json());
  }

  async checkSchemaVersionValidity(
    {abortSignal, ...params}: RequestConfig & s.CheckSchemaVersionValidityInput,
  ): Promise<s.CheckSchemaVersionValidityResponse> {
    const body: jsonP.JSONObject = {
      DataFormat: params["DataFormat"],
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CheckSchemaVersionValidity",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Valid": "b",
        "Error": "s",
      },
    }, await resp.json());
  }

  async createClassifier(
    {abortSignal, ...params}: RequestConfig & s.CreateClassifierRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GrokClassifier: fromCreateGrokClassifierRequest(params["GrokClassifier"]),
      XMLClassifier: fromCreateXMLClassifierRequest(params["XMLClassifier"]),
      JsonClassifier: fromCreateJsonClassifierRequest(params["JsonClassifier"]),
      CsvClassifier: fromCreateCsvClassifierRequest(params["CsvClassifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateClassifier",
    });
    await resp.text();
  }

  async createConnection(
    {abortSignal, ...params}: RequestConfig & s.CreateConnectionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionInput: fromConnectionInput(params["ConnectionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateConnection",
    });
    await resp.text();
  }

  async createCrawler(
    {abortSignal, ...params}: RequestConfig & s.CreateCrawlerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Role: params["Role"],
      DatabaseName: params["DatabaseName"],
      Description: params["Description"],
      Targets: fromCrawlerTargets(params["Targets"]),
      Schedule: params["Schedule"],
      Classifiers: params["Classifiers"],
      TablePrefix: params["TablePrefix"],
      SchemaChangePolicy: fromSchemaChangePolicy(params["SchemaChangePolicy"]),
      RecrawlPolicy: fromRecrawlPolicy(params["RecrawlPolicy"]),
      LineageConfiguration: fromLineageConfiguration(params["LineageConfiguration"]),
      Configuration: params["Configuration"],
      CrawlerSecurityConfiguration: params["CrawlerSecurityConfiguration"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCrawler",
    });
    await resp.text();
  }

  async createDatabase(
    {abortSignal, ...params}: RequestConfig & s.CreateDatabaseRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseInput: fromDatabaseInput(params["DatabaseInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatabase",
    });
    await resp.text();
  }

  async createDevEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateDevEndpointRequest,
  ): Promise<s.CreateDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      RoleArn: params["RoleArn"],
      SecurityGroupIds: params["SecurityGroupIds"],
      SubnetId: params["SubnetId"],
      PublicKey: params["PublicKey"],
      PublicKeys: params["PublicKeys"],
      NumberOfNodes: params["NumberOfNodes"],
      WorkerType: params["WorkerType"],
      GlueVersion: params["GlueVersion"],
      NumberOfWorkers: params["NumberOfWorkers"],
      ExtraPythonLibsS3Path: params["ExtraPythonLibsS3Path"],
      ExtraJarsS3Path: params["ExtraJarsS3Path"],
      SecurityConfiguration: params["SecurityConfiguration"],
      Tags: params["Tags"],
      Arguments: params["Arguments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "EndpointName": "s",
        "Status": "s",
        "SecurityGroupIds": ["s"],
        "SubnetId": "s",
        "RoleArn": "s",
        "YarnEndpointAddress": "s",
        "ZeppelinRemoteSparkInterpreterPort": "n",
        "NumberOfNodes": "n",
        "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
        "GlueVersion": "s",
        "NumberOfWorkers": "n",
        "AvailabilityZone": "s",
        "VpcId": "s",
        "ExtraPythonLibsS3Path": "s",
        "ExtraJarsS3Path": "s",
        "FailureReason": "s",
        "SecurityConfiguration": "s",
        "CreatedTimestamp": "d",
        "Arguments": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createJob(
    {abortSignal, ...params}: RequestConfig & s.CreateJobRequest,
  ): Promise<s.CreateJobResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      LogUri: params["LogUri"],
      Role: params["Role"],
      ExecutionProperty: fromExecutionProperty(params["ExecutionProperty"]),
      Command: fromJobCommand(params["Command"]),
      DefaultArguments: params["DefaultArguments"],
      NonOverridableArguments: params["NonOverridableArguments"],
      Connections: fromConnectionsList(params["Connections"]),
      MaxRetries: params["MaxRetries"],
      AllocatedCapacity: params["AllocatedCapacity"],
      Timeout: params["Timeout"],
      MaxCapacity: params["MaxCapacity"],
      SecurityConfiguration: params["SecurityConfiguration"],
      Tags: params["Tags"],
      NotificationProperty: fromNotificationProperty(params["NotificationProperty"]),
      GlueVersion: params["GlueVersion"],
      NumberOfWorkers: params["NumberOfWorkers"],
      WorkerType: params["WorkerType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async createMLTransform(
    {abortSignal, ...params}: RequestConfig & s.CreateMLTransformRequest,
  ): Promise<s.CreateMLTransformResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      InputRecordTables: params["InputRecordTables"]?.map(x => fromGlueTable(x)),
      Parameters: fromTransformParameters(params["Parameters"]),
      Role: params["Role"],
      GlueVersion: params["GlueVersion"],
      MaxCapacity: params["MaxCapacity"],
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
      Timeout: params["Timeout"],
      MaxRetries: params["MaxRetries"],
      Tags: params["Tags"],
      TransformEncryption: fromTransformEncryption(params["TransformEncryption"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async createPartition(
    {abortSignal, ...params}: RequestConfig & s.CreatePartitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionInput: fromPartitionInput(params["PartitionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePartition",
    });
    await resp.text();
  }

  async createPartitionIndex(
    {abortSignal, ...params}: RequestConfig & s.CreatePartitionIndexRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionIndex: fromPartitionIndex(params["PartitionIndex"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePartitionIndex",
    });
    await resp.text();
  }

  async createRegistry(
    {abortSignal, ...params}: RequestConfig & s.CreateRegistryInput,
  ): Promise<s.CreateRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryName: params["RegistryName"],
      Description: params["Description"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryArn": "s",
        "RegistryName": "s",
        "Description": "s",
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async createSchema(
    {abortSignal, ...params}: RequestConfig & s.CreateSchemaInput,
  ): Promise<s.CreateSchemaResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      SchemaName: params["SchemaName"],
      DataFormat: params["DataFormat"],
      Compatibility: params["Compatibility"],
      Description: params["Description"],
      Tags: params["Tags"],
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "SchemaName": "s",
        "SchemaArn": "s",
        "Description": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataFormat>(x),
        "Compatibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.Compatibility>(x),
        "SchemaCheckpoint": "n",
        "LatestSchemaVersion": "n",
        "NextSchemaVersion": "n",
        "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
        "Tags": x => jsonP.readMap(String, String, x),
        "SchemaVersionId": "s",
        "SchemaVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaVersionStatus>(x),
      },
    }, await resp.json());
  }

  async createScript(
    {abortSignal, ...params}: RequestConfig & s.CreateScriptRequest = {},
  ): Promise<s.CreateScriptResponse> {
    const body: jsonP.JSONObject = {
      DagNodes: params["DagNodes"]?.map(x => fromCodeGenNode(x)),
      DagEdges: params["DagEdges"]?.map(x => fromCodeGenEdge(x)),
      Language: params["Language"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateScript",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PythonScript": "s",
        "ScalaCode": "s",
      },
    }, await resp.json());
  }

  async createSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateSecurityConfigurationRequest,
  ): Promise<s.CreateSecurityConfigurationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      EncryptionConfiguration: fromEncryptionConfiguration(params["EncryptionConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
        "CreatedTimestamp": "d",
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & s.CreateTableRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableInput: fromTableInput(params["TableInput"]),
      PartitionIndexes: params["PartitionIndexes"]?.map(x => fromPartitionIndex(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    await resp.text();
  }

  async createTrigger(
    {abortSignal, ...params}: RequestConfig & s.CreateTriggerRequest,
  ): Promise<s.CreateTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      WorkflowName: params["WorkflowName"],
      Type: params["Type"],
      Schedule: params["Schedule"],
      Predicate: fromPredicate(params["Predicate"]),
      Actions: params["Actions"]?.map(x => fromAction(x)),
      Description: params["Description"],
      StartOnCreation: params["StartOnCreation"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async createUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & s.CreateUserDefinedFunctionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionInput: fromUserDefinedFunctionInput(params["FunctionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserDefinedFunction",
    });
    await resp.text();
  }

  async createWorkflow(
    {abortSignal, ...params}: RequestConfig & s.CreateWorkflowRequest,
  ): Promise<s.CreateWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      DefaultRunProperties: params["DefaultRunProperties"],
      Tags: params["Tags"],
      MaxConcurrentRuns: params["MaxConcurrentRuns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteClassifier(
    {abortSignal, ...params}: RequestConfig & s.DeleteClassifierRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteClassifier",
    });
    await resp.text();
  }

  async deleteColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & s.DeleteColumnStatisticsForPartitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnName: params["ColumnName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteColumnStatisticsForPartition",
    });
    await resp.text();
  }

  async deleteColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteColumnStatisticsForTableRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnName: params["ColumnName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteColumnStatisticsForTable",
    });
    await resp.text();
  }

  async deleteConnection(
    {abortSignal, ...params}: RequestConfig & s.DeleteConnectionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      ConnectionName: params["ConnectionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteConnection",
    });
    await resp.text();
  }

  async deleteCrawler(
    {abortSignal, ...params}: RequestConfig & s.DeleteCrawlerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCrawler",
    });
    await resp.text();
  }

  async deleteDatabase(
    {abortSignal, ...params}: RequestConfig & s.DeleteDatabaseRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatabase",
    });
    await resp.text();
  }

  async deleteDevEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteDevEndpointRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDevEndpoint",
    });
    await resp.text();
  }

  async deleteJob(
    {abortSignal, ...params}: RequestConfig & s.DeleteJobRequest,
  ): Promise<s.DeleteJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobName": "s",
      },
    }, await resp.json());
  }

  async deleteMLTransform(
    {abortSignal, ...params}: RequestConfig & s.DeleteMLTransformRequest,
  ): Promise<s.DeleteMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async deletePartition(
    {abortSignal, ...params}: RequestConfig & s.DeletePartitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePartition",
    });
    await resp.text();
  }

  async deletePartitionIndex(
    {abortSignal, ...params}: RequestConfig & s.DeletePartitionIndexRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      IndexName: params["IndexName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePartitionIndex",
    });
    await resp.text();
  }

  async deleteRegistry(
    {abortSignal, ...params}: RequestConfig & s.DeleteRegistryInput,
  ): Promise<s.DeleteRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistryStatus>(x),
      },
    }, await resp.json());
  }

  async deleteResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteResourcePolicyRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      PolicyHashCondition: params["PolicyHashCondition"],
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteResourcePolicy",
    });
    await resp.text();
  }

  async deleteSchema(
    {abortSignal, ...params}: RequestConfig & s.DeleteSchemaInput,
  ): Promise<s.DeleteSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
      },
    }, await resp.json());
  }

  async deleteSchemaVersions(
    {abortSignal, ...params}: RequestConfig & s.DeleteSchemaVersionsInput,
  ): Promise<s.DeleteSchemaVersionsResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      Versions: params["Versions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSchemaVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionErrors": [toSchemaVersionErrorItem],
      },
    }, await resp.json());
  }

  async deleteSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteSecurityConfigurationRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteSecurityConfiguration",
    });
    await resp.text();
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & s.DeleteTableRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
    await resp.text();
  }

  async deleteTableVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteTableVersionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionId: params["VersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTableVersion",
    });
    await resp.text();
  }

  async deleteTrigger(
    {abortSignal, ...params}: RequestConfig & s.DeleteTriggerRequest,
  ): Promise<s.DeleteTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async deleteUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserDefinedFunctionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserDefinedFunction",
    });
    await resp.text();
  }

  async deleteWorkflow(
    {abortSignal, ...params}: RequestConfig & s.DeleteWorkflowRequest,
  ): Promise<s.DeleteWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async getCatalogImportStatus(
    {abortSignal, ...params}: RequestConfig & s.GetCatalogImportStatusRequest = {},
  ): Promise<s.GetCatalogImportStatusResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCatalogImportStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImportStatus": toCatalogImportStatus,
      },
    }, await resp.json());
  }

  async getClassifier(
    {abortSignal, ...params}: RequestConfig & s.GetClassifierRequest,
  ): Promise<s.GetClassifierResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClassifier",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Classifier": toClassifier,
      },
    }, await resp.json());
  }

  async getClassifiers(
    {abortSignal, ...params}: RequestConfig & s.GetClassifiersRequest = {},
  ): Promise<s.GetClassifiersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClassifiers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Classifiers": [toClassifier],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & s.GetColumnStatisticsForPartitionRequest,
  ): Promise<s.GetColumnStatisticsForPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnNames: params["ColumnNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetColumnStatisticsForPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ColumnStatisticsList": [toColumnStatistics],
        "Errors": [toColumnError],
      },
    }, await resp.json());
  }

  async getColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & s.GetColumnStatisticsForTableRequest,
  ): Promise<s.GetColumnStatisticsForTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnNames: params["ColumnNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetColumnStatisticsForTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ColumnStatisticsList": [toColumnStatistics],
        "Errors": [toColumnError],
      },
    }, await resp.json());
  }

  async getConnection(
    {abortSignal, ...params}: RequestConfig & s.GetConnectionRequest,
  ): Promise<s.GetConnectionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      HidePassword: params["HidePassword"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConnection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Connection": toConnection,
      },
    }, await resp.json());
  }

  async getConnections(
    {abortSignal, ...params}: RequestConfig & s.GetConnectionsRequest = {},
  ): Promise<s.GetConnectionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Filter: fromGetConnectionsFilter(params["Filter"]),
      HidePassword: params["HidePassword"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetConnections",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ConnectionList": [toConnection],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getCrawler(
    {abortSignal, ...params}: RequestConfig & s.GetCrawlerRequest,
  ): Promise<s.GetCrawlerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawler",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawler": toCrawler,
      },
    }, await resp.json());
  }

  async getCrawlerMetrics(
    {abortSignal, ...params}: RequestConfig & s.GetCrawlerMetricsRequest = {},
  ): Promise<s.GetCrawlerMetricsResponse> {
    const body: jsonP.JSONObject = {
      CrawlerNameList: params["CrawlerNameList"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawlerMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrawlerMetricsList": [toCrawlerMetrics],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getCrawlers(
    {abortSignal, ...params}: RequestConfig & s.GetCrawlersRequest = {},
  ): Promise<s.GetCrawlersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Crawlers": [toCrawler],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDataCatalogEncryptionSettings(
    {abortSignal, ...params}: RequestConfig & s.GetDataCatalogEncryptionSettingsRequest = {},
  ): Promise<s.GetDataCatalogEncryptionSettingsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataCatalogEncryptionSettings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DataCatalogEncryptionSettings": toDataCatalogEncryptionSettings,
      },
    }, await resp.json());
  }

  async getDatabase(
    {abortSignal, ...params}: RequestConfig & s.GetDatabaseRequest,
  ): Promise<s.GetDatabaseResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Database": toDatabase,
      },
    }, await resp.json());
  }

  async getDatabases(
    {abortSignal, ...params}: RequestConfig & s.GetDatabasesRequest = {},
  ): Promise<s.GetDatabasesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ResourceShareType: params["ResourceShareType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDatabases",
    });
    return jsonP.readObj({
      required: {
        "DatabaseList": [toDatabase],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getDataflowGraph(
    {abortSignal, ...params}: RequestConfig & s.GetDataflowGraphRequest = {},
  ): Promise<s.GetDataflowGraphResponse> {
    const body: jsonP.JSONObject = {
      PythonScript: params["PythonScript"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDataflowGraph",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DagNodes": [toCodeGenNode],
        "DagEdges": [toCodeGenEdge],
      },
    }, await resp.json());
  }

  async getDevEndpoint(
    {abortSignal, ...params}: RequestConfig & s.GetDevEndpointRequest,
  ): Promise<s.GetDevEndpointResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDevEndpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoint": toDevEndpoint,
      },
    }, await resp.json());
  }

  async getDevEndpoints(
    {abortSignal, ...params}: RequestConfig & s.GetDevEndpointsRequest = {},
  ): Promise<s.GetDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpoints": [toDevEndpoint],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getJob(
    {abortSignal, ...params}: RequestConfig & s.GetJobRequest,
  ): Promise<s.GetJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Job": toJob,
      },
    }, await resp.json());
  }

  async getJobBookmark(
    {abortSignal, ...params}: RequestConfig & s.GetJobBookmarkRequest,
  ): Promise<s.GetJobBookmarkResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobBookmark",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobBookmarkEntry": toJobBookmarkEntry,
      },
    }, await resp.json());
  }

  async getJobRun(
    {abortSignal, ...params}: RequestConfig & s.GetJobRunRequest,
  ): Promise<s.GetJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
      PredecessorsIncluded: params["PredecessorsIncluded"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRun": toJobRun,
      },
    }, await resp.json());
  }

  async getJobRuns(
    {abortSignal, ...params}: RequestConfig & s.GetJobRunsRequest,
  ): Promise<s.GetJobRunsResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRuns": [toJobRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getJobs(
    {abortSignal, ...params}: RequestConfig & s.GetJobsRequest = {},
  ): Promise<s.GetJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Jobs": [toJob],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMLTaskRun(
    {abortSignal, ...params}: RequestConfig & s.GetMLTaskRunRequest,
  ): Promise<s.GetMLTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      TaskRunId: params["TaskRunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "TaskRunId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskStatusType>(x),
        "LogGroupName": "s",
        "Properties": toTaskRunProperties,
        "ErrorString": "s",
        "StartedOn": "d",
        "LastModifiedOn": "d",
        "CompletedOn": "d",
        "ExecutionTime": "n",
      },
    }, await resp.json());
  }

  async getMLTaskRuns(
    {abortSignal, ...params}: RequestConfig & s.GetMLTaskRunsRequest,
  ): Promise<s.GetMLTaskRunsResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTaskRunFilterCriteria(params["Filter"]),
      Sort: fromTaskRunSortCriteria(params["Sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTaskRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRuns": [toTaskRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMLTransform(
    {abortSignal, ...params}: RequestConfig & s.GetMLTransformRequest,
  ): Promise<s.GetMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
        "Name": "s",
        "Description": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformStatusType>(x),
        "CreatedOn": "d",
        "LastModifiedOn": "d",
        "InputRecordTables": [toGlueTable],
        "Parameters": toTransformParameters,
        "EvaluationMetrics": toEvaluationMetrics,
        "LabelCount": "n",
        "Schema": [toSchemaColumn],
        "Role": "s",
        "GlueVersion": "s",
        "MaxCapacity": "n",
        "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
        "NumberOfWorkers": "n",
        "Timeout": "n",
        "MaxRetries": "n",
        "TransformEncryption": toTransformEncryption,
      },
    }, await resp.json());
  }

  async getMLTransforms(
    {abortSignal, ...params}: RequestConfig & s.GetMLTransformsRequest = {},
  ): Promise<s.GetMLTransformsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTransformFilterCriteria(params["Filter"]),
      Sort: fromTransformSortCriteria(params["Sort"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMLTransforms",
    });
    return jsonP.readObj({
      required: {
        "Transforms": [toMLTransform],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getMapping(
    {abortSignal, ...params}: RequestConfig & s.GetMappingRequest,
  ): Promise<s.GetMappingResponse> {
    const body: jsonP.JSONObject = {
      Source: fromCatalogEntry(params["Source"]),
      Sinks: params["Sinks"]?.map(x => fromCatalogEntry(x)),
      Location: fromLocation(params["Location"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMapping",
    });
    return jsonP.readObj({
      required: {
        "Mapping": [toMappingEntry],
      },
      optional: {},
    }, await resp.json());
  }

  async getPartition(
    {abortSignal, ...params}: RequestConfig & s.GetPartitionRequest,
  ): Promise<s.GetPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partition": toPartition,
      },
    }, await resp.json());
  }

  async getPartitionIndexes(
    {abortSignal, ...params}: RequestConfig & s.GetPartitionIndexesRequest,
  ): Promise<s.GetPartitionIndexesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartitionIndexes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PartitionIndexDescriptorList": [toPartitionIndexDescriptor],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getPartitions(
    {abortSignal, ...params}: RequestConfig & s.GetPartitionsRequest,
  ): Promise<s.GetPartitionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      Expression: params["Expression"],
      NextToken: params["NextToken"],
      Segment: fromSegment(params["Segment"]),
      MaxResults: params["MaxResults"],
      ExcludeColumnSchema: params["ExcludeColumnSchema"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPartitions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Partitions": [toPartition],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getPlan(
    {abortSignal, ...params}: RequestConfig & s.GetPlanRequest,
  ): Promise<s.GetPlanResponse> {
    const body: jsonP.JSONObject = {
      Mapping: params["Mapping"]?.map(x => fromMappingEntry(x)),
      Source: fromCatalogEntry(params["Source"]),
      Sinks: params["Sinks"]?.map(x => fromCatalogEntry(x)),
      Location: fromLocation(params["Location"]),
      Language: params["Language"],
      AdditionalPlanOptionsMap: params["AdditionalPlanOptionsMap"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPlan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PythonScript": "s",
        "ScalaCode": "s",
      },
    }, await resp.json());
  }

  async getRegistry(
    {abortSignal, ...params}: RequestConfig & s.GetRegistryInput,
  ): Promise<s.GetRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "Description": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistryStatus>(x),
        "CreatedTime": "s",
        "UpdatedTime": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicies(
    {abortSignal, ...params}: RequestConfig & s.GetResourcePoliciesRequest = {},
  ): Promise<s.GetResourcePoliciesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "GetResourcePoliciesResponseList": [toGluePolicy],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetResourcePolicyRequest = {},
  ): Promise<s.GetResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyInJson": "s",
        "PolicyHash": "s",
        "CreateTime": "d",
        "UpdateTime": "d",
      },
    }, await resp.json());
  }

  async getSchema(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaInput,
  ): Promise<s.GetSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
        "SchemaName": "s",
        "SchemaArn": "s",
        "Description": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataFormat>(x),
        "Compatibility": (x: jsonP.JSONValue) => cmnP.readEnum<s.Compatibility>(x),
        "SchemaCheckpoint": "n",
        "LatestSchemaVersion": "n",
        "NextSchemaVersion": "n",
        "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
        "CreatedTime": "s",
        "UpdatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaByDefinition(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaByDefinitionInput,
  ): Promise<s.GetSchemaByDefinitionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaByDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "SchemaArn": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataFormat>(x),
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaVersionStatus>(x),
        "CreatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaVersion(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaVersionInput = {},
  ): Promise<s.GetSchemaVersionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionId: params["SchemaVersionId"],
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "SchemaDefinition": "s",
        "DataFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataFormat>(x),
        "SchemaArn": "s",
        "VersionNumber": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaVersionStatus>(x),
        "CreatedTime": "s",
      },
    }, await resp.json());
  }

  async getSchemaVersionsDiff(
    {abortSignal, ...params}: RequestConfig & s.GetSchemaVersionsDiffInput,
  ): Promise<s.GetSchemaVersionsDiffResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      FirstSchemaVersionNumber: fromSchemaVersionNumber(params["FirstSchemaVersionNumber"]),
      SecondSchemaVersionNumber: fromSchemaVersionNumber(params["SecondSchemaVersionNumber"]),
      SchemaDiffType: params["SchemaDiffType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSchemaVersionsDiff",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Diff": "s",
      },
    }, await resp.json());
  }

  async getSecurityConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetSecurityConfigurationRequest,
  ): Promise<s.GetSecurityConfigurationResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecurityConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfiguration": toSecurityConfiguration,
      },
    }, await resp.json());
  }

  async getSecurityConfigurations(
    {abortSignal, ...params}: RequestConfig & s.GetSecurityConfigurationsRequest = {},
  ): Promise<s.GetSecurityConfigurationsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSecurityConfigurations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SecurityConfigurations": [toSecurityConfiguration],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTable(
    {abortSignal, ...params}: RequestConfig & s.GetTableRequest,
  ): Promise<s.GetTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTable,
      },
    }, await resp.json());
  }

  async getTableVersion(
    {abortSignal, ...params}: RequestConfig & s.GetTableVersionRequest,
  ): Promise<s.GetTableVersionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      VersionId: params["VersionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTableVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableVersion": toTableVersion,
      },
    }, await resp.json());
  }

  async getTableVersions(
    {abortSignal, ...params}: RequestConfig & s.GetTableVersionsRequest,
  ): Promise<s.GetTableVersionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTableVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableVersions": [toTableVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTables(
    {abortSignal, ...params}: RequestConfig & s.GetTablesRequest,
  ): Promise<s.GetTablesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Expression: params["Expression"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TableList": [toTable],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getTags(
    {abortSignal, ...params}: RequestConfig & s.GetTagsRequest,
  ): Promise<s.GetTagsResponse> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getTrigger(
    {abortSignal, ...params}: RequestConfig & s.GetTriggerRequest,
  ): Promise<s.GetTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Trigger": toTrigger,
      },
    }, await resp.json());
  }

  async getTriggers(
    {abortSignal, ...params}: RequestConfig & s.GetTriggersRequest = {},
  ): Promise<s.GetTriggersResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      DependentJobName: params["DependentJobName"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Triggers": [toTrigger],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & s.GetUserDefinedFunctionRequest,
  ): Promise<s.GetUserDefinedFunctionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserDefinedFunction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserDefinedFunction": toUserDefinedFunction,
      },
    }, await resp.json());
  }

  async getUserDefinedFunctions(
    {abortSignal, ...params}: RequestConfig & s.GetUserDefinedFunctionsRequest,
  ): Promise<s.GetUserDefinedFunctionsResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      Pattern: params["Pattern"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetUserDefinedFunctions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserDefinedFunctions": [toUserDefinedFunction],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getWorkflow(
    {abortSignal, ...params}: RequestConfig & s.GetWorkflowRequest,
  ): Promise<s.GetWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflow": toWorkflow,
      },
    }, await resp.json());
  }

  async getWorkflowRun(
    {abortSignal, ...params}: RequestConfig & s.GetWorkflowRunRequest,
  ): Promise<s.GetWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      IncludeGraph: params["IncludeGraph"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Run": toWorkflowRun,
      },
    }, await resp.json());
  }

  async getWorkflowRunProperties(
    {abortSignal, ...params}: RequestConfig & s.GetWorkflowRunPropertiesRequest,
  ): Promise<s.GetWorkflowRunPropertiesResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRunProperties",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunProperties": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async getWorkflowRuns(
    {abortSignal, ...params}: RequestConfig & s.GetWorkflowRunsRequest,
  ): Promise<s.GetWorkflowRunsResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      IncludeGraph: params["IncludeGraph"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetWorkflowRuns",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Runs": [toWorkflowRun],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async importCatalogToGlue(
    {abortSignal, ...params}: RequestConfig & s.ImportCatalogToGlueRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ImportCatalogToGlue",
    });
    await resp.text();
  }

  async listCrawlers(
    {abortSignal, ...params}: RequestConfig & s.ListCrawlersRequest = {},
  ): Promise<s.ListCrawlersResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCrawlers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CrawlerNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDevEndpoints(
    {abortSignal, ...params}: RequestConfig & s.ListDevEndpointsRequest = {},
  ): Promise<s.ListDevEndpointsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevEndpoints",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DevEndpointNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listJobs(
    {abortSignal, ...params}: RequestConfig & s.ListJobsRequest = {},
  ): Promise<s.ListJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMLTransforms(
    {abortSignal, ...params}: RequestConfig & s.ListMLTransformsRequest = {},
  ): Promise<s.ListMLTransformsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      Filter: fromTransformFilterCriteria(params["Filter"]),
      Sort: fromTransformSortCriteria(params["Sort"]),
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMLTransforms",
    });
    return jsonP.readObj({
      required: {
        "TransformIds": ["s"],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listRegistries(
    {abortSignal, ...params}: RequestConfig & s.ListRegistriesInput = {},
  ): Promise<s.ListRegistriesResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListRegistries",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Registries": [toRegistryListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemaVersions(
    {abortSignal, ...params}: RequestConfig & s.ListSchemaVersionsInput,
  ): Promise<s.ListSchemaVersionsResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemaVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Schemas": [toSchemaVersionListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSchemas(
    {abortSignal, ...params}: RequestConfig & s.ListSchemasInput = {},
  ): Promise<s.ListSchemasResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSchemas",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Schemas": [toSchemaListItem],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTriggers(
    {abortSignal, ...params}: RequestConfig & s.ListTriggersRequest = {},
  ): Promise<s.ListTriggersResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      DependentJobName: params["DependentJobName"],
      MaxResults: params["MaxResults"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTriggers",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TriggerNames": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkflows(
    {abortSignal, ...params}: RequestConfig & s.ListWorkflowsRequest = {},
  ): Promise<s.ListWorkflowsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkflows",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Workflows": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putDataCatalogEncryptionSettings(
    {abortSignal, ...params}: RequestConfig & s.PutDataCatalogEncryptionSettingsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DataCatalogEncryptionSettings: fromDataCatalogEncryptionSettings(params["DataCatalogEncryptionSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDataCatalogEncryptionSettings",
    });
    await resp.text();
  }

  async putResourcePolicy(
    {abortSignal, ...params}: RequestConfig & s.PutResourcePolicyRequest,
  ): Promise<s.PutResourcePolicyResponse> {
    const body: jsonP.JSONObject = {
      PolicyInJson: params["PolicyInJson"],
      ResourceArn: params["ResourceArn"],
      PolicyHashCondition: params["PolicyHashCondition"],
      PolicyExistsCondition: params["PolicyExistsCondition"],
      EnableHybrid: params["EnableHybrid"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutResourcePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PolicyHash": "s",
      },
    }, await resp.json());
  }

  async putSchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & s.PutSchemaVersionMetadataInput,
  ): Promise<s.PutSchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataKeyValue: fromMetadataKeyValuePair(params["MetadataKeyValue"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutSchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
        "LatestVersion": "b",
        "VersionNumber": "n",
        "SchemaVersionId": "s",
        "MetadataKey": "s",
        "MetadataValue": "s",
      },
    }, await resp.json());
  }

  async putWorkflowRunProperties(
    {abortSignal, ...params}: RequestConfig & s.PutWorkflowRunPropertiesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      RunProperties: params["RunProperties"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutWorkflowRunProperties",
    });
    await resp.text();
  }

  async querySchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & s.QuerySchemaVersionMetadataInput = {},
  ): Promise<s.QuerySchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataList: params["MetadataList"]?.map(x => fromMetadataKeyValuePair(x)),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "QuerySchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MetadataInfoMap": x => jsonP.readMap(String, toMetadataInfo, x),
        "SchemaVersionId": "s",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async registerSchemaVersion(
    {abortSignal, ...params}: RequestConfig & s.RegisterSchemaVersionInput,
  ): Promise<s.RegisterSchemaVersionResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaDefinition: params["SchemaDefinition"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterSchemaVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaVersionId": "s",
        "VersionNumber": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaVersionStatus>(x),
      },
    }, await resp.json());
  }

  async removeSchemaVersionMetadata(
    {abortSignal, ...params}: RequestConfig & s.RemoveSchemaVersionMetadataInput,
  ): Promise<s.RemoveSchemaVersionMetadataResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      SchemaVersionId: params["SchemaVersionId"],
      MetadataKeyValue: fromMetadataKeyValuePair(params["MetadataKeyValue"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveSchemaVersionMetadata",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
        "LatestVersion": "b",
        "VersionNumber": "n",
        "SchemaVersionId": "s",
        "MetadataKey": "s",
        "MetadataValue": "s",
      },
    }, await resp.json());
  }

  async resetJobBookmark(
    {abortSignal, ...params}: RequestConfig & s.ResetJobBookmarkRequest,
  ): Promise<s.ResetJobBookmarkResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResetJobBookmark",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobBookmarkEntry": toJobBookmarkEntry,
      },
    }, await resp.json());
  }

  async resumeWorkflowRun(
    {abortSignal, ...params}: RequestConfig & s.ResumeWorkflowRunRequest,
  ): Promise<s.ResumeWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
      NodeIds: params["NodeIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ResumeWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunId": "s",
        "NodeIds": ["s"],
      },
    }, await resp.json());
  }

  async searchTables(
    {abortSignal, ...params}: RequestConfig & s.SearchTablesRequest = {},
  ): Promise<s.SearchTablesResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      NextToken: params["NextToken"],
      Filters: params["Filters"]?.map(x => fromPropertyPredicate(x)),
      SearchText: params["SearchText"],
      SortCriteria: params["SortCriteria"]?.map(x => fromSortCriterion(x)),
      MaxResults: params["MaxResults"],
      ResourceShareType: params["ResourceShareType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SearchTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "TableList": [toTable],
      },
    }, await resp.json());
  }

  async startCrawler(
    {abortSignal, ...params}: RequestConfig & s.StartCrawlerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartCrawler",
    });
    await resp.text();
  }

  async startCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & s.StartCrawlerScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartCrawlerSchedule",
    });
    await resp.text();
  }

  async startExportLabelsTaskRun(
    {abortSignal, ...params}: RequestConfig & s.StartExportLabelsTaskRunRequest,
  ): Promise<s.StartExportLabelsTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      OutputS3Path: params["OutputS3Path"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartExportLabelsTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startImportLabelsTaskRun(
    {abortSignal, ...params}: RequestConfig & s.StartImportLabelsTaskRunRequest,
  ): Promise<s.StartImportLabelsTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      InputS3Path: params["InputS3Path"],
      ReplaceAllLabels: params["ReplaceAllLabels"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartImportLabelsTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startJobRun(
    {abortSignal, ...params}: RequestConfig & s.StartJobRunRequest,
  ): Promise<s.StartJobRunResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobRunId: params["JobRunId"],
      Arguments: params["Arguments"],
      AllocatedCapacity: params["AllocatedCapacity"],
      Timeout: params["Timeout"],
      MaxCapacity: params["MaxCapacity"],
      SecurityConfiguration: params["SecurityConfiguration"],
      NotificationProperty: fromNotificationProperty(params["NotificationProperty"]),
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartJobRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobRunId": "s",
      },
    }, await resp.json());
  }

  async startMLEvaluationTaskRun(
    {abortSignal, ...params}: RequestConfig & s.StartMLEvaluationTaskRunRequest,
  ): Promise<s.StartMLEvaluationTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMLEvaluationTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startMLLabelingSetGenerationTaskRun(
    {abortSignal, ...params}: RequestConfig & s.StartMLLabelingSetGenerationTaskRunRequest,
  ): Promise<s.StartMLLabelingSetGenerationTaskRunResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      OutputS3Path: params["OutputS3Path"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMLLabelingSetGenerationTaskRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskRunId": "s",
      },
    }, await resp.json());
  }

  async startTrigger(
    {abortSignal, ...params}: RequestConfig & s.StartTriggerRequest,
  ): Promise<s.StartTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async startWorkflowRun(
    {abortSignal, ...params}: RequestConfig & s.StartWorkflowRunRequest,
  ): Promise<s.StartWorkflowRunResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartWorkflowRun",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RunId": "s",
      },
    }, await resp.json());
  }

  async stopCrawler(
    {abortSignal, ...params}: RequestConfig & s.StopCrawlerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCrawler",
    });
    await resp.text();
  }

  async stopCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & s.StopCrawlerScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCrawlerSchedule",
    });
    await resp.text();
  }

  async stopTrigger(
    {abortSignal, ...params}: RequestConfig & s.StopTriggerRequest,
  ): Promise<s.StopTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

  async stopWorkflowRun(
    {abortSignal, ...params}: RequestConfig & s.StopWorkflowRunRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      RunId: params["RunId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopWorkflowRun",
    });
    await resp.text();
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagsToAdd: params["TagsToAdd"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    await resp.text();
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagsToRemove: params["TagsToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    await resp.text();
  }

  async updateClassifier(
    {abortSignal, ...params}: RequestConfig & s.UpdateClassifierRequest = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      GrokClassifier: fromUpdateGrokClassifierRequest(params["GrokClassifier"]),
      XMLClassifier: fromUpdateXMLClassifierRequest(params["XMLClassifier"]),
      JsonClassifier: fromUpdateJsonClassifierRequest(params["JsonClassifier"]),
      CsvClassifier: fromUpdateCsvClassifierRequest(params["CsvClassifier"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateClassifier",
    });
    await resp.text();
  }

  async updateColumnStatisticsForPartition(
    {abortSignal, ...params}: RequestConfig & s.UpdateColumnStatisticsForPartitionRequest,
  ): Promise<s.UpdateColumnStatisticsForPartitionResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValues: params["PartitionValues"],
      ColumnStatisticsList: params["ColumnStatisticsList"]?.map(x => fromColumnStatistics(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateColumnStatisticsForPartition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toColumnStatisticsError],
      },
    }, await resp.json());
  }

  async updateColumnStatisticsForTable(
    {abortSignal, ...params}: RequestConfig & s.UpdateColumnStatisticsForTableRequest,
  ): Promise<s.UpdateColumnStatisticsForTableResponse> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      ColumnStatisticsList: params["ColumnStatisticsList"]?.map(x => fromColumnStatistics(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateColumnStatisticsForTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Errors": [toColumnStatisticsError],
      },
    }, await resp.json());
  }

  async updateConnection(
    {abortSignal, ...params}: RequestConfig & s.UpdateConnectionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      ConnectionInput: fromConnectionInput(params["ConnectionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateConnection",
    });
    await resp.text();
  }

  async updateCrawler(
    {abortSignal, ...params}: RequestConfig & s.UpdateCrawlerRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Role: params["Role"],
      DatabaseName: params["DatabaseName"],
      Description: params["Description"],
      Targets: fromCrawlerTargets(params["Targets"]),
      Schedule: params["Schedule"],
      Classifiers: params["Classifiers"],
      TablePrefix: params["TablePrefix"],
      SchemaChangePolicy: fromSchemaChangePolicy(params["SchemaChangePolicy"]),
      RecrawlPolicy: fromRecrawlPolicy(params["RecrawlPolicy"]),
      LineageConfiguration: fromLineageConfiguration(params["LineageConfiguration"]),
      Configuration: params["Configuration"],
      CrawlerSecurityConfiguration: params["CrawlerSecurityConfiguration"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCrawler",
    });
    await resp.text();
  }

  async updateCrawlerSchedule(
    {abortSignal, ...params}: RequestConfig & s.UpdateCrawlerScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CrawlerName: params["CrawlerName"],
      Schedule: params["Schedule"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCrawlerSchedule",
    });
    await resp.text();
  }

  async updateDatabase(
    {abortSignal, ...params}: RequestConfig & s.UpdateDatabaseRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      Name: params["Name"],
      DatabaseInput: fromDatabaseInput(params["DatabaseInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatabase",
    });
    await resp.text();
  }

  async updateDevEndpoint(
    {abortSignal, ...params}: RequestConfig & s.UpdateDevEndpointRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      PublicKey: params["PublicKey"],
      AddPublicKeys: params["AddPublicKeys"],
      DeletePublicKeys: params["DeletePublicKeys"],
      CustomLibraries: fromDevEndpointCustomLibraries(params["CustomLibraries"]),
      UpdateEtlLibraries: params["UpdateEtlLibraries"],
      DeleteArguments: params["DeleteArguments"],
      AddArguments: params["AddArguments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDevEndpoint",
    });
    await resp.text();
  }

  async updateJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateJobRequest,
  ): Promise<s.UpdateJobResponse> {
    const body: jsonP.JSONObject = {
      JobName: params["JobName"],
      JobUpdate: fromJobUpdate(params["JobUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJob",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobName": "s",
      },
    }, await resp.json());
  }

  async updateMLTransform(
    {abortSignal, ...params}: RequestConfig & s.UpdateMLTransformRequest,
  ): Promise<s.UpdateMLTransformResponse> {
    const body: jsonP.JSONObject = {
      TransformId: params["TransformId"],
      Name: params["Name"],
      Description: params["Description"],
      Parameters: fromTransformParameters(params["Parameters"]),
      Role: params["Role"],
      GlueVersion: params["GlueVersion"],
      MaxCapacity: params["MaxCapacity"],
      WorkerType: params["WorkerType"],
      NumberOfWorkers: params["NumberOfWorkers"],
      Timeout: params["Timeout"],
      MaxRetries: params["MaxRetries"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMLTransform",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TransformId": "s",
      },
    }, await resp.json());
  }

  async updatePartition(
    {abortSignal, ...params}: RequestConfig & s.UpdatePartitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      PartitionValueList: params["PartitionValueList"],
      PartitionInput: fromPartitionInput(params["PartitionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePartition",
    });
    await resp.text();
  }

  async updateRegistry(
    {abortSignal, ...params}: RequestConfig & s.UpdateRegistryInput,
  ): Promise<s.UpdateRegistryResponse> {
    const body: jsonP.JSONObject = {
      RegistryId: fromRegistryId(params["RegistryId"]),
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RegistryName": "s",
        "RegistryArn": "s",
      },
    }, await resp.json());
  }

  async updateSchema(
    {abortSignal, ...params}: RequestConfig & s.UpdateSchemaInput,
  ): Promise<s.UpdateSchemaResponse> {
    const body: jsonP.JSONObject = {
      SchemaId: fromSchemaId(params["SchemaId"]),
      SchemaVersionNumber: fromSchemaVersionNumber(params["SchemaVersionNumber"]),
      Compatibility: params["Compatibility"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSchema",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SchemaArn": "s",
        "SchemaName": "s",
        "RegistryName": "s",
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & s.UpdateTableRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      TableInput: fromTableInput(params["TableInput"]),
      SkipArchive: params["SkipArchive"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    await resp.text();
  }

  async updateTrigger(
    {abortSignal, ...params}: RequestConfig & s.UpdateTriggerRequest,
  ): Promise<s.UpdateTriggerResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      TriggerUpdate: fromTriggerUpdate(params["TriggerUpdate"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrigger",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Trigger": toTrigger,
      },
    }, await resp.json());
  }

  async updateUserDefinedFunction(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserDefinedFunctionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CatalogId: params["CatalogId"],
      DatabaseName: params["DatabaseName"],
      FunctionName: params["FunctionName"],
      FunctionInput: fromUserDefinedFunctionInput(params["FunctionInput"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserDefinedFunction",
    });
    await resp.text();
  }

  async updateWorkflow(
    {abortSignal, ...params}: RequestConfig & s.UpdateWorkflowRequest,
  ): Promise<s.UpdateWorkflowResponse> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      Description: params["Description"],
      DefaultRunProperties: params["DefaultRunProperties"],
      MaxConcurrentRuns: params["MaxConcurrentRuns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkflow",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Name": "s",
      },
    }, await resp.json());
  }

}

function fromPartitionInput(input?: s.PartitionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
    LastAccessTime: jsonP.serializeDate_unixTimestamp(input["LastAccessTime"]),
    StorageDescriptor: fromStorageDescriptor(input["StorageDescriptor"]),
    Parameters: input["Parameters"],
    LastAnalyzedTime: jsonP.serializeDate_unixTimestamp(input["LastAnalyzedTime"]),
  }
}

function fromStorageDescriptor(input?: s.StorageDescriptor | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Columns: input["Columns"]?.map(x => fromColumn(x)),
    Location: input["Location"],
    InputFormat: input["InputFormat"],
    OutputFormat: input["OutputFormat"],
    Compressed: input["Compressed"],
    NumberOfBuckets: input["NumberOfBuckets"],
    SerdeInfo: fromSerDeInfo(input["SerdeInfo"]),
    BucketColumns: input["BucketColumns"],
    SortColumns: input["SortColumns"]?.map(x => fromOrder(x)),
    Parameters: input["Parameters"],
    SkewedInfo: fromSkewedInfo(input["SkewedInfo"]),
    StoredAsSubDirectories: input["StoredAsSubDirectories"],
    SchemaReference: fromSchemaReference(input["SchemaReference"]),
  }
}
function toStorageDescriptor(root: jsonP.JSONValue): s.StorageDescriptor {
  return jsonP.readObj({
    required: {},
    optional: {
      "Columns": [toColumn],
      "Location": "s",
      "InputFormat": "s",
      "OutputFormat": "s",
      "Compressed": "b",
      "NumberOfBuckets": "n",
      "SerdeInfo": toSerDeInfo,
      "BucketColumns": ["s"],
      "SortColumns": [toOrder],
      "Parameters": x => jsonP.readMap(String, String, x),
      "SkewedInfo": toSkewedInfo,
      "StoredAsSubDirectories": "b",
      "SchemaReference": toSchemaReference,
    },
  }, root);
}

function fromColumn(input?: s.Column | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Type: input["Type"],
    Comment: input["Comment"],
    Parameters: input["Parameters"],
  }
}
function toColumn(root: jsonP.JSONValue): s.Column {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Type": "s",
      "Comment": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromSerDeInfo(input?: s.SerDeInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    SerializationLibrary: input["SerializationLibrary"],
    Parameters: input["Parameters"],
  }
}
function toSerDeInfo(root: jsonP.JSONValue): s.SerDeInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "SerializationLibrary": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromOrder(input?: s.Order | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortOrder: input["SortOrder"],
  }
}
function toOrder(root: jsonP.JSONValue): s.Order {
  return jsonP.readObj({
    required: {
      "Column": "s",
      "SortOrder": "n",
    },
    optional: {},
  }, root);
}

function fromSkewedInfo(input?: s.SkewedInfo | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SkewedColumnNames: input["SkewedColumnNames"],
    SkewedColumnValues: input["SkewedColumnValues"],
    SkewedColumnValueLocationMaps: input["SkewedColumnValueLocationMaps"],
  }
}
function toSkewedInfo(root: jsonP.JSONValue): s.SkewedInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "SkewedColumnNames": ["s"],
      "SkewedColumnValues": ["s"],
      "SkewedColumnValueLocationMaps": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromSchemaReference(input?: s.SchemaReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaId: fromSchemaId(input["SchemaId"]),
    SchemaVersionId: input["SchemaVersionId"],
    SchemaVersionNumber: input["SchemaVersionNumber"],
  }
}
function toSchemaReference(root: jsonP.JSONValue): s.SchemaReference {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaId": toSchemaId,
      "SchemaVersionId": "s",
      "SchemaVersionNumber": "n",
    },
  }, root);
}

function fromSchemaId(input?: s.SchemaId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SchemaArn: input["SchemaArn"],
    SchemaName: input["SchemaName"],
    RegistryName: input["RegistryName"],
  }
}
function toSchemaId(root: jsonP.JSONValue): s.SchemaId {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "SchemaName": "s",
      "RegistryName": "s",
    },
  }, root);
}

function fromPartitionValueList(input?: s.PartitionValueList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
  }
}
function toPartitionValueList(root: jsonP.JSONValue): s.PartitionValueList {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

function fromBatchUpdatePartitionRequestEntry(input?: s.BatchUpdatePartitionRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PartitionValueList: input["PartitionValueList"],
    PartitionInput: fromPartitionInput(input["PartitionInput"]),
  }
}

function fromCreateGrokClassifierRequest(input?: s.CreateGrokClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Name: input["Name"],
    GrokPattern: input["GrokPattern"],
    CustomPatterns: input["CustomPatterns"],
  }
}

function fromCreateXMLClassifierRequest(input?: s.CreateXMLClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Classification: input["Classification"],
    Name: input["Name"],
    RowTag: input["RowTag"],
  }
}

function fromCreateJsonClassifierRequest(input?: s.CreateJsonClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    JsonPath: input["JsonPath"],
  }
}

function fromCreateCsvClassifierRequest(input?: s.CreateCsvClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Delimiter: input["Delimiter"],
    QuoteSymbol: input["QuoteSymbol"],
    ContainsHeader: input["ContainsHeader"],
    Header: input["Header"],
    DisableValueTrimming: input["DisableValueTrimming"],
    AllowSingleColumn: input["AllowSingleColumn"],
  }
}

function fromConnectionInput(input?: s.ConnectionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    ConnectionType: input["ConnectionType"],
    MatchCriteria: input["MatchCriteria"],
    ConnectionProperties: input["ConnectionProperties"],
    PhysicalConnectionRequirements: fromPhysicalConnectionRequirements(input["PhysicalConnectionRequirements"]),
  }
}

function fromPhysicalConnectionRequirements(input?: s.PhysicalConnectionRequirements | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetId: input["SubnetId"],
    SecurityGroupIdList: input["SecurityGroupIdList"],
    AvailabilityZone: input["AvailabilityZone"],
  }
}
function toPhysicalConnectionRequirements(root: jsonP.JSONValue): s.PhysicalConnectionRequirements {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetId": "s",
      "SecurityGroupIdList": ["s"],
      "AvailabilityZone": "s",
    },
  }, root);
}

function fromCrawlerTargets(input?: s.CrawlerTargets | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Targets: input["S3Targets"]?.map(x => fromS3Target(x)),
    JdbcTargets: input["JdbcTargets"]?.map(x => fromJdbcTarget(x)),
    MongoDBTargets: input["MongoDBTargets"]?.map(x => fromMongoDBTarget(x)),
    DynamoDBTargets: input["DynamoDBTargets"]?.map(x => fromDynamoDBTarget(x)),
    CatalogTargets: input["CatalogTargets"]?.map(x => fromCatalogTarget(x)),
  }
}
function toCrawlerTargets(root: jsonP.JSONValue): s.CrawlerTargets {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Targets": [toS3Target],
      "JdbcTargets": [toJdbcTarget],
      "MongoDBTargets": [toMongoDBTarget],
      "DynamoDBTargets": [toDynamoDBTarget],
      "CatalogTargets": [toCatalogTarget],
    },
  }, root);
}

function fromS3Target(input?: s.S3Target | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    Exclusions: input["Exclusions"],
    ConnectionName: input["ConnectionName"],
  }
}
function toS3Target(root: jsonP.JSONValue): s.S3Target {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "Exclusions": ["s"],
      "ConnectionName": "s",
    },
  }, root);
}

function fromJdbcTarget(input?: s.JdbcTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectionName: input["ConnectionName"],
    Path: input["Path"],
    Exclusions: input["Exclusions"],
  }
}
function toJdbcTarget(root: jsonP.JSONValue): s.JdbcTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionName": "s",
      "Path": "s",
      "Exclusions": ["s"],
    },
  }, root);
}

function fromMongoDBTarget(input?: s.MongoDBTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConnectionName: input["ConnectionName"],
    Path: input["Path"],
    ScanAll: input["ScanAll"],
  }
}
function toMongoDBTarget(root: jsonP.JSONValue): s.MongoDBTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConnectionName": "s",
      "Path": "s",
      "ScanAll": "b",
    },
  }, root);
}

function fromDynamoDBTarget(input?: s.DynamoDBTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Path: input["Path"],
    scanAll: input["scanAll"],
    scanRate: input["scanRate"],
  }
}
function toDynamoDBTarget(root: jsonP.JSONValue): s.DynamoDBTarget {
  return jsonP.readObj({
    required: {},
    optional: {
      "Path": "s",
      "scanAll": "b",
      "scanRate": "n",
    },
  }, root);
}

function fromCatalogTarget(input?: s.CatalogTarget | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    Tables: input["Tables"],
  }
}
function toCatalogTarget(root: jsonP.JSONValue): s.CatalogTarget {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "Tables": ["s"],
    },
    optional: {},
  }, root);
}

function fromSchemaChangePolicy(input?: s.SchemaChangePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UpdateBehavior: input["UpdateBehavior"],
    DeleteBehavior: input["DeleteBehavior"],
  }
}
function toSchemaChangePolicy(root: jsonP.JSONValue): s.SchemaChangePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "UpdateBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.UpdateBehavior>(x),
      "DeleteBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeleteBehavior>(x),
    },
  }, root);
}

function fromRecrawlPolicy(input?: s.RecrawlPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RecrawlBehavior: input["RecrawlBehavior"],
  }
}
function toRecrawlPolicy(root: jsonP.JSONValue): s.RecrawlPolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "RecrawlBehavior": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecrawlBehavior>(x),
    },
  }, root);
}

function fromLineageConfiguration(input?: s.LineageConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CrawlerLineageSettings: input["CrawlerLineageSettings"],
  }
}
function toLineageConfiguration(root: jsonP.JSONValue): s.LineageConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CrawlerLineageSettings": (x: jsonP.JSONValue) => cmnP.readEnum<s.CrawlerLineageSettings>(x),
    },
  }, root);
}

function fromDatabaseInput(input?: s.DatabaseInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    LocationUri: input["LocationUri"],
    Parameters: input["Parameters"],
    CreateTableDefaultPermissions: input["CreateTableDefaultPermissions"]?.map(x => fromPrincipalPermissions(x)),
    TargetDatabase: fromDatabaseIdentifier(input["TargetDatabase"]),
  }
}

function fromPrincipalPermissions(input?: s.PrincipalPermissions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Principal: fromDataLakePrincipal(input["Principal"]),
    Permissions: input["Permissions"],
  }
}
function toPrincipalPermissions(root: jsonP.JSONValue): s.PrincipalPermissions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Principal": toDataLakePrincipal,
      "Permissions": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Permission>(x)],
    },
  }, root);
}

function fromDataLakePrincipal(input?: s.DataLakePrincipal | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataLakePrincipalIdentifier: input["DataLakePrincipalIdentifier"],
  }
}
function toDataLakePrincipal(root: jsonP.JSONValue): s.DataLakePrincipal {
  return jsonP.readObj({
    required: {},
    optional: {
      "DataLakePrincipalIdentifier": "s",
    },
  }, root);
}

function fromDatabaseIdentifier(input?: s.DatabaseIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
  }
}
function toDatabaseIdentifier(root: jsonP.JSONValue): s.DatabaseIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "CatalogId": "s",
      "DatabaseName": "s",
    },
  }, root);
}

function fromExecutionProperty(input?: s.ExecutionProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxConcurrentRuns: input["MaxConcurrentRuns"],
  }
}
function toExecutionProperty(root: jsonP.JSONValue): s.ExecutionProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxConcurrentRuns": "n",
    },
  }, root);
}

function fromJobCommand(input?: s.JobCommand | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    ScriptLocation: input["ScriptLocation"],
    PythonVersion: input["PythonVersion"],
  }
}
function toJobCommand(root: jsonP.JSONValue): s.JobCommand {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "ScriptLocation": "s",
      "PythonVersion": "s",
    },
  }, root);
}

function fromConnectionsList(input?: s.ConnectionsList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Connections: input["Connections"],
  }
}
function toConnectionsList(root: jsonP.JSONValue): s.ConnectionsList {
  return jsonP.readObj({
    required: {},
    optional: {
      "Connections": ["s"],
    },
  }, root);
}

function fromNotificationProperty(input?: s.NotificationProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotifyDelayAfter: input["NotifyDelayAfter"],
  }
}
function toNotificationProperty(root: jsonP.JSONValue): s.NotificationProperty {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotifyDelayAfter": "n",
    },
  }, root);
}

function fromGlueTable(input?: s.GlueTable | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
    CatalogId: input["CatalogId"],
    ConnectionName: input["ConnectionName"],
  }
}
function toGlueTable(root: jsonP.JSONValue): s.GlueTable {
  return jsonP.readObj({
    required: {
      "DatabaseName": "s",
      "TableName": "s",
    },
    optional: {
      "CatalogId": "s",
      "ConnectionName": "s",
    },
  }, root);
}

function fromTransformParameters(input?: s.TransformParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TransformType: input["TransformType"],
    FindMatchesParameters: fromFindMatchesParameters(input["FindMatchesParameters"]),
  }
}
function toTransformParameters(root: jsonP.JSONValue): s.TransformParameters {
  return jsonP.readObj({
    required: {
      "TransformType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformType>(x),
    },
    optional: {
      "FindMatchesParameters": toFindMatchesParameters,
    },
  }, root);
}

function fromFindMatchesParameters(input?: s.FindMatchesParameters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrimaryKeyColumnName: input["PrimaryKeyColumnName"],
    PrecisionRecallTradeoff: input["PrecisionRecallTradeoff"],
    AccuracyCostTradeoff: input["AccuracyCostTradeoff"],
    EnforceProvidedLabels: input["EnforceProvidedLabels"],
  }
}
function toFindMatchesParameters(root: jsonP.JSONValue): s.FindMatchesParameters {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryKeyColumnName": "s",
      "PrecisionRecallTradeoff": "n",
      "AccuracyCostTradeoff": "n",
      "EnforceProvidedLabels": "b",
    },
  }, root);
}

function fromTransformEncryption(input?: s.TransformEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MlUserDataEncryption: fromMLUserDataEncryption(input["MlUserDataEncryption"]),
    TaskRunSecurityConfigurationName: input["TaskRunSecurityConfigurationName"],
  }
}
function toTransformEncryption(root: jsonP.JSONValue): s.TransformEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "MlUserDataEncryption": toMLUserDataEncryption,
      "TaskRunSecurityConfigurationName": "s",
    },
  }, root);
}

function fromMLUserDataEncryption(input?: s.MLUserDataEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MlUserDataEncryptionMode: input["MlUserDataEncryptionMode"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toMLUserDataEncryption(root: jsonP.JSONValue): s.MLUserDataEncryption {
  return jsonP.readObj({
    required: {
      "MlUserDataEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.MLUserDataEncryptionModeString>(x),
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromPartitionIndex(input?: s.PartitionIndex | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Keys: input["Keys"],
    IndexName: input["IndexName"],
  }
}

function fromRegistryId(input?: s.RegistryId | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RegistryName: input["RegistryName"],
    RegistryArn: input["RegistryArn"],
  }
}

function fromCodeGenNode(input?: s.CodeGenNode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    NodeType: input["NodeType"],
    Args: input["Args"]?.map(x => fromCodeGenNodeArg(x)),
    LineNumber: input["LineNumber"],
  }
}
function toCodeGenNode(root: jsonP.JSONValue): s.CodeGenNode {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "NodeType": "s",
      "Args": [toCodeGenNodeArg],
    },
    optional: {
      "LineNumber": "n",
    },
  }, root);
}

function fromCodeGenNodeArg(input?: s.CodeGenNodeArg | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
    Param: input["Param"],
  }
}
function toCodeGenNodeArg(root: jsonP.JSONValue): s.CodeGenNodeArg {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Value": "s",
    },
    optional: {
      "Param": "b",
    },
  }, root);
}

function fromCodeGenEdge(input?: s.CodeGenEdge | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Source: input["Source"],
    Target: input["Target"],
    TargetParameter: input["TargetParameter"],
  }
}
function toCodeGenEdge(root: jsonP.JSONValue): s.CodeGenEdge {
  return jsonP.readObj({
    required: {
      "Source": "s",
      "Target": "s",
    },
    optional: {
      "TargetParameter": "s",
    },
  }, root);
}

function fromEncryptionConfiguration(input?: s.EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Encryption: input["S3Encryption"]?.map(x => fromS3Encryption(x)),
    CloudWatchEncryption: fromCloudWatchEncryption(input["CloudWatchEncryption"]),
    JobBookmarksEncryption: fromJobBookmarksEncryption(input["JobBookmarksEncryption"]),
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): s.EncryptionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Encryption": [toS3Encryption],
      "CloudWatchEncryption": toCloudWatchEncryption,
      "JobBookmarksEncryption": toJobBookmarksEncryption,
    },
  }, root);
}

function fromS3Encryption(input?: s.S3Encryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3EncryptionMode: input["S3EncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toS3Encryption(root: jsonP.JSONValue): s.S3Encryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3EncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3EncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

function fromCloudWatchEncryption(input?: s.CloudWatchEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CloudWatchEncryptionMode: input["CloudWatchEncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toCloudWatchEncryption(root: jsonP.JSONValue): s.CloudWatchEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "CloudWatchEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.CloudWatchEncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

function fromJobBookmarksEncryption(input?: s.JobBookmarksEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobBookmarksEncryptionMode: input["JobBookmarksEncryptionMode"],
    KmsKeyArn: input["KmsKeyArn"],
  }
}
function toJobBookmarksEncryption(root: jsonP.JSONValue): s.JobBookmarksEncryption {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobBookmarksEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobBookmarksEncryptionMode>(x),
      "KmsKeyArn": "s",
    },
  }, root);
}

function fromTableInput(input?: s.TableInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Owner: input["Owner"],
    LastAccessTime: jsonP.serializeDate_unixTimestamp(input["LastAccessTime"]),
    LastAnalyzedTime: jsonP.serializeDate_unixTimestamp(input["LastAnalyzedTime"]),
    Retention: input["Retention"],
    StorageDescriptor: fromStorageDescriptor(input["StorageDescriptor"]),
    PartitionKeys: input["PartitionKeys"]?.map(x => fromColumn(x)),
    ViewOriginalText: input["ViewOriginalText"],
    ViewExpandedText: input["ViewExpandedText"],
    TableType: input["TableType"],
    Parameters: input["Parameters"],
    TargetTable: fromTableIdentifier(input["TargetTable"]),
  }
}

function fromTableIdentifier(input?: s.TableIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogId: input["CatalogId"],
    DatabaseName: input["DatabaseName"],
    Name: input["Name"],
  }
}
function toTableIdentifier(root: jsonP.JSONValue): s.TableIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "CatalogId": "s",
      "DatabaseName": "s",
      "Name": "s",
    },
  }, root);
}

function fromPredicate(input?: s.Predicate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Logical: input["Logical"],
    Conditions: input["Conditions"]?.map(x => fromCondition(x)),
  }
}
function toPredicate(root: jsonP.JSONValue): s.Predicate {
  return jsonP.readObj({
    required: {},
    optional: {
      "Logical": (x: jsonP.JSONValue) => cmnP.readEnum<s.Logical>(x),
      "Conditions": [toCondition],
    },
  }, root);
}

function fromCondition(input?: s.Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LogicalOperator: input["LogicalOperator"],
    JobName: input["JobName"],
    State: input["State"],
    CrawlerName: input["CrawlerName"],
    CrawlState: input["CrawlState"],
  }
}
function toCondition(root: jsonP.JSONValue): s.Condition {
  return jsonP.readObj({
    required: {},
    optional: {
      "LogicalOperator": (x: jsonP.JSONValue) => cmnP.readEnum<s.LogicalOperator>(x),
      "JobName": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobRunState>(x),
      "CrawlerName": "s",
      "CrawlState": (x: jsonP.JSONValue) => cmnP.readEnum<s.CrawlState>(x),
    },
  }, root);
}

function fromAction(input?: s.Action | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    JobName: input["JobName"],
    Arguments: input["Arguments"],
    Timeout: input["Timeout"],
    SecurityConfiguration: input["SecurityConfiguration"],
    NotificationProperty: fromNotificationProperty(input["NotificationProperty"]),
    CrawlerName: input["CrawlerName"],
  }
}
function toAction(root: jsonP.JSONValue): s.Action {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "Arguments": x => jsonP.readMap(String, String, x),
      "Timeout": "n",
      "SecurityConfiguration": "s",
      "NotificationProperty": toNotificationProperty,
      "CrawlerName": "s",
    },
  }, root);
}

function fromUserDefinedFunctionInput(input?: s.UserDefinedFunctionInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FunctionName: input["FunctionName"],
    ClassName: input["ClassName"],
    OwnerName: input["OwnerName"],
    OwnerType: input["OwnerType"],
    ResourceUris: input["ResourceUris"]?.map(x => fromResourceUri(x)),
  }
}

function fromResourceUri(input?: s.ResourceUri | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ResourceType: input["ResourceType"],
    Uri: input["Uri"],
  }
}
function toResourceUri(root: jsonP.JSONValue): s.ResourceUri {
  return jsonP.readObj({
    required: {},
    optional: {
      "ResourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ResourceType>(x),
      "Uri": "s",
    },
  }, root);
}

function fromGetConnectionsFilter(input?: s.GetConnectionsFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MatchCriteria: input["MatchCriteria"],
    ConnectionType: input["ConnectionType"],
  }
}

function fromTaskRunFilterCriteria(input?: s.TaskRunFilterCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TaskRunType: input["TaskRunType"],
    Status: input["Status"],
    StartedBefore: jsonP.serializeDate_unixTimestamp(input["StartedBefore"]),
    StartedAfter: jsonP.serializeDate_unixTimestamp(input["StartedAfter"]),
  }
}

function fromTaskRunSortCriteria(input?: s.TaskRunSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortDirection: input["SortDirection"],
  }
}

function fromTransformFilterCriteria(input?: s.TransformFilterCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    TransformType: input["TransformType"],
    Status: input["Status"],
    GlueVersion: input["GlueVersion"],
    CreatedBefore: jsonP.serializeDate_unixTimestamp(input["CreatedBefore"]),
    CreatedAfter: jsonP.serializeDate_unixTimestamp(input["CreatedAfter"]),
    LastModifiedBefore: jsonP.serializeDate_unixTimestamp(input["LastModifiedBefore"]),
    LastModifiedAfter: jsonP.serializeDate_unixTimestamp(input["LastModifiedAfter"]),
    Schema: input["Schema"]?.map(x => fromSchemaColumn(x)),
  }
}

function fromSchemaColumn(input?: s.SchemaColumn | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    DataType: input["DataType"],
  }
}
function toSchemaColumn(root: jsonP.JSONValue): s.SchemaColumn {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "DataType": "s",
    },
  }, root);
}

function fromTransformSortCriteria(input?: s.TransformSortCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Column: input["Column"],
    SortDirection: input["SortDirection"],
  }
}

function fromCatalogEntry(input?: s.CatalogEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DatabaseName: input["DatabaseName"],
    TableName: input["TableName"],
  }
}

function fromLocation(input?: s.Location | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Jdbc: input["Jdbc"]?.map(x => fromCodeGenNodeArg(x)),
    S3: input["S3"]?.map(x => fromCodeGenNodeArg(x)),
    DynamoDB: input["DynamoDB"]?.map(x => fromCodeGenNodeArg(x)),
  }
}

function fromSegment(input?: s.Segment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SegmentNumber: input["SegmentNumber"],
    TotalSegments: input["TotalSegments"],
  }
}

function fromMappingEntry(input?: s.MappingEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceTable: input["SourceTable"],
    SourcePath: input["SourcePath"],
    SourceType: input["SourceType"],
    TargetTable: input["TargetTable"],
    TargetPath: input["TargetPath"],
    TargetType: input["TargetType"],
  }
}
function toMappingEntry(root: jsonP.JSONValue): s.MappingEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceTable": "s",
      "SourcePath": "s",
      "SourceType": "s",
      "TargetTable": "s",
      "TargetPath": "s",
      "TargetType": "s",
    },
  }, root);
}

function fromSchemaVersionNumber(input?: s.SchemaVersionNumber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LatestVersion: input["LatestVersion"],
    VersionNumber: input["VersionNumber"],
  }
}

function fromDataCatalogEncryptionSettings(input?: s.DataCatalogEncryptionSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EncryptionAtRest: fromEncryptionAtRest(input["EncryptionAtRest"]),
    ConnectionPasswordEncryption: fromConnectionPasswordEncryption(input["ConnectionPasswordEncryption"]),
  }
}
function toDataCatalogEncryptionSettings(root: jsonP.JSONValue): s.DataCatalogEncryptionSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "EncryptionAtRest": toEncryptionAtRest,
      "ConnectionPasswordEncryption": toConnectionPasswordEncryption,
    },
  }, root);
}

function fromEncryptionAtRest(input?: s.EncryptionAtRest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CatalogEncryptionMode: input["CatalogEncryptionMode"],
    SseAwsKmsKeyId: input["SseAwsKmsKeyId"],
  }
}
function toEncryptionAtRest(root: jsonP.JSONValue): s.EncryptionAtRest {
  return jsonP.readObj({
    required: {
      "CatalogEncryptionMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.CatalogEncryptionMode>(x),
    },
    optional: {
      "SseAwsKmsKeyId": "s",
    },
  }, root);
}

function fromConnectionPasswordEncryption(input?: s.ConnectionPasswordEncryption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ReturnConnectionPasswordEncrypted: input["ReturnConnectionPasswordEncrypted"],
    AwsKmsKeyId: input["AwsKmsKeyId"],
  }
}
function toConnectionPasswordEncryption(root: jsonP.JSONValue): s.ConnectionPasswordEncryption {
  return jsonP.readObj({
    required: {
      "ReturnConnectionPasswordEncrypted": "b",
    },
    optional: {
      "AwsKmsKeyId": "s",
    },
  }, root);
}

function fromMetadataKeyValuePair(input?: s.MetadataKeyValuePair | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetadataKey: input["MetadataKey"],
    MetadataValue: input["MetadataValue"],
  }
}

function fromPropertyPredicate(input?: s.PropertyPredicate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
    Comparator: input["Comparator"],
  }
}

function fromSortCriterion(input?: s.SortCriterion | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FieldName: input["FieldName"],
    Sort: input["Sort"],
  }
}

function fromUpdateGrokClassifierRequest(input?: s.UpdateGrokClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Classification: input["Classification"],
    GrokPattern: input["GrokPattern"],
    CustomPatterns: input["CustomPatterns"],
  }
}

function fromUpdateXMLClassifierRequest(input?: s.UpdateXMLClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Classification: input["Classification"],
    RowTag: input["RowTag"],
  }
}

function fromUpdateJsonClassifierRequest(input?: s.UpdateJsonClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    JsonPath: input["JsonPath"],
  }
}

function fromUpdateCsvClassifierRequest(input?: s.UpdateCsvClassifierRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Delimiter: input["Delimiter"],
    QuoteSymbol: input["QuoteSymbol"],
    ContainsHeader: input["ContainsHeader"],
    Header: input["Header"],
    DisableValueTrimming: input["DisableValueTrimming"],
    AllowSingleColumn: input["AllowSingleColumn"],
  }
}

function fromColumnStatistics(input?: s.ColumnStatistics | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ColumnName: input["ColumnName"],
    ColumnType: input["ColumnType"],
    AnalyzedTime: jsonP.serializeDate_unixTimestamp(input["AnalyzedTime"]),
    StatisticsData: fromColumnStatisticsData(input["StatisticsData"]),
  }
}
function toColumnStatistics(root: jsonP.JSONValue): s.ColumnStatistics {
  return jsonP.readObj({
    required: {
      "ColumnName": "s",
      "ColumnType": "s",
      "AnalyzedTime": "d",
      "StatisticsData": toColumnStatisticsData,
    },
    optional: {},
  }, root);
}

function fromColumnStatisticsData(input?: s.ColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    BooleanColumnStatisticsData: fromBooleanColumnStatisticsData(input["BooleanColumnStatisticsData"]),
    DateColumnStatisticsData: fromDateColumnStatisticsData(input["DateColumnStatisticsData"]),
    DecimalColumnStatisticsData: fromDecimalColumnStatisticsData(input["DecimalColumnStatisticsData"]),
    DoubleColumnStatisticsData: fromDoubleColumnStatisticsData(input["DoubleColumnStatisticsData"]),
    LongColumnStatisticsData: fromLongColumnStatisticsData(input["LongColumnStatisticsData"]),
    StringColumnStatisticsData: fromStringColumnStatisticsData(input["StringColumnStatisticsData"]),
    BinaryColumnStatisticsData: fromBinaryColumnStatisticsData(input["BinaryColumnStatisticsData"]),
  }
}
function toColumnStatisticsData(root: jsonP.JSONValue): s.ColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ColumnStatisticsType>(x),
    },
    optional: {
      "BooleanColumnStatisticsData": toBooleanColumnStatisticsData,
      "DateColumnStatisticsData": toDateColumnStatisticsData,
      "DecimalColumnStatisticsData": toDecimalColumnStatisticsData,
      "DoubleColumnStatisticsData": toDoubleColumnStatisticsData,
      "LongColumnStatisticsData": toLongColumnStatisticsData,
      "StringColumnStatisticsData": toStringColumnStatisticsData,
      "BinaryColumnStatisticsData": toBinaryColumnStatisticsData,
    },
  }, root);
}

function fromBooleanColumnStatisticsData(input?: s.BooleanColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NumberOfTrues: input["NumberOfTrues"],
    NumberOfFalses: input["NumberOfFalses"],
    NumberOfNulls: input["NumberOfNulls"],
  }
}
function toBooleanColumnStatisticsData(root: jsonP.JSONValue): s.BooleanColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfTrues": "n",
      "NumberOfFalses": "n",
      "NumberOfNulls": "n",
    },
    optional: {},
  }, root);
}

function fromDateColumnStatisticsData(input?: s.DateColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: jsonP.serializeDate_unixTimestamp(input["MinimumValue"]),
    MaximumValue: jsonP.serializeDate_unixTimestamp(input["MaximumValue"]),
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDateColumnStatisticsData(root: jsonP.JSONValue): s.DateColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "d",
      "MaximumValue": "d",
    },
  }, root);
}

function fromDecimalColumnStatisticsData(input?: s.DecimalColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: fromDecimalNumber(input["MinimumValue"]),
    MaximumValue: fromDecimalNumber(input["MaximumValue"]),
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDecimalColumnStatisticsData(root: jsonP.JSONValue): s.DecimalColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": toDecimalNumber,
      "MaximumValue": toDecimalNumber,
    },
  }, root);
}

function fromDecimalNumber(input?: s.DecimalNumber | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UnscaledValue: serializeBlob(input["UnscaledValue"]),
    Scale: input["Scale"],
  }
}
function toDecimalNumber(root: jsonP.JSONValue): s.DecimalNumber {
  return jsonP.readObj({
    required: {
      "UnscaledValue": "a",
      "Scale": "n",
    },
    optional: {},
  }, root);
}

function fromDoubleColumnStatisticsData(input?: s.DoubleColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: input["MinimumValue"],
    MaximumValue: input["MaximumValue"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toDoubleColumnStatisticsData(root: jsonP.JSONValue): s.DoubleColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "n",
      "MaximumValue": "n",
    },
  }, root);
}

function fromLongColumnStatisticsData(input?: s.LongColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinimumValue: input["MinimumValue"],
    MaximumValue: input["MaximumValue"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toLongColumnStatisticsData(root: jsonP.JSONValue): s.LongColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {
      "MinimumValue": "n",
      "MaximumValue": "n",
    },
  }, root);
}

function fromStringColumnStatisticsData(input?: s.StringColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumLength: input["MaximumLength"],
    AverageLength: input["AverageLength"],
    NumberOfNulls: input["NumberOfNulls"],
    NumberOfDistinctValues: input["NumberOfDistinctValues"],
  }
}
function toStringColumnStatisticsData(root: jsonP.JSONValue): s.StringColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "MaximumLength": "n",
      "AverageLength": "n",
      "NumberOfNulls": "n",
      "NumberOfDistinctValues": "n",
    },
    optional: {},
  }, root);
}

function fromBinaryColumnStatisticsData(input?: s.BinaryColumnStatisticsData | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaximumLength: input["MaximumLength"],
    AverageLength: input["AverageLength"],
    NumberOfNulls: input["NumberOfNulls"],
  }
}
function toBinaryColumnStatisticsData(root: jsonP.JSONValue): s.BinaryColumnStatisticsData {
  return jsonP.readObj({
    required: {
      "MaximumLength": "n",
      "AverageLength": "n",
      "NumberOfNulls": "n",
    },
    optional: {},
  }, root);
}

function fromDevEndpointCustomLibraries(input?: s.DevEndpointCustomLibraries | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExtraPythonLibsS3Path: input["ExtraPythonLibsS3Path"],
    ExtraJarsS3Path: input["ExtraJarsS3Path"],
  }
}

function fromJobUpdate(input?: s.JobUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Description: input["Description"],
    LogUri: input["LogUri"],
    Role: input["Role"],
    ExecutionProperty: fromExecutionProperty(input["ExecutionProperty"]),
    Command: fromJobCommand(input["Command"]),
    DefaultArguments: input["DefaultArguments"],
    NonOverridableArguments: input["NonOverridableArguments"],
    Connections: fromConnectionsList(input["Connections"]),
    MaxRetries: input["MaxRetries"],
    AllocatedCapacity: input["AllocatedCapacity"],
    Timeout: input["Timeout"],
    MaxCapacity: input["MaxCapacity"],
    WorkerType: input["WorkerType"],
    NumberOfWorkers: input["NumberOfWorkers"],
    SecurityConfiguration: input["SecurityConfiguration"],
    NotificationProperty: fromNotificationProperty(input["NotificationProperty"]),
    GlueVersion: input["GlueVersion"],
  }
}

function fromTriggerUpdate(input?: s.TriggerUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Schedule: input["Schedule"],
    Actions: input["Actions"]?.map(x => fromAction(x)),
    Predicate: fromPredicate(input["Predicate"]),
  }
}

function toPartitionError(root: jsonP.JSONValue): s.PartitionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "PartitionValues": ["s"],
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

function toErrorDetail(root: jsonP.JSONValue): s.ErrorDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toTableError(root: jsonP.JSONValue): s.TableError {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

function toTableVersionError(root: jsonP.JSONValue): s.TableVersionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "TableName": "s",
      "VersionId": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

function toCrawler(root: jsonP.JSONValue): s.Crawler {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Role": "s",
      "Targets": toCrawlerTargets,
      "DatabaseName": "s",
      "Description": "s",
      "Classifiers": ["s"],
      "RecrawlPolicy": toRecrawlPolicy,
      "SchemaChangePolicy": toSchemaChangePolicy,
      "LineageConfiguration": toLineageConfiguration,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.CrawlerState>(x),
      "TablePrefix": "s",
      "Schedule": toSchedule,
      "CrawlElapsedTime": "n",
      "CreationTime": "d",
      "LastUpdated": "d",
      "LastCrawl": toLastCrawlInfo,
      "Version": "n",
      "Configuration": "s",
      "CrawlerSecurityConfiguration": "s",
    },
  }, root);
}

function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScheduleExpression": "s",
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleState>(x),
    },
  }, root);
}

function toLastCrawlInfo(root: jsonP.JSONValue): s.LastCrawlInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastCrawlStatus>(x),
      "ErrorMessage": "s",
      "LogGroup": "s",
      "LogStream": "s",
      "MessagePrefix": "s",
      "StartTime": "d",
    },
  }, root);
}

function toDevEndpoint(root: jsonP.JSONValue): s.DevEndpoint {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointName": "s",
      "RoleArn": "s",
      "SecurityGroupIds": ["s"],
      "SubnetId": "s",
      "YarnEndpointAddress": "s",
      "PrivateAddress": "s",
      "ZeppelinRemoteSparkInterpreterPort": "n",
      "PublicAddress": "s",
      "Status": "s",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
      "GlueVersion": "s",
      "NumberOfWorkers": "n",
      "NumberOfNodes": "n",
      "AvailabilityZone": "s",
      "VpcId": "s",
      "ExtraPythonLibsS3Path": "s",
      "ExtraJarsS3Path": "s",
      "FailureReason": "s",
      "LastUpdateStatus": "s",
      "CreatedTimestamp": "d",
      "LastModifiedTimestamp": "d",
      "PublicKey": "s",
      "PublicKeys": ["s"],
      "SecurityConfiguration": "s",
      "Arguments": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toJob(root: jsonP.JSONValue): s.Job {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "LogUri": "s",
      "Role": "s",
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "ExecutionProperty": toExecutionProperty,
      "Command": toJobCommand,
      "DefaultArguments": x => jsonP.readMap(String, String, x),
      "NonOverridableArguments": x => jsonP.readMap(String, String, x),
      "Connections": toConnectionsList,
      "MaxRetries": "n",
      "AllocatedCapacity": "n",
      "Timeout": "n",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
      "NumberOfWorkers": "n",
      "SecurityConfiguration": "s",
      "NotificationProperty": toNotificationProperty,
      "GlueVersion": "s",
    },
  }, root);
}

function toPartition(root: jsonP.JSONValue): s.Partition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Values": ["s"],
      "DatabaseName": "s",
      "TableName": "s",
      "CreationTime": "d",
      "LastAccessTime": "d",
      "StorageDescriptor": toStorageDescriptor,
      "Parameters": x => jsonP.readMap(String, String, x),
      "LastAnalyzedTime": "d",
      "CatalogId": "s",
    },
  }, root);
}

function toTrigger(root: jsonP.JSONValue): s.Trigger {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "WorkflowName": "s",
      "Id": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TriggerType>(x),
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.TriggerState>(x),
      "Description": "s",
      "Schedule": "s",
      "Actions": [toAction],
      "Predicate": toPredicate,
    },
  }, root);
}

function toWorkflow(root: jsonP.JSONValue): s.Workflow {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "DefaultRunProperties": x => jsonP.readMap(String, String, x),
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "LastRun": toWorkflowRun,
      "Graph": toWorkflowGraph,
      "MaxConcurrentRuns": "n",
    },
  }, root);
}

function toWorkflowRun(root: jsonP.JSONValue): s.WorkflowRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "WorkflowRunId": "s",
      "PreviousRunId": "s",
      "WorkflowRunProperties": x => jsonP.readMap(String, String, x),
      "StartedOn": "d",
      "CompletedOn": "d",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkflowRunStatus>(x),
      "ErrorMessage": "s",
      "Statistics": toWorkflowRunStatistics,
      "Graph": toWorkflowGraph,
    },
  }, root);
}

function toWorkflowRunStatistics(root: jsonP.JSONValue): s.WorkflowRunStatistics {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalActions": "n",
      "TimeoutActions": "n",
      "FailedActions": "n",
      "StoppedActions": "n",
      "SucceededActions": "n",
      "RunningActions": "n",
    },
  }, root);
}

function toWorkflowGraph(root: jsonP.JSONValue): s.WorkflowGraph {
  return jsonP.readObj({
    required: {},
    optional: {
      "Nodes": [toNode],
      "Edges": [toEdge],
    },
  }, root);
}

function toNode(root: jsonP.JSONValue): s.Node {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.NodeType>(x),
      "Name": "s",
      "UniqueId": "s",
      "TriggerDetails": toTriggerNodeDetails,
      "JobDetails": toJobNodeDetails,
      "CrawlerDetails": toCrawlerNodeDetails,
    },
  }, root);
}

function toTriggerNodeDetails(root: jsonP.JSONValue): s.TriggerNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Trigger": toTrigger,
    },
  }, root);
}

function toJobNodeDetails(root: jsonP.JSONValue): s.JobNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobRuns": [toJobRun],
    },
  }, root);
}

function toJobRun(root: jsonP.JSONValue): s.JobRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "Id": "s",
      "Attempt": "n",
      "PreviousRunId": "s",
      "TriggerName": "s",
      "JobName": "s",
      "StartedOn": "d",
      "LastModifiedOn": "d",
      "CompletedOn": "d",
      "JobRunState": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobRunState>(x),
      "Arguments": x => jsonP.readMap(String, String, x),
      "ErrorMessage": "s",
      "PredecessorRuns": [toPredecessor],
      "AllocatedCapacity": "n",
      "ExecutionTime": "n",
      "Timeout": "n",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
      "NumberOfWorkers": "n",
      "SecurityConfiguration": "s",
      "LogGroupName": "s",
      "NotificationProperty": toNotificationProperty,
      "GlueVersion": "s",
    },
  }, root);
}

function toPredecessor(root: jsonP.JSONValue): s.Predecessor {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "RunId": "s",
    },
  }, root);
}

function toCrawlerNodeDetails(root: jsonP.JSONValue): s.CrawlerNodeDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "Crawls": [toCrawl],
    },
  }, root);
}

function toCrawl(root: jsonP.JSONValue): s.Crawl {
  return jsonP.readObj({
    required: {},
    optional: {
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.CrawlState>(x),
      "StartedOn": "d",
      "CompletedOn": "d",
      "ErrorMessage": "s",
      "LogGroup": "s",
      "LogStream": "s",
    },
  }, root);
}

function toEdge(root: jsonP.JSONValue): s.Edge {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceId": "s",
      "DestinationId": "s",
    },
  }, root);
}

function toBatchStopJobRunSuccessfulSubmission(root: jsonP.JSONValue): s.BatchStopJobRunSuccessfulSubmission {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "JobRunId": "s",
    },
  }, root);
}

function toBatchStopJobRunError(root: jsonP.JSONValue): s.BatchStopJobRunError {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "JobRunId": "s",
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

function toBatchUpdatePartitionFailureEntry(root: jsonP.JSONValue): s.BatchUpdatePartitionFailureEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "PartitionValueList": ["s"],
      "ErrorDetail": toErrorDetail,
    },
  }, root);
}

function toSchemaVersionErrorItem(root: jsonP.JSONValue): s.SchemaVersionErrorItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "VersionNumber": "n",
      "ErrorDetails": toErrorDetails,
    },
  }, root);
}

function toErrorDetails(root: jsonP.JSONValue): s.ErrorDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "ErrorMessage": "s",
    },
  }, root);
}

function toCatalogImportStatus(root: jsonP.JSONValue): s.CatalogImportStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "ImportCompleted": "b",
      "ImportTime": "d",
      "ImportedBy": "s",
    },
  }, root);
}

function toClassifier(root: jsonP.JSONValue): s.Classifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "GrokClassifier": toGrokClassifier,
      "XMLClassifier": toXMLClassifier,
      "JsonClassifier": toJsonClassifier,
      "CsvClassifier": toCsvClassifier,
    },
  }, root);
}

function toGrokClassifier(root: jsonP.JSONValue): s.GrokClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Classification": "s",
      "GrokPattern": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "CustomPatterns": "s",
    },
  }, root);
}

function toXMLClassifier(root: jsonP.JSONValue): s.XMLClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Classification": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "RowTag": "s",
    },
  }, root);
}

function toJsonClassifier(root: jsonP.JSONValue): s.JsonClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "JsonPath": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
    },
  }, root);
}

function toCsvClassifier(root: jsonP.JSONValue): s.CsvClassifier {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastUpdated": "d",
      "Version": "n",
      "Delimiter": "s",
      "QuoteSymbol": "s",
      "ContainsHeader": (x: jsonP.JSONValue) => cmnP.readEnum<s.CsvHeaderOption>(x),
      "Header": ["s"],
      "DisableValueTrimming": "b",
      "AllowSingleColumn": "b",
    },
  }, root);
}

function toColumnError(root: jsonP.JSONValue): s.ColumnError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnName": "s",
      "Error": toErrorDetail,
    },
  }, root);
}

function toConnection(root: jsonP.JSONValue): s.Connection {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Description": "s",
      "ConnectionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConnectionType>(x),
      "MatchCriteria": ["s"],
      "ConnectionProperties": x => jsonP.readMap(x => cmnP.readEnumReq<s.ConnectionPropertyKey>(x), String, x),
      "PhysicalConnectionRequirements": toPhysicalConnectionRequirements,
      "CreationTime": "d",
      "LastUpdatedTime": "d",
      "LastUpdatedBy": "s",
    },
  }, root);
}

function toCrawlerMetrics(root: jsonP.JSONValue): s.CrawlerMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "CrawlerName": "s",
      "TimeLeftSeconds": "n",
      "StillEstimating": "b",
      "LastRuntimeSeconds": "n",
      "MedianRuntimeSeconds": "n",
      "TablesCreated": "n",
      "TablesUpdated": "n",
      "TablesDeleted": "n",
    },
  }, root);
}

function toDatabase(root: jsonP.JSONValue): s.Database {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "Description": "s",
      "LocationUri": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
      "CreateTime": "d",
      "CreateTableDefaultPermissions": [toPrincipalPermissions],
      "TargetDatabase": toDatabaseIdentifier,
      "CatalogId": "s",
    },
  }, root);
}

function toJobBookmarkEntry(root: jsonP.JSONValue): s.JobBookmarkEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobName": "s",
      "Version": "n",
      "Run": "n",
      "Attempt": "n",
      "PreviousRunId": "s",
      "RunId": "s",
      "JobBookmark": "s",
    },
  }, root);
}

function toTaskRunProperties(root: jsonP.JSONValue): s.TaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "TaskType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskType>(x),
      "ImportLabelsTaskRunProperties": toImportLabelsTaskRunProperties,
      "ExportLabelsTaskRunProperties": toExportLabelsTaskRunProperties,
      "LabelingSetGenerationTaskRunProperties": toLabelingSetGenerationTaskRunProperties,
      "FindMatchesTaskRunProperties": toFindMatchesTaskRunProperties,
    },
  }, root);
}

function toImportLabelsTaskRunProperties(root: jsonP.JSONValue): s.ImportLabelsTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputS3Path": "s",
      "Replace": "b",
    },
  }, root);
}

function toExportLabelsTaskRunProperties(root: jsonP.JSONValue): s.ExportLabelsTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputS3Path": "s",
    },
  }, root);
}

function toLabelingSetGenerationTaskRunProperties(root: jsonP.JSONValue): s.LabelingSetGenerationTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "OutputS3Path": "s",
    },
  }, root);
}

function toFindMatchesTaskRunProperties(root: jsonP.JSONValue): s.FindMatchesTaskRunProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "JobId": "s",
      "JobName": "s",
      "JobRunId": "s",
    },
  }, root);
}

function toTaskRun(root: jsonP.JSONValue): s.TaskRun {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformId": "s",
      "TaskRunId": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TaskStatusType>(x),
      "LogGroupName": "s",
      "Properties": toTaskRunProperties,
      "ErrorString": "s",
      "StartedOn": "d",
      "LastModifiedOn": "d",
      "CompletedOn": "d",
      "ExecutionTime": "n",
    },
  }, root);
}

function toEvaluationMetrics(root: jsonP.JSONValue): s.EvaluationMetrics {
  return jsonP.readObj({
    required: {
      "TransformType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformType>(x),
    },
    optional: {
      "FindMatchesMetrics": toFindMatchesMetrics,
    },
  }, root);
}

function toFindMatchesMetrics(root: jsonP.JSONValue): s.FindMatchesMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "AreaUnderPRCurve": "n",
      "Precision": "n",
      "Recall": "n",
      "F1": "n",
      "ConfusionMatrix": toConfusionMatrix,
      "ColumnImportances": [toColumnImportance],
    },
  }, root);
}

function toConfusionMatrix(root: jsonP.JSONValue): s.ConfusionMatrix {
  return jsonP.readObj({
    required: {},
    optional: {
      "NumTruePositives": "n",
      "NumFalsePositives": "n",
      "NumTrueNegatives": "n",
      "NumFalseNegatives": "n",
    },
  }, root);
}

function toColumnImportance(root: jsonP.JSONValue): s.ColumnImportance {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnName": "s",
      "Importance": "n",
    },
  }, root);
}

function toMLTransform(root: jsonP.JSONValue): s.MLTransform {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformId": "s",
      "Name": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformStatusType>(x),
      "CreatedOn": "d",
      "LastModifiedOn": "d",
      "InputRecordTables": [toGlueTable],
      "Parameters": toTransformParameters,
      "EvaluationMetrics": toEvaluationMetrics,
      "LabelCount": "n",
      "Schema": [toSchemaColumn],
      "Role": "s",
      "GlueVersion": "s",
      "MaxCapacity": "n",
      "WorkerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.WorkerType>(x),
      "NumberOfWorkers": "n",
      "Timeout": "n",
      "MaxRetries": "n",
      "TransformEncryption": toTransformEncryption,
    },
  }, root);
}

function toPartitionIndexDescriptor(root: jsonP.JSONValue): s.PartitionIndexDescriptor {
  return jsonP.readObj({
    required: {
      "IndexName": "s",
      "Keys": [toKeySchemaElement],
      "IndexStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PartitionIndexStatus>(x),
    },
    optional: {
      "BackfillErrors": [toBackfillError],
    },
  }, root);
}

function toKeySchemaElement(root: jsonP.JSONValue): s.KeySchemaElement {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": "s",
    },
    optional: {},
  }, root);
}

function toBackfillError(root: jsonP.JSONValue): s.BackfillError {
  return jsonP.readObj({
    required: {},
    optional: {
      "Code": (x: jsonP.JSONValue) => cmnP.readEnum<s.BackfillErrorCode>(x),
      "Partitions": [toPartitionValueList],
    },
  }, root);
}

function toGluePolicy(root: jsonP.JSONValue): s.GluePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "PolicyInJson": "s",
      "PolicyHash": "s",
      "CreateTime": "d",
      "UpdateTime": "d",
    },
  }, root);
}

function toSecurityConfiguration(root: jsonP.JSONValue): s.SecurityConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "CreatedTimeStamp": "d",
      "EncryptionConfiguration": toEncryptionConfiguration,
    },
  }, root);
}

function toTable(root: jsonP.JSONValue): s.Table {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "DatabaseName": "s",
      "Description": "s",
      "Owner": "s",
      "CreateTime": "d",
      "UpdateTime": "d",
      "LastAccessTime": "d",
      "LastAnalyzedTime": "d",
      "Retention": "n",
      "StorageDescriptor": toStorageDescriptor,
      "PartitionKeys": [toColumn],
      "ViewOriginalText": "s",
      "ViewExpandedText": "s",
      "TableType": "s",
      "Parameters": x => jsonP.readMap(String, String, x),
      "CreatedBy": "s",
      "IsRegisteredWithLakeFormation": "b",
      "TargetTable": toTableIdentifier,
      "CatalogId": "s",
    },
  }, root);
}

function toTableVersion(root: jsonP.JSONValue): s.TableVersion {
  return jsonP.readObj({
    required: {},
    optional: {
      "Table": toTable,
      "VersionId": "s",
    },
  }, root);
}

function toUserDefinedFunction(root: jsonP.JSONValue): s.UserDefinedFunction {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionName": "s",
      "DatabaseName": "s",
      "ClassName": "s",
      "OwnerName": "s",
      "OwnerType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PrincipalType>(x),
      "CreateTime": "d",
      "ResourceUris": [toResourceUri],
      "CatalogId": "s",
    },
  }, root);
}

function toRegistryListItem(root: jsonP.JSONValue): s.RegistryListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegistryName": "s",
      "RegistryArn": "s",
      "Description": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.RegistryStatus>(x),
      "CreatedTime": "s",
      "UpdatedTime": "s",
    },
  }, root);
}

function toSchemaVersionListItem(root: jsonP.JSONValue): s.SchemaVersionListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "SchemaArn": "s",
      "SchemaVersionId": "s",
      "VersionNumber": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaVersionStatus>(x),
      "CreatedTime": "s",
    },
  }, root);
}

function toSchemaListItem(root: jsonP.JSONValue): s.SchemaListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "RegistryName": "s",
      "SchemaName": "s",
      "SchemaArn": "s",
      "Description": "s",
      "SchemaStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SchemaStatus>(x),
      "CreatedTime": "s",
      "UpdatedTime": "s",
    },
  }, root);
}

function toMetadataInfo(root: jsonP.JSONValue): s.MetadataInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetadataValue": "s",
      "CreatedTime": "s",
    },
  }, root);
}

function toColumnStatisticsError(root: jsonP.JSONValue): s.ColumnStatisticsError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ColumnStatistics": toColumnStatistics,
      "Error": toErrorDetail,
    },
  }, root);
}
