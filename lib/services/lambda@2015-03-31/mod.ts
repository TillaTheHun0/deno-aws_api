// Autogenerated API client for: AWS Lambda

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Lambda {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Lambda.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2015-03-31",
    "endpointPrefix": "lambda",
    "protocol": "rest-json",
    "serviceFullName": "AWS Lambda",
    "serviceId": "Lambda",
    "signatureVersion": "v4",
    "uid": "lambda-2015-03-31"
  };

  async addLayerVersionPermission(
    {abortSignal, ...params}: RequestConfig & AddLayerVersionPermissionRequest,
  ): Promise<AddLayerVersionPermissionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      StatementId: params["StatementId"],
      Action: params["Action"],
      Principal: params["Principal"],
      OrganizationId: params["OrganizationId"],
    };
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "AddLayerVersionPermission",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Statement": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async addPermission(
    {abortSignal, ...params}: RequestConfig & AddPermissionRequest,
  ): Promise<AddPermissionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      StatementId: params["StatementId"],
      Action: params["Action"],
      Principal: params["Principal"],
      SourceArn: params["SourceArn"],
      SourceAccount: params["SourceAccount"],
      EventSourceToken: params["EventSourceToken"],
      RevisionId: params["RevisionId"],
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "AddPermission",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Statement": "s",
      },
    }, await resp.json());
  }

  async createAlias(
    {abortSignal, ...params}: RequestConfig & CreateAliasRequest,
  ): Promise<AliasConfiguration> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FunctionVersion: params["FunctionVersion"],
      Description: params["Description"],
      RoutingConfig: fromAliasRoutingConfiguration(params["RoutingConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlias",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async createEventSourceMapping(
    {abortSignal, ...params}: RequestConfig & CreateEventSourceMappingRequest,
  ): Promise<EventSourceMappingConfiguration> {
    const body: jsonP.JSONObject = {
      EventSourceArn: params["EventSourceArn"],
      FunctionName: params["FunctionName"],
      Enabled: params["Enabled"],
      BatchSize: params["BatchSize"],
      MaximumBatchingWindowInSeconds: params["MaximumBatchingWindowInSeconds"],
      ParallelizationFactor: params["ParallelizationFactor"],
      StartingPosition: params["StartingPosition"],
      StartingPositionTimestamp: jsonP.serializeDate_unixTimestamp(params["StartingPositionTimestamp"]),
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
      MaximumRecordAgeInSeconds: params["MaximumRecordAgeInSeconds"],
      BisectBatchOnFunctionError: params["BisectBatchOnFunctionError"],
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      Topics: params["Topics"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEventSourceMapping",
      requestUri: "/2015-03-31/event-source-mappings/",
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
      },
    }, await resp.json());
  }

  async createFunction(
    {abortSignal, ...params}: RequestConfig & CreateFunctionRequest,
  ): Promise<FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionName: params["FunctionName"],
      Runtime: params["Runtime"],
      Role: params["Role"],
      Handler: params["Handler"],
      Code: fromFunctionCode(params["Code"]),
      Description: params["Description"],
      Timeout: params["Timeout"],
      MemorySize: params["MemorySize"],
      Publish: params["Publish"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      DeadLetterConfig: fromDeadLetterConfig(params["DeadLetterConfig"]),
      Environment: fromEnvironment(params["Environment"]),
      KMSKeyArn: params["KMSKeyArn"],
      TracingConfig: fromTracingConfig(params["TracingConfig"]),
      Tags: params["Tags"],
      Layers: params["Layers"],
      FileSystemConfigs: params["FileSystemConfigs"]?.map(x => fromFileSystemConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFunction",
      requestUri: "/2015-03-31/functions",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
      },
    }, await resp.json());
  }

  async deleteAlias(
    {abortSignal, ...params}: RequestConfig & DeleteAliasRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 204,
    });
  }

  async deleteEventSourceMapping(
    {abortSignal, ...params}: RequestConfig & DeleteEventSourceMappingRequest,
  ): Promise<EventSourceMappingConfiguration> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteEventSourceMapping",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
      },
    }, await resp.json());
  }

  async deleteFunction(
    {abortSignal, ...params}: RequestConfig & DeleteFunctionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteFunction",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}`,
      responseCode: 204,
    });
  }

  async deleteFunctionConcurrency(
    {abortSignal, ...params}: RequestConfig & DeleteFunctionConcurrencyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteFunctionConcurrency",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-10-31/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 204,
    });
  }

  async deleteFunctionEventInvokeConfig(
    {abortSignal, ...params}: RequestConfig & DeleteFunctionEventInvokeConfigRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteFunctionEventInvokeConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 204,
    });
  }

  async deleteLayerVersion(
    {abortSignal, ...params}: RequestConfig & DeleteLayerVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteLayerVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}`,
      responseCode: 204,
    });
  }

  async deleteProvisionedConcurrencyConfig(
    {abortSignal, ...params}: RequestConfig & DeleteProvisionedConcurrencyConfigRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteProvisionedConcurrencyConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 204,
    });
  }

  async getAccountSettings(
    {abortSignal, ...params}: RequestConfig & GetAccountSettingsRequest = {},
  ): Promise<GetAccountSettingsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAccountSettings",
      method: "GET",
      requestUri: "/2016-08-19/account-settings/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountLimit": toAccountLimit,
        "AccountUsage": toAccountUsage,
      },
    }, await resp.json());
  }

  async getAlias(
    {abortSignal, ...params}: RequestConfig & GetAliasRequest,
  ): Promise<AliasConfiguration> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getEventSourceMapping(
    {abortSignal, ...params}: RequestConfig & GetEventSourceMappingRequest,
  ): Promise<EventSourceMappingConfiguration> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEventSourceMapping",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
      },
    }, await resp.json());
  }

  async getFunction(
    {abortSignal, ...params}: RequestConfig & GetFunctionRequest,
  ): Promise<GetFunctionResponse> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toFunctionConfiguration,
        "Code": toFunctionCodeLocation,
        "Tags": x => jsonP.readMap(String, String, x),
        "Concurrency": toConcurrency,
      },
    }, await resp.json());
  }

  async getFunctionConcurrency(
    {abortSignal, ...params}: RequestConfig & GetFunctionConcurrencyRequest,
  ): Promise<GetFunctionConcurrencyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFunctionConcurrency",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedConcurrentExecutions": "n",
      },
    }, await resp.json());
  }

  async getFunctionConfiguration(
    {abortSignal, ...params}: RequestConfig & GetFunctionConfigurationRequest,
  ): Promise<FunctionConfiguration> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFunctionConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
      },
    }, await resp.json());
  }

  async getFunctionEventInvokeConfig(
    {abortSignal, ...params}: RequestConfig & GetFunctionEventInvokeConfigRequest,
  ): Promise<FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetFunctionEventInvokeConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  async getLayerVersion(
    {abortSignal, ...params}: RequestConfig & GetLayerVersionRequest,
  ): Promise<GetLayerVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetLayerVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async getLayerVersionByArn(
    {abortSignal, ...params}: RequestConfig & GetLayerVersionByArnRequest,
  ): Promise<GetLayerVersionResponse> {
    const query = new URLSearchParams;
    query.set("Arn", params["Arn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetLayerVersionByArn",
      method: "GET",
      requestUri: "/2018-10-31/layers?find=LayerVersion",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async getLayerVersionPolicy(
    {abortSignal, ...params}: RequestConfig & GetLayerVersionPolicyRequest,
  ): Promise<GetLayerVersionPolicyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetLayerVersionPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getPolicy(
    {abortSignal, ...params}: RequestConfig & GetPolicyRequest,
  ): Promise<GetPolicyResponse> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getProvisionedConcurrencyConfig(
    {abortSignal, ...params}: RequestConfig & GetProvisionedConcurrencyConfigRequest,
  ): Promise<GetProvisionedConcurrencyConfigResponse> {
    const query = new URLSearchParams;
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetProvisionedConcurrencyConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RequestedProvisionedConcurrentExecutions": "n",
        "AvailableProvisionedConcurrentExecutions": "n",
        "AllocatedProvisionedConcurrentExecutions": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ProvisionedConcurrencyStatusEnum>(x),
        "StatusReason": "s",
        "LastModified": "s",
      },
    }, await resp.json());
  }

  async invoke(
    {abortSignal, ...params}: RequestConfig & InvocationRequest,
  ): Promise<InvocationResponse> {
    const body = typeof params["Payload"] === 'string' ? new TextEncoder().encode(params["Payload"]) : params["Payload"];
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["InvocationType"] != null) headers.append("X-Amz-Invocation-Type", params["InvocationType"]);
    if (params["LogType"] != null) headers.append("X-Amz-Log-Type", params["LogType"]);
    if (params["ClientContext"] != null) headers.append("X-Amz-Client-Context", params["ClientContext"]);
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, headers, query, body,
      action: "Invoke",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/invocations`,
    });
  return {
    StatusCode: resp.status,
    FunctionError: resp.headers.get("X-Amz-Function-Error"),
    LogResult: resp.headers.get("X-Amz-Log-Result"),
    ExecutedVersion: resp.headers.get("X-Amz-Executed-Version"),
    Payload: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async invokeAsync(
    {abortSignal, ...params}: RequestConfig & InvokeAsyncRequest,
  ): Promise<InvokeAsyncResponse> {
    const body = typeof params["InvokeArgs"] === 'string' ? new TextEncoder().encode(params["InvokeArgs"]) : params["InvokeArgs"];
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "InvokeAsync",
      requestUri: cmnP.encodePath`/2014-11-13/functions/${params["FunctionName"]}/invoke-async/`,
      responseCode: 202,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
    };
  }

  async listAliases(
    {abortSignal, ...params}: RequestConfig & ListAliasesRequest,
  ): Promise<ListAliasesResponse> {
    const query = new URLSearchParams;
    if (params["FunctionVersion"] != null) query.set("FunctionVersion", params["FunctionVersion"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Aliases": [toAliasConfiguration],
      },
    }, await resp.json());
  }

  async listEventSourceMappings(
    {abortSignal, ...params}: RequestConfig & ListEventSourceMappingsRequest = {},
  ): Promise<ListEventSourceMappingsResponse> {
    const query = new URLSearchParams;
    if (params["EventSourceArn"] != null) query.set("EventSourceArn", params["EventSourceArn"]?.toString() ?? "");
    if (params["FunctionName"] != null) query.set("FunctionName", params["FunctionName"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListEventSourceMappings",
      method: "GET",
      requestUri: "/2015-03-31/event-source-mappings/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "EventSourceMappings": [toEventSourceMappingConfiguration],
      },
    }, await resp.json());
  }

  async listFunctionEventInvokeConfigs(
    {abortSignal, ...params}: RequestConfig & ListFunctionEventInvokeConfigsRequest,
  ): Promise<ListFunctionEventInvokeConfigsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFunctionEventInvokeConfigs",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config/list`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionEventInvokeConfigs": [toFunctionEventInvokeConfig],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listFunctions(
    {abortSignal, ...params}: RequestConfig & ListFunctionsRequest = {},
  ): Promise<ListFunctionsResponse> {
    const query = new URLSearchParams;
    if (params["MasterRegion"] != null) query.set("MasterRegion", params["MasterRegion"]?.toString() ?? "");
    if (params["FunctionVersion"] != null) query.set("FunctionVersion", params["FunctionVersion"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFunctions",
      method: "GET",
      requestUri: "/2015-03-31/functions/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Functions": [toFunctionConfiguration],
      },
    }, await resp.json());
  }

  async listLayerVersions(
    {abortSignal, ...params}: RequestConfig & ListLayerVersionsRequest,
  ): Promise<ListLayerVersionsResponse> {
    const query = new URLSearchParams;
    if (params["CompatibleRuntime"] != null) query.set("CompatibleRuntime", params["CompatibleRuntime"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListLayerVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "LayerVersions": [toLayerVersionsListItem],
      },
    }, await resp.json());
  }

  async listLayers(
    {abortSignal, ...params}: RequestConfig & ListLayersRequest = {},
  ): Promise<ListLayersResponse> {
    const query = new URLSearchParams;
    if (params["CompatibleRuntime"] != null) query.set("CompatibleRuntime", params["CompatibleRuntime"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListLayers",
      method: "GET",
      requestUri: "/2018-10-31/layers",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Layers": [toLayersListItem],
      },
    }, await resp.json());
  }

  async listProvisionedConcurrencyConfigs(
    {abortSignal, ...params}: RequestConfig & ListProvisionedConcurrencyConfigsRequest,
  ): Promise<ListProvisionedConcurrencyConfigsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListProvisionedConcurrencyConfigs",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency?List=ALL`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProvisionedConcurrencyConfigs": [toProvisionedConcurrencyConfigListItem],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & ListTagsRequest,
  ): Promise<ListTagsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTags",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listVersionsByFunction(
    {abortSignal, ...params}: RequestConfig & ListVersionsByFunctionRequest,
  ): Promise<ListVersionsByFunctionResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListVersionsByFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/versions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Versions": [toFunctionConfiguration],
      },
    }, await resp.json());
  }

  async publishLayerVersion(
    {abortSignal, ...params}: RequestConfig & PublishLayerVersionRequest,
  ): Promise<PublishLayerVersionResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Content: fromLayerVersionContentInput(params["Content"]),
      CompatibleRuntimes: params["CompatibleRuntimes"],
      LicenseInfo: params["LicenseInfo"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PublishLayerVersion",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async publishVersion(
    {abortSignal, ...params}: RequestConfig & PublishVersionRequest,
  ): Promise<FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      CodeSha256: params["CodeSha256"],
      Description: params["Description"],
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PublishVersion",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
      },
    }, await resp.json());
  }

  async putFunctionConcurrency(
    {abortSignal, ...params}: RequestConfig & PutFunctionConcurrencyRequest,
  ): Promise<Concurrency> {
    const body: jsonP.JSONObject = {
      ReservedConcurrentExecutions: params["ReservedConcurrentExecutions"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutFunctionConcurrency",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-10-31/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedConcurrentExecutions": "n",
      },
    }, await resp.json());
  }

  async putFunctionEventInvokeConfig(
    {abortSignal, ...params}: RequestConfig & PutFunctionEventInvokeConfigRequest,
  ): Promise<FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      MaximumEventAgeInSeconds: params["MaximumEventAgeInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutFunctionEventInvokeConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  async putProvisionedConcurrencyConfig(
    {abortSignal, ...params}: RequestConfig & PutProvisionedConcurrencyConfigRequest,
  ): Promise<PutProvisionedConcurrencyConfigResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      ProvisionedConcurrentExecutions: params["ProvisionedConcurrentExecutions"],
    };
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutProvisionedConcurrencyConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RequestedProvisionedConcurrentExecutions": "n",
        "AvailableProvisionedConcurrentExecutions": "n",
        "AllocatedProvisionedConcurrentExecutions": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ProvisionedConcurrencyStatusEnum>(x),
        "StatusReason": "s",
        "LastModified": "s",
      },
    }, await resp.json());
  }

  async removeLayerVersionPermission(
    {abortSignal, ...params}: RequestConfig & RemoveLayerVersionPermissionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "RemoveLayerVersionPermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy/${params["StatementId"]}`,
      responseCode: 204,
    });
  }

  async removePermission(
    {abortSignal, ...params}: RequestConfig & RemovePermissionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "RemovePermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy/${params["StatementId"]}`,
      responseCode: 204,
    });
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
      responseCode: 204,
    });
  }

  async updateAlias(
    {abortSignal, ...params}: RequestConfig & UpdateAliasRequest,
  ): Promise<AliasConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionVersion: params["FunctionVersion"],
      Description: params["Description"],
      RoutingConfig: fromAliasRoutingConfiguration(params["RoutingConfig"]),
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async updateEventSourceMapping(
    {abortSignal, ...params}: RequestConfig & UpdateEventSourceMappingRequest,
  ): Promise<EventSourceMappingConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionName: params["FunctionName"],
      Enabled: params["Enabled"],
      BatchSize: params["BatchSize"],
      MaximumBatchingWindowInSeconds: params["MaximumBatchingWindowInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
      MaximumRecordAgeInSeconds: params["MaximumRecordAgeInSeconds"],
      BisectBatchOnFunctionError: params["BisectBatchOnFunctionError"],
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      ParallelizationFactor: params["ParallelizationFactor"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEventSourceMapping",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
      },
    }, await resp.json());
  }

  async updateFunctionCode(
    {abortSignal, ...params}: RequestConfig & UpdateFunctionCodeRequest,
  ): Promise<FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      ZipFile: jsonP.serializeBlob(params["ZipFile"]),
      S3Bucket: params["S3Bucket"],
      S3Key: params["S3Key"],
      S3ObjectVersion: params["S3ObjectVersion"],
      Publish: params["Publish"],
      DryRun: params["DryRun"],
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFunctionCode",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/code`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
      },
    }, await resp.json());
  }

  async updateFunctionConfiguration(
    {abortSignal, ...params}: RequestConfig & UpdateFunctionConfigurationRequest,
  ): Promise<FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      Role: params["Role"],
      Handler: params["Handler"],
      Description: params["Description"],
      Timeout: params["Timeout"],
      MemorySize: params["MemorySize"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      Environment: fromEnvironment(params["Environment"]),
      Runtime: params["Runtime"],
      DeadLetterConfig: fromDeadLetterConfig(params["DeadLetterConfig"]),
      KMSKeyArn: params["KMSKeyArn"],
      TracingConfig: fromTracingConfig(params["TracingConfig"]),
      RevisionId: params["RevisionId"],
      Layers: params["Layers"],
      FileSystemConfigs: params["FileSystemConfigs"]?.map(x => fromFileSystemConfig(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateFunctionConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
      },
    }, await resp.json());
  }

  async updateFunctionEventInvokeConfig(
    {abortSignal, ...params}: RequestConfig & UpdateFunctionEventInvokeConfigRequest,
  ): Promise<FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      MaximumEventAgeInSeconds: params["MaximumEventAgeInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateFunctionEventInvokeConfig",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForFunctionExists(
    params: RequestConfig & GetFunctionRequest,
  ): Promise<GetFunctionResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getFunction(params);
        return resp; // for status 200
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /**
   * Waits for the function's State to be Active.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForFunctionActive(
    params: RequestConfig & GetFunctionConfigurationRequest,
  ): Promise<FunctionConfiguration> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionActive';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getFunctionConfiguration(params);
      const field = resp?.State;
      if (field === "Active") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "Pending") continue;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Waits for the function's LastUpdateStatus to be Successful.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForFunctionUpdated(
    params: RequestConfig & GetFunctionConfigurationRequest,
  ): Promise<FunctionConfiguration> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionUpdated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getFunctionConfiguration(params);
      const field = resp?.LastUpdateStatus;
      if (field === "Successful") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "InProgress") continue;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddLayerVersionPermissionRequest {
  LayerName: string;
  VersionNumber: number;
  StatementId: string;
  Action: string;
  Principal: string;
  OrganizationId?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface AddPermissionRequest {
  FunctionName: string;
  StatementId: string;
  Action: string;
  Principal: string;
  SourceArn?: string | null;
  SourceAccount?: string | null;
  EventSourceToken?: string | null;
  Qualifier?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateAliasRequest {
  FunctionName: string;
  Name: string;
  FunctionVersion: string;
  Description?: string | null;
  RoutingConfig?: AliasRoutingConfiguration | null;
}

// refs: 1 - tags: named, input
export interface CreateEventSourceMappingRequest {
  EventSourceArn: string;
  FunctionName: string;
  Enabled?: boolean | null;
  BatchSize?: number | null;
  MaximumBatchingWindowInSeconds?: number | null;
  ParallelizationFactor?: number | null;
  StartingPosition?: EventSourcePosition | null;
  StartingPositionTimestamp?: Date | number | null;
  DestinationConfig?: DestinationConfig | null;
  MaximumRecordAgeInSeconds?: number | null;
  BisectBatchOnFunctionError?: boolean | null;
  MaximumRetryAttempts?: number | null;
  Topics?: string[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFunctionRequest {
  FunctionName: string;
  Runtime: Runtime;
  Role: string;
  Handler: string;
  Code: FunctionCode;
  Description?: string | null;
  Timeout?: number | null;
  MemorySize?: number | null;
  Publish?: boolean | null;
  VpcConfig?: VpcConfig | null;
  DeadLetterConfig?: DeadLetterConfig | null;
  Environment?: Environment | null;
  KMSKeyArn?: string | null;
  TracingConfig?: TracingConfig | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Layers?: string[] | null;
  FileSystemConfigs?: FileSystemConfig[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAliasRequest {
  FunctionName: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface DeleteEventSourceMappingRequest {
  UUID: string;
}

// refs: 1 - tags: named, input
export interface DeleteFunctionRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteFunctionConcurrencyRequest {
  FunctionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteFunctionEventInvokeConfigRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteLayerVersionRequest {
  LayerName: string;
  VersionNumber: number;
}

// refs: 1 - tags: named, input
export interface DeleteProvisionedConcurrencyConfigRequest {
  FunctionName: string;
  Qualifier: string;
}

// refs: 1 - tags: named, input
export interface GetAccountSettingsRequest {
}

// refs: 1 - tags: named, input
export interface GetAliasRequest {
  FunctionName: string;
  Name: string;
}

// refs: 1 - tags: named, input
export interface GetEventSourceMappingRequest {
  UUID: string;
}

// refs: 1 - tags: named, input
export interface GetFunctionRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface GetFunctionConcurrencyRequest {
  FunctionName: string;
}

// refs: 1 - tags: named, input
export interface GetFunctionConfigurationRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface GetFunctionEventInvokeConfigRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface GetLayerVersionRequest {
  LayerName: string;
  VersionNumber: number;
}

// refs: 1 - tags: named, input
export interface GetLayerVersionByArnRequest {
  Arn: string;
}

// refs: 1 - tags: named, input
export interface GetLayerVersionPolicyRequest {
  LayerName: string;
  VersionNumber: number;
}

// refs: 1 - tags: named, input
export interface GetPolicyRequest {
  FunctionName: string;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface GetProvisionedConcurrencyConfigRequest {
  FunctionName: string;
  Qualifier: string;
}

// refs: 1 - tags: named, input
export interface InvocationRequest {
  FunctionName: string;
  InvocationType?: InvocationType | null;
  LogType?: LogType | null;
  ClientContext?: string | null;
  Payload?: Uint8Array | string | null;
  Qualifier?: string | null;
}

// refs: 1 - tags: named, input
export interface InvokeAsyncRequest {
  FunctionName: string;
  InvokeArgs: Uint8Array | string;
}

// refs: 1 - tags: named, input
export interface ListAliasesRequest {
  FunctionName: string;
  FunctionVersion?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListEventSourceMappingsRequest {
  EventSourceArn?: string | null;
  FunctionName?: string | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListFunctionEventInvokeConfigsRequest {
  FunctionName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListFunctionsRequest {
  MasterRegion?: string | null;
  FunctionVersion?: FunctionVersion | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListLayerVersionsRequest {
  CompatibleRuntime?: Runtime | null;
  LayerName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListLayersRequest {
  CompatibleRuntime?: Runtime | null;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListProvisionedConcurrencyConfigsRequest {
  FunctionName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsRequest {
  Resource: string;
}

// refs: 1 - tags: named, input
export interface ListVersionsByFunctionRequest {
  FunctionName: string;
  Marker?: string | null;
  MaxItems?: number | null;
}

// refs: 1 - tags: named, input
export interface PublishLayerVersionRequest {
  LayerName: string;
  Description?: string | null;
  Content: LayerVersionContentInput;
  CompatibleRuntimes?: Runtime[] | null;
  LicenseInfo?: string | null;
}

// refs: 1 - tags: named, input
export interface PublishVersionRequest {
  FunctionName: string;
  CodeSha256?: string | null;
  Description?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface PutFunctionConcurrencyRequest {
  FunctionName: string;
  ReservedConcurrentExecutions: number;
}

// refs: 1 - tags: named, input
export interface PutFunctionEventInvokeConfigRequest {
  FunctionName: string;
  Qualifier?: string | null;
  MaximumRetryAttempts?: number | null;
  MaximumEventAgeInSeconds?: number | null;
  DestinationConfig?: DestinationConfig | null;
}

// refs: 1 - tags: named, input
export interface PutProvisionedConcurrencyConfigRequest {
  FunctionName: string;
  Qualifier: string;
  ProvisionedConcurrentExecutions: number;
}

// refs: 1 - tags: named, input
export interface RemoveLayerVersionPermissionRequest {
  LayerName: string;
  VersionNumber: number;
  StatementId: string;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface RemovePermissionRequest {
  FunctionName: string;
  StatementId: string;
  Qualifier?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  Resource: string;
  Tags: { [key: string]: string | null | undefined };
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  Resource: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateAliasRequest {
  FunctionName: string;
  Name: string;
  FunctionVersion?: string | null;
  Description?: string | null;
  RoutingConfig?: AliasRoutingConfiguration | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateEventSourceMappingRequest {
  UUID: string;
  FunctionName?: string | null;
  Enabled?: boolean | null;
  BatchSize?: number | null;
  MaximumBatchingWindowInSeconds?: number | null;
  DestinationConfig?: DestinationConfig | null;
  MaximumRecordAgeInSeconds?: number | null;
  BisectBatchOnFunctionError?: boolean | null;
  MaximumRetryAttempts?: number | null;
  ParallelizationFactor?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateFunctionCodeRequest {
  FunctionName: string;
  ZipFile?: Uint8Array | string | null;
  S3Bucket?: string | null;
  S3Key?: string | null;
  S3ObjectVersion?: string | null;
  Publish?: boolean | null;
  DryRun?: boolean | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateFunctionConfigurationRequest {
  FunctionName: string;
  Role?: string | null;
  Handler?: string | null;
  Description?: string | null;
  Timeout?: number | null;
  MemorySize?: number | null;
  VpcConfig?: VpcConfig | null;
  Environment?: Environment | null;
  Runtime?: Runtime | null;
  DeadLetterConfig?: DeadLetterConfig | null;
  KMSKeyArn?: string | null;
  TracingConfig?: TracingConfig | null;
  RevisionId?: string | null;
  Layers?: string[] | null;
  FileSystemConfigs?: FileSystemConfig[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateFunctionEventInvokeConfigRequest {
  FunctionName: string;
  Qualifier?: string | null;
  MaximumRetryAttempts?: number | null;
  MaximumEventAgeInSeconds?: number | null;
  DestinationConfig?: DestinationConfig | null;
}

// refs: 1 - tags: named, output
export interface AddLayerVersionPermissionResponse {
  Statement?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, output
export interface AddPermissionResponse {
  Statement?: string | null;
}

// refs: 2 - tags: named, output, interface
export interface AliasConfiguration {
  AliasArn?: string | null;
  Name?: string | null;
  FunctionVersion?: string | null;
  Description?: string | null;
  RoutingConfig?: AliasRoutingConfiguration | null;
  RevisionId?: string | null;
}
function toAliasConfiguration(root: jsonP.JSONValue): AliasConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasArn": "s",
      "Name": "s",
      "FunctionVersion": "s",
      "Description": "s",
      "RoutingConfig": toAliasRoutingConfiguration,
      "RevisionId": "s",
    },
  }, root);
}

// refs: 2 - tags: named, output, interface
export interface EventSourceMappingConfiguration {
  UUID?: string | null;
  BatchSize?: number | null;
  MaximumBatchingWindowInSeconds?: number | null;
  ParallelizationFactor?: number | null;
  EventSourceArn?: string | null;
  FunctionArn?: string | null;
  LastModified?: Date | number | null;
  LastProcessingResult?: string | null;
  State?: string | null;
  StateTransitionReason?: string | null;
  DestinationConfig?: DestinationConfig | null;
  Topics?: string[] | null;
  MaximumRecordAgeInSeconds?: number | null;
  BisectBatchOnFunctionError?: boolean | null;
  MaximumRetryAttempts?: number | null;
}
function toEventSourceMappingConfiguration(root: jsonP.JSONValue): EventSourceMappingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "UUID": "s",
      "BatchSize": "n",
      "MaximumBatchingWindowInSeconds": "n",
      "ParallelizationFactor": "n",
      "EventSourceArn": "s",
      "FunctionArn": "s",
      "LastModified": "d",
      "LastProcessingResult": "s",
      "State": "s",
      "StateTransitionReason": "s",
      "DestinationConfig": toDestinationConfig,
      "Topics": ["s"],
      "MaximumRecordAgeInSeconds": "n",
      "BisectBatchOnFunctionError": "b",
      "MaximumRetryAttempts": "n",
    },
  }, root);
}

// refs: 4 - tags: named, output, interface
export interface FunctionConfiguration {
  FunctionName?: string | null;
  FunctionArn?: string | null;
  Runtime?: Runtime | null;
  Role?: string | null;
  Handler?: string | null;
  CodeSize?: number | null;
  Description?: string | null;
  Timeout?: number | null;
  MemorySize?: number | null;
  LastModified?: string | null;
  CodeSha256?: string | null;
  Version?: string | null;
  VpcConfig?: VpcConfigResponse | null;
  DeadLetterConfig?: DeadLetterConfig | null;
  Environment?: EnvironmentResponse | null;
  KMSKeyArn?: string | null;
  TracingConfig?: TracingConfigResponse | null;
  MasterArn?: string | null;
  RevisionId?: string | null;
  Layers?: Layer[] | null;
  State?: State | null;
  StateReason?: string | null;
  StateReasonCode?: StateReasonCode | null;
  LastUpdateStatus?: LastUpdateStatus | null;
  LastUpdateStatusReason?: string | null;
  LastUpdateStatusReasonCode?: LastUpdateStatusReasonCode | null;
  FileSystemConfigs?: FileSystemConfig[] | null;
}
function toFunctionConfiguration(root: jsonP.JSONValue): FunctionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionName": "s",
      "FunctionArn": "s",
      "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x),
      "Role": "s",
      "Handler": "s",
      "CodeSize": "n",
      "Description": "s",
      "Timeout": "n",
      "MemorySize": "n",
      "LastModified": "s",
      "CodeSha256": "s",
      "Version": "s",
      "VpcConfig": toVpcConfigResponse,
      "DeadLetterConfig": toDeadLetterConfig,
      "Environment": toEnvironmentResponse,
      "KMSKeyArn": "s",
      "TracingConfig": toTracingConfigResponse,
      "MasterArn": "s",
      "RevisionId": "s",
      "Layers": [toLayer],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<State>(x),
      "StateReason": "s",
      "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<StateReasonCode>(x),
      "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatus>(x),
      "LastUpdateStatusReason": "s",
      "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<LastUpdateStatusReasonCode>(x),
      "FileSystemConfigs": [toFileSystemConfig],
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface GetAccountSettingsResponse {
  AccountLimit?: AccountLimit | null;
  AccountUsage?: AccountUsage | null;
}

// refs: 1 - tags: named, output
export interface GetFunctionResponse {
  Configuration?: FunctionConfiguration | null;
  Code?: FunctionCodeLocation | null;
  Tags?: { [key: string]: string | null | undefined } | null;
  Concurrency?: Concurrency | null;
}

// refs: 1 - tags: named, output
export interface GetFunctionConcurrencyResponse {
  ReservedConcurrentExecutions?: number | null;
}

// refs: 2 - tags: named, output, interface
export interface FunctionEventInvokeConfig {
  LastModified?: Date | number | null;
  FunctionArn?: string | null;
  MaximumRetryAttempts?: number | null;
  MaximumEventAgeInSeconds?: number | null;
  DestinationConfig?: DestinationConfig | null;
}
function toFunctionEventInvokeConfig(root: jsonP.JSONValue): FunctionEventInvokeConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastModified": "d",
      "FunctionArn": "s",
      "MaximumRetryAttempts": "n",
      "MaximumEventAgeInSeconds": "n",
      "DestinationConfig": toDestinationConfig,
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface GetLayerVersionResponse {
  Content?: LayerVersionContentOutput | null;
  LayerArn?: string | null;
  LayerVersionArn?: string | null;
  Description?: string | null;
  CreatedDate?: string | null;
  Version?: number | null;
  CompatibleRuntimes?: Runtime[] | null;
  LicenseInfo?: string | null;
}

// refs: 1 - tags: named, output
export interface GetLayerVersionPolicyResponse {
  Policy?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPolicyResponse {
  Policy?: string | null;
  RevisionId?: string | null;
}

// refs: 1 - tags: named, output
export interface GetProvisionedConcurrencyConfigResponse {
  RequestedProvisionedConcurrentExecutions?: number | null;
  AvailableProvisionedConcurrentExecutions?: number | null;
  AllocatedProvisionedConcurrentExecutions?: number | null;
  Status?: ProvisionedConcurrencyStatusEnum | null;
  StatusReason?: string | null;
  LastModified?: string | null;
}

// refs: 1 - tags: named, output
export interface InvocationResponse {
  StatusCode?: number | null;
  FunctionError?: string | null;
  LogResult?: string | null;
  Payload?: Uint8Array | string | null;
  ExecutedVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface InvokeAsyncResponse {
  Status?: number | null;
}

// refs: 1 - tags: named, output
export interface ListAliasesResponse {
  NextMarker?: string | null;
  Aliases?: AliasConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface ListEventSourceMappingsResponse {
  NextMarker?: string | null;
  EventSourceMappings?: EventSourceMappingConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface ListFunctionEventInvokeConfigsResponse {
  FunctionEventInvokeConfigs?: FunctionEventInvokeConfig[] | null;
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFunctionsResponse {
  NextMarker?: string | null;
  Functions?: FunctionConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface ListLayerVersionsResponse {
  NextMarker?: string | null;
  LayerVersions?: LayerVersionsListItem[] | null;
}

// refs: 1 - tags: named, output
export interface ListLayersResponse {
  NextMarker?: string | null;
  Layers?: LayersListItem[] | null;
}

// refs: 1 - tags: named, output
export interface ListProvisionedConcurrencyConfigsResponse {
  ProvisionedConcurrencyConfigs?: ProvisionedConcurrencyConfigListItem[] | null;
  NextMarker?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsResponse {
  Tags?: { [key: string]: string | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface ListVersionsByFunctionResponse {
  NextMarker?: string | null;
  Versions?: FunctionConfiguration[] | null;
}

// refs: 1 - tags: named, output
export interface PublishLayerVersionResponse {
  Content?: LayerVersionContentOutput | null;
  LayerArn?: string | null;
  LayerVersionArn?: string | null;
  Description?: string | null;
  CreatedDate?: string | null;
  Version?: number | null;
  CompatibleRuntimes?: Runtime[] | null;
  LicenseInfo?: string | null;
}

// refs: 2 - tags: output, named, interface
export interface Concurrency {
  ReservedConcurrentExecutions?: number | null;
}
function toConcurrency(root: jsonP.JSONValue): Concurrency {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservedConcurrentExecutions": "n",
    },
  }, root);
}

// refs: 1 - tags: named, output
export interface PutProvisionedConcurrencyConfigResponse {
  RequestedProvisionedConcurrentExecutions?: number | null;
  AvailableProvisionedConcurrentExecutions?: number | null;
  AllocatedProvisionedConcurrentExecutions?: number | null;
  Status?: ProvisionedConcurrencyStatusEnum | null;
  StatusReason?: string | null;
  LastModified?: string | null;
}

// refs: 4 - tags: input, named, interface, output
export interface AliasRoutingConfiguration {
  AdditionalVersionWeights?: { [key: string]: number | null | undefined } | null;
}
function fromAliasRoutingConfiguration(input?: AliasRoutingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdditionalVersionWeights: input["AdditionalVersionWeights"],
  }
}
function toAliasRoutingConfiguration(root: jsonP.JSONValue): AliasRoutingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalVersionWeights": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

// refs: 1 - tags: input, named, enum
export type EventSourcePosition =
| "TRIM_HORIZON"
| "LATEST"
| "AT_TIMESTAMP"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface DestinationConfig {
  OnSuccess?: OnSuccess | null;
  OnFailure?: OnFailure | null;
}
function fromDestinationConfig(input?: DestinationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OnSuccess: fromOnSuccess(input["OnSuccess"]),
    OnFailure: fromOnFailure(input["OnFailure"]),
  }
}
function toDestinationConfig(root: jsonP.JSONValue): DestinationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnSuccess": toOnSuccess,
      "OnFailure": toOnFailure,
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface OnSuccess {
  Destination?: string | null;
}
function fromOnSuccess(input?: OnSuccess | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Destination: input["Destination"],
  }
}
function toOnSuccess(root: jsonP.JSONValue): OnSuccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface OnFailure {
  Destination?: string | null;
}
function fromOnFailure(input?: OnFailure | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Destination: input["Destination"],
  }
}
function toOnFailure(root: jsonP.JSONValue): OnFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
    },
  }, root);
}

// refs: 13 - tags: input, named, enum, output
export type Runtime =
| "nodejs"
| "nodejs4.3"
| "nodejs6.10"
| "nodejs8.10"
| "nodejs10.x"
| "nodejs12.x"
| "java8"
| "java8.al2"
| "java11"
| "python2.7"
| "python3.6"
| "python3.7"
| "python3.8"
| "dotnetcore1.0"
| "dotnetcore2.0"
| "dotnetcore2.1"
| "dotnetcore3.1"
| "nodejs4.3-edge"
| "go1.x"
| "ruby2.5"
| "ruby2.7"
| "provided"
| "provided.al2"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface FunctionCode {
  ZipFile?: Uint8Array | string | null;
  S3Bucket?: string | null;
  S3Key?: string | null;
  S3ObjectVersion?: string | null;
}
function fromFunctionCode(input?: FunctionCode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ZipFile: jsonP.serializeBlob(input["ZipFile"]),
    S3Bucket: input["S3Bucket"],
    S3Key: input["S3Key"],
    S3ObjectVersion: input["S3ObjectVersion"],
  }
}

// refs: 2 - tags: input, named, interface
export interface VpcConfig {
  SubnetIds?: string[] | null;
  SecurityGroupIds?: string[] | null;
}
function fromVpcConfig(input?: VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

// refs: 6 - tags: input, named, interface, output
export interface DeadLetterConfig {
  TargetArn?: string | null;
}
function fromDeadLetterConfig(input?: DeadLetterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetArn: input["TargetArn"],
  }
}
function toDeadLetterConfig(root: jsonP.JSONValue): DeadLetterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface Environment {
  Variables?: { [key: string]: string | null | undefined } | null;
}
function fromEnvironment(input?: Environment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Variables: input["Variables"],
  }
}

// refs: 2 - tags: input, named, interface
export interface TracingConfig {
  Mode?: TracingMode | null;
}
function fromTracingConfig(input?: TracingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Mode: input["Mode"],
  }
}

// refs: 6 - tags: input, named, enum, output
export type TracingMode =
| "Active"
| "PassThrough"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface FileSystemConfig {
  Arn: string;
  LocalMountPath: string;
}
function fromFileSystemConfig(input?: FileSystemConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    LocalMountPath: input["LocalMountPath"],
  }
}
function toFileSystemConfig(root: jsonP.JSONValue): FileSystemConfig {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "LocalMountPath": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: input, named, enum
export type InvocationType =
| "Event"
| "RequestResponse"
| "DryRun"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type LogType =
| "None"
| "Tail"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type FunctionVersion =
| "ALL"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface LayerVersionContentInput {
  S3Bucket?: string | null;
  S3Key?: string | null;
  S3ObjectVersion?: string | null;
  ZipFile?: Uint8Array | string | null;
}
function fromLayerVersionContentInput(input?: LayerVersionContentInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Bucket: input["S3Bucket"],
    S3Key: input["S3Key"],
    S3ObjectVersion: input["S3ObjectVersion"],
    ZipFile: jsonP.serializeBlob(input["ZipFile"]),
  }
}

// refs: 4 - tags: output, named, interface
export interface VpcConfigResponse {
  SubnetIds?: string[] | null;
  SecurityGroupIds?: string[] | null;
  VpcId?: string | null;
}
function toVpcConfigResponse(root: jsonP.JSONValue): VpcConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIds": ["s"],
      "SecurityGroupIds": ["s"],
      "VpcId": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface EnvironmentResponse {
  Variables?: { [key: string]: string | null | undefined } | null;
  Error?: EnvironmentError | null;
}
function toEnvironmentResponse(root: jsonP.JSONValue): EnvironmentResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Variables": x => jsonP.readMap(String, String, x),
      "Error": toEnvironmentError,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface EnvironmentError {
  ErrorCode?: string | null;
  Message?: string | null;
}
function toEnvironmentError(root: jsonP.JSONValue): EnvironmentError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface TracingConfigResponse {
  Mode?: TracingMode | null;
}
function toTracingConfigResponse(root: jsonP.JSONValue): TracingConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<TracingMode>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Layer {
  Arn?: string | null;
  CodeSize?: number | null;
}
function toLayer(root: jsonP.JSONValue): Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CodeSize": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type State =
| "Pending"
| "Active"
| "Inactive"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type StateReasonCode =
| "Idle"
| "Creating"
| "Restoring"
| "EniLimitExceeded"
| "InsufficientRolePermissions"
| "InvalidConfiguration"
| "InternalError"
| "SubnetOutOfIPAddresses"
| "InvalidSubnet"
| "InvalidSecurityGroup"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type LastUpdateStatus =
| "Successful"
| "Failed"
| "InProgress"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type LastUpdateStatusReasonCode =
| "EniLimitExceeded"
| "InsufficientRolePermissions"
| "InvalidConfiguration"
| "InternalError"
| "SubnetOutOfIPAddresses"
| "InvalidSubnet"
| "InvalidSecurityGroup"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AccountLimit {
  TotalCodeSize?: number | null;
  CodeSizeUnzipped?: number | null;
  CodeSizeZipped?: number | null;
  ConcurrentExecutions?: number | null;
  UnreservedConcurrentExecutions?: number | null;
}
function toAccountLimit(root: jsonP.JSONValue): AccountLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCodeSize": "n",
      "CodeSizeUnzipped": "n",
      "CodeSizeZipped": "n",
      "ConcurrentExecutions": "n",
      "UnreservedConcurrentExecutions": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AccountUsage {
  TotalCodeSize?: number | null;
  FunctionCount?: number | null;
}
function toAccountUsage(root: jsonP.JSONValue): AccountUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCodeSize": "n",
      "FunctionCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FunctionCodeLocation {
  RepositoryType?: string | null;
  Location?: string | null;
}
function toFunctionCodeLocation(root: jsonP.JSONValue): FunctionCodeLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "RepositoryType": "s",
      "Location": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LayerVersionContentOutput {
  Location?: string | null;
  CodeSha256?: string | null;
  CodeSize?: number | null;
}
function toLayerVersionContentOutput(root: jsonP.JSONValue): LayerVersionContentOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Location": "s",
      "CodeSha256": "s",
      "CodeSize": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type ProvisionedConcurrencyStatusEnum =
| "IN_PROGRESS"
| "READY"
| "FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface LayerVersionsListItem {
  LayerVersionArn?: string | null;
  Version?: number | null;
  Description?: string | null;
  CreatedDate?: string | null;
  CompatibleRuntimes?: Runtime[] | null;
  LicenseInfo?: string | null;
}
function toLayerVersionsListItem(root: jsonP.JSONValue): LayerVersionsListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerVersionArn": "s",
      "Version": "n",
      "Description": "s",
      "CreatedDate": "s",
      "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<Runtime>(x)],
      "LicenseInfo": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LayersListItem {
  LayerName?: string | null;
  LayerArn?: string | null;
  LatestMatchingVersion?: LayerVersionsListItem | null;
}
function toLayersListItem(root: jsonP.JSONValue): LayersListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerName": "s",
      "LayerArn": "s",
      "LatestMatchingVersion": toLayerVersionsListItem,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ProvisionedConcurrencyConfigListItem {
  FunctionArn?: string | null;
  RequestedProvisionedConcurrentExecutions?: number | null;
  AvailableProvisionedConcurrentExecutions?: number | null;
  AllocatedProvisionedConcurrentExecutions?: number | null;
  Status?: ProvisionedConcurrencyStatusEnum | null;
  StatusReason?: string | null;
  LastModified?: string | null;
}
function toProvisionedConcurrencyConfigListItem(root: jsonP.JSONValue): ProvisionedConcurrencyConfigListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionArn": "s",
      "RequestedProvisionedConcurrentExecutions": "n",
      "AvailableProvisionedConcurrentExecutions": "n",
      "AllocatedProvisionedConcurrentExecutions": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<ProvisionedConcurrencyStatusEnum>(x),
      "StatusReason": "s",
      "LastModified": "s",
    },
  }, root);
}
