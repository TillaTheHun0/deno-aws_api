// Autogenerated API client for: AWS Health APIs and Notifications

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Health {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Health.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-08-04",
    "endpointPrefix": "health",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWSHealth",
    "serviceFullName": "AWS Health APIs and Notifications",
    "serviceId": "Health",
    "signatureVersion": "v4",
    "targetPrefix": "AWSHealth_20160804",
    "uid": "health-2016-08-04"
  };

  async describeAffectedAccountsForOrganization(
    {abortSignal, ...params}: RequestConfig & s.DescribeAffectedAccountsForOrganizationRequest,
  ): Promise<s.DescribeAffectedAccountsForOrganizationResponse> {
    const body: jsonP.JSONObject = {
      eventArn: params["eventArn"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAffectedAccountsForOrganization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "affectedAccounts": ["s"],
        "eventScopeCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventScopeCode>(x),
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeAffectedEntities(
    {abortSignal, ...params}: RequestConfig & s.DescribeAffectedEntitiesRequest,
  ): Promise<s.DescribeAffectedEntitiesResponse> {
    const body: jsonP.JSONObject = {
      filter: fromEntityFilter(params["filter"]),
      locale: params["locale"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAffectedEntities",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entities": [toAffectedEntity],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeAffectedEntitiesForOrganization(
    {abortSignal, ...params}: RequestConfig & s.DescribeAffectedEntitiesForOrganizationRequest,
  ): Promise<s.DescribeAffectedEntitiesForOrganizationResponse> {
    const body: jsonP.JSONObject = {
      organizationEntityFilters: params["organizationEntityFilters"]?.map(x => fromEventAccountFilter(x)),
      locale: params["locale"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAffectedEntitiesForOrganization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entities": [toAffectedEntity],
        "failedSet": [toOrganizationAffectedEntitiesErrorItem],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeEntityAggregates(
    {abortSignal, ...params}: RequestConfig & s.DescribeEntityAggregatesRequest = {},
  ): Promise<s.DescribeEntityAggregatesResponse> {
    const body: jsonP.JSONObject = {
      eventArns: params["eventArns"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEntityAggregates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "entityAggregates": [toEntityAggregate],
      },
    }, await resp.json());
  }

  async describeEventAggregates(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventAggregatesRequest,
  ): Promise<s.DescribeEventAggregatesResponse> {
    const body: jsonP.JSONObject = {
      filter: fromEventFilter(params["filter"]),
      aggregateField: params["aggregateField"],
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventAggregates",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventAggregates": [toEventAggregate],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeEventDetails(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventDetailsRequest,
  ): Promise<s.DescribeEventDetailsResponse> {
    const body: jsonP.JSONObject = {
      eventArns: params["eventArns"],
      locale: params["locale"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventDetails",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulSet": [toEventDetails],
        "failedSet": [toEventDetailsErrorItem],
      },
    }, await resp.json());
  }

  async describeEventDetailsForOrganization(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventDetailsForOrganizationRequest,
  ): Promise<s.DescribeEventDetailsForOrganizationResponse> {
    const body: jsonP.JSONObject = {
      organizationEventDetailFilters: params["organizationEventDetailFilters"]?.map(x => fromEventAccountFilter(x)),
      locale: params["locale"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventDetailsForOrganization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulSet": [toOrganizationEventDetails],
        "failedSet": [toOrganizationEventDetailsErrorItem],
      },
    }, await resp.json());
  }

  async describeEventTypes(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventTypesRequest = {},
  ): Promise<s.DescribeEventTypesResponse> {
    const body: jsonP.JSONObject = {
      filter: fromEventTypeFilter(params["filter"]),
      locale: params["locale"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventTypes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "eventTypes": [toEventType],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeEvents(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsRequest = {},
  ): Promise<s.DescribeEventsResponse> {
    const body: jsonP.JSONObject = {
      filter: fromEventFilter(params["filter"]),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      locale: params["locale"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEvents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "events": [toEvent],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeEventsForOrganization(
    {abortSignal, ...params}: RequestConfig & s.DescribeEventsForOrganizationRequest = {},
  ): Promise<s.DescribeEventsForOrganizationResponse> {
    const body: jsonP.JSONObject = {
      filter: fromOrganizationEventFilter(params["filter"]),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      locale: params["locale"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEventsForOrganization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "events": [toOrganizationEvent],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeHealthServiceStatusForOrganization(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<s.DescribeHealthServiceStatusForOrganizationResponse> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DescribeHealthServiceStatusForOrganization",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "healthServiceAccessStatusForOrganization": "s",
      },
    }, await resp.json());
  }

  async disableHealthServiceAccessForOrganization(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<void> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DisableHealthServiceAccessForOrganization",
    });
  }

  async enableHealthServiceAccessForOrganization(
    {abortSignal, ...params}: RequestConfig = {},
  ): Promise<void> {
    const resp = await this.#client.performRequest({
      abortSignal,
      action: "EnableHealthServiceAccessForOrganization",
    });
  }

}

function fromEntityFilter(input?: s.EntityFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventArns: input["eventArns"],
    entityArns: input["entityArns"],
    entityValues: input["entityValues"],
    lastUpdatedTimes: input["lastUpdatedTimes"]?.map(x => fromDateTimeRange(x)),
    tags: input["tags"],
    statusCodes: input["statusCodes"],
  }
}

function fromDateTimeRange(input?: s.DateTimeRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    from: jsonP.serializeDate_unixTimestamp(input["from"]),
    to: jsonP.serializeDate_unixTimestamp(input["to"]),
  }
}

function fromEventAccountFilter(input?: s.EventAccountFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventArn: input["eventArn"],
    awsAccountId: input["awsAccountId"],
  }
}

function fromEventFilter(input?: s.EventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventArns: input["eventArns"],
    eventTypeCodes: input["eventTypeCodes"],
    services: input["services"],
    regions: input["regions"],
    availabilityZones: input["availabilityZones"],
    startTimes: input["startTimes"]?.map(x => fromDateTimeRange(x)),
    endTimes: input["endTimes"]?.map(x => fromDateTimeRange(x)),
    lastUpdatedTimes: input["lastUpdatedTimes"]?.map(x => fromDateTimeRange(x)),
    entityArns: input["entityArns"],
    entityValues: input["entityValues"],
    eventTypeCategories: input["eventTypeCategories"],
    tags: input["tags"],
    eventStatusCodes: input["eventStatusCodes"],
  }
}

function fromEventTypeFilter(input?: s.EventTypeFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventTypeCodes: input["eventTypeCodes"],
    services: input["services"],
    eventTypeCategories: input["eventTypeCategories"],
  }
}

function fromOrganizationEventFilter(input?: s.OrganizationEventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    eventTypeCodes: input["eventTypeCodes"],
    awsAccountIds: input["awsAccountIds"],
    services: input["services"],
    regions: input["regions"],
    startTime: fromDateTimeRange(input["startTime"]),
    endTime: fromDateTimeRange(input["endTime"]),
    lastUpdatedTime: fromDateTimeRange(input["lastUpdatedTime"]),
    entityArns: input["entityArns"],
    entityValues: input["entityValues"],
    eventTypeCategories: input["eventTypeCategories"],
    eventStatusCodes: input["eventStatusCodes"],
  }
}

function toAffectedEntity(root: jsonP.JSONValue): s.AffectedEntity {
  return jsonP.readObj({
    required: {},
    optional: {
      "entityArn": "s",
      "eventArn": "s",
      "entityValue": "s",
      "entityUrl": "s",
      "awsAccountId": "s",
      "lastUpdatedTime": "d",
      "statusCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.entityStatusCode>(x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toOrganizationAffectedEntitiesErrorItem(root: jsonP.JSONValue): s.OrganizationAffectedEntitiesErrorItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsAccountId": "s",
      "eventArn": "s",
      "errorName": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toEntityAggregate(root: jsonP.JSONValue): s.EntityAggregate {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventArn": "s",
      "count": "n",
    },
  }, root);
}

function toEventAggregate(root: jsonP.JSONValue): s.EventAggregate {
  return jsonP.readObj({
    required: {},
    optional: {
      "aggregateValue": "s",
      "count": "n",
    },
  }, root);
}

function toEventDetails(root: jsonP.JSONValue): s.EventDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "event": toEvent,
      "eventDescription": toEventDescription,
      "eventMetadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toEvent(root: jsonP.JSONValue): s.Event {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "service": "s",
      "eventTypeCode": "s",
      "eventTypeCategory": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventTypeCategory>(x),
      "region": "s",
      "availabilityZone": "s",
      "startTime": "d",
      "endTime": "d",
      "lastUpdatedTime": "d",
      "statusCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventStatusCode>(x),
      "eventScopeCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventScopeCode>(x),
    },
  }, root);
}

function toEventDescription(root: jsonP.JSONValue): s.EventDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "latestDescription": "s",
    },
  }, root);
}

function toEventDetailsErrorItem(root: jsonP.JSONValue): s.EventDetailsErrorItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "eventArn": "s",
      "errorName": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toOrganizationEventDetails(root: jsonP.JSONValue): s.OrganizationEventDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsAccountId": "s",
      "event": toEvent,
      "eventDescription": toEventDescription,
      "eventMetadata": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toOrganizationEventDetailsErrorItem(root: jsonP.JSONValue): s.OrganizationEventDetailsErrorItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsAccountId": "s",
      "eventArn": "s",
      "errorName": "s",
      "errorMessage": "s",
    },
  }, root);
}

function toEventType(root: jsonP.JSONValue): s.EventType {
  return jsonP.readObj({
    required: {},
    optional: {
      "service": "s",
      "code": "s",
      "category": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventTypeCategory>(x),
    },
  }, root);
}

function toOrganizationEvent(root: jsonP.JSONValue): s.OrganizationEvent {
  return jsonP.readObj({
    required: {},
    optional: {
      "arn": "s",
      "service": "s",
      "eventTypeCode": "s",
      "eventTypeCategory": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventTypeCategory>(x),
      "eventScopeCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventScopeCode>(x),
      "region": "s",
      "startTime": "d",
      "endTime": "d",
      "lastUpdatedTime": "d",
      "statusCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.eventStatusCode>(x),
    },
  }, root);
}
