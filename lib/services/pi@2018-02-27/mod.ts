// Autogenerated API client for: AWS Performance Insights

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import { JSONObject, JSONValue } from '../../encoding/json.ts';
import * as prt from "../../encoding/json.ts";

export default class PI {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(PI.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-02-27",
    "endpointPrefix": "pi",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWS PI",
    "serviceFullName": "AWS Performance Insights",
    "serviceId": "PI",
    "signatureVersion": "v4",
    "signingName": "pi",
    "targetPrefix": "PerformanceInsightsv20180227",
    "uid": "pi-2018-02-27"
  };

  async describeDimensionKeys(
    {abortSignal, ...params}: RequestConfig & DescribeDimensionKeysRequest,
  ): Promise<DescribeDimensionKeysResponse> {
    const body: JSONObject = {...params,
    StartTime: prt.serializeDate_unixTimestamp(params["StartTime"]),
    EndTime: prt.serializeDate_unixTimestamp(params["EndTime"]),
    GroupBy: fromDimensionGroup(params["GroupBy"]),
    PartitionBy: fromDimensionGroup(params["PartitionBy"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDimensionKeys",
    });
    return prt.readObj({
      required: {},
      optional: {
        "AlignedStartTime": "d",
        "AlignedEndTime": "d",
        "PartitionKeys": [toResponsePartitionKey],
        "Keys": [toDimensionKeyDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getResourceMetrics(
    {abortSignal, ...params}: RequestConfig & GetResourceMetricsRequest,
  ): Promise<GetResourceMetricsResponse> {
    const body: JSONObject = {...params,
    MetricQueries: params["MetricQueries"]?.map(x => fromMetricQuery(x)),
    StartTime: prt.serializeDate_unixTimestamp(params["StartTime"]),
    EndTime: prt.serializeDate_unixTimestamp(params["EndTime"]),
  };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourceMetrics",
    });
    return prt.readObj({
      required: {},
      optional: {
        "AlignedStartTime": "d",
        "AlignedEndTime": "d",
        "Identifier": "s",
        "MetricList": [toMetricKeyDataPoints],
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface DescribeDimensionKeysRequest {
  ServiceType: ServiceType;
  Identifier: string;
  StartTime: Date | number;
  EndTime: Date | number;
  Metric: string;
  PeriodInSeconds?: number | null;
  GroupBy: DimensionGroup;
  PartitionBy?: DimensionGroup | null;
  Filter?: { [key: string]: string } | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetResourceMetricsRequest {
  ServiceType: ServiceType;
  Identifier: string;
  MetricQueries: MetricQuery[];
  StartTime: Date | number;
  EndTime: Date | number;
  PeriodInSeconds?: number | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeDimensionKeysResponse {
  AlignedStartTime?: Date | number | null;
  AlignedEndTime?: Date | number | null;
  PartitionKeys?: ResponsePartitionKey[] | null;
  Keys?: DimensionKeyDescription[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface GetResourceMetricsResponse {
  AlignedStartTime?: Date | number | null;
  AlignedEndTime?: Date | number | null;
  Identifier?: string | null;
  MetricList?: MetricKeyDataPoints[] | null;
  NextToken?: string | null;
}

// refs: 2 - tags: input, named, enum
export type ServiceType =
| "RDS"
;


// refs: 3 - tags: input, named, interface
export interface DimensionGroup {
  Group: string;
  Dimensions?: string[] | null;
  Limit?: number | null;
}
function fromDimensionGroup(input?: DimensionGroup | null): JSONValue {
  if (!input) return input;
  return {...input,
  }
}

// refs: 1 - tags: input, named, interface
export interface MetricQuery {
  Metric: string;
  GroupBy?: DimensionGroup | null;
  Filter?: { [key: string]: string } | null;
}
function fromMetricQuery(input?: MetricQuery | null): JSONValue {
  if (!input) return input;
  return {...input,
    GroupBy: fromDimensionGroup(input["GroupBy"]),
  }
}

// refs: 1 - tags: output, named, interface
export interface ResponsePartitionKey {
  Dimensions: { [key: string]: string };
}
function toResponsePartitionKey(root: JSONValue): ResponsePartitionKey {
  return prt.readObj({
    required: {
      "Dimensions": x => prt.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DimensionKeyDescription {
  Dimensions?: { [key: string]: string } | null;
  Total?: number | null;
  Partitions?: number[] | null;
}
function toDimensionKeyDescription(root: JSONValue): DimensionKeyDescription {
  return prt.readObj({
    required: {},
    optional: {
      "Dimensions": x => prt.readMap(String, String, x),
      "Total": "n",
      "Partitions": ["n"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MetricKeyDataPoints {
  Key?: ResponseResourceMetricKey | null;
  DataPoints?: DataPoint[] | null;
}
function toMetricKeyDataPoints(root: JSONValue): MetricKeyDataPoints {
  return prt.readObj({
    required: {},
    optional: {
      "Key": toResponseResourceMetricKey,
      "DataPoints": [toDataPoint],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResponseResourceMetricKey {
  Metric: string;
  Dimensions?: { [key: string]: string } | null;
}
function toResponseResourceMetricKey(root: JSONValue): ResponseResourceMetricKey {
  return prt.readObj({
    required: {
      "Metric": "s",
    },
    optional: {
      "Dimensions": x => prt.readMap(String, String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DataPoint {
  Timestamp: Date | number;
  Value: number;
}
function toDataPoint(root: JSONValue): DataPoint {
  return prt.readObj({
    required: {
      "Timestamp": "d",
      "Value": "n",
    },
    optional: {},
  }, root);
}
