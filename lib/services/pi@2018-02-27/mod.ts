// Autogenerated API client for: AWS Performance Insights

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class PI {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(PI.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-02-27",
    "endpointPrefix": "pi",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "AWS PI",
    "serviceFullName": "AWS Performance Insights",
    "serviceId": "PI",
    "signatureVersion": "v4",
    "signingName": "pi",
    "targetPrefix": "PerformanceInsightsv20180227",
    "uid": "pi-2018-02-27"
  };

  async describeDimensionKeys(
    {abortSignal, ...params}: RequestConfig & s.DescribeDimensionKeysRequest,
  ): Promise<s.DescribeDimensionKeysResponse> {
    const body: jsonP.JSONObject = {
      ServiceType: params["ServiceType"],
      Identifier: params["Identifier"],
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Metric: params["Metric"],
      PeriodInSeconds: params["PeriodInSeconds"],
      GroupBy: fromDimensionGroup(params["GroupBy"]),
      PartitionBy: fromDimensionGroup(params["PartitionBy"]),
      Filter: params["Filter"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDimensionKeys",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AlignedStartTime": "d",
        "AlignedEndTime": "d",
        "PartitionKeys": [toResponsePartitionKey],
        "Keys": [toDimensionKeyDescription],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async getResourceMetrics(
    {abortSignal, ...params}: RequestConfig & s.GetResourceMetricsRequest,
  ): Promise<s.GetResourceMetricsResponse> {
    const body: jsonP.JSONObject = {
      ServiceType: params["ServiceType"],
      Identifier: params["Identifier"],
      MetricQueries: params["MetricQueries"]?.map(x => fromMetricQuery(x)),
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      PeriodInSeconds: params["PeriodInSeconds"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetResourceMetrics",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AlignedStartTime": "d",
        "AlignedEndTime": "d",
        "Identifier": "s",
        "MetricList": [toMetricKeyDataPoints],
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

function fromDimensionGroup(input?: s.DimensionGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Group: input["Group"],
    Dimensions: input["Dimensions"],
    Limit: input["Limit"],
  }
}

function fromMetricQuery(input?: s.MetricQuery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Metric: input["Metric"],
    GroupBy: fromDimensionGroup(input["GroupBy"]),
    Filter: input["Filter"],
  }
}

function toResponsePartitionKey(root: jsonP.JSONValue): s.ResponsePartitionKey {
  return jsonP.readObj({
    required: {
      "Dimensions": x => jsonP.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

function toDimensionKeyDescription(root: jsonP.JSONValue): s.DimensionKeyDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "Dimensions": x => jsonP.readMap(String, String, x),
      "Total": "n",
      "Partitions": ["n"],
    },
  }, root);
}

function toMetricKeyDataPoints(root: jsonP.JSONValue): s.MetricKeyDataPoints {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": toResponseResourceMetricKey,
      "DataPoints": [toDataPoint],
    },
  }, root);
}

function toResponseResourceMetricKey(root: jsonP.JSONValue): s.ResponseResourceMetricKey {
  return jsonP.readObj({
    required: {
      "Metric": "s",
    },
    optional: {
      "Dimensions": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toDataPoint(root: jsonP.JSONValue): s.DataPoint {
  return jsonP.readObj({
    required: {
      "Timestamp": "d",
      "Value": "n",
    },
    optional: {},
  }, root);
}
