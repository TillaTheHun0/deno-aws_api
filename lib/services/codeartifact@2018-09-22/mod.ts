// Autogenerated API client for: CodeArtifact

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class CodeArtifact {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeArtifact.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2018-09-22",
    "endpointPrefix": "codeartifact",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "CodeArtifact",
    "serviceId": "codeartifact",
    "signatureVersion": "v4",
    "signingName": "codeartifact",
    "uid": "codeartifact-2018-09-22"
  };

  async associateExternalConnection(
    {abortSignal, ...params}: RequestConfig & s.AssociateExternalConnectionRequest,
  ): Promise<s.AssociateExternalConnectionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("external-connection", params["externalConnection"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "AssociateExternalConnection",
      requestUri: "/v1/repository/external-connection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

  async copyPackageVersions(
    {abortSignal, ...params}: RequestConfig & s.CopyPackageVersionsRequest,
  ): Promise<s.CopyPackageVersionsResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      allowOverwrite: params["allowOverwrite"],
      includeFromUpstream: params["includeFromUpstream"],
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("source-repository", params["sourceRepository"]?.toString() ?? "");
    query.set("destination-repository", params["destinationRepository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CopyPackageVersions",
      requestUri: "/v1/package/versions/copy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
        "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
      },
    }, await resp.json());
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<s.CreateDomainResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      encryptionKey: params["encryptionKey"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateDomain",
      requestUri: "/v1/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domain": toDomainDescription,
      },
    }, await resp.json());
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & s.CreateRepositoryRequest,
  ): Promise<s.CreateRepositoryResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      description: params["description"],
      upstreams: params["upstreams"]?.map(x => fromUpstreamRepository(x)),
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateRepository",
      requestUri: "/v1/repository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<s.DeleteDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDomain",
      method: "DELETE",
      requestUri: "/v1/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domain": toDomainDescription,
      },
    }, await resp.json());
  }

  async deleteDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainPermissionsPolicyRequest,
  ): Promise<s.DeleteDomainPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["policyRevision"] != null) query.set("policy-revision", params["policyRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDomainPermissionsPolicy",
      method: "DELETE",
      requestUri: "/v1/domain/permissions/policy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async deletePackageVersions(
    {abortSignal, ...params}: RequestConfig & s.DeletePackageVersionsRequest,
  ): Promise<s.DeletePackageVersionsResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      versions: params["versions"],
      expectedStatus: params["expectedStatus"],
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "DeletePackageVersions",
      requestUri: "/v1/package/versions/delete",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
        "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
      },
    }, await resp.json());
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & s.DeleteRepositoryRequest,
  ): Promise<s.DeleteRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRepository",
      method: "DELETE",
      requestUri: "/v1/repository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

  async deleteRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteRepositoryPermissionsPolicyRequest,
  ): Promise<s.DeleteRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    if (params["policyRevision"] != null) query.set("policy-revision", params["policyRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRepositoryPermissionsPolicy",
      method: "DELETE",
      requestUri: "/v1/repository/permissions/policies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async describeDomain(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainRequest,
  ): Promise<s.DescribeDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDomain",
      method: "GET",
      requestUri: "/v1/domain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domain": toDomainDescription,
      },
    }, await resp.json());
  }

  async describePackageVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribePackageVersionRequest,
  ): Promise<s.DescribePackageVersionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribePackageVersion",
      method: "GET",
      requestUri: "/v1/package/version",
    });
    return jsonP.readObj({
      required: {
        "packageVersion": toPackageVersionDescription,
      },
      optional: {},
    }, await resp.json());
  }

  async describeRepository(
    {abortSignal, ...params}: RequestConfig & s.DescribeRepositoryRequest,
  ): Promise<s.DescribeRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRepository",
      method: "GET",
      requestUri: "/v1/repository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

  async disassociateExternalConnection(
    {abortSignal, ...params}: RequestConfig & s.DisassociateExternalConnectionRequest,
  ): Promise<s.DisassociateExternalConnectionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("external-connection", params["externalConnection"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DisassociateExternalConnection",
      method: "DELETE",
      requestUri: "/v1/repository/external-connection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

  async disposePackageVersions(
    {abortSignal, ...params}: RequestConfig & s.DisposePackageVersionsRequest,
  ): Promise<s.DisposePackageVersionsResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      expectedStatus: params["expectedStatus"],
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "DisposePackageVersions",
      requestUri: "/v1/package/versions/dispose",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
        "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
      },
    }, await resp.json());
  }

  async getAuthorizationToken(
    {abortSignal, ...params}: RequestConfig & s.GetAuthorizationTokenRequest,
  ): Promise<s.GetAuthorizationTokenResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["durationSeconds"] != null) query.set("duration", params["durationSeconds"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAuthorizationToken",
      requestUri: "/v1/authorization-token",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizationToken": "s",
        "expiration": "d",
      },
    }, await resp.json());
  }

  async getDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetDomainPermissionsPolicyRequest,
  ): Promise<s.GetDomainPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDomainPermissionsPolicy",
      method: "GET",
      requestUri: "/v1/domain/permissions/policy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async getPackageVersionAsset(
    {abortSignal, ...params}: RequestConfig & s.GetPackageVersionAssetRequest,
  ): Promise<s.GetPackageVersionAssetResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    query.set("asset", params["asset"]?.toString() ?? "");
    if (params["packageVersionRevision"] != null) query.set("revision", params["packageVersionRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPackageVersionAsset",
      method: "GET",
      requestUri: "/v1/package/version/asset",
    });
  return {
    assetName: resp.headers.get("X-AssetName"),
    packageVersion: resp.headers.get("X-PackageVersion"),
    packageVersionRevision: resp.headers.get("X-PackageVersionRevision"),
    asset: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getPackageVersionReadme(
    {abortSignal, ...params}: RequestConfig & s.GetPackageVersionReadmeRequest,
  ): Promise<s.GetPackageVersionReadmeResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPackageVersionReadme",
      method: "GET",
      requestUri: "/v1/package/version/readme",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
        "namespace": "s",
        "package": "s",
        "version": "s",
        "versionRevision": "s",
        "readme": "s",
      },
    }, await resp.json());
  }

  async getRepositoryEndpoint(
    {abortSignal, ...params}: RequestConfig & s.GetRepositoryEndpointRequest,
  ): Promise<s.GetRepositoryEndpointResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRepositoryEndpoint",
      method: "GET",
      requestUri: "/v1/repository/endpoint",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryEndpoint": "s",
      },
    }, await resp.json());
  }

  async getRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetRepositoryPermissionsPolicyRequest,
  ): Promise<s.GetRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRepositoryPermissionsPolicy",
      method: "GET",
      requestUri: "/v1/repository/permissions/policy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & s.ListDomainsRequest = {},
  ): Promise<s.ListDomainsResult> {
    const body: jsonP.JSONObject = {
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
      requestUri: "/v1/domains",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "domains": [toDomainSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPackageVersionAssets(
    {abortSignal, ...params}: RequestConfig & s.ListPackageVersionAssetsRequest,
  ): Promise<s.ListPackageVersionAssetsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersionAssets",
      requestUri: "/v1/package/version/assets",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
        "namespace": "s",
        "package": "s",
        "version": "s",
        "versionRevision": "s",
        "nextToken": "s",
        "assets": [toAssetSummary],
      },
    }, await resp.json());
  }

  async listPackageVersionDependencies(
    {abortSignal, ...params}: RequestConfig & s.ListPackageVersionDependenciesRequest,
  ): Promise<s.ListPackageVersionDependenciesResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersionDependencies",
      requestUri: "/v1/package/version/dependencies",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
        "namespace": "s",
        "package": "s",
        "version": "s",
        "versionRevision": "s",
        "nextToken": "s",
        "dependencies": [toPackageDependency],
      },
    }, await resp.json());
  }

  async listPackageVersions(
    {abortSignal, ...params}: RequestConfig & s.ListPackageVersionsRequest,
  ): Promise<s.ListPackageVersionsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["sortBy"] != null) query.set("sortBy", params["sortBy"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersions",
      requestUri: "/v1/package/versions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "defaultDisplayVersion": "s",
        "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
        "namespace": "s",
        "package": "s",
        "versions": [toPackageVersionSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listPackages(
    {abortSignal, ...params}: RequestConfig & s.ListPackagesRequest,
  ): Promise<s.ListPackagesResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    if (params["format"] != null) query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    if (params["packagePrefix"] != null) query.set("package-prefix", params["packagePrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackages",
      requestUri: "/v1/packages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "packages": [toPackageSummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositories(
    {abortSignal, ...params}: RequestConfig & s.ListRepositoriesRequest = {},
  ): Promise<s.ListRepositoriesResult> {
    const query = new URLSearchParams;
    if (params["repositoryPrefix"] != null) query.set("repository-prefix", params["repositoryPrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRepositories",
      requestUri: "/v1/repositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositorySummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listRepositoriesInDomain(
    {abortSignal, ...params}: RequestConfig & s.ListRepositoriesInDomainRequest,
  ): Promise<s.ListRepositoriesInDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["administratorAccount"] != null) query.set("administrator-account", params["administratorAccount"]?.toString() ?? "");
    if (params["repositoryPrefix"] != null) query.set("repository-prefix", params["repositoryPrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRepositoriesInDomain",
      requestUri: "/v1/domain/repositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepositorySummary],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const query = new URLSearchParams;
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource",
      requestUri: "/v1/tags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutDomainPermissionsPolicyRequest,
  ): Promise<s.PutDomainPermissionsPolicyResult> {
    const body: jsonP.JSONObject = {
      domain: params["domain"],
      domainOwner: params["domainOwner"],
      policyRevision: params["policyRevision"],
      policyDocument: params["policyDocument"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDomainPermissionsPolicy",
      method: "PUT",
      requestUri: "/v1/domain/permissions/policy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async putRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutRepositoryPermissionsPolicyRequest,
  ): Promise<s.PutRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      policyRevision: params["policyRevision"],
      policyDocument: params["policyDocument"],
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutRepositoryPermissionsPolicy",
      method: "PUT",
      requestUri: "/v1/repository/permissions/policy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "policy": toResourcePolicy,
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<s.TagResourceResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource",
      requestUri: "/v1/tag",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<s.UntagResourceResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      tagKeys: params["tagKeys"],
    };
    query.set("resourceArn", params["resourceArn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource",
      requestUri: "/v1/untag",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updatePackageVersionsStatus(
    {abortSignal, ...params}: RequestConfig & s.UpdatePackageVersionsStatusRequest,
  ): Promise<s.UpdatePackageVersionsStatusResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      expectedStatus: params["expectedStatus"],
      targetStatus: params["targetStatus"],
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdatePackageVersionsStatus",
      requestUri: "/v1/package/versions/update_status",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
        "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
      },
    }, await resp.json());
  }

  async updateRepository(
    {abortSignal, ...params}: RequestConfig & s.UpdateRepositoryRequest,
  ): Promise<s.UpdateRepositoryResult> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      description: params["description"],
      upstreams: params["upstreams"]?.map(x => fromUpstreamRepository(x)),
    };
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateRepository",
      method: "PUT",
      requestUri: "/v1/repository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepositoryDescription,
      },
    }, await resp.json());
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromUpstreamRepository(input?: s.UpstreamRepository | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repositoryName: input["repositoryName"],
  }
}

function toRepositoryDescription(root: jsonP.JSONValue): s.RepositoryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "administratorAccount": "s",
      "domainName": "s",
      "domainOwner": "s",
      "arn": "s",
      "description": "s",
      "upstreams": [toUpstreamRepositoryInfo],
      "externalConnections": [toRepositoryExternalConnectionInfo],
    },
  }, root);
}

function toUpstreamRepositoryInfo(root: jsonP.JSONValue): s.UpstreamRepositoryInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
    },
  }, root);
}

function toRepositoryExternalConnectionInfo(root: jsonP.JSONValue): s.RepositoryExternalConnectionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "externalConnectionName": "s",
      "packageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExternalConnectionStatus>(x),
    },
  }, root);
}

function toSuccessfulPackageVersionInfo(root: jsonP.JSONValue): s.SuccessfulPackageVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "revision": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageVersionStatus>(x),
    },
  }, root);
}

function toPackageVersionError(root: jsonP.JSONValue): s.PackageVersionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageVersionErrorCode>(x),
      "errorMessage": "s",
    },
  }, root);
}

function toDomainDescription(root: jsonP.JSONValue): s.DomainDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "owner": "s",
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatus>(x),
      "createdTime": "d",
      "encryptionKey": "s",
      "repositoryCount": "n",
      "assetSizeBytes": "n",
      "s3BucketArn": "s",
    },
  }, root);
}

function toResourcePolicy(root: jsonP.JSONValue): s.ResourcePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceArn": "s",
      "revision": "s",
      "document": "s",
    },
  }, root);
}

function toPackageVersionDescription(root: jsonP.JSONValue): s.PackageVersionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
      "namespace": "s",
      "packageName": "s",
      "displayName": "s",
      "version": "s",
      "summary": "s",
      "homePage": "s",
      "sourceCodeRepository": "s",
      "publishedTime": "d",
      "licenses": [toLicenseInfo],
      "revision": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageVersionStatus>(x),
    },
  }, root);
}

function toLicenseInfo(root: jsonP.JSONValue): s.LicenseInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "url": "s",
    },
  }, root);
}

function toDomainSummary(root: jsonP.JSONValue): s.DomainSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "owner": "s",
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatus>(x),
      "createdTime": "d",
      "encryptionKey": "s",
    },
  }, root);
}

function toAssetSummary(root: jsonP.JSONValue): s.AssetSummary {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "size": "n",
      "hashes": x => jsonP.readMap(x => cmnP.readEnumReq<s.HashAlgorithm>(x), String, x),
    },
  }, root);
}

function toPackageDependency(root: jsonP.JSONValue): s.PackageDependency {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "package": "s",
      "dependencyType": "s",
      "versionRequirement": "s",
    },
  }, root);
}

function toPackageVersionSummary(root: jsonP.JSONValue): s.PackageVersionSummary {
  return jsonP.readObj({
    required: {
      "version": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageVersionStatus>(x),
    },
    optional: {
      "revision": "s",
    },
  }, root);
}

function toPackageSummary(root: jsonP.JSONValue): s.PackageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageFormat>(x),
      "namespace": "s",
      "package": "s",
    },
  }, root);
}

function toRepositorySummary(root: jsonP.JSONValue): s.RepositorySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "administratorAccount": "s",
      "domainName": "s",
      "domainOwner": "s",
      "arn": "s",
      "description": "s",
    },
  }, root);
}
