// Autogenerated API client for: CodeArtifact

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class CodeArtifact {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CodeArtifact.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-09-22",
    "endpointPrefix": "codeartifact",
    "jsonVersion": "1.1",
    "protocol": "rest-json",
    "serviceFullName": "CodeArtifact",
    "serviceId": "codeartifact",
    "signatureVersion": "v4",
    "signingName": "codeartifact",
    "uid": "codeartifact-2018-09-22"
  };

  async associateExternalConnection(
    {abortSignal, ...params}: RequestConfig & AssociateExternalConnectionRequest,
  ): Promise<AssociateExternalConnectionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("external-connection", params["externalConnection"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "AssociateExternalConnection",
      requestUri: "/v1/repository/external-connection",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

  async copyPackageVersions(
    {abortSignal, ...params}: RequestConfig & CopyPackageVersionsRequest,
  ): Promise<CopyPackageVersionsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("source-repository", params["sourceRepository"]?.toString() ?? "");
    query.set("destination-repository", params["destinationRepository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      allowOverwrite: params["allowOverwrite"],
      includeFromUpstream: params["includeFromUpstream"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CopyPackageVersions",
      requestUri: "/v1/package/versions/copy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
          "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
        },
      }, await resp.json()),
  };
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & CreateDomainRequest,
  ): Promise<CreateDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      encryptionKey: params["encryptionKey"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateDomain",
      requestUri: "/v1/domain",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "domain": toDomainDescription,
        },
      }, await resp.json()),
  };
  }

  async createRepository(
    {abortSignal, ...params}: RequestConfig & CreateRepositoryRequest,
  ): Promise<CreateRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      upstreams: params["upstreams"]?.map(x => fromUpstreamRepository(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "CreateRepository",
      requestUri: "/v1/repository",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & DeleteDomainRequest,
  ): Promise<DeleteDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDomain",
      method: "DELETE",
      requestUri: "/v1/domain",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "domain": toDomainDescription,
        },
      }, await resp.json()),
  };
  }

  async deleteDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteDomainPermissionsPolicyRequest,
  ): Promise<DeleteDomainPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["policyRevision"] != null) query.set("policy-revision", params["policyRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteDomainPermissionsPolicy",
      method: "DELETE",
      requestUri: "/v1/domain/permissions/policy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async deletePackageVersions(
    {abortSignal, ...params}: RequestConfig & DeletePackageVersionsRequest,
  ): Promise<DeletePackageVersionsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      versions: params["versions"],
      expectedStatus: params["expectedStatus"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "DeletePackageVersions",
      requestUri: "/v1/package/versions/delete",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
          "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
        },
      }, await resp.json()),
  };
  }

  async deleteRepository(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryRequest,
  ): Promise<DeleteRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRepository",
      method: "DELETE",
      requestUri: "/v1/repository",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

  async deleteRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & DeleteRepositoryPermissionsPolicyRequest,
  ): Promise<DeleteRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    if (params["policyRevision"] != null) query.set("policy-revision", params["policyRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteRepositoryPermissionsPolicy",
      method: "DELETE",
      requestUri: "/v1/repository/permissions/policies",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async describeDomain(
    {abortSignal, ...params}: RequestConfig & DescribeDomainRequest,
  ): Promise<DescribeDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeDomain",
      method: "GET",
      requestUri: "/v1/domain",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "domain": toDomainDescription,
        },
      }, await resp.json()),
  };
  }

  async describePackageVersion(
    {abortSignal, ...params}: RequestConfig & DescribePackageVersionRequest,
  ): Promise<DescribePackageVersionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribePackageVersion",
      method: "GET",
      requestUri: "/v1/package/version",
    });
  return {
    ...jsonP.readObj({
        required: {
          "packageVersion": toPackageVersionDescription,
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async describeRepository(
    {abortSignal, ...params}: RequestConfig & DescribeRepositoryRequest,
  ): Promise<DescribeRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DescribeRepository",
      method: "GET",
      requestUri: "/v1/repository",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

  async disassociateExternalConnection(
    {abortSignal, ...params}: RequestConfig & DisassociateExternalConnectionRequest,
  ): Promise<DisassociateExternalConnectionResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("external-connection", params["externalConnection"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DisassociateExternalConnection",
      method: "DELETE",
      requestUri: "/v1/repository/external-connection",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

  async disposePackageVersions(
    {abortSignal, ...params}: RequestConfig & DisposePackageVersionsRequest,
  ): Promise<DisposePackageVersionsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      expectedStatus: params["expectedStatus"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "DisposePackageVersions",
      requestUri: "/v1/package/versions/dispose",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
          "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
        },
      }, await resp.json()),
  };
  }

  async getAuthorizationToken(
    {abortSignal, ...params}: RequestConfig & GetAuthorizationTokenRequest,
  ): Promise<GetAuthorizationTokenResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["durationSeconds"] != null) query.set("duration", params["durationSeconds"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetAuthorizationToken",
      requestUri: "/v1/authorization-token",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "authorizationToken": "s",
          "expiration": "d",
        },
      }, await resp.json()),
  };
  }

  async getDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & GetDomainPermissionsPolicyRequest,
  ): Promise<GetDomainPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetDomainPermissionsPolicy",
      method: "GET",
      requestUri: "/v1/domain/permissions/policy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async getPackageVersionAsset(
    {abortSignal, ...params}: RequestConfig & GetPackageVersionAssetRequest,
  ): Promise<GetPackageVersionAssetResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    query.set("asset", params["asset"]?.toString() ?? "");
    if (params["packageVersionRevision"] != null) query.set("revision", params["packageVersionRevision"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPackageVersionAsset",
      method: "GET",
      requestUri: "/v1/package/version/asset",
    });
  return {
    assetName: resp.headers.get("X-AssetName"),
    packageVersion: resp.headers.get("X-PackageVersion"),
    packageVersionRevision: resp.headers.get("X-PackageVersionRevision"),
    asset: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getPackageVersionReadme(
    {abortSignal, ...params}: RequestConfig & GetPackageVersionReadmeRequest,
  ): Promise<GetPackageVersionReadmeResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPackageVersionReadme",
      method: "GET",
      requestUri: "/v1/package/version/readme",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
          "namespace": "s",
          "package": "s",
          "version": "s",
          "versionRevision": "s",
          "readme": "s",
        },
      }, await resp.json()),
  };
  }

  async getRepositoryEndpoint(
    {abortSignal, ...params}: RequestConfig & GetRepositoryEndpointRequest,
  ): Promise<GetRepositoryEndpointResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRepositoryEndpoint",
      method: "GET",
      requestUri: "/v1/repository/endpoint",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repositoryEndpoint": "s",
        },
      }, await resp.json()),
  };
  }

  async getRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & GetRepositoryPermissionsPolicyRequest,
  ): Promise<GetRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRepositoryPermissionsPolicy",
      method: "GET",
      requestUri: "/v1/repository/permissions/policy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & ListDomainsRequest = {},
  ): Promise<ListDomainsResult> {
    const body: jsonP.JSONObject = params ? {
      maxResults: params["maxResults"],
      nextToken: params["nextToken"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
      requestUri: "/v1/domains",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "domains": [toDomainSummary],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPackageVersionAssets(
    {abortSignal, ...params}: RequestConfig & ListPackageVersionAssetsRequest,
  ): Promise<ListPackageVersionAssetsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersionAssets",
      requestUri: "/v1/package/version/assets",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
          "namespace": "s",
          "package": "s",
          "version": "s",
          "versionRevision": "s",
          "nextToken": "s",
          "assets": [toAssetSummary],
        },
      }, await resp.json()),
  };
  }

  async listPackageVersionDependencies(
    {abortSignal, ...params}: RequestConfig & ListPackageVersionDependenciesRequest,
  ): Promise<ListPackageVersionDependenciesResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    query.set("version", params["packageVersion"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersionDependencies",
      requestUri: "/v1/package/version/dependencies",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
          "namespace": "s",
          "package": "s",
          "version": "s",
          "versionRevision": "s",
          "nextToken": "s",
          "dependencies": [toPackageDependency],
        },
      }, await resp.json()),
  };
  }

  async listPackageVersions(
    {abortSignal, ...params}: RequestConfig & ListPackageVersionsRequest,
  ): Promise<ListPackageVersionsResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    if (params["status"] != null) query.set("status", params["status"]?.toString() ?? "");
    if (params["sortBy"] != null) query.set("sortBy", params["sortBy"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackageVersions",
      requestUri: "/v1/package/versions",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "defaultDisplayVersion": "s",
          "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
          "namespace": "s",
          "package": "s",
          "versions": [toPackageVersionSummary],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listPackages(
    {abortSignal, ...params}: RequestConfig & ListPackagesRequest,
  ): Promise<ListPackagesResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    if (params["format"] != null) query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    if (params["packagePrefix"] != null) query.set("package-prefix", params["packagePrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPackages",
      requestUri: "/v1/packages",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "packages": [toPackageSummary],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listRepositories(
    {abortSignal, ...params}: RequestConfig & ListRepositoriesRequest = {},
  ): Promise<ListRepositoriesResult> {
    const query = new URLSearchParams;
    if (params["repositoryPrefix"] != null) query.set("repository-prefix", params["repositoryPrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRepositories",
      requestUri: "/v1/repositories",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repositories": [toRepositorySummary],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listRepositoriesInDomain(
    {abortSignal, ...params}: RequestConfig & ListRepositoriesInDomainRequest,
  ): Promise<ListRepositoriesInDomainResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    if (params["administratorAccount"] != null) query.set("administrator-account", params["administratorAccount"]?.toString() ?? "");
    if (params["repositoryPrefix"] != null) query.set("repository-prefix", params["repositoryPrefix"]?.toString() ?? "");
    if (params["maxResults"] != null) query.set("max-results", params["maxResults"]?.toString() ?? "");
    if (params["nextToken"] != null) query.set("next-token", params["nextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRepositoriesInDomain",
      requestUri: "/v1/domain/repositories",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repositories": [toRepositorySummary],
          "nextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async putDomainPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & PutDomainPermissionsPolicyRequest,
  ): Promise<PutDomainPermissionsPolicyResult> {
    const body: jsonP.JSONObject = params ? {
      domain: params["domain"],
      domainOwner: params["domainOwner"],
      policyRevision: params["policyRevision"],
      policyDocument: params["policyDocument"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutDomainPermissionsPolicy",
      method: "PUT",
      requestUri: "/v1/domain/permissions/policy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async putRepositoryPermissionsPolicy(
    {abortSignal, ...params}: RequestConfig & PutRepositoryPermissionsPolicyRequest,
  ): Promise<PutRepositoryPermissionsPolicyResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      policyRevision: params["policyRevision"],
      policyDocument: params["policyDocument"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "PutRepositoryPermissionsPolicy",
      method: "PUT",
      requestUri: "/v1/repository/permissions/policy",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "policy": toResourcePolicy,
        },
      }, await resp.json()),
  };
  }

  async updatePackageVersionsStatus(
    {abortSignal, ...params}: RequestConfig & UpdatePackageVersionsStatusRequest,
  ): Promise<UpdatePackageVersionsStatusResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    query.set("format", params["format"]?.toString() ?? "");
    if (params["namespace"] != null) query.set("namespace", params["namespace"]?.toString() ?? "");
    query.set("package", params["package"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      versions: params["versions"],
      versionRevisions: params["versionRevisions"],
      expectedStatus: params["expectedStatus"],
      targetStatus: params["targetStatus"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdatePackageVersionsStatus",
      requestUri: "/v1/package/versions/update_status",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "successfulVersions": x => jsonP.readMap(String, toSuccessfulPackageVersionInfo, x),
          "failedVersions": x => jsonP.readMap(String, toPackageVersionError, x),
        },
      }, await resp.json()),
  };
  }

  async updateRepository(
    {abortSignal, ...params}: RequestConfig & UpdateRepositoryRequest,
  ): Promise<UpdateRepositoryResult> {
    const query = new URLSearchParams;
    query.set("domain", params["domain"]?.toString() ?? "");
    if (params["domainOwner"] != null) query.set("domain-owner", params["domainOwner"]?.toString() ?? "");
    query.set("repository", params["repository"]?.toString() ?? "");
    const body: jsonP.JSONObject = params ? {
      description: params["description"],
      upstreams: params["upstreams"]?.map(x => fromUpstreamRepository(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateRepository",
      method: "PUT",
      requestUri: "/v1/repository",
    });
  return {
    ...jsonP.readObj({
        required: {},
        optional: {
          "repository": toRepositoryDescription,
        },
      }, await resp.json()),
  };
  }

}

// refs: 1 - tags: named, input
export interface AssociateExternalConnectionRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  externalConnection: string;
}

// refs: 1 - tags: named, input
export interface CopyPackageVersionsRequest {
  domain: string;
  domainOwner?: string | null;
  sourceRepository: string;
  destinationRepository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  versions?: string[] | null;
  versionRevisions?: { [key: string]: string | null | undefined } | null;
  allowOverwrite?: boolean | null;
  includeFromUpstream?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateDomainRequest {
  domain: string;
  encryptionKey?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateRepositoryRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  description?: string | null;
  upstreams?: UpstreamRepository[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDomainRequest {
  domain: string;
  domainOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDomainPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
  policyRevision?: string | null;
}

// refs: 1 - tags: named, input
export interface DeletePackageVersionsRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  versions: string[];
  expectedStatus?: PackageVersionStatus | null;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
}

// refs: 1 - tags: named, input
export interface DeleteRepositoryPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  policyRevision?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribeDomainRequest {
  domain: string;
  domainOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface DescribePackageVersionRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  packageVersion: string;
}

// refs: 1 - tags: named, input
export interface DescribeRepositoryRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
}

// refs: 1 - tags: named, input
export interface DisassociateExternalConnectionRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  externalConnection: string;
}

// refs: 1 - tags: named, input
export interface DisposePackageVersionsRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  versions: string[];
  versionRevisions?: { [key: string]: string | null | undefined } | null;
  expectedStatus?: PackageVersionStatus | null;
}

// refs: 1 - tags: named, input
export interface GetAuthorizationTokenRequest {
  domain: string;
  domainOwner?: string | null;
  durationSeconds?: number | null;
}

// refs: 1 - tags: named, input
export interface GetDomainPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPackageVersionAssetRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  packageVersion: string;
  asset: string;
  packageVersionRevision?: string | null;
}

// refs: 1 - tags: named, input
export interface GetPackageVersionReadmeRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  packageVersion: string;
}

// refs: 1 - tags: named, input
export interface GetRepositoryEndpointRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
}

// refs: 1 - tags: named, input
export interface GetRepositoryPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
}

// refs: 1 - tags: named, input
export interface ListDomainsRequest {
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPackageVersionAssetsRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  packageVersion: string;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPackageVersionDependenciesRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  packageVersion: string;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPackageVersionsRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  status?: PackageVersionStatus | null;
  sortBy?: PackageVersionSortType | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPackagesRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format?: PackageFormat | null;
  namespace?: string | null;
  packagePrefix?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListRepositoriesRequest {
  repositoryPrefix?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListRepositoriesInDomainRequest {
  domain: string;
  domainOwner?: string | null;
  administratorAccount?: string | null;
  repositoryPrefix?: string | null;
  maxResults?: number | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface PutDomainPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
  policyRevision?: string | null;
  policyDocument: string;
}

// refs: 1 - tags: named, input
export interface PutRepositoryPermissionsPolicyRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  policyRevision?: string | null;
  policyDocument: string;
}

// refs: 1 - tags: named, input
export interface UpdatePackageVersionsStatusRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  format: PackageFormat;
  namespace?: string | null;
  package: string;
  versions: string[];
  versionRevisions?: { [key: string]: string | null | undefined } | null;
  expectedStatus?: PackageVersionStatus | null;
  targetStatus: PackageVersionStatus;
}

// refs: 1 - tags: named, input
export interface UpdateRepositoryRequest {
  domain: string;
  domainOwner?: string | null;
  repository: string;
  description?: string | null;
  upstreams?: UpstreamRepository[] | null;
}

// refs: 1 - tags: named, output
export interface AssociateExternalConnectionResult {
  repository?: RepositoryDescription | null;
}

// refs: 1 - tags: named, output
export interface CopyPackageVersionsResult {
  successfulVersions?: { [key: string]: SuccessfulPackageVersionInfo | null | undefined } | null;
  failedVersions?: { [key: string]: PackageVersionError | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface CreateDomainResult {
  domain?: DomainDescription | null;
}

// refs: 1 - tags: named, output
export interface CreateRepositoryResult {
  repository?: RepositoryDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteDomainResult {
  domain?: DomainDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteDomainPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface DeletePackageVersionsResult {
  successfulVersions?: { [key: string]: SuccessfulPackageVersionInfo | null | undefined } | null;
  failedVersions?: { [key: string]: PackageVersionError | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryResult {
  repository?: RepositoryDescription | null;
}

// refs: 1 - tags: named, output
export interface DeleteRepositoryPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface DescribeDomainResult {
  domain?: DomainDescription | null;
}

// refs: 1 - tags: named, output
export interface DescribePackageVersionResult {
  packageVersion: PackageVersionDescription;
}

// refs: 1 - tags: named, output
export interface DescribeRepositoryResult {
  repository?: RepositoryDescription | null;
}

// refs: 1 - tags: named, output
export interface DisassociateExternalConnectionResult {
  repository?: RepositoryDescription | null;
}

// refs: 1 - tags: named, output
export interface DisposePackageVersionsResult {
  successfulVersions?: { [key: string]: SuccessfulPackageVersionInfo | null | undefined } | null;
  failedVersions?: { [key: string]: PackageVersionError | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface GetAuthorizationTokenResult {
  authorizationToken?: string | null;
  expiration?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface GetDomainPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface GetPackageVersionAssetResult {
  asset?: Uint8Array | string | null;
  assetName?: string | null;
  packageVersion?: string | null;
  packageVersionRevision?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPackageVersionReadmeResult {
  format?: PackageFormat | null;
  namespace?: string | null;
  package?: string | null;
  version?: string | null;
  versionRevision?: string | null;
  readme?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryEndpointResult {
  repositoryEndpoint?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRepositoryPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface ListDomainsResult {
  domains?: DomainSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPackageVersionAssetsResult {
  format?: PackageFormat | null;
  namespace?: string | null;
  package?: string | null;
  version?: string | null;
  versionRevision?: string | null;
  nextToken?: string | null;
  assets?: AssetSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListPackageVersionDependenciesResult {
  format?: PackageFormat | null;
  namespace?: string | null;
  package?: string | null;
  version?: string | null;
  versionRevision?: string | null;
  nextToken?: string | null;
  dependencies?: PackageDependency[] | null;
}

// refs: 1 - tags: named, output
export interface ListPackageVersionsResult {
  defaultDisplayVersion?: string | null;
  format?: PackageFormat | null;
  namespace?: string | null;
  package?: string | null;
  versions?: PackageVersionSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListPackagesResult {
  packages?: PackageSummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRepositoriesResult {
  repositories?: RepositorySummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListRepositoriesInDomainResult {
  repositories?: RepositorySummary[] | null;
  nextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface PutDomainPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface PutRepositoryPermissionsPolicyResult {
  policy?: ResourcePolicy | null;
}

// refs: 1 - tags: named, output
export interface UpdatePackageVersionsStatusResult {
  successfulVersions?: { [key: string]: SuccessfulPackageVersionInfo | null | undefined } | null;
  failedVersions?: { [key: string]: PackageVersionError | null | undefined } | null;
}

// refs: 1 - tags: named, output
export interface UpdateRepositoryResult {
  repository?: RepositoryDescription | null;
}

// refs: 24 - tags: input, named, enum, output
export type PackageFormat =
| "npm"
| "pypi"
| "maven"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface UpstreamRepository {
  repositoryName: string;
}
function fromUpstreamRepository(input?: UpstreamRepository | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    repositoryName: input["repositoryName"],
  }
}

// refs: 11 - tags: input, named, enum, output
export type PackageVersionStatus =
| "Published"
| "Unfinished"
| "Unlisted"
| "Archived"
| "Disposed"
| "Deleted"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type PackageVersionSortType =
| "PUBLISHED_TIME"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface RepositoryDescription {
  name?: string | null;
  administratorAccount?: string | null;
  domainName?: string | null;
  domainOwner?: string | null;
  arn?: string | null;
  description?: string | null;
  upstreams?: UpstreamRepositoryInfo[] | null;
  externalConnections?: RepositoryExternalConnectionInfo[] | null;
}
function toRepositoryDescription(root: jsonP.JSONValue): RepositoryDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "administratorAccount": "s",
      "domainName": "s",
      "domainOwner": "s",
      "arn": "s",
      "description": "s",
      "upstreams": [toUpstreamRepositoryInfo],
      "externalConnections": [toRepositoryExternalConnectionInfo],
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface UpstreamRepositoryInfo {
  repositoryName?: string | null;
}
function toUpstreamRepositoryInfo(root: jsonP.JSONValue): UpstreamRepositoryInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, interface
export interface RepositoryExternalConnectionInfo {
  externalConnectionName?: string | null;
  packageFormat?: PackageFormat | null;
  status?: ExternalConnectionStatus | null;
}
function toRepositoryExternalConnectionInfo(root: jsonP.JSONValue): RepositoryExternalConnectionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "externalConnectionName": "s",
      "packageFormat": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<ExternalConnectionStatus>(x),
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type ExternalConnectionStatus =
| "Available"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface SuccessfulPackageVersionInfo {
  revision?: string | null;
  status?: PackageVersionStatus | null;
}
function toSuccessfulPackageVersionInfo(root: jsonP.JSONValue): SuccessfulPackageVersionInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "revision": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<PackageVersionStatus>(x),
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface PackageVersionError {
  errorCode?: PackageVersionErrorCode | null;
  errorMessage?: string | null;
}
function toPackageVersionError(root: jsonP.JSONValue): PackageVersionError {
  return jsonP.readObj({
    required: {},
    optional: {
      "errorCode": (x: jsonP.JSONValue) => cmnP.readEnum<PackageVersionErrorCode>(x),
      "errorMessage": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type PackageVersionErrorCode =
| "ALREADY_EXISTS"
| "MISMATCHED_REVISION"
| "MISMATCHED_STATUS"
| "NOT_ALLOWED"
| "NOT_FOUND"
| "SKIPPED"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface DomainDescription {
  name?: string | null;
  owner?: string | null;
  arn?: string | null;
  status?: DomainStatus | null;
  createdTime?: Date | number | null;
  encryptionKey?: string | null;
  repositoryCount?: number | null;
  assetSizeBytes?: number | null;
}
function toDomainDescription(root: jsonP.JSONValue): DomainDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "owner": "s",
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DomainStatus>(x),
      "createdTime": "d",
      "encryptionKey": "s",
      "repositoryCount": "n",
      "assetSizeBytes": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type DomainStatus =
| "Active"
| "Deleted"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: output, named, interface
export interface ResourcePolicy {
  resourceArn?: string | null;
  revision?: string | null;
  document?: string | null;
}
function toResourcePolicy(root: jsonP.JSONValue): ResourcePolicy {
  return jsonP.readObj({
    required: {},
    optional: {
      "resourceArn": "s",
      "revision": "s",
      "document": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PackageVersionDescription {
  format?: PackageFormat | null;
  namespace?: string | null;
  packageName?: string | null;
  displayName?: string | null;
  version?: string | null;
  summary?: string | null;
  homePage?: string | null;
  sourceCodeRepository?: string | null;
  publishedTime?: Date | number | null;
  licenses?: LicenseInfo[] | null;
  revision?: string | null;
  status?: PackageVersionStatus | null;
}
function toPackageVersionDescription(root: jsonP.JSONValue): PackageVersionDescription {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
      "namespace": "s",
      "packageName": "s",
      "displayName": "s",
      "version": "s",
      "summary": "s",
      "homePage": "s",
      "sourceCodeRepository": "s",
      "publishedTime": "d",
      "licenses": [toLicenseInfo],
      "revision": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<PackageVersionStatus>(x),
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LicenseInfo {
  name?: string | null;
  url?: string | null;
}
function toLicenseInfo(root: jsonP.JSONValue): LicenseInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "url": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DomainSummary {
  name?: string | null;
  owner?: string | null;
  arn?: string | null;
  status?: DomainStatus | null;
  createdTime?: Date | number | null;
  encryptionKey?: string | null;
}
function toDomainSummary(root: jsonP.JSONValue): DomainSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "owner": "s",
      "arn": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<DomainStatus>(x),
      "createdTime": "d",
      "encryptionKey": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AssetSummary {
  name: string;
  size?: number | null;
  hashes?: { [key in HashAlgorithm]: string | null | undefined } | null;
}
function toAssetSummary(root: jsonP.JSONValue): AssetSummary {
  return jsonP.readObj({
    required: {
      "name": "s",
    },
    optional: {
      "size": "n",
      "hashes": x => jsonP.readMap(x => cmnP.readEnumReq<HashAlgorithm>(x), String, x),
    },
  }, root);
}

// refs: 1 - tags: output, named, enum
export type HashAlgorithm =
| "MD5"
| "SHA-1"
| "SHA-256"
| "SHA-512"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface PackageDependency {
  namespace?: string | null;
  package?: string | null;
  dependencyType?: string | null;
  versionRequirement?: string | null;
}
function toPackageDependency(root: jsonP.JSONValue): PackageDependency {
  return jsonP.readObj({
    required: {},
    optional: {
      "namespace": "s",
      "package": "s",
      "dependencyType": "s",
      "versionRequirement": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PackageVersionSummary {
  version: string;
  revision?: string | null;
  status: PackageVersionStatus;
}
function toPackageVersionSummary(root: jsonP.JSONValue): PackageVersionSummary {
  return jsonP.readObj({
    required: {
      "version": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<PackageVersionStatus>(x),
    },
    optional: {
      "revision": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PackageSummary {
  format?: PackageFormat | null;
  namespace?: string | null;
  package?: string | null;
}
function toPackageSummary(root: jsonP.JSONValue): PackageSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "format": (x: jsonP.JSONValue) => cmnP.readEnum<PackageFormat>(x),
      "namespace": "s",
      "package": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface RepositorySummary {
  name?: string | null;
  administratorAccount?: string | null;
  domainName?: string | null;
  domainOwner?: string | null;
  arn?: string | null;
  description?: string | null;
}
function toRepositorySummary(root: jsonP.JSONValue): RepositorySummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "administratorAccount": "s",
      "domainName": "s",
      "domainOwner": "s",
      "arn": "s",
      "description": "s",
    },
  }, root);
}
