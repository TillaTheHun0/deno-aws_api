// Autogenerated API client for: Amazon Kinesis Video Streams Archived Media

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";

export default class KinesisVideoArchivedMedia {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(KinesisVideoArchivedMedia.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-09-30",
    "endpointPrefix": "kinesisvideo",
    "protocol": "rest-json",
    "serviceAbbreviation": "Kinesis Video Archived Media",
    "serviceFullName": "Amazon Kinesis Video Streams Archived Media",
    "serviceId": "Kinesis Video Archived Media",
    "signatureVersion": "v4",
    "uid": "kinesis-video-archived-media-2017-09-30"
  };

  async getClip(
    {abortSignal, ...params}: RequestConfig & s.GetClipInput,
  ): Promise<s.GetClipOutput> {
    const body: jsonP.JSONObject = {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      ClipFragmentSelector: fromClipFragmentSelector(params["ClipFragmentSelector"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetClip",
      requestUri: "/getClip",
    });
  return {
    ContentType: resp.headers.get("Content-Type"),
    Payload: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async getDASHStreamingSessionURL(
    {abortSignal, ...params}: RequestConfig & s.GetDASHStreamingSessionURLInput = {},
  ): Promise<s.GetDASHStreamingSessionURLOutput> {
    const body: jsonP.JSONObject = {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      PlaybackMode: params["PlaybackMode"],
      DisplayFragmentTimestamp: params["DisplayFragmentTimestamp"],
      DisplayFragmentNumber: params["DisplayFragmentNumber"],
      DASHFragmentSelector: fromDASHFragmentSelector(params["DASHFragmentSelector"]),
      Expires: params["Expires"],
      MaxManifestFragmentResults: params["MaxManifestFragmentResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDASHStreamingSessionURL",
      requestUri: "/getDASHStreamingSessionURL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DASHStreamingSessionURL": "s",
      },
    }, await resp.json());
  }

  async getHLSStreamingSessionURL(
    {abortSignal, ...params}: RequestConfig & s.GetHLSStreamingSessionURLInput = {},
  ): Promise<s.GetHLSStreamingSessionURLOutput> {
    const body: jsonP.JSONObject = {
      StreamName: params["StreamName"],
      StreamARN: params["StreamARN"],
      PlaybackMode: params["PlaybackMode"],
      HLSFragmentSelector: fromHLSFragmentSelector(params["HLSFragmentSelector"]),
      ContainerFormat: params["ContainerFormat"],
      DiscontinuityMode: params["DiscontinuityMode"],
      DisplayFragmentTimestamp: params["DisplayFragmentTimestamp"],
      Expires: params["Expires"],
      MaxMediaPlaylistFragmentResults: params["MaxMediaPlaylistFragmentResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetHLSStreamingSessionURL",
      requestUri: "/getHLSStreamingSessionURL",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "HLSStreamingSessionURL": "s",
      },
    }, await resp.json());
  }

  async getMediaForFragmentList(
    {abortSignal, ...params}: RequestConfig & s.GetMediaForFragmentListInput,
  ): Promise<s.GetMediaForFragmentListOutput> {
    const body: jsonP.JSONObject = {
      StreamName: params["StreamName"],
      Fragments: params["Fragments"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetMediaForFragmentList",
      requestUri: "/getMediaForFragmentList",
    });
  return {
    ContentType: resp.headers.get("Content-Type"),
    Payload: await resp.text(), // TODO: maybe allow proper body streaming,
  };
  }

  async listFragments(
    {abortSignal, ...params}: RequestConfig & s.ListFragmentsInput,
  ): Promise<s.ListFragmentsOutput> {
    const body: jsonP.JSONObject = {
      StreamName: params["StreamName"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      FragmentSelector: fromFragmentSelector(params["FragmentSelector"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFragments",
      requestUri: "/listFragments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Fragments": [toFragment],
        "NextToken": "s",
      },
    }, await resp.json());
  }

}

function fromClipFragmentSelector(input?: s.ClipFragmentSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FragmentSelectorType: input["FragmentSelectorType"],
    TimestampRange: fromClipTimestampRange(input["TimestampRange"]),
  }
}

function fromClipTimestampRange(input?: s.ClipTimestampRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTimestamp: jsonP.serializeDate_unixTimestamp(input["StartTimestamp"]),
    EndTimestamp: jsonP.serializeDate_unixTimestamp(input["EndTimestamp"]),
  }
}

function fromDASHFragmentSelector(input?: s.DASHFragmentSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FragmentSelectorType: input["FragmentSelectorType"],
    TimestampRange: fromDASHTimestampRange(input["TimestampRange"]),
  }
}

function fromDASHTimestampRange(input?: s.DASHTimestampRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTimestamp: jsonP.serializeDate_unixTimestamp(input["StartTimestamp"]),
    EndTimestamp: jsonP.serializeDate_unixTimestamp(input["EndTimestamp"]),
  }
}

function fromHLSFragmentSelector(input?: s.HLSFragmentSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FragmentSelectorType: input["FragmentSelectorType"],
    TimestampRange: fromHLSTimestampRange(input["TimestampRange"]),
  }
}

function fromHLSTimestampRange(input?: s.HLSTimestampRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTimestamp: jsonP.serializeDate_unixTimestamp(input["StartTimestamp"]),
    EndTimestamp: jsonP.serializeDate_unixTimestamp(input["EndTimestamp"]),
  }
}

function fromFragmentSelector(input?: s.FragmentSelector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FragmentSelectorType: input["FragmentSelectorType"],
    TimestampRange: fromTimestampRange(input["TimestampRange"]),
  }
}

function fromTimestampRange(input?: s.TimestampRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StartTimestamp: jsonP.serializeDate_unixTimestamp(input["StartTimestamp"]),
    EndTimestamp: jsonP.serializeDate_unixTimestamp(input["EndTimestamp"]),
  }
}

function toFragment(root: jsonP.JSONValue): s.Fragment {
  return jsonP.readObj({
    required: {},
    optional: {
      "FragmentNumber": "s",
      "FragmentSizeInBytes": "n",
      "ProducerTimestamp": "d",
      "ServerTimestamp": "d",
      "FragmentLengthInMilliseconds": "n",
    },
  }, root);
}
