// Autogenerated API client for: Amazon SageMaker Service

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import * as uuidv4 from "https://deno.land/std@0.86.0/uuid/v4.ts";
import type * as s from "./structs.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class SageMaker {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SageMaker.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2017-07-24",
    "endpointPrefix": "api.sagemaker",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "SageMaker",
    "serviceFullName": "Amazon SageMaker Service",
    "serviceId": "SageMaker",
    "signatureVersion": "v4",
    "signingName": "sagemaker",
    "targetPrefix": "SageMaker",
    "uid": "sagemaker-2017-07-24"
  };

  async addAssociation(
    {abortSignal, ...params}: RequestConfig & s.AddAssociationRequest,
  ): Promise<s.AddAssociationResponse> {
    const body: jsonP.JSONObject = {
      SourceArn: params["SourceArn"],
      DestinationArn: params["DestinationArn"],
      AssociationType: params["AssociationType"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SourceArn": "s",
        "DestinationArn": "s",
      },
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & s.AddTagsInput,
  ): Promise<s.AddTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async associateTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.AssociateTrialComponentRequest,
  ): Promise<s.AssociateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async createAction(
    {abortSignal, ...params}: RequestConfig & s.CreateActionRequest,
  ): Promise<s.CreateActionResponse> {
    const body: jsonP.JSONObject = {
      ActionName: params["ActionName"],
      Source: fromActionSource(params["Source"]),
      ActionType: params["ActionType"],
      Description: params["Description"],
      Status: params["Status"],
      Properties: params["Properties"],
      MetadataProperties: fromMetadataProperties(params["MetadataProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActionArn": "s",
      },
    }, await resp.json());
  }

  async createAlgorithm(
    {abortSignal, ...params}: RequestConfig & s.CreateAlgorithmInput,
  ): Promise<s.CreateAlgorithmOutput> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
      AlgorithmDescription: params["AlgorithmDescription"],
      TrainingSpecification: fromTrainingSpecification(params["TrainingSpecification"]),
      InferenceSpecification: fromInferenceSpecification(params["InferenceSpecification"]),
      ValidationSpecification: fromAlgorithmValidationSpecification(params["ValidationSpecification"]),
      CertifyForMarketplace: params["CertifyForMarketplace"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlgorithm",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createApp(
    {abortSignal, ...params}: RequestConfig & s.CreateAppRequest,
  ): Promise<s.CreateAppResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ResourceSpec: fromResourceSpec(params["ResourceSpec"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppArn": "s",
      },
    }, await resp.json());
  }

  async createAppImageConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateAppImageConfigRequest,
  ): Promise<s.CreateAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KernelGatewayImageConfig: fromKernelGatewayImageConfig(params["KernelGatewayImageConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
      },
    }, await resp.json());
  }

  async createArtifact(
    {abortSignal, ...params}: RequestConfig & s.CreateArtifactRequest,
  ): Promise<s.CreateArtifactResponse> {
    const body: jsonP.JSONObject = {
      ArtifactName: params["ArtifactName"],
      Source: fromArtifactSource(params["Source"]),
      ArtifactType: params["ArtifactType"],
      Properties: params["Properties"],
      MetadataProperties: fromMetadataProperties(params["MetadataProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateArtifact",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArtifactArn": "s",
      },
    }, await resp.json());
  }

  async createAutoMLJob(
    {abortSignal, ...params}: RequestConfig & s.CreateAutoMLJobRequest,
  ): Promise<s.CreateAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
      InputDataConfig: params["InputDataConfig"]?.map(x => fromAutoMLChannel(x)),
      OutputDataConfig: fromAutoMLOutputDataConfig(params["OutputDataConfig"]),
      ProblemType: params["ProblemType"],
      AutoMLJobObjective: fromAutoMLJobObjective(params["AutoMLJobObjective"]),
      AutoMLJobConfig: fromAutoMLJobConfig(params["AutoMLJobConfig"]),
      RoleArn: params["RoleArn"],
      GenerateCandidateDefinitionsOnly: params["GenerateCandidateDefinitionsOnly"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCodeRepository(
    {abortSignal, ...params}: RequestConfig & s.CreateCodeRepositoryInput,
  ): Promise<s.CreateCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
      GitConfig: fromGitConfig(params["GitConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCompilationJob(
    {abortSignal, ...params}: RequestConfig & s.CreateCompilationJobRequest,
  ): Promise<s.CreateCompilationJobResponse> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
      RoleArn: params["RoleArn"],
      InputConfig: fromInputConfig(params["InputConfig"]),
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
      StoppingCondition: fromStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCompilationJob",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createContext(
    {abortSignal, ...params}: RequestConfig & s.CreateContextRequest,
  ): Promise<s.CreateContextResponse> {
    const body: jsonP.JSONObject = {
      ContextName: params["ContextName"],
      Source: fromContextSource(params["Source"]),
      ContextType: params["ContextType"],
      Description: params["Description"],
      Properties: params["Properties"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateContext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContextArn": "s",
      },
    }, await resp.json());
  }

  async createDataQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateDataQualityJobDefinitionRequest,
  ): Promise<s.CreateDataQualityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
      DataQualityBaselineConfig: fromDataQualityBaselineConfig(params["DataQualityBaselineConfig"]),
      DataQualityAppSpecification: fromDataQualityAppSpecification(params["DataQualityAppSpecification"]),
      DataQualityJobInput: fromDataQualityJobInput(params["DataQualityJobInput"]),
      DataQualityJobOutputConfig: fromMonitoringOutputConfig(params["DataQualityJobOutputConfig"]),
      JobResources: fromMonitoringResources(params["JobResources"]),
      NetworkConfig: fromMonitoringNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      StoppingCondition: fromMonitoringStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDataQualityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createDeviceFleet(
    {abortSignal, ...params}: RequestConfig & s.CreateDeviceFleetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
      RoleArn: params["RoleArn"],
      Description: params["Description"],
      OutputConfig: fromEdgeOutputConfig(params["OutputConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDeviceFleet",
    });
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & s.CreateDomainRequest,
  ): Promise<s.CreateDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      AuthMode: params["AuthMode"],
      DefaultUserSettings: fromUserSettings(params["DefaultUserSettings"]),
      SubnetIds: params["SubnetIds"],
      VpcId: params["VpcId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      AppNetworkAccessType: params["AppNetworkAccessType"],
      HomeEfsFileSystemKmsKeyId: params["HomeEfsFileSystemKmsKeyId"],
      KmsKeyId: params["KmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
        "Url": "s",
      },
    }, await resp.json());
  }

  async createEdgePackagingJob(
    {abortSignal, ...params}: RequestConfig & s.CreateEdgePackagingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EdgePackagingJobName: params["EdgePackagingJobName"],
      CompilationJobName: params["CompilationJobName"],
      ModelName: params["ModelName"],
      ModelVersion: params["ModelVersion"],
      RoleArn: params["RoleArn"],
      OutputConfig: fromEdgeOutputConfig(params["OutputConfig"]),
      ResourceKey: params["ResourceKey"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEdgePackagingJob",
    });
  }

  async createEndpoint(
    {abortSignal, ...params}: RequestConfig & s.CreateEndpointInput,
  ): Promise<s.CreateEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      EndpointConfigName: params["EndpointConfigName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createEndpointConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateEndpointConfigInput,
  ): Promise<s.CreateEndpointConfigOutput> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
      ProductionVariants: params["ProductionVariants"]?.map(x => fromProductionVariant(x)),
      DataCaptureConfig: fromDataCaptureConfig(params["DataCaptureConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KmsKeyId: params["KmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpointConfig",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createExperiment(
    {abortSignal, ...params}: RequestConfig & s.CreateExperimentRequest,
  ): Promise<s.CreateExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      DisplayName: params["DisplayName"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async createFeatureGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateFeatureGroupRequest,
  ): Promise<s.CreateFeatureGroupResponse> {
    const body: jsonP.JSONObject = {
      FeatureGroupName: params["FeatureGroupName"],
      RecordIdentifierFeatureName: params["RecordIdentifierFeatureName"],
      EventTimeFeatureName: params["EventTimeFeatureName"],
      FeatureDefinitions: params["FeatureDefinitions"]?.map(x => fromFeatureDefinition(x)),
      OnlineStoreConfig: fromOnlineStoreConfig(params["OnlineStoreConfig"]),
      OfflineStoreConfig: fromOfflineStoreConfig(params["OfflineStoreConfig"]),
      RoleArn: params["RoleArn"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFeatureGroup",
    });
    return jsonP.readObj({
      required: {
        "FeatureGroupArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createFlowDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateFlowDefinitionRequest,
  ): Promise<s.CreateFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
      HumanLoopRequestSource: fromHumanLoopRequestSource(params["HumanLoopRequestSource"]),
      HumanLoopActivationConfig: fromHumanLoopActivationConfig(params["HumanLoopActivationConfig"]),
      HumanLoopConfig: fromHumanLoopConfig(params["HumanLoopConfig"]),
      OutputConfig: fromFlowDefinitionOutputConfig(params["OutputConfig"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFlowDefinition",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & s.CreateHumanTaskUiRequest,
  ): Promise<s.CreateHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
      UiTemplate: fromUiTemplate(params["UiTemplate"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHumanTaskUi",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & s.CreateHyperParameterTuningJobRequest,
  ): Promise<s.CreateHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
      HyperParameterTuningJobConfig: fromHyperParameterTuningJobConfig(params["HyperParameterTuningJobConfig"]),
      TrainingJobDefinition: fromHyperParameterTrainingJobDefinition(params["TrainingJobDefinition"]),
      TrainingJobDefinitions: params["TrainingJobDefinitions"]?.map(x => fromHyperParameterTrainingJobDefinition(x)),
      WarmStartConfig: fromHyperParameterTuningJobWarmStartConfig(params["WarmStartConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createImage(
    {abortSignal, ...params}: RequestConfig & s.CreateImageRequest,
  ): Promise<s.CreateImageResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      ImageName: params["ImageName"],
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageArn": "s",
      },
    }, await resp.json());
  }

  async createImageVersion(
    {abortSignal, ...params}: RequestConfig & s.CreateImageVersionRequest,
  ): Promise<s.CreateImageVersionResponse> {
    const body: jsonP.JSONObject = {
      BaseImage: params["BaseImage"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageVersionArn": "s",
      },
    }, await resp.json());
  }

  async createLabelingJob(
    {abortSignal, ...params}: RequestConfig & s.CreateLabelingJobRequest,
  ): Promise<s.CreateLabelingJobResponse> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
      LabelAttributeName: params["LabelAttributeName"],
      InputConfig: fromLabelingJobInputConfig(params["InputConfig"]),
      OutputConfig: fromLabelingJobOutputConfig(params["OutputConfig"]),
      RoleArn: params["RoleArn"],
      LabelCategoryConfigS3Uri: params["LabelCategoryConfigS3Uri"],
      StoppingConditions: fromLabelingJobStoppingConditions(params["StoppingConditions"]),
      LabelingJobAlgorithmsConfig: fromLabelingJobAlgorithmsConfig(params["LabelingJobAlgorithmsConfig"]),
      HumanTaskConfig: fromHumanTaskConfig(params["HumanTaskConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLabelingJob",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & s.CreateModelInput,
  ): Promise<s.CreateModelOutput> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
      PrimaryContainer: fromContainerDefinition(params["PrimaryContainer"]),
      Containers: params["Containers"]?.map(x => fromContainerDefinition(x)),
      ExecutionRoleArn: params["ExecutionRoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      EnableNetworkIsolation: params["EnableNetworkIsolation"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
    });
    return jsonP.readObj({
      required: {
        "ModelArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelBiasJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateModelBiasJobDefinitionRequest,
  ): Promise<s.CreateModelBiasJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
      ModelBiasBaselineConfig: fromModelBiasBaselineConfig(params["ModelBiasBaselineConfig"]),
      ModelBiasAppSpecification: fromModelBiasAppSpecification(params["ModelBiasAppSpecification"]),
      ModelBiasJobInput: fromModelBiasJobInput(params["ModelBiasJobInput"]),
      ModelBiasJobOutputConfig: fromMonitoringOutputConfig(params["ModelBiasJobOutputConfig"]),
      JobResources: fromMonitoringResources(params["JobResources"]),
      NetworkConfig: fromMonitoringNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      StoppingCondition: fromMonitoringStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelBiasJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelExplainabilityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateModelExplainabilityJobDefinitionRequest,
  ): Promise<s.CreateModelExplainabilityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
      ModelExplainabilityBaselineConfig: fromModelExplainabilityBaselineConfig(params["ModelExplainabilityBaselineConfig"]),
      ModelExplainabilityAppSpecification: fromModelExplainabilityAppSpecification(params["ModelExplainabilityAppSpecification"]),
      ModelExplainabilityJobInput: fromModelExplainabilityJobInput(params["ModelExplainabilityJobInput"]),
      ModelExplainabilityJobOutputConfig: fromMonitoringOutputConfig(params["ModelExplainabilityJobOutputConfig"]),
      JobResources: fromMonitoringResources(params["JobResources"]),
      NetworkConfig: fromMonitoringNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      StoppingCondition: fromMonitoringStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelExplainabilityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelPackage(
    {abortSignal, ...params}: RequestConfig & s.CreateModelPackageInput = {},
  ): Promise<s.CreateModelPackageOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
      ModelPackageGroupName: params["ModelPackageGroupName"],
      ModelPackageDescription: params["ModelPackageDescription"],
      InferenceSpecification: fromInferenceSpecification(params["InferenceSpecification"]),
      ValidationSpecification: fromModelPackageValidationSpecification(params["ValidationSpecification"]),
      SourceAlgorithmSpecification: fromSourceAlgorithmSpecification(params["SourceAlgorithmSpecification"]),
      CertifyForMarketplace: params["CertifyForMarketplace"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ModelApprovalStatus: params["ModelApprovalStatus"],
      MetadataProperties: fromMetadataProperties(params["MetadataProperties"]),
      ModelMetrics: fromModelMetrics(params["ModelMetrics"]),
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelPackage",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelPackageGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateModelPackageGroupInput,
  ): Promise<s.CreateModelPackageGroupOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
      ModelPackageGroupDescription: params["ModelPackageGroupDescription"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelPackageGroup",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageGroupArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.CreateModelQualityJobDefinitionRequest,
  ): Promise<s.CreateModelQualityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
      ModelQualityBaselineConfig: fromModelQualityBaselineConfig(params["ModelQualityBaselineConfig"]),
      ModelQualityAppSpecification: fromModelQualityAppSpecification(params["ModelQualityAppSpecification"]),
      ModelQualityJobInput: fromModelQualityJobInput(params["ModelQualityJobInput"]),
      ModelQualityJobOutputConfig: fromMonitoringOutputConfig(params["ModelQualityJobOutputConfig"]),
      JobResources: fromMonitoringResources(params["JobResources"]),
      NetworkConfig: fromMonitoringNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      StoppingCondition: fromMonitoringStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelQualityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.CreateMonitoringScheduleRequest,
  ): Promise<s.CreateMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      MonitoringScheduleConfig: fromMonitoringScheduleConfig(params["MonitoringScheduleConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.CreateNotebookInstanceInput,
  ): Promise<s.CreateNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      InstanceType: params["InstanceType"],
      SubnetId: params["SubnetId"],
      SecurityGroupIds: params["SecurityGroupIds"],
      RoleArn: params["RoleArn"],
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      LifecycleConfigName: params["LifecycleConfigName"],
      DirectInternetAccess: params["DirectInternetAccess"],
      VolumeSizeInGB: params["VolumeSizeInGB"],
      AcceleratorTypes: params["AcceleratorTypes"],
      DefaultCodeRepository: params["DefaultCodeRepository"],
      AdditionalCodeRepositories: params["AdditionalCodeRepositories"],
      RootAccess: params["RootAccess"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceArn": "s",
      },
    }, await resp.json());
  }

  async createNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateNotebookInstanceLifecycleConfigInput,
  ): Promise<s.CreateNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
      OnCreate: params["OnCreate"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
      OnStart: params["OnStart"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceLifecycleConfigArn": "s",
      },
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & s.CreatePipelineRequest,
  ): Promise<s.CreatePipelineResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
      PipelineDisplayName: params["PipelineDisplayName"],
      PipelineDefinition: params["PipelineDefinition"],
      PipelineDescription: params["PipelineDescription"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineArn": "s",
      },
    }, await resp.json());
  }

  async createPresignedDomainUrl(
    {abortSignal, ...params}: RequestConfig & s.CreatePresignedDomainUrlRequest,
  ): Promise<s.CreatePresignedDomainUrlResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      SessionExpirationDurationInSeconds: params["SessionExpirationDurationInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePresignedDomainUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizedUrl": "s",
      },
    }, await resp.json());
  }

  async createPresignedNotebookInstanceUrl(
    {abortSignal, ...params}: RequestConfig & s.CreatePresignedNotebookInstanceUrlInput,
  ): Promise<s.CreatePresignedNotebookInstanceUrlOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      SessionExpirationDurationInSeconds: params["SessionExpirationDurationInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePresignedNotebookInstanceUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizedUrl": "s",
      },
    }, await resp.json());
  }

  async createProcessingJob(
    {abortSignal, ...params}: RequestConfig & s.CreateProcessingJobRequest,
  ): Promise<s.CreateProcessingJobResponse> {
    const body: jsonP.JSONObject = {
      ProcessingInputs: params["ProcessingInputs"]?.map(x => fromProcessingInput(x)),
      ProcessingOutputConfig: fromProcessingOutputConfig(params["ProcessingOutputConfig"]),
      ProcessingJobName: params["ProcessingJobName"],
      ProcessingResources: fromProcessingResources(params["ProcessingResources"]),
      StoppingCondition: fromProcessingStoppingCondition(params["StoppingCondition"]),
      AppSpecification: fromAppSpecification(params["AppSpecification"]),
      Environment: params["Environment"],
      NetworkConfig: fromNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProcessingJob",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createProject(
    {abortSignal, ...params}: RequestConfig & s.CreateProjectInput,
  ): Promise<s.CreateProjectOutput> {
    const body: jsonP.JSONObject = {
      ProjectName: params["ProjectName"],
      ProjectDescription: params["ProjectDescription"],
      ServiceCatalogProvisioningDetails: fromServiceCatalogProvisioningDetails(params["ServiceCatalogProvisioningDetails"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProject",
    });
    return jsonP.readObj({
      required: {
        "ProjectArn": "s",
        "ProjectId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTrainingJob(
    {abortSignal, ...params}: RequestConfig & s.CreateTrainingJobRequest,
  ): Promise<s.CreateTrainingJobResponse> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
      HyperParameters: params["HyperParameters"],
      AlgorithmSpecification: fromAlgorithmSpecification(params["AlgorithmSpecification"]),
      RoleArn: params["RoleArn"],
      InputDataConfig: params["InputDataConfig"]?.map(x => fromChannel(x)),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      ResourceConfig: fromResourceConfig(params["ResourceConfig"]),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      StoppingCondition: fromStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      EnableNetworkIsolation: params["EnableNetworkIsolation"],
      EnableInterContainerTrafficEncryption: params["EnableInterContainerTrafficEncryption"],
      EnableManagedSpotTraining: params["EnableManagedSpotTraining"],
      CheckpointConfig: fromCheckpointConfig(params["CheckpointConfig"]),
      DebugHookConfig: fromDebugHookConfig(params["DebugHookConfig"]),
      DebugRuleConfigurations: params["DebugRuleConfigurations"]?.map(x => fromDebugRuleConfiguration(x)),
      TensorBoardOutputConfig: fromTensorBoardOutputConfig(params["TensorBoardOutputConfig"]),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
      ProfilerConfig: fromProfilerConfig(params["ProfilerConfig"]),
      ProfilerRuleConfigurations: params["ProfilerRuleConfigurations"]?.map(x => fromProfilerRuleConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrainingJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTransformJob(
    {abortSignal, ...params}: RequestConfig & s.CreateTransformJobRequest,
  ): Promise<s.CreateTransformJobResponse> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
      ModelName: params["ModelName"],
      MaxConcurrentTransforms: params["MaxConcurrentTransforms"],
      ModelClientConfig: fromModelClientConfig(params["ModelClientConfig"]),
      MaxPayloadInMB: params["MaxPayloadInMB"],
      BatchStrategy: params["BatchStrategy"],
      Environment: params["Environment"],
      TransformInput: fromTransformInput(params["TransformInput"]),
      TransformOutput: fromTransformOutput(params["TransformOutput"]),
      TransformResources: fromTransformResources(params["TransformResources"]),
      DataProcessing: fromDataProcessing(params["DataProcessing"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransformJob",
    });
    return jsonP.readObj({
      required: {
        "TransformJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTrial(
    {abortSignal, ...params}: RequestConfig & s.CreateTrialRequest,
  ): Promise<s.CreateTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
      DisplayName: params["DisplayName"],
      ExperimentName: params["ExperimentName"],
      MetadataProperties: fromMetadataProperties(params["MetadataProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async createTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.CreateTrialComponentRequest,
  ): Promise<s.CreateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      DisplayName: params["DisplayName"],
      Status: fromTrialComponentStatus(params["Status"]),
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Parameters: jsonP.serializeMap(params["Parameters"], x => fromTrialComponentParameterValue(x)),
      InputArtifacts: jsonP.serializeMap(params["InputArtifacts"], x => fromTrialComponentArtifact(x)),
      OutputArtifacts: jsonP.serializeMap(params["OutputArtifacts"], x => fromTrialComponentArtifact(x)),
      MetadataProperties: fromMetadataProperties(params["MetadataProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async createUserProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateUserProfileRequest,
  ): Promise<s.CreateUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      SingleSignOnUserIdentifier: params["SingleSignOnUserIdentifier"],
      SingleSignOnUserValue: params["SingleSignOnUserValue"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      UserSettings: fromUserSettings(params["UserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfileArn": "s",
      },
    }, await resp.json());
  }

  async createWorkforce(
    {abortSignal, ...params}: RequestConfig & s.CreateWorkforceRequest,
  ): Promise<s.CreateWorkforceResponse> {
    const body: jsonP.JSONObject = {
      CognitoConfig: fromCognitoConfig(params["CognitoConfig"]),
      OidcConfig: fromOidcConfig(params["OidcConfig"]),
      SourceIpConfig: fromSourceIpConfig(params["SourceIpConfig"]),
      WorkforceName: params["WorkforceName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkforce",
    });
    return jsonP.readObj({
      required: {
        "WorkforceArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createWorkteam(
    {abortSignal, ...params}: RequestConfig & s.CreateWorkteamRequest,
  ): Promise<s.CreateWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
      WorkforceName: params["WorkforceName"],
      MemberDefinitions: params["MemberDefinitions"]?.map(x => fromMemberDefinition(x)),
      Description: params["Description"],
      NotificationConfiguration: fromNotificationConfiguration(params["NotificationConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkteam",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WorkteamArn": "s",
      },
    }, await resp.json());
  }

  async deleteAction(
    {abortSignal, ...params}: RequestConfig & s.DeleteActionRequest,
  ): Promise<s.DeleteActionResponse> {
    const body: jsonP.JSONObject = {
      ActionName: params["ActionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActionArn": "s",
      },
    }, await resp.json());
  }

  async deleteAlgorithm(
    {abortSignal, ...params}: RequestConfig & s.DeleteAlgorithmInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlgorithm",
    });
  }

  async deleteApp(
    {abortSignal, ...params}: RequestConfig & s.DeleteAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApp",
    });
  }

  async deleteAppImageConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteAppImageConfigRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAppImageConfig",
    });
  }

  async deleteArtifact(
    {abortSignal, ...params}: RequestConfig & s.DeleteArtifactRequest = {},
  ): Promise<s.DeleteArtifactResponse> {
    const body: jsonP.JSONObject = {
      ArtifactArn: params["ArtifactArn"],
      Source: fromArtifactSource(params["Source"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteArtifact",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArtifactArn": "s",
      },
    }, await resp.json());
  }

  async deleteAssociation(
    {abortSignal, ...params}: RequestConfig & s.DeleteAssociationRequest,
  ): Promise<s.DeleteAssociationResponse> {
    const body: jsonP.JSONObject = {
      SourceArn: params["SourceArn"],
      DestinationArn: params["DestinationArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAssociation",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "SourceArn": "s",
        "DestinationArn": "s",
      },
    }, await resp.json());
  }

  async deleteCodeRepository(
    {abortSignal, ...params}: RequestConfig & s.DeleteCodeRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCodeRepository",
    });
  }

  async deleteContext(
    {abortSignal, ...params}: RequestConfig & s.DeleteContextRequest,
  ): Promise<s.DeleteContextResponse> {
    const body: jsonP.JSONObject = {
      ContextName: params["ContextName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteContext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContextArn": "s",
      },
    }, await resp.json());
  }

  async deleteDataQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteDataQualityJobDefinitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDataQualityJobDefinition",
    });
  }

  async deleteDeviceFleet(
    {abortSignal, ...params}: RequestConfig & s.DeleteDeviceFleetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDeviceFleet",
    });
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & s.DeleteDomainRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      RetentionPolicy: fromRetentionPolicy(params["RetentionPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteEndpointInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpoint",
    });
  }

  async deleteEndpointConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteEndpointConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpointConfig",
    });
  }

  async deleteExperiment(
    {abortSignal, ...params}: RequestConfig & s.DeleteExperimentRequest,
  ): Promise<s.DeleteExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async deleteFeatureGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteFeatureGroupRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      FeatureGroupName: params["FeatureGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFeatureGroup",
    });
  }

  async deleteFlowDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteFlowDefinitionRequest,
  ): Promise<s.DeleteFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFlowDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & s.DeleteHumanTaskUiRequest,
  ): Promise<s.DeleteHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHumanTaskUi",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImage(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageRequest,
  ): Promise<s.DeleteImageResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImageVersion(
    {abortSignal, ...params}: RequestConfig & s.DeleteImageVersionRequest,
  ): Promise<s.DeleteImageVersionResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
      Version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModel",
    });
  }

  async deleteModelBiasJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelBiasJobDefinitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelBiasJobDefinition",
    });
  }

  async deleteModelExplainabilityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelExplainabilityJobDefinitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelExplainabilityJobDefinition",
    });
  }

  async deleteModelPackage(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelPackageInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelPackage",
    });
  }

  async deleteModelPackageGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelPackageGroupInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelPackageGroup",
    });
  }

  async deleteModelPackageGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelPackageGroupPolicyInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelPackageGroupPolicy",
    });
  }

  async deleteModelQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DeleteModelQualityJobDefinitionRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelQualityJobDefinition",
    });
  }

  async deleteMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.DeleteMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMonitoringSchedule",
    });
  }

  async deleteNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.DeleteNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotebookInstance",
    });
  }

  async deleteNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteNotebookInstanceLifecycleConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotebookInstanceLifecycleConfig",
    });
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeletePipelineRequest,
  ): Promise<s.DeletePipelineResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineArn": "s",
      },
    }, await resp.json());
  }

  async deleteProject(
    {abortSignal, ...params}: RequestConfig & s.DeleteProjectInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ProjectName: params["ProjectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteProject",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & s.DeleteTagsInput,
  ): Promise<s.DeleteTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTrial(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrialRequest,
  ): Promise<s.DeleteTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async deleteTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.DeleteTrialComponentRequest,
  ): Promise<s.DeleteTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async deleteUserProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserProfile",
    });
  }

  async deleteWorkforce(
    {abortSignal, ...params}: RequestConfig & s.DeleteWorkforceRequest,
  ): Promise<s.DeleteWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkforce",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWorkteam(
    {abortSignal, ...params}: RequestConfig & s.DeleteWorkteamRequest,
  ): Promise<s.DeleteWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Success": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async deregisterDevices(
    {abortSignal, ...params}: RequestConfig & s.DeregisterDevicesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
      DeviceNames: params["DeviceNames"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeregisterDevices",
    });
  }

  async describeAction(
    {abortSignal, ...params}: RequestConfig & s.DescribeActionRequest,
  ): Promise<s.DescribeActionResponse> {
    const body: jsonP.JSONObject = {
      ActionName: params["ActionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActionName": "s",
        "ActionArn": "s",
        "Source": toActionSource,
        "ActionType": "s",
        "Description": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionStatus>(x),
        "Properties": x => jsonP.readMap(String, String, x),
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "MetadataProperties": toMetadataProperties,
      },
    }, await resp.json());
  }

  async describeAlgorithm(
    {abortSignal, ...params}: RequestConfig & s.DescribeAlgorithmInput,
  ): Promise<s.DescribeAlgorithmOutput> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlgorithm",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmName": "s",
        "AlgorithmArn": "s",
        "CreationTime": "d",
        "TrainingSpecification": toTrainingSpecification,
        "AlgorithmStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AlgorithmStatus>(x),
        "AlgorithmStatusDetails": toAlgorithmStatusDetails,
      },
      optional: {
        "AlgorithmDescription": "s",
        "InferenceSpecification": toInferenceSpecification,
        "ValidationSpecification": toAlgorithmValidationSpecification,
        "ProductId": "s",
        "CertifyForMarketplace": "b",
      },
    }, await resp.json());
  }

  async describeApp(
    {abortSignal, ...params}: RequestConfig & s.DescribeAppRequest,
  ): Promise<s.DescribeAppResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppArn": "s",
        "AppType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppType>(x),
        "AppName": "s",
        "DomainId": "s",
        "UserProfileName": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppStatus>(x),
        "LastHealthCheckTimestamp": "d",
        "LastUserActivityTimestamp": "d",
        "CreationTime": "d",
        "FailureReason": "s",
        "ResourceSpec": toResourceSpec,
      },
    }, await resp.json());
  }

  async describeAppImageConfig(
    {abortSignal, ...params}: RequestConfig & s.DescribeAppImageConfigRequest,
  ): Promise<s.DescribeAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
        "AppImageConfigName": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "KernelGatewayImageConfig": toKernelGatewayImageConfig,
      },
    }, await resp.json());
  }

  async describeArtifact(
    {abortSignal, ...params}: RequestConfig & s.DescribeArtifactRequest,
  ): Promise<s.DescribeArtifactResponse> {
    const body: jsonP.JSONObject = {
      ArtifactArn: params["ArtifactArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeArtifact",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArtifactName": "s",
        "ArtifactArn": "s",
        "Source": toArtifactSource,
        "ArtifactType": "s",
        "Properties": x => jsonP.readMap(String, String, x),
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "MetadataProperties": toMetadataProperties,
      },
    }, await resp.json());
  }

  async describeAutoMLJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeAutoMLJobRequest,
  ): Promise<s.DescribeAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobName": "s",
        "AutoMLJobArn": "s",
        "InputDataConfig": [toAutoMLChannel],
        "OutputDataConfig": toAutoMLOutputDataConfig,
        "RoleArn": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "AutoMLJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLJobStatus>(x),
        "AutoMLJobSecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLJobSecondaryStatus>(x),
      },
      optional: {
        "AutoMLJobObjective": toAutoMLJobObjective,
        "ProblemType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProblemType>(x),
        "AutoMLJobConfig": toAutoMLJobConfig,
        "EndTime": "d",
        "FailureReason": "s",
        "BestCandidate": toAutoMLCandidate,
        "GenerateCandidateDefinitionsOnly": "b",
        "AutoMLJobArtifacts": toAutoMLJobArtifacts,
        "ResolvedAttributes": toResolvedAttributes,
      },
    }, await resp.json());
  }

  async describeCodeRepository(
    {abortSignal, ...params}: RequestConfig & s.DescribeCodeRepositoryInput,
  ): Promise<s.DescribeCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryName": "s",
        "CodeRepositoryArn": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
      },
      optional: {
        "GitConfig": toGitConfig,
      },
    }, await resp.json());
  }

  async describeCompilationJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeCompilationJobRequest,
  ): Promise<s.DescribeCompilationJobResponse> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCompilationJob",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobName": "s",
        "CompilationJobArn": "s",
        "CompilationJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompilationJobStatus>(x),
        "StoppingCondition": toStoppingCondition,
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "ModelArtifacts": toModelArtifacts,
        "RoleArn": "s",
        "InputConfig": toInputConfig,
        "OutputConfig": toOutputConfig,
      },
      optional: {
        "CompilationStartTime": "d",
        "CompilationEndTime": "d",
        "ModelDigests": toModelDigests,
      },
    }, await resp.json());
  }

  async describeContext(
    {abortSignal, ...params}: RequestConfig & s.DescribeContextRequest,
  ): Promise<s.DescribeContextResponse> {
    const body: jsonP.JSONObject = {
      ContextName: params["ContextName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeContext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContextName": "s",
        "ContextArn": "s",
        "Source": toContextSource,
        "ContextType": "s",
        "Description": "s",
        "Properties": x => jsonP.readMap(String, String, x),
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeDataQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeDataQualityJobDefinitionRequest,
  ): Promise<s.DescribeDataQualityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDataQualityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
        "JobDefinitionName": "s",
        "CreationTime": "d",
        "DataQualityAppSpecification": toDataQualityAppSpecification,
        "DataQualityJobInput": toDataQualityJobInput,
        "DataQualityJobOutputConfig": toMonitoringOutputConfig,
        "JobResources": toMonitoringResources,
        "RoleArn": "s",
      },
      optional: {
        "DataQualityBaselineConfig": toDataQualityBaselineConfig,
        "NetworkConfig": toMonitoringNetworkConfig,
        "StoppingCondition": toMonitoringStoppingCondition,
      },
    }, await resp.json());
  }

  async describeDevice(
    {abortSignal, ...params}: RequestConfig & s.DescribeDeviceRequest,
  ): Promise<s.DescribeDeviceResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      DeviceName: params["DeviceName"],
      DeviceFleetName: params["DeviceFleetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDevice",
    });
    return jsonP.readObj({
      required: {
        "DeviceName": "s",
        "DeviceFleetName": "s",
        "RegistrationTime": "d",
      },
      optional: {
        "DeviceArn": "s",
        "Description": "s",
        "IotThingName": "s",
        "LatestHeartbeat": "d",
        "Models": [toEdgeModel],
        "MaxModels": "n",
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async describeDeviceFleet(
    {abortSignal, ...params}: RequestConfig & s.DescribeDeviceFleetRequest,
  ): Promise<s.DescribeDeviceFleetResponse> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDeviceFleet",
    });
    return jsonP.readObj({
      required: {
        "DeviceFleetName": "s",
        "DeviceFleetArn": "s",
        "OutputConfig": toEdgeOutputConfig,
        "CreationTime": "d",
        "LastModifiedTime": "d",
      },
      optional: {
        "Description": "s",
        "RoleArn": "s",
        "IotRoleAlias": "s",
      },
    }, await resp.json());
  }

  async describeDomain(
    {abortSignal, ...params}: RequestConfig & s.DescribeDomainRequest,
  ): Promise<s.DescribeDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
        "DomainId": "s",
        "DomainName": "s",
        "HomeEfsFileSystemId": "s",
        "SingleSignOnManagedApplicationInstanceId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "AuthMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.AuthMode>(x),
        "DefaultUserSettings": toUserSettings,
        "AppNetworkAccessType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppNetworkAccessType>(x),
        "HomeEfsFileSystemKmsKeyId": "s",
        "SubnetIds": ["s"],
        "Url": "s",
        "VpcId": "s",
        "KmsKeyId": "s",
      },
    }, await resp.json());
  }

  async describeEdgePackagingJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeEdgePackagingJobRequest,
  ): Promise<s.DescribeEdgePackagingJobResponse> {
    const body: jsonP.JSONObject = {
      EdgePackagingJobName: params["EdgePackagingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEdgePackagingJob",
    });
    return jsonP.readObj({
      required: {
        "EdgePackagingJobArn": "s",
        "EdgePackagingJobName": "s",
        "EdgePackagingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EdgePackagingJobStatus>(x),
      },
      optional: {
        "CompilationJobName": "s",
        "ModelName": "s",
        "ModelVersion": "s",
        "RoleArn": "s",
        "OutputConfig": toEdgeOutputConfig,
        "ResourceKey": "s",
        "EdgePackagingJobStatusMessage": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "ModelArtifact": "s",
        "ModelSignature": "s",
      },
    }, await resp.json());
  }

  async describeEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointInput,
  ): Promise<s.DescribeEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointName": "s",
        "EndpointArn": "s",
        "EndpointConfigName": "s",
        "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
      },
      optional: {
        "ProductionVariants": [toProductionVariantSummary],
        "DataCaptureConfig": toDataCaptureConfigSummary,
        "FailureReason": "s",
        "LastDeploymentConfig": toDeploymentConfig,
      },
    }, await resp.json());
  }

  async describeEndpointConfig(
    {abortSignal, ...params}: RequestConfig & s.DescribeEndpointConfigInput,
  ): Promise<s.DescribeEndpointConfigOutput> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpointConfig",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigName": "s",
        "EndpointConfigArn": "s",
        "ProductionVariants": [toProductionVariant],
        "CreationTime": "d",
      },
      optional: {
        "DataCaptureConfig": toDataCaptureConfig,
        "KmsKeyId": "s",
      },
    }, await resp.json());
  }

  async describeExperiment(
    {abortSignal, ...params}: RequestConfig & s.DescribeExperimentRequest,
  ): Promise<s.DescribeExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentName": "s",
        "ExperimentArn": "s",
        "DisplayName": "s",
        "Source": toExperimentSource,
        "Description": "s",
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeFeatureGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeFeatureGroupRequest,
  ): Promise<s.DescribeFeatureGroupResponse> {
    const body: jsonP.JSONObject = {
      FeatureGroupName: params["FeatureGroupName"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFeatureGroup",
    });
    return jsonP.readObj({
      required: {
        "FeatureGroupArn": "s",
        "FeatureGroupName": "s",
        "RecordIdentifierFeatureName": "s",
        "EventTimeFeatureName": "s",
        "FeatureDefinitions": [toFeatureDefinition],
        "CreationTime": "d",
        "NextToken": "s",
      },
      optional: {
        "OnlineStoreConfig": toOnlineStoreConfig,
        "OfflineStoreConfig": toOfflineStoreConfig,
        "RoleArn": "s",
        "FeatureGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeatureGroupStatus>(x),
        "OfflineStoreStatus": toOfflineStoreStatus,
        "FailureReason": "s",
        "Description": "s",
      },
    }, await resp.json());
  }

  async describeFlowDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeFlowDefinitionRequest,
  ): Promise<s.DescribeFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFlowDefinition",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionArn": "s",
        "FlowDefinitionName": "s",
        "FlowDefinitionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FlowDefinitionStatus>(x),
        "CreationTime": "d",
        "HumanLoopConfig": toHumanLoopConfig,
        "OutputConfig": toFlowDefinitionOutputConfig,
        "RoleArn": "s",
      },
      optional: {
        "HumanLoopRequestSource": toHumanLoopRequestSource,
        "HumanLoopActivationConfig": toHumanLoopActivationConfig,
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async describeHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & s.DescribeHumanTaskUiRequest,
  ): Promise<s.DescribeHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHumanTaskUi",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiArn": "s",
        "HumanTaskUiName": "s",
        "CreationTime": "d",
        "UiTemplate": toUiTemplateInfo,
      },
      optional: {
        "HumanTaskUiStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.HumanTaskUiStatus>(x),
      },
    }, await resp.json());
  }

  async describeHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeHyperParameterTuningJobRequest,
  ): Promise<s.DescribeHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobName": "s",
        "HyperParameterTuningJobArn": "s",
        "HyperParameterTuningJobConfig": toHyperParameterTuningJobConfig,
        "HyperParameterTuningJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobStatus>(x),
        "CreationTime": "d",
        "TrainingJobStatusCounters": toTrainingJobStatusCounters,
        "ObjectiveStatusCounters": toObjectiveStatusCounters,
      },
      optional: {
        "TrainingJobDefinition": toHyperParameterTrainingJobDefinition,
        "TrainingJobDefinitions": [toHyperParameterTrainingJobDefinition],
        "HyperParameterTuningEndTime": "d",
        "LastModifiedTime": "d",
        "BestTrainingJob": toHyperParameterTrainingJobSummary,
        "OverallBestTrainingJob": toHyperParameterTrainingJobSummary,
        "WarmStartConfig": toHyperParameterTuningJobWarmStartConfig,
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async describeImage(
    {abortSignal, ...params}: RequestConfig & s.DescribeImageRequest,
  ): Promise<s.DescribeImageResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CreationTime": "d",
        "Description": "s",
        "DisplayName": "s",
        "FailureReason": "s",
        "ImageArn": "s",
        "ImageName": "s",
        "ImageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageStatus>(x),
        "LastModifiedTime": "d",
        "RoleArn": "s",
      },
    }, await resp.json());
  }

  async describeImageVersion(
    {abortSignal, ...params}: RequestConfig & s.DescribeImageVersionRequest,
  ): Promise<s.DescribeImageVersionResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
      Version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaseImage": "s",
        "ContainerImage": "s",
        "CreationTime": "d",
        "FailureReason": "s",
        "ImageArn": "s",
        "ImageVersionArn": "s",
        "ImageVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageVersionStatus>(x),
        "LastModifiedTime": "d",
        "Version": "n",
      },
    }, await resp.json());
  }

  async describeLabelingJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeLabelingJobRequest,
  ): Promise<s.DescribeLabelingJobResponse> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLabelingJob",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LabelingJobStatus>(x),
        "LabelCounters": toLabelCounters,
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "JobReferenceCode": "s",
        "LabelingJobName": "s",
        "LabelingJobArn": "s",
        "InputConfig": toLabelingJobInputConfig,
        "OutputConfig": toLabelingJobOutputConfig,
        "RoleArn": "s",
        "HumanTaskConfig": toHumanTaskConfig,
      },
      optional: {
        "FailureReason": "s",
        "LabelAttributeName": "s",
        "LabelCategoryConfigS3Uri": "s",
        "StoppingConditions": toLabelingJobStoppingConditions,
        "LabelingJobAlgorithmsConfig": toLabelingJobAlgorithmsConfig,
        "Tags": [toTag],
        "LabelingJobOutput": toLabelingJobOutput,
      },
    }, await resp.json());
  }

  async describeModel(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelInput,
  ): Promise<s.DescribeModelOutput> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModel",
    });
    return jsonP.readObj({
      required: {
        "ModelName": "s",
        "ExecutionRoleArn": "s",
        "CreationTime": "d",
        "ModelArn": "s",
      },
      optional: {
        "PrimaryContainer": toContainerDefinition,
        "Containers": [toContainerDefinition],
        "VpcConfig": toVpcConfig,
        "EnableNetworkIsolation": "b",
      },
    }, await resp.json());
  }

  async describeModelBiasJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelBiasJobDefinitionRequest,
  ): Promise<s.DescribeModelBiasJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelBiasJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
        "JobDefinitionName": "s",
        "CreationTime": "d",
        "ModelBiasAppSpecification": toModelBiasAppSpecification,
        "ModelBiasJobInput": toModelBiasJobInput,
        "ModelBiasJobOutputConfig": toMonitoringOutputConfig,
        "JobResources": toMonitoringResources,
        "RoleArn": "s",
      },
      optional: {
        "ModelBiasBaselineConfig": toModelBiasBaselineConfig,
        "NetworkConfig": toMonitoringNetworkConfig,
        "StoppingCondition": toMonitoringStoppingCondition,
      },
    }, await resp.json());
  }

  async describeModelExplainabilityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelExplainabilityJobDefinitionRequest,
  ): Promise<s.DescribeModelExplainabilityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelExplainabilityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
        "JobDefinitionName": "s",
        "CreationTime": "d",
        "ModelExplainabilityAppSpecification": toModelExplainabilityAppSpecification,
        "ModelExplainabilityJobInput": toModelExplainabilityJobInput,
        "ModelExplainabilityJobOutputConfig": toMonitoringOutputConfig,
        "JobResources": toMonitoringResources,
        "RoleArn": "s",
      },
      optional: {
        "ModelExplainabilityBaselineConfig": toModelExplainabilityBaselineConfig,
        "NetworkConfig": toMonitoringNetworkConfig,
        "StoppingCondition": toMonitoringStoppingCondition,
      },
    }, await resp.json());
  }

  async describeModelPackage(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelPackageInput,
  ): Promise<s.DescribeModelPackageOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelPackage",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageName": "s",
        "ModelPackageArn": "s",
        "CreationTime": "d",
        "ModelPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageStatus>(x),
        "ModelPackageStatusDetails": toModelPackageStatusDetails,
      },
      optional: {
        "ModelPackageGroupName": "s",
        "ModelPackageVersion": "n",
        "ModelPackageDescription": "s",
        "InferenceSpecification": toInferenceSpecification,
        "SourceAlgorithmSpecification": toSourceAlgorithmSpecification,
        "ValidationSpecification": toModelPackageValidationSpecification,
        "CertifyForMarketplace": "b",
        "ModelApprovalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelApprovalStatus>(x),
        "CreatedBy": toUserContext,
        "MetadataProperties": toMetadataProperties,
        "ModelMetrics": toModelMetrics,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "ApprovalDescription": "s",
      },
    }, await resp.json());
  }

  async describeModelPackageGroup(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelPackageGroupInput,
  ): Promise<s.DescribeModelPackageGroupOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelPackageGroup",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageGroupName": "s",
        "ModelPackageGroupArn": "s",
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "ModelPackageGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageGroupStatus>(x),
      },
      optional: {
        "ModelPackageGroupDescription": "s",
      },
    }, await resp.json());
  }

  async describeModelQualityJobDefinition(
    {abortSignal, ...params}: RequestConfig & s.DescribeModelQualityJobDefinitionRequest,
  ): Promise<s.DescribeModelQualityJobDefinitionResponse> {
    const body: jsonP.JSONObject = {
      JobDefinitionName: params["JobDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelQualityJobDefinition",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionArn": "s",
        "JobDefinitionName": "s",
        "CreationTime": "d",
        "ModelQualityAppSpecification": toModelQualityAppSpecification,
        "ModelQualityJobInput": toModelQualityJobInput,
        "ModelQualityJobOutputConfig": toMonitoringOutputConfig,
        "JobResources": toMonitoringResources,
        "RoleArn": "s",
      },
      optional: {
        "ModelQualityBaselineConfig": toModelQualityBaselineConfig,
        "NetworkConfig": toMonitoringNetworkConfig,
        "StoppingCondition": toMonitoringStoppingCondition,
      },
    }, await resp.json());
  }

  async describeMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.DescribeMonitoringScheduleRequest,
  ): Promise<s.DescribeMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
        "MonitoringScheduleName": "s",
        "MonitoringScheduleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "MonitoringScheduleConfig": toMonitoringScheduleConfig,
      },
      optional: {
        "MonitoringType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringType>(x),
        "FailureReason": "s",
        "EndpointName": "s",
        "LastMonitoringExecutionSummary": toMonitoringExecutionSummary,
      },
    }, await resp.json());
  }

  async describeNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotebookInstanceInput,
  ): Promise<s.DescribeNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceArn": "s",
        "NotebookInstanceName": "s",
        "NotebookInstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookInstanceStatus>(x),
        "FailureReason": "s",
        "Url": "s",
        "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceType>(x),
        "SubnetId": "s",
        "SecurityGroups": ["s"],
        "RoleArn": "s",
        "KmsKeyId": "s",
        "NetworkInterfaceId": "s",
        "LastModifiedTime": "d",
        "CreationTime": "d",
        "NotebookInstanceLifecycleConfigName": "s",
        "DirectInternetAccess": (x: jsonP.JSONValue) => cmnP.readEnum<s.DirectInternetAccess>(x),
        "VolumeSizeInGB": "n",
        "AcceleratorTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookInstanceAcceleratorType>(x)],
        "DefaultCodeRepository": "s",
        "AdditionalCodeRepositories": ["s"],
        "RootAccess": (x: jsonP.JSONValue) => cmnP.readEnum<s.RootAccess>(x),
      },
    }, await resp.json());
  }

  async describeNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & s.DescribeNotebookInstanceLifecycleConfigInput,
  ): Promise<s.DescribeNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceLifecycleConfigArn": "s",
        "NotebookInstanceLifecycleConfigName": "s",
        "OnCreate": [toNotebookInstanceLifecycleHook],
        "OnStart": [toNotebookInstanceLifecycleHook],
        "LastModifiedTime": "d",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

  async describePipeline(
    {abortSignal, ...params}: RequestConfig & s.DescribePipelineRequest,
  ): Promise<s.DescribePipelineResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineArn": "s",
        "PipelineName": "s",
        "PipelineDisplayName": "s",
        "PipelineDefinition": "s",
        "PipelineDescription": "s",
        "RoleArn": "s",
        "PipelineStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "LastRunTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describePipelineDefinitionForExecution(
    {abortSignal, ...params}: RequestConfig & s.DescribePipelineDefinitionForExecutionRequest,
  ): Promise<s.DescribePipelineDefinitionForExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePipelineDefinitionForExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineDefinition": "s",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

  async describePipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.DescribePipelineExecutionRequest,
  ): Promise<s.DescribePipelineExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineArn": "s",
        "PipelineExecutionArn": "s",
        "PipelineExecutionDisplayName": "s",
        "PipelineExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStatus>(x),
        "PipelineExecutionDescription": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeProcessingJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeProcessingJobRequest,
  ): Promise<s.DescribeProcessingJobResponse> {
    const body: jsonP.JSONObject = {
      ProcessingJobName: params["ProcessingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeProcessingJob",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobName": "s",
        "ProcessingResources": toProcessingResources,
        "AppSpecification": toAppSpecification,
        "ProcessingJobArn": "s",
        "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingJobStatus>(x),
        "CreationTime": "d",
      },
      optional: {
        "ProcessingInputs": [toProcessingInput],
        "ProcessingOutputConfig": toProcessingOutputConfig,
        "StoppingCondition": toProcessingStoppingCondition,
        "Environment": x => jsonP.readMap(String, String, x),
        "NetworkConfig": toNetworkConfig,
        "RoleArn": "s",
        "ExperimentConfig": toExperimentConfig,
        "ExitMessage": "s",
        "FailureReason": "s",
        "ProcessingEndTime": "d",
        "ProcessingStartTime": "d",
        "LastModifiedTime": "d",
        "MonitoringScheduleArn": "s",
        "AutoMLJobArn": "s",
        "TrainingJobArn": "s",
      },
    }, await resp.json());
  }

  async describeProject(
    {abortSignal, ...params}: RequestConfig & s.DescribeProjectInput,
  ): Promise<s.DescribeProjectOutput> {
    const body: jsonP.JSONObject = {
      ProjectName: params["ProjectName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeProject",
    });
    return jsonP.readObj({
      required: {
        "ProjectArn": "s",
        "ProjectName": "s",
        "ProjectId": "s",
        "ServiceCatalogProvisioningDetails": toServiceCatalogProvisioningDetails,
        "ProjectStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectStatus>(x),
        "CreationTime": "d",
      },
      optional: {
        "ProjectDescription": "s",
        "ServiceCatalogProvisionedProductDetails": toServiceCatalogProvisionedProductDetails,
        "CreatedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeSubscribedWorkteam(
    {abortSignal, ...params}: RequestConfig & s.DescribeSubscribedWorkteamRequest,
  ): Promise<s.DescribeSubscribedWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamArn: params["WorkteamArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubscribedWorkteam",
    });
    return jsonP.readObj({
      required: {
        "SubscribedWorkteam": toSubscribedWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  async describeTrainingJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrainingJobRequest,
  ): Promise<s.DescribeTrainingJobResponse> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrainingJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobName": "s",
        "TrainingJobArn": "s",
        "ModelArtifacts": toModelArtifacts,
        "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingJobStatus>(x),
        "SecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecondaryStatus>(x),
        "AlgorithmSpecification": toAlgorithmSpecification,
        "ResourceConfig": toResourceConfig,
        "StoppingCondition": toStoppingCondition,
        "CreationTime": "d",
      },
      optional: {
        "TuningJobArn": "s",
        "LabelingJobArn": "s",
        "AutoMLJobArn": "s",
        "FailureReason": "s",
        "HyperParameters": x => jsonP.readMap(String, String, x),
        "RoleArn": "s",
        "InputDataConfig": [toChannel],
        "OutputDataConfig": toOutputDataConfig,
        "VpcConfig": toVpcConfig,
        "TrainingStartTime": "d",
        "TrainingEndTime": "d",
        "LastModifiedTime": "d",
        "SecondaryStatusTransitions": [toSecondaryStatusTransition],
        "FinalMetricDataList": [toMetricData],
        "EnableNetworkIsolation": "b",
        "EnableInterContainerTrafficEncryption": "b",
        "EnableManagedSpotTraining": "b",
        "CheckpointConfig": toCheckpointConfig,
        "TrainingTimeInSeconds": "n",
        "BillableTimeInSeconds": "n",
        "DebugHookConfig": toDebugHookConfig,
        "ExperimentConfig": toExperimentConfig,
        "DebugRuleConfigurations": [toDebugRuleConfiguration],
        "TensorBoardOutputConfig": toTensorBoardOutputConfig,
        "DebugRuleEvaluationStatuses": [toDebugRuleEvaluationStatus],
        "ProfilerConfig": toProfilerConfig,
        "ProfilerRuleConfigurations": [toProfilerRuleConfiguration],
        "ProfilerRuleEvaluationStatuses": [toProfilerRuleEvaluationStatus],
        "ProfilingStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProfilingStatus>(x),
      },
    }, await resp.json());
  }

  async describeTransformJob(
    {abortSignal, ...params}: RequestConfig & s.DescribeTransformJobRequest,
  ): Promise<s.DescribeTransformJobResponse> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransformJob",
    });
    return jsonP.readObj({
      required: {
        "TransformJobName": "s",
        "TransformJobArn": "s",
        "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformJobStatus>(x),
        "ModelName": "s",
        "TransformInput": toTransformInput,
        "TransformResources": toTransformResources,
        "CreationTime": "d",
      },
      optional: {
        "FailureReason": "s",
        "MaxConcurrentTransforms": "n",
        "ModelClientConfig": toModelClientConfig,
        "MaxPayloadInMB": "n",
        "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchStrategy>(x),
        "Environment": x => jsonP.readMap(String, String, x),
        "TransformOutput": toTransformOutput,
        "TransformStartTime": "d",
        "TransformEndTime": "d",
        "LabelingJobArn": "s",
        "AutoMLJobArn": "s",
        "DataProcessing": toDataProcessing,
        "ExperimentConfig": toExperimentConfig,
      },
    }, await resp.json());
  }

  async describeTrial(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrialRequest,
  ): Promise<s.DescribeTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialName": "s",
        "TrialArn": "s",
        "DisplayName": "s",
        "ExperimentName": "s",
        "Source": toTrialSource,
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "MetadataProperties": toMetadataProperties,
      },
    }, await resp.json());
  }

  async describeTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.DescribeTrialComponentRequest,
  ): Promise<s.DescribeTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentName": "s",
        "TrialComponentArn": "s",
        "DisplayName": "s",
        "Source": toTrialComponentSource,
        "Status": toTrialComponentStatus,
        "StartTime": "d",
        "EndTime": "d",
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "Parameters": x => jsonP.readMap(String, toTrialComponentParameterValue, x),
        "InputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
        "OutputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
        "MetadataProperties": toMetadataProperties,
        "Metrics": [toTrialComponentMetricSummary],
      },
    }, await resp.json());
  }

  async describeUserProfile(
    {abortSignal, ...params}: RequestConfig & s.DescribeUserProfileRequest,
  ): Promise<s.DescribeUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainId": "s",
        "UserProfileArn": "s",
        "UserProfileName": "s",
        "HomeEfsFileSystemUid": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserProfileStatus>(x),
        "LastModifiedTime": "d",
        "CreationTime": "d",
        "FailureReason": "s",
        "SingleSignOnUserIdentifier": "s",
        "SingleSignOnUserValue": "s",
        "UserSettings": toUserSettings,
      },
    }, await resp.json());
  }

  async describeWorkforce(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorkforceRequest,
  ): Promise<s.DescribeWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkforce",
    });
    return jsonP.readObj({
      required: {
        "Workforce": toWorkforce,
      },
      optional: {},
    }, await resp.json());
  }

  async describeWorkteam(
    {abortSignal, ...params}: RequestConfig & s.DescribeWorkteamRequest,
  ): Promise<s.DescribeWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Workteam": toWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  async disableSagemakerServicecatalogPortfolio(
    {abortSignal, ...params}: RequestConfig & s.DisableSagemakerServicecatalogPortfolioInput = {},
  ): Promise<s.DisableSagemakerServicecatalogPortfolioOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisableSagemakerServicecatalogPortfolio",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async disassociateTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.DisassociateTrialComponentRequest,
  ): Promise<s.DisassociateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async enableSagemakerServicecatalogPortfolio(
    {abortSignal, ...params}: RequestConfig & s.EnableSagemakerServicecatalogPortfolioInput = {},
  ): Promise<s.EnableSagemakerServicecatalogPortfolioOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EnableSagemakerServicecatalogPortfolio",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async getDeviceFleetReport(
    {abortSignal, ...params}: RequestConfig & s.GetDeviceFleetReportRequest,
  ): Promise<s.GetDeviceFleetReportResponse> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDeviceFleetReport",
    });
    return jsonP.readObj({
      required: {
        "DeviceFleetArn": "s",
        "DeviceFleetName": "s",
      },
      optional: {
        "OutputConfig": toEdgeOutputConfig,
        "Description": "s",
        "ReportGenerated": "d",
        "DeviceStats": toDeviceStats,
        "AgentVersions": [toAgentVersion],
        "ModelStats": [toEdgeModelStat],
      },
    }, await resp.json());
  }

  async getModelPackageGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetModelPackageGroupPolicyInput,
  ): Promise<s.GetModelPackageGroupPolicyOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetModelPackageGroupPolicy",
    });
    return jsonP.readObj({
      required: {
        "ResourcePolicy": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getSagemakerServicecatalogPortfolioStatus(
    {abortSignal, ...params}: RequestConfig & s.GetSagemakerServicecatalogPortfolioStatusInput = {},
  ): Promise<s.GetSagemakerServicecatalogPortfolioStatusOutput> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSagemakerServicecatalogPortfolioStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SagemakerServicecatalogStatus>(x),
      },
    }, await resp.json());
  }

  async getSearchSuggestions(
    {abortSignal, ...params}: RequestConfig & s.GetSearchSuggestionsRequest,
  ): Promise<s.GetSearchSuggestionsResponse> {
    const body: jsonP.JSONObject = {
      Resource: params["Resource"],
      SuggestionQuery: fromSuggestionQuery(params["SuggestionQuery"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSearchSuggestions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PropertyNameSuggestions": [toPropertyNameSuggestion],
      },
    }, await resp.json());
  }

  async listActions(
    {abortSignal, ...params}: RequestConfig & s.ListActionsRequest = {},
  ): Promise<s.ListActionsResponse> {
    const body: jsonP.JSONObject = {
      SourceUri: params["SourceUri"],
      ActionType: params["ActionType"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListActions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActionSummaries": [toActionSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAlgorithms(
    {abortSignal, ...params}: RequestConfig & s.ListAlgorithmsInput = {},
  ): Promise<s.ListAlgorithmsOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAlgorithms",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmSummaryList": [toAlgorithmSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAppImageConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListAppImageConfigsRequest = {},
  ): Promise<s.ListAppImageConfigsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      ModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["ModifiedTimeBefore"]),
      ModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["ModifiedTimeAfter"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAppImageConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "AppImageConfigs": [toAppImageConfigDetails],
      },
    }, await resp.json());
  }

  async listApps(
    {abortSignal, ...params}: RequestConfig & s.ListAppsRequest = {},
  ): Promise<s.ListAppsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      DomainIdEquals: params["DomainIdEquals"],
      UserProfileNameEquals: params["UserProfileNameEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Apps": [toAppDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listArtifacts(
    {abortSignal, ...params}: RequestConfig & s.ListArtifactsRequest = {},
  ): Promise<s.ListArtifactsResponse> {
    const body: jsonP.JSONObject = {
      SourceUri: params["SourceUri"],
      ArtifactType: params["ArtifactType"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListArtifacts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArtifactSummaries": [toArtifactSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAssociations(
    {abortSignal, ...params}: RequestConfig & s.ListAssociationsRequest = {},
  ): Promise<s.ListAssociationsResponse> {
    const body: jsonP.JSONObject = {
      SourceArn: params["SourceArn"],
      DestinationArn: params["DestinationArn"],
      SourceType: params["SourceType"],
      DestinationType: params["DestinationType"],
      AssociationType: params["AssociationType"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAssociations",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AssociationSummaries": [toAssociationSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAutoMLJobs(
    {abortSignal, ...params}: RequestConfig & s.ListAutoMLJobsRequest = {},
  ): Promise<s.ListAutoMLJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAutoMLJobs",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobSummaries": [toAutoMLJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCandidatesForAutoMLJob(
    {abortSignal, ...params}: RequestConfig & s.ListCandidatesForAutoMLJobRequest,
  ): Promise<s.ListCandidatesForAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
      StatusEquals: params["StatusEquals"],
      CandidateNameEquals: params["CandidateNameEquals"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCandidatesForAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "Candidates": [toAutoMLCandidate],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCodeRepositories(
    {abortSignal, ...params}: RequestConfig & s.ListCodeRepositoriesInput = {},
  ): Promise<s.ListCodeRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCodeRepositories",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositorySummaryList": [toCodeRepositorySummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCompilationJobs(
    {abortSignal, ...params}: RequestConfig & s.ListCompilationJobsRequest = {},
  ): Promise<s.ListCompilationJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCompilationJobs",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobSummaries": [toCompilationJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listContexts(
    {abortSignal, ...params}: RequestConfig & s.ListContextsRequest = {},
  ): Promise<s.ListContextsResponse> {
    const body: jsonP.JSONObject = {
      SourceUri: params["SourceUri"],
      ContextType: params["ContextType"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListContexts",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContextSummaries": [toContextSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDataQualityJobDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListDataQualityJobDefinitionsRequest = {},
  ): Promise<s.ListDataQualityJobDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDataQualityJobDefinitions",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionSummaries": [toMonitoringJobDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDeviceFleets(
    {abortSignal, ...params}: RequestConfig & s.ListDeviceFleetsRequest = {},
  ): Promise<s.ListDeviceFleetsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDeviceFleets",
    });
    return jsonP.readObj({
      required: {
        "DeviceFleetSummaries": [toDeviceFleetSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDevices(
    {abortSignal, ...params}: RequestConfig & s.ListDevicesRequest = {},
  ): Promise<s.ListDevicesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      LatestHeartbeatAfter: jsonP.serializeDate_unixTimestamp(params["LatestHeartbeatAfter"]),
      ModelName: params["ModelName"],
      DeviceFleetName: params["DeviceFleetName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDevices",
    });
    return jsonP.readObj({
      required: {
        "DeviceSummaries": [toDeviceSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & s.ListDomainsRequest = {},
  ): Promise<s.ListDomainsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Domains": [toDomainDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEdgePackagingJobs(
    {abortSignal, ...params}: RequestConfig & s.ListEdgePackagingJobsRequest = {},
  ): Promise<s.ListEdgePackagingJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      ModelNameContains: params["ModelNameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEdgePackagingJobs",
    });
    return jsonP.readObj({
      required: {
        "EdgePackagingJobSummaries": [toEdgePackagingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEndpointConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListEndpointConfigsInput = {},
  ): Promise<s.ListEndpointConfigsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEndpointConfigs",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigs": [toEndpointConfigSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEndpoints(
    {abortSignal, ...params}: RequestConfig & s.ListEndpointsInput = {},
  ): Promise<s.ListEndpointsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpointSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listExperiments(
    {abortSignal, ...params}: RequestConfig & s.ListExperimentsRequest = {},
  ): Promise<s.ListExperimentsResponse> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListExperiments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentSummaries": [toExperimentSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFeatureGroups(
    {abortSignal, ...params}: RequestConfig & s.ListFeatureGroupsRequest = {},
  ): Promise<s.ListFeatureGroupsResponse> {
    const body: jsonP.JSONObject = {
      NameContains: params["NameContains"],
      FeatureGroupStatusEquals: params["FeatureGroupStatusEquals"],
      OfflineStoreStatusEquals: params["OfflineStoreStatusEquals"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFeatureGroups",
    });
    return jsonP.readObj({
      required: {
        "FeatureGroupSummaries": [toFeatureGroupSummary],
        "NextToken": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async listFlowDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListFlowDefinitionsRequest = {},
  ): Promise<s.ListFlowDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFlowDefinitions",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionSummaries": [toFlowDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHumanTaskUis(
    {abortSignal, ...params}: RequestConfig & s.ListHumanTaskUisRequest = {},
  ): Promise<s.ListHumanTaskUisResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHumanTaskUis",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiSummaries": [toHumanTaskUiSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHyperParameterTuningJobs(
    {abortSignal, ...params}: RequestConfig & s.ListHyperParameterTuningJobsRequest = {},
  ): Promise<s.ListHyperParameterTuningJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHyperParameterTuningJobs",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobSummaries": [toHyperParameterTuningJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listImageVersions(
    {abortSignal, ...params}: RequestConfig & s.ListImageVersionsRequest,
  ): Promise<s.ListImageVersionsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      ImageName: params["ImageName"],
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImageVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageVersions": [toImageVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listImages(
    {abortSignal, ...params}: RequestConfig & s.ListImagesRequest = {},
  ): Promise<s.ListImagesResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Images": [toImage],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLabelingJobs(
    {abortSignal, ...params}: RequestConfig & s.ListLabelingJobsRequest = {},
  ): Promise<s.ListLabelingJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      NameContains: params["NameContains"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLabelingJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LabelingJobSummaryList": [toLabelingJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLabelingJobsForWorkteam(
    {abortSignal, ...params}: RequestConfig & s.ListLabelingJobsForWorkteamRequest,
  ): Promise<s.ListLabelingJobsForWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamArn: params["WorkteamArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      JobReferenceCodeContains: params["JobReferenceCodeContains"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLabelingJobsForWorkteam",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobSummaryList": [toLabelingJobForWorkteamSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelBiasJobDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListModelBiasJobDefinitionsRequest = {},
  ): Promise<s.ListModelBiasJobDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelBiasJobDefinitions",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionSummaries": [toMonitoringJobDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelExplainabilityJobDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListModelExplainabilityJobDefinitionsRequest = {},
  ): Promise<s.ListModelExplainabilityJobDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelExplainabilityJobDefinitions",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionSummaries": [toMonitoringJobDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelPackageGroups(
    {abortSignal, ...params}: RequestConfig & s.ListModelPackageGroupsInput = {},
  ): Promise<s.ListModelPackageGroupsOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelPackageGroups",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageGroupSummaryList": [toModelPackageGroupSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelPackages(
    {abortSignal, ...params}: RequestConfig & s.ListModelPackagesInput = {},
  ): Promise<s.ListModelPackagesOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      ModelApprovalStatus: params["ModelApprovalStatus"],
      ModelPackageGroupName: params["ModelPackageGroupName"],
      ModelPackageType: params["ModelPackageType"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelPackages",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageSummaryList": [toModelPackageSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelQualityJobDefinitions(
    {abortSignal, ...params}: RequestConfig & s.ListModelQualityJobDefinitionsRequest = {},
  ): Promise<s.ListModelQualityJobDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelQualityJobDefinitions",
    });
    return jsonP.readObj({
      required: {
        "JobDefinitionSummaries": [toMonitoringJobDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModels(
    {abortSignal, ...params}: RequestConfig & s.ListModelsInput = {},
  ): Promise<s.ListModelsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModels",
    });
    return jsonP.readObj({
      required: {
        "Models": [toModelSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMonitoringExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListMonitoringExecutionsRequest = {},
  ): Promise<s.ListMonitoringExecutionsResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ScheduledTimeBefore: jsonP.serializeDate_unixTimestamp(params["ScheduledTimeBefore"]),
      ScheduledTimeAfter: jsonP.serializeDate_unixTimestamp(params["ScheduledTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
      MonitoringJobDefinitionName: params["MonitoringJobDefinitionName"],
      MonitoringTypeEquals: params["MonitoringTypeEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMonitoringExecutions",
    });
    return jsonP.readObj({
      required: {
        "MonitoringExecutionSummaries": [toMonitoringExecutionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMonitoringSchedules(
    {abortSignal, ...params}: RequestConfig & s.ListMonitoringSchedulesRequest = {},
  ): Promise<s.ListMonitoringSchedulesResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
      MonitoringJobDefinitionName: params["MonitoringJobDefinitionName"],
      MonitoringTypeEquals: params["MonitoringTypeEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMonitoringSchedules",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleSummaries": [toMonitoringScheduleSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNotebookInstanceLifecycleConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListNotebookInstanceLifecycleConfigsInput = {},
  ): Promise<s.ListNotebookInstanceLifecycleConfigsOutput> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookInstanceLifecycleConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NotebookInstanceLifecycleConfigs": [toNotebookInstanceLifecycleConfigSummary],
      },
    }, await resp.json());
  }

  async listNotebookInstances(
    {abortSignal, ...params}: RequestConfig & s.ListNotebookInstancesInput = {},
  ): Promise<s.ListNotebookInstancesOutput> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
      NotebookInstanceLifecycleConfigNameContains: params["NotebookInstanceLifecycleConfigNameContains"],
      DefaultCodeRepositoryContains: params["DefaultCodeRepositoryContains"],
      AdditionalCodeRepositoryEquals: params["AdditionalCodeRepositoryEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NotebookInstances": [toNotebookInstanceSummary],
      },
    }, await resp.json());
  }

  async listPipelineExecutionSteps(
    {abortSignal, ...params}: RequestConfig & s.ListPipelineExecutionStepsRequest = {},
  ): Promise<s.ListPipelineExecutionStepsResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelineExecutionSteps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineExecutionSteps": [toPipelineExecutionStep],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelineExecutions(
    {abortSignal, ...params}: RequestConfig & s.ListPipelineExecutionsRequest,
  ): Promise<s.ListPipelineExecutionsResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelineExecutions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineExecutionSummaries": [toPipelineExecutionSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelineParametersForExecution(
    {abortSignal, ...params}: RequestConfig & s.ListPipelineParametersForExecutionRequest,
  ): Promise<s.ListPipelineParametersForExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelineParametersForExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineParameters": [toParameter],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & s.ListPipelinesRequest = {},
  ): Promise<s.ListPipelinesResponse> {
    const body: jsonP.JSONObject = {
      PipelineNamePrefix: params["PipelineNamePrefix"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelines",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineSummaries": [toPipelineSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProcessingJobs(
    {abortSignal, ...params}: RequestConfig & s.ListProcessingJobsRequest = {},
  ): Promise<s.ListProcessingJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListProcessingJobs",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobSummaries": [toProcessingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listProjects(
    {abortSignal, ...params}: RequestConfig & s.ListProjectsInput = {},
  ): Promise<s.ListProjectsOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListProjects",
    });
    return jsonP.readObj({
      required: {
        "ProjectSummaryList": [toProjectSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSubscribedWorkteams(
    {abortSignal, ...params}: RequestConfig & s.ListSubscribedWorkteamsRequest = {},
  ): Promise<s.ListSubscribedWorkteamsResponse> {
    const body: jsonP.JSONObject = {
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSubscribedWorkteams",
    });
    return jsonP.readObj({
      required: {
        "SubscribedWorkteams": [toSubscribedWorkteam],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & s.ListTagsInput,
  ): Promise<s.ListTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrainingJobs(
    {abortSignal, ...params}: RequestConfig & s.ListTrainingJobsRequest = {},
  ): Promise<s.ListTrainingJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrainingJobs",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobSummaries": [toTrainingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrainingJobsForHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & s.ListTrainingJobsForHyperParameterTuningJobRequest,
  ): Promise<s.ListTrainingJobsForHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrainingJobsForHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobSummaries": [toHyperParameterTrainingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTransformJobs(
    {abortSignal, ...params}: RequestConfig & s.ListTransformJobsRequest = {},
  ): Promise<s.ListTransformJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTransformJobs",
    });
    return jsonP.readObj({
      required: {
        "TransformJobSummaries": [toTransformJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrialComponents(
    {abortSignal, ...params}: RequestConfig & s.ListTrialComponentsRequest = {},
  ): Promise<s.ListTrialComponentsResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      TrialName: params["TrialName"],
      SourceArn: params["SourceArn"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrialComponents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentSummaries": [toTrialComponentSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrials(
    {abortSignal, ...params}: RequestConfig & s.ListTrialsRequest = {},
  ): Promise<s.ListTrialsResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      TrialComponentName: params["TrialComponentName"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialSummaries": [toTrialSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listUserProfiles(
    {abortSignal, ...params}: RequestConfig & s.ListUserProfilesRequest = {},
  ): Promise<s.ListUserProfilesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      DomainIdEquals: params["DomainIdEquals"],
      UserProfileNameContains: params["UserProfileNameContains"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserProfiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfiles": [toUserProfileDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkforces(
    {abortSignal, ...params}: RequestConfig & s.ListWorkforcesRequest = {},
  ): Promise<s.ListWorkforcesResponse> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkforces",
    });
    return jsonP.readObj({
      required: {
        "Workforces": [toWorkforce],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkteams(
    {abortSignal, ...params}: RequestConfig & s.ListWorkteamsRequest = {},
  ): Promise<s.ListWorkteamsResponse> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkteams",
    });
    return jsonP.readObj({
      required: {
        "Workteams": [toWorkteam],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async putModelPackageGroupPolicy(
    {abortSignal, ...params}: RequestConfig & s.PutModelPackageGroupPolicyInput,
  ): Promise<s.PutModelPackageGroupPolicyOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageGroupName: params["ModelPackageGroupName"],
      ResourcePolicy: params["ResourcePolicy"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutModelPackageGroupPolicy",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageGroupArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async registerDevices(
    {abortSignal, ...params}: RequestConfig & s.RegisterDevicesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
      Devices: params["Devices"]?.map(x => fromDevice(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RegisterDevices",
    });
  }

  async renderUiTemplate(
    {abortSignal, ...params}: RequestConfig & s.RenderUiTemplateRequest,
  ): Promise<s.RenderUiTemplateResponse> {
    const body: jsonP.JSONObject = {
      UiTemplate: fromUiTemplate(params["UiTemplate"]),
      Task: fromRenderableTask(params["Task"]),
      RoleArn: params["RoleArn"],
      HumanTaskUiArn: params["HumanTaskUiArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RenderUiTemplate",
    });
    return jsonP.readObj({
      required: {
        "RenderedContent": "s",
        "Errors": [toRenderingError],
      },
      optional: {},
    }, await resp.json());
  }

  async search(
    {abortSignal, ...params}: RequestConfig & s.SearchRequest,
  ): Promise<s.SearchResponse> {
    const body: jsonP.JSONObject = {
      Resource: params["Resource"],
      SearchExpression: fromSearchExpression(params["SearchExpression"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toSearchRecord],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.StartMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMonitoringSchedule",
    });
  }

  async startNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.StartNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNotebookInstance",
    });
  }

  async startPipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.StartPipelineExecutionRequest,
  ): Promise<s.StartPipelineExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
      PipelineExecutionDisplayName: params["PipelineExecutionDisplayName"],
      PipelineParameters: params["PipelineParameters"]?.map(x => fromParameter(x)),
      PipelineExecutionDescription: params["PipelineExecutionDescription"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartPipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineExecutionArn": "s",
      },
    }, await resp.json());
  }

  async stopAutoMLJob(
    {abortSignal, ...params}: RequestConfig & s.StopAutoMLJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopAutoMLJob",
    });
  }

  async stopCompilationJob(
    {abortSignal, ...params}: RequestConfig & s.StopCompilationJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCompilationJob",
    });
  }

  async stopEdgePackagingJob(
    {abortSignal, ...params}: RequestConfig & s.StopEdgePackagingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EdgePackagingJobName: params["EdgePackagingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopEdgePackagingJob",
    });
  }

  async stopHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & s.StopHyperParameterTuningJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopHyperParameterTuningJob",
    });
  }

  async stopLabelingJob(
    {abortSignal, ...params}: RequestConfig & s.StopLabelingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopLabelingJob",
    });
  }

  async stopMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.StopMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopMonitoringSchedule",
    });
  }

  async stopNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.StopNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopNotebookInstance",
    });
  }

  async stopPipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.StopPipelineExecutionRequest,
  ): Promise<s.StopPipelineExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
      ClientRequestToken: params["ClientRequestToken"] ?? generateIdemptToken(),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopPipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineExecutionArn": "s",
      },
    }, await resp.json());
  }

  async stopProcessingJob(
    {abortSignal, ...params}: RequestConfig & s.StopProcessingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ProcessingJobName: params["ProcessingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopProcessingJob",
    });
  }

  async stopTrainingJob(
    {abortSignal, ...params}: RequestConfig & s.StopTrainingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrainingJob",
    });
  }

  async stopTransformJob(
    {abortSignal, ...params}: RequestConfig & s.StopTransformJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTransformJob",
    });
  }

  async updateAction(
    {abortSignal, ...params}: RequestConfig & s.UpdateActionRequest,
  ): Promise<s.UpdateActionResponse> {
    const body: jsonP.JSONObject = {
      ActionName: params["ActionName"],
      Description: params["Description"],
      Status: params["Status"],
      Properties: params["Properties"],
      PropertiesToRemove: params["PropertiesToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAction",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ActionArn": "s",
      },
    }, await resp.json());
  }

  async updateAppImageConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateAppImageConfigRequest,
  ): Promise<s.UpdateAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
      KernelGatewayImageConfig: fromKernelGatewayImageConfig(params["KernelGatewayImageConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
      },
    }, await resp.json());
  }

  async updateArtifact(
    {abortSignal, ...params}: RequestConfig & s.UpdateArtifactRequest,
  ): Promise<s.UpdateArtifactResponse> {
    const body: jsonP.JSONObject = {
      ArtifactArn: params["ArtifactArn"],
      ArtifactName: params["ArtifactName"],
      Properties: params["Properties"],
      PropertiesToRemove: params["PropertiesToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateArtifact",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ArtifactArn": "s",
      },
    }, await resp.json());
  }

  async updateCodeRepository(
    {abortSignal, ...params}: RequestConfig & s.UpdateCodeRepositoryInput,
  ): Promise<s.UpdateCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
      GitConfig: fromGitConfigForUpdate(params["GitConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateContext(
    {abortSignal, ...params}: RequestConfig & s.UpdateContextRequest,
  ): Promise<s.UpdateContextResponse> {
    const body: jsonP.JSONObject = {
      ContextName: params["ContextName"],
      Description: params["Description"],
      Properties: params["Properties"],
      PropertiesToRemove: params["PropertiesToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateContext",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ContextArn": "s",
      },
    }, await resp.json());
  }

  async updateDeviceFleet(
    {abortSignal, ...params}: RequestConfig & s.UpdateDeviceFleetRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
      RoleArn: params["RoleArn"],
      Description: params["Description"],
      OutputConfig: fromEdgeOutputConfig(params["OutputConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDeviceFleet",
    });
  }

  async updateDevices(
    {abortSignal, ...params}: RequestConfig & s.UpdateDevicesRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DeviceFleetName: params["DeviceFleetName"],
      Devices: params["Devices"]?.map(x => fromDevice(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDevices",
    });
  }

  async updateDomain(
    {abortSignal, ...params}: RequestConfig & s.UpdateDomainRequest,
  ): Promise<s.UpdateDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      DefaultUserSettings: fromUserSettings(params["DefaultUserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
      },
    }, await resp.json());
  }

  async updateEndpoint(
    {abortSignal, ...params}: RequestConfig & s.UpdateEndpointInput,
  ): Promise<s.UpdateEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      EndpointConfigName: params["EndpointConfigName"],
      RetainAllVariantProperties: params["RetainAllVariantProperties"],
      ExcludeRetainedVariantProperties: params["ExcludeRetainedVariantProperties"]?.map(x => fromVariantProperty(x)),
      DeploymentConfig: fromDeploymentConfig(params["DeploymentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateEndpointWeightsAndCapacities(
    {abortSignal, ...params}: RequestConfig & s.UpdateEndpointWeightsAndCapacitiesInput,
  ): Promise<s.UpdateEndpointWeightsAndCapacitiesOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      DesiredWeightsAndCapacities: params["DesiredWeightsAndCapacities"]?.map(x => fromDesiredWeightAndCapacity(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpointWeightsAndCapacities",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateExperiment(
    {abortSignal, ...params}: RequestConfig & s.UpdateExperimentRequest,
  ): Promise<s.UpdateExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      DisplayName: params["DisplayName"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async updateImage(
    {abortSignal, ...params}: RequestConfig & s.UpdateImageRequest,
  ): Promise<s.UpdateImageResponse> {
    const body: jsonP.JSONObject = {
      DeleteProperties: params["DeleteProperties"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      ImageName: params["ImageName"],
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageArn": "s",
      },
    }, await resp.json());
  }

  async updateModelPackage(
    {abortSignal, ...params}: RequestConfig & s.UpdateModelPackageInput,
  ): Promise<s.UpdateModelPackageOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageArn: params["ModelPackageArn"],
      ModelApprovalStatus: params["ModelApprovalStatus"],
      ApprovalDescription: params["ApprovalDescription"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateModelPackage",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & s.UpdateMonitoringScheduleRequest,
  ): Promise<s.UpdateMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      MonitoringScheduleConfig: fromMonitoringScheduleConfig(params["MonitoringScheduleConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateNotebookInstance(
    {abortSignal, ...params}: RequestConfig & s.UpdateNotebookInstanceInput,
  ): Promise<s.UpdateNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      InstanceType: params["InstanceType"],
      RoleArn: params["RoleArn"],
      LifecycleConfigName: params["LifecycleConfigName"],
      DisassociateLifecycleConfig: params["DisassociateLifecycleConfig"],
      VolumeSizeInGB: params["VolumeSizeInGB"],
      DefaultCodeRepository: params["DefaultCodeRepository"],
      AdditionalCodeRepositories: params["AdditionalCodeRepositories"],
      AcceleratorTypes: params["AcceleratorTypes"],
      DisassociateAcceleratorTypes: params["DisassociateAcceleratorTypes"],
      DisassociateDefaultCodeRepository: params["DisassociateDefaultCodeRepository"],
      DisassociateAdditionalCodeRepositories: params["DisassociateAdditionalCodeRepositories"],
      RootAccess: params["RootAccess"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateNotebookInstanceLifecycleConfigInput,
  ): Promise<s.UpdateNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
      OnCreate: params["OnCreate"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
      OnStart: params["OnStart"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updatePipeline(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineRequest,
  ): Promise<s.UpdatePipelineResponse> {
    const body: jsonP.JSONObject = {
      PipelineName: params["PipelineName"],
      PipelineDisplayName: params["PipelineDisplayName"],
      PipelineDefinition: params["PipelineDefinition"],
      PipelineDescription: params["PipelineDescription"],
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineArn": "s",
      },
    }, await resp.json());
  }

  async updatePipelineExecution(
    {abortSignal, ...params}: RequestConfig & s.UpdatePipelineExecutionRequest,
  ): Promise<s.UpdatePipelineExecutionResponse> {
    const body: jsonP.JSONObject = {
      PipelineExecutionArn: params["PipelineExecutionArn"],
      PipelineExecutionDescription: params["PipelineExecutionDescription"],
      PipelineExecutionDisplayName: params["PipelineExecutionDisplayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdatePipelineExecution",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PipelineExecutionArn": "s",
      },
    }, await resp.json());
  }

  async updateTrainingJob(
    {abortSignal, ...params}: RequestConfig & s.UpdateTrainingJobRequest,
  ): Promise<s.UpdateTrainingJobResponse> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
      ProfilerConfig: fromProfilerConfigForUpdate(params["ProfilerConfig"]),
      ProfilerRuleConfigurations: params["ProfilerRuleConfigurations"]?.map(x => fromProfilerRuleConfiguration(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrainingJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateTrial(
    {abortSignal, ...params}: RequestConfig & s.UpdateTrialRequest,
  ): Promise<s.UpdateTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
      DisplayName: params["DisplayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async updateTrialComponent(
    {abortSignal, ...params}: RequestConfig & s.UpdateTrialComponentRequest,
  ): Promise<s.UpdateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      DisplayName: params["DisplayName"],
      Status: fromTrialComponentStatus(params["Status"]),
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Parameters: jsonP.serializeMap(params["Parameters"], x => fromTrialComponentParameterValue(x)),
      ParametersToRemove: params["ParametersToRemove"],
      InputArtifacts: jsonP.serializeMap(params["InputArtifacts"], x => fromTrialComponentArtifact(x)),
      InputArtifactsToRemove: params["InputArtifactsToRemove"],
      OutputArtifacts: jsonP.serializeMap(params["OutputArtifacts"], x => fromTrialComponentArtifact(x)),
      OutputArtifactsToRemove: params["OutputArtifactsToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async updateUserProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateUserProfileRequest,
  ): Promise<s.UpdateUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      UserSettings: fromUserSettings(params["UserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfileArn": "s",
      },
    }, await resp.json());
  }

  async updateWorkforce(
    {abortSignal, ...params}: RequestConfig & s.UpdateWorkforceRequest,
  ): Promise<s.UpdateWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
      SourceIpConfig: fromSourceIpConfig(params["SourceIpConfig"]),
      OidcConfig: fromOidcConfig(params["OidcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkforce",
    });
    return jsonP.readObj({
      required: {
        "Workforce": toWorkforce,
      },
      optional: {},
    }, await resp.json());
  }

  async updateWorkteam(
    {abortSignal, ...params}: RequestConfig & s.UpdateWorkteamRequest,
  ): Promise<s.UpdateWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
      MemberDefinitions: params["MemberDefinitions"]?.map(x => fromMemberDefinition(x)),
      Description: params["Description"],
      NotificationConfiguration: fromNotificationConfiguration(params["NotificationConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Workteam": toWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceInService(
    params: RequestConfig & s.DescribeNotebookInstanceInput,
  ): Promise<s.DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceInService';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeNotebookInstance(params);
      const field = resp?.NotebookInstanceStatus;
      if (field === "InService") return resp;
      if (field === "Failed") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceStopped(
    params: RequestConfig & s.DescribeNotebookInstanceInput,
  ): Promise<s.DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceStopped';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeNotebookInstance(params);
      const field = resp?.NotebookInstanceStatus;
      if (field === "Stopped") return resp;
      if (field === "Failed") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceDeleted(
    params: RequestConfig & s.DescribeNotebookInstanceInput,
  ): Promise<Error | s.DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeNotebookInstance(params);
        if (resp?.NotebookInstanceStatus === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 180 times, 120 seconds apart (about 360 minutes max wait time). */
  async waitForTrainingJobCompletedOrStopped(
    params: RequestConfig & s.DescribeTrainingJobRequest,
  ): Promise<s.DescribeTrainingJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TrainingJobCompletedOrStopped';
    for (let i = 0; i < 180; i++) {
      try {
        const resp = await this.describeTrainingJob(params);
        const field = resp?.TrainingJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 120000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time). */
  async waitForEndpointInService(
    params: RequestConfig & s.DescribeEndpointInput,
  ): Promise<s.DescribeEndpointOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointInService';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeEndpoint(params);
        const field = resp?.EndpointStatus;
        if (field === "InService") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForEndpointDeleted(
    params: RequestConfig & s.DescribeEndpointInput,
  ): Promise<Error | s.DescribeEndpointOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeEndpoint(params);
        if (resp?.EndpointStatus === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time). */
  async waitForTransformJobCompletedOrStopped(
    params: RequestConfig & s.DescribeTransformJobRequest,
  ): Promise<s.DescribeTransformJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TransformJobCompletedOrStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeTransformJob(params);
        const field = resp?.TransformJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time). */
  async waitForProcessingJobCompletedOrStopped(
    params: RequestConfig & s.DescribeProcessingJobRequest,
  ): Promise<s.DescribeProcessingJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ProcessingJobCompletedOrStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeProcessingJob(params);
        const field = resp?.ProcessingJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromActionSource(input?: s.ActionSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceUri: input["SourceUri"],
    SourceType: input["SourceType"],
    SourceId: input["SourceId"],
  }
}
function toActionSource(root: jsonP.JSONValue): s.ActionSource {
  return jsonP.readObj({
    required: {
      "SourceUri": "s",
    },
    optional: {
      "SourceType": "s",
      "SourceId": "s",
    },
  }, root);
}

function fromMetadataProperties(input?: s.MetadataProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CommitId: input["CommitId"],
    Repository: input["Repository"],
    GeneratedBy: input["GeneratedBy"],
    ProjectId: input["ProjectId"],
  }
}
function toMetadataProperties(root: jsonP.JSONValue): s.MetadataProperties {
  return jsonP.readObj({
    required: {},
    optional: {
      "CommitId": "s",
      "Repository": "s",
      "GeneratedBy": "s",
      "ProjectId": "s",
    },
  }, root);
}

function fromTrainingSpecification(input?: s.TrainingSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    TrainingImageDigest: input["TrainingImageDigest"],
    SupportedHyperParameters: input["SupportedHyperParameters"]?.map(x => fromHyperParameterSpecification(x)),
    SupportedTrainingInstanceTypes: input["SupportedTrainingInstanceTypes"],
    SupportsDistributedTraining: input["SupportsDistributedTraining"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
    TrainingChannels: input["TrainingChannels"]?.map(x => fromChannelSpecification(x)),
    SupportedTuningJobObjectiveMetrics: input["SupportedTuningJobObjectiveMetrics"]?.map(x => fromHyperParameterTuningJobObjective(x)),
  }
}
function toTrainingSpecification(root: jsonP.JSONValue): s.TrainingSpecification {
  return jsonP.readObj({
    required: {
      "TrainingImage": "s",
      "SupportedTrainingInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInstanceType>(x)],
      "TrainingChannels": [toChannelSpecification],
    },
    optional: {
      "TrainingImageDigest": "s",
      "SupportedHyperParameters": [toHyperParameterSpecification],
      "SupportsDistributedTraining": "b",
      "MetricDefinitions": [toMetricDefinition],
      "SupportedTuningJobObjectiveMetrics": [toHyperParameterTuningJobObjective],
    },
  }, root);
}

function fromHyperParameterSpecification(input?: s.HyperParameterSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Type: input["Type"],
    Range: fromParameterRange(input["Range"]),
    IsTunable: input["IsTunable"],
    IsRequired: input["IsRequired"],
    DefaultValue: input["DefaultValue"],
  }
}
function toHyperParameterSpecification(root: jsonP.JSONValue): s.HyperParameterSpecification {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ParameterType>(x),
    },
    optional: {
      "Description": "s",
      "Range": toParameterRange,
      "IsTunable": "b",
      "IsRequired": "b",
      "DefaultValue": "s",
    },
  }, root);
}

function fromParameterRange(input?: s.ParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntegerParameterRangeSpecification: fromIntegerParameterRangeSpecification(input["IntegerParameterRangeSpecification"]),
    ContinuousParameterRangeSpecification: fromContinuousParameterRangeSpecification(input["ContinuousParameterRangeSpecification"]),
    CategoricalParameterRangeSpecification: fromCategoricalParameterRangeSpecification(input["CategoricalParameterRangeSpecification"]),
  }
}
function toParameterRange(root: jsonP.JSONValue): s.ParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntegerParameterRangeSpecification": toIntegerParameterRangeSpecification,
      "ContinuousParameterRangeSpecification": toContinuousParameterRangeSpecification,
      "CategoricalParameterRangeSpecification": toCategoricalParameterRangeSpecification,
    },
  }, root);
}

function fromIntegerParameterRangeSpecification(input?: s.IntegerParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
  }
}
function toIntegerParameterRangeSpecification(root: jsonP.JSONValue): s.IntegerParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {},
  }, root);
}

function fromContinuousParameterRangeSpecification(input?: s.ContinuousParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
  }
}
function toContinuousParameterRangeSpecification(root: jsonP.JSONValue): s.ContinuousParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {},
  }, root);
}

function fromCategoricalParameterRangeSpecification(input?: s.CategoricalParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
  }
}
function toCategoricalParameterRangeSpecification(root: jsonP.JSONValue): s.CategoricalParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

function fromMetricDefinition(input?: s.MetricDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Regex: input["Regex"],
  }
}
function toMetricDefinition(root: jsonP.JSONValue): s.MetricDefinition {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Regex": "s",
    },
    optional: {},
  }, root);
}

function fromChannelSpecification(input?: s.ChannelSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    IsRequired: input["IsRequired"],
    SupportedContentTypes: input["SupportedContentTypes"],
    SupportedCompressionTypes: input["SupportedCompressionTypes"],
    SupportedInputModes: input["SupportedInputModes"],
  }
}
function toChannelSpecification(root: jsonP.JSONValue): s.ChannelSpecification {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "SupportedContentTypes": ["s"],
      "SupportedInputModes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInputMode>(x)],
    },
    optional: {
      "Description": "s",
      "IsRequired": "b",
      "SupportedCompressionTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionType>(x)],
    },
  }, root);
}

function fromHyperParameterTuningJobObjective(input?: s.HyperParameterTuningJobObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    MetricName: input["MetricName"],
  }
}
function toHyperParameterTuningJobObjective(root: jsonP.JSONValue): s.HyperParameterTuningJobObjective {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobObjectiveType>(x),
      "MetricName": "s",
    },
    optional: {},
  }, root);
}

function fromInferenceSpecification(input?: s.InferenceSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Containers: input["Containers"]?.map(x => fromModelPackageContainerDefinition(x)),
    SupportedTransformInstanceTypes: input["SupportedTransformInstanceTypes"],
    SupportedRealtimeInferenceInstanceTypes: input["SupportedRealtimeInferenceInstanceTypes"],
    SupportedContentTypes: input["SupportedContentTypes"],
    SupportedResponseMIMETypes: input["SupportedResponseMIMETypes"],
  }
}
function toInferenceSpecification(root: jsonP.JSONValue): s.InferenceSpecification {
  return jsonP.readObj({
    required: {
      "Containers": [toModelPackageContainerDefinition],
      "SupportedContentTypes": ["s"],
      "SupportedResponseMIMETypes": ["s"],
    },
    optional: {
      "SupportedTransformInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.TransformInstanceType>(x)],
      "SupportedRealtimeInferenceInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ProductionVariantInstanceType>(x)],
    },
  }, root);
}

function fromModelPackageContainerDefinition(input?: s.ModelPackageContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContainerHostname: input["ContainerHostname"],
    Image: input["Image"],
    ImageDigest: input["ImageDigest"],
    ModelDataUrl: input["ModelDataUrl"],
    ProductId: input["ProductId"],
  }
}
function toModelPackageContainerDefinition(root: jsonP.JSONValue): s.ModelPackageContainerDefinition {
  return jsonP.readObj({
    required: {
      "Image": "s",
    },
    optional: {
      "ContainerHostname": "s",
      "ImageDigest": "s",
      "ModelDataUrl": "s",
      "ProductId": "s",
    },
  }, root);
}

function fromAlgorithmValidationSpecification(input?: s.AlgorithmValidationSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ValidationRole: input["ValidationRole"],
    ValidationProfiles: input["ValidationProfiles"]?.map(x => fromAlgorithmValidationProfile(x)),
  }
}
function toAlgorithmValidationSpecification(root: jsonP.JSONValue): s.AlgorithmValidationSpecification {
  return jsonP.readObj({
    required: {
      "ValidationRole": "s",
      "ValidationProfiles": [toAlgorithmValidationProfile],
    },
    optional: {},
  }, root);
}

function fromAlgorithmValidationProfile(input?: s.AlgorithmValidationProfile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProfileName: input["ProfileName"],
    TrainingJobDefinition: fromTrainingJobDefinition(input["TrainingJobDefinition"]),
    TransformJobDefinition: fromTransformJobDefinition(input["TransformJobDefinition"]),
  }
}
function toAlgorithmValidationProfile(root: jsonP.JSONValue): s.AlgorithmValidationProfile {
  return jsonP.readObj({
    required: {
      "ProfileName": "s",
      "TrainingJobDefinition": toTrainingJobDefinition,
    },
    optional: {
      "TransformJobDefinition": toTransformJobDefinition,
    },
  }, root);
}

function fromTrainingJobDefinition(input?: s.TrainingJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingInputMode: input["TrainingInputMode"],
    HyperParameters: input["HyperParameters"],
    InputDataConfig: input["InputDataConfig"]?.map(x => fromChannel(x)),
    OutputDataConfig: fromOutputDataConfig(input["OutputDataConfig"]),
    ResourceConfig: fromResourceConfig(input["ResourceConfig"]),
    StoppingCondition: fromStoppingCondition(input["StoppingCondition"]),
  }
}
function toTrainingJobDefinition(root: jsonP.JSONValue): s.TrainingJobDefinition {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInputMode>(x),
      "InputDataConfig": [toChannel],
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "StoppingCondition": toStoppingCondition,
    },
    optional: {
      "HyperParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromChannel(input?: s.Channel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ChannelName: input["ChannelName"],
    DataSource: fromDataSource(input["DataSource"]),
    ContentType: input["ContentType"],
    CompressionType: input["CompressionType"],
    RecordWrapperType: input["RecordWrapperType"],
    InputMode: input["InputMode"],
    ShuffleConfig: fromShuffleConfig(input["ShuffleConfig"]),
  }
}
function toChannel(root: jsonP.JSONValue): s.Channel {
  return jsonP.readObj({
    required: {
      "ChannelName": "s",
      "DataSource": toDataSource,
    },
    optional: {
      "ContentType": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionType>(x),
      "RecordWrapperType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecordWrapper>(x),
      "InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInputMode>(x),
      "ShuffleConfig": toShuffleConfig,
    },
  }, root);
}

function fromDataSource(input?: s.DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromS3DataSource(input["S3DataSource"]),
    FileSystemDataSource: fromFileSystemDataSource(input["FileSystemDataSource"]),
  }
}
function toDataSource(root: jsonP.JSONValue): s.DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3DataSource": toS3DataSource,
      "FileSystemDataSource": toFileSystemDataSource,
    },
  }, root);
}

function fromS3DataSource(input?: s.S3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
    S3DataDistributionType: input["S3DataDistributionType"],
    AttributeNames: input["AttributeNames"],
  }
}
function toS3DataSource(root: jsonP.JSONValue): s.S3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3DataType>(x),
      "S3Uri": "s",
    },
    optional: {
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3DataDistribution>(x),
      "AttributeNames": ["s"],
    },
  }, root);
}

function fromFileSystemDataSource(input?: s.FileSystemDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FileSystemId: input["FileSystemId"],
    FileSystemAccessMode: input["FileSystemAccessMode"],
    FileSystemType: input["FileSystemType"],
    DirectoryPath: input["DirectoryPath"],
  }
}
function toFileSystemDataSource(root: jsonP.JSONValue): s.FileSystemDataSource {
  return jsonP.readObj({
    required: {
      "FileSystemId": "s",
      "FileSystemAccessMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileSystemAccessMode>(x),
      "FileSystemType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FileSystemType>(x),
      "DirectoryPath": "s",
    },
    optional: {},
  }, root);
}

function fromShuffleConfig(input?: s.ShuffleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Seed: input["Seed"],
  }
}
function toShuffleConfig(root: jsonP.JSONValue): s.ShuffleConfig {
  return jsonP.readObj({
    required: {
      "Seed": "n",
    },
    optional: {},
  }, root);
}

function fromOutputDataConfig(input?: s.OutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsKeyId: input["KmsKeyId"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toOutputDataConfig(root: jsonP.JSONValue): s.OutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromResourceConfig(input?: s.ResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toResourceConfig(root: jsonP.JSONValue): s.ResourceConfig {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInstanceType>(x),
      "InstanceCount": "n",
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

function fromStoppingCondition(input?: s.StoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
    MaxWaitTimeInSeconds: input["MaxWaitTimeInSeconds"],
  }
}
function toStoppingCondition(root: jsonP.JSONValue): s.StoppingCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxRuntimeInSeconds": "n",
      "MaxWaitTimeInSeconds": "n",
    },
  }, root);
}

function fromTransformJobDefinition(input?: s.TransformJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxConcurrentTransforms: input["MaxConcurrentTransforms"],
    MaxPayloadInMB: input["MaxPayloadInMB"],
    BatchStrategy: input["BatchStrategy"],
    Environment: input["Environment"],
    TransformInput: fromTransformInput(input["TransformInput"]),
    TransformOutput: fromTransformOutput(input["TransformOutput"]),
    TransformResources: fromTransformResources(input["TransformResources"]),
  }
}
function toTransformJobDefinition(root: jsonP.JSONValue): s.TransformJobDefinition {
  return jsonP.readObj({
    required: {
      "TransformInput": toTransformInput,
      "TransformOutput": toTransformOutput,
      "TransformResources": toTransformResources,
    },
    optional: {
      "MaxConcurrentTransforms": "n",
      "MaxPayloadInMB": "n",
      "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchStrategy>(x),
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromTransformInput(input?: s.TransformInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromTransformDataSource(input["DataSource"]),
    ContentType: input["ContentType"],
    CompressionType: input["CompressionType"],
    SplitType: input["SplitType"],
  }
}
function toTransformInput(root: jsonP.JSONValue): s.TransformInput {
  return jsonP.readObj({
    required: {
      "DataSource": toTransformDataSource,
    },
    optional: {
      "ContentType": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionType>(x),
      "SplitType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SplitType>(x),
    },
  }, root);
}

function fromTransformDataSource(input?: s.TransformDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromTransformS3DataSource(input["S3DataSource"]),
  }
}
function toTransformDataSource(root: jsonP.JSONValue): s.TransformDataSource {
  return jsonP.readObj({
    required: {
      "S3DataSource": toTransformS3DataSource,
    },
    optional: {},
  }, root);
}

function fromTransformS3DataSource(input?: s.TransformS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
  }
}
function toTransformS3DataSource(root: jsonP.JSONValue): s.TransformS3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.S3DataType>(x),
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromTransformOutput(input?: s.TransformOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    Accept: input["Accept"],
    AssembleWith: input["AssembleWith"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toTransformOutput(root: jsonP.JSONValue): s.TransformOutput {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "Accept": "s",
      "AssembleWith": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssemblyType>(x),
      "KmsKeyId": "s",
    },
  }, root);
}

function fromTransformResources(input?: s.TransformResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toTransformResources(root: jsonP.JSONValue): s.TransformResources {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformInstanceType>(x),
      "InstanceCount": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

function fromResourceSpec(input?: s.ResourceSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SageMakerImageArn: input["SageMakerImageArn"],
    SageMakerImageVersionArn: input["SageMakerImageVersionArn"],
    InstanceType: input["InstanceType"],
  }
}
function toResourceSpec(root: jsonP.JSONValue): s.ResourceSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "SageMakerImageArn": "s",
      "SageMakerImageVersionArn": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppInstanceType>(x),
    },
  }, root);
}

function fromKernelGatewayImageConfig(input?: s.KernelGatewayImageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KernelSpecs: input["KernelSpecs"]?.map(x => fromKernelSpec(x)),
    FileSystemConfig: fromFileSystemConfig(input["FileSystemConfig"]),
  }
}
function toKernelGatewayImageConfig(root: jsonP.JSONValue): s.KernelGatewayImageConfig {
  return jsonP.readObj({
    required: {
      "KernelSpecs": [toKernelSpec],
    },
    optional: {
      "FileSystemConfig": toFileSystemConfig,
    },
  }, root);
}

function fromKernelSpec(input?: s.KernelSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    DisplayName: input["DisplayName"],
  }
}
function toKernelSpec(root: jsonP.JSONValue): s.KernelSpec {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "DisplayName": "s",
    },
  }, root);
}

function fromFileSystemConfig(input?: s.FileSystemConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MountPath: input["MountPath"],
    DefaultUid: input["DefaultUid"],
    DefaultGid: input["DefaultGid"],
  }
}
function toFileSystemConfig(root: jsonP.JSONValue): s.FileSystemConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "MountPath": "s",
      "DefaultUid": "n",
      "DefaultGid": "n",
    },
  }, root);
}

function fromArtifactSource(input?: s.ArtifactSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceUri: input["SourceUri"],
    SourceTypes: input["SourceTypes"]?.map(x => fromArtifactSourceType(x)),
  }
}
function toArtifactSource(root: jsonP.JSONValue): s.ArtifactSource {
  return jsonP.readObj({
    required: {
      "SourceUri": "s",
    },
    optional: {
      "SourceTypes": [toArtifactSourceType],
    },
  }, root);
}

function fromArtifactSourceType(input?: s.ArtifactSourceType | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceIdType: input["SourceIdType"],
    Value: input["Value"],
  }
}
function toArtifactSourceType(root: jsonP.JSONValue): s.ArtifactSourceType {
  return jsonP.readObj({
    required: {
      "SourceIdType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ArtifactSourceIdType>(x),
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromAutoMLChannel(input?: s.AutoMLChannel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromAutoMLDataSource(input["DataSource"]),
    CompressionType: input["CompressionType"],
    TargetAttributeName: input["TargetAttributeName"],
  }
}
function toAutoMLChannel(root: jsonP.JSONValue): s.AutoMLChannel {
  return jsonP.readObj({
    required: {
      "DataSource": toAutoMLDataSource,
      "TargetAttributeName": "s",
    },
    optional: {
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompressionType>(x),
    },
  }, root);
}

function fromAutoMLDataSource(input?: s.AutoMLDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromAutoMLS3DataSource(input["S3DataSource"]),
  }
}
function toAutoMLDataSource(root: jsonP.JSONValue): s.AutoMLDataSource {
  return jsonP.readObj({
    required: {
      "S3DataSource": toAutoMLS3DataSource,
    },
    optional: {},
  }, root);
}

function fromAutoMLS3DataSource(input?: s.AutoMLS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
  }
}
function toAutoMLS3DataSource(root: jsonP.JSONValue): s.AutoMLS3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLS3DataType>(x),
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromAutoMLOutputDataConfig(input?: s.AutoMLOutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsKeyId: input["KmsKeyId"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toAutoMLOutputDataConfig(root: jsonP.JSONValue): s.AutoMLOutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromAutoMLJobObjective(input?: s.AutoMLJobObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetricName: input["MetricName"],
  }
}
function toAutoMLJobObjective(root: jsonP.JSONValue): s.AutoMLJobObjective {
  return jsonP.readObj({
    required: {
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLMetricEnum>(x),
    },
    optional: {},
  }, root);
}

function fromAutoMLJobConfig(input?: s.AutoMLJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CompletionCriteria: fromAutoMLJobCompletionCriteria(input["CompletionCriteria"]),
    SecurityConfig: fromAutoMLSecurityConfig(input["SecurityConfig"]),
  }
}
function toAutoMLJobConfig(root: jsonP.JSONValue): s.AutoMLJobConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "CompletionCriteria": toAutoMLJobCompletionCriteria,
      "SecurityConfig": toAutoMLSecurityConfig,
    },
  }, root);
}

function fromAutoMLJobCompletionCriteria(input?: s.AutoMLJobCompletionCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxCandidates: input["MaxCandidates"],
    MaxRuntimePerTrainingJobInSeconds: input["MaxRuntimePerTrainingJobInSeconds"],
    MaxAutoMLJobRuntimeInSeconds: input["MaxAutoMLJobRuntimeInSeconds"],
  }
}
function toAutoMLJobCompletionCriteria(root: jsonP.JSONValue): s.AutoMLJobCompletionCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCandidates": "n",
      "MaxRuntimePerTrainingJobInSeconds": "n",
      "MaxAutoMLJobRuntimeInSeconds": "n",
    },
  }, root);
}

function fromAutoMLSecurityConfig(input?: s.AutoMLSecurityConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
  }
}
function toAutoMLSecurityConfig(root: jsonP.JSONValue): s.AutoMLSecurityConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeKmsKeyId": "s",
      "EnableInterContainerTrafficEncryption": "b",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function fromVpcConfig(input?: s.VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecurityGroupIds: input["SecurityGroupIds"],
    Subnets: input["Subnets"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): s.VpcConfig {
  return jsonP.readObj({
    required: {
      "SecurityGroupIds": ["s"],
      "Subnets": ["s"],
    },
    optional: {},
  }, root);
}

function fromGitConfig(input?: s.GitConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RepositoryUrl: input["RepositoryUrl"],
    Branch: input["Branch"],
    SecretArn: input["SecretArn"],
  }
}
function toGitConfig(root: jsonP.JSONValue): s.GitConfig {
  return jsonP.readObj({
    required: {
      "RepositoryUrl": "s",
    },
    optional: {
      "Branch": "s",
      "SecretArn": "s",
    },
  }, root);
}

function fromInputConfig(input?: s.InputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    DataInputConfig: input["DataInputConfig"],
    Framework: input["Framework"],
  }
}
function toInputConfig(root: jsonP.JSONValue): s.InputConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "DataInputConfig": "s",
      "Framework": (x: jsonP.JSONValue) => cmnP.readEnum<s.Framework>(x),
    },
    optional: {},
  }, root);
}

function fromOutputConfig(input?: s.OutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputLocation: input["S3OutputLocation"],
    TargetDevice: input["TargetDevice"],
    TargetPlatform: fromTargetPlatform(input["TargetPlatform"]),
    CompilerOptions: input["CompilerOptions"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toOutputConfig(root: jsonP.JSONValue): s.OutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputLocation": "s",
    },
    optional: {
      "TargetDevice": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetDevice>(x),
      "TargetPlatform": toTargetPlatform,
      "CompilerOptions": "s",
      "KmsKeyId": "s",
    },
  }, root);
}

function fromTargetPlatform(input?: s.TargetPlatform | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Os: input["Os"],
    Arch: input["Arch"],
    Accelerator: input["Accelerator"],
  }
}
function toTargetPlatform(root: jsonP.JSONValue): s.TargetPlatform {
  return jsonP.readObj({
    required: {
      "Os": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformOs>(x),
      "Arch": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformArch>(x),
    },
    optional: {
      "Accelerator": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformAccelerator>(x),
    },
  }, root);
}

function fromContextSource(input?: s.ContextSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceUri: input["SourceUri"],
    SourceType: input["SourceType"],
    SourceId: input["SourceId"],
  }
}
function toContextSource(root: jsonP.JSONValue): s.ContextSource {
  return jsonP.readObj({
    required: {
      "SourceUri": "s",
    },
    optional: {
      "SourceType": "s",
      "SourceId": "s",
    },
  }, root);
}

function fromDataQualityBaselineConfig(input?: s.DataQualityBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaseliningJobName: input["BaseliningJobName"],
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
    StatisticsResource: fromMonitoringStatisticsResource(input["StatisticsResource"]),
  }
}
function toDataQualityBaselineConfig(root: jsonP.JSONValue): s.DataQualityBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaseliningJobName": "s",
      "ConstraintsResource": toMonitoringConstraintsResource,
      "StatisticsResource": toMonitoringStatisticsResource,
    },
  }, root);
}

function fromMonitoringConstraintsResource(input?: s.MonitoringConstraintsResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toMonitoringConstraintsResource(root: jsonP.JSONValue): s.MonitoringConstraintsResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
    },
  }, root);
}

function fromMonitoringStatisticsResource(input?: s.MonitoringStatisticsResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toMonitoringStatisticsResource(root: jsonP.JSONValue): s.MonitoringStatisticsResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
    },
  }, root);
}

function fromDataQualityAppSpecification(input?: s.DataQualityAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
    RecordPreprocessorSourceUri: input["RecordPreprocessorSourceUri"],
    PostAnalyticsProcessorSourceUri: input["PostAnalyticsProcessorSourceUri"],
    Environment: input["Environment"],
  }
}
function toDataQualityAppSpecification(root: jsonP.JSONValue): s.DataQualityAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
      "RecordPreprocessorSourceUri": "s",
      "PostAnalyticsProcessorSourceUri": "s",
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromDataQualityJobInput(input?: s.DataQualityJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
  }
}
function toDataQualityJobInput(root: jsonP.JSONValue): s.DataQualityJobInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
    },
    optional: {},
  }, root);
}

function fromEndpointInput(input?: s.EndpointInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointName: input["EndpointName"],
    LocalPath: input["LocalPath"],
    S3InputMode: input["S3InputMode"],
    S3DataDistributionType: input["S3DataDistributionType"],
    FeaturesAttribute: input["FeaturesAttribute"],
    InferenceAttribute: input["InferenceAttribute"],
    ProbabilityAttribute: input["ProbabilityAttribute"],
    ProbabilityThresholdAttribute: input["ProbabilityThresholdAttribute"],
    StartTimeOffset: input["StartTimeOffset"],
    EndTimeOffset: input["EndTimeOffset"],
  }
}
function toEndpointInput(root: jsonP.JSONValue): s.EndpointInput {
  return jsonP.readObj({
    required: {
      "EndpointName": "s",
      "LocalPath": "s",
    },
    optional: {
      "S3InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3InputMode>(x),
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3DataDistributionType>(x),
      "FeaturesAttribute": "s",
      "InferenceAttribute": "s",
      "ProbabilityAttribute": "s",
      "ProbabilityThresholdAttribute": "n",
      "StartTimeOffset": "s",
      "EndTimeOffset": "s",
    },
  }, root);
}

function fromMonitoringOutputConfig(input?: s.MonitoringOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MonitoringOutputs: input["MonitoringOutputs"]?.map(x => fromMonitoringOutput(x)),
    KmsKeyId: input["KmsKeyId"],
  }
}
function toMonitoringOutputConfig(root: jsonP.JSONValue): s.MonitoringOutputConfig {
  return jsonP.readObj({
    required: {
      "MonitoringOutputs": [toMonitoringOutput],
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromMonitoringOutput(input?: s.MonitoringOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Output: fromMonitoringS3Output(input["S3Output"]),
  }
}
function toMonitoringOutput(root: jsonP.JSONValue): s.MonitoringOutput {
  return jsonP.readObj({
    required: {
      "S3Output": toMonitoringS3Output,
    },
    optional: {},
  }, root);
}

function fromMonitoringS3Output(input?: s.MonitoringS3Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3UploadMode: input["S3UploadMode"],
  }
}
function toMonitoringS3Output(root: jsonP.JSONValue): s.MonitoringS3Output {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "LocalPath": "s",
    },
    optional: {
      "S3UploadMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3UploadMode>(x),
    },
  }, root);
}

function fromMonitoringResources(input?: s.MonitoringResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterConfig: fromMonitoringClusterConfig(input["ClusterConfig"]),
  }
}
function toMonitoringResources(root: jsonP.JSONValue): s.MonitoringResources {
  return jsonP.readObj({
    required: {
      "ClusterConfig": toMonitoringClusterConfig,
    },
    optional: {},
  }, root);
}

function fromMonitoringClusterConfig(input?: s.MonitoringClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toMonitoringClusterConfig(root: jsonP.JSONValue): s.MonitoringClusterConfig {
  return jsonP.readObj({
    required: {
      "InstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

function fromMonitoringNetworkConfig(input?: s.MonitoringNetworkConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    EnableNetworkIsolation: input["EnableNetworkIsolation"],
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
  }
}
function toMonitoringNetworkConfig(root: jsonP.JSONValue): s.MonitoringNetworkConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnableInterContainerTrafficEncryption": "b",
      "EnableNetworkIsolation": "b",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function fromMonitoringStoppingCondition(input?: s.MonitoringStoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
  }
}
function toMonitoringStoppingCondition(root: jsonP.JSONValue): s.MonitoringStoppingCondition {
  return jsonP.readObj({
    required: {
      "MaxRuntimeInSeconds": "n",
    },
    optional: {},
  }, root);
}

function fromEdgeOutputConfig(input?: s.EdgeOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputLocation: input["S3OutputLocation"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toEdgeOutputConfig(root: jsonP.JSONValue): s.EdgeOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputLocation": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromUserSettings(input?: s.UserSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExecutionRole: input["ExecutionRole"],
    SecurityGroups: input["SecurityGroups"],
    SharingSettings: fromSharingSettings(input["SharingSettings"]),
    JupyterServerAppSettings: fromJupyterServerAppSettings(input["JupyterServerAppSettings"]),
    KernelGatewayAppSettings: fromKernelGatewayAppSettings(input["KernelGatewayAppSettings"]),
    TensorBoardAppSettings: fromTensorBoardAppSettings(input["TensorBoardAppSettings"]),
  }
}
function toUserSettings(root: jsonP.JSONValue): s.UserSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExecutionRole": "s",
      "SecurityGroups": ["s"],
      "SharingSettings": toSharingSettings,
      "JupyterServerAppSettings": toJupyterServerAppSettings,
      "KernelGatewayAppSettings": toKernelGatewayAppSettings,
      "TensorBoardAppSettings": toTensorBoardAppSettings,
    },
  }, root);
}

function fromSharingSettings(input?: s.SharingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotebookOutputOption: input["NotebookOutputOption"],
    S3OutputPath: input["S3OutputPath"],
    S3KmsKeyId: input["S3KmsKeyId"],
  }
}
function toSharingSettings(root: jsonP.JSONValue): s.SharingSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookOutputOption": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookOutputOption>(x),
      "S3OutputPath": "s",
      "S3KmsKeyId": "s",
    },
  }, root);
}

function fromJupyterServerAppSettings(input?: s.JupyterServerAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
  }
}
function toJupyterServerAppSettings(root: jsonP.JSONValue): s.JupyterServerAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
    },
  }, root);
}

function fromKernelGatewayAppSettings(input?: s.KernelGatewayAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
    CustomImages: input["CustomImages"]?.map(x => fromCustomImage(x)),
  }
}
function toKernelGatewayAppSettings(root: jsonP.JSONValue): s.KernelGatewayAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
      "CustomImages": [toCustomImage],
    },
  }, root);
}

function fromCustomImage(input?: s.CustomImage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageName: input["ImageName"],
    ImageVersionNumber: input["ImageVersionNumber"],
    AppImageConfigName: input["AppImageConfigName"],
  }
}
function toCustomImage(root: jsonP.JSONValue): s.CustomImage {
  return jsonP.readObj({
    required: {
      "ImageName": "s",
      "AppImageConfigName": "s",
    },
    optional: {
      "ImageVersionNumber": "n",
    },
  }, root);
}

function fromTensorBoardAppSettings(input?: s.TensorBoardAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
  }
}
function toTensorBoardAppSettings(root: jsonP.JSONValue): s.TensorBoardAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
    },
  }, root);
}

function fromProductionVariant(input?: s.ProductionVariant | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantName: input["VariantName"],
    ModelName: input["ModelName"],
    InitialInstanceCount: input["InitialInstanceCount"],
    InstanceType: input["InstanceType"],
    InitialVariantWeight: input["InitialVariantWeight"],
    AcceleratorType: input["AcceleratorType"],
  }
}
function toProductionVariant(root: jsonP.JSONValue): s.ProductionVariant {
  return jsonP.readObj({
    required: {
      "VariantName": "s",
      "ModelName": "s",
      "InitialInstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProductionVariantInstanceType>(x),
    },
    optional: {
      "InitialVariantWeight": "n",
      "AcceleratorType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProductionVariantAcceleratorType>(x),
    },
  }, root);
}

function fromDataCaptureConfig(input?: s.DataCaptureConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnableCapture: input["EnableCapture"],
    InitialSamplingPercentage: input["InitialSamplingPercentage"],
    DestinationS3Uri: input["DestinationS3Uri"],
    KmsKeyId: input["KmsKeyId"],
    CaptureOptions: input["CaptureOptions"]?.map(x => fromCaptureOption(x)),
    CaptureContentTypeHeader: fromCaptureContentTypeHeader(input["CaptureContentTypeHeader"]),
  }
}
function toDataCaptureConfig(root: jsonP.JSONValue): s.DataCaptureConfig {
  return jsonP.readObj({
    required: {
      "InitialSamplingPercentage": "n",
      "DestinationS3Uri": "s",
      "CaptureOptions": [toCaptureOption],
    },
    optional: {
      "EnableCapture": "b",
      "KmsKeyId": "s",
      "CaptureContentTypeHeader": toCaptureContentTypeHeader,
    },
  }, root);
}

function fromCaptureOption(input?: s.CaptureOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CaptureMode: input["CaptureMode"],
  }
}
function toCaptureOption(root: jsonP.JSONValue): s.CaptureOption {
  return jsonP.readObj({
    required: {
      "CaptureMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.CaptureMode>(x),
    },
    optional: {},
  }, root);
}

function fromCaptureContentTypeHeader(input?: s.CaptureContentTypeHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CsvContentTypes: input["CsvContentTypes"],
    JsonContentTypes: input["JsonContentTypes"],
  }
}
function toCaptureContentTypeHeader(root: jsonP.JSONValue): s.CaptureContentTypeHeader {
  return jsonP.readObj({
    required: {},
    optional: {
      "CsvContentTypes": ["s"],
      "JsonContentTypes": ["s"],
    },
  }, root);
}

function fromFeatureDefinition(input?: s.FeatureDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FeatureName: input["FeatureName"],
    FeatureType: input["FeatureType"],
  }
}
function toFeatureDefinition(root: jsonP.JSONValue): s.FeatureDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "FeatureName": "s",
      "FeatureType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeatureType>(x),
    },
  }, root);
}

function fromOnlineStoreConfig(input?: s.OnlineStoreConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecurityConfig: fromOnlineStoreSecurityConfig(input["SecurityConfig"]),
    EnableOnlineStore: input["EnableOnlineStore"],
  }
}
function toOnlineStoreConfig(root: jsonP.JSONValue): s.OnlineStoreConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "SecurityConfig": toOnlineStoreSecurityConfig,
      "EnableOnlineStore": "b",
    },
  }, root);
}

function fromOnlineStoreSecurityConfig(input?: s.OnlineStoreSecurityConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsKeyId: input["KmsKeyId"],
  }
}
function toOnlineStoreSecurityConfig(root: jsonP.JSONValue): s.OnlineStoreSecurityConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromOfflineStoreConfig(input?: s.OfflineStoreConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3StorageConfig: fromS3StorageConfig(input["S3StorageConfig"]),
    DisableGlueTableCreation: input["DisableGlueTableCreation"],
    DataCatalogConfig: fromDataCatalogConfig(input["DataCatalogConfig"]),
  }
}
function toOfflineStoreConfig(root: jsonP.JSONValue): s.OfflineStoreConfig {
  return jsonP.readObj({
    required: {
      "S3StorageConfig": toS3StorageConfig,
    },
    optional: {
      "DisableGlueTableCreation": "b",
      "DataCatalogConfig": toDataCatalogConfig,
    },
  }, root);
}

function fromS3StorageConfig(input?: s.S3StorageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toS3StorageConfig(root: jsonP.JSONValue): s.S3StorageConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromDataCatalogConfig(input?: s.DataCatalogConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TableName: input["TableName"],
    Catalog: input["Catalog"],
    Database: input["Database"],
  }
}
function toDataCatalogConfig(root: jsonP.JSONValue): s.DataCatalogConfig {
  return jsonP.readObj({
    required: {
      "TableName": "s",
      "Catalog": "s",
      "Database": "s",
    },
    optional: {},
  }, root);
}

function fromHumanLoopRequestSource(input?: s.HumanLoopRequestSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AwsManagedHumanLoopRequestSource: input["AwsManagedHumanLoopRequestSource"],
  }
}
function toHumanLoopRequestSource(root: jsonP.JSONValue): s.HumanLoopRequestSource {
  return jsonP.readObj({
    required: {
      "AwsManagedHumanLoopRequestSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.AwsManagedHumanLoopRequestSource>(x),
    },
    optional: {},
  }, root);
}

function fromHumanLoopActivationConfig(input?: s.HumanLoopActivationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopActivationConditionsConfig: fromHumanLoopActivationConditionsConfig(input["HumanLoopActivationConditionsConfig"]),
  }
}
function toHumanLoopActivationConfig(root: jsonP.JSONValue): s.HumanLoopActivationConfig {
  return jsonP.readObj({
    required: {
      "HumanLoopActivationConditionsConfig": toHumanLoopActivationConditionsConfig,
    },
    optional: {},
  }, root);
}

function fromHumanLoopActivationConditionsConfig(input?: s.HumanLoopActivationConditionsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopActivationConditions: jsonP.serializeJsonValue(input["HumanLoopActivationConditions"]),
  }
}
function toHumanLoopActivationConditionsConfig(root: jsonP.JSONValue): s.HumanLoopActivationConditionsConfig {
  return jsonP.readObj({
    required: {
      "HumanLoopActivationConditions": jsonP.readJsonValue,
    },
    optional: {},
  }, root);
}

function fromHumanLoopConfig(input?: s.HumanLoopConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WorkteamArn: input["WorkteamArn"],
    HumanTaskUiArn: input["HumanTaskUiArn"],
    TaskTitle: input["TaskTitle"],
    TaskDescription: input["TaskDescription"],
    TaskCount: input["TaskCount"],
    TaskAvailabilityLifetimeInSeconds: input["TaskAvailabilityLifetimeInSeconds"],
    TaskTimeLimitInSeconds: input["TaskTimeLimitInSeconds"],
    TaskKeywords: input["TaskKeywords"],
    PublicWorkforceTaskPrice: fromPublicWorkforceTaskPrice(input["PublicWorkforceTaskPrice"]),
  }
}
function toHumanLoopConfig(root: jsonP.JSONValue): s.HumanLoopConfig {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
      "HumanTaskUiArn": "s",
      "TaskTitle": "s",
      "TaskDescription": "s",
      "TaskCount": "n",
    },
    optional: {
      "TaskAvailabilityLifetimeInSeconds": "n",
      "TaskTimeLimitInSeconds": "n",
      "TaskKeywords": ["s"],
      "PublicWorkforceTaskPrice": toPublicWorkforceTaskPrice,
    },
  }, root);
}

function fromPublicWorkforceTaskPrice(input?: s.PublicWorkforceTaskPrice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AmountInUsd: fromUSD(input["AmountInUsd"]),
  }
}
function toPublicWorkforceTaskPrice(root: jsonP.JSONValue): s.PublicWorkforceTaskPrice {
  return jsonP.readObj({
    required: {},
    optional: {
      "AmountInUsd": toUSD,
    },
  }, root);
}

function fromUSD(input?: s.USD | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dollars: input["Dollars"],
    Cents: input["Cents"],
    TenthFractionsOfACent: input["TenthFractionsOfACent"],
  }
}
function toUSD(root: jsonP.JSONValue): s.USD {
  return jsonP.readObj({
    required: {},
    optional: {
      "Dollars": "n",
      "Cents": "n",
      "TenthFractionsOfACent": "n",
    },
  }, root);
}

function fromFlowDefinitionOutputConfig(input?: s.FlowDefinitionOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toFlowDefinitionOutputConfig(root: jsonP.JSONValue): s.FlowDefinitionOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromUiTemplate(input?: s.UiTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Content: input["Content"],
  }
}

function fromHyperParameterTuningJobConfig(input?: s.HyperParameterTuningJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Strategy: input["Strategy"],
    HyperParameterTuningJobObjective: fromHyperParameterTuningJobObjective(input["HyperParameterTuningJobObjective"]),
    ResourceLimits: fromResourceLimits(input["ResourceLimits"]),
    ParameterRanges: fromParameterRanges(input["ParameterRanges"]),
    TrainingJobEarlyStoppingType: input["TrainingJobEarlyStoppingType"],
    TuningJobCompletionCriteria: fromTuningJobCompletionCriteria(input["TuningJobCompletionCriteria"]),
  }
}
function toHyperParameterTuningJobConfig(root: jsonP.JSONValue): s.HyperParameterTuningJobConfig {
  return jsonP.readObj({
    required: {
      "Strategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobStrategyType>(x),
      "ResourceLimits": toResourceLimits,
    },
    optional: {
      "HyperParameterTuningJobObjective": toHyperParameterTuningJobObjective,
      "ParameterRanges": toParameterRanges,
      "TrainingJobEarlyStoppingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingJobEarlyStoppingType>(x),
      "TuningJobCompletionCriteria": toTuningJobCompletionCriteria,
    },
  }, root);
}

function fromResourceLimits(input?: s.ResourceLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxNumberOfTrainingJobs: input["MaxNumberOfTrainingJobs"],
    MaxParallelTrainingJobs: input["MaxParallelTrainingJobs"],
  }
}
function toResourceLimits(root: jsonP.JSONValue): s.ResourceLimits {
  return jsonP.readObj({
    required: {
      "MaxNumberOfTrainingJobs": "n",
      "MaxParallelTrainingJobs": "n",
    },
    optional: {},
  }, root);
}

function fromParameterRanges(input?: s.ParameterRanges | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntegerParameterRanges: input["IntegerParameterRanges"]?.map(x => fromIntegerParameterRange(x)),
    ContinuousParameterRanges: input["ContinuousParameterRanges"]?.map(x => fromContinuousParameterRange(x)),
    CategoricalParameterRanges: input["CategoricalParameterRanges"]?.map(x => fromCategoricalParameterRange(x)),
  }
}
function toParameterRanges(root: jsonP.JSONValue): s.ParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntegerParameterRanges": [toIntegerParameterRange],
      "ContinuousParameterRanges": [toContinuousParameterRange],
      "CategoricalParameterRanges": [toCategoricalParameterRange],
    },
  }, root);
}

function fromIntegerParameterRange(input?: s.IntegerParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
    ScalingType: input["ScalingType"],
  }
}
function toIntegerParameterRange(root: jsonP.JSONValue): s.IntegerParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterScalingType>(x),
    },
  }, root);
}

function fromContinuousParameterRange(input?: s.ContinuousParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
    ScalingType: input["ScalingType"],
  }
}
function toContinuousParameterRange(root: jsonP.JSONValue): s.ContinuousParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterScalingType>(x),
    },
  }, root);
}

function fromCategoricalParameterRange(input?: s.CategoricalParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}
function toCategoricalParameterRange(root: jsonP.JSONValue): s.CategoricalParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

function fromTuningJobCompletionCriteria(input?: s.TuningJobCompletionCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetObjectiveMetricValue: input["TargetObjectiveMetricValue"],
  }
}
function toTuningJobCompletionCriteria(root: jsonP.JSONValue): s.TuningJobCompletionCriteria {
  return jsonP.readObj({
    required: {
      "TargetObjectiveMetricValue": "n",
    },
    optional: {},
  }, root);
}

function fromHyperParameterTrainingJobDefinition(input?: s.HyperParameterTrainingJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefinitionName: input["DefinitionName"],
    TuningObjective: fromHyperParameterTuningJobObjective(input["TuningObjective"]),
    HyperParameterRanges: fromParameterRanges(input["HyperParameterRanges"]),
    StaticHyperParameters: input["StaticHyperParameters"],
    AlgorithmSpecification: fromHyperParameterAlgorithmSpecification(input["AlgorithmSpecification"]),
    RoleArn: input["RoleArn"],
    InputDataConfig: input["InputDataConfig"]?.map(x => fromChannel(x)),
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
    OutputDataConfig: fromOutputDataConfig(input["OutputDataConfig"]),
    ResourceConfig: fromResourceConfig(input["ResourceConfig"]),
    StoppingCondition: fromStoppingCondition(input["StoppingCondition"]),
    EnableNetworkIsolation: input["EnableNetworkIsolation"],
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    EnableManagedSpotTraining: input["EnableManagedSpotTraining"],
    CheckpointConfig: fromCheckpointConfig(input["CheckpointConfig"]),
  }
}
function toHyperParameterTrainingJobDefinition(root: jsonP.JSONValue): s.HyperParameterTrainingJobDefinition {
  return jsonP.readObj({
    required: {
      "AlgorithmSpecification": toHyperParameterAlgorithmSpecification,
      "RoleArn": "s",
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "StoppingCondition": toStoppingCondition,
    },
    optional: {
      "DefinitionName": "s",
      "TuningObjective": toHyperParameterTuningJobObjective,
      "HyperParameterRanges": toParameterRanges,
      "StaticHyperParameters": x => jsonP.readMap(String, String, x),
      "InputDataConfig": [toChannel],
      "VpcConfig": toVpcConfig,
      "EnableNetworkIsolation": "b",
      "EnableInterContainerTrafficEncryption": "b",
      "EnableManagedSpotTraining": "b",
      "CheckpointConfig": toCheckpointConfig,
    },
  }, root);
}

function fromHyperParameterAlgorithmSpecification(input?: s.HyperParameterAlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    TrainingInputMode: input["TrainingInputMode"],
    AlgorithmName: input["AlgorithmName"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
  }
}
function toHyperParameterAlgorithmSpecification(root: jsonP.JSONValue): s.HyperParameterAlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInputMode>(x),
    },
    optional: {
      "TrainingImage": "s",
      "AlgorithmName": "s",
      "MetricDefinitions": [toMetricDefinition],
    },
  }, root);
}

function fromCheckpointConfig(input?: s.CheckpointConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
  }
}
function toCheckpointConfig(root: jsonP.JSONValue): s.CheckpointConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "LocalPath": "s",
    },
  }, root);
}

function fromHyperParameterTuningJobWarmStartConfig(input?: s.HyperParameterTuningJobWarmStartConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentHyperParameterTuningJobs: input["ParentHyperParameterTuningJobs"]?.map(x => fromParentHyperParameterTuningJob(x)),
    WarmStartType: input["WarmStartType"],
  }
}
function toHyperParameterTuningJobWarmStartConfig(root: jsonP.JSONValue): s.HyperParameterTuningJobWarmStartConfig {
  return jsonP.readObj({
    required: {
      "ParentHyperParameterTuningJobs": [toParentHyperParameterTuningJob],
      "WarmStartType": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobWarmStartType>(x),
    },
    optional: {},
  }, root);
}

function fromParentHyperParameterTuningJob(input?: s.ParentHyperParameterTuningJob | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HyperParameterTuningJobName: input["HyperParameterTuningJobName"],
  }
}
function toParentHyperParameterTuningJob(root: jsonP.JSONValue): s.ParentHyperParameterTuningJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "HyperParameterTuningJobName": "s",
    },
  }, root);
}

function fromLabelingJobInputConfig(input?: s.LabelingJobInputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromLabelingJobDataSource(input["DataSource"]),
    DataAttributes: fromLabelingJobDataAttributes(input["DataAttributes"]),
  }
}
function toLabelingJobInputConfig(root: jsonP.JSONValue): s.LabelingJobInputConfig {
  return jsonP.readObj({
    required: {
      "DataSource": toLabelingJobDataSource,
    },
    optional: {
      "DataAttributes": toLabelingJobDataAttributes,
    },
  }, root);
}

function fromLabelingJobDataSource(input?: s.LabelingJobDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromLabelingJobS3DataSource(input["S3DataSource"]),
    SnsDataSource: fromLabelingJobSnsDataSource(input["SnsDataSource"]),
  }
}
function toLabelingJobDataSource(root: jsonP.JSONValue): s.LabelingJobDataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3DataSource": toLabelingJobS3DataSource,
      "SnsDataSource": toLabelingJobSnsDataSource,
    },
  }, root);
}

function fromLabelingJobS3DataSource(input?: s.LabelingJobS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ManifestS3Uri: input["ManifestS3Uri"],
  }
}
function toLabelingJobS3DataSource(root: jsonP.JSONValue): s.LabelingJobS3DataSource {
  return jsonP.readObj({
    required: {
      "ManifestS3Uri": "s",
    },
    optional: {},
  }, root);
}

function fromLabelingJobSnsDataSource(input?: s.LabelingJobSnsDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SnsTopicArn: input["SnsTopicArn"],
  }
}
function toLabelingJobSnsDataSource(root: jsonP.JSONValue): s.LabelingJobSnsDataSource {
  return jsonP.readObj({
    required: {
      "SnsTopicArn": "s",
    },
    optional: {},
  }, root);
}

function fromLabelingJobDataAttributes(input?: s.LabelingJobDataAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentClassifiers: input["ContentClassifiers"],
  }
}
function toLabelingJobDataAttributes(root: jsonP.JSONValue): s.LabelingJobDataAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContentClassifiers": [(x: jsonP.JSONValue) => cmnP.readEnum<s.ContentClassifier>(x)],
    },
  }, root);
}

function fromLabelingJobOutputConfig(input?: s.LabelingJobOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    KmsKeyId: input["KmsKeyId"],
    SnsTopicArn: input["SnsTopicArn"],
  }
}
function toLabelingJobOutputConfig(root: jsonP.JSONValue): s.LabelingJobOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
      "SnsTopicArn": "s",
    },
  }, root);
}

function fromLabelingJobStoppingConditions(input?: s.LabelingJobStoppingConditions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxHumanLabeledObjectCount: input["MaxHumanLabeledObjectCount"],
    MaxPercentageOfInputDatasetLabeled: input["MaxPercentageOfInputDatasetLabeled"],
  }
}
function toLabelingJobStoppingConditions(root: jsonP.JSONValue): s.LabelingJobStoppingConditions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxHumanLabeledObjectCount": "n",
      "MaxPercentageOfInputDatasetLabeled": "n",
    },
  }, root);
}

function fromLabelingJobAlgorithmsConfig(input?: s.LabelingJobAlgorithmsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LabelingJobAlgorithmSpecificationArn: input["LabelingJobAlgorithmSpecificationArn"],
    InitialActiveLearningModelArn: input["InitialActiveLearningModelArn"],
    LabelingJobResourceConfig: fromLabelingJobResourceConfig(input["LabelingJobResourceConfig"]),
  }
}
function toLabelingJobAlgorithmsConfig(root: jsonP.JSONValue): s.LabelingJobAlgorithmsConfig {
  return jsonP.readObj({
    required: {
      "LabelingJobAlgorithmSpecificationArn": "s",
    },
    optional: {
      "InitialActiveLearningModelArn": "s",
      "LabelingJobResourceConfig": toLabelingJobResourceConfig,
    },
  }, root);
}

function fromLabelingJobResourceConfig(input?: s.LabelingJobResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toLabelingJobResourceConfig(root: jsonP.JSONValue): s.LabelingJobResourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

function fromHumanTaskConfig(input?: s.HumanTaskConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WorkteamArn: input["WorkteamArn"],
    UiConfig: fromUiConfig(input["UiConfig"]),
    PreHumanTaskLambdaArn: input["PreHumanTaskLambdaArn"],
    TaskKeywords: input["TaskKeywords"],
    TaskTitle: input["TaskTitle"],
    TaskDescription: input["TaskDescription"],
    NumberOfHumanWorkersPerDataObject: input["NumberOfHumanWorkersPerDataObject"],
    TaskTimeLimitInSeconds: input["TaskTimeLimitInSeconds"],
    TaskAvailabilityLifetimeInSeconds: input["TaskAvailabilityLifetimeInSeconds"],
    MaxConcurrentTaskCount: input["MaxConcurrentTaskCount"],
    AnnotationConsolidationConfig: fromAnnotationConsolidationConfig(input["AnnotationConsolidationConfig"]),
    PublicWorkforceTaskPrice: fromPublicWorkforceTaskPrice(input["PublicWorkforceTaskPrice"]),
  }
}
function toHumanTaskConfig(root: jsonP.JSONValue): s.HumanTaskConfig {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
      "UiConfig": toUiConfig,
      "PreHumanTaskLambdaArn": "s",
      "TaskTitle": "s",
      "TaskDescription": "s",
      "NumberOfHumanWorkersPerDataObject": "n",
      "TaskTimeLimitInSeconds": "n",
      "AnnotationConsolidationConfig": toAnnotationConsolidationConfig,
    },
    optional: {
      "TaskKeywords": ["s"],
      "TaskAvailabilityLifetimeInSeconds": "n",
      "MaxConcurrentTaskCount": "n",
      "PublicWorkforceTaskPrice": toPublicWorkforceTaskPrice,
    },
  }, root);
}

function fromUiConfig(input?: s.UiConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UiTemplateS3Uri: input["UiTemplateS3Uri"],
    HumanTaskUiArn: input["HumanTaskUiArn"],
  }
}
function toUiConfig(root: jsonP.JSONValue): s.UiConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "UiTemplateS3Uri": "s",
      "HumanTaskUiArn": "s",
    },
  }, root);
}

function fromAnnotationConsolidationConfig(input?: s.AnnotationConsolidationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AnnotationConsolidationLambdaArn: input["AnnotationConsolidationLambdaArn"],
  }
}
function toAnnotationConsolidationConfig(root: jsonP.JSONValue): s.AnnotationConsolidationConfig {
  return jsonP.readObj({
    required: {
      "AnnotationConsolidationLambdaArn": "s",
    },
    optional: {},
  }, root);
}

function fromContainerDefinition(input?: s.ContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContainerHostname: input["ContainerHostname"],
    Image: input["Image"],
    ImageConfig: fromImageConfig(input["ImageConfig"]),
    Mode: input["Mode"],
    ModelDataUrl: input["ModelDataUrl"],
    Environment: input["Environment"],
    ModelPackageName: input["ModelPackageName"],
    MultiModelConfig: fromMultiModelConfig(input["MultiModelConfig"]),
  }
}
function toContainerDefinition(root: jsonP.JSONValue): s.ContainerDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContainerHostname": "s",
      "Image": "s",
      "ImageConfig": toImageConfig,
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ContainerMode>(x),
      "ModelDataUrl": "s",
      "Environment": x => jsonP.readMap(String, String, x),
      "ModelPackageName": "s",
      "MultiModelConfig": toMultiModelConfig,
    },
  }, root);
}

function fromImageConfig(input?: s.ImageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RepositoryAccessMode: input["RepositoryAccessMode"],
  }
}
function toImageConfig(root: jsonP.JSONValue): s.ImageConfig {
  return jsonP.readObj({
    required: {
      "RepositoryAccessMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.RepositoryAccessMode>(x),
    },
    optional: {},
  }, root);
}

function fromMultiModelConfig(input?: s.MultiModelConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ModelCacheSetting: input["ModelCacheSetting"],
  }
}
function toMultiModelConfig(root: jsonP.JSONValue): s.MultiModelConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelCacheSetting": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelCacheSetting>(x),
    },
  }, root);
}

function fromModelBiasBaselineConfig(input?: s.ModelBiasBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaseliningJobName: input["BaseliningJobName"],
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
  }
}
function toModelBiasBaselineConfig(root: jsonP.JSONValue): s.ModelBiasBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaseliningJobName": "s",
      "ConstraintsResource": toMonitoringConstraintsResource,
    },
  }, root);
}

function fromModelBiasAppSpecification(input?: s.ModelBiasAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ConfigUri: input["ConfigUri"],
    Environment: input["Environment"],
  }
}
function toModelBiasAppSpecification(root: jsonP.JSONValue): s.ModelBiasAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
      "ConfigUri": "s",
    },
    optional: {
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromModelBiasJobInput(input?: s.ModelBiasJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
    GroundTruthS3Input: fromMonitoringGroundTruthS3Input(input["GroundTruthS3Input"]),
  }
}
function toModelBiasJobInput(root: jsonP.JSONValue): s.ModelBiasJobInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
      "GroundTruthS3Input": toMonitoringGroundTruthS3Input,
    },
    optional: {},
  }, root);
}

function fromMonitoringGroundTruthS3Input(input?: s.MonitoringGroundTruthS3Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toMonitoringGroundTruthS3Input(root: jsonP.JSONValue): s.MonitoringGroundTruthS3Input {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
    },
  }, root);
}

function fromModelExplainabilityBaselineConfig(input?: s.ModelExplainabilityBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaseliningJobName: input["BaseliningJobName"],
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
  }
}
function toModelExplainabilityBaselineConfig(root: jsonP.JSONValue): s.ModelExplainabilityBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaseliningJobName": "s",
      "ConstraintsResource": toMonitoringConstraintsResource,
    },
  }, root);
}

function fromModelExplainabilityAppSpecification(input?: s.ModelExplainabilityAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ConfigUri: input["ConfigUri"],
    Environment: input["Environment"],
  }
}
function toModelExplainabilityAppSpecification(root: jsonP.JSONValue): s.ModelExplainabilityAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
      "ConfigUri": "s",
    },
    optional: {
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromModelExplainabilityJobInput(input?: s.ModelExplainabilityJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
  }
}
function toModelExplainabilityJobInput(root: jsonP.JSONValue): s.ModelExplainabilityJobInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
    },
    optional: {},
  }, root);
}

function fromModelPackageValidationSpecification(input?: s.ModelPackageValidationSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ValidationRole: input["ValidationRole"],
    ValidationProfiles: input["ValidationProfiles"]?.map(x => fromModelPackageValidationProfile(x)),
  }
}
function toModelPackageValidationSpecification(root: jsonP.JSONValue): s.ModelPackageValidationSpecification {
  return jsonP.readObj({
    required: {
      "ValidationRole": "s",
      "ValidationProfiles": [toModelPackageValidationProfile],
    },
    optional: {},
  }, root);
}

function fromModelPackageValidationProfile(input?: s.ModelPackageValidationProfile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProfileName: input["ProfileName"],
    TransformJobDefinition: fromTransformJobDefinition(input["TransformJobDefinition"]),
  }
}
function toModelPackageValidationProfile(root: jsonP.JSONValue): s.ModelPackageValidationProfile {
  return jsonP.readObj({
    required: {
      "ProfileName": "s",
      "TransformJobDefinition": toTransformJobDefinition,
    },
    optional: {},
  }, root);
}

function fromSourceAlgorithmSpecification(input?: s.SourceAlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceAlgorithms: input["SourceAlgorithms"]?.map(x => fromSourceAlgorithm(x)),
  }
}
function toSourceAlgorithmSpecification(root: jsonP.JSONValue): s.SourceAlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "SourceAlgorithms": [toSourceAlgorithm],
    },
    optional: {},
  }, root);
}

function fromSourceAlgorithm(input?: s.SourceAlgorithm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ModelDataUrl: input["ModelDataUrl"],
    AlgorithmName: input["AlgorithmName"],
  }
}
function toSourceAlgorithm(root: jsonP.JSONValue): s.SourceAlgorithm {
  return jsonP.readObj({
    required: {
      "AlgorithmName": "s",
    },
    optional: {
      "ModelDataUrl": "s",
    },
  }, root);
}

function fromModelMetrics(input?: s.ModelMetrics | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ModelQuality: fromModelQuality(input["ModelQuality"]),
    ModelDataQuality: fromModelDataQuality(input["ModelDataQuality"]),
    Bias: fromBias(input["Bias"]),
    Explainability: fromExplainability(input["Explainability"]),
  }
}
function toModelMetrics(root: jsonP.JSONValue): s.ModelMetrics {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelQuality": toModelQuality,
      "ModelDataQuality": toModelDataQuality,
      "Bias": toBias,
      "Explainability": toExplainability,
    },
  }, root);
}

function fromModelQuality(input?: s.ModelQuality | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statistics: fromMetricsSource(input["Statistics"]),
    Constraints: fromMetricsSource(input["Constraints"]),
  }
}
function toModelQuality(root: jsonP.JSONValue): s.ModelQuality {
  return jsonP.readObj({
    required: {},
    optional: {
      "Statistics": toMetricsSource,
      "Constraints": toMetricsSource,
    },
  }, root);
}

function fromMetricsSource(input?: s.MetricsSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentType: input["ContentType"],
    ContentDigest: input["ContentDigest"],
    S3Uri: input["S3Uri"],
  }
}
function toMetricsSource(root: jsonP.JSONValue): s.MetricsSource {
  return jsonP.readObj({
    required: {
      "ContentType": "s",
      "S3Uri": "s",
    },
    optional: {
      "ContentDigest": "s",
    },
  }, root);
}

function fromModelDataQuality(input?: s.ModelDataQuality | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Statistics: fromMetricsSource(input["Statistics"]),
    Constraints: fromMetricsSource(input["Constraints"]),
  }
}
function toModelDataQuality(root: jsonP.JSONValue): s.ModelDataQuality {
  return jsonP.readObj({
    required: {},
    optional: {
      "Statistics": toMetricsSource,
      "Constraints": toMetricsSource,
    },
  }, root);
}

function fromBias(input?: s.Bias | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Report: fromMetricsSource(input["Report"]),
  }
}
function toBias(root: jsonP.JSONValue): s.Bias {
  return jsonP.readObj({
    required: {},
    optional: {
      "Report": toMetricsSource,
    },
  }, root);
}

function fromExplainability(input?: s.Explainability | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Report: fromMetricsSource(input["Report"]),
  }
}
function toExplainability(root: jsonP.JSONValue): s.Explainability {
  return jsonP.readObj({
    required: {},
    optional: {
      "Report": toMetricsSource,
    },
  }, root);
}

function fromModelQualityBaselineConfig(input?: s.ModelQualityBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaseliningJobName: input["BaseliningJobName"],
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
  }
}
function toModelQualityBaselineConfig(root: jsonP.JSONValue): s.ModelQualityBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaseliningJobName": "s",
      "ConstraintsResource": toMonitoringConstraintsResource,
    },
  }, root);
}

function fromModelQualityAppSpecification(input?: s.ModelQualityAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
    RecordPreprocessorSourceUri: input["RecordPreprocessorSourceUri"],
    PostAnalyticsProcessorSourceUri: input["PostAnalyticsProcessorSourceUri"],
    ProblemType: input["ProblemType"],
    Environment: input["Environment"],
  }
}
function toModelQualityAppSpecification(root: jsonP.JSONValue): s.ModelQualityAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
      "RecordPreprocessorSourceUri": "s",
      "PostAnalyticsProcessorSourceUri": "s",
      "ProblemType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringProblemType>(x),
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromModelQualityJobInput(input?: s.ModelQualityJobInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
    GroundTruthS3Input: fromMonitoringGroundTruthS3Input(input["GroundTruthS3Input"]),
  }
}
function toModelQualityJobInput(root: jsonP.JSONValue): s.ModelQualityJobInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
      "GroundTruthS3Input": toMonitoringGroundTruthS3Input,
    },
    optional: {},
  }, root);
}

function fromMonitoringScheduleConfig(input?: s.MonitoringScheduleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ScheduleConfig: fromScheduleConfig(input["ScheduleConfig"]),
    MonitoringJobDefinition: fromMonitoringJobDefinition(input["MonitoringJobDefinition"]),
    MonitoringJobDefinitionName: input["MonitoringJobDefinitionName"],
    MonitoringType: input["MonitoringType"],
  }
}
function toMonitoringScheduleConfig(root: jsonP.JSONValue): s.MonitoringScheduleConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ScheduleConfig": toScheduleConfig,
      "MonitoringJobDefinition": toMonitoringJobDefinition,
      "MonitoringJobDefinitionName": "s",
      "MonitoringType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringType>(x),
    },
  }, root);
}

function fromScheduleConfig(input?: s.ScheduleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ScheduleExpression: input["ScheduleExpression"],
  }
}
function toScheduleConfig(root: jsonP.JSONValue): s.ScheduleConfig {
  return jsonP.readObj({
    required: {
      "ScheduleExpression": "s",
    },
    optional: {},
  }, root);
}

function fromMonitoringJobDefinition(input?: s.MonitoringJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaselineConfig: fromMonitoringBaselineConfig(input["BaselineConfig"]),
    MonitoringInputs: input["MonitoringInputs"]?.map(x => fromMonitoringInput(x)),
    MonitoringOutputConfig: fromMonitoringOutputConfig(input["MonitoringOutputConfig"]),
    MonitoringResources: fromMonitoringResources(input["MonitoringResources"]),
    MonitoringAppSpecification: fromMonitoringAppSpecification(input["MonitoringAppSpecification"]),
    StoppingCondition: fromMonitoringStoppingCondition(input["StoppingCondition"]),
    Environment: input["Environment"],
    NetworkConfig: fromNetworkConfig(input["NetworkConfig"]),
    RoleArn: input["RoleArn"],
  }
}
function toMonitoringJobDefinition(root: jsonP.JSONValue): s.MonitoringJobDefinition {
  return jsonP.readObj({
    required: {
      "MonitoringInputs": [toMonitoringInput],
      "MonitoringOutputConfig": toMonitoringOutputConfig,
      "MonitoringResources": toMonitoringResources,
      "MonitoringAppSpecification": toMonitoringAppSpecification,
      "RoleArn": "s",
    },
    optional: {
      "BaselineConfig": toMonitoringBaselineConfig,
      "StoppingCondition": toMonitoringStoppingCondition,
      "Environment": x => jsonP.readMap(String, String, x),
      "NetworkConfig": toNetworkConfig,
    },
  }, root);
}

function fromMonitoringBaselineConfig(input?: s.MonitoringBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaseliningJobName: input["BaseliningJobName"],
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
    StatisticsResource: fromMonitoringStatisticsResource(input["StatisticsResource"]),
  }
}
function toMonitoringBaselineConfig(root: jsonP.JSONValue): s.MonitoringBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "BaseliningJobName": "s",
      "ConstraintsResource": toMonitoringConstraintsResource,
      "StatisticsResource": toMonitoringStatisticsResource,
    },
  }, root);
}

function fromMonitoringInput(input?: s.MonitoringInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
  }
}
function toMonitoringInput(root: jsonP.JSONValue): s.MonitoringInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
    },
    optional: {},
  }, root);
}

function fromMonitoringAppSpecification(input?: s.MonitoringAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
    RecordPreprocessorSourceUri: input["RecordPreprocessorSourceUri"],
    PostAnalyticsProcessorSourceUri: input["PostAnalyticsProcessorSourceUri"],
  }
}
function toMonitoringAppSpecification(root: jsonP.JSONValue): s.MonitoringAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
      "RecordPreprocessorSourceUri": "s",
      "PostAnalyticsProcessorSourceUri": "s",
    },
  }, root);
}

function fromNetworkConfig(input?: s.NetworkConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    EnableNetworkIsolation: input["EnableNetworkIsolation"],
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
  }
}
function toNetworkConfig(root: jsonP.JSONValue): s.NetworkConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnableInterContainerTrafficEncryption": "b",
      "EnableNetworkIsolation": "b",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

function fromNotebookInstanceLifecycleHook(input?: s.NotebookInstanceLifecycleHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Content: input["Content"],
  }
}
function toNotebookInstanceLifecycleHook(root: jsonP.JSONValue): s.NotebookInstanceLifecycleHook {
  return jsonP.readObj({
    required: {},
    optional: {
      "Content": "s",
    },
  }, root);
}

function fromProcessingInput(input?: s.ProcessingInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputName: input["InputName"],
    AppManaged: input["AppManaged"],
    S3Input: fromProcessingS3Input(input["S3Input"]),
    DatasetDefinition: fromDatasetDefinition(input["DatasetDefinition"]),
  }
}
function toProcessingInput(root: jsonP.JSONValue): s.ProcessingInput {
  return jsonP.readObj({
    required: {
      "InputName": "s",
    },
    optional: {
      "AppManaged": "b",
      "S3Input": toProcessingS3Input,
      "DatasetDefinition": toDatasetDefinition,
    },
  }, root);
}

function fromProcessingS3Input(input?: s.ProcessingS3Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3DataType: input["S3DataType"],
    S3InputMode: input["S3InputMode"],
    S3DataDistributionType: input["S3DataDistributionType"],
    S3CompressionType: input["S3CompressionType"],
  }
}
function toProcessingS3Input(root: jsonP.JSONValue): s.ProcessingS3Input {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3DataType>(x),
    },
    optional: {
      "LocalPath": "s",
      "S3InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3InputMode>(x),
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3DataDistributionType>(x),
      "S3CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3CompressionType>(x),
    },
  }, root);
}

function fromDatasetDefinition(input?: s.DatasetDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AthenaDatasetDefinition: fromAthenaDatasetDefinition(input["AthenaDatasetDefinition"]),
    RedshiftDatasetDefinition: fromRedshiftDatasetDefinition(input["RedshiftDatasetDefinition"]),
    LocalPath: input["LocalPath"],
    DataDistributionType: input["DataDistributionType"],
    InputMode: input["InputMode"],
  }
}
function toDatasetDefinition(root: jsonP.JSONValue): s.DatasetDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "AthenaDatasetDefinition": toAthenaDatasetDefinition,
      "RedshiftDatasetDefinition": toRedshiftDatasetDefinition,
      "LocalPath": "s",
      "DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DataDistributionType>(x),
      "InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.InputMode>(x),
    },
  }, root);
}

function fromAthenaDatasetDefinition(input?: s.AthenaDatasetDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Catalog: input["Catalog"],
    Database: input["Database"],
    QueryString: input["QueryString"],
    WorkGroup: input["WorkGroup"],
    OutputS3Uri: input["OutputS3Uri"],
    KmsKeyId: input["KmsKeyId"],
    OutputFormat: input["OutputFormat"],
    OutputCompression: input["OutputCompression"],
  }
}
function toAthenaDatasetDefinition(root: jsonP.JSONValue): s.AthenaDatasetDefinition {
  return jsonP.readObj({
    required: {
      "Catalog": "s",
      "Database": "s",
      "QueryString": "s",
      "OutputS3Uri": "s",
      "OutputFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.AthenaResultFormat>(x),
    },
    optional: {
      "WorkGroup": "s",
      "KmsKeyId": "s",
      "OutputCompression": (x: jsonP.JSONValue) => cmnP.readEnum<s.AthenaResultCompressionType>(x),
    },
  }, root);
}

function fromRedshiftDatasetDefinition(input?: s.RedshiftDatasetDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterId: input["ClusterId"],
    Database: input["Database"],
    DbUser: input["DbUser"],
    QueryString: input["QueryString"],
    ClusterRoleArn: input["ClusterRoleArn"],
    OutputS3Uri: input["OutputS3Uri"],
    KmsKeyId: input["KmsKeyId"],
    OutputFormat: input["OutputFormat"],
    OutputCompression: input["OutputCompression"],
  }
}
function toRedshiftDatasetDefinition(root: jsonP.JSONValue): s.RedshiftDatasetDefinition {
  return jsonP.readObj({
    required: {
      "ClusterId": "s",
      "Database": "s",
      "DbUser": "s",
      "QueryString": "s",
      "ClusterRoleArn": "s",
      "OutputS3Uri": "s",
      "OutputFormat": (x: jsonP.JSONValue) => cmnP.readEnum<s.RedshiftResultFormat>(x),
    },
    optional: {
      "KmsKeyId": "s",
      "OutputCompression": (x: jsonP.JSONValue) => cmnP.readEnum<s.RedshiftResultCompressionType>(x),
    },
  }, root);
}

function fromProcessingOutputConfig(input?: s.ProcessingOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Outputs: input["Outputs"]?.map(x => fromProcessingOutput(x)),
    KmsKeyId: input["KmsKeyId"],
  }
}
function toProcessingOutputConfig(root: jsonP.JSONValue): s.ProcessingOutputConfig {
  return jsonP.readObj({
    required: {
      "Outputs": [toProcessingOutput],
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

function fromProcessingOutput(input?: s.ProcessingOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OutputName: input["OutputName"],
    S3Output: fromProcessingS3Output(input["S3Output"]),
    FeatureStoreOutput: fromProcessingFeatureStoreOutput(input["FeatureStoreOutput"]),
    AppManaged: input["AppManaged"],
  }
}
function toProcessingOutput(root: jsonP.JSONValue): s.ProcessingOutput {
  return jsonP.readObj({
    required: {
      "OutputName": "s",
    },
    optional: {
      "S3Output": toProcessingS3Output,
      "FeatureStoreOutput": toProcessingFeatureStoreOutput,
      "AppManaged": "b",
    },
  }, root);
}

function fromProcessingS3Output(input?: s.ProcessingS3Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3UploadMode: input["S3UploadMode"],
  }
}
function toProcessingS3Output(root: jsonP.JSONValue): s.ProcessingS3Output {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "LocalPath": "s",
      "S3UploadMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingS3UploadMode>(x),
    },
    optional: {},
  }, root);
}

function fromProcessingFeatureStoreOutput(input?: s.ProcessingFeatureStoreOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FeatureGroupName: input["FeatureGroupName"],
  }
}
function toProcessingFeatureStoreOutput(root: jsonP.JSONValue): s.ProcessingFeatureStoreOutput {
  return jsonP.readObj({
    required: {
      "FeatureGroupName": "s",
    },
    optional: {},
  }, root);
}

function fromProcessingResources(input?: s.ProcessingResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterConfig: fromProcessingClusterConfig(input["ClusterConfig"]),
  }
}
function toProcessingResources(root: jsonP.JSONValue): s.ProcessingResources {
  return jsonP.readObj({
    required: {
      "ClusterConfig": toProcessingClusterConfig,
    },
    optional: {},
  }, root);
}

function fromProcessingClusterConfig(input?: s.ProcessingClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toProcessingClusterConfig(root: jsonP.JSONValue): s.ProcessingClusterConfig {
  return jsonP.readObj({
    required: {
      "InstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

function fromProcessingStoppingCondition(input?: s.ProcessingStoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
  }
}
function toProcessingStoppingCondition(root: jsonP.JSONValue): s.ProcessingStoppingCondition {
  return jsonP.readObj({
    required: {
      "MaxRuntimeInSeconds": "n",
    },
    optional: {},
  }, root);
}

function fromAppSpecification(input?: s.AppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
  }
}
function toAppSpecification(root: jsonP.JSONValue): s.AppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
    },
  }, root);
}

function fromExperimentConfig(input?: s.ExperimentConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExperimentName: input["ExperimentName"],
    TrialName: input["TrialName"],
    TrialComponentDisplayName: input["TrialComponentDisplayName"],
  }
}
function toExperimentConfig(root: jsonP.JSONValue): s.ExperimentConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentName": "s",
      "TrialName": "s",
      "TrialComponentDisplayName": "s",
    },
  }, root);
}

function fromServiceCatalogProvisioningDetails(input?: s.ServiceCatalogProvisioningDetails | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProductId: input["ProductId"],
    ProvisioningArtifactId: input["ProvisioningArtifactId"],
    PathId: input["PathId"],
    ProvisioningParameters: input["ProvisioningParameters"]?.map(x => fromProvisioningParameter(x)),
  }
}
function toServiceCatalogProvisioningDetails(root: jsonP.JSONValue): s.ServiceCatalogProvisioningDetails {
  return jsonP.readObj({
    required: {
      "ProductId": "s",
      "ProvisioningArtifactId": "s",
    },
    optional: {
      "PathId": "s",
      "ProvisioningParameters": [toProvisioningParameter],
    },
  }, root);
}

function fromProvisioningParameter(input?: s.ProvisioningParameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toProvisioningParameter(root: jsonP.JSONValue): s.ProvisioningParameter {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromAlgorithmSpecification(input?: s.AlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    AlgorithmName: input["AlgorithmName"],
    TrainingInputMode: input["TrainingInputMode"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
    EnableSageMakerMetricsTimeSeries: input["EnableSageMakerMetricsTimeSeries"],
  }
}
function toAlgorithmSpecification(root: jsonP.JSONValue): s.AlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingInputMode>(x),
    },
    optional: {
      "TrainingImage": "s",
      "AlgorithmName": "s",
      "MetricDefinitions": [toMetricDefinition],
      "EnableSageMakerMetricsTimeSeries": "b",
    },
  }, root);
}

function fromDebugHookConfig(input?: s.DebugHookConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
    HookParameters: input["HookParameters"],
    CollectionConfigurations: input["CollectionConfigurations"]?.map(x => fromCollectionConfiguration(x)),
  }
}
function toDebugHookConfig(root: jsonP.JSONValue): s.DebugHookConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "LocalPath": "s",
      "HookParameters": x => jsonP.readMap(String, String, x),
      "CollectionConfigurations": [toCollectionConfiguration],
    },
  }, root);
}

function fromCollectionConfiguration(input?: s.CollectionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CollectionName: input["CollectionName"],
    CollectionParameters: input["CollectionParameters"],
  }
}
function toCollectionConfiguration(root: jsonP.JSONValue): s.CollectionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CollectionName": "s",
      "CollectionParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromDebugRuleConfiguration(input?: s.DebugRuleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleConfigurationName: input["RuleConfigurationName"],
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
    RuleEvaluatorImage: input["RuleEvaluatorImage"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    RuleParameters: input["RuleParameters"],
  }
}
function toDebugRuleConfiguration(root: jsonP.JSONValue): s.DebugRuleConfiguration {
  return jsonP.readObj({
    required: {
      "RuleConfigurationName": "s",
      "RuleEvaluatorImage": "s",
    },
    optional: {
      "LocalPath": "s",
      "S3OutputPath": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
      "RuleParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromTensorBoardOutputConfig(input?: s.TensorBoardOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toTensorBoardOutputConfig(root: jsonP.JSONValue): s.TensorBoardOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "LocalPath": "s",
    },
  }, root);
}

function fromProfilerConfig(input?: s.ProfilerConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    ProfilingIntervalInMilliseconds: input["ProfilingIntervalInMilliseconds"],
    ProfilingParameters: input["ProfilingParameters"],
  }
}
function toProfilerConfig(root: jsonP.JSONValue): s.ProfilerConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "ProfilingIntervalInMilliseconds": "n",
      "ProfilingParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromProfilerRuleConfiguration(input?: s.ProfilerRuleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleConfigurationName: input["RuleConfigurationName"],
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
    RuleEvaluatorImage: input["RuleEvaluatorImage"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    RuleParameters: input["RuleParameters"],
  }
}
function toProfilerRuleConfiguration(root: jsonP.JSONValue): s.ProfilerRuleConfiguration {
  return jsonP.readObj({
    required: {
      "RuleConfigurationName": "s",
      "RuleEvaluatorImage": "s",
    },
    optional: {
      "LocalPath": "s",
      "S3OutputPath": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
      "RuleParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function fromModelClientConfig(input?: s.ModelClientConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InvocationsTimeoutInSeconds: input["InvocationsTimeoutInSeconds"],
    InvocationsMaxRetries: input["InvocationsMaxRetries"],
  }
}
function toModelClientConfig(root: jsonP.JSONValue): s.ModelClientConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "InvocationsTimeoutInSeconds": "n",
      "InvocationsMaxRetries": "n",
    },
  }, root);
}

function fromDataProcessing(input?: s.DataProcessing | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputFilter: input["InputFilter"],
    OutputFilter: input["OutputFilter"],
    JoinSource: input["JoinSource"],
  }
}
function toDataProcessing(root: jsonP.JSONValue): s.DataProcessing {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputFilter": "s",
      "OutputFilter": "s",
      "JoinSource": (x: jsonP.JSONValue) => cmnP.readEnum<s.JoinSource>(x),
    },
  }, root);
}

function fromTrialComponentStatus(input?: s.TrialComponentStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrimaryStatus: input["PrimaryStatus"],
    Message: input["Message"],
  }
}
function toTrialComponentStatus(root: jsonP.JSONValue): s.TrialComponentStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrialComponentPrimaryStatus>(x),
      "Message": "s",
    },
  }, root);
}

function fromTrialComponentParameterValue(input?: s.TrialComponentParameterValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    NumberValue: input["NumberValue"],
  }
}
function toTrialComponentParameterValue(root: jsonP.JSONValue): s.TrialComponentParameterValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "StringValue": "s",
      "NumberValue": "n",
    },
  }, root);
}

function fromTrialComponentArtifact(input?: s.TrialComponentArtifact | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MediaType: input["MediaType"],
    Value: input["Value"],
  }
}
function toTrialComponentArtifact(root: jsonP.JSONValue): s.TrialComponentArtifact {
  return jsonP.readObj({
    required: {
      "Value": "s",
    },
    optional: {
      "MediaType": "s",
    },
  }, root);
}

function fromCognitoConfig(input?: s.CognitoConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserPool: input["UserPool"],
    ClientId: input["ClientId"],
  }
}
function toCognitoConfig(root: jsonP.JSONValue): s.CognitoConfig {
  return jsonP.readObj({
    required: {
      "UserPool": "s",
      "ClientId": "s",
    },
    optional: {},
  }, root);
}

function fromOidcConfig(input?: s.OidcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClientId: input["ClientId"],
    ClientSecret: input["ClientSecret"],
    Issuer: input["Issuer"],
    AuthorizationEndpoint: input["AuthorizationEndpoint"],
    TokenEndpoint: input["TokenEndpoint"],
    UserInfoEndpoint: input["UserInfoEndpoint"],
    LogoutEndpoint: input["LogoutEndpoint"],
    JwksUri: input["JwksUri"],
  }
}

function fromSourceIpConfig(input?: s.SourceIpConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Cidrs: input["Cidrs"],
  }
}
function toSourceIpConfig(root: jsonP.JSONValue): s.SourceIpConfig {
  return jsonP.readObj({
    required: {
      "Cidrs": ["s"],
    },
    optional: {},
  }, root);
}

function fromMemberDefinition(input?: s.MemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CognitoMemberDefinition: fromCognitoMemberDefinition(input["CognitoMemberDefinition"]),
    OidcMemberDefinition: fromOidcMemberDefinition(input["OidcMemberDefinition"]),
  }
}
function toMemberDefinition(root: jsonP.JSONValue): s.MemberDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "CognitoMemberDefinition": toCognitoMemberDefinition,
      "OidcMemberDefinition": toOidcMemberDefinition,
    },
  }, root);
}

function fromCognitoMemberDefinition(input?: s.CognitoMemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserPool: input["UserPool"],
    UserGroup: input["UserGroup"],
    ClientId: input["ClientId"],
  }
}
function toCognitoMemberDefinition(root: jsonP.JSONValue): s.CognitoMemberDefinition {
  return jsonP.readObj({
    required: {
      "UserPool": "s",
      "UserGroup": "s",
      "ClientId": "s",
    },
    optional: {},
  }, root);
}

function fromOidcMemberDefinition(input?: s.OidcMemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Groups: input["Groups"],
  }
}
function toOidcMemberDefinition(root: jsonP.JSONValue): s.OidcMemberDefinition {
  return jsonP.readObj({
    required: {
      "Groups": ["s"],
    },
    optional: {},
  }, root);
}

function fromNotificationConfiguration(input?: s.NotificationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotificationTopicArn: input["NotificationTopicArn"],
  }
}
function toNotificationConfiguration(root: jsonP.JSONValue): s.NotificationConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotificationTopicArn": "s",
    },
  }, root);
}

function fromRetentionPolicy(input?: s.RetentionPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HomeEfsFileSystem: input["HomeEfsFileSystem"],
  }
}

function fromSuggestionQuery(input?: s.SuggestionQuery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PropertyNameQuery: fromPropertyNameQuery(input["PropertyNameQuery"]),
  }
}

function fromPropertyNameQuery(input?: s.PropertyNameQuery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PropertyNameHint: input["PropertyNameHint"],
  }
}

function fromDevice(input?: s.Device | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeviceName: input["DeviceName"],
    Description: input["Description"],
    IotThingName: input["IotThingName"],
  }
}

function fromRenderableTask(input?: s.RenderableTask | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Input: input["Input"],
  }
}

function fromSearchExpression(input?: s.SearchExpression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Filters: input["Filters"]?.map(x => fromFilter(x)),
    NestedFilters: input["NestedFilters"]?.map(x => fromNestedFilters(x)),
    SubExpressions: input["SubExpressions"]?.map(x => fromSearchExpression(x)),
    Operator: input["Operator"],
  }
}

function fromFilter(input?: s.Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Operator: input["Operator"],
    Value: input["Value"],
  }
}

function fromNestedFilters(input?: s.NestedFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NestedPropertyName: input["NestedPropertyName"],
    Filters: input["Filters"]?.map(x => fromFilter(x)),
  }
}

function fromParameter(input?: s.Parameter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
  }
}
function toParameter(root: jsonP.JSONValue): s.Parameter {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function fromGitConfigForUpdate(input?: s.GitConfigForUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecretArn: input["SecretArn"],
  }
}

function fromVariantProperty(input?: s.VariantProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantPropertyType: input["VariantPropertyType"],
  }
}

function fromDeploymentConfig(input?: s.DeploymentConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BlueGreenUpdatePolicy: fromBlueGreenUpdatePolicy(input["BlueGreenUpdatePolicy"]),
    AutoRollbackConfiguration: fromAutoRollbackConfig(input["AutoRollbackConfiguration"]),
  }
}
function toDeploymentConfig(root: jsonP.JSONValue): s.DeploymentConfig {
  return jsonP.readObj({
    required: {
      "BlueGreenUpdatePolicy": toBlueGreenUpdatePolicy,
    },
    optional: {
      "AutoRollbackConfiguration": toAutoRollbackConfig,
    },
  }, root);
}

function fromBlueGreenUpdatePolicy(input?: s.BlueGreenUpdatePolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrafficRoutingConfiguration: fromTrafficRoutingConfig(input["TrafficRoutingConfiguration"]),
    TerminationWaitInSeconds: input["TerminationWaitInSeconds"],
    MaximumExecutionTimeoutInSeconds: input["MaximumExecutionTimeoutInSeconds"],
  }
}
function toBlueGreenUpdatePolicy(root: jsonP.JSONValue): s.BlueGreenUpdatePolicy {
  return jsonP.readObj({
    required: {
      "TrafficRoutingConfiguration": toTrafficRoutingConfig,
    },
    optional: {
      "TerminationWaitInSeconds": "n",
      "MaximumExecutionTimeoutInSeconds": "n",
    },
  }, root);
}

function fromTrafficRoutingConfig(input?: s.TrafficRoutingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    WaitIntervalInSeconds: input["WaitIntervalInSeconds"],
    CanarySize: fromCapacitySize(input["CanarySize"]),
  }
}
function toTrafficRoutingConfig(root: jsonP.JSONValue): s.TrafficRoutingConfig {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrafficRoutingConfigType>(x),
      "WaitIntervalInSeconds": "n",
    },
    optional: {
      "CanarySize": toCapacitySize,
    },
  }, root);
}

function fromCapacitySize(input?: s.CapacitySize | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    Value: input["Value"],
  }
}
function toCapacitySize(root: jsonP.JSONValue): s.CapacitySize {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.CapacitySizeType>(x),
      "Value": "n",
    },
    optional: {},
  }, root);
}

function fromAutoRollbackConfig(input?: s.AutoRollbackConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Alarms: input["Alarms"]?.map(x => fromAlarm(x)),
  }
}
function toAutoRollbackConfig(root: jsonP.JSONValue): s.AutoRollbackConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "Alarms": [toAlarm],
    },
  }, root);
}

function fromAlarm(input?: s.Alarm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AlarmName: input["AlarmName"],
  }
}
function toAlarm(root: jsonP.JSONValue): s.Alarm {
  return jsonP.readObj({
    required: {},
    optional: {
      "AlarmName": "s",
    },
  }, root);
}

function fromDesiredWeightAndCapacity(input?: s.DesiredWeightAndCapacity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantName: input["VariantName"],
    DesiredWeight: input["DesiredWeight"],
    DesiredInstanceCount: input["DesiredInstanceCount"],
  }
}

function fromProfilerConfigForUpdate(input?: s.ProfilerConfigForUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    ProfilingIntervalInMilliseconds: input["ProfilingIntervalInMilliseconds"],
    ProfilingParameters: input["ProfilingParameters"],
    DisableProfiler: input["DisableProfiler"],
  }
}

function toUserContext(root: jsonP.JSONValue): s.UserContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserProfileArn": "s",
      "UserProfileName": "s",
      "DomainId": "s",
    },
  }, root);
}

function toAlgorithmStatusDetails(root: jsonP.JSONValue): s.AlgorithmStatusDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ValidationStatuses": [toAlgorithmStatusItem],
      "ImageScanStatuses": [toAlgorithmStatusItem],
    },
  }, root);
}

function toAlgorithmStatusItem(root: jsonP.JSONValue): s.AlgorithmStatusItem {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetailedAlgorithmStatus>(x),
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

function toAutoMLCandidate(root: jsonP.JSONValue): s.AutoMLCandidate {
  return jsonP.readObj({
    required: {
      "CandidateName": "s",
      "ObjectiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectiveStatus>(x),
      "CandidateSteps": [toAutoMLCandidateStep],
      "CandidateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CandidateStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "FinalAutoMLJobObjectiveMetric": toFinalAutoMLJobObjectiveMetric,
      "InferenceContainers": [toAutoMLContainerDefinition],
      "EndTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

function toFinalAutoMLJobObjectiveMetric(root: jsonP.JSONValue): s.FinalAutoMLJobObjectiveMetric {
  return jsonP.readObj({
    required: {
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLMetricEnum>(x),
      "Value": "n",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLJobObjectiveType>(x),
    },
  }, root);
}

function toAutoMLCandidateStep(root: jsonP.JSONValue): s.AutoMLCandidateStep {
  return jsonP.readObj({
    required: {
      "CandidateStepType": (x: jsonP.JSONValue) => cmnP.readEnum<s.CandidateStepType>(x),
      "CandidateStepArn": "s",
      "CandidateStepName": "s",
    },
    optional: {},
  }, root);
}

function toAutoMLContainerDefinition(root: jsonP.JSONValue): s.AutoMLContainerDefinition {
  return jsonP.readObj({
    required: {
      "Image": "s",
      "ModelDataUrl": "s",
    },
    optional: {
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toAutoMLJobArtifacts(root: jsonP.JSONValue): s.AutoMLJobArtifacts {
  return jsonP.readObj({
    required: {},
    optional: {
      "CandidateDefinitionNotebookLocation": "s",
      "DataExplorationNotebookLocation": "s",
    },
  }, root);
}

function toResolvedAttributes(root: jsonP.JSONValue): s.ResolvedAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutoMLJobObjective": toAutoMLJobObjective,
      "ProblemType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProblemType>(x),
      "CompletionCriteria": toAutoMLJobCompletionCriteria,
    },
  }, root);
}

function toModelArtifacts(root: jsonP.JSONValue): s.ModelArtifacts {
  return jsonP.readObj({
    required: {
      "S3ModelArtifacts": "s",
    },
    optional: {},
  }, root);
}

function toModelDigests(root: jsonP.JSONValue): s.ModelDigests {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArtifactDigest": "s",
    },
  }, root);
}

function toEdgeModel(root: jsonP.JSONValue): s.EdgeModel {
  return jsonP.readObj({
    required: {
      "ModelName": "s",
      "ModelVersion": "s",
    },
    optional: {
      "LatestSampleTime": "d",
      "LatestInference": "d",
    },
  }, root);
}

function toProductionVariantSummary(root: jsonP.JSONValue): s.ProductionVariantSummary {
  return jsonP.readObj({
    required: {
      "VariantName": "s",
    },
    optional: {
      "DeployedImages": [toDeployedImage],
      "CurrentWeight": "n",
      "DesiredWeight": "n",
      "CurrentInstanceCount": "n",
      "DesiredInstanceCount": "n",
    },
  }, root);
}

function toDeployedImage(root: jsonP.JSONValue): s.DeployedImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpecifiedImage": "s",
      "ResolvedImage": "s",
      "ResolutionTime": "d",
    },
  }, root);
}

function toDataCaptureConfigSummary(root: jsonP.JSONValue): s.DataCaptureConfigSummary {
  return jsonP.readObj({
    required: {
      "EnableCapture": "b",
      "CaptureStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CaptureStatus>(x),
      "CurrentSamplingPercentage": "n",
      "DestinationS3Uri": "s",
      "KmsKeyId": "s",
    },
    optional: {},
  }, root);
}

function toExperimentSource(root: jsonP.JSONValue): s.ExperimentSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

function toOfflineStoreStatus(root: jsonP.JSONValue): s.OfflineStoreStatus {
  return jsonP.readObj({
    required: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.OfflineStoreStatusValue>(x),
    },
    optional: {
      "BlockedReason": "s",
    },
  }, root);
}

function toUiTemplateInfo(root: jsonP.JSONValue): s.UiTemplateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
      "ContentSha256": "s",
    },
  }, root);
}

function toTrainingJobStatusCounters(root: jsonP.JSONValue): s.TrainingJobStatusCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Completed": "n",
      "InProgress": "n",
      "RetryableError": "n",
      "NonRetryableError": "n",
      "Stopped": "n",
    },
  }, root);
}

function toObjectiveStatusCounters(root: jsonP.JSONValue): s.ObjectiveStatusCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Succeeded": "n",
      "Pending": "n",
      "Failed": "n",
    },
  }, root);
}

function toHyperParameterTrainingJobSummary(root: jsonP.JSONValue): s.HyperParameterTrainingJobSummary {
  return jsonP.readObj({
    required: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "CreationTime": "d",
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingJobStatus>(x),
      "TunedHyperParameters": x => jsonP.readMap(String, String, x),
    },
    optional: {
      "TrainingJobDefinitionName": "s",
      "TuningJobName": "s",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "FailureReason": "s",
      "FinalHyperParameterTuningJobObjectiveMetric": toFinalHyperParameterTuningJobObjectiveMetric,
      "ObjectiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ObjectiveStatus>(x),
    },
  }, root);
}

function toFinalHyperParameterTuningJobObjectiveMetric(root: jsonP.JSONValue): s.FinalHyperParameterTuningJobObjectiveMetric {
  return jsonP.readObj({
    required: {
      "MetricName": "s",
      "Value": "n",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobObjectiveType>(x),
    },
  }, root);
}

function toLabelCounters(root: jsonP.JSONValue): s.LabelCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalLabeled": "n",
      "HumanLabeled": "n",
      "MachineLabeled": "n",
      "FailedNonRetryableError": "n",
      "Unlabeled": "n",
    },
  }, root);
}

function toLabelingJobOutput(root: jsonP.JSONValue): s.LabelingJobOutput {
  return jsonP.readObj({
    required: {
      "OutputDatasetS3Uri": "s",
    },
    optional: {
      "FinalActiveLearningModelArn": "s",
    },
  }, root);
}

function toModelPackageStatusDetails(root: jsonP.JSONValue): s.ModelPackageStatusDetails {
  return jsonP.readObj({
    required: {
      "ValidationStatuses": [toModelPackageStatusItem],
    },
    optional: {
      "ImageScanStatuses": [toModelPackageStatusItem],
    },
  }, root);
}

function toModelPackageStatusItem(root: jsonP.JSONValue): s.ModelPackageStatusItem {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DetailedModelPackageStatus>(x),
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

function toMonitoringExecutionSummary(root: jsonP.JSONValue): s.MonitoringExecutionSummary {
  return jsonP.readObj({
    required: {
      "MonitoringScheduleName": "s",
      "ScheduledTime": "d",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "MonitoringExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ExecutionStatus>(x),
    },
    optional: {
      "ProcessingJobArn": "s",
      "EndpointName": "s",
      "FailureReason": "s",
      "MonitoringJobDefinitionName": "s",
      "MonitoringType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringType>(x),
    },
  }, root);
}

function toServiceCatalogProvisionedProductDetails(root: jsonP.JSONValue): s.ServiceCatalogProvisionedProductDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProvisionedProductId": "s",
      "ProvisionedProductStatusMessage": "s",
    },
  }, root);
}

function toSubscribedWorkteam(root: jsonP.JSONValue): s.SubscribedWorkteam {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
    },
    optional: {
      "MarketplaceTitle": "s",
      "SellerName": "s",
      "MarketplaceDescription": "s",
      "ListingId": "s",
    },
  }, root);
}

function toSecondaryStatusTransition(root: jsonP.JSONValue): s.SecondaryStatusTransition {
  return jsonP.readObj({
    required: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecondaryStatus>(x),
      "StartTime": "d",
    },
    optional: {
      "EndTime": "d",
      "StatusMessage": "s",
    },
  }, root);
}

function toMetricData(root: jsonP.JSONValue): s.MetricData {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetricName": "s",
      "Value": "n",
      "Timestamp": "d",
    },
  }, root);
}

function toDebugRuleEvaluationStatus(root: jsonP.JSONValue): s.DebugRuleEvaluationStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleConfigurationName": "s",
      "RuleEvaluationJobArn": "s",
      "RuleEvaluationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleEvaluationStatus>(x),
      "StatusDetails": "s",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toProfilerRuleEvaluationStatus(root: jsonP.JSONValue): s.ProfilerRuleEvaluationStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleConfigurationName": "s",
      "RuleEvaluationJobArn": "s",
      "RuleEvaluationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.RuleEvaluationStatus>(x),
      "StatusDetails": "s",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toTrialSource(root: jsonP.JSONValue): s.TrialSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

function toTrialComponentSource(root: jsonP.JSONValue): s.TrialComponentSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

function toTrialComponentMetricSummary(root: jsonP.JSONValue): s.TrialComponentMetricSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetricName": "s",
      "SourceArn": "s",
      "TimeStamp": "d",
      "Max": "n",
      "Min": "n",
      "Last": "n",
      "Count": "n",
      "Avg": "n",
      "StdDev": "n",
    },
  }, root);
}

function toWorkforce(root: jsonP.JSONValue): s.Workforce {
  return jsonP.readObj({
    required: {
      "WorkforceName": "s",
      "WorkforceArn": "s",
    },
    optional: {
      "LastUpdatedDate": "d",
      "SourceIpConfig": toSourceIpConfig,
      "SubDomain": "s",
      "CognitoConfig": toCognitoConfig,
      "OidcConfig": toOidcConfigForResponse,
      "CreateDate": "d",
    },
  }, root);
}

function toOidcConfigForResponse(root: jsonP.JSONValue): s.OidcConfigForResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientId": "s",
      "Issuer": "s",
      "AuthorizationEndpoint": "s",
      "TokenEndpoint": "s",
      "UserInfoEndpoint": "s",
      "LogoutEndpoint": "s",
      "JwksUri": "s",
    },
  }, root);
}

function toWorkteam(root: jsonP.JSONValue): s.Workteam {
  return jsonP.readObj({
    required: {
      "WorkteamName": "s",
      "MemberDefinitions": [toMemberDefinition],
      "WorkteamArn": "s",
      "Description": "s",
    },
    optional: {
      "WorkforceArn": "s",
      "ProductListingIds": ["s"],
      "SubDomain": "s",
      "CreateDate": "d",
      "LastUpdatedDate": "d",
      "NotificationConfiguration": toNotificationConfiguration,
    },
  }, root);
}

function toDeviceStats(root: jsonP.JSONValue): s.DeviceStats {
  return jsonP.readObj({
    required: {
      "ConnectedDeviceCount": "n",
      "RegisteredDeviceCount": "n",
    },
    optional: {},
  }, root);
}

function toAgentVersion(root: jsonP.JSONValue): s.AgentVersion {
  return jsonP.readObj({
    required: {
      "Version": "s",
      "AgentCount": "n",
    },
    optional: {},
  }, root);
}

function toEdgeModelStat(root: jsonP.JSONValue): s.EdgeModelStat {
  return jsonP.readObj({
    required: {
      "ModelName": "s",
      "ModelVersion": "s",
      "OfflineDeviceCount": "n",
      "ConnectedDeviceCount": "n",
      "ActiveDeviceCount": "n",
      "SamplingDeviceCount": "n",
    },
    optional: {},
  }, root);
}

function toPropertyNameSuggestion(root: jsonP.JSONValue): s.PropertyNameSuggestion {
  return jsonP.readObj({
    required: {},
    optional: {
      "PropertyName": "s",
    },
  }, root);
}

function toActionSummary(root: jsonP.JSONValue): s.ActionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ActionArn": "s",
      "ActionName": "s",
      "Source": toActionSource,
      "ActionType": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ActionStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toAlgorithmSummary(root: jsonP.JSONValue): s.AlgorithmSummary {
  return jsonP.readObj({
    required: {
      "AlgorithmName": "s",
      "AlgorithmArn": "s",
      "CreationTime": "d",
      "AlgorithmStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AlgorithmStatus>(x),
    },
    optional: {
      "AlgorithmDescription": "s",
    },
  }, root);
}

function toAppImageConfigDetails(root: jsonP.JSONValue): s.AppImageConfigDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppImageConfigArn": "s",
      "AppImageConfigName": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "KernelGatewayImageConfig": toKernelGatewayImageConfig,
    },
  }, root);
}

function toAppDetails(root: jsonP.JSONValue): s.AppDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainId": "s",
      "UserProfileName": "s",
      "AppType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppType>(x),
      "AppName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.AppStatus>(x),
      "CreationTime": "d",
    },
  }, root);
}

function toArtifactSummary(root: jsonP.JSONValue): s.ArtifactSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ArtifactArn": "s",
      "ArtifactName": "s",
      "Source": toArtifactSource,
      "ArtifactType": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toAssociationSummary(root: jsonP.JSONValue): s.AssociationSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceArn": "s",
      "DestinationArn": "s",
      "SourceType": "s",
      "DestinationType": "s",
      "AssociationType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AssociationEdgeType>(x),
      "SourceName": "s",
      "DestinationName": "s",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
    },
  }, root);
}

function toAutoMLJobSummary(root: jsonP.JSONValue): s.AutoMLJobSummary {
  return jsonP.readObj({
    required: {
      "AutoMLJobName": "s",
      "AutoMLJobArn": "s",
      "AutoMLJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLJobStatus>(x),
      "AutoMLJobSecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.AutoMLJobSecondaryStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "EndTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

function toCodeRepositorySummary(root: jsonP.JSONValue): s.CodeRepositorySummary {
  return jsonP.readObj({
    required: {
      "CodeRepositoryName": "s",
      "CodeRepositoryArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "GitConfig": toGitConfig,
    },
  }, root);
}

function toCompilationJobSummary(root: jsonP.JSONValue): s.CompilationJobSummary {
  return jsonP.readObj({
    required: {
      "CompilationJobName": "s",
      "CompilationJobArn": "s",
      "CreationTime": "d",
      "CompilationJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CompilationJobStatus>(x),
    },
    optional: {
      "CompilationStartTime": "d",
      "CompilationEndTime": "d",
      "CompilationTargetDevice": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetDevice>(x),
      "CompilationTargetPlatformOs": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformOs>(x),
      "CompilationTargetPlatformArch": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformArch>(x),
      "CompilationTargetPlatformAccelerator": (x: jsonP.JSONValue) => cmnP.readEnum<s.TargetPlatformAccelerator>(x),
      "LastModifiedTime": "d",
    },
  }, root);
}

function toContextSummary(root: jsonP.JSONValue): s.ContextSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContextArn": "s",
      "ContextName": "s",
      "Source": toContextSource,
      "ContextType": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toMonitoringJobDefinitionSummary(root: jsonP.JSONValue): s.MonitoringJobDefinitionSummary {
  return jsonP.readObj({
    required: {
      "MonitoringJobDefinitionName": "s",
      "MonitoringJobDefinitionArn": "s",
      "CreationTime": "d",
      "EndpointName": "s",
    },
    optional: {},
  }, root);
}

function toDeviceFleetSummary(root: jsonP.JSONValue): s.DeviceFleetSummary {
  return jsonP.readObj({
    required: {
      "DeviceFleetArn": "s",
      "DeviceFleetName": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toDeviceSummary(root: jsonP.JSONValue): s.DeviceSummary {
  return jsonP.readObj({
    required: {
      "DeviceName": "s",
      "DeviceArn": "s",
    },
    optional: {
      "Description": "s",
      "DeviceFleetName": "s",
      "IotThingName": "s",
      "RegistrationTime": "d",
      "LatestHeartbeat": "d",
      "Models": [toEdgeModelSummary],
    },
  }, root);
}

function toEdgeModelSummary(root: jsonP.JSONValue): s.EdgeModelSummary {
  return jsonP.readObj({
    required: {
      "ModelName": "s",
      "ModelVersion": "s",
    },
    optional: {},
  }, root);
}

function toDomainDetails(root: jsonP.JSONValue): s.DomainDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainArn": "s",
      "DomainId": "s",
      "DomainName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.DomainStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "Url": "s",
    },
  }, root);
}

function toEdgePackagingJobSummary(root: jsonP.JSONValue): s.EdgePackagingJobSummary {
  return jsonP.readObj({
    required: {
      "EdgePackagingJobArn": "s",
      "EdgePackagingJobName": "s",
      "EdgePackagingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EdgePackagingJobStatus>(x),
    },
    optional: {
      "CompilationJobName": "s",
      "ModelName": "s",
      "ModelVersion": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toEndpointConfigSummary(root: jsonP.JSONValue): s.EndpointConfigSummary {
  return jsonP.readObj({
    required: {
      "EndpointConfigName": "s",
      "EndpointConfigArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

function toEndpointSummary(root: jsonP.JSONValue): s.EndpointSummary {
  return jsonP.readObj({
    required: {
      "EndpointName": "s",
      "EndpointArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointStatus>(x),
    },
    optional: {},
  }, root);
}

function toExperimentSummary(root: jsonP.JSONValue): s.ExperimentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentArn": "s",
      "ExperimentName": "s",
      "DisplayName": "s",
      "ExperimentSource": toExperimentSource,
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toFeatureGroupSummary(root: jsonP.JSONValue): s.FeatureGroupSummary {
  return jsonP.readObj({
    required: {
      "FeatureGroupName": "s",
      "FeatureGroupArn": "s",
      "CreationTime": "d",
    },
    optional: {
      "FeatureGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeatureGroupStatus>(x),
      "OfflineStoreStatus": toOfflineStoreStatus,
    },
  }, root);
}

function toFlowDefinitionSummary(root: jsonP.JSONValue): s.FlowDefinitionSummary {
  return jsonP.readObj({
    required: {
      "FlowDefinitionName": "s",
      "FlowDefinitionArn": "s",
      "FlowDefinitionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FlowDefinitionStatus>(x),
      "CreationTime": "d",
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

function toHumanTaskUiSummary(root: jsonP.JSONValue): s.HumanTaskUiSummary {
  return jsonP.readObj({
    required: {
      "HumanTaskUiName": "s",
      "HumanTaskUiArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

function toHyperParameterTuningJobSummary(root: jsonP.JSONValue): s.HyperParameterTuningJobSummary {
  return jsonP.readObj({
    required: {
      "HyperParameterTuningJobName": "s",
      "HyperParameterTuningJobArn": "s",
      "HyperParameterTuningJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobStatus>(x),
      "Strategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.HyperParameterTuningJobStrategyType>(x),
      "CreationTime": "d",
      "TrainingJobStatusCounters": toTrainingJobStatusCounters,
      "ObjectiveStatusCounters": toObjectiveStatusCounters,
    },
    optional: {
      "HyperParameterTuningEndTime": "d",
      "LastModifiedTime": "d",
      "ResourceLimits": toResourceLimits,
    },
  }, root);
}

function toImageVersion(root: jsonP.JSONValue): s.ImageVersion {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "ImageArn": "s",
      "ImageVersionArn": "s",
      "ImageVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageVersionStatus>(x),
      "LastModifiedTime": "d",
      "Version": "n",
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

function toImage(root: jsonP.JSONValue): s.Image {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "ImageArn": "s",
      "ImageName": "s",
      "ImageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageStatus>(x),
      "LastModifiedTime": "d",
    },
    optional: {
      "Description": "s",
      "DisplayName": "s",
      "FailureReason": "s",
    },
  }, root);
}

function toLabelingJobSummary(root: jsonP.JSONValue): s.LabelingJobSummary {
  return jsonP.readObj({
    required: {
      "LabelingJobName": "s",
      "LabelingJobArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "LabelingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LabelingJobStatus>(x),
      "LabelCounters": toLabelCounters,
      "WorkteamArn": "s",
      "PreHumanTaskLambdaArn": "s",
    },
    optional: {
      "AnnotationConsolidationLambdaArn": "s",
      "FailureReason": "s",
      "LabelingJobOutput": toLabelingJobOutput,
      "InputConfig": toLabelingJobInputConfig,
    },
  }, root);
}

function toLabelingJobForWorkteamSummary(root: jsonP.JSONValue): s.LabelingJobForWorkteamSummary {
  return jsonP.readObj({
    required: {
      "JobReferenceCode": "s",
      "WorkRequesterAccountId": "s",
      "CreationTime": "d",
    },
    optional: {
      "LabelingJobName": "s",
      "LabelCounters": toLabelCountersForWorkteam,
      "NumberOfHumanWorkersPerDataObject": "n",
    },
  }, root);
}

function toLabelCountersForWorkteam(root: jsonP.JSONValue): s.LabelCountersForWorkteam {
  return jsonP.readObj({
    required: {},
    optional: {
      "HumanLabeled": "n",
      "PendingHuman": "n",
      "Total": "n",
    },
  }, root);
}

function toModelPackageGroupSummary(root: jsonP.JSONValue): s.ModelPackageGroupSummary {
  return jsonP.readObj({
    required: {
      "ModelPackageGroupName": "s",
      "ModelPackageGroupArn": "s",
      "CreationTime": "d",
      "ModelPackageGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageGroupStatus>(x),
    },
    optional: {
      "ModelPackageGroupDescription": "s",
    },
  }, root);
}

function toModelPackageSummary(root: jsonP.JSONValue): s.ModelPackageSummary {
  return jsonP.readObj({
    required: {
      "ModelPackageName": "s",
      "ModelPackageArn": "s",
      "CreationTime": "d",
      "ModelPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageStatus>(x),
    },
    optional: {
      "ModelPackageGroupName": "s",
      "ModelPackageVersion": "n",
      "ModelPackageDescription": "s",
      "ModelApprovalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelApprovalStatus>(x),
    },
  }, root);
}

function toModelSummary(root: jsonP.JSONValue): s.ModelSummary {
  return jsonP.readObj({
    required: {
      "ModelName": "s",
      "ModelArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

function toMonitoringScheduleSummary(root: jsonP.JSONValue): s.MonitoringScheduleSummary {
  return jsonP.readObj({
    required: {
      "MonitoringScheduleName": "s",
      "MonitoringScheduleArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "MonitoringScheduleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleStatus>(x),
    },
    optional: {
      "EndpointName": "s",
      "MonitoringJobDefinitionName": "s",
      "MonitoringType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringType>(x),
    },
  }, root);
}

function toNotebookInstanceLifecycleConfigSummary(root: jsonP.JSONValue): s.NotebookInstanceLifecycleConfigSummary {
  return jsonP.readObj({
    required: {
      "NotebookInstanceLifecycleConfigName": "s",
      "NotebookInstanceLifecycleConfigArn": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toNotebookInstanceSummary(root: jsonP.JSONValue): s.NotebookInstanceSummary {
  return jsonP.readObj({
    required: {
      "NotebookInstanceName": "s",
      "NotebookInstanceArn": "s",
    },
    optional: {
      "NotebookInstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.NotebookInstanceStatus>(x),
      "Url": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.InstanceType>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "NotebookInstanceLifecycleConfigName": "s",
      "DefaultCodeRepository": "s",
      "AdditionalCodeRepositories": ["s"],
    },
  }, root);
}

function toPipelineExecutionStep(root: jsonP.JSONValue): s.PipelineExecutionStep {
  return jsonP.readObj({
    required: {},
    optional: {
      "StepName": "s",
      "StartTime": "d",
      "EndTime": "d",
      "StepStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.StepStatus>(x),
      "CacheHitResult": toCacheHitResult,
      "FailureReason": "s",
      "Metadata": toPipelineExecutionStepMetadata,
    },
  }, root);
}

function toCacheHitResult(root: jsonP.JSONValue): s.CacheHitResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourcePipelineExecutionArn": "s",
    },
  }, root);
}

function toPipelineExecutionStepMetadata(root: jsonP.JSONValue): s.PipelineExecutionStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrainingJob": toTrainingJobStepMetadata,
      "ProcessingJob": toProcessingJobStepMetadata,
      "TransformJob": toTransformJobStepMetadata,
      "Model": toModelStepMetadata,
      "RegisterModel": toRegisterModelStepMetadata,
      "Condition": toConditionStepMetadata,
    },
  }, root);
}

function toTrainingJobStepMetadata(root: jsonP.JSONValue): s.TrainingJobStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toProcessingJobStepMetadata(root: jsonP.JSONValue): s.ProcessingJobStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toTransformJobStepMetadata(root: jsonP.JSONValue): s.TransformJobStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toModelStepMetadata(root: jsonP.JSONValue): s.ModelStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toRegisterModelStepMetadata(root: jsonP.JSONValue): s.RegisterModelStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
    },
  }, root);
}

function toConditionStepMetadata(root: jsonP.JSONValue): s.ConditionStepMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Outcome": (x: jsonP.JSONValue) => cmnP.readEnum<s.ConditionOutcome>(x),
    },
  }, root);
}

function toPipelineExecutionSummary(root: jsonP.JSONValue): s.PipelineExecutionSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PipelineExecutionArn": "s",
      "StartTime": "d",
      "PipelineExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStatus>(x),
      "PipelineExecutionDescription": "s",
      "PipelineExecutionDisplayName": "s",
    },
  }, root);
}

function toPipelineSummary(root: jsonP.JSONValue): s.PipelineSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "PipelineArn": "s",
      "PipelineName": "s",
      "PipelineDisplayName": "s",
      "PipelineDescription": "s",
      "RoleArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "LastExecutionTime": "d",
    },
  }, root);
}

function toProcessingJobSummary(root: jsonP.JSONValue): s.ProcessingJobSummary {
  return jsonP.readObj({
    required: {
      "ProcessingJobName": "s",
      "ProcessingJobArn": "s",
      "CreationTime": "d",
      "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingJobStatus>(x),
    },
    optional: {
      "ProcessingEndTime": "d",
      "LastModifiedTime": "d",
      "FailureReason": "s",
      "ExitMessage": "s",
    },
  }, root);
}

function toProjectSummary(root: jsonP.JSONValue): s.ProjectSummary {
  return jsonP.readObj({
    required: {
      "ProjectName": "s",
      "ProjectArn": "s",
      "ProjectId": "s",
      "CreationTime": "d",
      "ProjectStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProjectStatus>(x),
    },
    optional: {
      "ProjectDescription": "s",
    },
  }, root);
}

function toTrainingJobSummary(root: jsonP.JSONValue): s.TrainingJobSummary {
  return jsonP.readObj({
    required: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "CreationTime": "d",
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingJobStatus>(x),
    },
    optional: {
      "TrainingEndTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toTransformJobSummary(root: jsonP.JSONValue): s.TransformJobSummary {
  return jsonP.readObj({
    required: {
      "TransformJobName": "s",
      "TransformJobArn": "s",
      "CreationTime": "d",
      "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformJobStatus>(x),
    },
    optional: {
      "TransformEndTime": "d",
      "LastModifiedTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

function toTrialComponentSummary(root: jsonP.JSONValue): s.TrialComponentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "TrialComponentArn": "s",
      "DisplayName": "s",
      "TrialComponentSource": toTrialComponentSource,
      "Status": toTrialComponentStatus,
      "StartTime": "d",
      "EndTime": "d",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
    },
  }, root);
}

function toTrialSummary(root: jsonP.JSONValue): s.TrialSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialArn": "s",
      "TrialName": "s",
      "DisplayName": "s",
      "TrialSource": toTrialSource,
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toUserProfileDetails(root: jsonP.JSONValue): s.UserProfileDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainId": "s",
      "UserProfileName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.UserProfileStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

function toRenderingError(root: jsonP.JSONValue): s.RenderingError {
  return jsonP.readObj({
    required: {
      "Code": "s",
      "Message": "s",
    },
    optional: {},
  }, root);
}

function toSearchRecord(root: jsonP.JSONValue): s.SearchRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrainingJob": toTrainingJob,
      "Experiment": toExperiment,
      "Trial": toTrial,
      "TrialComponent": toTrialComponent,
      "Endpoint": toEndpoint,
      "ModelPackage": toModelPackage,
      "ModelPackageGroup": toModelPackageGroup,
      "Pipeline": toPipeline,
      "PipelineExecution": toPipelineExecution,
      "FeatureGroup": toFeatureGroup,
    },
  }, root);
}

function toTrainingJob(root: jsonP.JSONValue): s.TrainingJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "TuningJobArn": "s",
      "LabelingJobArn": "s",
      "AutoMLJobArn": "s",
      "ModelArtifacts": toModelArtifacts,
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TrainingJobStatus>(x),
      "SecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.SecondaryStatus>(x),
      "FailureReason": "s",
      "HyperParameters": x => jsonP.readMap(String, String, x),
      "AlgorithmSpecification": toAlgorithmSpecification,
      "RoleArn": "s",
      "InputDataConfig": [toChannel],
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "VpcConfig": toVpcConfig,
      "StoppingCondition": toStoppingCondition,
      "CreationTime": "d",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "LastModifiedTime": "d",
      "SecondaryStatusTransitions": [toSecondaryStatusTransition],
      "FinalMetricDataList": [toMetricData],
      "EnableNetworkIsolation": "b",
      "EnableInterContainerTrafficEncryption": "b",
      "EnableManagedSpotTraining": "b",
      "CheckpointConfig": toCheckpointConfig,
      "TrainingTimeInSeconds": "n",
      "BillableTimeInSeconds": "n",
      "DebugHookConfig": toDebugHookConfig,
      "ExperimentConfig": toExperimentConfig,
      "DebugRuleConfigurations": [toDebugRuleConfiguration],
      "TensorBoardOutputConfig": toTensorBoardOutputConfig,
      "DebugRuleEvaluationStatuses": [toDebugRuleEvaluationStatus],
      "Tags": [toTag],
    },
  }, root);
}

function toExperiment(root: jsonP.JSONValue): s.Experiment {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentName": "s",
      "ExperimentArn": "s",
      "DisplayName": "s",
      "Source": toExperimentSource,
      "Description": "s",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "Tags": [toTag],
    },
  }, root);
}

function toTrial(root: jsonP.JSONValue): s.Trial {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialName": "s",
      "TrialArn": "s",
      "DisplayName": "s",
      "ExperimentName": "s",
      "Source": toTrialSource,
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "MetadataProperties": toMetadataProperties,
      "Tags": [toTag],
      "TrialComponentSummaries": [toTrialComponentSimpleSummary],
    },
  }, root);
}

function toTrialComponentSimpleSummary(root: jsonP.JSONValue): s.TrialComponentSimpleSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "TrialComponentArn": "s",
      "TrialComponentSource": toTrialComponentSource,
      "CreationTime": "d",
      "CreatedBy": toUserContext,
    },
  }, root);
}

function toTrialComponent(root: jsonP.JSONValue): s.TrialComponent {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "DisplayName": "s",
      "TrialComponentArn": "s",
      "Source": toTrialComponentSource,
      "Status": toTrialComponentStatus,
      "StartTime": "d",
      "EndTime": "d",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "Parameters": x => jsonP.readMap(String, toTrialComponentParameterValue, x),
      "InputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
      "OutputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
      "Metrics": [toTrialComponentMetricSummary],
      "MetadataProperties": toMetadataProperties,
      "SourceDetail": toTrialComponentSourceDetail,
      "Tags": [toTag],
      "Parents": [toParent],
    },
  }, root);
}

function toTrialComponentSourceDetail(root: jsonP.JSONValue): s.TrialComponentSourceDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceArn": "s",
      "TrainingJob": toTrainingJob,
      "ProcessingJob": toProcessingJob,
      "TransformJob": toTransformJob,
    },
  }, root);
}

function toProcessingJob(root: jsonP.JSONValue): s.ProcessingJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProcessingInputs": [toProcessingInput],
      "ProcessingOutputConfig": toProcessingOutputConfig,
      "ProcessingJobName": "s",
      "ProcessingResources": toProcessingResources,
      "StoppingCondition": toProcessingStoppingCondition,
      "AppSpecification": toAppSpecification,
      "Environment": x => jsonP.readMap(String, String, x),
      "NetworkConfig": toNetworkConfig,
      "RoleArn": "s",
      "ExperimentConfig": toExperimentConfig,
      "ProcessingJobArn": "s",
      "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProcessingJobStatus>(x),
      "ExitMessage": "s",
      "FailureReason": "s",
      "ProcessingEndTime": "d",
      "ProcessingStartTime": "d",
      "LastModifiedTime": "d",
      "CreationTime": "d",
      "MonitoringScheduleArn": "s",
      "AutoMLJobArn": "s",
      "TrainingJobArn": "s",
      "Tags": [toTag],
    },
  }, root);
}

function toTransformJob(root: jsonP.JSONValue): s.TransformJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformJobName": "s",
      "TransformJobArn": "s",
      "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.TransformJobStatus>(x),
      "FailureReason": "s",
      "ModelName": "s",
      "MaxConcurrentTransforms": "n",
      "ModelClientConfig": toModelClientConfig,
      "MaxPayloadInMB": "n",
      "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<s.BatchStrategy>(x),
      "Environment": x => jsonP.readMap(String, String, x),
      "TransformInput": toTransformInput,
      "TransformOutput": toTransformOutput,
      "TransformResources": toTransformResources,
      "CreationTime": "d",
      "TransformStartTime": "d",
      "TransformEndTime": "d",
      "LabelingJobArn": "s",
      "AutoMLJobArn": "s",
      "DataProcessing": toDataProcessing,
      "ExperimentConfig": toExperimentConfig,
      "Tags": [toTag],
    },
  }, root);
}

function toParent(root: jsonP.JSONValue): s.Parent {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialName": "s",
      "ExperimentName": "s",
    },
  }, root);
}

function toEndpoint(root: jsonP.JSONValue): s.Endpoint {
  return jsonP.readObj({
    required: {
      "EndpointName": "s",
      "EndpointArn": "s",
      "EndpointConfigName": "s",
      "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.EndpointStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "ProductionVariants": [toProductionVariantSummary],
      "DataCaptureConfig": toDataCaptureConfigSummary,
      "FailureReason": "s",
      "MonitoringSchedules": [toMonitoringSchedule],
      "Tags": [toTag],
    },
  }, root);
}

function toMonitoringSchedule(root: jsonP.JSONValue): s.MonitoringSchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "MonitoringScheduleArn": "s",
      "MonitoringScheduleName": "s",
      "MonitoringScheduleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScheduleStatus>(x),
      "MonitoringType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MonitoringType>(x),
      "FailureReason": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "MonitoringScheduleConfig": toMonitoringScheduleConfig,
      "EndpointName": "s",
      "LastMonitoringExecutionSummary": toMonitoringExecutionSummary,
      "Tags": [toTag],
    },
  }, root);
}

function toModelPackage(root: jsonP.JSONValue): s.ModelPackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelPackageName": "s",
      "ModelPackageGroupName": "s",
      "ModelPackageVersion": "n",
      "ModelPackageArn": "s",
      "ModelPackageDescription": "s",
      "CreationTime": "d",
      "InferenceSpecification": toInferenceSpecification,
      "SourceAlgorithmSpecification": toSourceAlgorithmSpecification,
      "ValidationSpecification": toModelPackageValidationSpecification,
      "ModelPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageStatus>(x),
      "ModelPackageStatusDetails": toModelPackageStatusDetails,
      "CertifyForMarketplace": "b",
      "ModelApprovalStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelApprovalStatus>(x),
      "CreatedBy": toUserContext,
      "MetadataProperties": toMetadataProperties,
      "ModelMetrics": toModelMetrics,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "ApprovalDescription": "s",
      "Tags": [toTag],
    },
  }, root);
}

function toModelPackageGroup(root: jsonP.JSONValue): s.ModelPackageGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "ModelPackageGroupName": "s",
      "ModelPackageGroupArn": "s",
      "ModelPackageGroupDescription": "s",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "ModelPackageGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.ModelPackageGroupStatus>(x),
      "Tags": [toTag],
    },
  }, root);
}

function toPipeline(root: jsonP.JSONValue): s.Pipeline {
  return jsonP.readObj({
    required: {},
    optional: {
      "PipelineArn": "s",
      "PipelineName": "s",
      "PipelineDisplayName": "s",
      "PipelineDescription": "s",
      "RoleArn": "s",
      "PipelineStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "LastRunTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedBy": toUserContext,
      "Tags": [toTag],
    },
  }, root);
}

function toPipelineExecution(root: jsonP.JSONValue): s.PipelineExecution {
  return jsonP.readObj({
    required: {},
    optional: {
      "PipelineArn": "s",
      "PipelineExecutionArn": "s",
      "PipelineExecutionDisplayName": "s",
      "PipelineExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.PipelineExecutionStatus>(x),
      "PipelineExecutionDescription": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedBy": toUserContext,
      "PipelineParameters": [toParameter],
    },
  }, root);
}

function toFeatureGroup(root: jsonP.JSONValue): s.FeatureGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "FeatureGroupArn": "s",
      "FeatureGroupName": "s",
      "RecordIdentifierFeatureName": "s",
      "EventTimeFeatureName": "s",
      "FeatureDefinitions": [toFeatureDefinition],
      "CreationTime": "d",
      "OnlineStoreConfig": toOnlineStoreConfig,
      "OfflineStoreConfig": toOfflineStoreConfig,
      "RoleArn": "s",
      "FeatureGroupStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.FeatureGroupStatus>(x),
      "OfflineStoreStatus": toOfflineStoreStatus,
      "FailureReason": "s",
      "Description": "s",
      "Tags": [toTag],
    },
  }, root);
}
