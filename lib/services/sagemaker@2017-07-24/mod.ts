// Autogenerated API client for: Amazon SageMaker Service

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as uuidv4 from "https://deno.land/std@0.71.0/uuid/v4.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
function generateIdemptToken() {
  return uuidv4.generate();
}

export default class SageMaker {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SageMaker.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2017-07-24",
    "endpointPrefix": "api.sagemaker",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "SageMaker",
    "serviceFullName": "Amazon SageMaker Service",
    "serviceId": "SageMaker",
    "signatureVersion": "v4",
    "signingName": "sagemaker",
    "targetPrefix": "SageMaker",
    "uid": "sagemaker-2017-07-24"
  };

  async addTags(
    {abortSignal, ...params}: RequestConfig & AddTagsInput,
  ): Promise<AddTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async associateTrialComponent(
    {abortSignal, ...params}: RequestConfig & AssociateTrialComponentRequest,
  ): Promise<AssociateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AssociateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async createAlgorithm(
    {abortSignal, ...params}: RequestConfig & CreateAlgorithmInput,
  ): Promise<CreateAlgorithmOutput> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
      AlgorithmDescription: params["AlgorithmDescription"],
      TrainingSpecification: fromTrainingSpecification(params["TrainingSpecification"]),
      InferenceSpecification: fromInferenceSpecification(params["InferenceSpecification"]),
      ValidationSpecification: fromAlgorithmValidationSpecification(params["ValidationSpecification"]),
      CertifyForMarketplace: params["CertifyForMarketplace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAlgorithm",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createApp(
    {abortSignal, ...params}: RequestConfig & CreateAppRequest,
  ): Promise<CreateAppResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ResourceSpec: fromResourceSpec(params["ResourceSpec"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppArn": "s",
      },
    }, await resp.json());
  }

  async createAppImageConfig(
    {abortSignal, ...params}: RequestConfig & CreateAppImageConfigRequest,
  ): Promise<CreateAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KernelGatewayImageConfig: fromKernelGatewayImageConfig(params["KernelGatewayImageConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
      },
    }, await resp.json());
  }

  async createAutoMLJob(
    {abortSignal, ...params}: RequestConfig & CreateAutoMLJobRequest,
  ): Promise<CreateAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
      InputDataConfig: params["InputDataConfig"]?.map(x => fromAutoMLChannel(x)),
      OutputDataConfig: fromAutoMLOutputDataConfig(params["OutputDataConfig"]),
      ProblemType: params["ProblemType"],
      AutoMLJobObjective: fromAutoMLJobObjective(params["AutoMLJobObjective"]),
      AutoMLJobConfig: fromAutoMLJobConfig(params["AutoMLJobConfig"]),
      RoleArn: params["RoleArn"],
      GenerateCandidateDefinitionsOnly: params["GenerateCandidateDefinitionsOnly"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCodeRepository(
    {abortSignal, ...params}: RequestConfig & CreateCodeRepositoryInput,
  ): Promise<CreateCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
      GitConfig: fromGitConfig(params["GitConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createCompilationJob(
    {abortSignal, ...params}: RequestConfig & CreateCompilationJobRequest,
  ): Promise<CreateCompilationJobResponse> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
      RoleArn: params["RoleArn"],
      InputConfig: fromInputConfig(params["InputConfig"]),
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
      StoppingCondition: fromStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCompilationJob",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createDomain(
    {abortSignal, ...params}: RequestConfig & CreateDomainRequest,
  ): Promise<CreateDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainName: params["DomainName"],
      AuthMode: params["AuthMode"],
      DefaultUserSettings: fromUserSettings(params["DefaultUserSettings"]),
      SubnetIds: params["SubnetIds"],
      VpcId: params["VpcId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      AppNetworkAccessType: params["AppNetworkAccessType"],
      HomeEfsFileSystemKmsKeyId: params["HomeEfsFileSystemKmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
        "Url": "s",
      },
    }, await resp.json());
  }

  async createEndpoint(
    {abortSignal, ...params}: RequestConfig & CreateEndpointInput,
  ): Promise<CreateEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      EndpointConfigName: params["EndpointConfigName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createEndpointConfig(
    {abortSignal, ...params}: RequestConfig & CreateEndpointConfigInput,
  ): Promise<CreateEndpointConfigOutput> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
      ProductionVariants: params["ProductionVariants"]?.map(x => fromProductionVariant(x)),
      DataCaptureConfig: fromDataCaptureConfig(params["DataCaptureConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      KmsKeyId: params["KmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEndpointConfig",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createExperiment(
    {abortSignal, ...params}: RequestConfig & CreateExperimentRequest,
  ): Promise<CreateExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      DisplayName: params["DisplayName"],
      Description: params["Description"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async createFlowDefinition(
    {abortSignal, ...params}: RequestConfig & CreateFlowDefinitionRequest,
  ): Promise<CreateFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
      HumanLoopRequestSource: fromHumanLoopRequestSource(params["HumanLoopRequestSource"]),
      HumanLoopActivationConfig: fromHumanLoopActivationConfig(params["HumanLoopActivationConfig"]),
      HumanLoopConfig: fromHumanLoopConfig(params["HumanLoopConfig"]),
      OutputConfig: fromFlowDefinitionOutputConfig(params["OutputConfig"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFlowDefinition",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & CreateHumanTaskUiRequest,
  ): Promise<CreateHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
      UiTemplate: fromUiTemplate(params["UiTemplate"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHumanTaskUi",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & CreateHyperParameterTuningJobRequest,
  ): Promise<CreateHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
      HyperParameterTuningJobConfig: fromHyperParameterTuningJobConfig(params["HyperParameterTuningJobConfig"]),
      TrainingJobDefinition: fromHyperParameterTrainingJobDefinition(params["TrainingJobDefinition"]),
      TrainingJobDefinitions: params["TrainingJobDefinitions"]?.map(x => fromHyperParameterTrainingJobDefinition(x)),
      WarmStartConfig: fromHyperParameterTuningJobWarmStartConfig(params["WarmStartConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createImage(
    {abortSignal, ...params}: RequestConfig & CreateImageRequest,
  ): Promise<CreateImageResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      ImageName: params["ImageName"],
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageArn": "s",
      },
    }, await resp.json());
  }

  async createImageVersion(
    {abortSignal, ...params}: RequestConfig & CreateImageVersionRequest,
  ): Promise<CreateImageVersionResponse> {
    const body: jsonP.JSONObject = {
      BaseImage: params["BaseImage"],
      ClientToken: params["ClientToken"] ?? generateIdemptToken(),
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageVersionArn": "s",
      },
    }, await resp.json());
  }

  async createLabelingJob(
    {abortSignal, ...params}: RequestConfig & CreateLabelingJobRequest,
  ): Promise<CreateLabelingJobResponse> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
      LabelAttributeName: params["LabelAttributeName"],
      InputConfig: fromLabelingJobInputConfig(params["InputConfig"]),
      OutputConfig: fromLabelingJobOutputConfig(params["OutputConfig"]),
      RoleArn: params["RoleArn"],
      LabelCategoryConfigS3Uri: params["LabelCategoryConfigS3Uri"],
      StoppingConditions: fromLabelingJobStoppingConditions(params["StoppingConditions"]),
      LabelingJobAlgorithmsConfig: fromLabelingJobAlgorithmsConfig(params["LabelingJobAlgorithmsConfig"]),
      HumanTaskConfig: fromHumanTaskConfig(params["HumanTaskConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateLabelingJob",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModel(
    {abortSignal, ...params}: RequestConfig & CreateModelInput,
  ): Promise<CreateModelOutput> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
      PrimaryContainer: fromContainerDefinition(params["PrimaryContainer"]),
      Containers: params["Containers"]?.map(x => fromContainerDefinition(x)),
      ExecutionRoleArn: params["ExecutionRoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      EnableNetworkIsolation: params["EnableNetworkIsolation"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModel",
    });
    return jsonP.readObj({
      required: {
        "ModelArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createModelPackage(
    {abortSignal, ...params}: RequestConfig & CreateModelPackageInput = {},
  ): Promise<CreateModelPackageOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
      ModelPackageDescription: params["ModelPackageDescription"],
      InferenceSpecification: fromInferenceSpecification(params["InferenceSpecification"]),
      ValidationSpecification: fromModelPackageValidationSpecification(params["ValidationSpecification"]),
      SourceAlgorithmSpecification: fromSourceAlgorithmSpecification(params["SourceAlgorithmSpecification"]),
      CertifyForMarketplace: params["CertifyForMarketplace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateModelPackage",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & CreateMonitoringScheduleRequest,
  ): Promise<CreateMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      MonitoringScheduleConfig: fromMonitoringScheduleConfig(params["MonitoringScheduleConfig"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createNotebookInstance(
    {abortSignal, ...params}: RequestConfig & CreateNotebookInstanceInput,
  ): Promise<CreateNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      InstanceType: params["InstanceType"],
      SubnetId: params["SubnetId"],
      SecurityGroupIds: params["SecurityGroupIds"],
      RoleArn: params["RoleArn"],
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      LifecycleConfigName: params["LifecycleConfigName"],
      DirectInternetAccess: params["DirectInternetAccess"],
      VolumeSizeInGB: params["VolumeSizeInGB"],
      AcceleratorTypes: params["AcceleratorTypes"],
      DefaultCodeRepository: params["DefaultCodeRepository"],
      AdditionalCodeRepositories: params["AdditionalCodeRepositories"],
      RootAccess: params["RootAccess"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceArn": "s",
      },
    }, await resp.json());
  }

  async createNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & CreateNotebookInstanceLifecycleConfigInput,
  ): Promise<CreateNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
      OnCreate: params["OnCreate"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
      OnStart: params["OnStart"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceLifecycleConfigArn": "s",
      },
    }, await resp.json());
  }

  async createPresignedDomainUrl(
    {abortSignal, ...params}: RequestConfig & CreatePresignedDomainUrlRequest,
  ): Promise<CreatePresignedDomainUrlResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      SessionExpirationDurationInSeconds: params["SessionExpirationDurationInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePresignedDomainUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizedUrl": "s",
      },
    }, await resp.json());
  }

  async createPresignedNotebookInstanceUrl(
    {abortSignal, ...params}: RequestConfig & CreatePresignedNotebookInstanceUrlInput,
  ): Promise<CreatePresignedNotebookInstanceUrlOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      SessionExpirationDurationInSeconds: params["SessionExpirationDurationInSeconds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePresignedNotebookInstanceUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AuthorizedUrl": "s",
      },
    }, await resp.json());
  }

  async createProcessingJob(
    {abortSignal, ...params}: RequestConfig & CreateProcessingJobRequest,
  ): Promise<CreateProcessingJobResponse> {
    const body: jsonP.JSONObject = {
      ProcessingInputs: params["ProcessingInputs"]?.map(x => fromProcessingInput(x)),
      ProcessingOutputConfig: fromProcessingOutputConfig(params["ProcessingOutputConfig"]),
      ProcessingJobName: params["ProcessingJobName"],
      ProcessingResources: fromProcessingResources(params["ProcessingResources"]),
      StoppingCondition: fromProcessingStoppingCondition(params["StoppingCondition"]),
      AppSpecification: fromAppSpecification(params["AppSpecification"]),
      Environment: params["Environment"],
      NetworkConfig: fromNetworkConfig(params["NetworkConfig"]),
      RoleArn: params["RoleArn"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateProcessingJob",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTrainingJob(
    {abortSignal, ...params}: RequestConfig & CreateTrainingJobRequest,
  ): Promise<CreateTrainingJobResponse> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
      HyperParameters: params["HyperParameters"],
      AlgorithmSpecification: fromAlgorithmSpecification(params["AlgorithmSpecification"]),
      RoleArn: params["RoleArn"],
      InputDataConfig: params["InputDataConfig"]?.map(x => fromChannel(x)),
      OutputDataConfig: fromOutputDataConfig(params["OutputDataConfig"]),
      ResourceConfig: fromResourceConfig(params["ResourceConfig"]),
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      StoppingCondition: fromStoppingCondition(params["StoppingCondition"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      EnableNetworkIsolation: params["EnableNetworkIsolation"],
      EnableInterContainerTrafficEncryption: params["EnableInterContainerTrafficEncryption"],
      EnableManagedSpotTraining: params["EnableManagedSpotTraining"],
      CheckpointConfig: fromCheckpointConfig(params["CheckpointConfig"]),
      DebugHookConfig: fromDebugHookConfig(params["DebugHookConfig"]),
      DebugRuleConfigurations: params["DebugRuleConfigurations"]?.map(x => fromDebugRuleConfiguration(x)),
      TensorBoardOutputConfig: fromTensorBoardOutputConfig(params["TensorBoardOutputConfig"]),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrainingJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTransformJob(
    {abortSignal, ...params}: RequestConfig & CreateTransformJobRequest,
  ): Promise<CreateTransformJobResponse> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
      ModelName: params["ModelName"],
      MaxConcurrentTransforms: params["MaxConcurrentTransforms"],
      ModelClientConfig: fromModelClientConfig(params["ModelClientConfig"]),
      MaxPayloadInMB: params["MaxPayloadInMB"],
      BatchStrategy: params["BatchStrategy"],
      Environment: params["Environment"],
      TransformInput: fromTransformInput(params["TransformInput"]),
      TransformOutput: fromTransformOutput(params["TransformOutput"]),
      TransformResources: fromTransformResources(params["TransformResources"]),
      DataProcessing: fromDataProcessing(params["DataProcessing"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
      ExperimentConfig: fromExperimentConfig(params["ExperimentConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTransformJob",
    });
    return jsonP.readObj({
      required: {
        "TransformJobArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createTrial(
    {abortSignal, ...params}: RequestConfig & CreateTrialRequest,
  ): Promise<CreateTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
      DisplayName: params["DisplayName"],
      ExperimentName: params["ExperimentName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async createTrialComponent(
    {abortSignal, ...params}: RequestConfig & CreateTrialComponentRequest,
  ): Promise<CreateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      DisplayName: params["DisplayName"],
      Status: fromTrialComponentStatus(params["Status"]),
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Parameters: jsonP.serializeMap(params["Parameters"], x => fromTrialComponentParameterValue(x)),
      InputArtifacts: jsonP.serializeMap(params["InputArtifacts"], x => fromTrialComponentArtifact(x)),
      OutputArtifacts: jsonP.serializeMap(params["OutputArtifacts"], x => fromTrialComponentArtifact(x)),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async createUserProfile(
    {abortSignal, ...params}: RequestConfig & CreateUserProfileRequest,
  ): Promise<CreateUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      SingleSignOnUserIdentifier: params["SingleSignOnUserIdentifier"],
      SingleSignOnUserValue: params["SingleSignOnUserValue"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
      UserSettings: fromUserSettings(params["UserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfileArn": "s",
      },
    }, await resp.json());
  }

  async createWorkforce(
    {abortSignal, ...params}: RequestConfig & CreateWorkforceRequest,
  ): Promise<CreateWorkforceResponse> {
    const body: jsonP.JSONObject = {
      CognitoConfig: fromCognitoConfig(params["CognitoConfig"]),
      OidcConfig: fromOidcConfig(params["OidcConfig"]),
      SourceIpConfig: fromSourceIpConfig(params["SourceIpConfig"]),
      WorkforceName: params["WorkforceName"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkforce",
    });
    return jsonP.readObj({
      required: {
        "WorkforceArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async createWorkteam(
    {abortSignal, ...params}: RequestConfig & CreateWorkteamRequest,
  ): Promise<CreateWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
      WorkforceName: params["WorkforceName"],
      MemberDefinitions: params["MemberDefinitions"]?.map(x => fromMemberDefinition(x)),
      Description: params["Description"],
      NotificationConfiguration: fromNotificationConfiguration(params["NotificationConfiguration"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateWorkteam",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "WorkteamArn": "s",
      },
    }, await resp.json());
  }

  async deleteAlgorithm(
    {abortSignal, ...params}: RequestConfig & DeleteAlgorithmInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAlgorithm",
    });
  }

  async deleteApp(
    {abortSignal, ...params}: RequestConfig & DeleteAppRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteApp",
    });
  }

  async deleteAppImageConfig(
    {abortSignal, ...params}: RequestConfig & DeleteAppImageConfigRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteAppImageConfig",
    });
  }

  async deleteCodeRepository(
    {abortSignal, ...params}: RequestConfig & DeleteCodeRepositoryInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteCodeRepository",
    });
  }

  async deleteDomain(
    {abortSignal, ...params}: RequestConfig & DeleteDomainRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      RetentionPolicy: fromRetentionPolicy(params["RetentionPolicy"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDomain",
    });
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & DeleteEndpointInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpoint",
    });
  }

  async deleteEndpointConfig(
    {abortSignal, ...params}: RequestConfig & DeleteEndpointConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteEndpointConfig",
    });
  }

  async deleteExperiment(
    {abortSignal, ...params}: RequestConfig & DeleteExperimentRequest,
  ): Promise<DeleteExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async deleteFlowDefinition(
    {abortSignal, ...params}: RequestConfig & DeleteFlowDefinitionRequest,
  ): Promise<DeleteFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteFlowDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & DeleteHumanTaskUiRequest,
  ): Promise<DeleteHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteHumanTaskUi",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImage(
    {abortSignal, ...params}: RequestConfig & DeleteImageRequest,
  ): Promise<DeleteImageResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteImageVersion(
    {abortSignal, ...params}: RequestConfig & DeleteImageVersionRequest,
  ): Promise<DeleteImageVersionResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
      Version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteModel(
    {abortSignal, ...params}: RequestConfig & DeleteModelInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModel",
    });
  }

  async deleteModelPackage(
    {abortSignal, ...params}: RequestConfig & DeleteModelPackageInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteModelPackage",
    });
  }

  async deleteMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & DeleteMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteMonitoringSchedule",
    });
  }

  async deleteNotebookInstance(
    {abortSignal, ...params}: RequestConfig & DeleteNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotebookInstance",
    });
  }

  async deleteNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & DeleteNotebookInstanceLifecycleConfigInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteNotebookInstanceLifecycleConfig",
    });
  }

  async deleteTags(
    {abortSignal, ...params}: RequestConfig & DeleteTagsInput,
  ): Promise<DeleteTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteTrial(
    {abortSignal, ...params}: RequestConfig & DeleteTrialRequest,
  ): Promise<DeleteTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async deleteTrialComponent(
    {abortSignal, ...params}: RequestConfig & DeleteTrialComponentRequest,
  ): Promise<DeleteTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async deleteUserProfile(
    {abortSignal, ...params}: RequestConfig & DeleteUserProfileRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteUserProfile",
    });
  }

  async deleteWorkforce(
    {abortSignal, ...params}: RequestConfig & DeleteWorkforceRequest,
  ): Promise<DeleteWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkforce",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deleteWorkteam(
    {abortSignal, ...params}: RequestConfig & DeleteWorkteamRequest,
  ): Promise<DeleteWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Success": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async describeAlgorithm(
    {abortSignal, ...params}: RequestConfig & DescribeAlgorithmInput,
  ): Promise<DescribeAlgorithmOutput> {
    const body: jsonP.JSONObject = {
      AlgorithmName: params["AlgorithmName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAlgorithm",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmName": "s",
        "AlgorithmArn": "s",
        "CreationTime": "d",
        "TrainingSpecification": toTrainingSpecification,
        "AlgorithmStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AlgorithmStatus>(x),
        "AlgorithmStatusDetails": toAlgorithmStatusDetails,
      },
      optional: {
        "AlgorithmDescription": "s",
        "InferenceSpecification": toInferenceSpecification,
        "ValidationSpecification": toAlgorithmValidationSpecification,
        "ProductId": "s",
        "CertifyForMarketplace": "b",
      },
    }, await resp.json());
  }

  async describeApp(
    {abortSignal, ...params}: RequestConfig & DescribeAppRequest,
  ): Promise<DescribeAppResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      AppType: params["AppType"],
      AppName: params["AppName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeApp",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppArn": "s",
        "AppType": (x: jsonP.JSONValue) => cmnP.readEnum<AppType>(x),
        "AppName": "s",
        "DomainId": "s",
        "UserProfileName": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<AppStatus>(x),
        "LastHealthCheckTimestamp": "d",
        "LastUserActivityTimestamp": "d",
        "CreationTime": "d",
        "FailureReason": "s",
        "ResourceSpec": toResourceSpec,
      },
    }, await resp.json());
  }

  async describeAppImageConfig(
    {abortSignal, ...params}: RequestConfig & DescribeAppImageConfigRequest,
  ): Promise<DescribeAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
        "AppImageConfigName": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "KernelGatewayImageConfig": toKernelGatewayImageConfig,
      },
    }, await resp.json());
  }

  async describeAutoMLJob(
    {abortSignal, ...params}: RequestConfig & DescribeAutoMLJobRequest,
  ): Promise<DescribeAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobName": "s",
        "AutoMLJobArn": "s",
        "InputDataConfig": [toAutoMLChannel],
        "OutputDataConfig": toAutoMLOutputDataConfig,
        "RoleArn": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "AutoMLJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLJobStatus>(x),
        "AutoMLJobSecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLJobSecondaryStatus>(x),
      },
      optional: {
        "AutoMLJobObjective": toAutoMLJobObjective,
        "ProblemType": (x: jsonP.JSONValue) => cmnP.readEnum<ProblemType>(x),
        "AutoMLJobConfig": toAutoMLJobConfig,
        "EndTime": "d",
        "FailureReason": "s",
        "BestCandidate": toAutoMLCandidate,
        "GenerateCandidateDefinitionsOnly": "b",
        "AutoMLJobArtifacts": toAutoMLJobArtifacts,
        "ResolvedAttributes": toResolvedAttributes,
      },
    }, await resp.json());
  }

  async describeCodeRepository(
    {abortSignal, ...params}: RequestConfig & DescribeCodeRepositoryInput,
  ): Promise<DescribeCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryName": "s",
        "CodeRepositoryArn": "s",
        "CreationTime": "d",
        "LastModifiedTime": "d",
      },
      optional: {
        "GitConfig": toGitConfig,
      },
    }, await resp.json());
  }

  async describeCompilationJob(
    {abortSignal, ...params}: RequestConfig & DescribeCompilationJobRequest,
  ): Promise<DescribeCompilationJobResponse> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeCompilationJob",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobName": "s",
        "CompilationJobArn": "s",
        "CompilationJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CompilationJobStatus>(x),
        "StoppingCondition": toStoppingCondition,
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "ModelArtifacts": toModelArtifacts,
        "RoleArn": "s",
        "InputConfig": toInputConfig,
        "OutputConfig": toOutputConfig,
      },
      optional: {
        "CompilationStartTime": "d",
        "CompilationEndTime": "d",
      },
    }, await resp.json());
  }

  async describeDomain(
    {abortSignal, ...params}: RequestConfig & DescribeDomainRequest,
  ): Promise<DescribeDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
        "DomainId": "s",
        "DomainName": "s",
        "HomeEfsFileSystemId": "s",
        "SingleSignOnManagedApplicationInstanceId": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<DomainStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "FailureReason": "s",
        "AuthMode": (x: jsonP.JSONValue) => cmnP.readEnum<AuthMode>(x),
        "DefaultUserSettings": toUserSettings,
        "AppNetworkAccessType": (x: jsonP.JSONValue) => cmnP.readEnum<AppNetworkAccessType>(x),
        "HomeEfsFileSystemKmsKeyId": "s",
        "SubnetIds": ["s"],
        "Url": "s",
        "VpcId": "s",
      },
    }, await resp.json());
  }

  async describeEndpoint(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointInput,
  ): Promise<DescribeEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointName": "s",
        "EndpointArn": "s",
        "EndpointConfigName": "s",
        "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<EndpointStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
      },
      optional: {
        "ProductionVariants": [toProductionVariantSummary],
        "DataCaptureConfig": toDataCaptureConfigSummary,
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async describeEndpointConfig(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointConfigInput,
  ): Promise<DescribeEndpointConfigOutput> {
    const body: jsonP.JSONObject = {
      EndpointConfigName: params["EndpointConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpointConfig",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigName": "s",
        "EndpointConfigArn": "s",
        "ProductionVariants": [toProductionVariant],
        "CreationTime": "d",
      },
      optional: {
        "DataCaptureConfig": toDataCaptureConfig,
        "KmsKeyId": "s",
      },
    }, await resp.json());
  }

  async describeExperiment(
    {abortSignal, ...params}: RequestConfig & DescribeExperimentRequest,
  ): Promise<DescribeExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentName": "s",
        "ExperimentArn": "s",
        "DisplayName": "s",
        "Source": toExperimentSource,
        "Description": "s",
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeFlowDefinition(
    {abortSignal, ...params}: RequestConfig & DescribeFlowDefinitionRequest,
  ): Promise<DescribeFlowDefinitionResponse> {
    const body: jsonP.JSONObject = {
      FlowDefinitionName: params["FlowDefinitionName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeFlowDefinition",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionArn": "s",
        "FlowDefinitionName": "s",
        "FlowDefinitionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<FlowDefinitionStatus>(x),
        "CreationTime": "d",
        "HumanLoopConfig": toHumanLoopConfig,
        "OutputConfig": toFlowDefinitionOutputConfig,
        "RoleArn": "s",
      },
      optional: {
        "HumanLoopRequestSource": toHumanLoopRequestSource,
        "HumanLoopActivationConfig": toHumanLoopActivationConfig,
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async describeHumanTaskUi(
    {abortSignal, ...params}: RequestConfig & DescribeHumanTaskUiRequest,
  ): Promise<DescribeHumanTaskUiResponse> {
    const body: jsonP.JSONObject = {
      HumanTaskUiName: params["HumanTaskUiName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHumanTaskUi",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiArn": "s",
        "HumanTaskUiName": "s",
        "CreationTime": "d",
        "UiTemplate": toUiTemplateInfo,
      },
      optional: {
        "HumanTaskUiStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HumanTaskUiStatus>(x),
      },
    }, await resp.json());
  }

  async describeHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & DescribeHyperParameterTuningJobRequest,
  ): Promise<DescribeHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobName": "s",
        "HyperParameterTuningJobArn": "s",
        "HyperParameterTuningJobConfig": toHyperParameterTuningJobConfig,
        "HyperParameterTuningJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobStatus>(x),
        "CreationTime": "d",
        "TrainingJobStatusCounters": toTrainingJobStatusCounters,
        "ObjectiveStatusCounters": toObjectiveStatusCounters,
      },
      optional: {
        "TrainingJobDefinition": toHyperParameterTrainingJobDefinition,
        "TrainingJobDefinitions": [toHyperParameterTrainingJobDefinition],
        "HyperParameterTuningEndTime": "d",
        "LastModifiedTime": "d",
        "BestTrainingJob": toHyperParameterTrainingJobSummary,
        "OverallBestTrainingJob": toHyperParameterTrainingJobSummary,
        "WarmStartConfig": toHyperParameterTuningJobWarmStartConfig,
        "FailureReason": "s",
      },
    }, await resp.json());
  }

  async describeImage(
    {abortSignal, ...params}: RequestConfig & DescribeImageRequest,
  ): Promise<DescribeImageResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "CreationTime": "d",
        "Description": "s",
        "DisplayName": "s",
        "FailureReason": "s",
        "ImageArn": "s",
        "ImageName": "s",
        "ImageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImageStatus>(x),
        "LastModifiedTime": "d",
        "RoleArn": "s",
      },
    }, await resp.json());
  }

  async describeImageVersion(
    {abortSignal, ...params}: RequestConfig & DescribeImageVersionRequest,
  ): Promise<DescribeImageVersionResponse> {
    const body: jsonP.JSONObject = {
      ImageName: params["ImageName"],
      Version: params["Version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeImageVersion",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "BaseImage": "s",
        "ContainerImage": "s",
        "CreationTime": "d",
        "FailureReason": "s",
        "ImageArn": "s",
        "ImageVersionArn": "s",
        "ImageVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImageVersionStatus>(x),
        "LastModifiedTime": "d",
        "Version": "n",
      },
    }, await resp.json());
  }

  async describeLabelingJob(
    {abortSignal, ...params}: RequestConfig & DescribeLabelingJobRequest,
  ): Promise<DescribeLabelingJobResponse> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeLabelingJob",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LabelingJobStatus>(x),
        "LabelCounters": toLabelCounters,
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "JobReferenceCode": "s",
        "LabelingJobName": "s",
        "LabelingJobArn": "s",
        "InputConfig": toLabelingJobInputConfig,
        "OutputConfig": toLabelingJobOutputConfig,
        "RoleArn": "s",
        "HumanTaskConfig": toHumanTaskConfig,
      },
      optional: {
        "FailureReason": "s",
        "LabelAttributeName": "s",
        "LabelCategoryConfigS3Uri": "s",
        "StoppingConditions": toLabelingJobStoppingConditions,
        "LabelingJobAlgorithmsConfig": toLabelingJobAlgorithmsConfig,
        "Tags": [toTag],
        "LabelingJobOutput": toLabelingJobOutput,
      },
    }, await resp.json());
  }

  async describeModel(
    {abortSignal, ...params}: RequestConfig & DescribeModelInput,
  ): Promise<DescribeModelOutput> {
    const body: jsonP.JSONObject = {
      ModelName: params["ModelName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModel",
    });
    return jsonP.readObj({
      required: {
        "ModelName": "s",
        "ExecutionRoleArn": "s",
        "CreationTime": "d",
        "ModelArn": "s",
      },
      optional: {
        "PrimaryContainer": toContainerDefinition,
        "Containers": [toContainerDefinition],
        "VpcConfig": toVpcConfig,
        "EnableNetworkIsolation": "b",
      },
    }, await resp.json());
  }

  async describeModelPackage(
    {abortSignal, ...params}: RequestConfig & DescribeModelPackageInput,
  ): Promise<DescribeModelPackageOutput> {
    const body: jsonP.JSONObject = {
      ModelPackageName: params["ModelPackageName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeModelPackage",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageName": "s",
        "ModelPackageArn": "s",
        "CreationTime": "d",
        "ModelPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ModelPackageStatus>(x),
        "ModelPackageStatusDetails": toModelPackageStatusDetails,
      },
      optional: {
        "ModelPackageDescription": "s",
        "InferenceSpecification": toInferenceSpecification,
        "SourceAlgorithmSpecification": toSourceAlgorithmSpecification,
        "ValidationSpecification": toModelPackageValidationSpecification,
        "CertifyForMarketplace": "b",
      },
    }, await resp.json());
  }

  async describeMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & DescribeMonitoringScheduleRequest,
  ): Promise<DescribeMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
        "MonitoringScheduleName": "s",
        "MonitoringScheduleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ScheduleStatus>(x),
        "CreationTime": "d",
        "LastModifiedTime": "d",
        "MonitoringScheduleConfig": toMonitoringScheduleConfig,
      },
      optional: {
        "FailureReason": "s",
        "EndpointName": "s",
        "LastMonitoringExecutionSummary": toMonitoringExecutionSummary,
      },
    }, await resp.json());
  }

  async describeNotebookInstance(
    {abortSignal, ...params}: RequestConfig & DescribeNotebookInstanceInput,
  ): Promise<DescribeNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceArn": "s",
        "NotebookInstanceName": "s",
        "NotebookInstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<NotebookInstanceStatus>(x),
        "FailureReason": "s",
        "Url": "s",
        "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceType>(x),
        "SubnetId": "s",
        "SecurityGroups": ["s"],
        "RoleArn": "s",
        "KmsKeyId": "s",
        "NetworkInterfaceId": "s",
        "LastModifiedTime": "d",
        "CreationTime": "d",
        "NotebookInstanceLifecycleConfigName": "s",
        "DirectInternetAccess": (x: jsonP.JSONValue) => cmnP.readEnum<DirectInternetAccess>(x),
        "VolumeSizeInGB": "n",
        "AcceleratorTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<NotebookInstanceAcceleratorType>(x)],
        "DefaultCodeRepository": "s",
        "AdditionalCodeRepositories": ["s"],
        "RootAccess": (x: jsonP.JSONValue) => cmnP.readEnum<RootAccess>(x),
      },
    }, await resp.json());
  }

  async describeNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & DescribeNotebookInstanceLifecycleConfigInput,
  ): Promise<DescribeNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NotebookInstanceLifecycleConfigArn": "s",
        "NotebookInstanceLifecycleConfigName": "s",
        "OnCreate": [toNotebookInstanceLifecycleHook],
        "OnStart": [toNotebookInstanceLifecycleHook],
        "LastModifiedTime": "d",
        "CreationTime": "d",
      },
    }, await resp.json());
  }

  async describeProcessingJob(
    {abortSignal, ...params}: RequestConfig & DescribeProcessingJobRequest,
  ): Promise<DescribeProcessingJobResponse> {
    const body: jsonP.JSONObject = {
      ProcessingJobName: params["ProcessingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeProcessingJob",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobName": "s",
        "ProcessingResources": toProcessingResources,
        "AppSpecification": toAppSpecification,
        "ProcessingJobArn": "s",
        "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingJobStatus>(x),
        "CreationTime": "d",
      },
      optional: {
        "ProcessingInputs": [toProcessingInput],
        "ProcessingOutputConfig": toProcessingOutputConfig,
        "StoppingCondition": toProcessingStoppingCondition,
        "Environment": x => jsonP.readMap(String, String, x),
        "NetworkConfig": toNetworkConfig,
        "RoleArn": "s",
        "ExperimentConfig": toExperimentConfig,
        "ExitMessage": "s",
        "FailureReason": "s",
        "ProcessingEndTime": "d",
        "ProcessingStartTime": "d",
        "LastModifiedTime": "d",
        "MonitoringScheduleArn": "s",
        "AutoMLJobArn": "s",
        "TrainingJobArn": "s",
      },
    }, await resp.json());
  }

  async describeSubscribedWorkteam(
    {abortSignal, ...params}: RequestConfig & DescribeSubscribedWorkteamRequest,
  ): Promise<DescribeSubscribedWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamArn: params["WorkteamArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeSubscribedWorkteam",
    });
    return jsonP.readObj({
      required: {
        "SubscribedWorkteam": toSubscribedWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  async describeTrainingJob(
    {abortSignal, ...params}: RequestConfig & DescribeTrainingJobRequest,
  ): Promise<DescribeTrainingJobResponse> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrainingJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobName": "s",
        "TrainingJobArn": "s",
        "ModelArtifacts": toModelArtifacts,
        "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingJobStatus>(x),
        "SecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SecondaryStatus>(x),
        "AlgorithmSpecification": toAlgorithmSpecification,
        "ResourceConfig": toResourceConfig,
        "StoppingCondition": toStoppingCondition,
        "CreationTime": "d",
      },
      optional: {
        "TuningJobArn": "s",
        "LabelingJobArn": "s",
        "AutoMLJobArn": "s",
        "FailureReason": "s",
        "HyperParameters": x => jsonP.readMap(String, String, x),
        "RoleArn": "s",
        "InputDataConfig": [toChannel],
        "OutputDataConfig": toOutputDataConfig,
        "VpcConfig": toVpcConfig,
        "TrainingStartTime": "d",
        "TrainingEndTime": "d",
        "LastModifiedTime": "d",
        "SecondaryStatusTransitions": [toSecondaryStatusTransition],
        "FinalMetricDataList": [toMetricData],
        "EnableNetworkIsolation": "b",
        "EnableInterContainerTrafficEncryption": "b",
        "EnableManagedSpotTraining": "b",
        "CheckpointConfig": toCheckpointConfig,
        "TrainingTimeInSeconds": "n",
        "BillableTimeInSeconds": "n",
        "DebugHookConfig": toDebugHookConfig,
        "ExperimentConfig": toExperimentConfig,
        "DebugRuleConfigurations": [toDebugRuleConfiguration],
        "TensorBoardOutputConfig": toTensorBoardOutputConfig,
        "DebugRuleEvaluationStatuses": [toDebugRuleEvaluationStatus],
      },
    }, await resp.json());
  }

  async describeTransformJob(
    {abortSignal, ...params}: RequestConfig & DescribeTransformJobRequest,
  ): Promise<DescribeTransformJobResponse> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTransformJob",
    });
    return jsonP.readObj({
      required: {
        "TransformJobName": "s",
        "TransformJobArn": "s",
        "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TransformJobStatus>(x),
        "ModelName": "s",
        "TransformInput": toTransformInput,
        "TransformResources": toTransformResources,
        "CreationTime": "d",
      },
      optional: {
        "FailureReason": "s",
        "MaxConcurrentTransforms": "n",
        "ModelClientConfig": toModelClientConfig,
        "MaxPayloadInMB": "n",
        "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<BatchStrategy>(x),
        "Environment": x => jsonP.readMap(String, String, x),
        "TransformOutput": toTransformOutput,
        "TransformStartTime": "d",
        "TransformEndTime": "d",
        "LabelingJobArn": "s",
        "AutoMLJobArn": "s",
        "DataProcessing": toDataProcessing,
        "ExperimentConfig": toExperimentConfig,
      },
    }, await resp.json());
  }

  async describeTrial(
    {abortSignal, ...params}: RequestConfig & DescribeTrialRequest,
  ): Promise<DescribeTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialName": "s",
        "TrialArn": "s",
        "DisplayName": "s",
        "ExperimentName": "s",
        "Source": toTrialSource,
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
      },
    }, await resp.json());
  }

  async describeTrialComponent(
    {abortSignal, ...params}: RequestConfig & DescribeTrialComponentRequest,
  ): Promise<DescribeTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentName": "s",
        "TrialComponentArn": "s",
        "DisplayName": "s",
        "Source": toTrialComponentSource,
        "Status": toTrialComponentStatus,
        "StartTime": "d",
        "EndTime": "d",
        "CreationTime": "d",
        "CreatedBy": toUserContext,
        "LastModifiedTime": "d",
        "LastModifiedBy": toUserContext,
        "Parameters": x => jsonP.readMap(String, toTrialComponentParameterValue, x),
        "InputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
        "OutputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
        "Metrics": [toTrialComponentMetricSummary],
      },
    }, await resp.json());
  }

  async describeUserProfile(
    {abortSignal, ...params}: RequestConfig & DescribeUserProfileRequest,
  ): Promise<DescribeUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainId": "s",
        "UserProfileArn": "s",
        "UserProfileName": "s",
        "HomeEfsFileSystemUid": "s",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<UserProfileStatus>(x),
        "LastModifiedTime": "d",
        "CreationTime": "d",
        "FailureReason": "s",
        "SingleSignOnUserIdentifier": "s",
        "SingleSignOnUserValue": "s",
        "UserSettings": toUserSettings,
      },
    }, await resp.json());
  }

  async describeWorkforce(
    {abortSignal, ...params}: RequestConfig & DescribeWorkforceRequest,
  ): Promise<DescribeWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkforce",
    });
    return jsonP.readObj({
      required: {
        "Workforce": toWorkforce,
      },
      optional: {},
    }, await resp.json());
  }

  async describeWorkteam(
    {abortSignal, ...params}: RequestConfig & DescribeWorkteamRequest,
  ): Promise<DescribeWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Workteam": toWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  async disassociateTrialComponent(
    {abortSignal, ...params}: RequestConfig & DisassociateTrialComponentRequest,
  ): Promise<DisassociateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      TrialName: params["TrialName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DisassociateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async getSearchSuggestions(
    {abortSignal, ...params}: RequestConfig & GetSearchSuggestionsRequest,
  ): Promise<GetSearchSuggestionsResponse> {
    const body: jsonP.JSONObject = {
      Resource: params["Resource"],
      SuggestionQuery: fromSuggestionQuery(params["SuggestionQuery"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetSearchSuggestions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "PropertyNameSuggestions": [toPropertyNameSuggestion],
      },
    }, await resp.json());
  }

  async listAlgorithms(
    {abortSignal, ...params}: RequestConfig & ListAlgorithmsInput = {},
  ): Promise<ListAlgorithmsOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAlgorithms",
    });
    return jsonP.readObj({
      required: {
        "AlgorithmSummaryList": [toAlgorithmSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAppImageConfigs(
    {abortSignal, ...params}: RequestConfig & ListAppImageConfigsRequest = {},
  ): Promise<ListAppImageConfigsResponse> {
    const body: jsonP.JSONObject = {
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      ModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["ModifiedTimeBefore"]),
      ModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["ModifiedTimeAfter"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAppImageConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "AppImageConfigs": [toAppImageConfigDetails],
      },
    }, await resp.json());
  }

  async listApps(
    {abortSignal, ...params}: RequestConfig & ListAppsRequest = {},
  ): Promise<ListAppsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      DomainIdEquals: params["DomainIdEquals"],
      UserProfileNameEquals: params["UserProfileNameEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListApps",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Apps": [toAppDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listAutoMLJobs(
    {abortSignal, ...params}: RequestConfig & ListAutoMLJobsRequest = {},
  ): Promise<ListAutoMLJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListAutoMLJobs",
    });
    return jsonP.readObj({
      required: {
        "AutoMLJobSummaries": [toAutoMLJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCandidatesForAutoMLJob(
    {abortSignal, ...params}: RequestConfig & ListCandidatesForAutoMLJobRequest,
  ): Promise<ListCandidatesForAutoMLJobResponse> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
      StatusEquals: params["StatusEquals"],
      CandidateNameEquals: params["CandidateNameEquals"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCandidatesForAutoMLJob",
    });
    return jsonP.readObj({
      required: {
        "Candidates": [toAutoMLCandidate],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCodeRepositories(
    {abortSignal, ...params}: RequestConfig & ListCodeRepositoriesInput = {},
  ): Promise<ListCodeRepositoriesOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCodeRepositories",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositorySummaryList": [toCodeRepositorySummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listCompilationJobs(
    {abortSignal, ...params}: RequestConfig & ListCompilationJobsRequest = {},
  ): Promise<ListCompilationJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListCompilationJobs",
    });
    return jsonP.readObj({
      required: {
        "CompilationJobSummaries": [toCompilationJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listDomains(
    {abortSignal, ...params}: RequestConfig & ListDomainsRequest = {},
  ): Promise<ListDomainsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDomains",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Domains": [toDomainDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEndpointConfigs(
    {abortSignal, ...params}: RequestConfig & ListEndpointConfigsInput = {},
  ): Promise<ListEndpointConfigsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEndpointConfigs",
    });
    return jsonP.readObj({
      required: {
        "EndpointConfigs": [toEndpointConfigSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listEndpoints(
    {abortSignal, ...params}: RequestConfig & ListEndpointsInput = {},
  ): Promise<ListEndpointsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpointSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listExperiments(
    {abortSignal, ...params}: RequestConfig & ListExperimentsRequest = {},
  ): Promise<ListExperimentsResponse> {
    const body: jsonP.JSONObject = {
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListExperiments",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentSummaries": [toExperimentSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listFlowDefinitions(
    {abortSignal, ...params}: RequestConfig & ListFlowDefinitionsRequest = {},
  ): Promise<ListFlowDefinitionsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListFlowDefinitions",
    });
    return jsonP.readObj({
      required: {
        "FlowDefinitionSummaries": [toFlowDefinitionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHumanTaskUis(
    {abortSignal, ...params}: RequestConfig & ListHumanTaskUisRequest = {},
  ): Promise<ListHumanTaskUisResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHumanTaskUis",
    });
    return jsonP.readObj({
      required: {
        "HumanTaskUiSummaries": [toHumanTaskUiSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listHyperParameterTuningJobs(
    {abortSignal, ...params}: RequestConfig & ListHyperParameterTuningJobsRequest = {},
  ): Promise<ListHyperParameterTuningJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListHyperParameterTuningJobs",
    });
    return jsonP.readObj({
      required: {
        "HyperParameterTuningJobSummaries": [toHyperParameterTuningJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listImageVersions(
    {abortSignal, ...params}: RequestConfig & ListImageVersionsRequest,
  ): Promise<ListImageVersionsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      ImageName: params["ImageName"],
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImageVersions",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageVersions": [toImageVersion],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listImages(
    {abortSignal, ...params}: RequestConfig & ListImagesRequest = {},
  ): Promise<ListImagesResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Images": [toImage],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLabelingJobs(
    {abortSignal, ...params}: RequestConfig & ListLabelingJobsRequest = {},
  ): Promise<ListLabelingJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      NameContains: params["NameContains"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLabelingJobs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LabelingJobSummaryList": [toLabelingJobSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listLabelingJobsForWorkteam(
    {abortSignal, ...params}: RequestConfig & ListLabelingJobsForWorkteamRequest,
  ): Promise<ListLabelingJobsForWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamArn: params["WorkteamArn"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      JobReferenceCodeContains: params["JobReferenceCodeContains"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListLabelingJobsForWorkteam",
    });
    return jsonP.readObj({
      required: {
        "LabelingJobSummaryList": [toLabelingJobForWorkteamSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModelPackages(
    {abortSignal, ...params}: RequestConfig & ListModelPackagesInput = {},
  ): Promise<ListModelPackagesOutput> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModelPackages",
    });
    return jsonP.readObj({
      required: {
        "ModelPackageSummaryList": [toModelPackageSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listModels(
    {abortSignal, ...params}: RequestConfig & ListModelsInput = {},
  ): Promise<ListModelsOutput> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListModels",
    });
    return jsonP.readObj({
      required: {
        "Models": [toModelSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMonitoringExecutions(
    {abortSignal, ...params}: RequestConfig & ListMonitoringExecutionsRequest = {},
  ): Promise<ListMonitoringExecutionsResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      ScheduledTimeBefore: jsonP.serializeDate_unixTimestamp(params["ScheduledTimeBefore"]),
      ScheduledTimeAfter: jsonP.serializeDate_unixTimestamp(params["ScheduledTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMonitoringExecutions",
    });
    return jsonP.readObj({
      required: {
        "MonitoringExecutionSummaries": [toMonitoringExecutionSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMonitoringSchedules(
    {abortSignal, ...params}: RequestConfig & ListMonitoringSchedulesRequest = {},
  ): Promise<ListMonitoringSchedulesResponse> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListMonitoringSchedules",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleSummaries": [toMonitoringScheduleSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listNotebookInstanceLifecycleConfigs(
    {abortSignal, ...params}: RequestConfig & ListNotebookInstanceLifecycleConfigsInput = {},
  ): Promise<ListNotebookInstanceLifecycleConfigsOutput> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookInstanceLifecycleConfigs",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NotebookInstanceLifecycleConfigs": [toNotebookInstanceLifecycleConfigSummary],
      },
    }, await resp.json());
  }

  async listNotebookInstances(
    {abortSignal, ...params}: RequestConfig & ListNotebookInstancesInput = {},
  ): Promise<ListNotebookInstancesOutput> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      StatusEquals: params["StatusEquals"],
      NotebookInstanceLifecycleConfigNameContains: params["NotebookInstanceLifecycleConfigNameContains"],
      DefaultCodeRepositoryContains: params["DefaultCodeRepositoryContains"],
      AdditionalCodeRepositoryEquals: params["AdditionalCodeRepositoryEquals"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListNotebookInstances",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextToken": "s",
        "NotebookInstances": [toNotebookInstanceSummary],
      },
    }, await resp.json());
  }

  async listProcessingJobs(
    {abortSignal, ...params}: RequestConfig & ListProcessingJobsRequest = {},
  ): Promise<ListProcessingJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListProcessingJobs",
    });
    return jsonP.readObj({
      required: {
        "ProcessingJobSummaries": [toProcessingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listSubscribedWorkteams(
    {abortSignal, ...params}: RequestConfig & ListSubscribedWorkteamsRequest = {},
  ): Promise<ListSubscribedWorkteamsResponse> {
    const body: jsonP.JSONObject = {
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListSubscribedWorkteams",
    });
    return jsonP.readObj({
      required: {
        "SubscribedWorkteams": [toSubscribedWorkteam],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTags(
    {abortSignal, ...params}: RequestConfig & ListTagsInput,
  ): Promise<ListTagsOutput> {
    const body: jsonP.JSONObject = {
      ResourceArn: params["ResourceArn"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrainingJobs(
    {abortSignal, ...params}: RequestConfig & ListTrainingJobsRequest = {},
  ): Promise<ListTrainingJobsResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrainingJobs",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobSummaries": [toTrainingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrainingJobsForHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & ListTrainingJobsForHyperParameterTuningJobRequest,
  ): Promise<ListTrainingJobsForHyperParameterTuningJobResponse> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrainingJobsForHyperParameterTuningJob",
    });
    return jsonP.readObj({
      required: {
        "TrainingJobSummaries": [toHyperParameterTrainingJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTransformJobs(
    {abortSignal, ...params}: RequestConfig & ListTransformJobsRequest = {},
  ): Promise<ListTransformJobsResponse> {
    const body: jsonP.JSONObject = {
      CreationTimeAfter: jsonP.serializeDate_unixTimestamp(params["CreationTimeAfter"]),
      CreationTimeBefore: jsonP.serializeDate_unixTimestamp(params["CreationTimeBefore"]),
      LastModifiedTimeAfter: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeAfter"]),
      LastModifiedTimeBefore: jsonP.serializeDate_unixTimestamp(params["LastModifiedTimeBefore"]),
      NameContains: params["NameContains"],
      StatusEquals: params["StatusEquals"],
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTransformJobs",
    });
    return jsonP.readObj({
      required: {
        "TransformJobSummaries": [toTransformJobSummary],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrialComponents(
    {abortSignal, ...params}: RequestConfig & ListTrialComponentsRequest = {},
  ): Promise<ListTrialComponentsResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      TrialName: params["TrialName"],
      SourceArn: params["SourceArn"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrialComponents",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentSummaries": [toTrialComponentSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTrials(
    {abortSignal, ...params}: RequestConfig & ListTrialsRequest = {},
  ): Promise<ListTrialsResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      TrialComponentName: params["TrialComponentName"],
      CreatedAfter: jsonP.serializeDate_unixTimestamp(params["CreatedAfter"]),
      CreatedBefore: jsonP.serializeDate_unixTimestamp(params["CreatedBefore"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTrials",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialSummaries": [toTrialSummary],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listUserProfiles(
    {abortSignal, ...params}: RequestConfig & ListUserProfilesRequest = {},
  ): Promise<ListUserProfilesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
      SortOrder: params["SortOrder"],
      SortBy: params["SortBy"],
      DomainIdEquals: params["DomainIdEquals"],
      UserProfileNameContains: params["UserProfileNameContains"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListUserProfiles",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfiles": [toUserProfileDetails],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkforces(
    {abortSignal, ...params}: RequestConfig & ListWorkforcesRequest = {},
  ): Promise<ListWorkforcesResponse> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkforces",
    });
    return jsonP.readObj({
      required: {
        "Workforces": [toWorkforce],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listWorkteams(
    {abortSignal, ...params}: RequestConfig & ListWorkteamsRequest = {},
  ): Promise<ListWorkteamsResponse> {
    const body: jsonP.JSONObject = {
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NameContains: params["NameContains"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListWorkteams",
    });
    return jsonP.readObj({
      required: {
        "Workteams": [toWorkteam],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async renderUiTemplate(
    {abortSignal, ...params}: RequestConfig & RenderUiTemplateRequest,
  ): Promise<RenderUiTemplateResponse> {
    const body: jsonP.JSONObject = {
      UiTemplate: fromUiTemplate(params["UiTemplate"]),
      Task: fromRenderableTask(params["Task"]),
      RoleArn: params["RoleArn"],
      HumanTaskUiArn: params["HumanTaskUiArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RenderUiTemplate",
    });
    return jsonP.readObj({
      required: {
        "RenderedContent": "s",
        "Errors": [toRenderingError],
      },
      optional: {},
    }, await resp.json());
  }

  async search(
    {abortSignal, ...params}: RequestConfig & SearchRequest,
  ): Promise<SearchResponse> {
    const body: jsonP.JSONObject = {
      Resource: params["Resource"],
      SearchExpression: fromSearchExpression(params["SearchExpression"]),
      SortBy: params["SortBy"],
      SortOrder: params["SortOrder"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "Search",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toSearchRecord],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async startMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & StartMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartMonitoringSchedule",
    });
  }

  async startNotebookInstance(
    {abortSignal, ...params}: RequestConfig & StartNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartNotebookInstance",
    });
  }

  async stopAutoMLJob(
    {abortSignal, ...params}: RequestConfig & StopAutoMLJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      AutoMLJobName: params["AutoMLJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopAutoMLJob",
    });
  }

  async stopCompilationJob(
    {abortSignal, ...params}: RequestConfig & StopCompilationJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      CompilationJobName: params["CompilationJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopCompilationJob",
    });
  }

  async stopHyperParameterTuningJob(
    {abortSignal, ...params}: RequestConfig & StopHyperParameterTuningJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      HyperParameterTuningJobName: params["HyperParameterTuningJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopHyperParameterTuningJob",
    });
  }

  async stopLabelingJob(
    {abortSignal, ...params}: RequestConfig & StopLabelingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      LabelingJobName: params["LabelingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopLabelingJob",
    });
  }

  async stopMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & StopMonitoringScheduleRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopMonitoringSchedule",
    });
  }

  async stopNotebookInstance(
    {abortSignal, ...params}: RequestConfig & StopNotebookInstanceInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopNotebookInstance",
    });
  }

  async stopProcessingJob(
    {abortSignal, ...params}: RequestConfig & StopProcessingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      ProcessingJobName: params["ProcessingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopProcessingJob",
    });
  }

  async stopTrainingJob(
    {abortSignal, ...params}: RequestConfig & StopTrainingJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      TrainingJobName: params["TrainingJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTrainingJob",
    });
  }

  async stopTransformJob(
    {abortSignal, ...params}: RequestConfig & StopTransformJobRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      TransformJobName: params["TransformJobName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StopTransformJob",
    });
  }

  async updateAppImageConfig(
    {abortSignal, ...params}: RequestConfig & UpdateAppImageConfigRequest,
  ): Promise<UpdateAppImageConfigResponse> {
    const body: jsonP.JSONObject = {
      AppImageConfigName: params["AppImageConfigName"],
      KernelGatewayImageConfig: fromKernelGatewayImageConfig(params["KernelGatewayImageConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAppImageConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AppImageConfigArn": "s",
      },
    }, await resp.json());
  }

  async updateCodeRepository(
    {abortSignal, ...params}: RequestConfig & UpdateCodeRepositoryInput,
  ): Promise<UpdateCodeRepositoryOutput> {
    const body: jsonP.JSONObject = {
      CodeRepositoryName: params["CodeRepositoryName"],
      GitConfig: fromGitConfigForUpdate(params["GitConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCodeRepository",
    });
    return jsonP.readObj({
      required: {
        "CodeRepositoryArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateDomain(
    {abortSignal, ...params}: RequestConfig & UpdateDomainRequest,
  ): Promise<UpdateDomainResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      DefaultUserSettings: fromUserSettings(params["DefaultUserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDomain",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DomainArn": "s",
      },
    }, await resp.json());
  }

  async updateEndpoint(
    {abortSignal, ...params}: RequestConfig & UpdateEndpointInput,
  ): Promise<UpdateEndpointOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      EndpointConfigName: params["EndpointConfigName"],
      RetainAllVariantProperties: params["RetainAllVariantProperties"],
      ExcludeRetainedVariantProperties: params["ExcludeRetainedVariantProperties"]?.map(x => fromVariantProperty(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpoint",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateEndpointWeightsAndCapacities(
    {abortSignal, ...params}: RequestConfig & UpdateEndpointWeightsAndCapacitiesInput,
  ): Promise<UpdateEndpointWeightsAndCapacitiesOutput> {
    const body: jsonP.JSONObject = {
      EndpointName: params["EndpointName"],
      DesiredWeightsAndCapacities: params["DesiredWeightsAndCapacities"]?.map(x => fromDesiredWeightAndCapacity(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpointWeightsAndCapacities",
    });
    return jsonP.readObj({
      required: {
        "EndpointArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateExperiment(
    {abortSignal, ...params}: RequestConfig & UpdateExperimentRequest,
  ): Promise<UpdateExperimentResponse> {
    const body: jsonP.JSONObject = {
      ExperimentName: params["ExperimentName"],
      DisplayName: params["DisplayName"],
      Description: params["Description"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateExperiment",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ExperimentArn": "s",
      },
    }, await resp.json());
  }

  async updateImage(
    {abortSignal, ...params}: RequestConfig & UpdateImageRequest,
  ): Promise<UpdateImageResponse> {
    const body: jsonP.JSONObject = {
      DeleteProperties: params["DeleteProperties"],
      Description: params["Description"],
      DisplayName: params["DisplayName"],
      ImageName: params["ImageName"],
      RoleArn: params["RoleArn"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ImageArn": "s",
      },
    }, await resp.json());
  }

  async updateMonitoringSchedule(
    {abortSignal, ...params}: RequestConfig & UpdateMonitoringScheduleRequest,
  ): Promise<UpdateMonitoringScheduleResponse> {
    const body: jsonP.JSONObject = {
      MonitoringScheduleName: params["MonitoringScheduleName"],
      MonitoringScheduleConfig: fromMonitoringScheduleConfig(params["MonitoringScheduleConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateMonitoringSchedule",
    });
    return jsonP.readObj({
      required: {
        "MonitoringScheduleArn": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async updateNotebookInstance(
    {abortSignal, ...params}: RequestConfig & UpdateNotebookInstanceInput,
  ): Promise<UpdateNotebookInstanceOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceName: params["NotebookInstanceName"],
      InstanceType: params["InstanceType"],
      RoleArn: params["RoleArn"],
      LifecycleConfigName: params["LifecycleConfigName"],
      DisassociateLifecycleConfig: params["DisassociateLifecycleConfig"],
      VolumeSizeInGB: params["VolumeSizeInGB"],
      DefaultCodeRepository: params["DefaultCodeRepository"],
      AdditionalCodeRepositories: params["AdditionalCodeRepositories"],
      AcceleratorTypes: params["AcceleratorTypes"],
      DisassociateAcceleratorTypes: params["DisassociateAcceleratorTypes"],
      DisassociateDefaultCodeRepository: params["DisassociateDefaultCodeRepository"],
      DisassociateAdditionalCodeRepositories: params["DisassociateAdditionalCodeRepositories"],
      RootAccess: params["RootAccess"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotebookInstance",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateNotebookInstanceLifecycleConfig(
    {abortSignal, ...params}: RequestConfig & UpdateNotebookInstanceLifecycleConfigInput,
  ): Promise<UpdateNotebookInstanceLifecycleConfigOutput> {
    const body: jsonP.JSONObject = {
      NotebookInstanceLifecycleConfigName: params["NotebookInstanceLifecycleConfigName"],
      OnCreate: params["OnCreate"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
      OnStart: params["OnStart"]?.map(x => fromNotebookInstanceLifecycleHook(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateNotebookInstanceLifecycleConfig",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateTrial(
    {abortSignal, ...params}: RequestConfig & UpdateTrialRequest,
  ): Promise<UpdateTrialResponse> {
    const body: jsonP.JSONObject = {
      TrialName: params["TrialName"],
      DisplayName: params["DisplayName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrial",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialArn": "s",
      },
    }, await resp.json());
  }

  async updateTrialComponent(
    {abortSignal, ...params}: RequestConfig & UpdateTrialComponentRequest,
  ): Promise<UpdateTrialComponentResponse> {
    const body: jsonP.JSONObject = {
      TrialComponentName: params["TrialComponentName"],
      DisplayName: params["DisplayName"],
      Status: fromTrialComponentStatus(params["Status"]),
      StartTime: jsonP.serializeDate_unixTimestamp(params["StartTime"]),
      EndTime: jsonP.serializeDate_unixTimestamp(params["EndTime"]),
      Parameters: jsonP.serializeMap(params["Parameters"], x => fromTrialComponentParameterValue(x)),
      ParametersToRemove: params["ParametersToRemove"],
      InputArtifacts: jsonP.serializeMap(params["InputArtifacts"], x => fromTrialComponentArtifact(x)),
      InputArtifactsToRemove: params["InputArtifactsToRemove"],
      OutputArtifacts: jsonP.serializeMap(params["OutputArtifacts"], x => fromTrialComponentArtifact(x)),
      OutputArtifactsToRemove: params["OutputArtifactsToRemove"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTrialComponent",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TrialComponentArn": "s",
      },
    }, await resp.json());
  }

  async updateUserProfile(
    {abortSignal, ...params}: RequestConfig & UpdateUserProfileRequest,
  ): Promise<UpdateUserProfileResponse> {
    const body: jsonP.JSONObject = {
      DomainId: params["DomainId"],
      UserProfileName: params["UserProfileName"],
      UserSettings: fromUserSettings(params["UserSettings"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateUserProfile",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UserProfileArn": "s",
      },
    }, await resp.json());
  }

  async updateWorkforce(
    {abortSignal, ...params}: RequestConfig & UpdateWorkforceRequest,
  ): Promise<UpdateWorkforceResponse> {
    const body: jsonP.JSONObject = {
      WorkforceName: params["WorkforceName"],
      SourceIpConfig: fromSourceIpConfig(params["SourceIpConfig"]),
      OidcConfig: fromOidcConfig(params["OidcConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkforce",
    });
    return jsonP.readObj({
      required: {
        "Workforce": toWorkforce,
      },
      optional: {},
    }, await resp.json());
  }

  async updateWorkteam(
    {abortSignal, ...params}: RequestConfig & UpdateWorkteamRequest,
  ): Promise<UpdateWorkteamResponse> {
    const body: jsonP.JSONObject = {
      WorkteamName: params["WorkteamName"],
      MemberDefinitions: params["MemberDefinitions"]?.map(x => fromMemberDefinition(x)),
      Description: params["Description"],
      NotificationConfiguration: fromNotificationConfiguration(params["NotificationConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateWorkteam",
    });
    return jsonP.readObj({
      required: {
        "Workteam": toWorkteam,
      },
      optional: {},
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceInService(
    params: RequestConfig & DescribeNotebookInstanceInput,
  ): Promise<DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceInService';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeNotebookInstance(params);
      const field = resp?.NotebookInstanceStatus;
      if (field === "InService") return resp;
      if (field === "Failed") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceStopped(
    params: RequestConfig & DescribeNotebookInstanceInput,
  ): Promise<DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceStopped';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeNotebookInstance(params);
      const field = resp?.NotebookInstanceStatus;
      if (field === "Stopped") return resp;
      if (field === "Failed") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForNotebookInstanceDeleted(
    params: RequestConfig & DescribeNotebookInstanceInput,
  ): Promise<Error | DescribeNotebookInstanceOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state NotebookInstanceDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeNotebookInstance(params);
        if (resp?.NotebookInstanceStatus === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 180 times, 120 seconds apart (about 360 minutes max wait time). */
  async waitForTrainingJobCompletedOrStopped(
    params: RequestConfig & DescribeTrainingJobRequest,
  ): Promise<DescribeTrainingJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TrainingJobCompletedOrStopped';
    for (let i = 0; i < 180; i++) {
      try {
        const resp = await this.describeTrainingJob(params);
        const field = resp?.TrainingJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 120000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 120 times, 30 seconds apart (about 60 minutes max wait time). */
  async waitForEndpointInService(
    params: RequestConfig & DescribeEndpointInput,
  ): Promise<DescribeEndpointOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointInService';
    for (let i = 0; i < 120; i++) {
      try {
        const resp = await this.describeEndpoint(params);
        const field = resp?.EndpointStatus;
        if (field === "InService") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForEndpointDeleted(
    params: RequestConfig & DescribeEndpointInput,
  ): Promise<Error | DescribeEndpointOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state EndpointDeleted';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeEndpoint(params);
        if (resp?.EndpointStatus === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time). */
  async waitForTransformJobCompletedOrStopped(
    params: RequestConfig & DescribeTransformJobRequest,
  ): Promise<DescribeTransformJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state TransformJobCompletedOrStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeTransformJob(params);
        const field = resp?.TransformJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 60 times, 60 seconds apart (about 60 minutes max wait time). */
  async waitForProcessingJobCompletedOrStopped(
    params: RequestConfig & DescribeProcessingJobRequest,
  ): Promise<DescribeProcessingJobResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ProcessingJobCompletedOrStopped';
    for (let i = 0; i < 60; i++) {
      try {
        const resp = await this.describeProcessingJob(params);
        const field = resp?.ProcessingJobStatus;
        if (field === "Completed") return resp;
        if (field === "Stopped") return resp;
        if (field === "Failed") throw new Error(errMessage);
      } catch (err) {
        if (["ValidationException"].includes(err.shortCode)) throw err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface AddTagsInput {
  ResourceArn: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface AssociateTrialComponentRequest {
  TrialComponentName: string;
  TrialName: string;
}

// refs: 1 - tags: named, input
export interface CreateAlgorithmInput {
  AlgorithmName: string;
  AlgorithmDescription?: string | null;
  TrainingSpecification: TrainingSpecification;
  InferenceSpecification?: InferenceSpecification | null;
  ValidationSpecification?: AlgorithmValidationSpecification | null;
  CertifyForMarketplace?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateAppRequest {
  DomainId: string;
  UserProfileName: string;
  AppType: AppType;
  AppName: string;
  Tags?: Tag[] | null;
  ResourceSpec?: ResourceSpec | null;
}

// refs: 1 - tags: named, input
export interface CreateAppImageConfigRequest {
  AppImageConfigName: string;
  Tags?: Tag[] | null;
  KernelGatewayImageConfig?: KernelGatewayImageConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateAutoMLJobRequest {
  AutoMLJobName: string;
  InputDataConfig: AutoMLChannel[];
  OutputDataConfig: AutoMLOutputDataConfig;
  ProblemType?: ProblemType | null;
  AutoMLJobObjective?: AutoMLJobObjective | null;
  AutoMLJobConfig?: AutoMLJobConfig | null;
  RoleArn: string;
  GenerateCandidateDefinitionsOnly?: boolean | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateCodeRepositoryInput {
  CodeRepositoryName: string;
  GitConfig: GitConfig;
}

// refs: 1 - tags: named, input
export interface CreateCompilationJobRequest {
  CompilationJobName: string;
  RoleArn: string;
  InputConfig: InputConfig;
  OutputConfig: OutputConfig;
  StoppingCondition: StoppingCondition;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateDomainRequest {
  DomainName: string;
  AuthMode: AuthMode;
  DefaultUserSettings: UserSettings;
  SubnetIds: string[];
  VpcId: string;
  Tags?: Tag[] | null;
  AppNetworkAccessType?: AppNetworkAccessType | null;
  HomeEfsFileSystemKmsKeyId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateEndpointInput {
  EndpointName: string;
  EndpointConfigName: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateEndpointConfigInput {
  EndpointConfigName: string;
  ProductionVariants: ProductionVariant[];
  DataCaptureConfig?: DataCaptureConfig | null;
  Tags?: Tag[] | null;
  KmsKeyId?: string | null;
}

// refs: 1 - tags: named, input
export interface CreateExperimentRequest {
  ExperimentName: string;
  DisplayName?: string | null;
  Description?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateFlowDefinitionRequest {
  FlowDefinitionName: string;
  HumanLoopRequestSource?: HumanLoopRequestSource | null;
  HumanLoopActivationConfig?: HumanLoopActivationConfig | null;
  HumanLoopConfig: HumanLoopConfig;
  OutputConfig: FlowDefinitionOutputConfig;
  RoleArn: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHumanTaskUiRequest {
  HumanTaskUiName: string;
  UiTemplate: UiTemplate;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateHyperParameterTuningJobRequest {
  HyperParameterTuningJobName: string;
  HyperParameterTuningJobConfig: HyperParameterTuningJobConfig;
  TrainingJobDefinition?: HyperParameterTrainingJobDefinition | null;
  TrainingJobDefinitions?: HyperParameterTrainingJobDefinition[] | null;
  WarmStartConfig?: HyperParameterTuningJobWarmStartConfig | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateImageRequest {
  Description?: string | null;
  DisplayName?: string | null;
  ImageName: string;
  RoleArn: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateImageVersionRequest {
  BaseImage: string;
  ClientToken: string;
  ImageName: string;
}

// refs: 1 - tags: named, input
export interface CreateLabelingJobRequest {
  LabelingJobName: string;
  LabelAttributeName: string;
  InputConfig: LabelingJobInputConfig;
  OutputConfig: LabelingJobOutputConfig;
  RoleArn: string;
  LabelCategoryConfigS3Uri?: string | null;
  StoppingConditions?: LabelingJobStoppingConditions | null;
  LabelingJobAlgorithmsConfig?: LabelingJobAlgorithmsConfig | null;
  HumanTaskConfig: HumanTaskConfig;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateModelInput {
  ModelName: string;
  PrimaryContainer?: ContainerDefinition | null;
  Containers?: ContainerDefinition[] | null;
  ExecutionRoleArn: string;
  Tags?: Tag[] | null;
  VpcConfig?: VpcConfig | null;
  EnableNetworkIsolation?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateModelPackageInput {
  ModelPackageName?: string | null;
  ModelPackageDescription?: string | null;
  InferenceSpecification?: InferenceSpecification | null;
  ValidationSpecification?: ModelPackageValidationSpecification | null;
  SourceAlgorithmSpecification?: SourceAlgorithmSpecification | null;
  CertifyForMarketplace?: boolean | null;
}

// refs: 1 - tags: named, input
export interface CreateMonitoringScheduleRequest {
  MonitoringScheduleName: string;
  MonitoringScheduleConfig: MonitoringScheduleConfig;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateNotebookInstanceInput {
  NotebookInstanceName: string;
  InstanceType: InstanceType;
  SubnetId?: string | null;
  SecurityGroupIds?: string[] | null;
  RoleArn: string;
  KmsKeyId?: string | null;
  Tags?: Tag[] | null;
  LifecycleConfigName?: string | null;
  DirectInternetAccess?: DirectInternetAccess | null;
  VolumeSizeInGB?: number | null;
  AcceleratorTypes?: NotebookInstanceAcceleratorType[] | null;
  DefaultCodeRepository?: string | null;
  AdditionalCodeRepositories?: string[] | null;
  RootAccess?: RootAccess | null;
}

// refs: 1 - tags: named, input
export interface CreateNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName: string;
  OnCreate?: NotebookInstanceLifecycleHook[] | null;
  OnStart?: NotebookInstanceLifecycleHook[] | null;
}

// refs: 1 - tags: named, input
export interface CreatePresignedDomainUrlRequest {
  DomainId: string;
  UserProfileName: string;
  SessionExpirationDurationInSeconds?: number | null;
}

// refs: 1 - tags: named, input
export interface CreatePresignedNotebookInstanceUrlInput {
  NotebookInstanceName: string;
  SessionExpirationDurationInSeconds?: number | null;
}

// refs: 1 - tags: named, input
export interface CreateProcessingJobRequest {
  ProcessingInputs?: ProcessingInput[] | null;
  ProcessingOutputConfig?: ProcessingOutputConfig | null;
  ProcessingJobName: string;
  ProcessingResources: ProcessingResources;
  StoppingCondition?: ProcessingStoppingCondition | null;
  AppSpecification: AppSpecification;
  Environment?: { [key: string]: string | null | undefined } | null;
  NetworkConfig?: NetworkConfig | null;
  RoleArn: string;
  Tags?: Tag[] | null;
  ExperimentConfig?: ExperimentConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateTrainingJobRequest {
  TrainingJobName: string;
  HyperParameters?: { [key: string]: string | null | undefined } | null;
  AlgorithmSpecification: AlgorithmSpecification;
  RoleArn: string;
  InputDataConfig?: Channel[] | null;
  OutputDataConfig: OutputDataConfig;
  ResourceConfig: ResourceConfig;
  VpcConfig?: VpcConfig | null;
  StoppingCondition: StoppingCondition;
  Tags?: Tag[] | null;
  EnableNetworkIsolation?: boolean | null;
  EnableInterContainerTrafficEncryption?: boolean | null;
  EnableManagedSpotTraining?: boolean | null;
  CheckpointConfig?: CheckpointConfig | null;
  DebugHookConfig?: DebugHookConfig | null;
  DebugRuleConfigurations?: DebugRuleConfiguration[] | null;
  TensorBoardOutputConfig?: TensorBoardOutputConfig | null;
  ExperimentConfig?: ExperimentConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateTransformJobRequest {
  TransformJobName: string;
  ModelName: string;
  MaxConcurrentTransforms?: number | null;
  ModelClientConfig?: ModelClientConfig | null;
  MaxPayloadInMB?: number | null;
  BatchStrategy?: BatchStrategy | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  TransformInput: TransformInput;
  TransformOutput: TransformOutput;
  TransformResources: TransformResources;
  DataProcessing?: DataProcessing | null;
  Tags?: Tag[] | null;
  ExperimentConfig?: ExperimentConfig | null;
}

// refs: 1 - tags: named, input
export interface CreateTrialRequest {
  TrialName: string;
  DisplayName?: string | null;
  ExperimentName: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTrialComponentRequest {
  TrialComponentName: string;
  DisplayName?: string | null;
  Status?: TrialComponentStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Parameters?: { [key: string]: TrialComponentParameterValue | null | undefined } | null;
  InputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateUserProfileRequest {
  DomainId: string;
  UserProfileName: string;
  SingleSignOnUserIdentifier?: string | null;
  SingleSignOnUserValue?: string | null;
  Tags?: Tag[] | null;
  UserSettings?: UserSettings | null;
}

// refs: 1 - tags: named, input
export interface CreateWorkforceRequest {
  CognitoConfig?: CognitoConfig | null;
  OidcConfig?: OidcConfig | null;
  SourceIpConfig?: SourceIpConfig | null;
  WorkforceName: string;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateWorkteamRequest {
  WorkteamName: string;
  WorkforceName?: string | null;
  MemberDefinitions: MemberDefinition[];
  Description: string;
  NotificationConfiguration?: NotificationConfiguration | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteAlgorithmInput {
  AlgorithmName: string;
}

// refs: 1 - tags: named, input
export interface DeleteAppRequest {
  DomainId: string;
  UserProfileName: string;
  AppType: AppType;
  AppName: string;
}

// refs: 1 - tags: named, input
export interface DeleteAppImageConfigRequest {
  AppImageConfigName: string;
}

// refs: 1 - tags: named, input
export interface DeleteCodeRepositoryInput {
  CodeRepositoryName: string;
}

// refs: 1 - tags: named, input
export interface DeleteDomainRequest {
  DomainId: string;
  RetentionPolicy?: RetentionPolicy | null;
}

// refs: 1 - tags: named, input
export interface DeleteEndpointInput {
  EndpointName: string;
}

// refs: 1 - tags: named, input
export interface DeleteEndpointConfigInput {
  EndpointConfigName: string;
}

// refs: 1 - tags: named, input
export interface DeleteExperimentRequest {
  ExperimentName: string;
}

// refs: 1 - tags: named, input
export interface DeleteFlowDefinitionRequest {
  FlowDefinitionName: string;
}

// refs: 1 - tags: named, input
export interface DeleteHumanTaskUiRequest {
  HumanTaskUiName: string;
}

// refs: 1 - tags: named, input
export interface DeleteImageRequest {
  ImageName: string;
}

// refs: 1 - tags: named, input
export interface DeleteImageVersionRequest {
  ImageName: string;
  Version: number;
}

// refs: 1 - tags: named, input
export interface DeleteModelInput {
  ModelName: string;
}

// refs: 1 - tags: named, input
export interface DeleteModelPackageInput {
  ModelPackageName: string;
}

// refs: 1 - tags: named, input
export interface DeleteMonitoringScheduleRequest {
  MonitoringScheduleName: string;
}

// refs: 1 - tags: named, input
export interface DeleteNotebookInstanceInput {
  NotebookInstanceName: string;
}

// refs: 1 - tags: named, input
export interface DeleteNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTagsInput {
  ResourceArn: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface DeleteTrialRequest {
  TrialName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTrialComponentRequest {
  TrialComponentName: string;
}

// refs: 1 - tags: named, input
export interface DeleteUserProfileRequest {
  DomainId: string;
  UserProfileName: string;
}

// refs: 1 - tags: named, input
export interface DeleteWorkforceRequest {
  WorkforceName: string;
}

// refs: 1 - tags: named, input
export interface DeleteWorkteamRequest {
  WorkteamName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAlgorithmInput {
  AlgorithmName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAppRequest {
  DomainId: string;
  UserProfileName: string;
  AppType: AppType;
  AppName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAppImageConfigRequest {
  AppImageConfigName: string;
}

// refs: 1 - tags: named, input
export interface DescribeAutoMLJobRequest {
  AutoMLJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeCodeRepositoryInput {
  CodeRepositoryName: string;
}

// refs: 1 - tags: named, input
export interface DescribeCompilationJobRequest {
  CompilationJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDomainRequest {
  DomainId: string;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointInput {
  EndpointName: string;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointConfigInput {
  EndpointConfigName: string;
}

// refs: 1 - tags: named, input
export interface DescribeExperimentRequest {
  ExperimentName: string;
}

// refs: 1 - tags: named, input
export interface DescribeFlowDefinitionRequest {
  FlowDefinitionName: string;
}

// refs: 1 - tags: named, input
export interface DescribeHumanTaskUiRequest {
  HumanTaskUiName: string;
}

// refs: 1 - tags: named, input
export interface DescribeHyperParameterTuningJobRequest {
  HyperParameterTuningJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeImageRequest {
  ImageName: string;
}

// refs: 1 - tags: named, input
export interface DescribeImageVersionRequest {
  ImageName: string;
  Version?: number | null;
}

// refs: 1 - tags: named, input
export interface DescribeLabelingJobRequest {
  LabelingJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeModelInput {
  ModelName: string;
}

// refs: 1 - tags: named, input
export interface DescribeModelPackageInput {
  ModelPackageName: string;
}

// refs: 1 - tags: named, input
export interface DescribeMonitoringScheduleRequest {
  MonitoringScheduleName: string;
}

// refs: 1 - tags: named, input
export interface DescribeNotebookInstanceInput {
  NotebookInstanceName: string;
}

// refs: 1 - tags: named, input
export interface DescribeNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName: string;
}

// refs: 1 - tags: named, input
export interface DescribeProcessingJobRequest {
  ProcessingJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeSubscribedWorkteamRequest {
  WorkteamArn: string;
}

// refs: 1 - tags: named, input
export interface DescribeTrainingJobRequest {
  TrainingJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTransformJobRequest {
  TransformJobName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTrialRequest {
  TrialName: string;
}

// refs: 1 - tags: named, input
export interface DescribeTrialComponentRequest {
  TrialComponentName: string;
}

// refs: 1 - tags: named, input
export interface DescribeUserProfileRequest {
  DomainId: string;
  UserProfileName: string;
}

// refs: 1 - tags: named, input
export interface DescribeWorkforceRequest {
  WorkforceName: string;
}

// refs: 1 - tags: named, input
export interface DescribeWorkteamRequest {
  WorkteamName: string;
}

// refs: 1 - tags: named, input
export interface DisassociateTrialComponentRequest {
  TrialComponentName: string;
  TrialName: string;
}

// refs: 1 - tags: named, input
export interface GetSearchSuggestionsRequest {
  Resource: ResourceType;
  SuggestionQuery?: SuggestionQuery | null;
}

// refs: 1 - tags: named, input
export interface ListAlgorithmsInput {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  NextToken?: string | null;
  SortBy?: AlgorithmSortBy | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListAppImageConfigsRequest {
  MaxResults?: number | null;
  NextToken?: string | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  ModifiedTimeBefore?: Date | number | null;
  ModifiedTimeAfter?: Date | number | null;
  SortBy?: AppImageConfigSortKey | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListAppsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  SortOrder?: SortOrder | null;
  SortBy?: AppSortKey | null;
  DomainIdEquals?: string | null;
  UserProfileNameEquals?: string | null;
}

// refs: 1 - tags: named, input
export interface ListAutoMLJobsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  NameContains?: string | null;
  StatusEquals?: AutoMLJobStatus | null;
  SortOrder?: AutoMLSortOrder | null;
  SortBy?: AutoMLSortBy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCandidatesForAutoMLJobRequest {
  AutoMLJobName: string;
  StatusEquals?: CandidateStatus | null;
  CandidateNameEquals?: string | null;
  SortOrder?: AutoMLSortOrder | null;
  SortBy?: CandidateSortBy | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCodeRepositoriesInput {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  NextToken?: string | null;
  SortBy?: CodeRepositorySortBy | null;
  SortOrder?: CodeRepositorySortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListCompilationJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  NameContains?: string | null;
  StatusEquals?: CompilationJobStatus | null;
  SortBy?: ListCompilationJobsSortBy | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListDomainsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListEndpointConfigsInput {
  SortBy?: EndpointConfigSortKey | null;
  SortOrder?: OrderKey | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface ListEndpointsInput {
  SortBy?: EndpointSortKey | null;
  SortOrder?: OrderKey | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  StatusEquals?: EndpointStatus | null;
}

// refs: 1 - tags: named, input
export interface ListExperimentsRequest {
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  SortBy?: SortExperimentsBy | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListFlowDefinitionsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListHumanTaskUisRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListHyperParameterTuningJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  SortBy?: HyperParameterTuningJobSortByOptions | null;
  SortOrder?: SortOrder | null;
  NameContains?: string | null;
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  StatusEquals?: HyperParameterTuningJobStatus | null;
}

// refs: 1 - tags: named, input
export interface ListImageVersionsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  ImageName: string;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  SortBy?: ImageVersionSortBy | null;
  SortOrder?: ImageVersionSortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListImagesRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  NextToken?: string | null;
  SortBy?: ImageSortBy | null;
  SortOrder?: ImageSortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListLabelingJobsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NextToken?: string | null;
  NameContains?: string | null;
  SortBy?: SortBy | null;
  SortOrder?: SortOrder | null;
  StatusEquals?: LabelingJobStatus | null;
}

// refs: 1 - tags: named, input
export interface ListLabelingJobsForWorkteamRequest {
  WorkteamArn: string;
  MaxResults?: number | null;
  NextToken?: string | null;
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  JobReferenceCodeContains?: string | null;
  SortBy?: ListLabelingJobsForWorkteamSortByOptions | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListModelPackagesInput {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  NextToken?: string | null;
  SortBy?: ModelPackageSortBy | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListModelsInput {
  SortBy?: ModelSortKey | null;
  SortOrder?: OrderKey | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface ListMonitoringExecutionsRequest {
  MonitoringScheduleName?: string | null;
  EndpointName?: string | null;
  SortBy?: MonitoringExecutionSortKey | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  ScheduledTimeBefore?: Date | number | null;
  ScheduledTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  StatusEquals?: ExecutionStatus | null;
}

// refs: 1 - tags: named, input
export interface ListMonitoringSchedulesRequest {
  EndpointName?: string | null;
  SortBy?: MonitoringScheduleSortKey | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  StatusEquals?: ScheduleStatus | null;
}

// refs: 1 - tags: named, input
export interface ListNotebookInstanceLifecycleConfigsInput {
  NextToken?: string | null;
  MaxResults?: number | null;
  SortBy?: NotebookInstanceLifecycleConfigSortKey | null;
  SortOrder?: NotebookInstanceLifecycleConfigSortOrder | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
}

// refs: 1 - tags: named, input
export interface ListNotebookInstancesInput {
  NextToken?: string | null;
  MaxResults?: number | null;
  SortBy?: NotebookInstanceSortKey | null;
  SortOrder?: NotebookInstanceSortOrder | null;
  NameContains?: string | null;
  CreationTimeBefore?: Date | number | null;
  CreationTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  StatusEquals?: NotebookInstanceStatus | null;
  NotebookInstanceLifecycleConfigNameContains?: string | null;
  DefaultCodeRepositoryContains?: string | null;
  AdditionalCodeRepositoryEquals?: string | null;
}

// refs: 1 - tags: named, input
export interface ListProcessingJobsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  NameContains?: string | null;
  StatusEquals?: ProcessingJobStatus | null;
  SortBy?: SortBy | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListSubscribedWorkteamsRequest {
  NameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsInput {
  ResourceArn: string;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTrainingJobsRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  NameContains?: string | null;
  StatusEquals?: TrainingJobStatus | null;
  SortBy?: SortBy | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListTrainingJobsForHyperParameterTuningJobRequest {
  HyperParameterTuningJobName: string;
  NextToken?: string | null;
  MaxResults?: number | null;
  StatusEquals?: TrainingJobStatus | null;
  SortBy?: TrainingJobSortByOptions | null;
  SortOrder?: SortOrder | null;
}

// refs: 1 - tags: named, input
export interface ListTransformJobsRequest {
  CreationTimeAfter?: Date | number | null;
  CreationTimeBefore?: Date | number | null;
  LastModifiedTimeAfter?: Date | number | null;
  LastModifiedTimeBefore?: Date | number | null;
  NameContains?: string | null;
  StatusEquals?: TransformJobStatus | null;
  SortBy?: SortBy | null;
  SortOrder?: SortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTrialComponentsRequest {
  ExperimentName?: string | null;
  TrialName?: string | null;
  SourceArn?: string | null;
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  SortBy?: SortTrialComponentsBy | null;
  SortOrder?: SortOrder | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTrialsRequest {
  ExperimentName?: string | null;
  TrialComponentName?: string | null;
  CreatedAfter?: Date | number | null;
  CreatedBefore?: Date | number | null;
  SortBy?: SortTrialsBy | null;
  SortOrder?: SortOrder | null;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface ListUserProfilesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
  SortOrder?: SortOrder | null;
  SortBy?: UserProfileSortKey | null;
  DomainIdEquals?: string | null;
  UserProfileNameContains?: string | null;
}

// refs: 1 - tags: named, input
export interface ListWorkforcesRequest {
  SortBy?: ListWorkforcesSortByOptions | null;
  SortOrder?: SortOrder | null;
  NameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListWorkteamsRequest {
  SortBy?: ListWorkteamsSortByOptions | null;
  SortOrder?: SortOrder | null;
  NameContains?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface RenderUiTemplateRequest {
  UiTemplate?: UiTemplate | null;
  Task: RenderableTask;
  RoleArn: string;
  HumanTaskUiArn?: string | null;
}

// refs: 1 - tags: named, input
export interface SearchRequest {
  Resource: ResourceType;
  SearchExpression?: SearchExpression | null;
  SortBy?: string | null;
  SortOrder?: SearchSortOrder | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface StartMonitoringScheduleRequest {
  MonitoringScheduleName: string;
}

// refs: 1 - tags: named, input
export interface StartNotebookInstanceInput {
  NotebookInstanceName: string;
}

// refs: 1 - tags: named, input
export interface StopAutoMLJobRequest {
  AutoMLJobName: string;
}

// refs: 1 - tags: named, input
export interface StopCompilationJobRequest {
  CompilationJobName: string;
}

// refs: 1 - tags: named, input
export interface StopHyperParameterTuningJobRequest {
  HyperParameterTuningJobName: string;
}

// refs: 1 - tags: named, input
export interface StopLabelingJobRequest {
  LabelingJobName: string;
}

// refs: 1 - tags: named, input
export interface StopMonitoringScheduleRequest {
  MonitoringScheduleName: string;
}

// refs: 1 - tags: named, input
export interface StopNotebookInstanceInput {
  NotebookInstanceName: string;
}

// refs: 1 - tags: named, input
export interface StopProcessingJobRequest {
  ProcessingJobName: string;
}

// refs: 1 - tags: named, input
export interface StopTrainingJobRequest {
  TrainingJobName: string;
}

// refs: 1 - tags: named, input
export interface StopTransformJobRequest {
  TransformJobName: string;
}

// refs: 1 - tags: named, input
export interface UpdateAppImageConfigRequest {
  AppImageConfigName: string;
  KernelGatewayImageConfig?: KernelGatewayImageConfig | null;
}

// refs: 1 - tags: named, input
export interface UpdateCodeRepositoryInput {
  CodeRepositoryName: string;
  GitConfig?: GitConfigForUpdate | null;
}

// refs: 1 - tags: named, input
export interface UpdateDomainRequest {
  DomainId: string;
  DefaultUserSettings?: UserSettings | null;
}

// refs: 1 - tags: named, input
export interface UpdateEndpointInput {
  EndpointName: string;
  EndpointConfigName: string;
  RetainAllVariantProperties?: boolean | null;
  ExcludeRetainedVariantProperties?: VariantProperty[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateEndpointWeightsAndCapacitiesInput {
  EndpointName: string;
  DesiredWeightsAndCapacities: DesiredWeightAndCapacity[];
}

// refs: 1 - tags: named, input
export interface UpdateExperimentRequest {
  ExperimentName: string;
  DisplayName?: string | null;
  Description?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateImageRequest {
  DeleteProperties?: string[] | null;
  Description?: string | null;
  DisplayName?: string | null;
  ImageName: string;
  RoleArn?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateMonitoringScheduleRequest {
  MonitoringScheduleName: string;
  MonitoringScheduleConfig: MonitoringScheduleConfig;
}

// refs: 1 - tags: named, input
export interface UpdateNotebookInstanceInput {
  NotebookInstanceName: string;
  InstanceType?: InstanceType | null;
  RoleArn?: string | null;
  LifecycleConfigName?: string | null;
  DisassociateLifecycleConfig?: boolean | null;
  VolumeSizeInGB?: number | null;
  DefaultCodeRepository?: string | null;
  AdditionalCodeRepositories?: string[] | null;
  AcceleratorTypes?: NotebookInstanceAcceleratorType[] | null;
  DisassociateAcceleratorTypes?: boolean | null;
  DisassociateDefaultCodeRepository?: boolean | null;
  DisassociateAdditionalCodeRepositories?: boolean | null;
  RootAccess?: RootAccess | null;
}

// refs: 1 - tags: named, input
export interface UpdateNotebookInstanceLifecycleConfigInput {
  NotebookInstanceLifecycleConfigName: string;
  OnCreate?: NotebookInstanceLifecycleHook[] | null;
  OnStart?: NotebookInstanceLifecycleHook[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateTrialRequest {
  TrialName: string;
  DisplayName?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateTrialComponentRequest {
  TrialComponentName: string;
  DisplayName?: string | null;
  Status?: TrialComponentStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  Parameters?: { [key: string]: TrialComponentParameterValue | null | undefined } | null;
  ParametersToRemove?: string[] | null;
  InputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  InputArtifactsToRemove?: string[] | null;
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  OutputArtifactsToRemove?: string[] | null;
}

// refs: 1 - tags: named, input
export interface UpdateUserProfileRequest {
  DomainId: string;
  UserProfileName: string;
  UserSettings?: UserSettings | null;
}

// refs: 1 - tags: named, input
export interface UpdateWorkforceRequest {
  WorkforceName: string;
  SourceIpConfig?: SourceIpConfig | null;
  OidcConfig?: OidcConfig | null;
}

// refs: 1 - tags: named, input
export interface UpdateWorkteamRequest {
  WorkteamName: string;
  MemberDefinitions?: MemberDefinition[] | null;
  Description?: string | null;
  NotificationConfiguration?: NotificationConfiguration | null;
}

// refs: 1 - tags: named, output
export interface AddTagsOutput {
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface AssociateTrialComponentResponse {
  TrialComponentArn?: string | null;
  TrialArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAlgorithmOutput {
  AlgorithmArn: string;
}

// refs: 1 - tags: named, output
export interface CreateAppResponse {
  AppArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAppImageConfigResponse {
  AppImageConfigArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateAutoMLJobResponse {
  AutoMLJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateCodeRepositoryOutput {
  CodeRepositoryArn: string;
}

// refs: 1 - tags: named, output
export interface CreateCompilationJobResponse {
  CompilationJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateDomainResponse {
  DomainArn?: string | null;
  Url?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateEndpointOutput {
  EndpointArn: string;
}

// refs: 1 - tags: named, output
export interface CreateEndpointConfigOutput {
  EndpointConfigArn: string;
}

// refs: 1 - tags: named, output
export interface CreateExperimentResponse {
  ExperimentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateFlowDefinitionResponse {
  FlowDefinitionArn: string;
}

// refs: 1 - tags: named, output
export interface CreateHumanTaskUiResponse {
  HumanTaskUiArn: string;
}

// refs: 1 - tags: named, output
export interface CreateHyperParameterTuningJobResponse {
  HyperParameterTuningJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateImageResponse {
  ImageArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateImageVersionResponse {
  ImageVersionArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateLabelingJobResponse {
  LabelingJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateModelOutput {
  ModelArn: string;
}

// refs: 1 - tags: named, output
export interface CreateModelPackageOutput {
  ModelPackageArn: string;
}

// refs: 1 - tags: named, output
export interface CreateMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
}

// refs: 1 - tags: named, output
export interface CreateNotebookInstanceOutput {
  NotebookInstanceArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateNotebookInstanceLifecycleConfigOutput {
  NotebookInstanceLifecycleConfigArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePresignedDomainUrlResponse {
  AuthorizedUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePresignedNotebookInstanceUrlOutput {
  AuthorizedUrl?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateProcessingJobResponse {
  ProcessingJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateTrainingJobResponse {
  TrainingJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateTransformJobResponse {
  TransformJobArn: string;
}

// refs: 1 - tags: named, output
export interface CreateTrialResponse {
  TrialArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateTrialComponentResponse {
  TrialComponentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateUserProfileResponse {
  UserProfileArn?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateWorkforceResponse {
  WorkforceArn: string;
}

// refs: 1 - tags: named, output
export interface CreateWorkteamResponse {
  WorkteamArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteExperimentResponse {
  ExperimentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteFlowDefinitionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteHumanTaskUiResponse {
}

// refs: 1 - tags: named, output
export interface DeleteImageResponse {
}

// refs: 1 - tags: named, output
export interface DeleteImageVersionResponse {
}

// refs: 1 - tags: named, output
export interface DeleteTagsOutput {
}

// refs: 1 - tags: named, output
export interface DeleteTrialResponse {
  TrialArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteTrialComponentResponse {
  TrialComponentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteWorkforceResponse {
}

// refs: 1 - tags: named, output
export interface DeleteWorkteamResponse {
  Success: boolean;
}

// refs: 1 - tags: named, output
export interface DescribeAlgorithmOutput {
  AlgorithmName: string;
  AlgorithmArn: string;
  AlgorithmDescription?: string | null;
  CreationTime: Date | number;
  TrainingSpecification: TrainingSpecification;
  InferenceSpecification?: InferenceSpecification | null;
  ValidationSpecification?: AlgorithmValidationSpecification | null;
  AlgorithmStatus: AlgorithmStatus;
  AlgorithmStatusDetails: AlgorithmStatusDetails;
  ProductId?: string | null;
  CertifyForMarketplace?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeAppResponse {
  AppArn?: string | null;
  AppType?: AppType | null;
  AppName?: string | null;
  DomainId?: string | null;
  UserProfileName?: string | null;
  Status?: AppStatus | null;
  LastHealthCheckTimestamp?: Date | number | null;
  LastUserActivityTimestamp?: Date | number | null;
  CreationTime?: Date | number | null;
  FailureReason?: string | null;
  ResourceSpec?: ResourceSpec | null;
}

// refs: 1 - tags: named, output
export interface DescribeAppImageConfigResponse {
  AppImageConfigArn?: string | null;
  AppImageConfigName?: string | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  KernelGatewayImageConfig?: KernelGatewayImageConfig | null;
}

// refs: 1 - tags: named, output
export interface DescribeAutoMLJobResponse {
  AutoMLJobName: string;
  AutoMLJobArn: string;
  InputDataConfig: AutoMLChannel[];
  OutputDataConfig: AutoMLOutputDataConfig;
  RoleArn: string;
  AutoMLJobObjective?: AutoMLJobObjective | null;
  ProblemType?: ProblemType | null;
  AutoMLJobConfig?: AutoMLJobConfig | null;
  CreationTime: Date | number;
  EndTime?: Date | number | null;
  LastModifiedTime: Date | number;
  FailureReason?: string | null;
  BestCandidate?: AutoMLCandidate | null;
  AutoMLJobStatus: AutoMLJobStatus;
  AutoMLJobSecondaryStatus: AutoMLJobSecondaryStatus;
  GenerateCandidateDefinitionsOnly?: boolean | null;
  AutoMLJobArtifacts?: AutoMLJobArtifacts | null;
  ResolvedAttributes?: ResolvedAttributes | null;
}

// refs: 1 - tags: named, output
export interface DescribeCodeRepositoryOutput {
  CodeRepositoryName: string;
  CodeRepositoryArn: string;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  GitConfig?: GitConfig | null;
}

// refs: 1 - tags: named, output
export interface DescribeCompilationJobResponse {
  CompilationJobName: string;
  CompilationJobArn: string;
  CompilationJobStatus: CompilationJobStatus;
  CompilationStartTime?: Date | number | null;
  CompilationEndTime?: Date | number | null;
  StoppingCondition: StoppingCondition;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  FailureReason: string;
  ModelArtifacts: ModelArtifacts;
  RoleArn: string;
  InputConfig: InputConfig;
  OutputConfig: OutputConfig;
}

// refs: 1 - tags: named, output
export interface DescribeDomainResponse {
  DomainArn?: string | null;
  DomainId?: string | null;
  DomainName?: string | null;
  HomeEfsFileSystemId?: string | null;
  SingleSignOnManagedApplicationInstanceId?: string | null;
  Status?: DomainStatus | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  FailureReason?: string | null;
  AuthMode?: AuthMode | null;
  DefaultUserSettings?: UserSettings | null;
  AppNetworkAccessType?: AppNetworkAccessType | null;
  HomeEfsFileSystemKmsKeyId?: string | null;
  SubnetIds?: string[] | null;
  Url?: string | null;
  VpcId?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointOutput {
  EndpointName: string;
  EndpointArn: string;
  EndpointConfigName: string;
  ProductionVariants?: ProductionVariantSummary[] | null;
  DataCaptureConfig?: DataCaptureConfigSummary | null;
  EndpointStatus: EndpointStatus;
  FailureReason?: string | null;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointConfigOutput {
  EndpointConfigName: string;
  EndpointConfigArn: string;
  ProductionVariants: ProductionVariant[];
  DataCaptureConfig?: DataCaptureConfig | null;
  KmsKeyId?: string | null;
  CreationTime: Date | number;
}

// refs: 1 - tags: named, output
export interface DescribeExperimentResponse {
  ExperimentName?: string | null;
  ExperimentArn?: string | null;
  DisplayName?: string | null;
  Source?: ExperimentSource | null;
  Description?: string | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
}

// refs: 1 - tags: named, output
export interface DescribeFlowDefinitionResponse {
  FlowDefinitionArn: string;
  FlowDefinitionName: string;
  FlowDefinitionStatus: FlowDefinitionStatus;
  CreationTime: Date | number;
  HumanLoopRequestSource?: HumanLoopRequestSource | null;
  HumanLoopActivationConfig?: HumanLoopActivationConfig | null;
  HumanLoopConfig: HumanLoopConfig;
  OutputConfig: FlowDefinitionOutputConfig;
  RoleArn: string;
  FailureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeHumanTaskUiResponse {
  HumanTaskUiArn: string;
  HumanTaskUiName: string;
  HumanTaskUiStatus?: HumanTaskUiStatus | null;
  CreationTime: Date | number;
  UiTemplate: UiTemplateInfo;
}

// refs: 1 - tags: named, output
export interface DescribeHyperParameterTuningJobResponse {
  HyperParameterTuningJobName: string;
  HyperParameterTuningJobArn: string;
  HyperParameterTuningJobConfig: HyperParameterTuningJobConfig;
  TrainingJobDefinition?: HyperParameterTrainingJobDefinition | null;
  TrainingJobDefinitions?: HyperParameterTrainingJobDefinition[] | null;
  HyperParameterTuningJobStatus: HyperParameterTuningJobStatus;
  CreationTime: Date | number;
  HyperParameterTuningEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  TrainingJobStatusCounters: TrainingJobStatusCounters;
  ObjectiveStatusCounters: ObjectiveStatusCounters;
  BestTrainingJob?: HyperParameterTrainingJobSummary | null;
  OverallBestTrainingJob?: HyperParameterTrainingJobSummary | null;
  WarmStartConfig?: HyperParameterTuningJobWarmStartConfig | null;
  FailureReason?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImageResponse {
  CreationTime?: Date | number | null;
  Description?: string | null;
  DisplayName?: string | null;
  FailureReason?: string | null;
  ImageArn?: string | null;
  ImageName?: string | null;
  ImageStatus?: ImageStatus | null;
  LastModifiedTime?: Date | number | null;
  RoleArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeImageVersionResponse {
  BaseImage?: string | null;
  ContainerImage?: string | null;
  CreationTime?: Date | number | null;
  FailureReason?: string | null;
  ImageArn?: string | null;
  ImageVersionArn?: string | null;
  ImageVersionStatus?: ImageVersionStatus | null;
  LastModifiedTime?: Date | number | null;
  Version?: number | null;
}

// refs: 1 - tags: named, output
export interface DescribeLabelingJobResponse {
  LabelingJobStatus: LabelingJobStatus;
  LabelCounters: LabelCounters;
  FailureReason?: string | null;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  JobReferenceCode: string;
  LabelingJobName: string;
  LabelingJobArn: string;
  LabelAttributeName?: string | null;
  InputConfig: LabelingJobInputConfig;
  OutputConfig: LabelingJobOutputConfig;
  RoleArn: string;
  LabelCategoryConfigS3Uri?: string | null;
  StoppingConditions?: LabelingJobStoppingConditions | null;
  LabelingJobAlgorithmsConfig?: LabelingJobAlgorithmsConfig | null;
  HumanTaskConfig: HumanTaskConfig;
  Tags?: Tag[] | null;
  LabelingJobOutput?: LabelingJobOutput | null;
}

// refs: 1 - tags: named, output
export interface DescribeModelOutput {
  ModelName: string;
  PrimaryContainer?: ContainerDefinition | null;
  Containers?: ContainerDefinition[] | null;
  ExecutionRoleArn: string;
  VpcConfig?: VpcConfig | null;
  CreationTime: Date | number;
  ModelArn: string;
  EnableNetworkIsolation?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeModelPackageOutput {
  ModelPackageName: string;
  ModelPackageArn: string;
  ModelPackageDescription?: string | null;
  CreationTime: Date | number;
  InferenceSpecification?: InferenceSpecification | null;
  SourceAlgorithmSpecification?: SourceAlgorithmSpecification | null;
  ValidationSpecification?: ModelPackageValidationSpecification | null;
  ModelPackageStatus: ModelPackageStatus;
  ModelPackageStatusDetails: ModelPackageStatusDetails;
  CertifyForMarketplace?: boolean | null;
}

// refs: 1 - tags: named, output
export interface DescribeMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
  MonitoringScheduleName: string;
  MonitoringScheduleStatus: ScheduleStatus;
  FailureReason?: string | null;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  MonitoringScheduleConfig: MonitoringScheduleConfig;
  EndpointName?: string | null;
  LastMonitoringExecutionSummary?: MonitoringExecutionSummary | null;
}

// refs: 1 - tags: named, output
export interface DescribeNotebookInstanceOutput {
  NotebookInstanceArn?: string | null;
  NotebookInstanceName?: string | null;
  NotebookInstanceStatus?: NotebookInstanceStatus | null;
  FailureReason?: string | null;
  Url?: string | null;
  InstanceType?: InstanceType | null;
  SubnetId?: string | null;
  SecurityGroups?: string[] | null;
  RoleArn?: string | null;
  KmsKeyId?: string | null;
  NetworkInterfaceId?: string | null;
  LastModifiedTime?: Date | number | null;
  CreationTime?: Date | number | null;
  NotebookInstanceLifecycleConfigName?: string | null;
  DirectInternetAccess?: DirectInternetAccess | null;
  VolumeSizeInGB?: number | null;
  AcceleratorTypes?: NotebookInstanceAcceleratorType[] | null;
  DefaultCodeRepository?: string | null;
  AdditionalCodeRepositories?: string[] | null;
  RootAccess?: RootAccess | null;
}

// refs: 1 - tags: named, output
export interface DescribeNotebookInstanceLifecycleConfigOutput {
  NotebookInstanceLifecycleConfigArn?: string | null;
  NotebookInstanceLifecycleConfigName?: string | null;
  OnCreate?: NotebookInstanceLifecycleHook[] | null;
  OnStart?: NotebookInstanceLifecycleHook[] | null;
  LastModifiedTime?: Date | number | null;
  CreationTime?: Date | number | null;
}

// refs: 1 - tags: named, output
export interface DescribeProcessingJobResponse {
  ProcessingInputs?: ProcessingInput[] | null;
  ProcessingOutputConfig?: ProcessingOutputConfig | null;
  ProcessingJobName: string;
  ProcessingResources: ProcessingResources;
  StoppingCondition?: ProcessingStoppingCondition | null;
  AppSpecification: AppSpecification;
  Environment?: { [key: string]: string | null | undefined } | null;
  NetworkConfig?: NetworkConfig | null;
  RoleArn?: string | null;
  ExperimentConfig?: ExperimentConfig | null;
  ProcessingJobArn: string;
  ProcessingJobStatus: ProcessingJobStatus;
  ExitMessage?: string | null;
  FailureReason?: string | null;
  ProcessingEndTime?: Date | number | null;
  ProcessingStartTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  CreationTime: Date | number;
  MonitoringScheduleArn?: string | null;
  AutoMLJobArn?: string | null;
  TrainingJobArn?: string | null;
}

// refs: 1 - tags: named, output
export interface DescribeSubscribedWorkteamResponse {
  SubscribedWorkteam: SubscribedWorkteam;
}

// refs: 1 - tags: named, output
export interface DescribeTrainingJobResponse {
  TrainingJobName: string;
  TrainingJobArn: string;
  TuningJobArn?: string | null;
  LabelingJobArn?: string | null;
  AutoMLJobArn?: string | null;
  ModelArtifacts: ModelArtifacts;
  TrainingJobStatus: TrainingJobStatus;
  SecondaryStatus: SecondaryStatus;
  FailureReason?: string | null;
  HyperParameters?: { [key: string]: string | null | undefined } | null;
  AlgorithmSpecification: AlgorithmSpecification;
  RoleArn?: string | null;
  InputDataConfig?: Channel[] | null;
  OutputDataConfig?: OutputDataConfig | null;
  ResourceConfig: ResourceConfig;
  VpcConfig?: VpcConfig | null;
  StoppingCondition: StoppingCondition;
  CreationTime: Date | number;
  TrainingStartTime?: Date | number | null;
  TrainingEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  SecondaryStatusTransitions?: SecondaryStatusTransition[] | null;
  FinalMetricDataList?: MetricData[] | null;
  EnableNetworkIsolation?: boolean | null;
  EnableInterContainerTrafficEncryption?: boolean | null;
  EnableManagedSpotTraining?: boolean | null;
  CheckpointConfig?: CheckpointConfig | null;
  TrainingTimeInSeconds?: number | null;
  BillableTimeInSeconds?: number | null;
  DebugHookConfig?: DebugHookConfig | null;
  ExperimentConfig?: ExperimentConfig | null;
  DebugRuleConfigurations?: DebugRuleConfiguration[] | null;
  TensorBoardOutputConfig?: TensorBoardOutputConfig | null;
  DebugRuleEvaluationStatuses?: DebugRuleEvaluationStatus[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeTransformJobResponse {
  TransformJobName: string;
  TransformJobArn: string;
  TransformJobStatus: TransformJobStatus;
  FailureReason?: string | null;
  ModelName: string;
  MaxConcurrentTransforms?: number | null;
  ModelClientConfig?: ModelClientConfig | null;
  MaxPayloadInMB?: number | null;
  BatchStrategy?: BatchStrategy | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  TransformInput: TransformInput;
  TransformOutput?: TransformOutput | null;
  TransformResources: TransformResources;
  CreationTime: Date | number;
  TransformStartTime?: Date | number | null;
  TransformEndTime?: Date | number | null;
  LabelingJobArn?: string | null;
  AutoMLJobArn?: string | null;
  DataProcessing?: DataProcessing | null;
  ExperimentConfig?: ExperimentConfig | null;
}

// refs: 1 - tags: named, output
export interface DescribeTrialResponse {
  TrialName?: string | null;
  TrialArn?: string | null;
  DisplayName?: string | null;
  ExperimentName?: string | null;
  Source?: TrialSource | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
}

// refs: 1 - tags: named, output
export interface DescribeTrialComponentResponse {
  TrialComponentName?: string | null;
  TrialComponentArn?: string | null;
  DisplayName?: string | null;
  Source?: TrialComponentSource | null;
  Status?: TrialComponentStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
  Parameters?: { [key: string]: TrialComponentParameterValue | null | undefined } | null;
  InputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  Metrics?: TrialComponentMetricSummary[] | null;
}

// refs: 1 - tags: named, output
export interface DescribeUserProfileResponse {
  DomainId?: string | null;
  UserProfileArn?: string | null;
  UserProfileName?: string | null;
  HomeEfsFileSystemUid?: string | null;
  Status?: UserProfileStatus | null;
  LastModifiedTime?: Date | number | null;
  CreationTime?: Date | number | null;
  FailureReason?: string | null;
  SingleSignOnUserIdentifier?: string | null;
  SingleSignOnUserValue?: string | null;
  UserSettings?: UserSettings | null;
}

// refs: 1 - tags: named, output
export interface DescribeWorkforceResponse {
  Workforce: Workforce;
}

// refs: 1 - tags: named, output
export interface DescribeWorkteamResponse {
  Workteam: Workteam;
}

// refs: 1 - tags: named, output
export interface DisassociateTrialComponentResponse {
  TrialComponentArn?: string | null;
  TrialArn?: string | null;
}

// refs: 1 - tags: named, output
export interface GetSearchSuggestionsResponse {
  PropertyNameSuggestions?: PropertyNameSuggestion[] | null;
}

// refs: 1 - tags: named, output
export interface ListAlgorithmsOutput {
  AlgorithmSummaryList: AlgorithmSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAppImageConfigsResponse {
  NextToken?: string | null;
  AppImageConfigs?: AppImageConfigDetails[] | null;
}

// refs: 1 - tags: named, output
export interface ListAppsResponse {
  Apps?: AppDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListAutoMLJobsResponse {
  AutoMLJobSummaries: AutoMLJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCandidatesForAutoMLJobResponse {
  Candidates: AutoMLCandidate[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCodeRepositoriesOutput {
  CodeRepositorySummaryList: CodeRepositorySummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCompilationJobsResponse {
  CompilationJobSummaries: CompilationJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListDomainsResponse {
  Domains?: DomainDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListEndpointConfigsOutput {
  EndpointConfigs: EndpointConfigSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListEndpointsOutput {
  Endpoints: EndpointSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListExperimentsResponse {
  ExperimentSummaries?: ExperimentSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListFlowDefinitionsResponse {
  FlowDefinitionSummaries: FlowDefinitionSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListHumanTaskUisResponse {
  HumanTaskUiSummaries: HumanTaskUiSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListHyperParameterTuningJobsResponse {
  HyperParameterTuningJobSummaries: HyperParameterTuningJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListImageVersionsResponse {
  ImageVersions?: ImageVersion[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListImagesResponse {
  Images?: Image[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListLabelingJobsResponse {
  LabelingJobSummaryList?: LabelingJobSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListLabelingJobsForWorkteamResponse {
  LabelingJobSummaryList: LabelingJobForWorkteamSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListModelPackagesOutput {
  ModelPackageSummaryList: ModelPackageSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListModelsOutput {
  Models: ModelSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMonitoringExecutionsResponse {
  MonitoringExecutionSummaries: MonitoringExecutionSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListMonitoringSchedulesResponse {
  MonitoringScheduleSummaries: MonitoringScheduleSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListNotebookInstanceLifecycleConfigsOutput {
  NextToken?: string | null;
  NotebookInstanceLifecycleConfigs?: NotebookInstanceLifecycleConfigSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListNotebookInstancesOutput {
  NextToken?: string | null;
  NotebookInstances?: NotebookInstanceSummary[] | null;
}

// refs: 1 - tags: named, output
export interface ListProcessingJobsResponse {
  ProcessingJobSummaries: ProcessingJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListSubscribedWorkteamsResponse {
  SubscribedWorkteams: SubscribedWorkteam[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsOutput {
  Tags?: Tag[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTrainingJobsResponse {
  TrainingJobSummaries: TrainingJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTrainingJobsForHyperParameterTuningJobResponse {
  TrainingJobSummaries: HyperParameterTrainingJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTransformJobsResponse {
  TransformJobSummaries: TransformJobSummary[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTrialComponentsResponse {
  TrialComponentSummaries?: TrialComponentSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTrialsResponse {
  TrialSummaries?: TrialSummary[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListUserProfilesResponse {
  UserProfiles?: UserProfileDetails[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListWorkforcesResponse {
  Workforces: Workforce[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListWorkteamsResponse {
  Workteams: Workteam[];
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface RenderUiTemplateResponse {
  RenderedContent: string;
  Errors: RenderingError[];
}

// refs: 1 - tags: named, output
export interface SearchResponse {
  Results?: SearchRecord[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateAppImageConfigResponse {
  AppImageConfigArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateCodeRepositoryOutput {
  CodeRepositoryArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateDomainResponse {
  DomainArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateEndpointOutput {
  EndpointArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateEndpointWeightsAndCapacitiesOutput {
  EndpointArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateExperimentResponse {
  ExperimentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateImageResponse {
  ImageArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateMonitoringScheduleResponse {
  MonitoringScheduleArn: string;
}

// refs: 1 - tags: named, output
export interface UpdateNotebookInstanceOutput {
}

// refs: 1 - tags: named, output
export interface UpdateNotebookInstanceLifecycleConfigOutput {
}

// refs: 1 - tags: named, output
export interface UpdateTrialResponse {
  TrialArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateTrialComponentResponse {
  TrialComponentArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateUserProfileResponse {
  UserProfileArn?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateWorkforceResponse {
  Workforce: Workforce;
}

// refs: 1 - tags: named, output
export interface UpdateWorkteamResponse {
  Workteam: Workteam;
}

// refs: 35 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TrainingSpecification {
  TrainingImage: string;
  TrainingImageDigest?: string | null;
  SupportedHyperParameters?: HyperParameterSpecification[] | null;
  SupportedTrainingInstanceTypes: TrainingInstanceType[];
  SupportsDistributedTraining?: boolean | null;
  MetricDefinitions?: MetricDefinition[] | null;
  TrainingChannels: ChannelSpecification[];
  SupportedTuningJobObjectiveMetrics?: HyperParameterTuningJobObjective[] | null;
}
function fromTrainingSpecification(input?: TrainingSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    TrainingImageDigest: input["TrainingImageDigest"],
    SupportedHyperParameters: input["SupportedHyperParameters"]?.map(x => fromHyperParameterSpecification(x)),
    SupportedTrainingInstanceTypes: input["SupportedTrainingInstanceTypes"],
    SupportsDistributedTraining: input["SupportsDistributedTraining"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
    TrainingChannels: input["TrainingChannels"]?.map(x => fromChannelSpecification(x)),
    SupportedTuningJobObjectiveMetrics: input["SupportedTuningJobObjectiveMetrics"]?.map(x => fromHyperParameterTuningJobObjective(x)),
  }
}
function toTrainingSpecification(root: jsonP.JSONValue): TrainingSpecification {
  return jsonP.readObj({
    required: {
      "TrainingImage": "s",
      "SupportedTrainingInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<TrainingInstanceType>(x)],
      "TrainingChannels": [toChannelSpecification],
    },
    optional: {
      "TrainingImageDigest": "s",
      "SupportedHyperParameters": [toHyperParameterSpecification],
      "SupportsDistributedTraining": "b",
      "MetricDefinitions": [toMetricDefinition],
      "SupportedTuningJobObjectiveMetrics": [toHyperParameterTuningJobObjective],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HyperParameterSpecification {
  Name: string;
  Description?: string | null;
  Type: ParameterType;
  Range?: ParameterRange | null;
  IsTunable?: boolean | null;
  IsRequired?: boolean | null;
  DefaultValue?: string | null;
}
function fromHyperParameterSpecification(input?: HyperParameterSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    Type: input["Type"],
    Range: fromParameterRange(input["Range"]),
    IsTunable: input["IsTunable"],
    IsRequired: input["IsRequired"],
    DefaultValue: input["DefaultValue"],
  }
}
function toHyperParameterSpecification(root: jsonP.JSONValue): HyperParameterSpecification {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<ParameterType>(x),
    },
    optional: {
      "Description": "s",
      "Range": toParameterRange,
      "IsTunable": "b",
      "IsRequired": "b",
      "DefaultValue": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ParameterType =
| "Integer"
| "Continuous"
| "Categorical"
| "FreeText"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ParameterRange {
  IntegerParameterRangeSpecification?: IntegerParameterRangeSpecification | null;
  ContinuousParameterRangeSpecification?: ContinuousParameterRangeSpecification | null;
  CategoricalParameterRangeSpecification?: CategoricalParameterRangeSpecification | null;
}
function fromParameterRange(input?: ParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntegerParameterRangeSpecification: fromIntegerParameterRangeSpecification(input["IntegerParameterRangeSpecification"]),
    ContinuousParameterRangeSpecification: fromContinuousParameterRangeSpecification(input["ContinuousParameterRangeSpecification"]),
    CategoricalParameterRangeSpecification: fromCategoricalParameterRangeSpecification(input["CategoricalParameterRangeSpecification"]),
  }
}
function toParameterRange(root: jsonP.JSONValue): ParameterRange {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntegerParameterRangeSpecification": toIntegerParameterRangeSpecification,
      "ContinuousParameterRangeSpecification": toContinuousParameterRangeSpecification,
      "CategoricalParameterRangeSpecification": toCategoricalParameterRangeSpecification,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface IntegerParameterRangeSpecification {
  MinValue: string;
  MaxValue: string;
}
function fromIntegerParameterRangeSpecification(input?: IntegerParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
  }
}
function toIntegerParameterRangeSpecification(root: jsonP.JSONValue): IntegerParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ContinuousParameterRangeSpecification {
  MinValue: string;
  MaxValue: string;
}
function fromContinuousParameterRangeSpecification(input?: ContinuousParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
  }
}
function toContinuousParameterRangeSpecification(root: jsonP.JSONValue): ContinuousParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface CategoricalParameterRangeSpecification {
  Values: string[];
}
function fromCategoricalParameterRangeSpecification(input?: CategoricalParameterRangeSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Values: input["Values"],
  }
}
function toCategoricalParameterRangeSpecification(root: jsonP.JSONValue): CategoricalParameterRangeSpecification {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type TrainingInstanceType =
| "ml.m4.xlarge"
| "ml.m4.2xlarge"
| "ml.m4.4xlarge"
| "ml.m4.10xlarge"
| "ml.m4.16xlarge"
| "ml.g4dn.xlarge"
| "ml.g4dn.2xlarge"
| "ml.g4dn.4xlarge"
| "ml.g4dn.8xlarge"
| "ml.g4dn.12xlarge"
| "ml.g4dn.16xlarge"
| "ml.m5.large"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.12xlarge"
| "ml.m5.24xlarge"
| "ml.c4.xlarge"
| "ml.c4.2xlarge"
| "ml.c4.4xlarge"
| "ml.c4.8xlarge"
| "ml.p2.xlarge"
| "ml.p2.8xlarge"
| "ml.p2.16xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| "ml.p3dn.24xlarge"
| "ml.p4d.24xlarge"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.18xlarge"
| "ml.c5n.xlarge"
| "ml.c5n.2xlarge"
| "ml.c5n.4xlarge"
| "ml.c5n.9xlarge"
| "ml.c5n.18xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface MetricDefinition {
  Name: string;
  Regex: string;
}
function fromMetricDefinition(input?: MetricDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Regex: input["Regex"],
  }
}
function toMetricDefinition(root: jsonP.JSONValue): MetricDefinition {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Regex": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ChannelSpecification {
  Name: string;
  Description?: string | null;
  IsRequired?: boolean | null;
  SupportedContentTypes: string[];
  SupportedCompressionTypes?: CompressionType[] | null;
  SupportedInputModes: TrainingInputMode[];
}
function fromChannelSpecification(input?: ChannelSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Description: input["Description"],
    IsRequired: input["IsRequired"],
    SupportedContentTypes: input["SupportedContentTypes"],
    SupportedCompressionTypes: input["SupportedCompressionTypes"],
    SupportedInputModes: input["SupportedInputModes"],
  }
}
function toChannelSpecification(root: jsonP.JSONValue): ChannelSpecification {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "SupportedContentTypes": ["s"],
      "SupportedInputModes": [(x: jsonP.JSONValue) => cmnP.readEnum<TrainingInputMode>(x)],
    },
    optional: {
      "Description": "s",
      "IsRequired": "b",
      "SupportedCompressionTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<CompressionType>(x)],
    },
  }, root);
}

// refs: 21 - tags: input, named, enum, output
export type CompressionType =
| "None"
| "Gzip"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, enum, output
export type TrainingInputMode =
| "Pipe"
| "File"
| cmnP.UnexpectedEnumValue;

// refs: 8 - tags: input, named, interface, output
export interface HyperParameterTuningJobObjective {
  Type: HyperParameterTuningJobObjectiveType;
  MetricName: string;
}
function fromHyperParameterTuningJobObjective(input?: HyperParameterTuningJobObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    MetricName: input["MetricName"],
  }
}
function toHyperParameterTuningJobObjective(root: jsonP.JSONValue): HyperParameterTuningJobObjective {
  return jsonP.readObj({
    required: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobObjectiveType>(x),
      "MetricName": "s",
    },
    optional: {},
  }, root);
}

// refs: 11 - tags: input, named, enum, output
export type HyperParameterTuningJobObjectiveType =
| "Maximize"
| "Minimize"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface InferenceSpecification {
  Containers: ModelPackageContainerDefinition[];
  SupportedTransformInstanceTypes: TransformInstanceType[];
  SupportedRealtimeInferenceInstanceTypes: ProductionVariantInstanceType[];
  SupportedContentTypes: string[];
  SupportedResponseMIMETypes: string[];
}
function fromInferenceSpecification(input?: InferenceSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Containers: input["Containers"]?.map(x => fromModelPackageContainerDefinition(x)),
    SupportedTransformInstanceTypes: input["SupportedTransformInstanceTypes"],
    SupportedRealtimeInferenceInstanceTypes: input["SupportedRealtimeInferenceInstanceTypes"],
    SupportedContentTypes: input["SupportedContentTypes"],
    SupportedResponseMIMETypes: input["SupportedResponseMIMETypes"],
  }
}
function toInferenceSpecification(root: jsonP.JSONValue): InferenceSpecification {
  return jsonP.readObj({
    required: {
      "Containers": [toModelPackageContainerDefinition],
      "SupportedTransformInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<TransformInstanceType>(x)],
      "SupportedRealtimeInferenceInstanceTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<ProductionVariantInstanceType>(x)],
      "SupportedContentTypes": ["s"],
      "SupportedResponseMIMETypes": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ModelPackageContainerDefinition {
  ContainerHostname?: string | null;
  Image: string;
  ImageDigest?: string | null;
  ModelDataUrl?: string | null;
  ProductId?: string | null;
}
function fromModelPackageContainerDefinition(input?: ModelPackageContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContainerHostname: input["ContainerHostname"],
    Image: input["Image"],
    ImageDigest: input["ImageDigest"],
    ModelDataUrl: input["ModelDataUrl"],
    ProductId: input["ProductId"],
  }
}
function toModelPackageContainerDefinition(root: jsonP.JSONValue): ModelPackageContainerDefinition {
  return jsonP.readObj({
    required: {
      "Image": "s",
    },
    optional: {
      "ContainerHostname": "s",
      "ImageDigest": "s",
      "ModelDataUrl": "s",
      "ProductId": "s",
    },
  }, root);
}

// refs: 11 - tags: input, named, enum, output
export type TransformInstanceType =
| "ml.m4.xlarge"
| "ml.m4.2xlarge"
| "ml.m4.4xlarge"
| "ml.m4.10xlarge"
| "ml.m4.16xlarge"
| "ml.c4.xlarge"
| "ml.c4.2xlarge"
| "ml.c4.4xlarge"
| "ml.c4.8xlarge"
| "ml.p2.xlarge"
| "ml.p2.8xlarge"
| "ml.p2.16xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.18xlarge"
| "ml.m5.large"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.12xlarge"
| "ml.m5.24xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ProductionVariantInstanceType =
| "ml.t2.medium"
| "ml.t2.large"
| "ml.t2.xlarge"
| "ml.t2.2xlarge"
| "ml.m4.xlarge"
| "ml.m4.2xlarge"
| "ml.m4.4xlarge"
| "ml.m4.10xlarge"
| "ml.m4.16xlarge"
| "ml.m5.large"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.12xlarge"
| "ml.m5.24xlarge"
| "ml.m5d.large"
| "ml.m5d.xlarge"
| "ml.m5d.2xlarge"
| "ml.m5d.4xlarge"
| "ml.m5d.12xlarge"
| "ml.m5d.24xlarge"
| "ml.c4.large"
| "ml.c4.xlarge"
| "ml.c4.2xlarge"
| "ml.c4.4xlarge"
| "ml.c4.8xlarge"
| "ml.p2.xlarge"
| "ml.p2.8xlarge"
| "ml.p2.16xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| "ml.c5.large"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.18xlarge"
| "ml.c5d.large"
| "ml.c5d.xlarge"
| "ml.c5d.2xlarge"
| "ml.c5d.4xlarge"
| "ml.c5d.9xlarge"
| "ml.c5d.18xlarge"
| "ml.g4dn.xlarge"
| "ml.g4dn.2xlarge"
| "ml.g4dn.4xlarge"
| "ml.g4dn.8xlarge"
| "ml.g4dn.12xlarge"
| "ml.g4dn.16xlarge"
| "ml.r5.large"
| "ml.r5.xlarge"
| "ml.r5.2xlarge"
| "ml.r5.4xlarge"
| "ml.r5.12xlarge"
| "ml.r5.24xlarge"
| "ml.r5d.large"
| "ml.r5d.xlarge"
| "ml.r5d.2xlarge"
| "ml.r5d.4xlarge"
| "ml.r5d.12xlarge"
| "ml.r5d.24xlarge"
| "ml.inf1.xlarge"
| "ml.inf1.2xlarge"
| "ml.inf1.6xlarge"
| "ml.inf1.24xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface AlgorithmValidationSpecification {
  ValidationRole: string;
  ValidationProfiles: AlgorithmValidationProfile[];
}
function fromAlgorithmValidationSpecification(input?: AlgorithmValidationSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ValidationRole: input["ValidationRole"],
    ValidationProfiles: input["ValidationProfiles"]?.map(x => fromAlgorithmValidationProfile(x)),
  }
}
function toAlgorithmValidationSpecification(root: jsonP.JSONValue): AlgorithmValidationSpecification {
  return jsonP.readObj({
    required: {
      "ValidationRole": "s",
      "ValidationProfiles": [toAlgorithmValidationProfile],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AlgorithmValidationProfile {
  ProfileName: string;
  TrainingJobDefinition: TrainingJobDefinition;
  TransformJobDefinition?: TransformJobDefinition | null;
}
function fromAlgorithmValidationProfile(input?: AlgorithmValidationProfile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProfileName: input["ProfileName"],
    TrainingJobDefinition: fromTrainingJobDefinition(input["TrainingJobDefinition"]),
    TransformJobDefinition: fromTransformJobDefinition(input["TransformJobDefinition"]),
  }
}
function toAlgorithmValidationProfile(root: jsonP.JSONValue): AlgorithmValidationProfile {
  return jsonP.readObj({
    required: {
      "ProfileName": "s",
      "TrainingJobDefinition": toTrainingJobDefinition,
    },
    optional: {
      "TransformJobDefinition": toTransformJobDefinition,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface TrainingJobDefinition {
  TrainingInputMode: TrainingInputMode;
  HyperParameters?: { [key: string]: string | null | undefined } | null;
  InputDataConfig: Channel[];
  OutputDataConfig: OutputDataConfig;
  ResourceConfig: ResourceConfig;
  StoppingCondition: StoppingCondition;
}
function fromTrainingJobDefinition(input?: TrainingJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingInputMode: input["TrainingInputMode"],
    HyperParameters: input["HyperParameters"],
    InputDataConfig: input["InputDataConfig"]?.map(x => fromChannel(x)),
    OutputDataConfig: fromOutputDataConfig(input["OutputDataConfig"]),
    ResourceConfig: fromResourceConfig(input["ResourceConfig"]),
    StoppingCondition: fromStoppingCondition(input["StoppingCondition"]),
  }
}
function toTrainingJobDefinition(root: jsonP.JSONValue): TrainingJobDefinition {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingInputMode>(x),
      "InputDataConfig": [toChannel],
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "StoppingCondition": toStoppingCondition,
    },
    optional: {
      "HyperParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface Channel {
  ChannelName: string;
  DataSource: DataSource;
  ContentType?: string | null;
  CompressionType?: CompressionType | null;
  RecordWrapperType?: RecordWrapper | null;
  InputMode?: TrainingInputMode | null;
  ShuffleConfig?: ShuffleConfig | null;
}
function fromChannel(input?: Channel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ChannelName: input["ChannelName"],
    DataSource: fromDataSource(input["DataSource"]),
    ContentType: input["ContentType"],
    CompressionType: input["CompressionType"],
    RecordWrapperType: input["RecordWrapperType"],
    InputMode: input["InputMode"],
    ShuffleConfig: fromShuffleConfig(input["ShuffleConfig"]),
  }
}
function toChannel(root: jsonP.JSONValue): Channel {
  return jsonP.readObj({
    required: {
      "ChannelName": "s",
      "DataSource": toDataSource,
    },
    optional: {
      "ContentType": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionType>(x),
      "RecordWrapperType": (x: jsonP.JSONValue) => cmnP.readEnum<RecordWrapper>(x),
      "InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingInputMode>(x),
      "ShuffleConfig": toShuffleConfig,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface DataSource {
  S3DataSource?: S3DataSource | null;
  FileSystemDataSource?: FileSystemDataSource | null;
}
function fromDataSource(input?: DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromS3DataSource(input["S3DataSource"]),
    FileSystemDataSource: fromFileSystemDataSource(input["FileSystemDataSource"]),
  }
}
function toDataSource(root: jsonP.JSONValue): DataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3DataSource": toS3DataSource,
      "FileSystemDataSource": toFileSystemDataSource,
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface S3DataSource {
  S3DataType: S3DataType;
  S3Uri: string;
  S3DataDistributionType?: S3DataDistribution | null;
  AttributeNames?: string[] | null;
}
function fromS3DataSource(input?: S3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
    S3DataDistributionType: input["S3DataDistributionType"],
    AttributeNames: input["AttributeNames"],
  }
}
function toS3DataSource(root: jsonP.JSONValue): S3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<S3DataType>(x),
      "S3Uri": "s",
    },
    optional: {
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<S3DataDistribution>(x),
      "AttributeNames": ["s"],
    },
  }, root);
}

// refs: 17 - tags: input, named, enum, output
export type S3DataType =
| "ManifestFile"
| "S3Prefix"
| "AugmentedManifestFile"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type S3DataDistribution =
| "FullyReplicated"
| "ShardedByS3Key"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface FileSystemDataSource {
  FileSystemId: string;
  FileSystemAccessMode: FileSystemAccessMode;
  FileSystemType: FileSystemType;
  DirectoryPath: string;
}
function fromFileSystemDataSource(input?: FileSystemDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FileSystemId: input["FileSystemId"],
    FileSystemAccessMode: input["FileSystemAccessMode"],
    FileSystemType: input["FileSystemType"],
    DirectoryPath: input["DirectoryPath"],
  }
}
function toFileSystemDataSource(root: jsonP.JSONValue): FileSystemDataSource {
  return jsonP.readObj({
    required: {
      "FileSystemId": "s",
      "FileSystemAccessMode": (x: jsonP.JSONValue) => cmnP.readEnum<FileSystemAccessMode>(x),
      "FileSystemType": (x: jsonP.JSONValue) => cmnP.readEnum<FileSystemType>(x),
      "DirectoryPath": "s",
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type FileSystemAccessMode =
| "rw"
| "ro"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type FileSystemType =
| "EFS"
| "FSxLustre"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, enum, output
export type RecordWrapper =
| "None"
| "RecordIO"
| cmnP.UnexpectedEnumValue;

// refs: 10 - tags: input, named, interface, output
export interface ShuffleConfig {
  Seed: number;
}
function fromShuffleConfig(input?: ShuffleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Seed: input["Seed"],
  }
}
function toShuffleConfig(root: jsonP.JSONValue): ShuffleConfig {
  return jsonP.readObj({
    required: {
      "Seed": "n",
    },
    optional: {},
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface OutputDataConfig {
  KmsKeyId?: string | null;
  S3OutputPath: string;
}
function fromOutputDataConfig(input?: OutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsKeyId: input["KmsKeyId"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toOutputDataConfig(root: jsonP.JSONValue): OutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface ResourceConfig {
  InstanceType: TrainingInstanceType;
  InstanceCount: number;
  VolumeSizeInGB: number;
  VolumeKmsKeyId?: string | null;
}
function fromResourceConfig(input?: ResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toResourceConfig(root: jsonP.JSONValue): ResourceConfig {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingInstanceType>(x),
      "InstanceCount": "n",
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

// refs: 12 - tags: input, named, interface, output
export interface StoppingCondition {
  MaxRuntimeInSeconds?: number | null;
  MaxWaitTimeInSeconds?: number | null;
}
function fromStoppingCondition(input?: StoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
    MaxWaitTimeInSeconds: input["MaxWaitTimeInSeconds"],
  }
}
function toStoppingCondition(root: jsonP.JSONValue): StoppingCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxRuntimeInSeconds": "n",
      "MaxWaitTimeInSeconds": "n",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface TransformJobDefinition {
  MaxConcurrentTransforms?: number | null;
  MaxPayloadInMB?: number | null;
  BatchStrategy?: BatchStrategy | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  TransformInput: TransformInput;
  TransformOutput: TransformOutput;
  TransformResources: TransformResources;
}
function fromTransformJobDefinition(input?: TransformJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxConcurrentTransforms: input["MaxConcurrentTransforms"],
    MaxPayloadInMB: input["MaxPayloadInMB"],
    BatchStrategy: input["BatchStrategy"],
    Environment: input["Environment"],
    TransformInput: fromTransformInput(input["TransformInput"]),
    TransformOutput: fromTransformOutput(input["TransformOutput"]),
    TransformResources: fromTransformResources(input["TransformResources"]),
  }
}
function toTransformJobDefinition(root: jsonP.JSONValue): TransformJobDefinition {
  return jsonP.readObj({
    required: {
      "TransformInput": toTransformInput,
      "TransformOutput": toTransformOutput,
      "TransformResources": toTransformResources,
    },
    optional: {
      "MaxConcurrentTransforms": "n",
      "MaxPayloadInMB": "n",
      "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<BatchStrategy>(x),
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type BatchStrategy =
| "MultiRecord"
| "SingleRecord"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface TransformInput {
  DataSource: TransformDataSource;
  ContentType?: string | null;
  CompressionType?: CompressionType | null;
  SplitType?: SplitType | null;
}
function fromTransformInput(input?: TransformInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromTransformDataSource(input["DataSource"]),
    ContentType: input["ContentType"],
    CompressionType: input["CompressionType"],
    SplitType: input["SplitType"],
  }
}
function toTransformInput(root: jsonP.JSONValue): TransformInput {
  return jsonP.readObj({
    required: {
      "DataSource": toTransformDataSource,
    },
    optional: {
      "ContentType": "s",
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionType>(x),
      "SplitType": (x: jsonP.JSONValue) => cmnP.readEnum<SplitType>(x),
    },
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface TransformDataSource {
  S3DataSource: TransformS3DataSource;
}
function fromTransformDataSource(input?: TransformDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromTransformS3DataSource(input["S3DataSource"]),
  }
}
function toTransformDataSource(root: jsonP.JSONValue): TransformDataSource {
  return jsonP.readObj({
    required: {
      "S3DataSource": toTransformS3DataSource,
    },
    optional: {},
  }, root);
}

// refs: 7 - tags: input, named, interface, output
export interface TransformS3DataSource {
  S3DataType: S3DataType;
  S3Uri: string;
}
function fromTransformS3DataSource(input?: TransformS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
  }
}
function toTransformS3DataSource(root: jsonP.JSONValue): TransformS3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<S3DataType>(x),
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type SplitType =
| "None"
| "Line"
| "RecordIO"
| "TFRecord"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface TransformOutput {
  S3OutputPath: string;
  Accept?: string | null;
  AssembleWith?: AssemblyType | null;
  KmsKeyId?: string | null;
}
function fromTransformOutput(input?: TransformOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    Accept: input["Accept"],
    AssembleWith: input["AssembleWith"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toTransformOutput(root: jsonP.JSONValue): TransformOutput {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "Accept": "s",
      "AssembleWith": (x: jsonP.JSONValue) => cmnP.readEnum<AssemblyType>(x),
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 7 - tags: input, named, enum, output
export type AssemblyType =
| "None"
| "Line"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface TransformResources {
  InstanceType: TransformInstanceType;
  InstanceCount: number;
  VolumeKmsKeyId?: string | null;
}
function fromTransformResources(input?: TransformResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceType: input["InstanceType"],
    InstanceCount: input["InstanceCount"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toTransformResources(root: jsonP.JSONValue): TransformResources {
  return jsonP.readObj({
    required: {
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<TransformInstanceType>(x),
      "InstanceCount": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type AppType =
| "JupyterServer"
| "KernelGateway"
| "TensorBoard"
| cmnP.UnexpectedEnumValue;

// refs: 20 - tags: input, named, interface, output
export interface ResourceSpec {
  SageMakerImageArn?: string | null;
  SageMakerImageVersionArn?: string | null;
  InstanceType?: AppInstanceType | null;
}
function fromResourceSpec(input?: ResourceSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SageMakerImageArn: input["SageMakerImageArn"],
    SageMakerImageVersionArn: input["SageMakerImageVersionArn"],
    InstanceType: input["InstanceType"],
  }
}
function toResourceSpec(root: jsonP.JSONValue): ResourceSpec {
  return jsonP.readObj({
    required: {},
    optional: {
      "SageMakerImageArn": "s",
      "SageMakerImageVersionArn": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<AppInstanceType>(x),
    },
  }, root);
}

// refs: 20 - tags: input, named, enum, output
export type AppInstanceType =
| "system"
| "ml.t3.micro"
| "ml.t3.small"
| "ml.t3.medium"
| "ml.t3.large"
| "ml.t3.xlarge"
| "ml.t3.2xlarge"
| "ml.m5.large"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.8xlarge"
| "ml.m5.12xlarge"
| "ml.m5.16xlarge"
| "ml.m5.24xlarge"
| "ml.c5.large"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.12xlarge"
| "ml.c5.18xlarge"
| "ml.c5.24xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| "ml.g4dn.xlarge"
| "ml.g4dn.2xlarge"
| "ml.g4dn.4xlarge"
| "ml.g4dn.8xlarge"
| "ml.g4dn.12xlarge"
| "ml.g4dn.16xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface KernelGatewayImageConfig {
  KernelSpecs: KernelSpec[];
  FileSystemConfig?: FileSystemConfig | null;
}
function fromKernelGatewayImageConfig(input?: KernelGatewayImageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KernelSpecs: input["KernelSpecs"]?.map(x => fromKernelSpec(x)),
    FileSystemConfig: fromFileSystemConfig(input["FileSystemConfig"]),
  }
}
function toKernelGatewayImageConfig(root: jsonP.JSONValue): KernelGatewayImageConfig {
  return jsonP.readObj({
    required: {
      "KernelSpecs": [toKernelSpec],
    },
    optional: {
      "FileSystemConfig": toFileSystemConfig,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface KernelSpec {
  Name: string;
  DisplayName?: string | null;
}
function fromKernelSpec(input?: KernelSpec | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    DisplayName: input["DisplayName"],
  }
}
function toKernelSpec(root: jsonP.JSONValue): KernelSpec {
  return jsonP.readObj({
    required: {
      "Name": "s",
    },
    optional: {
      "DisplayName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface FileSystemConfig {
  MountPath?: string | null;
  DefaultUid?: number | null;
  DefaultGid?: number | null;
}
function fromFileSystemConfig(input?: FileSystemConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MountPath: input["MountPath"],
    DefaultUid: input["DefaultUid"],
    DefaultGid: input["DefaultGid"],
  }
}
function toFileSystemConfig(root: jsonP.JSONValue): FileSystemConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "MountPath": "s",
      "DefaultUid": "n",
      "DefaultGid": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AutoMLChannel {
  DataSource: AutoMLDataSource;
  CompressionType?: CompressionType | null;
  TargetAttributeName: string;
}
function fromAutoMLChannel(input?: AutoMLChannel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromAutoMLDataSource(input["DataSource"]),
    CompressionType: input["CompressionType"],
    TargetAttributeName: input["TargetAttributeName"],
  }
}
function toAutoMLChannel(root: jsonP.JSONValue): AutoMLChannel {
  return jsonP.readObj({
    required: {
      "DataSource": toAutoMLDataSource,
      "TargetAttributeName": "s",
    },
    optional: {
      "CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<CompressionType>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AutoMLDataSource {
  S3DataSource: AutoMLS3DataSource;
}
function fromAutoMLDataSource(input?: AutoMLDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromAutoMLS3DataSource(input["S3DataSource"]),
  }
}
function toAutoMLDataSource(root: jsonP.JSONValue): AutoMLDataSource {
  return jsonP.readObj({
    required: {
      "S3DataSource": toAutoMLS3DataSource,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AutoMLS3DataSource {
  S3DataType: AutoMLS3DataType;
  S3Uri: string;
}
function fromAutoMLS3DataSource(input?: AutoMLS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataType: input["S3DataType"],
    S3Uri: input["S3Uri"],
  }
}
function toAutoMLS3DataSource(root: jsonP.JSONValue): AutoMLS3DataSource {
  return jsonP.readObj({
    required: {
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLS3DataType>(x),
      "S3Uri": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type AutoMLS3DataType =
| "ManifestFile"
| "S3Prefix"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface AutoMLOutputDataConfig {
  KmsKeyId?: string | null;
  S3OutputPath: string;
}
function fromAutoMLOutputDataConfig(input?: AutoMLOutputDataConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    KmsKeyId: input["KmsKeyId"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toAutoMLOutputDataConfig(root: jsonP.JSONValue): AutoMLOutputDataConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ProblemType =
| "BinaryClassification"
| "MulticlassClassification"
| "Regression"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface AutoMLJobObjective {
  MetricName: AutoMLMetricEnum;
}
function fromAutoMLJobObjective(input?: AutoMLJobObjective | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MetricName: input["MetricName"],
  }
}
function toAutoMLJobObjective(root: jsonP.JSONValue): AutoMLJobObjective {
  return jsonP.readObj({
    required: {
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLMetricEnum>(x),
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type AutoMLMetricEnum =
| "Accuracy"
| "MSE"
| "F1"
| "F1macro"
| "AUC"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface AutoMLJobConfig {
  CompletionCriteria?: AutoMLJobCompletionCriteria | null;
  SecurityConfig?: AutoMLSecurityConfig | null;
}
function fromAutoMLJobConfig(input?: AutoMLJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CompletionCriteria: fromAutoMLJobCompletionCriteria(input["CompletionCriteria"]),
    SecurityConfig: fromAutoMLSecurityConfig(input["SecurityConfig"]),
  }
}
function toAutoMLJobConfig(root: jsonP.JSONValue): AutoMLJobConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "CompletionCriteria": toAutoMLJobCompletionCriteria,
      "SecurityConfig": toAutoMLSecurityConfig,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface AutoMLJobCompletionCriteria {
  MaxCandidates?: number | null;
  MaxRuntimePerTrainingJobInSeconds?: number | null;
  MaxAutoMLJobRuntimeInSeconds?: number | null;
}
function fromAutoMLJobCompletionCriteria(input?: AutoMLJobCompletionCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxCandidates: input["MaxCandidates"],
    MaxRuntimePerTrainingJobInSeconds: input["MaxRuntimePerTrainingJobInSeconds"],
    MaxAutoMLJobRuntimeInSeconds: input["MaxAutoMLJobRuntimeInSeconds"],
  }
}
function toAutoMLJobCompletionCriteria(root: jsonP.JSONValue): AutoMLJobCompletionCriteria {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxCandidates": "n",
      "MaxRuntimePerTrainingJobInSeconds": "n",
      "MaxAutoMLJobRuntimeInSeconds": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AutoMLSecurityConfig {
  VolumeKmsKeyId?: string | null;
  EnableInterContainerTrafficEncryption?: boolean | null;
  VpcConfig?: VpcConfig | null;
}
function fromAutoMLSecurityConfig(input?: AutoMLSecurityConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
  }
}
function toAutoMLSecurityConfig(root: jsonP.JSONValue): AutoMLSecurityConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeKmsKeyId": "s",
      "EnableInterContainerTrafficEncryption": "b",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

// refs: 18 - tags: input, named, interface, output
export interface VpcConfig {
  SecurityGroupIds: string[];
  Subnets: string[];
}
function fromVpcConfig(input?: VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecurityGroupIds: input["SecurityGroupIds"],
    Subnets: input["Subnets"],
  }
}
function toVpcConfig(root: jsonP.JSONValue): VpcConfig {
  return jsonP.readObj({
    required: {
      "SecurityGroupIds": ["s"],
      "Subnets": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface GitConfig {
  RepositoryUrl: string;
  Branch?: string | null;
  SecretArn?: string | null;
}
function fromGitConfig(input?: GitConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RepositoryUrl: input["RepositoryUrl"],
    Branch: input["Branch"],
    SecretArn: input["SecretArn"],
  }
}
function toGitConfig(root: jsonP.JSONValue): GitConfig {
  return jsonP.readObj({
    required: {
      "RepositoryUrl": "s",
    },
    optional: {
      "Branch": "s",
      "SecretArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface InputConfig {
  S3Uri: string;
  DataInputConfig: string;
  Framework: Framework;
}
function fromInputConfig(input?: InputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    DataInputConfig: input["DataInputConfig"],
    Framework: input["Framework"],
  }
}
function toInputConfig(root: jsonP.JSONValue): InputConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "DataInputConfig": "s",
      "Framework": (x: jsonP.JSONValue) => cmnP.readEnum<Framework>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type Framework =
| "TENSORFLOW"
| "KERAS"
| "MXNET"
| "ONNX"
| "PYTORCH"
| "XGBOOST"
| "TFLITE"
| "DARKNET"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface OutputConfig {
  S3OutputLocation: string;
  TargetDevice?: TargetDevice | null;
  TargetPlatform?: TargetPlatform | null;
  CompilerOptions?: string | null;
}
function fromOutputConfig(input?: OutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputLocation: input["S3OutputLocation"],
    TargetDevice: input["TargetDevice"],
    TargetPlatform: fromTargetPlatform(input["TargetPlatform"]),
    CompilerOptions: input["CompilerOptions"],
  }
}
function toOutputConfig(root: jsonP.JSONValue): OutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputLocation": "s",
    },
    optional: {
      "TargetDevice": (x: jsonP.JSONValue) => cmnP.readEnum<TargetDevice>(x),
      "TargetPlatform": toTargetPlatform,
      "CompilerOptions": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type TargetDevice =
| "lambda"
| "ml_m4"
| "ml_m5"
| "ml_c4"
| "ml_c5"
| "ml_p2"
| "ml_p3"
| "ml_g4dn"
| "ml_inf1"
| "jetson_tx1"
| "jetson_tx2"
| "jetson_nano"
| "jetson_xavier"
| "rasp3b"
| "imx8qm"
| "deeplens"
| "rk3399"
| "rk3288"
| "aisage"
| "sbe_c"
| "qcs605"
| "qcs603"
| "sitara_am57x"
| "amba_cv22"
| "x86_win32"
| "x86_win64"
| "coreml"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface TargetPlatform {
  Os: TargetPlatformOs;
  Arch: TargetPlatformArch;
  Accelerator?: TargetPlatformAccelerator | null;
}
function fromTargetPlatform(input?: TargetPlatform | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Os: input["Os"],
    Arch: input["Arch"],
    Accelerator: input["Accelerator"],
  }
}
function toTargetPlatform(root: jsonP.JSONValue): TargetPlatform {
  return jsonP.readObj({
    required: {
      "Os": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformOs>(x),
      "Arch": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformArch>(x),
    },
    optional: {
      "Accelerator": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformAccelerator>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type TargetPlatformOs =
| "ANDROID"
| "LINUX"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type TargetPlatformArch =
| "X86_64"
| "X86"
| "ARM64"
| "ARM_EABI"
| "ARM_EABIHF"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type TargetPlatformAccelerator =
| "INTEL_GRAPHICS"
| "MALI"
| "NVIDIA"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type AuthMode =
| "SSO"
| "IAM"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface UserSettings {
  ExecutionRole?: string | null;
  SecurityGroups?: string[] | null;
  SharingSettings?: SharingSettings | null;
  JupyterServerAppSettings?: JupyterServerAppSettings | null;
  KernelGatewayAppSettings?: KernelGatewayAppSettings | null;
  TensorBoardAppSettings?: TensorBoardAppSettings | null;
}
function fromUserSettings(input?: UserSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExecutionRole: input["ExecutionRole"],
    SecurityGroups: input["SecurityGroups"],
    SharingSettings: fromSharingSettings(input["SharingSettings"]),
    JupyterServerAppSettings: fromJupyterServerAppSettings(input["JupyterServerAppSettings"]),
    KernelGatewayAppSettings: fromKernelGatewayAppSettings(input["KernelGatewayAppSettings"]),
    TensorBoardAppSettings: fromTensorBoardAppSettings(input["TensorBoardAppSettings"]),
  }
}
function toUserSettings(root: jsonP.JSONValue): UserSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExecutionRole": "s",
      "SecurityGroups": ["s"],
      "SharingSettings": toSharingSettings,
      "JupyterServerAppSettings": toJupyterServerAppSettings,
      "KernelGatewayAppSettings": toKernelGatewayAppSettings,
      "TensorBoardAppSettings": toTensorBoardAppSettings,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface SharingSettings {
  NotebookOutputOption?: NotebookOutputOption | null;
  S3OutputPath?: string | null;
  S3KmsKeyId?: string | null;
}
function fromSharingSettings(input?: SharingSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotebookOutputOption: input["NotebookOutputOption"],
    S3OutputPath: input["S3OutputPath"],
    S3KmsKeyId: input["S3KmsKeyId"],
  }
}
function toSharingSettings(root: jsonP.JSONValue): SharingSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotebookOutputOption": (x: jsonP.JSONValue) => cmnP.readEnum<NotebookOutputOption>(x),
      "S3OutputPath": "s",
      "S3KmsKeyId": "s",
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type NotebookOutputOption =
| "Allowed"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface JupyterServerAppSettings {
  DefaultResourceSpec?: ResourceSpec | null;
}
function fromJupyterServerAppSettings(input?: JupyterServerAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
  }
}
function toJupyterServerAppSettings(root: jsonP.JSONValue): JupyterServerAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface KernelGatewayAppSettings {
  DefaultResourceSpec?: ResourceSpec | null;
  CustomImages?: CustomImage[] | null;
}
function fromKernelGatewayAppSettings(input?: KernelGatewayAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
    CustomImages: input["CustomImages"]?.map(x => fromCustomImage(x)),
  }
}
function toKernelGatewayAppSettings(root: jsonP.JSONValue): KernelGatewayAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
      "CustomImages": [toCustomImage],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface CustomImage {
  ImageName: string;
  ImageVersionNumber?: number | null;
  AppImageConfigName: string;
}
function fromCustomImage(input?: CustomImage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageName: input["ImageName"],
    ImageVersionNumber: input["ImageVersionNumber"],
    AppImageConfigName: input["AppImageConfigName"],
  }
}
function toCustomImage(root: jsonP.JSONValue): CustomImage {
  return jsonP.readObj({
    required: {
      "ImageName": "s",
      "AppImageConfigName": "s",
    },
    optional: {
      "ImageVersionNumber": "n",
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface TensorBoardAppSettings {
  DefaultResourceSpec?: ResourceSpec | null;
}
function fromTensorBoardAppSettings(input?: TensorBoardAppSettings | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultResourceSpec: fromResourceSpec(input["DefaultResourceSpec"]),
  }
}
function toTensorBoardAppSettings(root: jsonP.JSONValue): TensorBoardAppSettings {
  return jsonP.readObj({
    required: {},
    optional: {
      "DefaultResourceSpec": toResourceSpec,
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type AppNetworkAccessType =
| "PublicInternetOnly"
| "VpcOnly"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ProductionVariant {
  VariantName: string;
  ModelName: string;
  InitialInstanceCount: number;
  InstanceType: ProductionVariantInstanceType;
  InitialVariantWeight?: number | null;
  AcceleratorType?: ProductionVariantAcceleratorType | null;
}
function fromProductionVariant(input?: ProductionVariant | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantName: input["VariantName"],
    ModelName: input["ModelName"],
    InitialInstanceCount: input["InitialInstanceCount"],
    InstanceType: input["InstanceType"],
    InitialVariantWeight: input["InitialVariantWeight"],
    AcceleratorType: input["AcceleratorType"],
  }
}
function toProductionVariant(root: jsonP.JSONValue): ProductionVariant {
  return jsonP.readObj({
    required: {
      "VariantName": "s",
      "ModelName": "s",
      "InitialInstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ProductionVariantInstanceType>(x),
    },
    optional: {
      "InitialVariantWeight": "n",
      "AcceleratorType": (x: jsonP.JSONValue) => cmnP.readEnum<ProductionVariantAcceleratorType>(x),
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type ProductionVariantAcceleratorType =
| "ml.eia1.medium"
| "ml.eia1.large"
| "ml.eia1.xlarge"
| "ml.eia2.medium"
| "ml.eia2.large"
| "ml.eia2.xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface DataCaptureConfig {
  EnableCapture?: boolean | null;
  InitialSamplingPercentage: number;
  DestinationS3Uri: string;
  KmsKeyId?: string | null;
  CaptureOptions: CaptureOption[];
  CaptureContentTypeHeader?: CaptureContentTypeHeader | null;
}
function fromDataCaptureConfig(input?: DataCaptureConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnableCapture: input["EnableCapture"],
    InitialSamplingPercentage: input["InitialSamplingPercentage"],
    DestinationS3Uri: input["DestinationS3Uri"],
    KmsKeyId: input["KmsKeyId"],
    CaptureOptions: input["CaptureOptions"]?.map(x => fromCaptureOption(x)),
    CaptureContentTypeHeader: fromCaptureContentTypeHeader(input["CaptureContentTypeHeader"]),
  }
}
function toDataCaptureConfig(root: jsonP.JSONValue): DataCaptureConfig {
  return jsonP.readObj({
    required: {
      "InitialSamplingPercentage": "n",
      "DestinationS3Uri": "s",
      "CaptureOptions": [toCaptureOption],
    },
    optional: {
      "EnableCapture": "b",
      "KmsKeyId": "s",
      "CaptureContentTypeHeader": toCaptureContentTypeHeader,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface CaptureOption {
  CaptureMode: CaptureMode;
}
function fromCaptureOption(input?: CaptureOption | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CaptureMode: input["CaptureMode"],
  }
}
function toCaptureOption(root: jsonP.JSONValue): CaptureOption {
  return jsonP.readObj({
    required: {
      "CaptureMode": (x: jsonP.JSONValue) => cmnP.readEnum<CaptureMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type CaptureMode =
| "Input"
| "Output"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface CaptureContentTypeHeader {
  CsvContentTypes?: string[] | null;
  JsonContentTypes?: string[] | null;
}
function fromCaptureContentTypeHeader(input?: CaptureContentTypeHeader | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CsvContentTypes: input["CsvContentTypes"],
    JsonContentTypes: input["JsonContentTypes"],
  }
}
function toCaptureContentTypeHeader(root: jsonP.JSONValue): CaptureContentTypeHeader {
  return jsonP.readObj({
    required: {},
    optional: {
      "CsvContentTypes": ["s"],
      "JsonContentTypes": ["s"],
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HumanLoopRequestSource {
  AwsManagedHumanLoopRequestSource: AwsManagedHumanLoopRequestSource;
}
function fromHumanLoopRequestSource(input?: HumanLoopRequestSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AwsManagedHumanLoopRequestSource: input["AwsManagedHumanLoopRequestSource"],
  }
}
function toHumanLoopRequestSource(root: jsonP.JSONValue): HumanLoopRequestSource {
  return jsonP.readObj({
    required: {
      "AwsManagedHumanLoopRequestSource": (x: jsonP.JSONValue) => cmnP.readEnum<AwsManagedHumanLoopRequestSource>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type AwsManagedHumanLoopRequestSource =
| "AWS/Rekognition/DetectModerationLabels/Image/V3"
| "AWS/Textract/AnalyzeDocument/Forms/V1"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface HumanLoopActivationConfig {
  HumanLoopActivationConditionsConfig: HumanLoopActivationConditionsConfig;
}
function fromHumanLoopActivationConfig(input?: HumanLoopActivationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopActivationConditionsConfig: fromHumanLoopActivationConditionsConfig(input["HumanLoopActivationConditionsConfig"]),
  }
}
function toHumanLoopActivationConfig(root: jsonP.JSONValue): HumanLoopActivationConfig {
  return jsonP.readObj({
    required: {
      "HumanLoopActivationConditionsConfig": toHumanLoopActivationConditionsConfig,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HumanLoopActivationConditionsConfig {
  HumanLoopActivationConditions: jsonP.JSONValue;
}
function fromHumanLoopActivationConditionsConfig(input?: HumanLoopActivationConditionsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopActivationConditions: jsonP.serializeJsonValue(input["HumanLoopActivationConditions"]),
  }
}
function toHumanLoopActivationConditionsConfig(root: jsonP.JSONValue): HumanLoopActivationConditionsConfig {
  return jsonP.readObj({
    required: {
      "HumanLoopActivationConditions": jsonP.readJsonValue,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HumanLoopConfig {
  WorkteamArn: string;
  HumanTaskUiArn: string;
  TaskTitle: string;
  TaskDescription: string;
  TaskCount: number;
  TaskAvailabilityLifetimeInSeconds?: number | null;
  TaskTimeLimitInSeconds?: number | null;
  TaskKeywords?: string[] | null;
  PublicWorkforceTaskPrice?: PublicWorkforceTaskPrice | null;
}
function fromHumanLoopConfig(input?: HumanLoopConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WorkteamArn: input["WorkteamArn"],
    HumanTaskUiArn: input["HumanTaskUiArn"],
    TaskTitle: input["TaskTitle"],
    TaskDescription: input["TaskDescription"],
    TaskCount: input["TaskCount"],
    TaskAvailabilityLifetimeInSeconds: input["TaskAvailabilityLifetimeInSeconds"],
    TaskTimeLimitInSeconds: input["TaskTimeLimitInSeconds"],
    TaskKeywords: input["TaskKeywords"],
    PublicWorkforceTaskPrice: fromPublicWorkforceTaskPrice(input["PublicWorkforceTaskPrice"]),
  }
}
function toHumanLoopConfig(root: jsonP.JSONValue): HumanLoopConfig {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
      "HumanTaskUiArn": "s",
      "TaskTitle": "s",
      "TaskDescription": "s",
      "TaskCount": "n",
    },
    optional: {
      "TaskAvailabilityLifetimeInSeconds": "n",
      "TaskTimeLimitInSeconds": "n",
      "TaskKeywords": ["s"],
      "PublicWorkforceTaskPrice": toPublicWorkforceTaskPrice,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface PublicWorkforceTaskPrice {
  AmountInUsd?: USD | null;
}
function fromPublicWorkforceTaskPrice(input?: PublicWorkforceTaskPrice | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AmountInUsd: fromUSD(input["AmountInUsd"]),
  }
}
function toPublicWorkforceTaskPrice(root: jsonP.JSONValue): PublicWorkforceTaskPrice {
  return jsonP.readObj({
    required: {},
    optional: {
      "AmountInUsd": toUSD,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface USD {
  Dollars?: number | null;
  Cents?: number | null;
  TenthFractionsOfACent?: number | null;
}
function fromUSD(input?: USD | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dollars: input["Dollars"],
    Cents: input["Cents"],
    TenthFractionsOfACent: input["TenthFractionsOfACent"],
  }
}
function toUSD(root: jsonP.JSONValue): USD {
  return jsonP.readObj({
    required: {},
    optional: {
      "Dollars": "n",
      "Cents": "n",
      "TenthFractionsOfACent": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface FlowDefinitionOutputConfig {
  S3OutputPath: string;
  KmsKeyId?: string | null;
}
function fromFlowDefinitionOutputConfig(input?: FlowDefinitionOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    KmsKeyId: input["KmsKeyId"],
  }
}
function toFlowDefinitionOutputConfig(root: jsonP.JSONValue): FlowDefinitionOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface UiTemplate {
  Content: string;
}
function fromUiTemplate(input?: UiTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Content: input["Content"],
  }
}

// refs: 2 - tags: input, named, interface, output
export interface HyperParameterTuningJobConfig {
  Strategy: HyperParameterTuningJobStrategyType;
  HyperParameterTuningJobObjective?: HyperParameterTuningJobObjective | null;
  ResourceLimits: ResourceLimits;
  ParameterRanges?: ParameterRanges | null;
  TrainingJobEarlyStoppingType?: TrainingJobEarlyStoppingType | null;
  TuningJobCompletionCriteria?: TuningJobCompletionCriteria | null;
}
function fromHyperParameterTuningJobConfig(input?: HyperParameterTuningJobConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Strategy: input["Strategy"],
    HyperParameterTuningJobObjective: fromHyperParameterTuningJobObjective(input["HyperParameterTuningJobObjective"]),
    ResourceLimits: fromResourceLimits(input["ResourceLimits"]),
    ParameterRanges: fromParameterRanges(input["ParameterRanges"]),
    TrainingJobEarlyStoppingType: input["TrainingJobEarlyStoppingType"],
    TuningJobCompletionCriteria: fromTuningJobCompletionCriteria(input["TuningJobCompletionCriteria"]),
  }
}
function toHyperParameterTuningJobConfig(root: jsonP.JSONValue): HyperParameterTuningJobConfig {
  return jsonP.readObj({
    required: {
      "Strategy": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobStrategyType>(x),
      "ResourceLimits": toResourceLimits,
    },
    optional: {
      "HyperParameterTuningJobObjective": toHyperParameterTuningJobObjective,
      "ParameterRanges": toParameterRanges,
      "TrainingJobEarlyStoppingType": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingJobEarlyStoppingType>(x),
      "TuningJobCompletionCriteria": toTuningJobCompletionCriteria,
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type HyperParameterTuningJobStrategyType =
| "Bayesian"
| "Random"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ResourceLimits {
  MaxNumberOfTrainingJobs: number;
  MaxParallelTrainingJobs: number;
}
function fromResourceLimits(input?: ResourceLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxNumberOfTrainingJobs: input["MaxNumberOfTrainingJobs"],
    MaxParallelTrainingJobs: input["MaxParallelTrainingJobs"],
  }
}
function toResourceLimits(root: jsonP.JSONValue): ResourceLimits {
  return jsonP.readObj({
    required: {
      "MaxNumberOfTrainingJobs": "n",
      "MaxParallelTrainingJobs": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface ParameterRanges {
  IntegerParameterRanges?: IntegerParameterRange[] | null;
  ContinuousParameterRanges?: ContinuousParameterRange[] | null;
  CategoricalParameterRanges?: CategoricalParameterRange[] | null;
}
function fromParameterRanges(input?: ParameterRanges | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IntegerParameterRanges: input["IntegerParameterRanges"]?.map(x => fromIntegerParameterRange(x)),
    ContinuousParameterRanges: input["ContinuousParameterRanges"]?.map(x => fromContinuousParameterRange(x)),
    CategoricalParameterRanges: input["CategoricalParameterRanges"]?.map(x => fromCategoricalParameterRange(x)),
  }
}
function toParameterRanges(root: jsonP.JSONValue): ParameterRanges {
  return jsonP.readObj({
    required: {},
    optional: {
      "IntegerParameterRanges": [toIntegerParameterRange],
      "ContinuousParameterRanges": [toContinuousParameterRange],
      "CategoricalParameterRanges": [toCategoricalParameterRange],
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface IntegerParameterRange {
  Name: string;
  MinValue: string;
  MaxValue: string;
  ScalingType?: HyperParameterScalingType | null;
}
function fromIntegerParameterRange(input?: IntegerParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
    ScalingType: input["ScalingType"],
  }
}
function toIntegerParameterRange(root: jsonP.JSONValue): IntegerParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterScalingType>(x),
    },
  }, root);
}

// refs: 12 - tags: input, named, enum, output
export type HyperParameterScalingType =
| "Auto"
| "Linear"
| "Logarithmic"
| "ReverseLogarithmic"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface ContinuousParameterRange {
  Name: string;
  MinValue: string;
  MaxValue: string;
  ScalingType?: HyperParameterScalingType | null;
}
function fromContinuousParameterRange(input?: ContinuousParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    MinValue: input["MinValue"],
    MaxValue: input["MaxValue"],
    ScalingType: input["ScalingType"],
  }
}
function toContinuousParameterRange(root: jsonP.JSONValue): ContinuousParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "MinValue": "s",
      "MaxValue": "s",
    },
    optional: {
      "ScalingType": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterScalingType>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface CategoricalParameterRange {
  Name: string;
  Values: string[];
}
function fromCategoricalParameterRange(input?: CategoricalParameterRange | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Values: input["Values"],
  }
}
function toCategoricalParameterRange(root: jsonP.JSONValue): CategoricalParameterRange {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Values": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type TrainingJobEarlyStoppingType =
| "Off"
| "Auto"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface TuningJobCompletionCriteria {
  TargetObjectiveMetricValue: number;
}
function fromTuningJobCompletionCriteria(input?: TuningJobCompletionCriteria | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetObjectiveMetricValue: input["TargetObjectiveMetricValue"],
  }
}
function toTuningJobCompletionCriteria(root: jsonP.JSONValue): TuningJobCompletionCriteria {
  return jsonP.readObj({
    required: {
      "TargetObjectiveMetricValue": "n",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface HyperParameterTrainingJobDefinition {
  DefinitionName?: string | null;
  TuningObjective?: HyperParameterTuningJobObjective | null;
  HyperParameterRanges?: ParameterRanges | null;
  StaticHyperParameters?: { [key: string]: string | null | undefined } | null;
  AlgorithmSpecification: HyperParameterAlgorithmSpecification;
  RoleArn: string;
  InputDataConfig?: Channel[] | null;
  VpcConfig?: VpcConfig | null;
  OutputDataConfig: OutputDataConfig;
  ResourceConfig: ResourceConfig;
  StoppingCondition: StoppingCondition;
  EnableNetworkIsolation?: boolean | null;
  EnableInterContainerTrafficEncryption?: boolean | null;
  EnableManagedSpotTraining?: boolean | null;
  CheckpointConfig?: CheckpointConfig | null;
}
function fromHyperParameterTrainingJobDefinition(input?: HyperParameterTrainingJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefinitionName: input["DefinitionName"],
    TuningObjective: fromHyperParameterTuningJobObjective(input["TuningObjective"]),
    HyperParameterRanges: fromParameterRanges(input["HyperParameterRanges"]),
    StaticHyperParameters: input["StaticHyperParameters"],
    AlgorithmSpecification: fromHyperParameterAlgorithmSpecification(input["AlgorithmSpecification"]),
    RoleArn: input["RoleArn"],
    InputDataConfig: input["InputDataConfig"]?.map(x => fromChannel(x)),
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
    OutputDataConfig: fromOutputDataConfig(input["OutputDataConfig"]),
    ResourceConfig: fromResourceConfig(input["ResourceConfig"]),
    StoppingCondition: fromStoppingCondition(input["StoppingCondition"]),
    EnableNetworkIsolation: input["EnableNetworkIsolation"],
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    EnableManagedSpotTraining: input["EnableManagedSpotTraining"],
    CheckpointConfig: fromCheckpointConfig(input["CheckpointConfig"]),
  }
}
function toHyperParameterTrainingJobDefinition(root: jsonP.JSONValue): HyperParameterTrainingJobDefinition {
  return jsonP.readObj({
    required: {
      "AlgorithmSpecification": toHyperParameterAlgorithmSpecification,
      "RoleArn": "s",
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "StoppingCondition": toStoppingCondition,
    },
    optional: {
      "DefinitionName": "s",
      "TuningObjective": toHyperParameterTuningJobObjective,
      "HyperParameterRanges": toParameterRanges,
      "StaticHyperParameters": x => jsonP.readMap(String, String, x),
      "InputDataConfig": [toChannel],
      "VpcConfig": toVpcConfig,
      "EnableNetworkIsolation": "b",
      "EnableInterContainerTrafficEncryption": "b",
      "EnableManagedSpotTraining": "b",
      "CheckpointConfig": toCheckpointConfig,
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface HyperParameterAlgorithmSpecification {
  TrainingImage?: string | null;
  TrainingInputMode: TrainingInputMode;
  AlgorithmName?: string | null;
  MetricDefinitions?: MetricDefinition[] | null;
}
function fromHyperParameterAlgorithmSpecification(input?: HyperParameterAlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    TrainingInputMode: input["TrainingInputMode"],
    AlgorithmName: input["AlgorithmName"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
  }
}
function toHyperParameterAlgorithmSpecification(root: jsonP.JSONValue): HyperParameterAlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingInputMode>(x),
    },
    optional: {
      "TrainingImage": "s",
      "AlgorithmName": "s",
      "MetricDefinitions": [toMetricDefinition],
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface CheckpointConfig {
  S3Uri: string;
  LocalPath?: string | null;
}
function fromCheckpointConfig(input?: CheckpointConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
  }
}
function toCheckpointConfig(root: jsonP.JSONValue): CheckpointConfig {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
    },
    optional: {
      "LocalPath": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HyperParameterTuningJobWarmStartConfig {
  ParentHyperParameterTuningJobs: ParentHyperParameterTuningJob[];
  WarmStartType: HyperParameterTuningJobWarmStartType;
}
function fromHyperParameterTuningJobWarmStartConfig(input?: HyperParameterTuningJobWarmStartConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ParentHyperParameterTuningJobs: input["ParentHyperParameterTuningJobs"]?.map(x => fromParentHyperParameterTuningJob(x)),
    WarmStartType: input["WarmStartType"],
  }
}
function toHyperParameterTuningJobWarmStartConfig(root: jsonP.JSONValue): HyperParameterTuningJobWarmStartConfig {
  return jsonP.readObj({
    required: {
      "ParentHyperParameterTuningJobs": [toParentHyperParameterTuningJob],
      "WarmStartType": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobWarmStartType>(x),
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ParentHyperParameterTuningJob {
  HyperParameterTuningJobName?: string | null;
}
function fromParentHyperParameterTuningJob(input?: ParentHyperParameterTuningJob | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HyperParameterTuningJobName: input["HyperParameterTuningJobName"],
  }
}
function toParentHyperParameterTuningJob(root: jsonP.JSONValue): ParentHyperParameterTuningJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "HyperParameterTuningJobName": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, enum, output
export type HyperParameterTuningJobWarmStartType =
| "IdenticalDataAndAlgorithm"
| "TransferLearning"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface LabelingJobInputConfig {
  DataSource: LabelingJobDataSource;
  DataAttributes?: LabelingJobDataAttributes | null;
}
function fromLabelingJobInputConfig(input?: LabelingJobInputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DataSource: fromLabelingJobDataSource(input["DataSource"]),
    DataAttributes: fromLabelingJobDataAttributes(input["DataAttributes"]),
  }
}
function toLabelingJobInputConfig(root: jsonP.JSONValue): LabelingJobInputConfig {
  return jsonP.readObj({
    required: {
      "DataSource": toLabelingJobDataSource,
    },
    optional: {
      "DataAttributes": toLabelingJobDataAttributes,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LabelingJobDataSource {
  S3DataSource?: LabelingJobS3DataSource | null;
  SnsDataSource?: LabelingJobSnsDataSource | null;
}
function fromLabelingJobDataSource(input?: LabelingJobDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3DataSource: fromLabelingJobS3DataSource(input["S3DataSource"]),
    SnsDataSource: fromLabelingJobSnsDataSource(input["SnsDataSource"]),
  }
}
function toLabelingJobDataSource(root: jsonP.JSONValue): LabelingJobDataSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3DataSource": toLabelingJobS3DataSource,
      "SnsDataSource": toLabelingJobSnsDataSource,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LabelingJobS3DataSource {
  ManifestS3Uri: string;
}
function fromLabelingJobS3DataSource(input?: LabelingJobS3DataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ManifestS3Uri: input["ManifestS3Uri"],
  }
}
function toLabelingJobS3DataSource(root: jsonP.JSONValue): LabelingJobS3DataSource {
  return jsonP.readObj({
    required: {
      "ManifestS3Uri": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LabelingJobSnsDataSource {
  SnsTopicArn: string;
}
function fromLabelingJobSnsDataSource(input?: LabelingJobSnsDataSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SnsTopicArn: input["SnsTopicArn"],
  }
}
function toLabelingJobSnsDataSource(root: jsonP.JSONValue): LabelingJobSnsDataSource {
  return jsonP.readObj({
    required: {
      "SnsTopicArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface LabelingJobDataAttributes {
  ContentClassifiers?: ContentClassifier[] | null;
}
function fromLabelingJobDataAttributes(input?: LabelingJobDataAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentClassifiers: input["ContentClassifiers"],
  }
}
function toLabelingJobDataAttributes(root: jsonP.JSONValue): LabelingJobDataAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContentClassifiers": [(x: jsonP.JSONValue) => cmnP.readEnum<ContentClassifier>(x)],
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ContentClassifier =
| "FreeOfPersonallyIdentifiableInformation"
| "FreeOfAdultContent"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface LabelingJobOutputConfig {
  S3OutputPath: string;
  KmsKeyId?: string | null;
  SnsTopicArn?: string | null;
}
function fromLabelingJobOutputConfig(input?: LabelingJobOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3OutputPath: input["S3OutputPath"],
    KmsKeyId: input["KmsKeyId"],
    SnsTopicArn: input["SnsTopicArn"],
  }
}
function toLabelingJobOutputConfig(root: jsonP.JSONValue): LabelingJobOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "KmsKeyId": "s",
      "SnsTopicArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface LabelingJobStoppingConditions {
  MaxHumanLabeledObjectCount?: number | null;
  MaxPercentageOfInputDatasetLabeled?: number | null;
}
function fromLabelingJobStoppingConditions(input?: LabelingJobStoppingConditions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxHumanLabeledObjectCount: input["MaxHumanLabeledObjectCount"],
    MaxPercentageOfInputDatasetLabeled: input["MaxPercentageOfInputDatasetLabeled"],
  }
}
function toLabelingJobStoppingConditions(root: jsonP.JSONValue): LabelingJobStoppingConditions {
  return jsonP.readObj({
    required: {},
    optional: {
      "MaxHumanLabeledObjectCount": "n",
      "MaxPercentageOfInputDatasetLabeled": "n",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface LabelingJobAlgorithmsConfig {
  LabelingJobAlgorithmSpecificationArn: string;
  InitialActiveLearningModelArn?: string | null;
  LabelingJobResourceConfig?: LabelingJobResourceConfig | null;
}
function fromLabelingJobAlgorithmsConfig(input?: LabelingJobAlgorithmsConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LabelingJobAlgorithmSpecificationArn: input["LabelingJobAlgorithmSpecificationArn"],
    InitialActiveLearningModelArn: input["InitialActiveLearningModelArn"],
    LabelingJobResourceConfig: fromLabelingJobResourceConfig(input["LabelingJobResourceConfig"]),
  }
}
function toLabelingJobAlgorithmsConfig(root: jsonP.JSONValue): LabelingJobAlgorithmsConfig {
  return jsonP.readObj({
    required: {
      "LabelingJobAlgorithmSpecificationArn": "s",
    },
    optional: {
      "InitialActiveLearningModelArn": "s",
      "LabelingJobResourceConfig": toLabelingJobResourceConfig,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface LabelingJobResourceConfig {
  VolumeKmsKeyId?: string | null;
}
function fromLabelingJobResourceConfig(input?: LabelingJobResourceConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toLabelingJobResourceConfig(root: jsonP.JSONValue): LabelingJobResourceConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface HumanTaskConfig {
  WorkteamArn: string;
  UiConfig: UiConfig;
  PreHumanTaskLambdaArn: string;
  TaskKeywords?: string[] | null;
  TaskTitle: string;
  TaskDescription: string;
  NumberOfHumanWorkersPerDataObject: number;
  TaskTimeLimitInSeconds: number;
  TaskAvailabilityLifetimeInSeconds?: number | null;
  MaxConcurrentTaskCount?: number | null;
  AnnotationConsolidationConfig: AnnotationConsolidationConfig;
  PublicWorkforceTaskPrice?: PublicWorkforceTaskPrice | null;
}
function fromHumanTaskConfig(input?: HumanTaskConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WorkteamArn: input["WorkteamArn"],
    UiConfig: fromUiConfig(input["UiConfig"]),
    PreHumanTaskLambdaArn: input["PreHumanTaskLambdaArn"],
    TaskKeywords: input["TaskKeywords"],
    TaskTitle: input["TaskTitle"],
    TaskDescription: input["TaskDescription"],
    NumberOfHumanWorkersPerDataObject: input["NumberOfHumanWorkersPerDataObject"],
    TaskTimeLimitInSeconds: input["TaskTimeLimitInSeconds"],
    TaskAvailabilityLifetimeInSeconds: input["TaskAvailabilityLifetimeInSeconds"],
    MaxConcurrentTaskCount: input["MaxConcurrentTaskCount"],
    AnnotationConsolidationConfig: fromAnnotationConsolidationConfig(input["AnnotationConsolidationConfig"]),
    PublicWorkforceTaskPrice: fromPublicWorkforceTaskPrice(input["PublicWorkforceTaskPrice"]),
  }
}
function toHumanTaskConfig(root: jsonP.JSONValue): HumanTaskConfig {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
      "UiConfig": toUiConfig,
      "PreHumanTaskLambdaArn": "s",
      "TaskTitle": "s",
      "TaskDescription": "s",
      "NumberOfHumanWorkersPerDataObject": "n",
      "TaskTimeLimitInSeconds": "n",
      "AnnotationConsolidationConfig": toAnnotationConsolidationConfig,
    },
    optional: {
      "TaskKeywords": ["s"],
      "TaskAvailabilityLifetimeInSeconds": "n",
      "MaxConcurrentTaskCount": "n",
      "PublicWorkforceTaskPrice": toPublicWorkforceTaskPrice,
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface UiConfig {
  UiTemplateS3Uri?: string | null;
  HumanTaskUiArn?: string | null;
}
function fromUiConfig(input?: UiConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UiTemplateS3Uri: input["UiTemplateS3Uri"],
    HumanTaskUiArn: input["HumanTaskUiArn"],
  }
}
function toUiConfig(root: jsonP.JSONValue): UiConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "UiTemplateS3Uri": "s",
      "HumanTaskUiArn": "s",
    },
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface AnnotationConsolidationConfig {
  AnnotationConsolidationLambdaArn: string;
}
function fromAnnotationConsolidationConfig(input?: AnnotationConsolidationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AnnotationConsolidationLambdaArn: input["AnnotationConsolidationLambdaArn"],
  }
}
function toAnnotationConsolidationConfig(root: jsonP.JSONValue): AnnotationConsolidationConfig {
  return jsonP.readObj({
    required: {
      "AnnotationConsolidationLambdaArn": "s",
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ContainerDefinition {
  ContainerHostname?: string | null;
  Image?: string | null;
  ImageConfig?: ImageConfig | null;
  Mode?: ContainerMode | null;
  ModelDataUrl?: string | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  ModelPackageName?: string | null;
}
function fromContainerDefinition(input?: ContainerDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContainerHostname: input["ContainerHostname"],
    Image: input["Image"],
    ImageConfig: fromImageConfig(input["ImageConfig"]),
    Mode: input["Mode"],
    ModelDataUrl: input["ModelDataUrl"],
    Environment: input["Environment"],
    ModelPackageName: input["ModelPackageName"],
  }
}
function toContainerDefinition(root: jsonP.JSONValue): ContainerDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "ContainerHostname": "s",
      "Image": "s",
      "ImageConfig": toImageConfig,
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<ContainerMode>(x),
      "ModelDataUrl": "s",
      "Environment": x => jsonP.readMap(String, String, x),
      "ModelPackageName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface ImageConfig {
  RepositoryAccessMode: RepositoryAccessMode;
}
function fromImageConfig(input?: ImageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RepositoryAccessMode: input["RepositoryAccessMode"],
  }
}
function toImageConfig(root: jsonP.JSONValue): ImageConfig {
  return jsonP.readObj({
    required: {
      "RepositoryAccessMode": (x: jsonP.JSONValue) => cmnP.readEnum<RepositoryAccessMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type RepositoryAccessMode =
| "Platform"
| "Vpc"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ContainerMode =
| "SingleModel"
| "MultiModel"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface, output
export interface ModelPackageValidationSpecification {
  ValidationRole: string;
  ValidationProfiles: ModelPackageValidationProfile[];
}
function fromModelPackageValidationSpecification(input?: ModelPackageValidationSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ValidationRole: input["ValidationRole"],
    ValidationProfiles: input["ValidationProfiles"]?.map(x => fromModelPackageValidationProfile(x)),
  }
}
function toModelPackageValidationSpecification(root: jsonP.JSONValue): ModelPackageValidationSpecification {
  return jsonP.readObj({
    required: {
      "ValidationRole": "s",
      "ValidationProfiles": [toModelPackageValidationProfile],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface ModelPackageValidationProfile {
  ProfileName: string;
  TransformJobDefinition: TransformJobDefinition;
}
function fromModelPackageValidationProfile(input?: ModelPackageValidationProfile | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ProfileName: input["ProfileName"],
    TransformJobDefinition: fromTransformJobDefinition(input["TransformJobDefinition"]),
  }
}
function toModelPackageValidationProfile(root: jsonP.JSONValue): ModelPackageValidationProfile {
  return jsonP.readObj({
    required: {
      "ProfileName": "s",
      "TransformJobDefinition": toTransformJobDefinition,
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SourceAlgorithmSpecification {
  SourceAlgorithms: SourceAlgorithm[];
}
function fromSourceAlgorithmSpecification(input?: SourceAlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SourceAlgorithms: input["SourceAlgorithms"]?.map(x => fromSourceAlgorithm(x)),
  }
}
function toSourceAlgorithmSpecification(root: jsonP.JSONValue): SourceAlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "SourceAlgorithms": [toSourceAlgorithm],
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface, output
export interface SourceAlgorithm {
  ModelDataUrl?: string | null;
  AlgorithmName: string;
}
function fromSourceAlgorithm(input?: SourceAlgorithm | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ModelDataUrl: input["ModelDataUrl"],
    AlgorithmName: input["AlgorithmName"],
  }
}
function toSourceAlgorithm(root: jsonP.JSONValue): SourceAlgorithm {
  return jsonP.readObj({
    required: {
      "AlgorithmName": "s",
    },
    optional: {
      "ModelDataUrl": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringScheduleConfig {
  ScheduleConfig?: ScheduleConfig | null;
  MonitoringJobDefinition: MonitoringJobDefinition;
}
function fromMonitoringScheduleConfig(input?: MonitoringScheduleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ScheduleConfig: fromScheduleConfig(input["ScheduleConfig"]),
    MonitoringJobDefinition: fromMonitoringJobDefinition(input["MonitoringJobDefinition"]),
  }
}
function toMonitoringScheduleConfig(root: jsonP.JSONValue): MonitoringScheduleConfig {
  return jsonP.readObj({
    required: {
      "MonitoringJobDefinition": toMonitoringJobDefinition,
    },
    optional: {
      "ScheduleConfig": toScheduleConfig,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ScheduleConfig {
  ScheduleExpression: string;
}
function fromScheduleConfig(input?: ScheduleConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ScheduleExpression: input["ScheduleExpression"],
  }
}
function toScheduleConfig(root: jsonP.JSONValue): ScheduleConfig {
  return jsonP.readObj({
    required: {
      "ScheduleExpression": "s",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringJobDefinition {
  BaselineConfig?: MonitoringBaselineConfig | null;
  MonitoringInputs: MonitoringInput[];
  MonitoringOutputConfig: MonitoringOutputConfig;
  MonitoringResources: MonitoringResources;
  MonitoringAppSpecification: MonitoringAppSpecification;
  StoppingCondition?: MonitoringStoppingCondition | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  NetworkConfig?: NetworkConfig | null;
  RoleArn: string;
}
function fromMonitoringJobDefinition(input?: MonitoringJobDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BaselineConfig: fromMonitoringBaselineConfig(input["BaselineConfig"]),
    MonitoringInputs: input["MonitoringInputs"]?.map(x => fromMonitoringInput(x)),
    MonitoringOutputConfig: fromMonitoringOutputConfig(input["MonitoringOutputConfig"]),
    MonitoringResources: fromMonitoringResources(input["MonitoringResources"]),
    MonitoringAppSpecification: fromMonitoringAppSpecification(input["MonitoringAppSpecification"]),
    StoppingCondition: fromMonitoringStoppingCondition(input["StoppingCondition"]),
    Environment: input["Environment"],
    NetworkConfig: fromNetworkConfig(input["NetworkConfig"]),
    RoleArn: input["RoleArn"],
  }
}
function toMonitoringJobDefinition(root: jsonP.JSONValue): MonitoringJobDefinition {
  return jsonP.readObj({
    required: {
      "MonitoringInputs": [toMonitoringInput],
      "MonitoringOutputConfig": toMonitoringOutputConfig,
      "MonitoringResources": toMonitoringResources,
      "MonitoringAppSpecification": toMonitoringAppSpecification,
      "RoleArn": "s",
    },
    optional: {
      "BaselineConfig": toMonitoringBaselineConfig,
      "StoppingCondition": toMonitoringStoppingCondition,
      "Environment": x => jsonP.readMap(String, String, x),
      "NetworkConfig": toNetworkConfig,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringBaselineConfig {
  ConstraintsResource?: MonitoringConstraintsResource | null;
  StatisticsResource?: MonitoringStatisticsResource | null;
}
function fromMonitoringBaselineConfig(input?: MonitoringBaselineConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConstraintsResource: fromMonitoringConstraintsResource(input["ConstraintsResource"]),
    StatisticsResource: fromMonitoringStatisticsResource(input["StatisticsResource"]),
  }
}
function toMonitoringBaselineConfig(root: jsonP.JSONValue): MonitoringBaselineConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ConstraintsResource": toMonitoringConstraintsResource,
      "StatisticsResource": toMonitoringStatisticsResource,
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringConstraintsResource {
  S3Uri?: string | null;
}
function fromMonitoringConstraintsResource(input?: MonitoringConstraintsResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toMonitoringConstraintsResource(root: jsonP.JSONValue): MonitoringConstraintsResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringStatisticsResource {
  S3Uri?: string | null;
}
function fromMonitoringStatisticsResource(input?: MonitoringStatisticsResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
  }
}
function toMonitoringStatisticsResource(root: jsonP.JSONValue): MonitoringStatisticsResource {
  return jsonP.readObj({
    required: {},
    optional: {
      "S3Uri": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringInput {
  EndpointInput: EndpointInput;
}
function fromMonitoringInput(input?: MonitoringInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointInput: fromEndpointInput(input["EndpointInput"]),
  }
}
function toMonitoringInput(root: jsonP.JSONValue): MonitoringInput {
  return jsonP.readObj({
    required: {
      "EndpointInput": toEndpointInput,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface EndpointInput {
  EndpointName: string;
  LocalPath: string;
  S3InputMode?: ProcessingS3InputMode | null;
  S3DataDistributionType?: ProcessingS3DataDistributionType | null;
}
function fromEndpointInput(input?: EndpointInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndpointName: input["EndpointName"],
    LocalPath: input["LocalPath"],
    S3InputMode: input["S3InputMode"],
    S3DataDistributionType: input["S3DataDistributionType"],
  }
}
function toEndpointInput(root: jsonP.JSONValue): EndpointInput {
  return jsonP.readObj({
    required: {
      "EndpointName": "s",
      "LocalPath": "s",
    },
    optional: {
      "S3InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3InputMode>(x),
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3DataDistributionType>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ProcessingS3InputMode =
| "Pipe"
| "File"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, enum, output
export type ProcessingS3DataDistributionType =
| "FullyReplicated"
| "ShardedByS3Key"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface MonitoringOutputConfig {
  MonitoringOutputs: MonitoringOutput[];
  KmsKeyId?: string | null;
}
function fromMonitoringOutputConfig(input?: MonitoringOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MonitoringOutputs: input["MonitoringOutputs"]?.map(x => fromMonitoringOutput(x)),
    KmsKeyId: input["KmsKeyId"],
  }
}
function toMonitoringOutputConfig(root: jsonP.JSONValue): MonitoringOutputConfig {
  return jsonP.readObj({
    required: {
      "MonitoringOutputs": [toMonitoringOutput],
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringOutput {
  S3Output: MonitoringS3Output;
}
function fromMonitoringOutput(input?: MonitoringOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Output: fromMonitoringS3Output(input["S3Output"]),
  }
}
function toMonitoringOutput(root: jsonP.JSONValue): MonitoringOutput {
  return jsonP.readObj({
    required: {
      "S3Output": toMonitoringS3Output,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringS3Output {
  S3Uri: string;
  LocalPath: string;
  S3UploadMode?: ProcessingS3UploadMode | null;
}
function fromMonitoringS3Output(input?: MonitoringS3Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3UploadMode: input["S3UploadMode"],
  }
}
function toMonitoringS3Output(root: jsonP.JSONValue): MonitoringS3Output {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "LocalPath": "s",
    },
    optional: {
      "S3UploadMode": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3UploadMode>(x),
    },
  }, root);
}

// refs: 6 - tags: input, named, enum, output
export type ProcessingS3UploadMode =
| "Continuous"
| "EndOfJob"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface MonitoringResources {
  ClusterConfig: MonitoringClusterConfig;
}
function fromMonitoringResources(input?: MonitoringResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterConfig: fromMonitoringClusterConfig(input["ClusterConfig"]),
  }
}
function toMonitoringResources(root: jsonP.JSONValue): MonitoringResources {
  return jsonP.readObj({
    required: {
      "ClusterConfig": toMonitoringClusterConfig,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringClusterConfig {
  InstanceCount: number;
  InstanceType: ProcessingInstanceType;
  VolumeSizeInGB: number;
  VolumeKmsKeyId?: string | null;
}
function fromMonitoringClusterConfig(input?: MonitoringClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toMonitoringClusterConfig(root: jsonP.JSONValue): MonitoringClusterConfig {
  return jsonP.readObj({
    required: {
      "InstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

// refs: 10 - tags: input, named, enum, output
export type ProcessingInstanceType =
| "ml.t3.medium"
| "ml.t3.large"
| "ml.t3.xlarge"
| "ml.t3.2xlarge"
| "ml.m4.xlarge"
| "ml.m4.2xlarge"
| "ml.m4.4xlarge"
| "ml.m4.10xlarge"
| "ml.m4.16xlarge"
| "ml.c4.xlarge"
| "ml.c4.2xlarge"
| "ml.c4.4xlarge"
| "ml.c4.8xlarge"
| "ml.p2.xlarge"
| "ml.p2.8xlarge"
| "ml.p2.16xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.18xlarge"
| "ml.m5.large"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.12xlarge"
| "ml.m5.24xlarge"
| "ml.r5.large"
| "ml.r5.xlarge"
| "ml.r5.2xlarge"
| "ml.r5.4xlarge"
| "ml.r5.8xlarge"
| "ml.r5.12xlarge"
| "ml.r5.16xlarge"
| "ml.r5.24xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface MonitoringAppSpecification {
  ImageUri: string;
  ContainerEntrypoint?: string[] | null;
  ContainerArguments?: string[] | null;
  RecordPreprocessorSourceUri?: string | null;
  PostAnalyticsProcessorSourceUri?: string | null;
}
function fromMonitoringAppSpecification(input?: MonitoringAppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
    RecordPreprocessorSourceUri: input["RecordPreprocessorSourceUri"],
    PostAnalyticsProcessorSourceUri: input["PostAnalyticsProcessorSourceUri"],
  }
}
function toMonitoringAppSpecification(root: jsonP.JSONValue): MonitoringAppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
      "RecordPreprocessorSourceUri": "s",
      "PostAnalyticsProcessorSourceUri": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringStoppingCondition {
  MaxRuntimeInSeconds: number;
}
function fromMonitoringStoppingCondition(input?: MonitoringStoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
  }
}
function toMonitoringStoppingCondition(root: jsonP.JSONValue): MonitoringStoppingCondition {
  return jsonP.readObj({
    required: {
      "MaxRuntimeInSeconds": "n",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface NetworkConfig {
  EnableInterContainerTrafficEncryption?: boolean | null;
  EnableNetworkIsolation?: boolean | null;
  VpcConfig?: VpcConfig | null;
}
function fromNetworkConfig(input?: NetworkConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EnableInterContainerTrafficEncryption: input["EnableInterContainerTrafficEncryption"],
    EnableNetworkIsolation: input["EnableNetworkIsolation"],
    VpcConfig: fromVpcConfig(input["VpcConfig"]),
  }
}
function toNetworkConfig(root: jsonP.JSONValue): NetworkConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "EnableInterContainerTrafficEncryption": "b",
      "EnableNetworkIsolation": "b",
      "VpcConfig": toVpcConfig,
    },
  }, root);
}

// refs: 4 - tags: input, named, enum, output
export type InstanceType =
| "ml.t2.medium"
| "ml.t2.large"
| "ml.t2.xlarge"
| "ml.t2.2xlarge"
| "ml.t3.medium"
| "ml.t3.large"
| "ml.t3.xlarge"
| "ml.t3.2xlarge"
| "ml.m4.xlarge"
| "ml.m4.2xlarge"
| "ml.m4.4xlarge"
| "ml.m4.10xlarge"
| "ml.m4.16xlarge"
| "ml.m5.xlarge"
| "ml.m5.2xlarge"
| "ml.m5.4xlarge"
| "ml.m5.12xlarge"
| "ml.m5.24xlarge"
| "ml.c4.xlarge"
| "ml.c4.2xlarge"
| "ml.c4.4xlarge"
| "ml.c4.8xlarge"
| "ml.c5.xlarge"
| "ml.c5.2xlarge"
| "ml.c5.4xlarge"
| "ml.c5.9xlarge"
| "ml.c5.18xlarge"
| "ml.c5d.xlarge"
| "ml.c5d.2xlarge"
| "ml.c5d.4xlarge"
| "ml.c5d.9xlarge"
| "ml.c5d.18xlarge"
| "ml.p2.xlarge"
| "ml.p2.8xlarge"
| "ml.p2.16xlarge"
| "ml.p3.2xlarge"
| "ml.p3.8xlarge"
| "ml.p3.16xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type DirectInternetAccess =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type NotebookInstanceAcceleratorType =
| "ml.eia1.medium"
| "ml.eia1.large"
| "ml.eia1.xlarge"
| "ml.eia2.medium"
| "ml.eia2.large"
| "ml.eia2.xlarge"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type RootAccess =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface NotebookInstanceLifecycleHook {
  Content?: string | null;
}
function fromNotebookInstanceLifecycleHook(input?: NotebookInstanceLifecycleHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Content: input["Content"],
  }
}
function toNotebookInstanceLifecycleHook(root: jsonP.JSONValue): NotebookInstanceLifecycleHook {
  return jsonP.readObj({
    required: {},
    optional: {
      "Content": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingInput {
  InputName: string;
  S3Input: ProcessingS3Input;
}
function fromProcessingInput(input?: ProcessingInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputName: input["InputName"],
    S3Input: fromProcessingS3Input(input["S3Input"]),
  }
}
function toProcessingInput(root: jsonP.JSONValue): ProcessingInput {
  return jsonP.readObj({
    required: {
      "InputName": "s",
      "S3Input": toProcessingS3Input,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingS3Input {
  S3Uri: string;
  LocalPath: string;
  S3DataType: ProcessingS3DataType;
  S3InputMode: ProcessingS3InputMode;
  S3DataDistributionType?: ProcessingS3DataDistributionType | null;
  S3CompressionType?: ProcessingS3CompressionType | null;
}
function fromProcessingS3Input(input?: ProcessingS3Input | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3DataType: input["S3DataType"],
    S3InputMode: input["S3InputMode"],
    S3DataDistributionType: input["S3DataDistributionType"],
    S3CompressionType: input["S3CompressionType"],
  }
}
function toProcessingS3Input(root: jsonP.JSONValue): ProcessingS3Input {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "LocalPath": "s",
      "S3DataType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3DataType>(x),
      "S3InputMode": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3InputMode>(x),
    },
    optional: {
      "S3DataDistributionType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3DataDistributionType>(x),
      "S3CompressionType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3CompressionType>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type ProcessingS3DataType =
| "ManifestFile"
| "S3Prefix"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ProcessingS3CompressionType =
| "None"
| "Gzip"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, interface, output
export interface ProcessingOutputConfig {
  Outputs: ProcessingOutput[];
  KmsKeyId?: string | null;
}
function fromProcessingOutputConfig(input?: ProcessingOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Outputs: input["Outputs"]?.map(x => fromProcessingOutput(x)),
    KmsKeyId: input["KmsKeyId"],
  }
}
function toProcessingOutputConfig(root: jsonP.JSONValue): ProcessingOutputConfig {
  return jsonP.readObj({
    required: {
      "Outputs": [toProcessingOutput],
    },
    optional: {
      "KmsKeyId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingOutput {
  OutputName: string;
  S3Output: ProcessingS3Output;
}
function fromProcessingOutput(input?: ProcessingOutput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OutputName: input["OutputName"],
    S3Output: fromProcessingS3Output(input["S3Output"]),
  }
}
function toProcessingOutput(root: jsonP.JSONValue): ProcessingOutput {
  return jsonP.readObj({
    required: {
      "OutputName": "s",
      "S3Output": toProcessingS3Output,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingS3Output {
  S3Uri: string;
  LocalPath: string;
  S3UploadMode: ProcessingS3UploadMode;
}
function fromProcessingS3Output(input?: ProcessingS3Output | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Uri: input["S3Uri"],
    LocalPath: input["LocalPath"],
    S3UploadMode: input["S3UploadMode"],
  }
}
function toProcessingS3Output(root: jsonP.JSONValue): ProcessingS3Output {
  return jsonP.readObj({
    required: {
      "S3Uri": "s",
      "LocalPath": "s",
      "S3UploadMode": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingS3UploadMode>(x),
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingResources {
  ClusterConfig: ProcessingClusterConfig;
}
function fromProcessingResources(input?: ProcessingResources | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClusterConfig: fromProcessingClusterConfig(input["ClusterConfig"]),
  }
}
function toProcessingResources(root: jsonP.JSONValue): ProcessingResources {
  return jsonP.readObj({
    required: {
      "ClusterConfig": toProcessingClusterConfig,
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingClusterConfig {
  InstanceCount: number;
  InstanceType: ProcessingInstanceType;
  VolumeSizeInGB: number;
  VolumeKmsKeyId?: string | null;
}
function fromProcessingClusterConfig(input?: ProcessingClusterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InstanceCount: input["InstanceCount"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    VolumeKmsKeyId: input["VolumeKmsKeyId"],
  }
}
function toProcessingClusterConfig(root: jsonP.JSONValue): ProcessingClusterConfig {
  return jsonP.readObj({
    required: {
      "InstanceCount": "n",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
    },
    optional: {
      "VolumeKmsKeyId": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ProcessingStoppingCondition {
  MaxRuntimeInSeconds: number;
}
function fromProcessingStoppingCondition(input?: ProcessingStoppingCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MaxRuntimeInSeconds: input["MaxRuntimeInSeconds"],
  }
}
function toProcessingStoppingCondition(root: jsonP.JSONValue): ProcessingStoppingCondition {
  return jsonP.readObj({
    required: {
      "MaxRuntimeInSeconds": "n",
    },
    optional: {},
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface AppSpecification {
  ImageUri: string;
  ContainerEntrypoint?: string[] | null;
  ContainerArguments?: string[] | null;
}
function fromAppSpecification(input?: AppSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ImageUri: input["ImageUri"],
    ContainerEntrypoint: input["ContainerEntrypoint"],
    ContainerArguments: input["ContainerArguments"],
  }
}
function toAppSpecification(root: jsonP.JSONValue): AppSpecification {
  return jsonP.readObj({
    required: {
      "ImageUri": "s",
    },
    optional: {
      "ContainerEntrypoint": ["s"],
      "ContainerArguments": ["s"],
    },
  }, root);
}

// refs: 10 - tags: input, named, interface, output
export interface ExperimentConfig {
  ExperimentName?: string | null;
  TrialName?: string | null;
  TrialComponentDisplayName?: string | null;
}
function fromExperimentConfig(input?: ExperimentConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ExperimentName: input["ExperimentName"],
    TrialName: input["TrialName"],
    TrialComponentDisplayName: input["TrialComponentDisplayName"],
  }
}
function toExperimentConfig(root: jsonP.JSONValue): ExperimentConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentName": "s",
      "TrialName": "s",
      "TrialComponentDisplayName": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface AlgorithmSpecification {
  TrainingImage?: string | null;
  AlgorithmName?: string | null;
  TrainingInputMode: TrainingInputMode;
  MetricDefinitions?: MetricDefinition[] | null;
  EnableSageMakerMetricsTimeSeries?: boolean | null;
}
function fromAlgorithmSpecification(input?: AlgorithmSpecification | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TrainingImage: input["TrainingImage"],
    AlgorithmName: input["AlgorithmName"],
    TrainingInputMode: input["TrainingInputMode"],
    MetricDefinitions: input["MetricDefinitions"]?.map(x => fromMetricDefinition(x)),
    EnableSageMakerMetricsTimeSeries: input["EnableSageMakerMetricsTimeSeries"],
  }
}
function toAlgorithmSpecification(root: jsonP.JSONValue): AlgorithmSpecification {
  return jsonP.readObj({
    required: {
      "TrainingInputMode": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingInputMode>(x),
    },
    optional: {
      "TrainingImage": "s",
      "AlgorithmName": "s",
      "MetricDefinitions": [toMetricDefinition],
      "EnableSageMakerMetricsTimeSeries": "b",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DebugHookConfig {
  LocalPath?: string | null;
  S3OutputPath: string;
  HookParameters?: { [key: string]: string | null | undefined } | null;
  CollectionConfigurations?: CollectionConfiguration[] | null;
}
function fromDebugHookConfig(input?: DebugHookConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
    HookParameters: input["HookParameters"],
    CollectionConfigurations: input["CollectionConfigurations"]?.map(x => fromCollectionConfiguration(x)),
  }
}
function toDebugHookConfig(root: jsonP.JSONValue): DebugHookConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "LocalPath": "s",
      "HookParameters": x => jsonP.readMap(String, String, x),
      "CollectionConfigurations": [toCollectionConfiguration],
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface CollectionConfiguration {
  CollectionName?: string | null;
  CollectionParameters?: { [key: string]: string | null | undefined } | null;
}
function fromCollectionConfiguration(input?: CollectionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CollectionName: input["CollectionName"],
    CollectionParameters: input["CollectionParameters"],
  }
}
function toCollectionConfiguration(root: jsonP.JSONValue): CollectionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "CollectionName": "s",
      "CollectionParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface DebugRuleConfiguration {
  RuleConfigurationName: string;
  LocalPath?: string | null;
  S3OutputPath?: string | null;
  RuleEvaluatorImage: string;
  InstanceType?: ProcessingInstanceType | null;
  VolumeSizeInGB?: number | null;
  RuleParameters?: { [key: string]: string | null | undefined } | null;
}
function fromDebugRuleConfiguration(input?: DebugRuleConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RuleConfigurationName: input["RuleConfigurationName"],
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
    RuleEvaluatorImage: input["RuleEvaluatorImage"],
    InstanceType: input["InstanceType"],
    VolumeSizeInGB: input["VolumeSizeInGB"],
    RuleParameters: input["RuleParameters"],
  }
}
function toDebugRuleConfiguration(root: jsonP.JSONValue): DebugRuleConfiguration {
  return jsonP.readObj({
    required: {
      "RuleConfigurationName": "s",
      "RuleEvaluatorImage": "s",
    },
    optional: {
      "LocalPath": "s",
      "S3OutputPath": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingInstanceType>(x),
      "VolumeSizeInGB": "n",
      "RuleParameters": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface TensorBoardOutputConfig {
  LocalPath?: string | null;
  S3OutputPath: string;
}
function fromTensorBoardOutputConfig(input?: TensorBoardOutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LocalPath: input["LocalPath"],
    S3OutputPath: input["S3OutputPath"],
  }
}
function toTensorBoardOutputConfig(root: jsonP.JSONValue): TensorBoardOutputConfig {
  return jsonP.readObj({
    required: {
      "S3OutputPath": "s",
    },
    optional: {
      "LocalPath": "s",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface ModelClientConfig {
  InvocationsTimeoutInSeconds?: number | null;
  InvocationsMaxRetries?: number | null;
}
function fromModelClientConfig(input?: ModelClientConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InvocationsTimeoutInSeconds: input["InvocationsTimeoutInSeconds"],
    InvocationsMaxRetries: input["InvocationsMaxRetries"],
  }
}
function toModelClientConfig(root: jsonP.JSONValue): ModelClientConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "InvocationsTimeoutInSeconds": "n",
      "InvocationsMaxRetries": "n",
    },
  }, root);
}

// refs: 3 - tags: input, named, interface, output
export interface DataProcessing {
  InputFilter?: string | null;
  OutputFilter?: string | null;
  JoinSource?: JoinSource | null;
}
function fromDataProcessing(input?: DataProcessing | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    InputFilter: input["InputFilter"],
    OutputFilter: input["OutputFilter"],
    JoinSource: input["JoinSource"],
  }
}
function toDataProcessing(root: jsonP.JSONValue): DataProcessing {
  return jsonP.readObj({
    required: {},
    optional: {
      "InputFilter": "s",
      "OutputFilter": "s",
      "JoinSource": (x: jsonP.JSONValue) => cmnP.readEnum<JoinSource>(x),
    },
  }, root);
}

// refs: 3 - tags: input, named, enum, output
export type JoinSource =
| "Input"
| "None"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: input, named, interface, output
export interface TrialComponentStatus {
  PrimaryStatus?: TrialComponentPrimaryStatus | null;
  Message?: string | null;
}
function fromTrialComponentStatus(input?: TrialComponentStatus | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PrimaryStatus: input["PrimaryStatus"],
    Message: input["Message"],
  }
}
function toTrialComponentStatus(root: jsonP.JSONValue): TrialComponentStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "PrimaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TrialComponentPrimaryStatus>(x),
      "Message": "s",
    },
  }, root);
}

// refs: 5 - tags: input, named, enum, output
export type TrialComponentPrimaryStatus =
| "InProgress"
| "Completed"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, interface, output
export interface TrialComponentParameterValue {
  StringValue?: string | null;
  NumberValue?: number | null;
}
function fromTrialComponentParameterValue(input?: TrialComponentParameterValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    NumberValue: input["NumberValue"],
  }
}
function toTrialComponentParameterValue(root: jsonP.JSONValue): TrialComponentParameterValue {
  return jsonP.readObj({
    required: {},
    optional: {
      "StringValue": "s",
      "NumberValue": "n",
    },
  }, root);
}

// refs: 8 - tags: input, named, interface, output
export interface TrialComponentArtifact {
  MediaType?: string | null;
  Value: string;
}
function fromTrialComponentArtifact(input?: TrialComponentArtifact | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MediaType: input["MediaType"],
    Value: input["Value"],
  }
}
function toTrialComponentArtifact(root: jsonP.JSONValue): TrialComponentArtifact {
  return jsonP.readObj({
    required: {
      "Value": "s",
    },
    optional: {
      "MediaType": "s",
    },
  }, root);
}

// refs: 4 - tags: input, named, interface, output
export interface CognitoConfig {
  UserPool: string;
  ClientId: string;
}
function fromCognitoConfig(input?: CognitoConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserPool: input["UserPool"],
    ClientId: input["ClientId"],
  }
}
function toCognitoConfig(root: jsonP.JSONValue): CognitoConfig {
  return jsonP.readObj({
    required: {
      "UserPool": "s",
      "ClientId": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface OidcConfig {
  ClientId: string;
  ClientSecret: string;
  Issuer: string;
  AuthorizationEndpoint: string;
  TokenEndpoint: string;
  UserInfoEndpoint: string;
  LogoutEndpoint: string;
  JwksUri: string;
}
function fromOidcConfig(input?: OidcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClientId: input["ClientId"],
    ClientSecret: input["ClientSecret"],
    Issuer: input["Issuer"],
    AuthorizationEndpoint: input["AuthorizationEndpoint"],
    TokenEndpoint: input["TokenEndpoint"],
    UserInfoEndpoint: input["UserInfoEndpoint"],
    LogoutEndpoint: input["LogoutEndpoint"],
    JwksUri: input["JwksUri"],
  }
}

// refs: 5 - tags: input, named, interface, output
export interface SourceIpConfig {
  Cidrs: string[];
}
function fromSourceIpConfig(input?: SourceIpConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Cidrs: input["Cidrs"],
  }
}
function toSourceIpConfig(root: jsonP.JSONValue): SourceIpConfig {
  return jsonP.readObj({
    required: {
      "Cidrs": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface MemberDefinition {
  CognitoMemberDefinition?: CognitoMemberDefinition | null;
  OidcMemberDefinition?: OidcMemberDefinition | null;
}
function fromMemberDefinition(input?: MemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CognitoMemberDefinition: fromCognitoMemberDefinition(input["CognitoMemberDefinition"]),
    OidcMemberDefinition: fromOidcMemberDefinition(input["OidcMemberDefinition"]),
  }
}
function toMemberDefinition(root: jsonP.JSONValue): MemberDefinition {
  return jsonP.readObj({
    required: {},
    optional: {
      "CognitoMemberDefinition": toCognitoMemberDefinition,
      "OidcMemberDefinition": toOidcMemberDefinition,
    },
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface CognitoMemberDefinition {
  UserPool: string;
  UserGroup: string;
  ClientId: string;
}
function fromCognitoMemberDefinition(input?: CognitoMemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserPool: input["UserPool"],
    UserGroup: input["UserGroup"],
    ClientId: input["ClientId"],
  }
}
function toCognitoMemberDefinition(root: jsonP.JSONValue): CognitoMemberDefinition {
  return jsonP.readObj({
    required: {
      "UserPool": "s",
      "UserGroup": "s",
      "ClientId": "s",
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface OidcMemberDefinition {
  Groups: string[];
}
function fromOidcMemberDefinition(input?: OidcMemberDefinition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Groups: input["Groups"],
  }
}
function toOidcMemberDefinition(root: jsonP.JSONValue): OidcMemberDefinition {
  return jsonP.readObj({
    required: {
      "Groups": ["s"],
    },
    optional: {},
  }, root);
}

// refs: 5 - tags: input, named, interface, output
export interface NotificationConfiguration {
  NotificationTopicArn?: string | null;
}
function fromNotificationConfiguration(input?: NotificationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NotificationTopicArn: input["NotificationTopicArn"],
  }
}
function toNotificationConfiguration(root: jsonP.JSONValue): NotificationConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "NotificationTopicArn": "s",
    },
  }, root);
}

// refs: 1 - tags: input, named, interface
export interface RetentionPolicy {
  HomeEfsFileSystem?: RetentionType | null;
}
function fromRetentionPolicy(input?: RetentionPolicy | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HomeEfsFileSystem: input["HomeEfsFileSystem"],
  }
}

// refs: 1 - tags: input, named, enum
export type RetentionType =
| "Retain"
| "Delete"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type ResourceType =
| "TrainingJob"
| "Experiment"
| "ExperimentTrial"
| "ExperimentTrialComponent"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface SuggestionQuery {
  PropertyNameQuery?: PropertyNameQuery | null;
}
function fromSuggestionQuery(input?: SuggestionQuery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PropertyNameQuery: fromPropertyNameQuery(input["PropertyNameQuery"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface PropertyNameQuery {
  PropertyNameHint: string;
}
function fromPropertyNameQuery(input?: PropertyNameQuery | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    PropertyNameHint: input["PropertyNameHint"],
  }
}

// refs: 1 - tags: input, named, enum
export type AlgorithmSortBy =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, enum
export type SortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type AppImageConfigSortKey =
| "CreationTime"
| "LastModifiedTime"
| "Name"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type AppSortKey =
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type AutoMLJobStatus =
| "Completed"
| "InProgress"
| "Failed"
| "Stopped"
| "Stopping"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type AutoMLSortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type AutoMLSortBy =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CandidateStatus =
| "Completed"
| "InProgress"
| "Failed"
| "Stopped"
| "Stopping"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type CandidateSortBy =
| "CreationTime"
| "Status"
| "FinalObjectiveMetricValue"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type CodeRepositorySortBy =
| "Name"
| "CreationTime"
| "LastModifiedTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type CodeRepositorySortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type CompilationJobStatus =
| "INPROGRESS"
| "COMPLETED"
| "FAILED"
| "STARTING"
| "STOPPING"
| "STOPPED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ListCompilationJobsSortBy =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type EndpointConfigSortKey =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum
export type OrderKey =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type EndpointSortKey =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type EndpointStatus =
| "OutOfService"
| "Creating"
| "Updating"
| "SystemUpdating"
| "RollingBack"
| "InService"
| "Deleting"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortExperimentsBy =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type HyperParameterTuningJobSortByOptions =
| "Name"
| "Status"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type HyperParameterTuningJobStatus =
| "Completed"
| "InProgress"
| "Failed"
| "Stopped"
| "Stopping"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ImageVersionSortBy =
| "CREATION_TIME"
| "LAST_MODIFIED_TIME"
| "VERSION"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ImageVersionSortOrder =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ImageSortBy =
| "CREATION_TIME"
| "LAST_MODIFIED_TIME"
| "IMAGE_NAME"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ImageSortOrder =
| "ASCENDING"
| "DESCENDING"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum
export type SortBy =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type LabelingJobStatus =
| "Initializing"
| "InProgress"
| "Completed"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ListLabelingJobsForWorkteamSortByOptions =
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ModelPackageSortBy =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ModelSortKey =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type MonitoringExecutionSortKey =
| "CreationTime"
| "ScheduledTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ExecutionStatus =
| "Pending"
| "Completed"
| "CompletedWithViolations"
| "InProgress"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type MonitoringScheduleSortKey =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type ScheduleStatus =
| "Pending"
| "Failed"
| "Scheduled"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type NotebookInstanceLifecycleConfigSortKey =
| "Name"
| "CreationTime"
| "LastModifiedTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type NotebookInstanceLifecycleConfigSortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type NotebookInstanceSortKey =
| "Name"
| "CreationTime"
| "Status"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type NotebookInstanceSortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: input, named, enum, output
export type NotebookInstanceStatus =
| "Pending"
| "InService"
| "Stopping"
| "Stopped"
| "Failed"
| "Deleting"
| "Updating"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type ProcessingJobStatus =
| "InProgress"
| "Completed"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 9 - tags: input, named, enum, output
export type TrainingJobStatus =
| "InProgress"
| "Completed"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type TrainingJobSortByOptions =
| "Name"
| "CreationTime"
| "Status"
| "FinalObjectiveMetricValue"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: input, named, enum, output
export type TransformJobStatus =
| "InProgress"
| "Completed"
| "Failed"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortTrialComponentsBy =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SortTrialsBy =
| "Name"
| "CreationTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type UserProfileSortKey =
| "CreationTime"
| "LastModifiedTime"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ListWorkforcesSortByOptions =
| "Name"
| "CreateDate"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type ListWorkteamsSortByOptions =
| "Name"
| "CreateDate"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface RenderableTask {
  Input: string;
}
function fromRenderableTask(input?: RenderableTask | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Input: input["Input"],
  }
}

// refs: 2 - tags: input, named, interface, recursed
export interface SearchExpression {
  Filters?: Filter[] | null;
  NestedFilters?: NestedFilters[] | null;
  SubExpressions?: SearchExpression[] | null;
  Operator?: BooleanOperator | null;
}
function fromSearchExpression(input?: SearchExpression | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Filters: input["Filters"]?.map(x => fromFilter(x)),
    NestedFilters: input["NestedFilters"]?.map(x => fromNestedFilters(x)),
    SubExpressions: input["SubExpressions"]?.map(x => fromSearchExpression(x)),
    Operator: input["Operator"],
  }
}

// refs: 2 - tags: input, named, interface
export interface Filter {
  Name: string;
  Operator?: Operator | null;
  Value?: string | null;
}
function fromFilter(input?: Filter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Operator: input["Operator"],
    Value: input["Value"],
  }
}

// refs: 2 - tags: input, named, enum
export type Operator =
| "Equals"
| "NotEquals"
| "GreaterThan"
| "GreaterThanOrEqualTo"
| "LessThan"
| "LessThanOrEqualTo"
| "Contains"
| "Exists"
| "NotExists"
| "In"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface NestedFilters {
  NestedPropertyName: string;
  Filters: Filter[];
}
function fromNestedFilters(input?: NestedFilters | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NestedPropertyName: input["NestedPropertyName"],
    Filters: input["Filters"]?.map(x => fromFilter(x)),
  }
}

// refs: 1 - tags: input, named, enum
export type BooleanOperator =
| "And"
| "Or"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, enum
export type SearchSortOrder =
| "Ascending"
| "Descending"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface GitConfigForUpdate {
  SecretArn?: string | null;
}
function fromGitConfigForUpdate(input?: GitConfigForUpdate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SecretArn: input["SecretArn"],
  }
}

// refs: 1 - tags: input, named, interface
export interface VariantProperty {
  VariantPropertyType: VariantPropertyType;
}
function fromVariantProperty(input?: VariantProperty | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantPropertyType: input["VariantPropertyType"],
  }
}

// refs: 1 - tags: input, named, enum
export type VariantPropertyType =
| "DesiredInstanceCount"
| "DesiredWeight"
| "DataCaptureConfig"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DesiredWeightAndCapacity {
  VariantName: string;
  DesiredWeight?: number | null;
  DesiredInstanceCount?: number | null;
}
function fromDesiredWeightAndCapacity(input?: DesiredWeightAndCapacity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    VariantName: input["VariantName"],
    DesiredWeight: input["DesiredWeight"],
    DesiredInstanceCount: input["DesiredInstanceCount"],
  }
}

// refs: 2 - tags: output, named, enum
export type AlgorithmStatus =
| "Pending"
| "InProgress"
| "Completed"
| "Failed"
| "Deleting"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AlgorithmStatusDetails {
  ValidationStatuses?: AlgorithmStatusItem[] | null;
  ImageScanStatuses?: AlgorithmStatusItem[] | null;
}
function toAlgorithmStatusDetails(root: jsonP.JSONValue): AlgorithmStatusDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "ValidationStatuses": [toAlgorithmStatusItem],
      "ImageScanStatuses": [toAlgorithmStatusItem],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface AlgorithmStatusItem {
  Name: string;
  Status: DetailedAlgorithmStatus;
  FailureReason?: string | null;
}
function toAlgorithmStatusItem(root: jsonP.JSONValue): AlgorithmStatusItem {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<DetailedAlgorithmStatus>(x),
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DetailedAlgorithmStatus =
| "NotStarted"
| "InProgress"
| "Completed"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type AppStatus =
| "Deleted"
| "Deleting"
| "Failed"
| "InService"
| "Pending"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AutoMLCandidate {
  CandidateName: string;
  FinalAutoMLJobObjectiveMetric?: FinalAutoMLJobObjectiveMetric | null;
  ObjectiveStatus: ObjectiveStatus;
  CandidateSteps: AutoMLCandidateStep[];
  CandidateStatus: CandidateStatus;
  InferenceContainers?: AutoMLContainerDefinition[] | null;
  CreationTime: Date | number;
  EndTime?: Date | number | null;
  LastModifiedTime: Date | number;
  FailureReason?: string | null;
}
function toAutoMLCandidate(root: jsonP.JSONValue): AutoMLCandidate {
  return jsonP.readObj({
    required: {
      "CandidateName": "s",
      "ObjectiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectiveStatus>(x),
      "CandidateSteps": [toAutoMLCandidateStep],
      "CandidateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CandidateStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "FinalAutoMLJobObjectiveMetric": toFinalAutoMLJobObjectiveMetric,
      "InferenceContainers": [toAutoMLContainerDefinition],
      "EndTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface FinalAutoMLJobObjectiveMetric {
  Type?: AutoMLJobObjectiveType | null;
  MetricName: AutoMLMetricEnum;
  Value: number;
}
function toFinalAutoMLJobObjectiveMetric(root: jsonP.JSONValue): FinalAutoMLJobObjectiveMetric {
  return jsonP.readObj({
    required: {
      "MetricName": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLMetricEnum>(x),
      "Value": "n",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLJobObjectiveType>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoMLJobObjectiveType =
| "Maximize"
| "Minimize"
| cmnP.UnexpectedEnumValue;

// refs: 5 - tags: output, named, enum
export type ObjectiveStatus =
| "Succeeded"
| "Pending"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AutoMLCandidateStep {
  CandidateStepType: CandidateStepType;
  CandidateStepArn: string;
  CandidateStepName: string;
}
function toAutoMLCandidateStep(root: jsonP.JSONValue): AutoMLCandidateStep {
  return jsonP.readObj({
    required: {
      "CandidateStepType": (x: jsonP.JSONValue) => cmnP.readEnum<CandidateStepType>(x),
      "CandidateStepArn": "s",
      "CandidateStepName": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, enum
export type CandidateStepType =
| "AWS::SageMaker::TrainingJob"
| "AWS::SageMaker::TransformJob"
| "AWS::SageMaker::ProcessingJob"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface AutoMLContainerDefinition {
  Image: string;
  ModelDataUrl: string;
  Environment?: { [key: string]: string | null | undefined } | null;
}
function toAutoMLContainerDefinition(root: jsonP.JSONValue): AutoMLContainerDefinition {
  return jsonP.readObj({
    required: {
      "Image": "s",
      "ModelDataUrl": "s",
    },
    optional: {
      "Environment": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type AutoMLJobSecondaryStatus =
| "Starting"
| "AnalyzingData"
| "FeatureEngineering"
| "ModelTuning"
| "MaxCandidatesReached"
| "Failed"
| "Stopped"
| "MaxAutoMLJobRuntimeReached"
| "Stopping"
| "CandidateDefinitionsGenerated"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface AutoMLJobArtifacts {
  CandidateDefinitionNotebookLocation?: string | null;
  DataExplorationNotebookLocation?: string | null;
}
function toAutoMLJobArtifacts(root: jsonP.JSONValue): AutoMLJobArtifacts {
  return jsonP.readObj({
    required: {},
    optional: {
      "CandidateDefinitionNotebookLocation": "s",
      "DataExplorationNotebookLocation": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ResolvedAttributes {
  AutoMLJobObjective?: AutoMLJobObjective | null;
  ProblemType?: ProblemType | null;
  CompletionCriteria?: AutoMLJobCompletionCriteria | null;
}
function toResolvedAttributes(root: jsonP.JSONValue): ResolvedAttributes {
  return jsonP.readObj({
    required: {},
    optional: {
      "AutoMLJobObjective": toAutoMLJobObjective,
      "ProblemType": (x: jsonP.JSONValue) => cmnP.readEnum<ProblemType>(x),
      "CompletionCriteria": toAutoMLJobCompletionCriteria,
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface ModelArtifacts {
  S3ModelArtifacts: string;
}
function toModelArtifacts(root: jsonP.JSONValue): ModelArtifacts {
  return jsonP.readObj({
    required: {
      "S3ModelArtifacts": "s",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DomainStatus =
| "Deleting"
| "Failed"
| "InService"
| "Pending"
| "Updating"
| "Update_Failed"
| "Delete_Failed"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ProductionVariantSummary {
  VariantName: string;
  DeployedImages?: DeployedImage[] | null;
  CurrentWeight?: number | null;
  DesiredWeight?: number | null;
  CurrentInstanceCount?: number | null;
  DesiredInstanceCount?: number | null;
}
function toProductionVariantSummary(root: jsonP.JSONValue): ProductionVariantSummary {
  return jsonP.readObj({
    required: {
      "VariantName": "s",
    },
    optional: {
      "DeployedImages": [toDeployedImage],
      "CurrentWeight": "n",
      "DesiredWeight": "n",
      "CurrentInstanceCount": "n",
      "DesiredInstanceCount": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DeployedImage {
  SpecifiedImage?: string | null;
  ResolvedImage?: string | null;
  ResolutionTime?: Date | number | null;
}
function toDeployedImage(root: jsonP.JSONValue): DeployedImage {
  return jsonP.readObj({
    required: {},
    optional: {
      "SpecifiedImage": "s",
      "ResolvedImage": "s",
      "ResolutionTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DataCaptureConfigSummary {
  EnableCapture: boolean;
  CaptureStatus: CaptureStatus;
  CurrentSamplingPercentage: number;
  DestinationS3Uri: string;
  KmsKeyId: string;
}
function toDataCaptureConfigSummary(root: jsonP.JSONValue): DataCaptureConfigSummary {
  return jsonP.readObj({
    required: {
      "EnableCapture": "b",
      "CaptureStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CaptureStatus>(x),
      "CurrentSamplingPercentage": "n",
      "DestinationS3Uri": "s",
      "KmsKeyId": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, enum
export type CaptureStatus =
| "Started"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface ExperimentSource {
  SourceArn: string;
  SourceType?: string | null;
}
function toExperimentSource(root: jsonP.JSONValue): ExperimentSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

// refs: 15 - tags: output, named, interface
export interface UserContext {
  UserProfileArn?: string | null;
  UserProfileName?: string | null;
  DomainId?: string | null;
}
function toUserContext(root: jsonP.JSONValue): UserContext {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserProfileArn": "s",
      "UserProfileName": "s",
      "DomainId": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type FlowDefinitionStatus =
| "Initializing"
| "Active"
| "Failed"
| "Deleting"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, enum
export type HumanTaskUiStatus =
| "Active"
| "Deleting"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface UiTemplateInfo {
  Url?: string | null;
  ContentSha256?: string | null;
}
function toUiTemplateInfo(root: jsonP.JSONValue): UiTemplateInfo {
  return jsonP.readObj({
    required: {},
    optional: {
      "Url": "s",
      "ContentSha256": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TrainingJobStatusCounters {
  Completed?: number | null;
  InProgress?: number | null;
  RetryableError?: number | null;
  NonRetryableError?: number | null;
  Stopped?: number | null;
}
function toTrainingJobStatusCounters(root: jsonP.JSONValue): TrainingJobStatusCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Completed": "n",
      "InProgress": "n",
      "RetryableError": "n",
      "NonRetryableError": "n",
      "Stopped": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ObjectiveStatusCounters {
  Succeeded?: number | null;
  Pending?: number | null;
  Failed?: number | null;
}
function toObjectiveStatusCounters(root: jsonP.JSONValue): ObjectiveStatusCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "Succeeded": "n",
      "Pending": "n",
      "Failed": "n",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface HyperParameterTrainingJobSummary {
  TrainingJobDefinitionName?: string | null;
  TrainingJobName: string;
  TrainingJobArn: string;
  TuningJobName?: string | null;
  CreationTime: Date | number;
  TrainingStartTime?: Date | number | null;
  TrainingEndTime?: Date | number | null;
  TrainingJobStatus: TrainingJobStatus;
  TunedHyperParameters: { [key: string]: string | null | undefined };
  FailureReason?: string | null;
  FinalHyperParameterTuningJobObjectiveMetric?: FinalHyperParameterTuningJobObjectiveMetric | null;
  ObjectiveStatus?: ObjectiveStatus | null;
}
function toHyperParameterTrainingJobSummary(root: jsonP.JSONValue): HyperParameterTrainingJobSummary {
  return jsonP.readObj({
    required: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "CreationTime": "d",
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingJobStatus>(x),
      "TunedHyperParameters": x => jsonP.readMap(String, String, x),
    },
    optional: {
      "TrainingJobDefinitionName": "s",
      "TuningJobName": "s",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "FailureReason": "s",
      "FinalHyperParameterTuningJobObjectiveMetric": toFinalHyperParameterTuningJobObjectiveMetric,
      "ObjectiveStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ObjectiveStatus>(x),
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface FinalHyperParameterTuningJobObjectiveMetric {
  Type?: HyperParameterTuningJobObjectiveType | null;
  MetricName: string;
  Value: number;
}
function toFinalHyperParameterTuningJobObjectiveMetric(root: jsonP.JSONValue): FinalHyperParameterTuningJobObjectiveMetric {
  return jsonP.readObj({
    required: {
      "MetricName": "s",
      "Value": "n",
    },
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobObjectiveType>(x),
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ImageStatus =
| "CREATING"
| "CREATED"
| "CREATE_FAILED"
| "UPDATING"
| "UPDATE_FAILED"
| "DELETING"
| "DELETE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, enum
export type ImageVersionStatus =
| "CREATING"
| "CREATED"
| "CREATE_FAILED"
| "DELETING"
| "DELETE_FAILED"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface LabelCounters {
  TotalLabeled?: number | null;
  HumanLabeled?: number | null;
  MachineLabeled?: number | null;
  FailedNonRetryableError?: number | null;
  Unlabeled?: number | null;
}
function toLabelCounters(root: jsonP.JSONValue): LabelCounters {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalLabeled": "n",
      "HumanLabeled": "n",
      "MachineLabeled": "n",
      "FailedNonRetryableError": "n",
      "Unlabeled": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface LabelingJobOutput {
  OutputDatasetS3Uri: string;
  FinalActiveLearningModelArn?: string | null;
}
function toLabelingJobOutput(root: jsonP.JSONValue): LabelingJobOutput {
  return jsonP.readObj({
    required: {
      "OutputDatasetS3Uri": "s",
    },
    optional: {
      "FinalActiveLearningModelArn": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type ModelPackageStatus =
| "Pending"
| "InProgress"
| "Completed"
| "Failed"
| "Deleting"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface ModelPackageStatusDetails {
  ValidationStatuses: ModelPackageStatusItem[];
  ImageScanStatuses?: ModelPackageStatusItem[] | null;
}
function toModelPackageStatusDetails(root: jsonP.JSONValue): ModelPackageStatusDetails {
  return jsonP.readObj({
    required: {
      "ValidationStatuses": [toModelPackageStatusItem],
    },
    optional: {
      "ImageScanStatuses": [toModelPackageStatusItem],
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface ModelPackageStatusItem {
  Name: string;
  Status: DetailedModelPackageStatus;
  FailureReason?: string | null;
}
function toModelPackageStatusItem(root: jsonP.JSONValue): ModelPackageStatusItem {
  return jsonP.readObj({
    required: {
      "Name": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<DetailedModelPackageStatus>(x),
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type DetailedModelPackageStatus =
| "NotStarted"
| "InProgress"
| "Completed"
| "Failed"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface MonitoringExecutionSummary {
  MonitoringScheduleName: string;
  ScheduledTime: Date | number;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  MonitoringExecutionStatus: ExecutionStatus;
  ProcessingJobArn?: string | null;
  EndpointName?: string | null;
  FailureReason?: string | null;
}
function toMonitoringExecutionSummary(root: jsonP.JSONValue): MonitoringExecutionSummary {
  return jsonP.readObj({
    required: {
      "MonitoringScheduleName": "s",
      "ScheduledTime": "d",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "MonitoringExecutionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ExecutionStatus>(x),
    },
    optional: {
      "ProcessingJobArn": "s",
      "EndpointName": "s",
      "FailureReason": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface SubscribedWorkteam {
  WorkteamArn: string;
  MarketplaceTitle?: string | null;
  SellerName?: string | null;
  MarketplaceDescription?: string | null;
  ListingId?: string | null;
}
function toSubscribedWorkteam(root: jsonP.JSONValue): SubscribedWorkteam {
  return jsonP.readObj({
    required: {
      "WorkteamArn": "s",
    },
    optional: {
      "MarketplaceTitle": "s",
      "SellerName": "s",
      "MarketplaceDescription": "s",
      "ListingId": "s",
    },
  }, root);
}

// refs: 6 - tags: output, named, enum
export type SecondaryStatus =
| "Starting"
| "LaunchingMLInstances"
| "PreparingTrainingStack"
| "Downloading"
| "DownloadingTrainingImage"
| "Training"
| "Uploading"
| "Stopping"
| "Stopped"
| "MaxRuntimeExceeded"
| "Completed"
| "Failed"
| "Interrupted"
| "MaxWaitTimeExceeded"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface SecondaryStatusTransition {
  Status: SecondaryStatus;
  StartTime: Date | number;
  EndTime?: Date | number | null;
  StatusMessage?: string | null;
}
function toSecondaryStatusTransition(root: jsonP.JSONValue): SecondaryStatusTransition {
  return jsonP.readObj({
    required: {
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<SecondaryStatus>(x),
      "StartTime": "d",
    },
    optional: {
      "EndTime": "d",
      "StatusMessage": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface MetricData {
  MetricName?: string | null;
  Value?: number | null;
  Timestamp?: Date | number | null;
}
function toMetricData(root: jsonP.JSONValue): MetricData {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetricName": "s",
      "Value": "n",
      "Timestamp": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface DebugRuleEvaluationStatus {
  RuleConfigurationName?: string | null;
  RuleEvaluationJobArn?: string | null;
  RuleEvaluationStatus?: RuleEvaluationStatus | null;
  StatusDetails?: string | null;
  LastModifiedTime?: Date | number | null;
}
function toDebugRuleEvaluationStatus(root: jsonP.JSONValue): DebugRuleEvaluationStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "RuleConfigurationName": "s",
      "RuleEvaluationJobArn": "s",
      "RuleEvaluationStatus": (x: jsonP.JSONValue) => cmnP.readEnum<RuleEvaluationStatus>(x),
      "StatusDetails": "s",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, enum
export type RuleEvaluationStatus =
| "InProgress"
| "NoIssuesFound"
| "IssuesFound"
| "Error"
| "Stopping"
| "Stopped"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface TrialSource {
  SourceArn: string;
  SourceType?: string | null;
}
function toTrialSource(root: jsonP.JSONValue): TrialSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface TrialComponentSource {
  SourceArn: string;
  SourceType?: string | null;
}
function toTrialComponentSource(root: jsonP.JSONValue): TrialComponentSource {
  return jsonP.readObj({
    required: {
      "SourceArn": "s",
    },
    optional: {
      "SourceType": "s",
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TrialComponentMetricSummary {
  MetricName?: string | null;
  SourceArn?: string | null;
  TimeStamp?: Date | number | null;
  Max?: number | null;
  Min?: number | null;
  Last?: number | null;
  Count?: number | null;
  Avg?: number | null;
  StdDev?: number | null;
}
function toTrialComponentMetricSummary(root: jsonP.JSONValue): TrialComponentMetricSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "MetricName": "s",
      "SourceArn": "s",
      "TimeStamp": "d",
      "Max": "n",
      "Min": "n",
      "Last": "n",
      "Count": "n",
      "Avg": "n",
      "StdDev": "n",
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type UserProfileStatus =
| "Deleting"
| "Failed"
| "InService"
| "Pending"
| "Updating"
| "Update_Failed"
| "Delete_Failed"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface Workforce {
  WorkforceName: string;
  WorkforceArn: string;
  LastUpdatedDate?: Date | number | null;
  SourceIpConfig?: SourceIpConfig | null;
  SubDomain?: string | null;
  CognitoConfig?: CognitoConfig | null;
  OidcConfig?: OidcConfigForResponse | null;
  CreateDate?: Date | number | null;
}
function toWorkforce(root: jsonP.JSONValue): Workforce {
  return jsonP.readObj({
    required: {
      "WorkforceName": "s",
      "WorkforceArn": "s",
    },
    optional: {
      "LastUpdatedDate": "d",
      "SourceIpConfig": toSourceIpConfig,
      "SubDomain": "s",
      "CognitoConfig": toCognitoConfig,
      "OidcConfig": toOidcConfigForResponse,
      "CreateDate": "d",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface OidcConfigForResponse {
  ClientId?: string | null;
  Issuer?: string | null;
  AuthorizationEndpoint?: string | null;
  TokenEndpoint?: string | null;
  UserInfoEndpoint?: string | null;
  LogoutEndpoint?: string | null;
  JwksUri?: string | null;
}
function toOidcConfigForResponse(root: jsonP.JSONValue): OidcConfigForResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ClientId": "s",
      "Issuer": "s",
      "AuthorizationEndpoint": "s",
      "TokenEndpoint": "s",
      "UserInfoEndpoint": "s",
      "LogoutEndpoint": "s",
      "JwksUri": "s",
    },
  }, root);
}

// refs: 3 - tags: output, named, interface
export interface Workteam {
  WorkteamName: string;
  MemberDefinitions: MemberDefinition[];
  WorkteamArn: string;
  WorkforceArn?: string | null;
  ProductListingIds?: string[] | null;
  Description: string;
  SubDomain?: string | null;
  CreateDate?: Date | number | null;
  LastUpdatedDate?: Date | number | null;
  NotificationConfiguration?: NotificationConfiguration | null;
}
function toWorkteam(root: jsonP.JSONValue): Workteam {
  return jsonP.readObj({
    required: {
      "WorkteamName": "s",
      "MemberDefinitions": [toMemberDefinition],
      "WorkteamArn": "s",
      "Description": "s",
    },
    optional: {
      "WorkforceArn": "s",
      "ProductListingIds": ["s"],
      "SubDomain": "s",
      "CreateDate": "d",
      "LastUpdatedDate": "d",
      "NotificationConfiguration": toNotificationConfiguration,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface PropertyNameSuggestion {
  PropertyName?: string | null;
}
function toPropertyNameSuggestion(root: jsonP.JSONValue): PropertyNameSuggestion {
  return jsonP.readObj({
    required: {},
    optional: {
      "PropertyName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AlgorithmSummary {
  AlgorithmName: string;
  AlgorithmArn: string;
  AlgorithmDescription?: string | null;
  CreationTime: Date | number;
  AlgorithmStatus: AlgorithmStatus;
}
function toAlgorithmSummary(root: jsonP.JSONValue): AlgorithmSummary {
  return jsonP.readObj({
    required: {
      "AlgorithmName": "s",
      "AlgorithmArn": "s",
      "CreationTime": "d",
      "AlgorithmStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AlgorithmStatus>(x),
    },
    optional: {
      "AlgorithmDescription": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AppImageConfigDetails {
  AppImageConfigArn?: string | null;
  AppImageConfigName?: string | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  KernelGatewayImageConfig?: KernelGatewayImageConfig | null;
}
function toAppImageConfigDetails(root: jsonP.JSONValue): AppImageConfigDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppImageConfigArn": "s",
      "AppImageConfigName": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "KernelGatewayImageConfig": toKernelGatewayImageConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AppDetails {
  DomainId?: string | null;
  UserProfileName?: string | null;
  AppType?: AppType | null;
  AppName?: string | null;
  Status?: AppStatus | null;
  CreationTime?: Date | number | null;
}
function toAppDetails(root: jsonP.JSONValue): AppDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainId": "s",
      "UserProfileName": "s",
      "AppType": (x: jsonP.JSONValue) => cmnP.readEnum<AppType>(x),
      "AppName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<AppStatus>(x),
      "CreationTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface AutoMLJobSummary {
  AutoMLJobName: string;
  AutoMLJobArn: string;
  AutoMLJobStatus: AutoMLJobStatus;
  AutoMLJobSecondaryStatus: AutoMLJobSecondaryStatus;
  CreationTime: Date | number;
  EndTime?: Date | number | null;
  LastModifiedTime: Date | number;
  FailureReason?: string | null;
}
function toAutoMLJobSummary(root: jsonP.JSONValue): AutoMLJobSummary {
  return jsonP.readObj({
    required: {
      "AutoMLJobName": "s",
      "AutoMLJobArn": "s",
      "AutoMLJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLJobStatus>(x),
      "AutoMLJobSecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<AutoMLJobSecondaryStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "EndTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CodeRepositorySummary {
  CodeRepositoryName: string;
  CodeRepositoryArn: string;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  GitConfig?: GitConfig | null;
}
function toCodeRepositorySummary(root: jsonP.JSONValue): CodeRepositorySummary {
  return jsonP.readObj({
    required: {
      "CodeRepositoryName": "s",
      "CodeRepositoryArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
    optional: {
      "GitConfig": toGitConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface CompilationJobSummary {
  CompilationJobName: string;
  CompilationJobArn: string;
  CreationTime: Date | number;
  CompilationStartTime?: Date | number | null;
  CompilationEndTime?: Date | number | null;
  CompilationTargetDevice?: TargetDevice | null;
  CompilationTargetPlatformOs?: TargetPlatformOs | null;
  CompilationTargetPlatformArch?: TargetPlatformArch | null;
  CompilationTargetPlatformAccelerator?: TargetPlatformAccelerator | null;
  LastModifiedTime?: Date | number | null;
  CompilationJobStatus: CompilationJobStatus;
}
function toCompilationJobSummary(root: jsonP.JSONValue): CompilationJobSummary {
  return jsonP.readObj({
    required: {
      "CompilationJobName": "s",
      "CompilationJobArn": "s",
      "CreationTime": "d",
      "CompilationJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<CompilationJobStatus>(x),
    },
    optional: {
      "CompilationStartTime": "d",
      "CompilationEndTime": "d",
      "CompilationTargetDevice": (x: jsonP.JSONValue) => cmnP.readEnum<TargetDevice>(x),
      "CompilationTargetPlatformOs": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformOs>(x),
      "CompilationTargetPlatformArch": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformArch>(x),
      "CompilationTargetPlatformAccelerator": (x: jsonP.JSONValue) => cmnP.readEnum<TargetPlatformAccelerator>(x),
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface DomainDetails {
  DomainArn?: string | null;
  DomainId?: string | null;
  DomainName?: string | null;
  Status?: DomainStatus | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  Url?: string | null;
}
function toDomainDetails(root: jsonP.JSONValue): DomainDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainArn": "s",
      "DomainId": "s",
      "DomainName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<DomainStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "Url": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EndpointConfigSummary {
  EndpointConfigName: string;
  EndpointConfigArn: string;
  CreationTime: Date | number;
}
function toEndpointConfigSummary(root: jsonP.JSONValue): EndpointConfigSummary {
  return jsonP.readObj({
    required: {
      "EndpointConfigName": "s",
      "EndpointConfigArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface EndpointSummary {
  EndpointName: string;
  EndpointArn: string;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  EndpointStatus: EndpointStatus;
}
function toEndpointSummary(root: jsonP.JSONValue): EndpointSummary {
  return jsonP.readObj({
    required: {
      "EndpointName": "s",
      "EndpointArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "EndpointStatus": (x: jsonP.JSONValue) => cmnP.readEnum<EndpointStatus>(x),
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ExperimentSummary {
  ExperimentArn?: string | null;
  ExperimentName?: string | null;
  DisplayName?: string | null;
  ExperimentSource?: ExperimentSource | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
}
function toExperimentSummary(root: jsonP.JSONValue): ExperimentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentArn": "s",
      "ExperimentName": "s",
      "DisplayName": "s",
      "ExperimentSource": toExperimentSource,
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface FlowDefinitionSummary {
  FlowDefinitionName: string;
  FlowDefinitionArn: string;
  FlowDefinitionStatus: FlowDefinitionStatus;
  CreationTime: Date | number;
  FailureReason?: string | null;
}
function toFlowDefinitionSummary(root: jsonP.JSONValue): FlowDefinitionSummary {
  return jsonP.readObj({
    required: {
      "FlowDefinitionName": "s",
      "FlowDefinitionArn": "s",
      "FlowDefinitionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<FlowDefinitionStatus>(x),
      "CreationTime": "d",
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HumanTaskUiSummary {
  HumanTaskUiName: string;
  HumanTaskUiArn: string;
  CreationTime: Date | number;
}
function toHumanTaskUiSummary(root: jsonP.JSONValue): HumanTaskUiSummary {
  return jsonP.readObj({
    required: {
      "HumanTaskUiName": "s",
      "HumanTaskUiArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface HyperParameterTuningJobSummary {
  HyperParameterTuningJobName: string;
  HyperParameterTuningJobArn: string;
  HyperParameterTuningJobStatus: HyperParameterTuningJobStatus;
  Strategy: HyperParameterTuningJobStrategyType;
  CreationTime: Date | number;
  HyperParameterTuningEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  TrainingJobStatusCounters: TrainingJobStatusCounters;
  ObjectiveStatusCounters: ObjectiveStatusCounters;
  ResourceLimits?: ResourceLimits | null;
}
function toHyperParameterTuningJobSummary(root: jsonP.JSONValue): HyperParameterTuningJobSummary {
  return jsonP.readObj({
    required: {
      "HyperParameterTuningJobName": "s",
      "HyperParameterTuningJobArn": "s",
      "HyperParameterTuningJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobStatus>(x),
      "Strategy": (x: jsonP.JSONValue) => cmnP.readEnum<HyperParameterTuningJobStrategyType>(x),
      "CreationTime": "d",
      "TrainingJobStatusCounters": toTrainingJobStatusCounters,
      "ObjectiveStatusCounters": toObjectiveStatusCounters,
    },
    optional: {
      "HyperParameterTuningEndTime": "d",
      "LastModifiedTime": "d",
      "ResourceLimits": toResourceLimits,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ImageVersion {
  CreationTime: Date | number;
  FailureReason?: string | null;
  ImageArn: string;
  ImageVersionArn: string;
  ImageVersionStatus: ImageVersionStatus;
  LastModifiedTime: Date | number;
  Version: number;
}
function toImageVersion(root: jsonP.JSONValue): ImageVersion {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "ImageArn": "s",
      "ImageVersionArn": "s",
      "ImageVersionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImageVersionStatus>(x),
      "LastModifiedTime": "d",
      "Version": "n",
    },
    optional: {
      "FailureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Image {
  CreationTime: Date | number;
  Description?: string | null;
  DisplayName?: string | null;
  FailureReason?: string | null;
  ImageArn: string;
  ImageName: string;
  ImageStatus: ImageStatus;
  LastModifiedTime: Date | number;
}
function toImage(root: jsonP.JSONValue): Image {
  return jsonP.readObj({
    required: {
      "CreationTime": "d",
      "ImageArn": "s",
      "ImageName": "s",
      "ImageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ImageStatus>(x),
      "LastModifiedTime": "d",
    },
    optional: {
      "Description": "s",
      "DisplayName": "s",
      "FailureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LabelingJobSummary {
  LabelingJobName: string;
  LabelingJobArn: string;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  LabelingJobStatus: LabelingJobStatus;
  LabelCounters: LabelCounters;
  WorkteamArn: string;
  PreHumanTaskLambdaArn: string;
  AnnotationConsolidationLambdaArn?: string | null;
  FailureReason?: string | null;
  LabelingJobOutput?: LabelingJobOutput | null;
  InputConfig?: LabelingJobInputConfig | null;
}
function toLabelingJobSummary(root: jsonP.JSONValue): LabelingJobSummary {
  return jsonP.readObj({
    required: {
      "LabelingJobName": "s",
      "LabelingJobArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "LabelingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<LabelingJobStatus>(x),
      "LabelCounters": toLabelCounters,
      "WorkteamArn": "s",
      "PreHumanTaskLambdaArn": "s",
    },
    optional: {
      "AnnotationConsolidationLambdaArn": "s",
      "FailureReason": "s",
      "LabelingJobOutput": toLabelingJobOutput,
      "InputConfig": toLabelingJobInputConfig,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LabelingJobForWorkteamSummary {
  LabelingJobName?: string | null;
  JobReferenceCode: string;
  WorkRequesterAccountId: string;
  CreationTime: Date | number;
  LabelCounters?: LabelCountersForWorkteam | null;
  NumberOfHumanWorkersPerDataObject?: number | null;
}
function toLabelingJobForWorkteamSummary(root: jsonP.JSONValue): LabelingJobForWorkteamSummary {
  return jsonP.readObj({
    required: {
      "JobReferenceCode": "s",
      "WorkRequesterAccountId": "s",
      "CreationTime": "d",
    },
    optional: {
      "LabelingJobName": "s",
      "LabelCounters": toLabelCountersForWorkteam,
      "NumberOfHumanWorkersPerDataObject": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface LabelCountersForWorkteam {
  HumanLabeled?: number | null;
  PendingHuman?: number | null;
  Total?: number | null;
}
function toLabelCountersForWorkteam(root: jsonP.JSONValue): LabelCountersForWorkteam {
  return jsonP.readObj({
    required: {},
    optional: {
      "HumanLabeled": "n",
      "PendingHuman": "n",
      "Total": "n",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ModelPackageSummary {
  ModelPackageName: string;
  ModelPackageArn: string;
  ModelPackageDescription?: string | null;
  CreationTime: Date | number;
  ModelPackageStatus: ModelPackageStatus;
}
function toModelPackageSummary(root: jsonP.JSONValue): ModelPackageSummary {
  return jsonP.readObj({
    required: {
      "ModelPackageName": "s",
      "ModelPackageArn": "s",
      "CreationTime": "d",
      "ModelPackageStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ModelPackageStatus>(x),
    },
    optional: {
      "ModelPackageDescription": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ModelSummary {
  ModelName: string;
  ModelArn: string;
  CreationTime: Date | number;
}
function toModelSummary(root: jsonP.JSONValue): ModelSummary {
  return jsonP.readObj({
    required: {
      "ModelName": "s",
      "ModelArn": "s",
      "CreationTime": "d",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface MonitoringScheduleSummary {
  MonitoringScheduleName: string;
  MonitoringScheduleArn: string;
  CreationTime: Date | number;
  LastModifiedTime: Date | number;
  MonitoringScheduleStatus: ScheduleStatus;
  EndpointName?: string | null;
}
function toMonitoringScheduleSummary(root: jsonP.JSONValue): MonitoringScheduleSummary {
  return jsonP.readObj({
    required: {
      "MonitoringScheduleName": "s",
      "MonitoringScheduleArn": "s",
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "MonitoringScheduleStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ScheduleStatus>(x),
    },
    optional: {
      "EndpointName": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookInstanceLifecycleConfigSummary {
  NotebookInstanceLifecycleConfigName: string;
  NotebookInstanceLifecycleConfigArn: string;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
}
function toNotebookInstanceLifecycleConfigSummary(root: jsonP.JSONValue): NotebookInstanceLifecycleConfigSummary {
  return jsonP.readObj({
    required: {
      "NotebookInstanceLifecycleConfigName": "s",
      "NotebookInstanceLifecycleConfigArn": "s",
    },
    optional: {
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface NotebookInstanceSummary {
  NotebookInstanceName: string;
  NotebookInstanceArn: string;
  NotebookInstanceStatus?: NotebookInstanceStatus | null;
  Url?: string | null;
  InstanceType?: InstanceType | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  NotebookInstanceLifecycleConfigName?: string | null;
  DefaultCodeRepository?: string | null;
  AdditionalCodeRepositories?: string[] | null;
}
function toNotebookInstanceSummary(root: jsonP.JSONValue): NotebookInstanceSummary {
  return jsonP.readObj({
    required: {
      "NotebookInstanceName": "s",
      "NotebookInstanceArn": "s",
    },
    optional: {
      "NotebookInstanceStatus": (x: jsonP.JSONValue) => cmnP.readEnum<NotebookInstanceStatus>(x),
      "Url": "s",
      "InstanceType": (x: jsonP.JSONValue) => cmnP.readEnum<InstanceType>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
      "NotebookInstanceLifecycleConfigName": "s",
      "DefaultCodeRepository": "s",
      "AdditionalCodeRepositories": ["s"],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ProcessingJobSummary {
  ProcessingJobName: string;
  ProcessingJobArn: string;
  CreationTime: Date | number;
  ProcessingEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  ProcessingJobStatus: ProcessingJobStatus;
  FailureReason?: string | null;
  ExitMessage?: string | null;
}
function toProcessingJobSummary(root: jsonP.JSONValue): ProcessingJobSummary {
  return jsonP.readObj({
    required: {
      "ProcessingJobName": "s",
      "ProcessingJobArn": "s",
      "CreationTime": "d",
      "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingJobStatus>(x),
    },
    optional: {
      "ProcessingEndTime": "d",
      "LastModifiedTime": "d",
      "FailureReason": "s",
      "ExitMessage": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrainingJobSummary {
  TrainingJobName: string;
  TrainingJobArn: string;
  CreationTime: Date | number;
  TrainingEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  TrainingJobStatus: TrainingJobStatus;
}
function toTrainingJobSummary(root: jsonP.JSONValue): TrainingJobSummary {
  return jsonP.readObj({
    required: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "CreationTime": "d",
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingJobStatus>(x),
    },
    optional: {
      "TrainingEndTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TransformJobSummary {
  TransformJobName: string;
  TransformJobArn: string;
  CreationTime: Date | number;
  TransformEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  TransformJobStatus: TransformJobStatus;
  FailureReason?: string | null;
}
function toTransformJobSummary(root: jsonP.JSONValue): TransformJobSummary {
  return jsonP.readObj({
    required: {
      "TransformJobName": "s",
      "TransformJobArn": "s",
      "CreationTime": "d",
      "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TransformJobStatus>(x),
    },
    optional: {
      "TransformEndTime": "d",
      "LastModifiedTime": "d",
      "FailureReason": "s",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrialComponentSummary {
  TrialComponentName?: string | null;
  TrialComponentArn?: string | null;
  DisplayName?: string | null;
  TrialComponentSource?: TrialComponentSource | null;
  Status?: TrialComponentStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
}
function toTrialComponentSummary(root: jsonP.JSONValue): TrialComponentSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "TrialComponentArn": "s",
      "DisplayName": "s",
      "TrialComponentSource": toTrialComponentSource,
      "Status": toTrialComponentStatus,
      "StartTime": "d",
      "EndTime": "d",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrialSummary {
  TrialArn?: string | null;
  TrialName?: string | null;
  DisplayName?: string | null;
  TrialSource?: TrialSource | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
}
function toTrialSummary(root: jsonP.JSONValue): TrialSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialArn": "s",
      "TrialName": "s",
      "DisplayName": "s",
      "TrialSource": toTrialSource,
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface UserProfileDetails {
  DomainId?: string | null;
  UserProfileName?: string | null;
  Status?: UserProfileStatus | null;
  CreationTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
}
function toUserProfileDetails(root: jsonP.JSONValue): UserProfileDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "DomainId": "s",
      "UserProfileName": "s",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<UserProfileStatus>(x),
      "CreationTime": "d",
      "LastModifiedTime": "d",
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface RenderingError {
  Code: string;
  Message: string;
}
function toRenderingError(root: jsonP.JSONValue): RenderingError {
  return jsonP.readObj({
    required: {
      "Code": "s",
      "Message": "s",
    },
    optional: {},
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface SearchRecord {
  TrainingJob?: TrainingJob | null;
  Experiment?: Experiment | null;
  Trial?: Trial | null;
  TrialComponent?: TrialComponent | null;
}
function toSearchRecord(root: jsonP.JSONValue): SearchRecord {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrainingJob": toTrainingJob,
      "Experiment": toExperiment,
      "Trial": toTrial,
      "TrialComponent": toTrialComponent,
    },
  }, root);
}

// refs: 2 - tags: output, named, interface
export interface TrainingJob {
  TrainingJobName?: string | null;
  TrainingJobArn?: string | null;
  TuningJobArn?: string | null;
  LabelingJobArn?: string | null;
  AutoMLJobArn?: string | null;
  ModelArtifacts?: ModelArtifacts | null;
  TrainingJobStatus?: TrainingJobStatus | null;
  SecondaryStatus?: SecondaryStatus | null;
  FailureReason?: string | null;
  HyperParameters?: { [key: string]: string | null | undefined } | null;
  AlgorithmSpecification?: AlgorithmSpecification | null;
  RoleArn?: string | null;
  InputDataConfig?: Channel[] | null;
  OutputDataConfig?: OutputDataConfig | null;
  ResourceConfig?: ResourceConfig | null;
  VpcConfig?: VpcConfig | null;
  StoppingCondition?: StoppingCondition | null;
  CreationTime?: Date | number | null;
  TrainingStartTime?: Date | number | null;
  TrainingEndTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  SecondaryStatusTransitions?: SecondaryStatusTransition[] | null;
  FinalMetricDataList?: MetricData[] | null;
  EnableNetworkIsolation?: boolean | null;
  EnableInterContainerTrafficEncryption?: boolean | null;
  EnableManagedSpotTraining?: boolean | null;
  CheckpointConfig?: CheckpointConfig | null;
  TrainingTimeInSeconds?: number | null;
  BillableTimeInSeconds?: number | null;
  DebugHookConfig?: DebugHookConfig | null;
  ExperimentConfig?: ExperimentConfig | null;
  DebugRuleConfigurations?: DebugRuleConfiguration[] | null;
  TensorBoardOutputConfig?: TensorBoardOutputConfig | null;
  DebugRuleEvaluationStatuses?: DebugRuleEvaluationStatus[] | null;
  Tags?: Tag[] | null;
}
function toTrainingJob(root: jsonP.JSONValue): TrainingJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrainingJobName": "s",
      "TrainingJobArn": "s",
      "TuningJobArn": "s",
      "LabelingJobArn": "s",
      "AutoMLJobArn": "s",
      "ModelArtifacts": toModelArtifacts,
      "TrainingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TrainingJobStatus>(x),
      "SecondaryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SecondaryStatus>(x),
      "FailureReason": "s",
      "HyperParameters": x => jsonP.readMap(String, String, x),
      "AlgorithmSpecification": toAlgorithmSpecification,
      "RoleArn": "s",
      "InputDataConfig": [toChannel],
      "OutputDataConfig": toOutputDataConfig,
      "ResourceConfig": toResourceConfig,
      "VpcConfig": toVpcConfig,
      "StoppingCondition": toStoppingCondition,
      "CreationTime": "d",
      "TrainingStartTime": "d",
      "TrainingEndTime": "d",
      "LastModifiedTime": "d",
      "SecondaryStatusTransitions": [toSecondaryStatusTransition],
      "FinalMetricDataList": [toMetricData],
      "EnableNetworkIsolation": "b",
      "EnableInterContainerTrafficEncryption": "b",
      "EnableManagedSpotTraining": "b",
      "CheckpointConfig": toCheckpointConfig,
      "TrainingTimeInSeconds": "n",
      "BillableTimeInSeconds": "n",
      "DebugHookConfig": toDebugHookConfig,
      "ExperimentConfig": toExperimentConfig,
      "DebugRuleConfigurations": [toDebugRuleConfiguration],
      "TensorBoardOutputConfig": toTensorBoardOutputConfig,
      "DebugRuleEvaluationStatuses": [toDebugRuleEvaluationStatus],
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Experiment {
  ExperimentName?: string | null;
  ExperimentArn?: string | null;
  DisplayName?: string | null;
  Source?: ExperimentSource | null;
  Description?: string | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
  Tags?: Tag[] | null;
}
function toExperiment(root: jsonP.JSONValue): Experiment {
  return jsonP.readObj({
    required: {},
    optional: {
      "ExperimentName": "s",
      "ExperimentArn": "s",
      "DisplayName": "s",
      "Source": toExperimentSource,
      "Description": "s",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Trial {
  TrialName?: string | null;
  TrialArn?: string | null;
  DisplayName?: string | null;
  ExperimentName?: string | null;
  Source?: TrialSource | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
  Tags?: Tag[] | null;
  TrialComponentSummaries?: TrialComponentSimpleSummary[] | null;
}
function toTrial(root: jsonP.JSONValue): Trial {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialName": "s",
      "TrialArn": "s",
      "DisplayName": "s",
      "ExperimentName": "s",
      "Source": toTrialSource,
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "Tags": [toTag],
      "TrialComponentSummaries": [toTrialComponentSimpleSummary],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrialComponentSimpleSummary {
  TrialComponentName?: string | null;
  TrialComponentArn?: string | null;
  TrialComponentSource?: TrialComponentSource | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
}
function toTrialComponentSimpleSummary(root: jsonP.JSONValue): TrialComponentSimpleSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "TrialComponentArn": "s",
      "TrialComponentSource": toTrialComponentSource,
      "CreationTime": "d",
      "CreatedBy": toUserContext,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrialComponent {
  TrialComponentName?: string | null;
  DisplayName?: string | null;
  TrialComponentArn?: string | null;
  Source?: TrialComponentSource | null;
  Status?: TrialComponentStatus | null;
  StartTime?: Date | number | null;
  EndTime?: Date | number | null;
  CreationTime?: Date | number | null;
  CreatedBy?: UserContext | null;
  LastModifiedTime?: Date | number | null;
  LastModifiedBy?: UserContext | null;
  Parameters?: { [key: string]: TrialComponentParameterValue | null | undefined } | null;
  InputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  OutputArtifacts?: { [key: string]: TrialComponentArtifact | null | undefined } | null;
  Metrics?: TrialComponentMetricSummary[] | null;
  SourceDetail?: TrialComponentSourceDetail | null;
  Tags?: Tag[] | null;
  Parents?: Parent[] | null;
}
function toTrialComponent(root: jsonP.JSONValue): TrialComponent {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialComponentName": "s",
      "DisplayName": "s",
      "TrialComponentArn": "s",
      "Source": toTrialComponentSource,
      "Status": toTrialComponentStatus,
      "StartTime": "d",
      "EndTime": "d",
      "CreationTime": "d",
      "CreatedBy": toUserContext,
      "LastModifiedTime": "d",
      "LastModifiedBy": toUserContext,
      "Parameters": x => jsonP.readMap(String, toTrialComponentParameterValue, x),
      "InputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
      "OutputArtifacts": x => jsonP.readMap(String, toTrialComponentArtifact, x),
      "Metrics": [toTrialComponentMetricSummary],
      "SourceDetail": toTrialComponentSourceDetail,
      "Tags": [toTag],
      "Parents": [toParent],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TrialComponentSourceDetail {
  SourceArn?: string | null;
  TrainingJob?: TrainingJob | null;
  ProcessingJob?: ProcessingJob | null;
  TransformJob?: TransformJob | null;
}
function toTrialComponentSourceDetail(root: jsonP.JSONValue): TrialComponentSourceDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "SourceArn": "s",
      "TrainingJob": toTrainingJob,
      "ProcessingJob": toProcessingJob,
      "TransformJob": toTransformJob,
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface ProcessingJob {
  ProcessingInputs?: ProcessingInput[] | null;
  ProcessingOutputConfig?: ProcessingOutputConfig | null;
  ProcessingJobName?: string | null;
  ProcessingResources?: ProcessingResources | null;
  StoppingCondition?: ProcessingStoppingCondition | null;
  AppSpecification?: AppSpecification | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  NetworkConfig?: NetworkConfig | null;
  RoleArn?: string | null;
  ExperimentConfig?: ExperimentConfig | null;
  ProcessingJobArn?: string | null;
  ProcessingJobStatus?: ProcessingJobStatus | null;
  ExitMessage?: string | null;
  FailureReason?: string | null;
  ProcessingEndTime?: Date | number | null;
  ProcessingStartTime?: Date | number | null;
  LastModifiedTime?: Date | number | null;
  CreationTime?: Date | number | null;
  MonitoringScheduleArn?: string | null;
  AutoMLJobArn?: string | null;
  TrainingJobArn?: string | null;
  Tags?: Tag[] | null;
}
function toProcessingJob(root: jsonP.JSONValue): ProcessingJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "ProcessingInputs": [toProcessingInput],
      "ProcessingOutputConfig": toProcessingOutputConfig,
      "ProcessingJobName": "s",
      "ProcessingResources": toProcessingResources,
      "StoppingCondition": toProcessingStoppingCondition,
      "AppSpecification": toAppSpecification,
      "Environment": x => jsonP.readMap(String, String, x),
      "NetworkConfig": toNetworkConfig,
      "RoleArn": "s",
      "ExperimentConfig": toExperimentConfig,
      "ProcessingJobArn": "s",
      "ProcessingJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<ProcessingJobStatus>(x),
      "ExitMessage": "s",
      "FailureReason": "s",
      "ProcessingEndTime": "d",
      "ProcessingStartTime": "d",
      "LastModifiedTime": "d",
      "CreationTime": "d",
      "MonitoringScheduleArn": "s",
      "AutoMLJobArn": "s",
      "TrainingJobArn": "s",
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface TransformJob {
  TransformJobName?: string | null;
  TransformJobArn?: string | null;
  TransformJobStatus?: TransformJobStatus | null;
  FailureReason?: string | null;
  ModelName?: string | null;
  MaxConcurrentTransforms?: number | null;
  ModelClientConfig?: ModelClientConfig | null;
  MaxPayloadInMB?: number | null;
  BatchStrategy?: BatchStrategy | null;
  Environment?: { [key: string]: string | null | undefined } | null;
  TransformInput?: TransformInput | null;
  TransformOutput?: TransformOutput | null;
  TransformResources?: TransformResources | null;
  CreationTime?: Date | number | null;
  TransformStartTime?: Date | number | null;
  TransformEndTime?: Date | number | null;
  LabelingJobArn?: string | null;
  AutoMLJobArn?: string | null;
  DataProcessing?: DataProcessing | null;
  ExperimentConfig?: ExperimentConfig | null;
  Tags?: Tag[] | null;
}
function toTransformJob(root: jsonP.JSONValue): TransformJob {
  return jsonP.readObj({
    required: {},
    optional: {
      "TransformJobName": "s",
      "TransformJobArn": "s",
      "TransformJobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TransformJobStatus>(x),
      "FailureReason": "s",
      "ModelName": "s",
      "MaxConcurrentTransforms": "n",
      "ModelClientConfig": toModelClientConfig,
      "MaxPayloadInMB": "n",
      "BatchStrategy": (x: jsonP.JSONValue) => cmnP.readEnum<BatchStrategy>(x),
      "Environment": x => jsonP.readMap(String, String, x),
      "TransformInput": toTransformInput,
      "TransformOutput": toTransformOutput,
      "TransformResources": toTransformResources,
      "CreationTime": "d",
      "TransformStartTime": "d",
      "TransformEndTime": "d",
      "LabelingJobArn": "s",
      "AutoMLJobArn": "s",
      "DataProcessing": toDataProcessing,
      "ExperimentConfig": toExperimentConfig,
      "Tags": [toTag],
    },
  }, root);
}

// refs: 1 - tags: output, named, interface
export interface Parent {
  TrialName?: string | null;
  ExperimentName?: string | null;
}
function toParent(root: jsonP.JSONValue): Parent {
  return jsonP.readObj({
    required: {},
    optional: {
      "TrialName": "s",
      "ExperimentName": "s",
    },
  }, root);
}
