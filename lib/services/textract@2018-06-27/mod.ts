// Autogenerated API client for: Amazon Textract

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class Textract {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Textract.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-06-27",
    "endpointPrefix": "textract",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Textract",
    "serviceId": "Textract",
    "signatureVersion": "v4",
    "targetPrefix": "Textract",
    "uid": "textract-2018-06-27"
  };

  async analyzeDocument(
    {abortSignal, ...params}: RequestConfig & AnalyzeDocumentRequest,
  ): Promise<AnalyzeDocumentResponse> {
    const body: jsonP.JSONObject = {
      Document: fromDocument(params["Document"]),
      FeatureTypes: params["FeatureTypes"],
      HumanLoopConfig: fromHumanLoopConfig(params["HumanLoopConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AnalyzeDocument",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentMetadata": toDocumentMetadata,
        "Blocks": [toBlock],
        "HumanLoopActivationOutput": toHumanLoopActivationOutput,
        "AnalyzeDocumentModelVersion": "s",
      },
    }, await resp.json());
  }

  async detectDocumentText(
    {abortSignal, ...params}: RequestConfig & DetectDocumentTextRequest,
  ): Promise<DetectDocumentTextResponse> {
    const body: jsonP.JSONObject = {
      Document: fromDocument(params["Document"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DetectDocumentText",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentMetadata": toDocumentMetadata,
        "Blocks": [toBlock],
        "DetectDocumentTextModelVersion": "s",
      },
    }, await resp.json());
  }

  async getDocumentAnalysis(
    {abortSignal, ...params}: RequestConfig & GetDocumentAnalysisRequest,
  ): Promise<GetDocumentAnalysisResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDocumentAnalysis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentMetadata": toDocumentMetadata,
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
        "NextToken": "s",
        "Blocks": [toBlock],
        "Warnings": [toWarning],
        "StatusMessage": "s",
        "AnalyzeDocumentModelVersion": "s",
      },
    }, await resp.json());
  }

  async getDocumentTextDetection(
    {abortSignal, ...params}: RequestConfig & GetDocumentTextDetectionRequest,
  ): Promise<GetDocumentTextDetectionResponse> {
    const body: jsonP.JSONObject = {
      JobId: params["JobId"],
      MaxResults: params["MaxResults"],
      NextToken: params["NextToken"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetDocumentTextDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "DocumentMetadata": toDocumentMetadata,
        "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<JobStatus>(x),
        "NextToken": "s",
        "Blocks": [toBlock],
        "Warnings": [toWarning],
        "StatusMessage": "s",
        "DetectDocumentTextModelVersion": "s",
      },
    }, await resp.json());
  }

  async startDocumentAnalysis(
    {abortSignal, ...params}: RequestConfig & StartDocumentAnalysisRequest,
  ): Promise<StartDocumentAnalysisResponse> {
    const body: jsonP.JSONObject = {
      DocumentLocation: fromDocumentLocation(params["DocumentLocation"]),
      FeatureTypes: params["FeatureTypes"],
      ClientRequestToken: params["ClientRequestToken"],
      JobTag: params["JobTag"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDocumentAnalysis",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

  async startDocumentTextDetection(
    {abortSignal, ...params}: RequestConfig & StartDocumentTextDetectionRequest,
  ): Promise<StartDocumentTextDetectionResponse> {
    const body: jsonP.JSONObject = {
      DocumentLocation: fromDocumentLocation(params["DocumentLocation"]),
      ClientRequestToken: params["ClientRequestToken"],
      JobTag: params["JobTag"],
      NotificationChannel: fromNotificationChannel(params["NotificationChannel"]),
      OutputConfig: fromOutputConfig(params["OutputConfig"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "StartDocumentTextDetection",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "JobId": "s",
      },
    }, await resp.json());
  }

}

// refs: 1 - tags: named, input
export interface AnalyzeDocumentRequest {
  Document: Document;
  FeatureTypes: FeatureType[];
  HumanLoopConfig?: HumanLoopConfig | null;
}

// refs: 1 - tags: named, input
export interface DetectDocumentTextRequest {
  Document: Document;
}

// refs: 1 - tags: named, input
export interface GetDocumentAnalysisRequest {
  JobId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface GetDocumentTextDetectionRequest {
  JobId: string;
  MaxResults?: number | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, input
export interface StartDocumentAnalysisRequest {
  DocumentLocation: DocumentLocation;
  FeatureTypes: FeatureType[];
  ClientRequestToken?: string | null;
  JobTag?: string | null;
  NotificationChannel?: NotificationChannel | null;
  OutputConfig?: OutputConfig | null;
}

// refs: 1 - tags: named, input
export interface StartDocumentTextDetectionRequest {
  DocumentLocation: DocumentLocation;
  ClientRequestToken?: string | null;
  JobTag?: string | null;
  NotificationChannel?: NotificationChannel | null;
  OutputConfig?: OutputConfig | null;
}

// refs: 1 - tags: named, output
export interface AnalyzeDocumentResponse {
  DocumentMetadata?: DocumentMetadata | null;
  Blocks?: Block[] | null;
  HumanLoopActivationOutput?: HumanLoopActivationOutput | null;
  AnalyzeDocumentModelVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface DetectDocumentTextResponse {
  DocumentMetadata?: DocumentMetadata | null;
  Blocks?: Block[] | null;
  DetectDocumentTextModelVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDocumentAnalysisResponse {
  DocumentMetadata?: DocumentMetadata | null;
  JobStatus?: JobStatus | null;
  NextToken?: string | null;
  Blocks?: Block[] | null;
  Warnings?: Warning[] | null;
  StatusMessage?: string | null;
  AnalyzeDocumentModelVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDocumentTextDetectionResponse {
  DocumentMetadata?: DocumentMetadata | null;
  JobStatus?: JobStatus | null;
  NextToken?: string | null;
  Blocks?: Block[] | null;
  Warnings?: Warning[] | null;
  StatusMessage?: string | null;
  DetectDocumentTextModelVersion?: string | null;
}

// refs: 1 - tags: named, output
export interface StartDocumentAnalysisResponse {
  JobId?: string | null;
}

// refs: 1 - tags: named, output
export interface StartDocumentTextDetectionResponse {
  JobId?: string | null;
}

// refs: 2 - tags: input, named, interface
export interface Document {
  Bytes?: Uint8Array | string | null;
  S3Object?: S3Object | null;
}
function fromDocument(input?: Document | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bytes: jsonP.serializeBlob(input["Bytes"]),
    S3Object: fromS3Object(input["S3Object"]),
  }
}

// refs: 4 - tags: input, named, interface
export interface S3Object {
  Bucket?: string | null;
  Name?: string | null;
  Version?: string | null;
}
function fromS3Object(input?: S3Object | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Bucket: input["Bucket"],
    Name: input["Name"],
    Version: input["Version"],
  }
}

// refs: 2 - tags: input, named, enum
export type FeatureType =
| "TABLES"
| "FORMS"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface HumanLoopConfig {
  HumanLoopName: string;
  FlowDefinitionArn: string;
  DataAttributes?: HumanLoopDataAttributes | null;
}
function fromHumanLoopConfig(input?: HumanLoopConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HumanLoopName: input["HumanLoopName"],
    FlowDefinitionArn: input["FlowDefinitionArn"],
    DataAttributes: fromHumanLoopDataAttributes(input["DataAttributes"]),
  }
}

// refs: 1 - tags: input, named, interface
export interface HumanLoopDataAttributes {
  ContentClassifiers?: ContentClassifier[] | null;
}
function fromHumanLoopDataAttributes(input?: HumanLoopDataAttributes | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ContentClassifiers: input["ContentClassifiers"],
  }
}

// refs: 1 - tags: input, named, enum
export type ContentClassifier =
| "FreeOfPersonallyIdentifiableInformation"
| "FreeOfAdultContent"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, interface
export interface DocumentLocation {
  S3Object?: S3Object | null;
}
function fromDocumentLocation(input?: DocumentLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Object: fromS3Object(input["S3Object"]),
  }
}

// refs: 2 - tags: input, named, interface
export interface NotificationChannel {
  SNSTopicArn: string;
  RoleArn: string;
}
function fromNotificationChannel(input?: NotificationChannel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SNSTopicArn: input["SNSTopicArn"],
    RoleArn: input["RoleArn"],
  }
}

// refs: 2 - tags: input, named, interface
export interface OutputConfig {
  S3Bucket: string;
  S3Prefix?: string | null;
}
function fromOutputConfig(input?: OutputConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Bucket: input["S3Bucket"],
    S3Prefix: input["S3Prefix"],
  }
}

// refs: 4 - tags: output, named, interface
export interface DocumentMetadata {
  Pages?: number | null;
}
function toDocumentMetadata(root: jsonP.JSONValue): DocumentMetadata {
  return jsonP.readObj({
    required: {},
    optional: {
      "Pages": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Block {
  BlockType?: BlockType | null;
  Confidence?: number | null;
  Text?: string | null;
  RowIndex?: number | null;
  ColumnIndex?: number | null;
  RowSpan?: number | null;
  ColumnSpan?: number | null;
  Geometry?: Geometry | null;
  Id?: string | null;
  Relationships?: Relationship[] | null;
  EntityTypes?: EntityType[] | null;
  SelectionStatus?: SelectionStatus | null;
  Page?: number | null;
}
function toBlock(root: jsonP.JSONValue): Block {
  return jsonP.readObj({
    required: {},
    optional: {
      "BlockType": (x: jsonP.JSONValue) => cmnP.readEnum<BlockType>(x),
      "Confidence": "n",
      "Text": "s",
      "RowIndex": "n",
      "ColumnIndex": "n",
      "RowSpan": "n",
      "ColumnSpan": "n",
      "Geometry": toGeometry,
      "Id": "s",
      "Relationships": [toRelationship],
      "EntityTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<EntityType>(x)],
      "SelectionStatus": (x: jsonP.JSONValue) => cmnP.readEnum<SelectionStatus>(x),
      "Page": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type BlockType =
| "KEY_VALUE_SET"
| "PAGE"
| "LINE"
| "WORD"
| "TABLE"
| "CELL"
| "SELECTION_ELEMENT"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Geometry {
  BoundingBox?: BoundingBox | null;
  Polygon?: Point[] | null;
}
function toGeometry(root: jsonP.JSONValue): Geometry {
  return jsonP.readObj({
    required: {},
    optional: {
      "BoundingBox": toBoundingBox,
      "Polygon": [toPoint],
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface BoundingBox {
  Width?: number | null;
  Height?: number | null;
  Left?: number | null;
  Top?: number | null;
}
function toBoundingBox(root: jsonP.JSONValue): BoundingBox {
  return jsonP.readObj({
    required: {},
    optional: {
      "Width": "n",
      "Height": "n",
      "Left": "n",
      "Top": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Point {
  X?: number | null;
  Y?: number | null;
}
function toPoint(root: jsonP.JSONValue): Point {
  return jsonP.readObj({
    required: {},
    optional: {
      "X": "n",
      "Y": "n",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Relationship {
  Type?: RelationshipType | null;
  Ids?: string[] | null;
}
function toRelationship(root: jsonP.JSONValue): Relationship {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<RelationshipType>(x),
      "Ids": ["s"],
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type RelationshipType =
| "VALUE"
| "CHILD"
| "COMPLEX_FEATURES"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type EntityType =
| "KEY"
| "VALUE"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, enum
export type SelectionStatus =
| "SELECTED"
| "NOT_SELECTED"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface HumanLoopActivationOutput {
  HumanLoopArn?: string | null;
  HumanLoopActivationReasons?: string[] | null;
  HumanLoopActivationConditionsEvaluationResults?: jsonP.JSONValue | null;
}
function toHumanLoopActivationOutput(root: jsonP.JSONValue): HumanLoopActivationOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "HumanLoopArn": "s",
      "HumanLoopActivationReasons": ["s"],
      "HumanLoopActivationConditionsEvaluationResults": jsonP.readJsonValue,
    },
  }, root);
}

// refs: 2 - tags: output, named, enum
export type JobStatus =
| "IN_PROGRESS"
| "SUCCEEDED"
| "FAILED"
| "PARTIAL_SUCCESS"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: output, named, interface
export interface Warning {
  ErrorCode?: string | null;
  Pages?: number[] | null;
}
function toWarning(root: jsonP.JSONValue): Warning {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "Pages": ["n"],
    },
  }, root);
}
