// Autogenerated API client for: Amazon Pinpoint

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.91.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export default class Pinpoint {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Pinpoint.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2016-12-01",
    "endpointPrefix": "pinpoint",
    "signingName": "mobiletargeting",
    "serviceFullName": "Amazon Pinpoint",
    "serviceId": "Pinpoint",
    "protocol": "rest-json",
    "jsonVersion": "1.1",
    "uid": "pinpoint-2016-12-01",
    "signatureVersion": "v4"
  };

  async createApp(
    {abortSignal, ...params}: RequestConfig & s.CreateAppRequest,
  ): Promise<s.CreateAppResponse> {
    const inner = params["CreateApplicationRequest"];
    const body: jsonP.JSONObject = inner ? {
      Name: inner["Name"],
      tags: inner["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateApp",
      requestUri: "/v1/apps",
      responseCode: 201,
    });
  return {
    ApplicationResponse: toApplicationResponse(await resp.json()),
  };
  }

  async createCampaign(
    {abortSignal, ...params}: RequestConfig & s.CreateCampaignRequest,
  ): Promise<s.CreateCampaignResponse> {
    const inner = params["WriteCampaignRequest"];
    const body: jsonP.JSONObject = inner ? {
      AdditionalTreatments: inner["AdditionalTreatments"]?.map(x => fromWriteTreatmentResource(x)),
      CustomDeliveryConfiguration: fromCustomDeliveryConfiguration(inner["CustomDeliveryConfiguration"]),
      Description: inner["Description"],
      HoldoutPercent: inner["HoldoutPercent"],
      Hook: fromCampaignHook(inner["Hook"]),
      IsPaused: inner["IsPaused"],
      Limits: fromCampaignLimits(inner["Limits"]),
      MessageConfiguration: fromMessageConfiguration(inner["MessageConfiguration"]),
      Name: inner["Name"],
      Schedule: fromSchedule(inner["Schedule"]),
      SegmentId: inner["SegmentId"],
      SegmentVersion: inner["SegmentVersion"],
      tags: inner["tags"],
      TemplateConfiguration: fromTemplateConfiguration(inner["TemplateConfiguration"]),
      TreatmentDescription: inner["TreatmentDescription"],
      TreatmentName: inner["TreatmentName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCampaign",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns`,
      responseCode: 201,
    });
  return {
    CampaignResponse: toCampaignResponse(await resp.json()),
  };
  }

  async createEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateEmailTemplateRequest,
  ): Promise<s.CreateEmailTemplateResponse> {
    const inner = params["EmailTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      HtmlPart: inner["HtmlPart"],
      RecommenderId: inner["RecommenderId"],
      Subject: inner["Subject"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
      TextPart: inner["TextPart"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateEmailTemplate",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/email`,
      responseCode: 201,
    });
  return {
    CreateTemplateMessageBody: toCreateTemplateMessageBody(await resp.json()),
  };
  }

  async createExportJob(
    {abortSignal, ...params}: RequestConfig & s.CreateExportJobRequest,
  ): Promise<s.CreateExportJobResponse> {
    const inner = params["ExportJobRequest"];
    const body: jsonP.JSONObject = inner ? {
      RoleArn: inner["RoleArn"],
      S3UrlPrefix: inner["S3UrlPrefix"],
      SegmentId: inner["SegmentId"],
      SegmentVersion: inner["SegmentVersion"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateExportJob",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/export`,
      responseCode: 202,
    });
  return {
    ExportJobResponse: toExportJobResponse(await resp.json()),
  };
  }

  async createImportJob(
    {abortSignal, ...params}: RequestConfig & s.CreateImportJobRequest,
  ): Promise<s.CreateImportJobResponse> {
    const inner = params["ImportJobRequest"];
    const body: jsonP.JSONObject = inner ? {
      DefineSegment: inner["DefineSegment"],
      ExternalId: inner["ExternalId"],
      Format: inner["Format"],
      RegisterEndpoints: inner["RegisterEndpoints"],
      RoleArn: inner["RoleArn"],
      S3Url: inner["S3Url"],
      SegmentId: inner["SegmentId"],
      SegmentName: inner["SegmentName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateImportJob",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/import`,
      responseCode: 201,
    });
  return {
    ImportJobResponse: toImportJobResponse(await resp.json()),
  };
  }

  async createJourney(
    {abortSignal, ...params}: RequestConfig & s.CreateJourneyRequest,
  ): Promise<s.CreateJourneyResponse> {
    const inner = params["WriteJourneyRequest"];
    const body: jsonP.JSONObject = inner ? {
      Activities: jsonP.serializeMap(inner["Activities"], x => fromActivity(x)),
      CreationDate: inner["CreationDate"],
      LastModifiedDate: inner["LastModifiedDate"],
      Limits: fromJourneyLimits(inner["Limits"]),
      LocalTime: inner["LocalTime"],
      Name: inner["Name"],
      QuietTime: fromQuietTime(inner["QuietTime"]),
      RefreshFrequency: inner["RefreshFrequency"],
      Schedule: fromJourneySchedule(inner["Schedule"]),
      StartActivity: inner["StartActivity"],
      StartCondition: fromStartCondition(inner["StartCondition"]),
      State: inner["State"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateJourney",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys`,
      responseCode: 201,
    });
  return {
    JourneyResponse: toJourneyResponse(await resp.json()),
  };
  }

  async createPushTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreatePushTemplateRequest,
  ): Promise<s.CreatePushTemplateResponse> {
    const inner = params["PushNotificationTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      ADM: fromAndroidPushNotificationTemplate(inner["ADM"]),
      APNS: fromAPNSPushNotificationTemplate(inner["APNS"]),
      Baidu: fromAndroidPushNotificationTemplate(inner["Baidu"]),
      Default: fromDefaultPushNotificationTemplate(inner["Default"]),
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      GCM: fromAndroidPushNotificationTemplate(inner["GCM"]),
      RecommenderId: inner["RecommenderId"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePushTemplate",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/push`,
      responseCode: 201,
    });
  return {
    CreateTemplateMessageBody: toCreateTemplateMessageBody(await resp.json()),
  };
  }

  async createRecommenderConfiguration(
    {abortSignal, ...params}: RequestConfig & s.CreateRecommenderConfigurationRequest,
  ): Promise<s.CreateRecommenderConfigurationResponse> {
    const inner = params["CreateRecommenderConfiguration"];
    const body: jsonP.JSONObject = inner ? {
      Attributes: inner["Attributes"],
      Description: inner["Description"],
      Name: inner["Name"],
      RecommendationProviderIdType: inner["RecommendationProviderIdType"],
      RecommendationProviderRoleArn: inner["RecommendationProviderRoleArn"],
      RecommendationProviderUri: inner["RecommendationProviderUri"],
      RecommendationTransformerUri: inner["RecommendationTransformerUri"],
      RecommendationsDisplayName: inner["RecommendationsDisplayName"],
      RecommendationsPerMessage: inner["RecommendationsPerMessage"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRecommenderConfiguration",
      requestUri: "/v1/recommenders",
      responseCode: 201,
    });
  return {
    RecommenderConfigurationResponse: toRecommenderConfigurationResponse(await resp.json()),
  };
  }

  async createSegment(
    {abortSignal, ...params}: RequestConfig & s.CreateSegmentRequest,
  ): Promise<s.CreateSegmentResponse> {
    const inner = params["WriteSegmentRequest"];
    const body: jsonP.JSONObject = inner ? {
      Dimensions: fromSegmentDimensions(inner["Dimensions"]),
      Name: inner["Name"],
      SegmentGroups: fromSegmentGroupList(inner["SegmentGroups"]),
      tags: inner["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSegment",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments`,
      responseCode: 201,
    });
  return {
    SegmentResponse: toSegmentResponse(await resp.json()),
  };
  }

  async createSmsTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateSmsTemplateRequest,
  ): Promise<s.CreateSmsTemplateResponse> {
    const inner = params["SMSTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      Body: inner["Body"],
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      RecommenderId: inner["RecommenderId"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateSmsTemplate",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/sms`,
      responseCode: 201,
    });
  return {
    CreateTemplateMessageBody: toCreateTemplateMessageBody(await resp.json()),
  };
  }

  async createVoiceTemplate(
    {abortSignal, ...params}: RequestConfig & s.CreateVoiceTemplateRequest,
  ): Promise<s.CreateVoiceTemplateResponse> {
    const inner = params["VoiceTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      Body: inner["Body"],
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      LanguageCode: inner["LanguageCode"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
      VoiceId: inner["VoiceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateVoiceTemplate",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/voice`,
      responseCode: 201,
    });
  return {
    CreateTemplateMessageBody: toCreateTemplateMessageBody(await resp.json()),
  };
  }

  async deleteAdmChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteAdmChannelRequest,
  ): Promise<s.DeleteAdmChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteAdmChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/adm`,
      responseCode: 200,
    });
  return {
    ADMChannelResponse: toADMChannelResponse(await resp.json()),
  };
  }

  async deleteApnsChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteApnsChannelRequest,
  ): Promise<s.DeleteApnsChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApnsChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns`,
      responseCode: 200,
    });
  return {
    APNSChannelResponse: toAPNSChannelResponse(await resp.json()),
  };
  }

  async deleteApnsSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteApnsSandboxChannelRequest,
  ): Promise<s.DeleteApnsSandboxChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApnsSandboxChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_sandbox`,
      responseCode: 200,
    });
  return {
    APNSSandboxChannelResponse: toAPNSSandboxChannelResponse(await resp.json()),
  };
  }

  async deleteApnsVoipChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteApnsVoipChannelRequest,
  ): Promise<s.DeleteApnsVoipChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApnsVoipChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip`,
      responseCode: 200,
    });
  return {
    APNSVoipChannelResponse: toAPNSVoipChannelResponse(await resp.json()),
  };
  }

  async deleteApnsVoipSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteApnsVoipSandboxChannelRequest,
  ): Promise<s.DeleteApnsVoipSandboxChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApnsVoipSandboxChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip_sandbox`,
      responseCode: 200,
    });
  return {
    APNSVoipSandboxChannelResponse: toAPNSVoipSandboxChannelResponse(await resp.json()),
  };
  }

  async deleteApp(
    {abortSignal, ...params}: RequestConfig & s.DeleteAppRequest,
  ): Promise<s.DeleteAppResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteApp",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}`,
      responseCode: 200,
    });
  return {
    ApplicationResponse: toApplicationResponse(await resp.json()),
  };
  }

  async deleteBaiduChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteBaiduChannelRequest,
  ): Promise<s.DeleteBaiduChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteBaiduChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/baidu`,
      responseCode: 200,
    });
  return {
    BaiduChannelResponse: toBaiduChannelResponse(await resp.json()),
  };
  }

  async deleteCampaign(
    {abortSignal, ...params}: RequestConfig & s.DeleteCampaignRequest,
  ): Promise<s.DeleteCampaignResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteCampaign",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}`,
      responseCode: 200,
    });
  return {
    CampaignResponse: toCampaignResponse(await resp.json()),
  };
  }

  async deleteEmailChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteEmailChannelRequest,
  ): Promise<s.DeleteEmailChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteEmailChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/email`,
      responseCode: 200,
    });
  return {
    EmailChannelResponse: toEmailChannelResponse(await resp.json()),
  };
  }

  async deleteEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteEmailTemplateRequest,
  ): Promise<s.DeleteEmailTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteEmailTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/email`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async deleteEndpoint(
    {abortSignal, ...params}: RequestConfig & s.DeleteEndpointRequest,
  ): Promise<s.DeleteEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteEndpoint",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/endpoints/${params["EndpointId"]}`,
      responseCode: 202,
    });
  return {
    EndpointResponse: toEndpointResponse(await resp.json()),
  };
  }

  async deleteEventStream(
    {abortSignal, ...params}: RequestConfig & s.DeleteEventStreamRequest,
  ): Promise<s.DeleteEventStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteEventStream",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/eventstream`,
      responseCode: 200,
    });
  return {
    EventStream: toEventStream(await resp.json()),
  };
  }

  async deleteGcmChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteGcmChannelRequest,
  ): Promise<s.DeleteGcmChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteGcmChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/gcm`,
      responseCode: 200,
    });
  return {
    GCMChannelResponse: toGCMChannelResponse(await resp.json()),
  };
  }

  async deleteJourney(
    {abortSignal, ...params}: RequestConfig & s.DeleteJourneyRequest,
  ): Promise<s.DeleteJourneyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteJourney",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}`,
      responseCode: 200,
    });
  return {
    JourneyResponse: toJourneyResponse(await resp.json()),
  };
  }

  async deletePushTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeletePushTemplateRequest,
  ): Promise<s.DeletePushTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeletePushTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/push`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async deleteRecommenderConfiguration(
    {abortSignal, ...params}: RequestConfig & s.DeleteRecommenderConfigurationRequest,
  ): Promise<s.DeleteRecommenderConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteRecommenderConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/recommenders/${params["RecommenderId"]}`,
      responseCode: 200,
    });
  return {
    RecommenderConfigurationResponse: toRecommenderConfigurationResponse(await resp.json()),
  };
  }

  async deleteSegment(
    {abortSignal, ...params}: RequestConfig & s.DeleteSegmentRequest,
  ): Promise<s.DeleteSegmentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSegment",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}`,
      responseCode: 200,
    });
  return {
    SegmentResponse: toSegmentResponse(await resp.json()),
  };
  }

  async deleteSmsChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteSmsChannelRequest,
  ): Promise<s.DeleteSmsChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteSmsChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/sms`,
      responseCode: 200,
    });
  return {
    SMSChannelResponse: toSMSChannelResponse(await resp.json()),
  };
  }

  async deleteSmsTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteSmsTemplateRequest,
  ): Promise<s.DeleteSmsTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteSmsTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/sms`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async deleteUserEndpoints(
    {abortSignal, ...params}: RequestConfig & s.DeleteUserEndpointsRequest,
  ): Promise<s.DeleteUserEndpointsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteUserEndpoints",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/users/${params["UserId"]}`,
      responseCode: 202,
    });
  return {
    EndpointsResponse: toEndpointsResponse(await resp.json()),
  };
  }

  async deleteVoiceChannel(
    {abortSignal, ...params}: RequestConfig & s.DeleteVoiceChannelRequest,
  ): Promise<s.DeleteVoiceChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteVoiceChannel",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/voice`,
      responseCode: 200,
    });
  return {
    VoiceChannelResponse: toVoiceChannelResponse(await resp.json()),
  };
  }

  async deleteVoiceTemplate(
    {abortSignal, ...params}: RequestConfig & s.DeleteVoiceTemplateRequest,
  ): Promise<s.DeleteVoiceTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "DeleteVoiceTemplate",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/voice`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async getAdmChannel(
    {abortSignal, ...params}: RequestConfig & s.GetAdmChannelRequest,
  ): Promise<s.GetAdmChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetAdmChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/adm`,
      responseCode: 200,
    });
  return {
    ADMChannelResponse: toADMChannelResponse(await resp.json()),
  };
  }

  async getApnsChannel(
    {abortSignal, ...params}: RequestConfig & s.GetApnsChannelRequest,
  ): Promise<s.GetApnsChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApnsChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns`,
      responseCode: 200,
    });
  return {
    APNSChannelResponse: toAPNSChannelResponse(await resp.json()),
  };
  }

  async getApnsSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.GetApnsSandboxChannelRequest,
  ): Promise<s.GetApnsSandboxChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApnsSandboxChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_sandbox`,
      responseCode: 200,
    });
  return {
    APNSSandboxChannelResponse: toAPNSSandboxChannelResponse(await resp.json()),
  };
  }

  async getApnsVoipChannel(
    {abortSignal, ...params}: RequestConfig & s.GetApnsVoipChannelRequest,
  ): Promise<s.GetApnsVoipChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApnsVoipChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip`,
      responseCode: 200,
    });
  return {
    APNSVoipChannelResponse: toAPNSVoipChannelResponse(await resp.json()),
  };
  }

  async getApnsVoipSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.GetApnsVoipSandboxChannelRequest,
  ): Promise<s.GetApnsVoipSandboxChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApnsVoipSandboxChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip_sandbox`,
      responseCode: 200,
    });
  return {
    APNSVoipSandboxChannelResponse: toAPNSVoipSandboxChannelResponse(await resp.json()),
  };
  }

  async getApp(
    {abortSignal, ...params}: RequestConfig & s.GetAppRequest,
  ): Promise<s.GetAppResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApp",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}`,
      responseCode: 200,
    });
  return {
    ApplicationResponse: toApplicationResponse(await resp.json()),
  };
  }

  async getApplicationDateRangeKpi(
    {abortSignal, ...params}: RequestConfig & s.GetApplicationDateRangeKpiRequest,
  ): Promise<s.GetApplicationDateRangeKpiResponse> {
    const query = new URLSearchParams;
    if (params["EndTime"] != null) query.set("end-time", cmnP.serializeDate_iso8601(params["EndTime"]) ?? "");
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["StartTime"] != null) query.set("start-time", cmnP.serializeDate_iso8601(params["StartTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApplicationDateRangeKpi",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/kpis/daterange/${params["KpiName"]}`,
      responseCode: 200,
    });
  return {
    ApplicationDateRangeKpiResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
          "EndTime": "d",
          "KpiName": "s",
          "KpiResult": toBaseKpiResult,
          "StartTime": "d",
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getApplicationSettings(
    {abortSignal, ...params}: RequestConfig & s.GetApplicationSettingsRequest,
  ): Promise<s.GetApplicationSettingsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetApplicationSettings",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/settings`,
      responseCode: 200,
    });
  return {
    ApplicationSettingsResource: toApplicationSettingsResource(await resp.json()),
  };
  }

  async getApps(
    {abortSignal, ...params}: RequestConfig & s.GetAppsRequest = {},
  ): Promise<s.GetAppsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetApps",
      method: "GET",
      requestUri: "/v1/apps",
      responseCode: 200,
    });
  return {
    ApplicationsResponse: jsonP.readObj({
        required: {},
        optional: {
          "Item": [toApplicationResponse],
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getBaiduChannel(
    {abortSignal, ...params}: RequestConfig & s.GetBaiduChannelRequest,
  ): Promise<s.GetBaiduChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetBaiduChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/baidu`,
      responseCode: 200,
    });
  return {
    BaiduChannelResponse: toBaiduChannelResponse(await resp.json()),
  };
  }

  async getCampaign(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignRequest,
  ): Promise<s.GetCampaignResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCampaign",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}`,
      responseCode: 200,
    });
  return {
    CampaignResponse: toCampaignResponse(await resp.json()),
  };
  }

  async getCampaignActivities(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignActivitiesRequest,
  ): Promise<s.GetCampaignActivitiesResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCampaignActivities",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}/activities`,
      responseCode: 200,
    });
  return {
    ActivitiesResponse: jsonP.readObj({
        required: {
          "Item": [toActivityResponse],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getCampaignDateRangeKpi(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignDateRangeKpiRequest,
  ): Promise<s.GetCampaignDateRangeKpiResponse> {
    const query = new URLSearchParams;
    if (params["EndTime"] != null) query.set("end-time", cmnP.serializeDate_iso8601(params["EndTime"]) ?? "");
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["StartTime"] != null) query.set("start-time", cmnP.serializeDate_iso8601(params["StartTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCampaignDateRangeKpi",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}/kpis/daterange/${params["KpiName"]}`,
      responseCode: 200,
    });
  return {
    CampaignDateRangeKpiResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
          "CampaignId": "s",
          "EndTime": "d",
          "KpiName": "s",
          "KpiResult": toBaseKpiResult,
          "StartTime": "d",
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getCampaignVersion(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignVersionRequest,
  ): Promise<s.GetCampaignVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCampaignVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}/versions/${params["Version"]}`,
      responseCode: 200,
    });
  return {
    CampaignResponse: toCampaignResponse(await resp.json()),
  };
  }

  async getCampaignVersions(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignVersionsRequest,
  ): Promise<s.GetCampaignVersionsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCampaignVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}/versions`,
      responseCode: 200,
    });
  return {
    CampaignsResponse: toCampaignsResponse(await resp.json()),
  };
  }

  async getCampaigns(
    {abortSignal, ...params}: RequestConfig & s.GetCampaignsRequest,
  ): Promise<s.GetCampaignsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetCampaigns",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns`,
      responseCode: 200,
    });
  return {
    CampaignsResponse: toCampaignsResponse(await resp.json()),
  };
  }

  async getChannels(
    {abortSignal, ...params}: RequestConfig & s.GetChannelsRequest,
  ): Promise<s.GetChannelsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetChannels",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels`,
      responseCode: 200,
    });
  return {
    ChannelsResponse: jsonP.readObj({
        required: {
          "Channels": x => jsonP.readMap(String, toChannelResponse, x),
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getEmailChannel(
    {abortSignal, ...params}: RequestConfig & s.GetEmailChannelRequest,
  ): Promise<s.GetEmailChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEmailChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/email`,
      responseCode: 200,
    });
  return {
    EmailChannelResponse: toEmailChannelResponse(await resp.json()),
  };
  }

  async getEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetEmailTemplateRequest,
  ): Promise<s.GetEmailTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetEmailTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/email`,
      responseCode: 200,
    });
  return {
    EmailTemplateResponse: jsonP.readObj({
        required: {
          "CreationDate": "s",
          "LastModifiedDate": "s",
          "TemplateName": "s",
          "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
        },
        optional: {
          "Arn": "s",
          "DefaultSubstitutions": "s",
          "HtmlPart": "s",
          "RecommenderId": "s",
          "Subject": "s",
          "tags": x => jsonP.readMap(String, String, x),
          "TemplateDescription": "s",
          "TextPart": "s",
          "Version": "s",
        },
      }, await resp.json()),
  };
  }

  async getEndpoint(
    {abortSignal, ...params}: RequestConfig & s.GetEndpointRequest,
  ): Promise<s.GetEndpointResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEndpoint",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/endpoints/${params["EndpointId"]}`,
      responseCode: 200,
    });
  return {
    EndpointResponse: toEndpointResponse(await resp.json()),
  };
  }

  async getEventStream(
    {abortSignal, ...params}: RequestConfig & s.GetEventStreamRequest,
  ): Promise<s.GetEventStreamResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetEventStream",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/eventstream`,
      responseCode: 200,
    });
  return {
    EventStream: toEventStream(await resp.json()),
  };
  }

  async getExportJob(
    {abortSignal, ...params}: RequestConfig & s.GetExportJobRequest,
  ): Promise<s.GetExportJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetExportJob",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/export/${params["JobId"]}`,
      responseCode: 200,
    });
  return {
    ExportJobResponse: toExportJobResponse(await resp.json()),
  };
  }

  async getExportJobs(
    {abortSignal, ...params}: RequestConfig & s.GetExportJobsRequest,
  ): Promise<s.GetExportJobsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetExportJobs",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/export`,
      responseCode: 200,
    });
  return {
    ExportJobsResponse: toExportJobsResponse(await resp.json()),
  };
  }

  async getGcmChannel(
    {abortSignal, ...params}: RequestConfig & s.GetGcmChannelRequest,
  ): Promise<s.GetGcmChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetGcmChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/gcm`,
      responseCode: 200,
    });
  return {
    GCMChannelResponse: toGCMChannelResponse(await resp.json()),
  };
  }

  async getImportJob(
    {abortSignal, ...params}: RequestConfig & s.GetImportJobRequest,
  ): Promise<s.GetImportJobResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetImportJob",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/import/${params["JobId"]}`,
      responseCode: 200,
    });
  return {
    ImportJobResponse: toImportJobResponse(await resp.json()),
  };
  }

  async getImportJobs(
    {abortSignal, ...params}: RequestConfig & s.GetImportJobsRequest,
  ): Promise<s.GetImportJobsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetImportJobs",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/jobs/import`,
      responseCode: 200,
    });
  return {
    ImportJobsResponse: toImportJobsResponse(await resp.json()),
  };
  }

  async getJourney(
    {abortSignal, ...params}: RequestConfig & s.GetJourneyRequest,
  ): Promise<s.GetJourneyResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetJourney",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}`,
      responseCode: 200,
    });
  return {
    JourneyResponse: toJourneyResponse(await resp.json()),
  };
  }

  async getJourneyDateRangeKpi(
    {abortSignal, ...params}: RequestConfig & s.GetJourneyDateRangeKpiRequest,
  ): Promise<s.GetJourneyDateRangeKpiResponse> {
    const query = new URLSearchParams;
    if (params["EndTime"] != null) query.set("end-time", cmnP.serializeDate_iso8601(params["EndTime"]) ?? "");
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["StartTime"] != null) query.set("start-time", cmnP.serializeDate_iso8601(params["StartTime"]) ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetJourneyDateRangeKpi",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}/kpis/daterange/${params["KpiName"]}`,
      responseCode: 200,
    });
  return {
    JourneyDateRangeKpiResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
          "EndTime": "d",
          "JourneyId": "s",
          "KpiName": "s",
          "KpiResult": toBaseKpiResult,
          "StartTime": "d",
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getJourneyExecutionActivityMetrics(
    {abortSignal, ...params}: RequestConfig & s.GetJourneyExecutionActivityMetricsRequest,
  ): Promise<s.GetJourneyExecutionActivityMetricsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetJourneyExecutionActivityMetrics",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}/activities/${params["JourneyActivityId"]}/execution-metrics`,
      responseCode: 200,
    });
  return {
    JourneyExecutionActivityMetricsResponse: jsonP.readObj({
        required: {
          "ActivityType": "s",
          "ApplicationId": "s",
          "JourneyActivityId": "s",
          "JourneyId": "s",
          "LastEvaluatedTime": "s",
          "Metrics": x => jsonP.readMap(String, String, x),
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getJourneyExecutionMetrics(
    {abortSignal, ...params}: RequestConfig & s.GetJourneyExecutionMetricsRequest,
  ): Promise<s.GetJourneyExecutionMetricsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetJourneyExecutionMetrics",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}/execution-metrics`,
      responseCode: 200,
    });
  return {
    JourneyExecutionMetricsResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
          "JourneyId": "s",
          "LastEvaluatedTime": "s",
          "Metrics": x => jsonP.readMap(String, String, x),
        },
        optional: {},
      }, await resp.json()),
  };
  }

  async getPushTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetPushTemplateRequest,
  ): Promise<s.GetPushTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetPushTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/push`,
      responseCode: 200,
    });
  return {
    PushNotificationTemplateResponse: jsonP.readObj({
        required: {
          "CreationDate": "s",
          "LastModifiedDate": "s",
          "TemplateName": "s",
          "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
        },
        optional: {
          "ADM": toAndroidPushNotificationTemplate,
          "APNS": toAPNSPushNotificationTemplate,
          "Arn": "s",
          "Baidu": toAndroidPushNotificationTemplate,
          "Default": toDefaultPushNotificationTemplate,
          "DefaultSubstitutions": "s",
          "GCM": toAndroidPushNotificationTemplate,
          "RecommenderId": "s",
          "tags": x => jsonP.readMap(String, String, x),
          "TemplateDescription": "s",
          "Version": "s",
        },
      }, await resp.json()),
  };
  }

  async getRecommenderConfiguration(
    {abortSignal, ...params}: RequestConfig & s.GetRecommenderConfigurationRequest,
  ): Promise<s.GetRecommenderConfigurationResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetRecommenderConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/recommenders/${params["RecommenderId"]}`,
      responseCode: 200,
    });
  return {
    RecommenderConfigurationResponse: toRecommenderConfigurationResponse(await resp.json()),
  };
  }

  async getRecommenderConfigurations(
    {abortSignal, ...params}: RequestConfig & s.GetRecommenderConfigurationsRequest = {},
  ): Promise<s.GetRecommenderConfigurationsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetRecommenderConfigurations",
      method: "GET",
      requestUri: "/v1/recommenders",
      responseCode: 200,
    });
  return {
    ListRecommenderConfigurationsResponse: jsonP.readObj({
        required: {
          "Item": [toRecommenderConfigurationResponse],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async getSegment(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentRequest,
  ): Promise<s.GetSegmentResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSegment",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}`,
      responseCode: 200,
    });
  return {
    SegmentResponse: toSegmentResponse(await resp.json()),
  };
  }

  async getSegmentExportJobs(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentExportJobsRequest,
  ): Promise<s.GetSegmentExportJobsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSegmentExportJobs",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}/jobs/export`,
      responseCode: 200,
    });
  return {
    ExportJobsResponse: toExportJobsResponse(await resp.json()),
  };
  }

  async getSegmentImportJobs(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentImportJobsRequest,
  ): Promise<s.GetSegmentImportJobsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSegmentImportJobs",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}/jobs/import`,
      responseCode: 200,
    });
  return {
    ImportJobsResponse: toImportJobsResponse(await resp.json()),
  };
  }

  async getSegmentVersion(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentVersionRequest,
  ): Promise<s.GetSegmentVersionResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSegmentVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}/versions/${params["Version"]}`,
      responseCode: 200,
    });
  return {
    SegmentResponse: toSegmentResponse(await resp.json()),
  };
  }

  async getSegmentVersions(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentVersionsRequest,
  ): Promise<s.GetSegmentVersionsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSegmentVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}/versions`,
      responseCode: 200,
    });
  return {
    SegmentsResponse: toSegmentsResponse(await resp.json()),
  };
  }

  async getSegments(
    {abortSignal, ...params}: RequestConfig & s.GetSegmentsRequest,
  ): Promise<s.GetSegmentsResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSegments",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments`,
      responseCode: 200,
    });
  return {
    SegmentsResponse: toSegmentsResponse(await resp.json()),
  };
  }

  async getSmsChannel(
    {abortSignal, ...params}: RequestConfig & s.GetSmsChannelRequest,
  ): Promise<s.GetSmsChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetSmsChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/sms`,
      responseCode: 200,
    });
  return {
    SMSChannelResponse: toSMSChannelResponse(await resp.json()),
  };
  }

  async getSmsTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetSmsTemplateRequest,
  ): Promise<s.GetSmsTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetSmsTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/sms`,
      responseCode: 200,
    });
  return {
    SMSTemplateResponse: jsonP.readObj({
        required: {
          "CreationDate": "s",
          "LastModifiedDate": "s",
          "TemplateName": "s",
          "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
        },
        optional: {
          "Arn": "s",
          "Body": "s",
          "DefaultSubstitutions": "s",
          "RecommenderId": "s",
          "tags": x => jsonP.readMap(String, String, x),
          "TemplateDescription": "s",
          "Version": "s",
        },
      }, await resp.json()),
  };
  }

  async getUserEndpoints(
    {abortSignal, ...params}: RequestConfig & s.GetUserEndpointsRequest,
  ): Promise<s.GetUserEndpointsResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetUserEndpoints",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/users/${params["UserId"]}`,
      responseCode: 200,
    });
  return {
    EndpointsResponse: toEndpointsResponse(await resp.json()),
  };
  }

  async getVoiceChannel(
    {abortSignal, ...params}: RequestConfig & s.GetVoiceChannelRequest,
  ): Promise<s.GetVoiceChannelResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetVoiceChannel",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/voice`,
      responseCode: 200,
    });
  return {
    VoiceChannelResponse: toVoiceChannelResponse(await resp.json()),
  };
  }

  async getVoiceTemplate(
    {abortSignal, ...params}: RequestConfig & s.GetVoiceTemplateRequest,
  ): Promise<s.GetVoiceTemplateResponse> {
    const query = new URLSearchParams;
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "GetVoiceTemplate",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/voice`,
      responseCode: 200,
    });
  return {
    VoiceTemplateResponse: jsonP.readObj({
        required: {
          "CreationDate": "s",
          "LastModifiedDate": "s",
          "TemplateName": "s",
          "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
        },
        optional: {
          "Arn": "s",
          "Body": "s",
          "DefaultSubstitutions": "s",
          "LanguageCode": "s",
          "tags": x => jsonP.readMap(String, String, x),
          "TemplateDescription": "s",
          "Version": "s",
          "VoiceId": "s",
        },
      }, await resp.json()),
  };
  }

  async listJourneys(
    {abortSignal, ...params}: RequestConfig & s.ListJourneysRequest,
  ): Promise<s.ListJourneysResponse> {
    const query = new URLSearchParams;
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Token"] != null) query.set("token", params["Token"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListJourneys",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys`,
      responseCode: 200,
    });
  return {
    JourneysResponse: jsonP.readObj({
        required: {
          "Item": [toJourneyResponse],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 200,
    });
  return {
    TagsModel: toTagsModel(await resp.json()),
  };
  }

  async listTemplateVersions(
    {abortSignal, ...params}: RequestConfig & s.ListTemplateVersionsRequest,
  ): Promise<s.ListTemplateVersionsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTemplateVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/${params["TemplateType"]}/versions`,
      responseCode: 200,
    });
  return {
    TemplateVersionsResponse: jsonP.readObj({
        required: {
          "Item": [toTemplateVersionResponse],
        },
        optional: {
          "Message": "s",
          "NextToken": "s",
          "RequestID": "s",
        },
      }, await resp.json()),
  };
  }

  async listTemplates(
    {abortSignal, ...params}: RequestConfig & s.ListTemplatesRequest = {},
  ): Promise<s.ListTemplatesResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("next-token", params["NextToken"]?.toString() ?? "");
    if (params["PageSize"] != null) query.set("page-size", params["PageSize"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["TemplateType"] != null) query.set("template-type", params["TemplateType"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTemplates",
      method: "GET",
      requestUri: "/v1/templates",
      responseCode: 200,
    });
  return {
    TemplatesResponse: jsonP.readObj({
        required: {
          "Item": [toTemplateResponse],
        },
        optional: {
          "NextToken": "s",
        },
      }, await resp.json()),
  };
  }

  async phoneNumberValidate(
    {abortSignal, ...params}: RequestConfig & s.PhoneNumberValidateRequest,
  ): Promise<s.PhoneNumberValidateResponse> {
    const inner = params["NumberValidateRequest"];
    const body: jsonP.JSONObject = inner ? {
      IsoCountryCode: inner["IsoCountryCode"],
      PhoneNumber: inner["PhoneNumber"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PhoneNumberValidate",
      requestUri: "/v1/phone/number/validate",
      responseCode: 200,
    });
  return {
    NumberValidateResponse: jsonP.readObj({
        required: {},
        optional: {
          "Carrier": "s",
          "City": "s",
          "CleansedPhoneNumberE164": "s",
          "CleansedPhoneNumberNational": "s",
          "Country": "s",
          "CountryCodeIso2": "s",
          "CountryCodeNumeric": "s",
          "County": "s",
          "OriginalCountryCodeIso2": "s",
          "OriginalPhoneNumber": "s",
          "PhoneType": "s",
          "PhoneTypeCode": "n",
          "Timezone": "s",
          "ZipCode": "s",
        },
      }, await resp.json()),
  };
  }

  async putEventStream(
    {abortSignal, ...params}: RequestConfig & s.PutEventStreamRequest,
  ): Promise<s.PutEventStreamResponse> {
    const inner = params["WriteEventStream"];
    const body: jsonP.JSONObject = inner ? {
      DestinationStreamArn: inner["DestinationStreamArn"],
      RoleArn: inner["RoleArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEventStream",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/eventstream`,
      responseCode: 200,
    });
  return {
    EventStream: toEventStream(await resp.json()),
  };
  }

  async putEvents(
    {abortSignal, ...params}: RequestConfig & s.PutEventsRequest,
  ): Promise<s.PutEventsResponse> {
    const inner = params["EventsRequest"];
    const body: jsonP.JSONObject = inner ? {
      BatchItem: jsonP.serializeMap(inner["BatchItem"], x => fromEventsBatch(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutEvents",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/events`,
      responseCode: 202,
    });
  return {
    EventsResponse: jsonP.readObj({
        required: {},
        optional: {
          "Results": x => jsonP.readMap(String, toItemResponse, x),
        },
      }, await resp.json()),
  };
  }

  async removeAttributes(
    {abortSignal, ...params}: RequestConfig & s.RemoveAttributesRequest,
  ): Promise<s.RemoveAttributesResponse> {
    const inner = params["UpdateAttributesRequest"];
    const body: jsonP.JSONObject = inner ? {
      Blacklist: inner["Blacklist"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveAttributes",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/attributes/${params["AttributeType"]}`,
      responseCode: 200,
    });
  return {
    AttributesResource: jsonP.readObj({
        required: {
          "ApplicationId": "s",
          "AttributeType": "s",
        },
        optional: {
          "Attributes": ["s"],
        },
      }, await resp.json()),
  };
  }

  async sendMessages(
    {abortSignal, ...params}: RequestConfig & s.SendMessagesRequest,
  ): Promise<s.SendMessagesResponse> {
    const inner = params["MessageRequest"];
    const body: jsonP.JSONObject = inner ? {
      Addresses: jsonP.serializeMap(inner["Addresses"], x => fromAddressConfiguration(x)),
      Context: inner["Context"],
      Endpoints: jsonP.serializeMap(inner["Endpoints"], x => fromEndpointSendConfiguration(x)),
      MessageConfiguration: fromDirectMessageConfiguration(inner["MessageConfiguration"]),
      TemplateConfiguration: fromTemplateConfiguration(inner["TemplateConfiguration"]),
      TraceId: inner["TraceId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendMessages",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/messages`,
      responseCode: 200,
    });
  return {
    MessageResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
        },
        optional: {
          "EndpointResult": x => jsonP.readMap(String, toEndpointMessageResult, x),
          "RequestId": "s",
          "Result": x => jsonP.readMap(String, toMessageResult, x),
        },
      }, await resp.json()),
  };
  }

  async sendUsersMessages(
    {abortSignal, ...params}: RequestConfig & s.SendUsersMessagesRequest,
  ): Promise<s.SendUsersMessagesResponse> {
    const inner = params["SendUsersMessageRequest"];
    const body: jsonP.JSONObject = inner ? {
      Context: inner["Context"],
      MessageConfiguration: fromDirectMessageConfiguration(inner["MessageConfiguration"]),
      TemplateConfiguration: fromTemplateConfiguration(inner["TemplateConfiguration"]),
      TraceId: inner["TraceId"],
      Users: jsonP.serializeMap(inner["Users"], x => fromEndpointSendConfiguration(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SendUsersMessages",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/users-messages`,
      responseCode: 200,
    });
  return {
    SendUsersMessageResponse: jsonP.readObj({
        required: {
          "ApplicationId": "s",
        },
        optional: {
          "RequestId": "s",
          "Result": x => jsonP.readMap(String, y => jsonP.readMap(String, toEndpointMessageResult, y)!, x),
        },
      }, await resp.json()),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const inner = params["TagsModel"];
    const body: jsonP.JSONObject = inner ? {
      tags: inner["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/v1/tags/${params["ResourceArn"]}`,
      responseCode: 204,
    });
  }

  async updateAdmChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateAdmChannelRequest,
  ): Promise<s.UpdateAdmChannelResponse> {
    const inner = params["ADMChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      ClientId: inner["ClientId"],
      ClientSecret: inner["ClientSecret"],
      Enabled: inner["Enabled"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateAdmChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/adm`,
      responseCode: 200,
    });
  return {
    ADMChannelResponse: toADMChannelResponse(await resp.json()),
  };
  }

  async updateApnsChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateApnsChannelRequest,
  ): Promise<s.UpdateApnsChannelResponse> {
    const inner = params["APNSChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      BundleId: inner["BundleId"],
      Certificate: inner["Certificate"],
      DefaultAuthenticationMethod: inner["DefaultAuthenticationMethod"],
      Enabled: inner["Enabled"],
      PrivateKey: inner["PrivateKey"],
      TeamId: inner["TeamId"],
      TokenKey: inner["TokenKey"],
      TokenKeyId: inner["TokenKeyId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApnsChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns`,
      responseCode: 200,
    });
  return {
    APNSChannelResponse: toAPNSChannelResponse(await resp.json()),
  };
  }

  async updateApnsSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateApnsSandboxChannelRequest,
  ): Promise<s.UpdateApnsSandboxChannelResponse> {
    const inner = params["APNSSandboxChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      BundleId: inner["BundleId"],
      Certificate: inner["Certificate"],
      DefaultAuthenticationMethod: inner["DefaultAuthenticationMethod"],
      Enabled: inner["Enabled"],
      PrivateKey: inner["PrivateKey"],
      TeamId: inner["TeamId"],
      TokenKey: inner["TokenKey"],
      TokenKeyId: inner["TokenKeyId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApnsSandboxChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_sandbox`,
      responseCode: 200,
    });
  return {
    APNSSandboxChannelResponse: toAPNSSandboxChannelResponse(await resp.json()),
  };
  }

  async updateApnsVoipChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateApnsVoipChannelRequest,
  ): Promise<s.UpdateApnsVoipChannelResponse> {
    const inner = params["APNSVoipChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      BundleId: inner["BundleId"],
      Certificate: inner["Certificate"],
      DefaultAuthenticationMethod: inner["DefaultAuthenticationMethod"],
      Enabled: inner["Enabled"],
      PrivateKey: inner["PrivateKey"],
      TeamId: inner["TeamId"],
      TokenKey: inner["TokenKey"],
      TokenKeyId: inner["TokenKeyId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApnsVoipChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip`,
      responseCode: 200,
    });
  return {
    APNSVoipChannelResponse: toAPNSVoipChannelResponse(await resp.json()),
  };
  }

  async updateApnsVoipSandboxChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateApnsVoipSandboxChannelRequest,
  ): Promise<s.UpdateApnsVoipSandboxChannelResponse> {
    const inner = params["APNSVoipSandboxChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      BundleId: inner["BundleId"],
      Certificate: inner["Certificate"],
      DefaultAuthenticationMethod: inner["DefaultAuthenticationMethod"],
      Enabled: inner["Enabled"],
      PrivateKey: inner["PrivateKey"],
      TeamId: inner["TeamId"],
      TokenKey: inner["TokenKey"],
      TokenKeyId: inner["TokenKeyId"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApnsVoipSandboxChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/apns_voip_sandbox`,
      responseCode: 200,
    });
  return {
    APNSVoipSandboxChannelResponse: toAPNSVoipSandboxChannelResponse(await resp.json()),
  };
  }

  async updateApplicationSettings(
    {abortSignal, ...params}: RequestConfig & s.UpdateApplicationSettingsRequest,
  ): Promise<s.UpdateApplicationSettingsResponse> {
    const inner = params["WriteApplicationSettingsRequest"];
    const body: jsonP.JSONObject = inner ? {
      CampaignHook: fromCampaignHook(inner["CampaignHook"]),
      CloudWatchMetricsEnabled: inner["CloudWatchMetricsEnabled"],
      EventTaggingEnabled: inner["EventTaggingEnabled"],
      Limits: fromCampaignLimits(inner["Limits"]),
      QuietTime: fromQuietTime(inner["QuietTime"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateApplicationSettings",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/settings`,
      responseCode: 200,
    });
  return {
    ApplicationSettingsResource: toApplicationSettingsResource(await resp.json()),
  };
  }

  async updateBaiduChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateBaiduChannelRequest,
  ): Promise<s.UpdateBaiduChannelResponse> {
    const inner = params["BaiduChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      ApiKey: inner["ApiKey"],
      Enabled: inner["Enabled"],
      SecretKey: inner["SecretKey"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateBaiduChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/baidu`,
      responseCode: 200,
    });
  return {
    BaiduChannelResponse: toBaiduChannelResponse(await resp.json()),
  };
  }

  async updateCampaign(
    {abortSignal, ...params}: RequestConfig & s.UpdateCampaignRequest,
  ): Promise<s.UpdateCampaignResponse> {
    const inner = params["WriteCampaignRequest"];
    const body: jsonP.JSONObject = inner ? {
      AdditionalTreatments: inner["AdditionalTreatments"]?.map(x => fromWriteTreatmentResource(x)),
      CustomDeliveryConfiguration: fromCustomDeliveryConfiguration(inner["CustomDeliveryConfiguration"]),
      Description: inner["Description"],
      HoldoutPercent: inner["HoldoutPercent"],
      Hook: fromCampaignHook(inner["Hook"]),
      IsPaused: inner["IsPaused"],
      Limits: fromCampaignLimits(inner["Limits"]),
      MessageConfiguration: fromMessageConfiguration(inner["MessageConfiguration"]),
      Name: inner["Name"],
      Schedule: fromSchedule(inner["Schedule"]),
      SegmentId: inner["SegmentId"],
      SegmentVersion: inner["SegmentVersion"],
      tags: inner["tags"],
      TemplateConfiguration: fromTemplateConfiguration(inner["TemplateConfiguration"]),
      TreatmentDescription: inner["TreatmentDescription"],
      TreatmentName: inner["TreatmentName"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateCampaign",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/campaigns/${params["CampaignId"]}`,
      responseCode: 200,
    });
  return {
    CampaignResponse: toCampaignResponse(await resp.json()),
  };
  }

  async updateEmailChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateEmailChannelRequest,
  ): Promise<s.UpdateEmailChannelResponse> {
    const inner = params["EmailChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      ConfigurationSet: inner["ConfigurationSet"],
      Enabled: inner["Enabled"],
      FromAddress: inner["FromAddress"],
      Identity: inner["Identity"],
      RoleArn: inner["RoleArn"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEmailChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/email`,
      responseCode: 200,
    });
  return {
    EmailChannelResponse: toEmailChannelResponse(await resp.json()),
  };
  }

  async updateEmailTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateEmailTemplateRequest,
  ): Promise<s.UpdateEmailTemplateResponse> {
    const inner = params["EmailTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      HtmlPart: inner["HtmlPart"],
      RecommenderId: inner["RecommenderId"],
      Subject: inner["Subject"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
      TextPart: inner["TextPart"],
    } : {};
    const query = new URLSearchParams;
    if (params["CreateNewVersion"] != null) query.set("create-new-version", params["CreateNewVersion"]?.toString() ?? "");
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateEmailTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/email`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateEndpoint(
    {abortSignal, ...params}: RequestConfig & s.UpdateEndpointRequest,
  ): Promise<s.UpdateEndpointResponse> {
    const inner = params["EndpointRequest"];
    const body: jsonP.JSONObject = inner ? {
      Address: inner["Address"],
      Attributes: inner["Attributes"],
      ChannelType: inner["ChannelType"],
      Demographic: fromEndpointDemographic(inner["Demographic"]),
      EffectiveDate: inner["EffectiveDate"],
      EndpointStatus: inner["EndpointStatus"],
      Location: fromEndpointLocation(inner["Location"]),
      Metrics: inner["Metrics"],
      OptOut: inner["OptOut"],
      RequestId: inner["RequestId"],
      User: fromEndpointUser(inner["User"]),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpoint",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/endpoints/${params["EndpointId"]}`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateEndpointsBatch(
    {abortSignal, ...params}: RequestConfig & s.UpdateEndpointsBatchRequest,
  ): Promise<s.UpdateEndpointsBatchResponse> {
    const inner = params["EndpointBatchRequest"];
    const body: jsonP.JSONObject = inner ? {
      Item: inner["Item"]?.map(x => fromEndpointBatchItem(x)),
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateEndpointsBatch",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/endpoints`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateGcmChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateGcmChannelRequest,
  ): Promise<s.UpdateGcmChannelResponse> {
    const inner = params["GCMChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      ApiKey: inner["ApiKey"],
      Enabled: inner["Enabled"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateGcmChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/gcm`,
      responseCode: 200,
    });
  return {
    GCMChannelResponse: toGCMChannelResponse(await resp.json()),
  };
  }

  async updateJourney(
    {abortSignal, ...params}: RequestConfig & s.UpdateJourneyRequest,
  ): Promise<s.UpdateJourneyResponse> {
    const inner = params["WriteJourneyRequest"];
    const body: jsonP.JSONObject = inner ? {
      Activities: jsonP.serializeMap(inner["Activities"], x => fromActivity(x)),
      CreationDate: inner["CreationDate"],
      LastModifiedDate: inner["LastModifiedDate"],
      Limits: fromJourneyLimits(inner["Limits"]),
      LocalTime: inner["LocalTime"],
      Name: inner["Name"],
      QuietTime: fromQuietTime(inner["QuietTime"]),
      RefreshFrequency: inner["RefreshFrequency"],
      Schedule: fromJourneySchedule(inner["Schedule"]),
      StartActivity: inner["StartActivity"],
      StartCondition: fromStartCondition(inner["StartCondition"]),
      State: inner["State"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJourney",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}`,
      responseCode: 200,
    });
  return {
    JourneyResponse: toJourneyResponse(await resp.json()),
  };
  }

  async updateJourneyState(
    {abortSignal, ...params}: RequestConfig & s.UpdateJourneyStateRequest,
  ): Promise<s.UpdateJourneyStateResponse> {
    const inner = params["JourneyStateRequest"];
    const body: jsonP.JSONObject = inner ? {
      State: inner["State"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateJourneyState",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/journeys/${params["JourneyId"]}/state`,
      responseCode: 200,
    });
  return {
    JourneyResponse: toJourneyResponse(await resp.json()),
  };
  }

  async updatePushTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdatePushTemplateRequest,
  ): Promise<s.UpdatePushTemplateResponse> {
    const inner = params["PushNotificationTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      ADM: fromAndroidPushNotificationTemplate(inner["ADM"]),
      APNS: fromAPNSPushNotificationTemplate(inner["APNS"]),
      Baidu: fromAndroidPushNotificationTemplate(inner["Baidu"]),
      Default: fromDefaultPushNotificationTemplate(inner["Default"]),
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      GCM: fromAndroidPushNotificationTemplate(inner["GCM"]),
      RecommenderId: inner["RecommenderId"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
    } : {};
    const query = new URLSearchParams;
    if (params["CreateNewVersion"] != null) query.set("create-new-version", params["CreateNewVersion"]?.toString() ?? "");
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdatePushTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/push`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateRecommenderConfiguration(
    {abortSignal, ...params}: RequestConfig & s.UpdateRecommenderConfigurationRequest,
  ): Promise<s.UpdateRecommenderConfigurationResponse> {
    const inner = params["UpdateRecommenderConfiguration"];
    const body: jsonP.JSONObject = inner ? {
      Attributes: inner["Attributes"],
      Description: inner["Description"],
      Name: inner["Name"],
      RecommendationProviderIdType: inner["RecommendationProviderIdType"],
      RecommendationProviderRoleArn: inner["RecommendationProviderRoleArn"],
      RecommendationProviderUri: inner["RecommendationProviderUri"],
      RecommendationTransformerUri: inner["RecommendationTransformerUri"],
      RecommendationsDisplayName: inner["RecommendationsDisplayName"],
      RecommendationsPerMessage: inner["RecommendationsPerMessage"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRecommenderConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/recommenders/${params["RecommenderId"]}`,
      responseCode: 200,
    });
  return {
    RecommenderConfigurationResponse: toRecommenderConfigurationResponse(await resp.json()),
  };
  }

  async updateSegment(
    {abortSignal, ...params}: RequestConfig & s.UpdateSegmentRequest,
  ): Promise<s.UpdateSegmentResponse> {
    const inner = params["WriteSegmentRequest"];
    const body: jsonP.JSONObject = inner ? {
      Dimensions: fromSegmentDimensions(inner["Dimensions"]),
      Name: inner["Name"],
      SegmentGroups: fromSegmentGroupList(inner["SegmentGroups"]),
      tags: inner["tags"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSegment",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/segments/${params["SegmentId"]}`,
      responseCode: 200,
    });
  return {
    SegmentResponse: toSegmentResponse(await resp.json()),
  };
  }

  async updateSmsChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateSmsChannelRequest,
  ): Promise<s.UpdateSmsChannelResponse> {
    const inner = params["SMSChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      Enabled: inner["Enabled"],
      SenderId: inner["SenderId"],
      ShortCode: inner["ShortCode"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateSmsChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/sms`,
      responseCode: 200,
    });
  return {
    SMSChannelResponse: toSMSChannelResponse(await resp.json()),
  };
  }

  async updateSmsTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateSmsTemplateRequest,
  ): Promise<s.UpdateSmsTemplateResponse> {
    const inner = params["SMSTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      Body: inner["Body"],
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      RecommenderId: inner["RecommenderId"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
    } : {};
    const query = new URLSearchParams;
    if (params["CreateNewVersion"] != null) query.set("create-new-version", params["CreateNewVersion"]?.toString() ?? "");
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateSmsTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/sms`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateTemplateActiveVersion(
    {abortSignal, ...params}: RequestConfig & s.UpdateTemplateActiveVersionRequest,
  ): Promise<s.UpdateTemplateActiveVersionResponse> {
    const inner = params["TemplateActiveVersionRequest"];
    const body: jsonP.JSONObject = inner ? {
      Version: inner["Version"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTemplateActiveVersion",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/${params["TemplateType"]}/active-version`,
      responseCode: 200,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

  async updateVoiceChannel(
    {abortSignal, ...params}: RequestConfig & s.UpdateVoiceChannelRequest,
  ): Promise<s.UpdateVoiceChannelResponse> {
    const inner = params["VoiceChannelRequest"];
    const body: jsonP.JSONObject = inner ? {
      Enabled: inner["Enabled"],
    } : {};
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateVoiceChannel",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/apps/${params["ApplicationId"]}/channels/voice`,
      responseCode: 200,
    });
  return {
    VoiceChannelResponse: toVoiceChannelResponse(await resp.json()),
  };
  }

  async updateVoiceTemplate(
    {abortSignal, ...params}: RequestConfig & s.UpdateVoiceTemplateRequest,
  ): Promise<s.UpdateVoiceTemplateResponse> {
    const inner = params["VoiceTemplateRequest"];
    const body: jsonP.JSONObject = inner ? {
      Body: inner["Body"],
      DefaultSubstitutions: inner["DefaultSubstitutions"],
      LanguageCode: inner["LanguageCode"],
      tags: inner["tags"],
      TemplateDescription: inner["TemplateDescription"],
      VoiceId: inner["VoiceId"],
    } : {};
    const query = new URLSearchParams;
    if (params["CreateNewVersion"] != null) query.set("create-new-version", params["CreateNewVersion"]?.toString() ?? "");
    if (params["Version"] != null) query.set("version", params["Version"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UpdateVoiceTemplate",
      method: "PUT",
      requestUri: cmnP.encodePath`/v1/templates/${params["TemplateName"]}/voice`,
      responseCode: 202,
    });
  return {
    MessageBody: toMessageBody(await resp.json()),
  };
  }

}

function fromCreateApplicationRequest(input?: s.CreateApplicationRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    tags: input["tags"],
  }
}

function fromWriteCampaignRequest(input?: s.WriteCampaignRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdditionalTreatments: input["AdditionalTreatments"]?.map(x => fromWriteTreatmentResource(x)),
    CustomDeliveryConfiguration: fromCustomDeliveryConfiguration(input["CustomDeliveryConfiguration"]),
    Description: input["Description"],
    HoldoutPercent: input["HoldoutPercent"],
    Hook: fromCampaignHook(input["Hook"]),
    IsPaused: input["IsPaused"],
    Limits: fromCampaignLimits(input["Limits"]),
    MessageConfiguration: fromMessageConfiguration(input["MessageConfiguration"]),
    Name: input["Name"],
    Schedule: fromSchedule(input["Schedule"]),
    SegmentId: input["SegmentId"],
    SegmentVersion: input["SegmentVersion"],
    tags: input["tags"],
    TemplateConfiguration: fromTemplateConfiguration(input["TemplateConfiguration"]),
    TreatmentDescription: input["TreatmentDescription"],
    TreatmentName: input["TreatmentName"],
  }
}

function fromWriteTreatmentResource(input?: s.WriteTreatmentResource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CustomDeliveryConfiguration: fromCustomDeliveryConfiguration(input["CustomDeliveryConfiguration"]),
    MessageConfiguration: fromMessageConfiguration(input["MessageConfiguration"]),
    Schedule: fromSchedule(input["Schedule"]),
    SizePercent: input["SizePercent"],
    TemplateConfiguration: fromTemplateConfiguration(input["TemplateConfiguration"]),
    TreatmentDescription: input["TreatmentDescription"],
    TreatmentName: input["TreatmentName"],
  }
}

function fromCustomDeliveryConfiguration(input?: s.CustomDeliveryConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeliveryUri: input["DeliveryUri"],
    EndpointTypes: input["EndpointTypes"],
  }
}
function toCustomDeliveryConfiguration(root: jsonP.JSONValue): s.CustomDeliveryConfiguration {
  return jsonP.readObj({
    required: {
      "DeliveryUri": "s",
    },
    optional: {
      "EndpointTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__EndpointTypesElement>(x)],
    },
  }, root);
}

function fromMessageConfiguration(input?: s.MessageConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ADMMessage: fromMessage(input["ADMMessage"]),
    APNSMessage: fromMessage(input["APNSMessage"]),
    BaiduMessage: fromMessage(input["BaiduMessage"]),
    CustomMessage: fromCampaignCustomMessage(input["CustomMessage"]),
    DefaultMessage: fromMessage(input["DefaultMessage"]),
    EmailMessage: fromCampaignEmailMessage(input["EmailMessage"]),
    GCMMessage: fromMessage(input["GCMMessage"]),
    SMSMessage: fromCampaignSmsMessage(input["SMSMessage"]),
  }
}
function toMessageConfiguration(root: jsonP.JSONValue): s.MessageConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "ADMMessage": toMessage,
      "APNSMessage": toMessage,
      "BaiduMessage": toMessage,
      "CustomMessage": toCampaignCustomMessage,
      "DefaultMessage": toMessage,
      "EmailMessage": toCampaignEmailMessage,
      "GCMMessage": toMessage,
      "SMSMessage": toCampaignSmsMessage,
    },
  }, root);
}

function fromMessage(input?: s.Message | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    ImageIconUrl: input["ImageIconUrl"],
    ImageSmallIconUrl: input["ImageSmallIconUrl"],
    ImageUrl: input["ImageUrl"],
    JsonBody: input["JsonBody"],
    MediaUrl: input["MediaUrl"],
    RawContent: input["RawContent"],
    SilentPush: input["SilentPush"],
    TimeToLive: input["TimeToLive"],
    Title: input["Title"],
    Url: input["Url"],
  }
}
function toMessage(root: jsonP.JSONValue): s.Message {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<s.Action>(x),
      "Body": "s",
      "ImageIconUrl": "s",
      "ImageSmallIconUrl": "s",
      "ImageUrl": "s",
      "JsonBody": "s",
      "MediaUrl": "s",
      "RawContent": "s",
      "SilentPush": "b",
      "TimeToLive": "n",
      "Title": "s",
      "Url": "s",
    },
  }, root);
}

function fromCampaignCustomMessage(input?: s.CampaignCustomMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Data: input["Data"],
  }
}
function toCampaignCustomMessage(root: jsonP.JSONValue): s.CampaignCustomMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Data": "s",
    },
  }, root);
}

function fromCampaignEmailMessage(input?: s.CampaignEmailMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    FromAddress: input["FromAddress"],
    HtmlBody: input["HtmlBody"],
    Title: input["Title"],
  }
}
function toCampaignEmailMessage(root: jsonP.JSONValue): s.CampaignEmailMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Body": "s",
      "FromAddress": "s",
      "HtmlBody": "s",
      "Title": "s",
    },
  }, root);
}

function fromCampaignSmsMessage(input?: s.CampaignSmsMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    MessageType: input["MessageType"],
    OriginationNumber: input["OriginationNumber"],
    SenderId: input["SenderId"],
    EntityId: input["EntityId"],
    TemplateId: input["TemplateId"],
  }
}
function toCampaignSmsMessage(root: jsonP.JSONValue): s.CampaignSmsMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Body": "s",
      "MessageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageType>(x),
      "OriginationNumber": "s",
      "SenderId": "s",
      "EntityId": "s",
      "TemplateId": "s",
    },
  }, root);
}

function fromSchedule(input?: s.Schedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndTime: input["EndTime"],
    EventFilter: fromCampaignEventFilter(input["EventFilter"]),
    Frequency: input["Frequency"],
    IsLocalTime: input["IsLocalTime"],
    QuietTime: fromQuietTime(input["QuietTime"]),
    StartTime: input["StartTime"],
    Timezone: input["Timezone"],
  }
}
function toSchedule(root: jsonP.JSONValue): s.Schedule {
  return jsonP.readObj({
    required: {
      "StartTime": "s",
    },
    optional: {
      "EndTime": "s",
      "EventFilter": toCampaignEventFilter,
      "Frequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.Frequency>(x),
      "IsLocalTime": "b",
      "QuietTime": toQuietTime,
      "Timezone": "s",
    },
  }, root);
}

function fromCampaignEventFilter(input?: s.CampaignEventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: fromEventDimensions(input["Dimensions"]),
    FilterType: input["FilterType"],
  }
}
function toCampaignEventFilter(root: jsonP.JSONValue): s.CampaignEventFilter {
  return jsonP.readObj({
    required: {
      "Dimensions": toEventDimensions,
      "FilterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FilterType>(x),
    },
    optional: {},
  }, root);
}

function fromEventDimensions(input?: s.EventDimensions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: jsonP.serializeMap(input["Attributes"], x => fromAttributeDimension(x)),
    EventType: fromSetDimension(input["EventType"]),
    Metrics: jsonP.serializeMap(input["Metrics"], x => fromMetricDimension(x)),
  }
}
function toEventDimensions(root: jsonP.JSONValue): s.EventDimensions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, toAttributeDimension, x),
      "EventType": toSetDimension,
      "Metrics": x => jsonP.readMap(String, toMetricDimension, x),
    },
  }, root);
}

function fromAttributeDimension(input?: s.AttributeDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AttributeType: input["AttributeType"],
    Values: input["Values"],
  }
}
function toAttributeDimension(root: jsonP.JSONValue): s.AttributeDimension {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {
      "AttributeType": (x: jsonP.JSONValue) => cmnP.readEnum<s.AttributeType>(x),
    },
  }, root);
}

function fromSetDimension(input?: s.SetDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DimensionType: input["DimensionType"],
    Values: input["Values"],
  }
}
function toSetDimension(root: jsonP.JSONValue): s.SetDimension {
  return jsonP.readObj({
    required: {
      "Values": ["s"],
    },
    optional: {
      "DimensionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.DimensionType>(x),
    },
  }, root);
}

function fromMetricDimension(input?: s.MetricDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ComparisonOperator: input["ComparisonOperator"],
    Value: input["Value"],
  }
}
function toMetricDimension(root: jsonP.JSONValue): s.MetricDimension {
  return jsonP.readObj({
    required: {
      "ComparisonOperator": "s",
      "Value": "n",
    },
    optional: {},
  }, root);
}

function fromQuietTime(input?: s.QuietTime | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    End: input["End"],
    Start: input["Start"],
  }
}
function toQuietTime(root: jsonP.JSONValue): s.QuietTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "End": "s",
      "Start": "s",
    },
  }, root);
}

function fromTemplateConfiguration(input?: s.TemplateConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EmailTemplate: fromTemplate(input["EmailTemplate"]),
    PushTemplate: fromTemplate(input["PushTemplate"]),
    SMSTemplate: fromTemplate(input["SMSTemplate"]),
    VoiceTemplate: fromTemplate(input["VoiceTemplate"]),
  }
}
function toTemplateConfiguration(root: jsonP.JSONValue): s.TemplateConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "EmailTemplate": toTemplate,
      "PushTemplate": toTemplate,
      "SMSTemplate": toTemplate,
      "VoiceTemplate": toTemplate,
    },
  }, root);
}

function fromTemplate(input?: s.Template | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Version: input["Version"],
  }
}
function toTemplate(root: jsonP.JSONValue): s.Template {
  return jsonP.readObj({
    required: {},
    optional: {
      "Name": "s",
      "Version": "s",
    },
  }, root);
}

function fromCampaignHook(input?: s.CampaignHook | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    LambdaFunctionName: input["LambdaFunctionName"],
    Mode: input["Mode"],
    WebUrl: input["WebUrl"],
  }
}
function toCampaignHook(root: jsonP.JSONValue): s.CampaignHook {
  return jsonP.readObj({
    required: {},
    optional: {
      "LambdaFunctionName": "s",
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.Mode>(x),
      "WebUrl": "s",
    },
  }, root);
}

function fromCampaignLimits(input?: s.CampaignLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Daily: input["Daily"],
    MaximumDuration: input["MaximumDuration"],
    MessagesPerSecond: input["MessagesPerSecond"],
    Total: input["Total"],
  }
}
function toCampaignLimits(root: jsonP.JSONValue): s.CampaignLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "Daily": "n",
      "MaximumDuration": "n",
      "MessagesPerSecond": "n",
      "Total": "n",
    },
  }, root);
}

function fromEmailTemplateRequest(input?: s.EmailTemplateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefaultSubstitutions: input["DefaultSubstitutions"],
    HtmlPart: input["HtmlPart"],
    RecommenderId: input["RecommenderId"],
    Subject: input["Subject"],
    tags: input["tags"],
    TemplateDescription: input["TemplateDescription"],
    TextPart: input["TextPart"],
  }
}

function fromExportJobRequest(input?: s.ExportJobRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    RoleArn: input["RoleArn"],
    S3UrlPrefix: input["S3UrlPrefix"],
    SegmentId: input["SegmentId"],
    SegmentVersion: input["SegmentVersion"],
  }
}

function fromImportJobRequest(input?: s.ImportJobRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DefineSegment: input["DefineSegment"],
    ExternalId: input["ExternalId"],
    Format: input["Format"],
    RegisterEndpoints: input["RegisterEndpoints"],
    RoleArn: input["RoleArn"],
    S3Url: input["S3Url"],
    SegmentId: input["SegmentId"],
    SegmentName: input["SegmentName"],
  }
}

function fromWriteJourneyRequest(input?: s.WriteJourneyRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Activities: jsonP.serializeMap(input["Activities"], x => fromActivity(x)),
    CreationDate: input["CreationDate"],
    LastModifiedDate: input["LastModifiedDate"],
    Limits: fromJourneyLimits(input["Limits"]),
    LocalTime: input["LocalTime"],
    Name: input["Name"],
    QuietTime: fromQuietTime(input["QuietTime"]),
    RefreshFrequency: input["RefreshFrequency"],
    Schedule: fromJourneySchedule(input["Schedule"]),
    StartActivity: input["StartActivity"],
    StartCondition: fromStartCondition(input["StartCondition"]),
    State: input["State"],
  }
}

function fromActivity(input?: s.Activity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CUSTOM: fromCustomMessageActivity(input["CUSTOM"]),
    ConditionalSplit: fromConditionalSplitActivity(input["ConditionalSplit"]),
    Description: input["Description"],
    EMAIL: fromEmailMessageActivity(input["EMAIL"]),
    Holdout: fromHoldoutActivity(input["Holdout"]),
    MultiCondition: fromMultiConditionalSplitActivity(input["MultiCondition"]),
    PUSH: fromPushMessageActivity(input["PUSH"]),
    RandomSplit: fromRandomSplitActivity(input["RandomSplit"]),
    SMS: fromSMSMessageActivity(input["SMS"]),
    Wait: fromWaitActivity(input["Wait"]),
  }
}
function toActivity(root: jsonP.JSONValue): s.Activity {
  return jsonP.readObj({
    required: {},
    optional: {
      "CUSTOM": toCustomMessageActivity,
      "ConditionalSplit": toConditionalSplitActivity,
      "Description": "s",
      "EMAIL": toEmailMessageActivity,
      "Holdout": toHoldoutActivity,
      "MultiCondition": toMultiConditionalSplitActivity,
      "PUSH": toPushMessageActivity,
      "RandomSplit": toRandomSplitActivity,
      "SMS": toSMSMessageActivity,
      "Wait": toWaitActivity,
    },
  }, root);
}

function fromCustomMessageActivity(input?: s.CustomMessageActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DeliveryUri: input["DeliveryUri"],
    EndpointTypes: input["EndpointTypes"],
    MessageConfig: fromJourneyCustomMessage(input["MessageConfig"]),
    NextActivity: input["NextActivity"],
    TemplateName: input["TemplateName"],
    TemplateVersion: input["TemplateVersion"],
  }
}
function toCustomMessageActivity(root: jsonP.JSONValue): s.CustomMessageActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "DeliveryUri": "s",
      "EndpointTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.__EndpointTypesElement>(x)],
      "MessageConfig": toJourneyCustomMessage,
      "NextActivity": "s",
      "TemplateName": "s",
      "TemplateVersion": "s",
    },
  }, root);
}

function fromJourneyCustomMessage(input?: s.JourneyCustomMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Data: input["Data"],
  }
}
function toJourneyCustomMessage(root: jsonP.JSONValue): s.JourneyCustomMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "Data": "s",
    },
  }, root);
}

function fromConditionalSplitActivity(input?: s.ConditionalSplitActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Condition: fromCondition(input["Condition"]),
    EvaluationWaitTime: fromWaitTime(input["EvaluationWaitTime"]),
    FalseActivity: input["FalseActivity"],
    TrueActivity: input["TrueActivity"],
  }
}
function toConditionalSplitActivity(root: jsonP.JSONValue): s.ConditionalSplitActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Condition": toCondition,
      "EvaluationWaitTime": toWaitTime,
      "FalseActivity": "s",
      "TrueActivity": "s",
    },
  }, root);
}

function fromCondition(input?: s.Condition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Conditions: input["Conditions"]?.map(x => fromSimpleCondition(x)),
    Operator: input["Operator"],
  }
}
function toCondition(root: jsonP.JSONValue): s.Condition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Conditions": [toSimpleCondition],
      "Operator": (x: jsonP.JSONValue) => cmnP.readEnum<s.Operator>(x),
    },
  }, root);
}

function fromSimpleCondition(input?: s.SimpleCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EventCondition: fromEventCondition(input["EventCondition"]),
    SegmentCondition: fromSegmentCondition(input["SegmentCondition"]),
    segmentDimensions: fromSegmentDimensions(input["SegmentDimensions"]),
  }
}
function toSimpleCondition(root: jsonP.JSONValue): s.SimpleCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventCondition": toEventCondition,
      "SegmentCondition": toSegmentCondition,
      "SegmentDimensions": toSegmentDimensions,
    },
  }, root);
}

function fromEventCondition(input?: s.EventCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: fromEventDimensions(input["Dimensions"]),
    MessageActivity: input["MessageActivity"],
  }
}
function toEventCondition(root: jsonP.JSONValue): s.EventCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Dimensions": toEventDimensions,
      "MessageActivity": "s",
    },
  }, root);
}

function fromSegmentCondition(input?: s.SegmentCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SegmentId: input["SegmentId"],
  }
}
function toSegmentCondition(root: jsonP.JSONValue): s.SegmentCondition {
  return jsonP.readObj({
    required: {
      "SegmentId": "s",
    },
    optional: {},
  }, root);
}

function fromSegmentDimensions(input?: s.SegmentDimensions | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: jsonP.serializeMap(input["Attributes"], x => fromAttributeDimension(x)),
    Behavior: fromSegmentBehaviors(input["Behavior"]),
    Demographic: fromSegmentDemographics(input["Demographic"]),
    Location: fromSegmentLocation(input["Location"]),
    Metrics: jsonP.serializeMap(input["Metrics"], x => fromMetricDimension(x)),
    UserAttributes: jsonP.serializeMap(input["UserAttributes"], x => fromAttributeDimension(x)),
  }
}
function toSegmentDimensions(root: jsonP.JSONValue): s.SegmentDimensions {
  return jsonP.readObj({
    required: {},
    optional: {
      "Attributes": x => jsonP.readMap(String, toAttributeDimension, x),
      "Behavior": toSegmentBehaviors,
      "Demographic": toSegmentDemographics,
      "Location": toSegmentLocation,
      "Metrics": x => jsonP.readMap(String, toMetricDimension, x),
      "UserAttributes": x => jsonP.readMap(String, toAttributeDimension, x),
    },
  }, root);
}

function fromSegmentBehaviors(input?: s.SegmentBehaviors | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Recency: fromRecencyDimension(input["Recency"]),
  }
}
function toSegmentBehaviors(root: jsonP.JSONValue): s.SegmentBehaviors {
  return jsonP.readObj({
    required: {},
    optional: {
      "Recency": toRecencyDimension,
    },
  }, root);
}

function fromRecencyDimension(input?: s.RecencyDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Duration: input["Duration"],
    RecencyType: input["RecencyType"],
  }
}
function toRecencyDimension(root: jsonP.JSONValue): s.RecencyDimension {
  return jsonP.readObj({
    required: {
      "Duration": (x: jsonP.JSONValue) => cmnP.readEnum<s.Duration>(x),
      "RecencyType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RecencyType>(x),
    },
    optional: {},
  }, root);
}

function fromSegmentDemographics(input?: s.SegmentDemographics | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AppVersion: fromSetDimension(input["AppVersion"]),
    Channel: fromSetDimension(input["Channel"]),
    DeviceType: fromSetDimension(input["DeviceType"]),
    Make: fromSetDimension(input["Make"]),
    Model: fromSetDimension(input["Model"]),
    Platform: fromSetDimension(input["Platform"]),
  }
}
function toSegmentDemographics(root: jsonP.JSONValue): s.SegmentDemographics {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppVersion": toSetDimension,
      "Channel": toSetDimension,
      "DeviceType": toSetDimension,
      "Make": toSetDimension,
      "Model": toSetDimension,
      "Platform": toSetDimension,
    },
  }, root);
}

function fromSegmentLocation(input?: s.SegmentLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Country: fromSetDimension(input["Country"]),
    GPSPoint: fromGPSPointDimension(input["GPSPoint"]),
  }
}
function toSegmentLocation(root: jsonP.JSONValue): s.SegmentLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "Country": toSetDimension,
      "GPSPoint": toGPSPointDimension,
    },
  }, root);
}

function fromGPSPointDimension(input?: s.GPSPointDimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Coordinates: fromGPSCoordinates(input["Coordinates"]),
    RangeInKilometers: input["RangeInKilometers"],
  }
}
function toGPSPointDimension(root: jsonP.JSONValue): s.GPSPointDimension {
  return jsonP.readObj({
    required: {
      "Coordinates": toGPSCoordinates,
    },
    optional: {
      "RangeInKilometers": "n",
    },
  }, root);
}

function fromGPSCoordinates(input?: s.GPSCoordinates | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Latitude: input["Latitude"],
    Longitude: input["Longitude"],
  }
}
function toGPSCoordinates(root: jsonP.JSONValue): s.GPSCoordinates {
  return jsonP.readObj({
    required: {
      "Latitude": "n",
      "Longitude": "n",
    },
    optional: {},
  }, root);
}

function fromWaitTime(input?: s.WaitTime | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    WaitFor: input["WaitFor"],
    WaitUntil: input["WaitUntil"],
  }
}
function toWaitTime(root: jsonP.JSONValue): s.WaitTime {
  return jsonP.readObj({
    required: {},
    optional: {
      "WaitFor": "s",
      "WaitUntil": "s",
    },
  }, root);
}

function fromEmailMessageActivity(input?: s.EmailMessageActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageConfig: fromJourneyEmailMessage(input["MessageConfig"]),
    NextActivity: input["NextActivity"],
    TemplateName: input["TemplateName"],
    TemplateVersion: input["TemplateVersion"],
  }
}
function toEmailMessageActivity(root: jsonP.JSONValue): s.EmailMessageActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageConfig": toJourneyEmailMessage,
      "NextActivity": "s",
      "TemplateName": "s",
      "TemplateVersion": "s",
    },
  }, root);
}

function fromJourneyEmailMessage(input?: s.JourneyEmailMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    FromAddress: input["FromAddress"],
  }
}
function toJourneyEmailMessage(root: jsonP.JSONValue): s.JourneyEmailMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "FromAddress": "s",
    },
  }, root);
}

function fromHoldoutActivity(input?: s.HoldoutActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NextActivity: input["NextActivity"],
    Percentage: input["Percentage"],
  }
}
function toHoldoutActivity(root: jsonP.JSONValue): s.HoldoutActivity {
  return jsonP.readObj({
    required: {
      "Percentage": "n",
    },
    optional: {
      "NextActivity": "s",
    },
  }, root);
}

function fromMultiConditionalSplitActivity(input?: s.MultiConditionalSplitActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Branches: input["Branches"]?.map(x => fromMultiConditionalBranch(x)),
    DefaultActivity: input["DefaultActivity"],
    EvaluationWaitTime: fromWaitTime(input["EvaluationWaitTime"]),
  }
}
function toMultiConditionalSplitActivity(root: jsonP.JSONValue): s.MultiConditionalSplitActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Branches": [toMultiConditionalBranch],
      "DefaultActivity": "s",
      "EvaluationWaitTime": toWaitTime,
    },
  }, root);
}

function fromMultiConditionalBranch(input?: s.MultiConditionalBranch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Condition: fromSimpleCondition(input["Condition"]),
    NextActivity: input["NextActivity"],
  }
}
function toMultiConditionalBranch(root: jsonP.JSONValue): s.MultiConditionalBranch {
  return jsonP.readObj({
    required: {},
    optional: {
      "Condition": toSimpleCondition,
      "NextActivity": "s",
    },
  }, root);
}

function fromPushMessageActivity(input?: s.PushMessageActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageConfig: fromJourneyPushMessage(input["MessageConfig"]),
    NextActivity: input["NextActivity"],
    TemplateName: input["TemplateName"],
    TemplateVersion: input["TemplateVersion"],
  }
}
function toPushMessageActivity(root: jsonP.JSONValue): s.PushMessageActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageConfig": toJourneyPushMessage,
      "NextActivity": "s",
      "TemplateName": "s",
      "TemplateVersion": "s",
    },
  }, root);
}

function fromJourneyPushMessage(input?: s.JourneyPushMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TimeToLive: input["TimeToLive"],
  }
}
function toJourneyPushMessage(root: jsonP.JSONValue): s.JourneyPushMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "TimeToLive": "s",
    },
  }, root);
}

function fromRandomSplitActivity(input?: s.RandomSplitActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Branches: input["Branches"]?.map(x => fromRandomSplitEntry(x)),
  }
}
function toRandomSplitActivity(root: jsonP.JSONValue): s.RandomSplitActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "Branches": [toRandomSplitEntry],
    },
  }, root);
}

function fromRandomSplitEntry(input?: s.RandomSplitEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NextActivity: input["NextActivity"],
    Percentage: input["Percentage"],
  }
}
function toRandomSplitEntry(root: jsonP.JSONValue): s.RandomSplitEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "NextActivity": "s",
      "Percentage": "n",
    },
  }, root);
}

function fromSMSMessageActivity(input?: s.SMSMessageActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageConfig: fromJourneySMSMessage(input["MessageConfig"]),
    NextActivity: input["NextActivity"],
    TemplateName: input["TemplateName"],
    TemplateVersion: input["TemplateVersion"],
  }
}
function toSMSMessageActivity(root: jsonP.JSONValue): s.SMSMessageActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageConfig": toJourneySMSMessage,
      "NextActivity": "s",
      "TemplateName": "s",
      "TemplateVersion": "s",
    },
  }, root);
}

function fromJourneySMSMessage(input?: s.JourneySMSMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MessageType: input["MessageType"],
    OriginationNumber: input["OriginationNumber"],
    SenderId: input["SenderId"],
    EntityId: input["EntityId"],
    TemplateId: input["TemplateId"],
  }
}
function toJourneySMSMessage(root: jsonP.JSONValue): s.JourneySMSMessage {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.MessageType>(x),
      "OriginationNumber": "s",
      "SenderId": "s",
      "EntityId": "s",
      "TemplateId": "s",
    },
  }, root);
}

function fromWaitActivity(input?: s.WaitActivity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    NextActivity: input["NextActivity"],
    WaitTime: fromWaitTime(input["WaitTime"]),
  }
}
function toWaitActivity(root: jsonP.JSONValue): s.WaitActivity {
  return jsonP.readObj({
    required: {},
    optional: {
      "NextActivity": "s",
      "WaitTime": toWaitTime,
    },
  }, root);
}

function fromJourneyLimits(input?: s.JourneyLimits | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DailyCap: input["DailyCap"],
    EndpointReentryCap: input["EndpointReentryCap"],
    MessagesPerSecond: input["MessagesPerSecond"],
  }
}
function toJourneyLimits(root: jsonP.JSONValue): s.JourneyLimits {
  return jsonP.readObj({
    required: {},
    optional: {
      "DailyCap": "n",
      "EndpointReentryCap": "n",
      "MessagesPerSecond": "n",
    },
  }, root);
}

function fromJourneySchedule(input?: s.JourneySchedule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EndTime: jsonP.serializeDate_iso8601(input["EndTime"]),
    StartTime: jsonP.serializeDate_iso8601(input["StartTime"]),
    Timezone: input["Timezone"],
  }
}
function toJourneySchedule(root: jsonP.JSONValue): s.JourneySchedule {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndTime": "d",
      "StartTime": "d",
      "Timezone": "s",
    },
  }, root);
}

function fromStartCondition(input?: s.StartCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Description: input["Description"],
    EventStartCondition: fromEventStartCondition(input["EventStartCondition"]),
    SegmentStartCondition: fromSegmentCondition(input["SegmentStartCondition"]),
  }
}
function toStartCondition(root: jsonP.JSONValue): s.StartCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "Description": "s",
      "EventStartCondition": toEventStartCondition,
      "SegmentStartCondition": toSegmentCondition,
    },
  }, root);
}

function fromEventStartCondition(input?: s.EventStartCondition | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EventFilter: fromEventFilter(input["EventFilter"]),
    SegmentId: input["SegmentId"],
  }
}
function toEventStartCondition(root: jsonP.JSONValue): s.EventStartCondition {
  return jsonP.readObj({
    required: {},
    optional: {
      "EventFilter": toEventFilter,
      "SegmentId": "s",
    },
  }, root);
}

function fromEventFilter(input?: s.EventFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: fromEventDimensions(input["Dimensions"]),
    FilterType: input["FilterType"],
  }
}
function toEventFilter(root: jsonP.JSONValue): s.EventFilter {
  return jsonP.readObj({
    required: {
      "Dimensions": toEventDimensions,
      "FilterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.FilterType>(x),
    },
    optional: {},
  }, root);
}

function fromPushNotificationTemplateRequest(input?: s.PushNotificationTemplateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ADM: fromAndroidPushNotificationTemplate(input["ADM"]),
    APNS: fromAPNSPushNotificationTemplate(input["APNS"]),
    Baidu: fromAndroidPushNotificationTemplate(input["Baidu"]),
    Default: fromDefaultPushNotificationTemplate(input["Default"]),
    DefaultSubstitutions: input["DefaultSubstitutions"],
    GCM: fromAndroidPushNotificationTemplate(input["GCM"]),
    RecommenderId: input["RecommenderId"],
    tags: input["tags"],
    TemplateDescription: input["TemplateDescription"],
  }
}

function fromAndroidPushNotificationTemplate(input?: s.AndroidPushNotificationTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    ImageIconUrl: input["ImageIconUrl"],
    ImageUrl: input["ImageUrl"],
    RawContent: input["RawContent"],
    SmallImageIconUrl: input["SmallImageIconUrl"],
    Sound: input["Sound"],
    Title: input["Title"],
    Url: input["Url"],
  }
}
function toAndroidPushNotificationTemplate(root: jsonP.JSONValue): s.AndroidPushNotificationTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<s.Action>(x),
      "Body": "s",
      "ImageIconUrl": "s",
      "ImageUrl": "s",
      "RawContent": "s",
      "SmallImageIconUrl": "s",
      "Sound": "s",
      "Title": "s",
      "Url": "s",
    },
  }, root);
}

function fromAPNSPushNotificationTemplate(input?: s.APNSPushNotificationTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    MediaUrl: input["MediaUrl"],
    RawContent: input["RawContent"],
    Sound: input["Sound"],
    Title: input["Title"],
    Url: input["Url"],
  }
}
function toAPNSPushNotificationTemplate(root: jsonP.JSONValue): s.APNSPushNotificationTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<s.Action>(x),
      "Body": "s",
      "MediaUrl": "s",
      "RawContent": "s",
      "Sound": "s",
      "Title": "s",
      "Url": "s",
    },
  }, root);
}

function fromDefaultPushNotificationTemplate(input?: s.DefaultPushNotificationTemplate | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    Sound: input["Sound"],
    Title: input["Title"],
    Url: input["Url"],
  }
}
function toDefaultPushNotificationTemplate(root: jsonP.JSONValue): s.DefaultPushNotificationTemplate {
  return jsonP.readObj({
    required: {},
    optional: {
      "Action": (x: jsonP.JSONValue) => cmnP.readEnum<s.Action>(x),
      "Body": "s",
      "Sound": "s",
      "Title": "s",
      "Url": "s",
    },
  }, root);
}

function fromCreateRecommenderConfiguration(input?: s.CreateRecommenderConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: input["Attributes"],
    Description: input["Description"],
    Name: input["Name"],
    RecommendationProviderIdType: input["RecommendationProviderIdType"],
    RecommendationProviderRoleArn: input["RecommendationProviderRoleArn"],
    RecommendationProviderUri: input["RecommendationProviderUri"],
    RecommendationTransformerUri: input["RecommendationTransformerUri"],
    RecommendationsDisplayName: input["RecommendationsDisplayName"],
    RecommendationsPerMessage: input["RecommendationsPerMessage"],
  }
}

function fromWriteSegmentRequest(input?: s.WriteSegmentRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: fromSegmentDimensions(input["Dimensions"]),
    Name: input["Name"],
    SegmentGroups: fromSegmentGroupList(input["SegmentGroups"]),
    tags: input["tags"],
  }
}

function fromSegmentGroupList(input?: s.SegmentGroupList | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Groups: input["Groups"]?.map(x => fromSegmentGroup(x)),
    Include: input["Include"],
  }
}
function toSegmentGroupList(root: jsonP.JSONValue): s.SegmentGroupList {
  return jsonP.readObj({
    required: {},
    optional: {
      "Groups": [toSegmentGroup],
      "Include": (x: jsonP.JSONValue) => cmnP.readEnum<s.Include>(x),
    },
  }, root);
}

function fromSegmentGroup(input?: s.SegmentGroup | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: input["Dimensions"]?.map(x => fromSegmentDimensions(x)),
    SourceSegments: input["SourceSegments"]?.map(x => fromSegmentReference(x)),
    SourceType: input["SourceType"],
    Type: input["Type"],
  }
}
function toSegmentGroup(root: jsonP.JSONValue): s.SegmentGroup {
  return jsonP.readObj({
    required: {},
    optional: {
      "Dimensions": [toSegmentDimensions],
      "SourceSegments": [toSegmentReference],
      "SourceType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceType>(x),
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.Type>(x),
    },
  }, root);
}

function fromSegmentReference(input?: s.SegmentReference | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    Version: input["Version"],
  }
}
function toSegmentReference(root: jsonP.JSONValue): s.SegmentReference {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {
      "Version": "n",
    },
  }, root);
}

function fromSMSTemplateRequest(input?: s.SMSTemplateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    DefaultSubstitutions: input["DefaultSubstitutions"],
    RecommenderId: input["RecommenderId"],
    tags: input["tags"],
    TemplateDescription: input["TemplateDescription"],
  }
}

function fromVoiceTemplateRequest(input?: s.VoiceTemplateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    DefaultSubstitutions: input["DefaultSubstitutions"],
    LanguageCode: input["LanguageCode"],
    tags: input["tags"],
    TemplateDescription: input["TemplateDescription"],
    VoiceId: input["VoiceId"],
  }
}

function fromNumberValidateRequest(input?: s.NumberValidateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    IsoCountryCode: input["IsoCountryCode"],
    PhoneNumber: input["PhoneNumber"],
  }
}

function fromWriteEventStream(input?: s.WriteEventStream | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    DestinationStreamArn: input["DestinationStreamArn"],
    RoleArn: input["RoleArn"],
  }
}

function fromEventsRequest(input?: s.EventsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BatchItem: jsonP.serializeMap(input["BatchItem"], x => fromEventsBatch(x)),
  }
}

function fromEventsBatch(input?: s.EventsBatch | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Endpoint: fromPublicEndpoint(input["Endpoint"]),
    Events: jsonP.serializeMap(input["Events"], x => fromEvent(x)),
  }
}

function fromPublicEndpoint(input?: s.PublicEndpoint | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Attributes: input["Attributes"],
    ChannelType: input["ChannelType"],
    Demographic: fromEndpointDemographic(input["Demographic"]),
    EffectiveDate: input["EffectiveDate"],
    EndpointStatus: input["EndpointStatus"],
    Location: fromEndpointLocation(input["Location"]),
    Metrics: input["Metrics"],
    OptOut: input["OptOut"],
    RequestId: input["RequestId"],
    User: fromEndpointUser(input["User"]),
  }
}

function fromEndpointDemographic(input?: s.EndpointDemographic | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AppVersion: input["AppVersion"],
    Locale: input["Locale"],
    Make: input["Make"],
    Model: input["Model"],
    ModelVersion: input["ModelVersion"],
    Platform: input["Platform"],
    PlatformVersion: input["PlatformVersion"],
    Timezone: input["Timezone"],
  }
}
function toEndpointDemographic(root: jsonP.JSONValue): s.EndpointDemographic {
  return jsonP.readObj({
    required: {},
    optional: {
      "AppVersion": "s",
      "Locale": "s",
      "Make": "s",
      "Model": "s",
      "ModelVersion": "s",
      "Platform": "s",
      "PlatformVersion": "s",
      "Timezone": "s",
    },
  }, root);
}

function fromEndpointLocation(input?: s.EndpointLocation | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    City: input["City"],
    Country: input["Country"],
    Latitude: input["Latitude"],
    Longitude: input["Longitude"],
    PostalCode: input["PostalCode"],
    Region: input["Region"],
  }
}
function toEndpointLocation(root: jsonP.JSONValue): s.EndpointLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "City": "s",
      "Country": "s",
      "Latitude": "n",
      "Longitude": "n",
      "PostalCode": "s",
      "Region": "s",
    },
  }, root);
}

function fromEndpointUser(input?: s.EndpointUser | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UserAttributes: input["UserAttributes"],
    UserId: input["UserId"],
  }
}
function toEndpointUser(root: jsonP.JSONValue): s.EndpointUser {
  return jsonP.readObj({
    required: {},
    optional: {
      "UserAttributes": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "UserId": "s",
    },
  }, root);
}

function fromEvent(input?: s.Event | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AppPackageName: input["AppPackageName"],
    AppTitle: input["AppTitle"],
    AppVersionCode: input["AppVersionCode"],
    Attributes: input["Attributes"],
    ClientSdkVersion: input["ClientSdkVersion"],
    EventType: input["EventType"],
    Metrics: input["Metrics"],
    SdkName: input["SdkName"],
    Session: fromSession(input["Session"]),
    Timestamp: input["Timestamp"],
  }
}

function fromSession(input?: s.Session | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Duration: input["Duration"],
    Id: input["Id"],
    StartTimestamp: input["StartTimestamp"],
    StopTimestamp: input["StopTimestamp"],
  }
}

function fromUpdateAttributesRequest(input?: s.UpdateAttributesRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Blacklist: input["Blacklist"],
  }
}

function fromMessageRequest(input?: s.MessageRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Addresses: jsonP.serializeMap(input["Addresses"], x => fromAddressConfiguration(x)),
    Context: input["Context"],
    Endpoints: jsonP.serializeMap(input["Endpoints"], x => fromEndpointSendConfiguration(x)),
    MessageConfiguration: fromDirectMessageConfiguration(input["MessageConfiguration"]),
    TemplateConfiguration: fromTemplateConfiguration(input["TemplateConfiguration"]),
    TraceId: input["TraceId"],
  }
}

function fromAddressConfiguration(input?: s.AddressConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BodyOverride: input["BodyOverride"],
    ChannelType: input["ChannelType"],
    Context: input["Context"],
    RawContent: input["RawContent"],
    Substitutions: input["Substitutions"],
    TitleOverride: input["TitleOverride"],
  }
}

function fromEndpointSendConfiguration(input?: s.EndpointSendConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BodyOverride: input["BodyOverride"],
    Context: input["Context"],
    RawContent: input["RawContent"],
    Substitutions: input["Substitutions"],
    TitleOverride: input["TitleOverride"],
  }
}

function fromDirectMessageConfiguration(input?: s.DirectMessageConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ADMMessage: fromADMMessage(input["ADMMessage"]),
    APNSMessage: fromAPNSMessage(input["APNSMessage"]),
    BaiduMessage: fromBaiduMessage(input["BaiduMessage"]),
    DefaultMessage: fromDefaultMessage(input["DefaultMessage"]),
    DefaultPushNotificationMessage: fromDefaultPushNotificationMessage(input["DefaultPushNotificationMessage"]),
    EmailMessage: fromEmailMessage(input["EmailMessage"]),
    GCMMessage: fromGCMMessage(input["GCMMessage"]),
    SMSMessage: fromSMSMessage(input["SMSMessage"]),
    VoiceMessage: fromVoiceMessage(input["VoiceMessage"]),
  }
}

function fromADMMessage(input?: s.ADMMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    ConsolidationKey: input["ConsolidationKey"],
    Data: input["Data"],
    ExpiresAfter: input["ExpiresAfter"],
    IconReference: input["IconReference"],
    ImageIconUrl: input["ImageIconUrl"],
    ImageUrl: input["ImageUrl"],
    MD5: input["MD5"],
    RawContent: input["RawContent"],
    SilentPush: input["SilentPush"],
    SmallImageIconUrl: input["SmallImageIconUrl"],
    Sound: input["Sound"],
    Substitutions: input["Substitutions"],
    Title: input["Title"],
    Url: input["Url"],
  }
}

function fromAPNSMessage(input?: s.APNSMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    APNSPushType: input["APNSPushType"],
    Action: input["Action"],
    Badge: input["Badge"],
    Body: input["Body"],
    Category: input["Category"],
    CollapseId: input["CollapseId"],
    Data: input["Data"],
    MediaUrl: input["MediaUrl"],
    PreferredAuthenticationMethod: input["PreferredAuthenticationMethod"],
    Priority: input["Priority"],
    RawContent: input["RawContent"],
    SilentPush: input["SilentPush"],
    Sound: input["Sound"],
    Substitutions: input["Substitutions"],
    ThreadId: input["ThreadId"],
    TimeToLive: input["TimeToLive"],
    Title: input["Title"],
    Url: input["Url"],
  }
}

function fromBaiduMessage(input?: s.BaiduMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    Data: input["Data"],
    IconReference: input["IconReference"],
    ImageIconUrl: input["ImageIconUrl"],
    ImageUrl: input["ImageUrl"],
    RawContent: input["RawContent"],
    SilentPush: input["SilentPush"],
    SmallImageIconUrl: input["SmallImageIconUrl"],
    Sound: input["Sound"],
    Substitutions: input["Substitutions"],
    TimeToLive: input["TimeToLive"],
    Title: input["Title"],
    Url: input["Url"],
  }
}

function fromDefaultMessage(input?: s.DefaultMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    Substitutions: input["Substitutions"],
  }
}

function fromDefaultPushNotificationMessage(input?: s.DefaultPushNotificationMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    Data: input["Data"],
    SilentPush: input["SilentPush"],
    Substitutions: input["Substitutions"],
    Title: input["Title"],
    Url: input["Url"],
  }
}

function fromEmailMessage(input?: s.EmailMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    FeedbackForwardingAddress: input["FeedbackForwardingAddress"],
    FromAddress: input["FromAddress"],
    RawEmail: fromRawEmail(input["RawEmail"]),
    ReplyToAddresses: input["ReplyToAddresses"],
    SimpleEmail: fromSimpleEmail(input["SimpleEmail"]),
    Substitutions: input["Substitutions"],
  }
}

function fromRawEmail(input?: s.RawEmail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Data: serializeBlob(input["Data"]),
  }
}

function fromSimpleEmail(input?: s.SimpleEmail | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    HtmlPart: fromSimpleEmailPart(input["HtmlPart"]),
    Subject: fromSimpleEmailPart(input["Subject"]),
    TextPart: fromSimpleEmailPart(input["TextPart"]),
  }
}

function fromSimpleEmailPart(input?: s.SimpleEmailPart | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Charset: input["Charset"],
    Data: input["Data"],
  }
}

function fromGCMMessage(input?: s.GCMMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Action: input["Action"],
    Body: input["Body"],
    CollapseKey: input["CollapseKey"],
    Data: input["Data"],
    IconReference: input["IconReference"],
    ImageIconUrl: input["ImageIconUrl"],
    ImageUrl: input["ImageUrl"],
    Priority: input["Priority"],
    RawContent: input["RawContent"],
    RestrictedPackageName: input["RestrictedPackageName"],
    SilentPush: input["SilentPush"],
    SmallImageIconUrl: input["SmallImageIconUrl"],
    Sound: input["Sound"],
    Substitutions: input["Substitutions"],
    TimeToLive: input["TimeToLive"],
    Title: input["Title"],
    Url: input["Url"],
  }
}

function fromSMSMessage(input?: s.SMSMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    Keyword: input["Keyword"],
    MediaUrl: input["MediaUrl"],
    MessageType: input["MessageType"],
    OriginationNumber: input["OriginationNumber"],
    SenderId: input["SenderId"],
    Substitutions: input["Substitutions"],
    EntityId: input["EntityId"],
    TemplateId: input["TemplateId"],
  }
}

function fromVoiceMessage(input?: s.VoiceMessage | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Body: input["Body"],
    LanguageCode: input["LanguageCode"],
    OriginationNumber: input["OriginationNumber"],
    Substitutions: input["Substitutions"],
    VoiceId: input["VoiceId"],
  }
}

function fromSendUsersMessageRequest(input?: s.SendUsersMessageRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Context: input["Context"],
    MessageConfiguration: fromDirectMessageConfiguration(input["MessageConfiguration"]),
    TemplateConfiguration: fromTemplateConfiguration(input["TemplateConfiguration"]),
    TraceId: input["TraceId"],
    Users: jsonP.serializeMap(input["Users"], x => fromEndpointSendConfiguration(x)),
  }
}

function fromTagsModel(input?: s.TagsModel | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tags: input["tags"],
  }
}
function toTagsModel(root: jsonP.JSONValue): s.TagsModel {
  return jsonP.readObj({
    required: {
      "tags": x => jsonP.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

function fromADMChannelRequest(input?: s.ADMChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ClientId: input["ClientId"],
    ClientSecret: input["ClientSecret"],
    Enabled: input["Enabled"],
  }
}

function fromAPNSChannelRequest(input?: s.APNSChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BundleId: input["BundleId"],
    Certificate: input["Certificate"],
    DefaultAuthenticationMethod: input["DefaultAuthenticationMethod"],
    Enabled: input["Enabled"],
    PrivateKey: input["PrivateKey"],
    TeamId: input["TeamId"],
    TokenKey: input["TokenKey"],
    TokenKeyId: input["TokenKeyId"],
  }
}

function fromAPNSSandboxChannelRequest(input?: s.APNSSandboxChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BundleId: input["BundleId"],
    Certificate: input["Certificate"],
    DefaultAuthenticationMethod: input["DefaultAuthenticationMethod"],
    Enabled: input["Enabled"],
    PrivateKey: input["PrivateKey"],
    TeamId: input["TeamId"],
    TokenKey: input["TokenKey"],
    TokenKeyId: input["TokenKeyId"],
  }
}

function fromAPNSVoipChannelRequest(input?: s.APNSVoipChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BundleId: input["BundleId"],
    Certificate: input["Certificate"],
    DefaultAuthenticationMethod: input["DefaultAuthenticationMethod"],
    Enabled: input["Enabled"],
    PrivateKey: input["PrivateKey"],
    TeamId: input["TeamId"],
    TokenKey: input["TokenKey"],
    TokenKeyId: input["TokenKeyId"],
  }
}

function fromAPNSVoipSandboxChannelRequest(input?: s.APNSVoipSandboxChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    BundleId: input["BundleId"],
    Certificate: input["Certificate"],
    DefaultAuthenticationMethod: input["DefaultAuthenticationMethod"],
    Enabled: input["Enabled"],
    PrivateKey: input["PrivateKey"],
    TeamId: input["TeamId"],
    TokenKey: input["TokenKey"],
    TokenKeyId: input["TokenKeyId"],
  }
}

function fromWriteApplicationSettingsRequest(input?: s.WriteApplicationSettingsRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    CampaignHook: fromCampaignHook(input["CampaignHook"]),
    CloudWatchMetricsEnabled: input["CloudWatchMetricsEnabled"],
    EventTaggingEnabled: input["EventTaggingEnabled"],
    Limits: fromCampaignLimits(input["Limits"]),
    QuietTime: fromQuietTime(input["QuietTime"]),
  }
}

function fromBaiduChannelRequest(input?: s.BaiduChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApiKey: input["ApiKey"],
    Enabled: input["Enabled"],
    SecretKey: input["SecretKey"],
  }
}

function fromEmailChannelRequest(input?: s.EmailChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ConfigurationSet: input["ConfigurationSet"],
    Enabled: input["Enabled"],
    FromAddress: input["FromAddress"],
    Identity: input["Identity"],
    RoleArn: input["RoleArn"],
  }
}

function fromEndpointRequest(input?: s.EndpointRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Attributes: input["Attributes"],
    ChannelType: input["ChannelType"],
    Demographic: fromEndpointDemographic(input["Demographic"]),
    EffectiveDate: input["EffectiveDate"],
    EndpointStatus: input["EndpointStatus"],
    Location: fromEndpointLocation(input["Location"]),
    Metrics: input["Metrics"],
    OptOut: input["OptOut"],
    RequestId: input["RequestId"],
    User: fromEndpointUser(input["User"]),
  }
}

function fromEndpointBatchRequest(input?: s.EndpointBatchRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Item: input["Item"]?.map(x => fromEndpointBatchItem(x)),
  }
}

function fromEndpointBatchItem(input?: s.EndpointBatchItem | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Address: input["Address"],
    Attributes: input["Attributes"],
    ChannelType: input["ChannelType"],
    Demographic: fromEndpointDemographic(input["Demographic"]),
    EffectiveDate: input["EffectiveDate"],
    EndpointStatus: input["EndpointStatus"],
    Id: input["Id"],
    Location: fromEndpointLocation(input["Location"]),
    Metrics: input["Metrics"],
    OptOut: input["OptOut"],
    RequestId: input["RequestId"],
    User: fromEndpointUser(input["User"]),
  }
}

function fromGCMChannelRequest(input?: s.GCMChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ApiKey: input["ApiKey"],
    Enabled: input["Enabled"],
  }
}

function fromJourneyStateRequest(input?: s.JourneyStateRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    State: input["State"],
  }
}

function fromUpdateRecommenderConfiguration(input?: s.UpdateRecommenderConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Attributes: input["Attributes"],
    Description: input["Description"],
    Name: input["Name"],
    RecommendationProviderIdType: input["RecommendationProviderIdType"],
    RecommendationProviderRoleArn: input["RecommendationProviderRoleArn"],
    RecommendationProviderUri: input["RecommendationProviderUri"],
    RecommendationTransformerUri: input["RecommendationTransformerUri"],
    RecommendationsDisplayName: input["RecommendationsDisplayName"],
    RecommendationsPerMessage: input["RecommendationsPerMessage"],
  }
}

function fromSMSChannelRequest(input?: s.SMSChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
    SenderId: input["SenderId"],
    ShortCode: input["ShortCode"],
  }
}

function fromTemplateActiveVersionRequest(input?: s.TemplateActiveVersionRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Version: input["Version"],
  }
}

function fromVoiceChannelRequest(input?: s.VoiceChannelRequest | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Enabled: input["Enabled"],
  }
}

function toApplicationResponse(root: jsonP.JSONValue): s.ApplicationResponse {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "Id": "s",
      "Name": "s",
    },
    optional: {
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toCampaignResponse(root: jsonP.JSONValue): s.CampaignResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "Arn": "s",
      "CreationDate": "s",
      "Id": "s",
      "LastModifiedDate": "s",
      "SegmentId": "s",
      "SegmentVersion": "n",
    },
    optional: {
      "AdditionalTreatments": [toTreatmentResource],
      "CustomDeliveryConfiguration": toCustomDeliveryConfiguration,
      "DefaultState": toCampaignState,
      "Description": "s",
      "HoldoutPercent": "n",
      "Hook": toCampaignHook,
      "IsPaused": "b",
      "Limits": toCampaignLimits,
      "MessageConfiguration": toMessageConfiguration,
      "Name": "s",
      "Schedule": toSchedule,
      "State": toCampaignState,
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateConfiguration": toTemplateConfiguration,
      "TreatmentDescription": "s",
      "TreatmentName": "s",
      "Version": "n",
    },
  }, root);
}

function toTreatmentResource(root: jsonP.JSONValue): s.TreatmentResource {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "SizePercent": "n",
    },
    optional: {
      "CustomDeliveryConfiguration": toCustomDeliveryConfiguration,
      "MessageConfiguration": toMessageConfiguration,
      "Schedule": toSchedule,
      "State": toCampaignState,
      "TemplateConfiguration": toTemplateConfiguration,
      "TreatmentDescription": "s",
      "TreatmentName": "s",
    },
  }, root);
}

function toCampaignState(root: jsonP.JSONValue): s.CampaignState {
  return jsonP.readObj({
    required: {},
    optional: {
      "CampaignStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.CampaignStatus>(x),
    },
  }, root);
}

function toCreateTemplateMessageBody(root: jsonP.JSONValue): s.CreateTemplateMessageBody {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "Message": "s",
      "RequestID": "s",
    },
  }, root);
}

function toExportJobResponse(root: jsonP.JSONValue): s.ExportJobResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Definition": toExportJobResource,
      "Id": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Type": "s",
    },
    optional: {
      "CompletedPieces": "n",
      "CompletionDate": "s",
      "FailedPieces": "n",
      "Failures": ["s"],
      "TotalFailures": "n",
      "TotalPieces": "n",
      "TotalProcessed": "n",
    },
  }, root);
}

function toExportJobResource(root: jsonP.JSONValue): s.ExportJobResource {
  return jsonP.readObj({
    required: {
      "RoleArn": "s",
      "S3UrlPrefix": "s",
    },
    optional: {
      "SegmentId": "s",
      "SegmentVersion": "n",
    },
  }, root);
}

function toImportJobResponse(root: jsonP.JSONValue): s.ImportJobResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Definition": toImportJobResource,
      "Id": "s",
      "JobStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.JobStatus>(x),
      "Type": "s",
    },
    optional: {
      "CompletedPieces": "n",
      "CompletionDate": "s",
      "FailedPieces": "n",
      "Failures": ["s"],
      "TotalFailures": "n",
      "TotalPieces": "n",
      "TotalProcessed": "n",
    },
  }, root);
}

function toImportJobResource(root: jsonP.JSONValue): s.ImportJobResource {
  return jsonP.readObj({
    required: {
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
      "RoleArn": "s",
      "S3Url": "s",
    },
    optional: {
      "DefineSegment": "b",
      "ExternalId": "s",
      "RegisterEndpoints": "b",
      "SegmentId": "s",
      "SegmentName": "s",
    },
  }, root);
}

function toJourneyResponse(root: jsonP.JSONValue): s.JourneyResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "Id": "s",
      "Name": "s",
    },
    optional: {
      "Activities": x => jsonP.readMap(String, toActivity, x),
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "Limits": toJourneyLimits,
      "LocalTime": "b",
      "QuietTime": toQuietTime,
      "RefreshFrequency": "s",
      "Schedule": toJourneySchedule,
      "StartActivity": "s",
      "StartCondition": toStartCondition,
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
      "tags": x => jsonP.readMap(String, String, x),
    },
  }, root);
}

function toRecommenderConfigurationResponse(root: jsonP.JSONValue): s.RecommenderConfigurationResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "Id": "s",
      "LastModifiedDate": "s",
      "RecommendationProviderRoleArn": "s",
      "RecommendationProviderUri": "s",
    },
    optional: {
      "Attributes": x => jsonP.readMap(String, String, x),
      "Description": "s",
      "Name": "s",
      "RecommendationProviderIdType": "s",
      "RecommendationTransformerUri": "s",
      "RecommendationsDisplayName": "s",
      "RecommendationsPerMessage": "n",
    },
  }, root);
}

function toSegmentResponse(root: jsonP.JSONValue): s.SegmentResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "Arn": "s",
      "CreationDate": "s",
      "Id": "s",
      "SegmentType": (x: jsonP.JSONValue) => cmnP.readEnum<s.SegmentType>(x),
    },
    optional: {
      "Dimensions": toSegmentDimensions,
      "ImportDefinition": toSegmentImportResource,
      "LastModifiedDate": "s",
      "Name": "s",
      "SegmentGroups": toSegmentGroupList,
      "tags": x => jsonP.readMap(String, String, x),
      "Version": "n",
    },
  }, root);
}

function toSegmentImportResource(root: jsonP.JSONValue): s.SegmentImportResource {
  return jsonP.readObj({
    required: {
      "ExternalId": "s",
      "Format": (x: jsonP.JSONValue) => cmnP.readEnum<s.Format>(x),
      "RoleArn": "s",
      "S3Url": "s",
      "Size": "n",
    },
    optional: {
      "ChannelCounts": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function toADMChannelResponse(root: jsonP.JSONValue): s.ADMChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toAPNSChannelResponse(root: jsonP.JSONValue): s.APNSChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "DefaultAuthenticationMethod": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "HasTokenKey": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toAPNSSandboxChannelResponse(root: jsonP.JSONValue): s.APNSSandboxChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "DefaultAuthenticationMethod": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "HasTokenKey": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toAPNSVoipChannelResponse(root: jsonP.JSONValue): s.APNSVoipChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "DefaultAuthenticationMethod": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "HasTokenKey": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toAPNSVoipSandboxChannelResponse(root: jsonP.JSONValue): s.APNSVoipSandboxChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "DefaultAuthenticationMethod": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "HasTokenKey": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toBaiduChannelResponse(root: jsonP.JSONValue): s.BaiduChannelResponse {
  return jsonP.readObj({
    required: {
      "Credential": "s",
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toEmailChannelResponse(root: jsonP.JSONValue): s.EmailChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "ConfigurationSet": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "FromAddress": "s",
      "HasCredential": "b",
      "Id": "s",
      "Identity": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "MessagesPerSecond": "n",
      "RoleArn": "s",
      "Version": "n",
    },
  }, root);
}

function toMessageBody(root: jsonP.JSONValue): s.MessageBody {
  return jsonP.readObj({
    required: {},
    optional: {
      "Message": "s",
      "RequestID": "s",
    },
  }, root);
}

function toEndpointResponse(root: jsonP.JSONValue): s.EndpointResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Address": "s",
      "ApplicationId": "s",
      "Attributes": x => jsonP.readMap(String, l => Array.isArray(l) ? l.map(String) : [], x),
      "ChannelType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ChannelType>(x),
      "CohortId": "s",
      "CreationDate": "s",
      "Demographic": toEndpointDemographic,
      "EffectiveDate": "s",
      "EndpointStatus": "s",
      "Id": "s",
      "Location": toEndpointLocation,
      "Metrics": x => jsonP.readMap(String, Number, x),
      "OptOut": "s",
      "RequestId": "s",
      "User": toEndpointUser,
    },
  }, root);
}

function toEventStream(root: jsonP.JSONValue): s.EventStream {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "DestinationStreamArn": "s",
      "RoleArn": "s",
    },
    optional: {
      "ExternalId": "s",
      "LastModifiedDate": "s",
      "LastUpdatedBy": "s",
    },
  }, root);
}

function toGCMChannelResponse(root: jsonP.JSONValue): s.GCMChannelResponse {
  return jsonP.readObj({
    required: {
      "Credential": "s",
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toSMSChannelResponse(root: jsonP.JSONValue): s.SMSChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "PromotionalMessagesPerSecond": "n",
      "SenderId": "s",
      "ShortCode": "s",
      "TransactionalMessagesPerSecond": "n",
      "Version": "n",
    },
  }, root);
}

function toEndpointsResponse(root: jsonP.JSONValue): s.EndpointsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toEndpointResponse],
    },
    optional: {},
  }, root);
}

function toVoiceChannelResponse(root: jsonP.JSONValue): s.VoiceChannelResponse {
  return jsonP.readObj({
    required: {
      "Platform": "s",
    },
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toApplicationDateRangeKpiResponse(root: jsonP.JSONValue): s.ApplicationDateRangeKpiResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "EndTime": "d",
      "KpiName": "s",
      "KpiResult": toBaseKpiResult,
      "StartTime": "d",
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toBaseKpiResult(root: jsonP.JSONValue): s.BaseKpiResult {
  return jsonP.readObj({
    required: {
      "Rows": [toResultRow],
    },
    optional: {},
  }, root);
}

function toResultRow(root: jsonP.JSONValue): s.ResultRow {
  return jsonP.readObj({
    required: {
      "GroupedBys": [toResultRowValue],
      "Values": [toResultRowValue],
    },
    optional: {},
  }, root);
}

function toResultRowValue(root: jsonP.JSONValue): s.ResultRowValue {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Type": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

function toApplicationSettingsResource(root: jsonP.JSONValue): s.ApplicationSettingsResource {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
    },
    optional: {
      "CampaignHook": toCampaignHook,
      "LastModifiedDate": "s",
      "Limits": toCampaignLimits,
      "QuietTime": toQuietTime,
    },
  }, root);
}

function toApplicationsResponse(root: jsonP.JSONValue): s.ApplicationsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Item": [toApplicationResponse],
      "NextToken": "s",
    },
  }, root);
}

function toActivitiesResponse(root: jsonP.JSONValue): s.ActivitiesResponse {
  return jsonP.readObj({
    required: {
      "Item": [toActivityResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toActivityResponse(root: jsonP.JSONValue): s.ActivityResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CampaignId": "s",
      "Id": "s",
    },
    optional: {
      "End": "s",
      "Result": "s",
      "ScheduledStart": "s",
      "Start": "s",
      "State": "s",
      "SuccessfulEndpointCount": "n",
      "TimezonesCompletedCount": "n",
      "TimezonesTotalCount": "n",
      "TotalEndpointCount": "n",
      "TreatmentId": "s",
    },
  }, root);
}

function toCampaignDateRangeKpiResponse(root: jsonP.JSONValue): s.CampaignDateRangeKpiResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "CampaignId": "s",
      "EndTime": "d",
      "KpiName": "s",
      "KpiResult": toBaseKpiResult,
      "StartTime": "d",
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toCampaignsResponse(root: jsonP.JSONValue): s.CampaignsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toCampaignResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toChannelsResponse(root: jsonP.JSONValue): s.ChannelsResponse {
  return jsonP.readObj({
    required: {
      "Channels": x => jsonP.readMap(String, toChannelResponse, x),
    },
    optional: {},
  }, root);
}

function toChannelResponse(root: jsonP.JSONValue): s.ChannelResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ApplicationId": "s",
      "CreationDate": "s",
      "Enabled": "b",
      "HasCredential": "b",
      "Id": "s",
      "IsArchived": "b",
      "LastModifiedBy": "s",
      "LastModifiedDate": "s",
      "Version": "n",
    },
  }, root);
}

function toEmailTemplateResponse(root: jsonP.JSONValue): s.EmailTemplateResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
    },
    optional: {
      "Arn": "s",
      "DefaultSubstitutions": "s",
      "HtmlPart": "s",
      "RecommenderId": "s",
      "Subject": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateDescription": "s",
      "TextPart": "s",
      "Version": "s",
    },
  }, root);
}

function toExportJobsResponse(root: jsonP.JSONValue): s.ExportJobsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toExportJobResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toImportJobsResponse(root: jsonP.JSONValue): s.ImportJobsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toImportJobResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toJourneyDateRangeKpiResponse(root: jsonP.JSONValue): s.JourneyDateRangeKpiResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "EndTime": "d",
      "JourneyId": "s",
      "KpiName": "s",
      "KpiResult": toBaseKpiResult,
      "StartTime": "d",
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toJourneyExecutionActivityMetricsResponse(root: jsonP.JSONValue): s.JourneyExecutionActivityMetricsResponse {
  return jsonP.readObj({
    required: {
      "ActivityType": "s",
      "ApplicationId": "s",
      "JourneyActivityId": "s",
      "JourneyId": "s",
      "LastEvaluatedTime": "s",
      "Metrics": x => jsonP.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

function toJourneyExecutionMetricsResponse(root: jsonP.JSONValue): s.JourneyExecutionMetricsResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "JourneyId": "s",
      "LastEvaluatedTime": "s",
      "Metrics": x => jsonP.readMap(String, String, x),
    },
    optional: {},
  }, root);
}

function toPushNotificationTemplateResponse(root: jsonP.JSONValue): s.PushNotificationTemplateResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
    },
    optional: {
      "ADM": toAndroidPushNotificationTemplate,
      "APNS": toAPNSPushNotificationTemplate,
      "Arn": "s",
      "Baidu": toAndroidPushNotificationTemplate,
      "Default": toDefaultPushNotificationTemplate,
      "DefaultSubstitutions": "s",
      "GCM": toAndroidPushNotificationTemplate,
      "RecommenderId": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateDescription": "s",
      "Version": "s",
    },
  }, root);
}

function toListRecommenderConfigurationsResponse(root: jsonP.JSONValue): s.ListRecommenderConfigurationsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toRecommenderConfigurationResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toSegmentsResponse(root: jsonP.JSONValue): s.SegmentsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toSegmentResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toSMSTemplateResponse(root: jsonP.JSONValue): s.SMSTemplateResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
    },
    optional: {
      "Arn": "s",
      "Body": "s",
      "DefaultSubstitutions": "s",
      "RecommenderId": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateDescription": "s",
      "Version": "s",
    },
  }, root);
}

function toVoiceTemplateResponse(root: jsonP.JSONValue): s.VoiceTemplateResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
    },
    optional: {
      "Arn": "s",
      "Body": "s",
      "DefaultSubstitutions": "s",
      "LanguageCode": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateDescription": "s",
      "Version": "s",
      "VoiceId": "s",
    },
  }, root);
}

function toJourneysResponse(root: jsonP.JSONValue): s.JourneysResponse {
  return jsonP.readObj({
    required: {
      "Item": [toJourneyResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toTemplateVersionsResponse(root: jsonP.JSONValue): s.TemplateVersionsResponse {
  return jsonP.readObj({
    required: {
      "Item": [toTemplateVersionResponse],
    },
    optional: {
      "Message": "s",
      "NextToken": "s",
      "RequestID": "s",
    },
  }, root);
}

function toTemplateVersionResponse(root: jsonP.JSONValue): s.TemplateVersionResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": "s",
    },
    optional: {
      "DefaultSubstitutions": "s",
      "TemplateDescription": "s",
      "Version": "s",
    },
  }, root);
}

function toTemplatesResponse(root: jsonP.JSONValue): s.TemplatesResponse {
  return jsonP.readObj({
    required: {
      "Item": [toTemplateResponse],
    },
    optional: {
      "NextToken": "s",
    },
  }, root);
}

function toTemplateResponse(root: jsonP.JSONValue): s.TemplateResponse {
  return jsonP.readObj({
    required: {
      "CreationDate": "s",
      "LastModifiedDate": "s",
      "TemplateName": "s",
      "TemplateType": (x: jsonP.JSONValue) => cmnP.readEnum<s.TemplateType>(x),
    },
    optional: {
      "Arn": "s",
      "DefaultSubstitutions": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "TemplateDescription": "s",
      "Version": "s",
    },
  }, root);
}

function toNumberValidateResponse(root: jsonP.JSONValue): s.NumberValidateResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Carrier": "s",
      "City": "s",
      "CleansedPhoneNumberE164": "s",
      "CleansedPhoneNumberNational": "s",
      "Country": "s",
      "CountryCodeIso2": "s",
      "CountryCodeNumeric": "s",
      "County": "s",
      "OriginalCountryCodeIso2": "s",
      "OriginalPhoneNumber": "s",
      "PhoneType": "s",
      "PhoneTypeCode": "n",
      "Timezone": "s",
      "ZipCode": "s",
    },
  }, root);
}

function toEventsResponse(root: jsonP.JSONValue): s.EventsResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Results": x => jsonP.readMap(String, toItemResponse, x),
    },
  }, root);
}

function toItemResponse(root: jsonP.JSONValue): s.ItemResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "EndpointItemResponse": toEndpointItemResponse,
      "EventsItemResponse": x => jsonP.readMap(String, toEventItemResponse, x),
    },
  }, root);
}

function toEndpointItemResponse(root: jsonP.JSONValue): s.EndpointItemResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Message": "s",
      "StatusCode": "n",
    },
  }, root);
}

function toEventItemResponse(root: jsonP.JSONValue): s.EventItemResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Message": "s",
      "StatusCode": "n",
    },
  }, root);
}

function toAttributesResource(root: jsonP.JSONValue): s.AttributesResource {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
      "AttributeType": "s",
    },
    optional: {
      "Attributes": ["s"],
    },
  }, root);
}

function toMessageResponse(root: jsonP.JSONValue): s.MessageResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
    },
    optional: {
      "EndpointResult": x => jsonP.readMap(String, toEndpointMessageResult, x),
      "RequestId": "s",
      "Result": x => jsonP.readMap(String, toMessageResult, x),
    },
  }, root);
}

function toEndpointMessageResult(root: jsonP.JSONValue): s.EndpointMessageResult {
  return jsonP.readObj({
    required: {
      "DeliveryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStatus>(x),
      "StatusCode": "n",
    },
    optional: {
      "Address": "s",
      "MessageId": "s",
      "StatusMessage": "s",
      "UpdatedToken": "s",
    },
  }, root);
}

function toMessageResult(root: jsonP.JSONValue): s.MessageResult {
  return jsonP.readObj({
    required: {
      "DeliveryStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.DeliveryStatus>(x),
      "StatusCode": "n",
    },
    optional: {
      "MessageId": "s",
      "StatusMessage": "s",
      "UpdatedToken": "s",
    },
  }, root);
}

function toSendUsersMessageResponse(root: jsonP.JSONValue): s.SendUsersMessageResponse {
  return jsonP.readObj({
    required: {
      "ApplicationId": "s",
    },
    optional: {
      "RequestId": "s",
      "Result": x => jsonP.readMap(String, y => jsonP.readMap(String, toEndpointMessageResult, y)!, x),
    },
  }, root);
}
