// Autogenerated API client for: Amazon CloudFront

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";

export default class CloudFront {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFront.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2020-05-31",
    "endpointPrefix": "cloudfront",
    "globalEndpoint": "cloudfront.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "CloudFront",
    "serviceFullName": "Amazon CloudFront",
    "serviceId": "CloudFront",
    "signatureVersion": "v4",
    "uid": "cloudfront-2020-05-31"
  };

  async createCachePolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateCachePolicyRequest,
  ): Promise<CreateCachePolicyResult> {
    const inner = params["CachePolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "CachePolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "DefaultTTL", content: inner["DefaultTTL"]?.toString()},
        {name: "MaxTTL", content: inner["MaxTTL"]?.toString()},
        {name: "MinTTL", content: inner["MinTTL"]?.toString()},
        {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(inner["ParametersInCacheKeyAndForwardedToOrigin"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCachePolicy2020_05_31",
      requestUri: "/2020-05-31/cache-policy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async createCloudFrontOriginAccessIdentity2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateCloudFrontOriginAccessIdentityRequest,
  ): Promise<CreateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFrontOriginAccessIdentity2020_05_31",
      requestUri: "/2020-05-31/origin-access-identity/cloudfront",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async createDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateDistributionRequest,
  ): Promise<CreateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "OriginGroups", ...OriginGroups_Serialize(inner["OriginGroups"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistribution2020_05_31",
      requestUri: "/2020-05-31/distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createDistributionWithTags2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateDistributionWithTagsRequest,
  ): Promise<CreateDistributionWithTagsResult> {
    const inner = params["DistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "DistributionConfig", ...DistributionConfig_Serialize(inner["DistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistributionWithTags2020_05_31",
      requestUri: "/2020-05-31/distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createFieldLevelEncryptionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateFieldLevelEncryptionConfigRequest,
  ): Promise<CreateFieldLevelEncryptionConfigResult> {
    const inner = params["FieldLevelEncryptionConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(inner["QueryArgProfileConfig"])},
        {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(inner["ContentTypeProfileConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFieldLevelEncryptionConfig2020_05_31",
      requestUri: "/2020-05-31/field-level-encryption",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async createFieldLevelEncryptionProfile2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateFieldLevelEncryptionProfileRequest,
  ): Promise<CreateFieldLevelEncryptionProfileResult> {
    const inner = params["FieldLevelEncryptionProfileConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionProfileConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "EncryptionEntities", ...EncryptionEntities_Serialize(inner["EncryptionEntities"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFieldLevelEncryptionProfile2020_05_31",
      requestUri: "/2020-05-31/field-level-encryption-profile",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async createInvalidation2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateInvalidationRequest,
  ): Promise<CreateInvalidationResult> {
    const inner = params["InvalidationBatch"];
    const body = inner ? xmlP.stringify({
      name: "InvalidationBatch",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Paths", ...Paths_Serialize(inner["Paths"])},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInvalidation2020_05_31",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async createKeyGroup2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateKeyGroupRequest,
  ): Promise<CreateKeyGroupResult> {
    const inner = params["KeyGroupConfig"];
    const body = inner ? xmlP.stringify({
      name: "KeyGroupConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "Items", children: inner["Items"]?.map(x => ({name: "PublicKey", content: x}))},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeyGroup2020_05_31",
      requestUri: "/2020-05-31/key-group",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async createMonitoringSubscription2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateMonitoringSubscriptionRequest,
  ): Promise<CreateMonitoringSubscriptionResult> {
    const inner = params["MonitoringSubscription"];
    const body = inner ? xmlP.stringify({
      name: "MonitoringSubscription",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "RealtimeMetricsSubscriptionConfig", ...RealtimeMetricsSubscriptionConfig_Serialize(inner["RealtimeMetricsSubscriptionConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMonitoringSubscription2020_05_31",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    MonitoringSubscription: MonitoringSubscription_Parse(xml),
  };
  }

  async createOriginRequestPolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateOriginRequestPolicyRequest,
  ): Promise<CreateOriginRequestPolicyResult> {
    const inner = params["OriginRequestPolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "OriginRequestPolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(inner["HeadersConfig"])},
        {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(inner["CookiesConfig"])},
        {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(inner["QueryStringsConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOriginRequestPolicy2020_05_31",
      requestUri: "/2020-05-31/origin-request-policy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async createPublicKey2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreatePublicKeyRequest,
  ): Promise<CreatePublicKeyResult> {
    const inner = params["PublicKeyConfig"];
    const body = inner ? xmlP.stringify({
      name: "PublicKeyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "EncodedKey", content: inner["EncodedKey"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePublicKey2020_05_31",
      requestUri: "/2020-05-31/public-key",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async createRealtimeLogConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateRealtimeLogConfigRequest,
  ): Promise<CreateRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "CreateRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "EndPoints", children: params["EndPoints"]?.map(x => ({name: "member", ...EndPoint_Serialize(x)}))},
        {name: "Fields", children: params["Fields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "SamplingRate", content: params["SamplingRate"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/realtime-log-config",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async createStreamingDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateStreamingDistributionRequest,
  ): Promise<CreateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistribution2020_05_31",
      requestUri: "/2020-05-31/streaming-distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async createStreamingDistributionWithTags2020_05_31(
    {abortSignal, ...params}: RequestConfig & CreateStreamingDistributionWithTagsRequest,
  ): Promise<CreateStreamingDistributionWithTagsResult> {
    const inner = params["StreamingDistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(inner["StreamingDistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistributionWithTags2020_05_31",
      requestUri: "/2020-05-31/streaming-distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async deleteCachePolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteCachePolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCachePolicy2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteCloudFrontOriginAccessIdentity2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteCloudFrontOriginAccessIdentityRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCloudFrontOriginAccessIdentity2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDistribution2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteFieldLevelEncryptionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteFieldLevelEncryptionConfigRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFieldLevelEncryptionConfig2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteFieldLevelEncryptionProfile2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteFieldLevelEncryptionProfileRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFieldLevelEncryptionProfile2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteKeyGroup2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteKeyGroupRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteKeyGroup2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteMonitoringSubscription2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteMonitoringSubscriptionRequest,
  ): Promise<DeleteMonitoringSubscriptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMonitoringSubscription2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    return {
    };
  }

  async deleteOriginRequestPolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteOriginRequestPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteOriginRequestPolicy2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deletePublicKey2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeletePublicKeyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeletePublicKey2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteRealtimeLogConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteRealtimeLogConfigRequest = {},
  ): Promise<void> {
    const body = xmlP.stringify({
      name: "DeleteRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/delete-realtime-log-config/",
      responseCode: 204,
    });
  }

  async deleteStreamingDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & DeleteStreamingDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStreamingDistribution2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async getCachePolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetCachePolicyRequest,
  ): Promise<GetCachePolicyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCachePolicy2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async getCachePolicyConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetCachePolicyConfigRequest,
  ): Promise<GetCachePolicyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCachePolicyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicyConfig: CachePolicyConfig_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentity2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetCloudFrontOriginAccessIdentityRequest,
  ): Promise<GetCloudFrontOriginAccessIdentityResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentity2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentityConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetCloudFrontOriginAccessIdentityConfigRequest,
  ): Promise<GetCloudFrontOriginAccessIdentityConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentityConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig_Parse(xml),
  };
  }

  async getDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetDistributionRequest,
  ): Promise<GetDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistribution2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async getDistributionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetDistributionConfigRequest,
  ): Promise<GetDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistributionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    DistributionConfig: DistributionConfig_Parse(xml),
  };
  }

  async getFieldLevelEncryption2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetFieldLevelEncryptionRequest,
  ): Promise<GetFieldLevelEncryptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryption2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async getFieldLevelEncryptionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetFieldLevelEncryptionConfigRequest,
  ): Promise<GetFieldLevelEncryptionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionConfig: FieldLevelEncryptionConfig_Parse(xml),
  };
  }

  async getFieldLevelEncryptionProfile2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetFieldLevelEncryptionProfileRequest,
  ): Promise<GetFieldLevelEncryptionProfileResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionProfile2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async getFieldLevelEncryptionProfileConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetFieldLevelEncryptionProfileConfigRequest,
  ): Promise<GetFieldLevelEncryptionProfileConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionProfileConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig_Parse(xml),
  };
  }

  async getInvalidation2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetInvalidationRequest,
  ): Promise<GetInvalidationResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInvalidation2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async getKeyGroup2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetKeyGroupRequest,
  ): Promise<GetKeyGroupResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetKeyGroup2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async getKeyGroupConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetKeyGroupConfigRequest,
  ): Promise<GetKeyGroupConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetKeyGroupConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroupConfig: KeyGroupConfig_Parse(xml),
  };
  }

  async getMonitoringSubscription2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetMonitoringSubscriptionRequest,
  ): Promise<GetMonitoringSubscriptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMonitoringSubscription2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    MonitoringSubscription: MonitoringSubscription_Parse(xml),
  };
  }

  async getOriginRequestPolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetOriginRequestPolicyRequest,
  ): Promise<GetOriginRequestPolicyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetOriginRequestPolicy2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async getOriginRequestPolicyConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetOriginRequestPolicyConfigRequest,
  ): Promise<GetOriginRequestPolicyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetOriginRequestPolicyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicyConfig: OriginRequestPolicyConfig_Parse(xml),
  };
  }

  async getPublicKey2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetPublicKeyRequest,
  ): Promise<GetPublicKeyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPublicKey2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async getPublicKeyConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetPublicKeyConfigRequest,
  ): Promise<GetPublicKeyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPublicKeyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKeyConfig: PublicKeyConfig_Parse(xml),
  };
  }

  async getRealtimeLogConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetRealtimeLogConfigRequest = {},
  ): Promise<GetRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "GetRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/get-realtime-log-config/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async getStreamingDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetStreamingDistributionRequest,
  ): Promise<GetStreamingDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistribution2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async getStreamingDistributionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & GetStreamingDistributionConfigRequest,
  ): Promise<GetStreamingDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistributionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistributionConfig: StreamingDistributionConfig_Parse(xml),
  };
  }

  async listCachePolicies2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListCachePoliciesRequest = {},
  ): Promise<ListCachePoliciesResult> {
    const query = new URLSearchParams;
    if (params["Type"] != null) query.set("Type", params["Type"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCachePolicies2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/cache-policy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CachePolicyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CachePolicySummary").map(CachePolicySummary_Parse),
      },
  };
  }

  async listCloudFrontOriginAccessIdentities2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListCloudFrontOriginAccessIdentitiesRequest = {},
  ): Promise<ListCloudFrontOriginAccessIdentitiesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCloudFrontOriginAccessIdentities2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/origin-access-identity/cloudfront",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CloudFrontOriginAccessIdentityList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
      },
  };
  }

  async listDistributions2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsRequest = {},
  ): Promise<ListDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributions2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByCachePolicyId2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByCachePolicyIdRequest,
  ): Promise<ListDistributionsByCachePolicyIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByCachePolicyId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByCachePolicyId/${params["CachePolicyId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByKeyGroup2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByKeyGroupRequest,
  ): Promise<ListDistributionsByKeyGroupResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByKeyGroup2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByKeyGroupId/${params["KeyGroupId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByOriginRequestPolicyId2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByOriginRequestPolicyIdRequest,
  ): Promise<ListDistributionsByOriginRequestPolicyIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByOriginRequestPolicyId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByOriginRequestPolicyId/${params["OriginRequestPolicyId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByRealtimeLogConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByRealtimeLogConfigRequest = {},
  ): Promise<ListDistributionsByRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "ListDistributionsByRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Marker", content: params["Marker"]?.toString()},
        {name: "MaxItems", content: params["MaxItems"]?.toString()},
        {name: "RealtimeLogConfigName", content: params["RealtimeLogConfigName"]?.toString()},
        {name: "RealtimeLogConfigArn", content: params["RealtimeLogConfigArn"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDistributionsByRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/distributionsByRealtimeLogConfig/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByWebACLId2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListDistributionsByWebACLIdRequest,
  ): Promise<ListDistributionsByWebACLIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByWebACLId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByWebACLId/${params["WebACLId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listFieldLevelEncryptionConfigs2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListFieldLevelEncryptionConfigsRequest = {},
  ): Promise<ListFieldLevelEncryptionConfigsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFieldLevelEncryptionConfigs2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/field-level-encryption",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    FieldLevelEncryptionList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "FieldLevelEncryptionSummary").map(FieldLevelEncryptionSummary_Parse),
      },
  };
  }

  async listFieldLevelEncryptionProfiles2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListFieldLevelEncryptionProfilesRequest = {},
  ): Promise<ListFieldLevelEncryptionProfilesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFieldLevelEncryptionProfiles2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/field-level-encryption-profile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    FieldLevelEncryptionProfileList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "FieldLevelEncryptionProfileSummary").map(FieldLevelEncryptionProfileSummary_Parse),
      },
  };
  }

  async listInvalidations2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListInvalidationsRequest,
  ): Promise<ListInvalidationsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvalidations2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    InvalidationList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
      },
  };
  }

  async listKeyGroups2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListKeyGroupsRequest = {},
  ): Promise<ListKeyGroupsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListKeyGroups2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/key-group",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    KeyGroupList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "KeyGroupSummary").map(KeyGroupSummary_Parse),
      },
  };
  }

  async listOriginRequestPolicies2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListOriginRequestPoliciesRequest = {},
  ): Promise<ListOriginRequestPoliciesResult> {
    const query = new URLSearchParams;
    if (params["Type"] != null) query.set("Type", params["Type"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOriginRequestPolicies2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/origin-request-policy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    OriginRequestPolicyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "OriginRequestPolicySummary").map(OriginRequestPolicySummary_Parse),
      },
  };
  }

  async listPublicKeys2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListPublicKeysRequest = {},
  ): Promise<ListPublicKeysResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPublicKeys2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/public-key",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PublicKeyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "PublicKeySummary").map(PublicKeySummary_Parse),
      },
  };
  }

  async listRealtimeLogConfigs2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListRealtimeLogConfigsRequest = {},
  ): Promise<ListRealtimeLogConfigsResult> {
    const query = new URLSearchParams;
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRealtimeLogConfigs2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/realtime-log-config",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    RealtimeLogConfigs: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "member").map(RealtimeLogConfig_Parse),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
      },
  };
  }

  async listStreamingDistributions2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListStreamingDistributionsRequest = {},
  ): Promise<ListStreamingDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListStreamingDistributions2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/streaming-distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StreamingDistributionList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
      },
  };
  }

  async listTagsForResource2020_05_31(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResult> {
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/tagging",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Tags: Tags_Parse(xml),
  };
  }

  async tagResource2020_05_31(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<void> {
    const inner = params["Tags"];
    const body = inner ? xmlP.stringify({
      name: "Tags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource2020_05_31",
      requestUri: "/2020-05-31/tagging?Operation=Tag",
      responseCode: 204,
    });
  }

  async untagResource2020_05_31(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<void> {
    const inner = params["TagKeys"];
    const body = inner ? xmlP.stringify({
      name: "TagKeys",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Key", content: x}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource2020_05_31",
      requestUri: "/2020-05-31/tagging?Operation=Untag",
      responseCode: 204,
    });
  }

  async updateCachePolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateCachePolicyRequest,
  ): Promise<UpdateCachePolicyResult> {
    const inner = params["CachePolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "CachePolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "DefaultTTL", content: inner["DefaultTTL"]?.toString()},
        {name: "MaxTTL", content: inner["MaxTTL"]?.toString()},
        {name: "MinTTL", content: inner["MinTTL"]?.toString()},
        {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(inner["ParametersInCacheKeyAndForwardedToOrigin"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCachePolicy2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async updateCloudFrontOriginAccessIdentity2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateCloudFrontOriginAccessIdentityRequest,
  ): Promise<UpdateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCloudFrontOriginAccessIdentity2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async updateDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateDistributionRequest,
  ): Promise<UpdateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "OriginGroups", ...OriginGroups_Serialize(inner["OriginGroups"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDistribution2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async updateFieldLevelEncryptionConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateFieldLevelEncryptionConfigRequest,
  ): Promise<UpdateFieldLevelEncryptionConfigResult> {
    const inner = params["FieldLevelEncryptionConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(inner["QueryArgProfileConfig"])},
        {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(inner["ContentTypeProfileConfig"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFieldLevelEncryptionConfig2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async updateFieldLevelEncryptionProfile2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateFieldLevelEncryptionProfileRequest,
  ): Promise<UpdateFieldLevelEncryptionProfileResult> {
    const inner = params["FieldLevelEncryptionProfileConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionProfileConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "EncryptionEntities", ...EncryptionEntities_Serialize(inner["EncryptionEntities"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFieldLevelEncryptionProfile2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async updateKeyGroup2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateKeyGroupRequest,
  ): Promise<UpdateKeyGroupResult> {
    const inner = params["KeyGroupConfig"];
    const body = inner ? xmlP.stringify({
      name: "KeyGroupConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "Items", children: inner["Items"]?.map(x => ({name: "PublicKey", content: x}))},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateKeyGroup2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async updateOriginRequestPolicy2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateOriginRequestPolicyRequest,
  ): Promise<UpdateOriginRequestPolicyResult> {
    const inner = params["OriginRequestPolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "OriginRequestPolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(inner["HeadersConfig"])},
        {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(inner["CookiesConfig"])},
        {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(inner["QueryStringsConfig"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateOriginRequestPolicy2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async updatePublicKey2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdatePublicKeyRequest,
  ): Promise<UpdatePublicKeyResult> {
    const inner = params["PublicKeyConfig"];
    const body = inner ? xmlP.stringify({
      name: "PublicKeyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "EncodedKey", content: inner["EncodedKey"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdatePublicKey2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async updateRealtimeLogConfig2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateRealtimeLogConfigRequest = {},
  ): Promise<UpdateRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "UpdateRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "EndPoints", children: params["EndPoints"]?.map(x => ({name: "member", ...EndPoint_Serialize(x)}))},
        {name: "Fields", children: params["Fields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
        {name: "SamplingRate", content: params["SamplingRate"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRealtimeLogConfig2020_05_31",
      method: "PUT",
      requestUri: "/2020-05-31/realtime-log-config/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async updateStreamingDistribution2020_05_31(
    {abortSignal, ...params}: RequestConfig & UpdateStreamingDistributionRequest,
  ): Promise<UpdateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateStreamingDistribution2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  // Resource State Waiters

  /**
   * Wait until a distribution is deployed.
   * Checks state up to 35 times, 60 seconds apart (about 35 minutes max wait time).
   */
  async waitForDistributionDeployed(
    params: RequestConfig & GetDistributionRequest,
  ): Promise<GetDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DistributionDeployed';
    for (let i = 0; i < 35; i++) {
      const resp = await this.getDistribution2020_05_31(params);
      if (resp?.Distribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an invalidation has completed.
   * Checks state up to 30 times, 20 seconds apart (about 10 minutes max wait time).
   */
  async waitForInvalidationCompleted(
    params: RequestConfig & GetInvalidationRequest,
  ): Promise<GetInvalidationResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InvalidationCompleted';
    for (let i = 0; i < 30; i++) {
      const resp = await this.getInvalidation2020_05_31(params);
      if (resp?.Invalidation?.Status === "Completed") return resp;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a streaming distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForStreamingDistributionDeployed(
    params: RequestConfig & GetStreamingDistributionRequest,
  ): Promise<GetStreamingDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamingDistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getStreamingDistribution2020_05_31(params);
      if (resp?.StreamingDistribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

// refs: 1 - tags: named, input
export interface CreateCachePolicyRequest {
  CachePolicyConfig: CachePolicyConfig;
}

// refs: 1 - tags: named, input
export interface CreateCloudFrontOriginAccessIdentityRequest {
  CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
}

// refs: 1 - tags: named, input
export interface CreateDistributionRequest {
  DistributionConfig: DistributionConfig;
}

// refs: 1 - tags: named, input
export interface CreateDistributionWithTagsRequest {
  DistributionConfigWithTags: DistributionConfigWithTags;
}

// refs: 1 - tags: named, input
export interface CreateFieldLevelEncryptionConfigRequest {
  FieldLevelEncryptionConfig: FieldLevelEncryptionConfig;
}

// refs: 1 - tags: named, input
export interface CreateFieldLevelEncryptionProfileRequest {
  FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig;
}

// refs: 1 - tags: named, input
export interface CreateInvalidationRequest {
  DistributionId: string;
  InvalidationBatch: InvalidationBatch;
}

// refs: 1 - tags: named, input
export interface CreateKeyGroupRequest {
  KeyGroupConfig: KeyGroupConfig;
}

// refs: 1 - tags: named, input
export interface CreateMonitoringSubscriptionRequest {
  DistributionId: string;
  MonitoringSubscription: MonitoringSubscription;
}

// refs: 1 - tags: named, input
export interface CreateOriginRequestPolicyRequest {
  OriginRequestPolicyConfig: OriginRequestPolicyConfig;
}

// refs: 1 - tags: named, input
export interface CreatePublicKeyRequest {
  PublicKeyConfig: PublicKeyConfig;
}

// refs: 1 - tags: named, input
export interface CreateRealtimeLogConfigRequest {
  EndPoints: EndPoint[];
  Fields: string[];
  Name: string;
  SamplingRate: number;
}

// refs: 1 - tags: named, input
export interface CreateStreamingDistributionRequest {
  StreamingDistributionConfig: StreamingDistributionConfig;
}

// refs: 1 - tags: named, input
export interface CreateStreamingDistributionWithTagsRequest {
  StreamingDistributionConfigWithTags: StreamingDistributionConfigWithTags;
}

// refs: 1 - tags: named, input
export interface DeleteCachePolicyRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteCloudFrontOriginAccessIdentityRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteDistributionRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteFieldLevelEncryptionConfigRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteFieldLevelEncryptionProfileRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteKeyGroupRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteMonitoringSubscriptionRequest {
  DistributionId: string;
}

// refs: 1 - tags: named, input
export interface DeleteOriginRequestPolicyRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeletePublicKeyRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteRealtimeLogConfigRequest {
  Name?: string | null;
  ARN?: string | null;
}

// refs: 1 - tags: named, input
export interface DeleteStreamingDistributionRequest {
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface GetCachePolicyRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetCachePolicyConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetCloudFrontOriginAccessIdentityRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetCloudFrontOriginAccessIdentityConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetDistributionRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetDistributionConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetFieldLevelEncryptionRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetFieldLevelEncryptionConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetFieldLevelEncryptionProfileRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetFieldLevelEncryptionProfileConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetInvalidationRequest {
  DistributionId: string;
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetKeyGroupRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetKeyGroupConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetMonitoringSubscriptionRequest {
  DistributionId: string;
}

// refs: 1 - tags: named, input
export interface GetOriginRequestPolicyRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetOriginRequestPolicyConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetPublicKeyRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetPublicKeyConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetRealtimeLogConfigRequest {
  Name?: string | null;
  ARN?: string | null;
}

// refs: 1 - tags: named, input
export interface GetStreamingDistributionRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface GetStreamingDistributionConfigRequest {
  Id: string;
}

// refs: 1 - tags: named, input
export interface ListCachePoliciesRequest {
  Type?: CachePolicyType | null;
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListCloudFrontOriginAccessIdentitiesRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDistributionsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByCachePolicyIdRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  CachePolicyId: string;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByKeyGroupRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  KeyGroupId: string;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByOriginRequestPolicyIdRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  OriginRequestPolicyId: string;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByRealtimeLogConfigRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  RealtimeLogConfigName?: string | null;
  RealtimeLogConfigArn?: string | null;
}

// refs: 1 - tags: named, input
export interface ListDistributionsByWebACLIdRequest {
  Marker?: string | null;
  MaxItems?: string | null;
  WebACLId: string;
}

// refs: 1 - tags: named, input
export interface ListFieldLevelEncryptionConfigsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListFieldLevelEncryptionProfilesRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListInvalidationsRequest {
  DistributionId: string;
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListKeyGroupsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListOriginRequestPoliciesRequest {
  Type?: OriginRequestPolicyType | null;
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListPublicKeysRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListRealtimeLogConfigsRequest {
  MaxItems?: string | null;
  Marker?: string | null;
}

// refs: 1 - tags: named, input
export interface ListStreamingDistributionsRequest {
  Marker?: string | null;
  MaxItems?: string | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  Resource: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  Resource: string;
  Tags: Tags;
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  Resource: string;
  TagKeys: TagKeys;
}

// refs: 1 - tags: named, input
export interface UpdateCachePolicyRequest {
  CachePolicyConfig: CachePolicyConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateCloudFrontOriginAccessIdentityRequest {
  CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateDistributionRequest {
  DistributionConfig: DistributionConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateFieldLevelEncryptionConfigRequest {
  FieldLevelEncryptionConfig: FieldLevelEncryptionConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateFieldLevelEncryptionProfileRequest {
  FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateKeyGroupRequest {
  KeyGroupConfig: KeyGroupConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateOriginRequestPolicyRequest {
  OriginRequestPolicyConfig: OriginRequestPolicyConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdatePublicKeyRequest {
  PublicKeyConfig: PublicKeyConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, input
export interface UpdateRealtimeLogConfigRequest {
  EndPoints?: EndPoint[] | null;
  Fields?: string[] | null;
  Name?: string | null;
  ARN?: string | null;
  SamplingRate?: number | null;
}

// refs: 1 - tags: named, input
export interface UpdateStreamingDistributionRequest {
  StreamingDistributionConfig: StreamingDistributionConfig;
  Id: string;
  IfMatch?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCachePolicyResult {
  CachePolicy?: CachePolicy | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDistributionResult {
  Distribution?: Distribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateDistributionWithTagsResult {
  Distribution?: Distribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateFieldLevelEncryptionConfigResult {
  FieldLevelEncryption?: FieldLevelEncryption | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateFieldLevelEncryptionProfileResult {
  FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateInvalidationResult {
  Location?: string | null;
  Invalidation?: Invalidation | null;
}

// refs: 1 - tags: named, output
export interface CreateKeyGroupResult {
  KeyGroup?: KeyGroup | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateMonitoringSubscriptionResult {
  MonitoringSubscription?: MonitoringSubscription | null;
}

// refs: 1 - tags: named, output
export interface CreateOriginRequestPolicyResult {
  OriginRequestPolicy?: OriginRequestPolicy | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreatePublicKeyResult {
  PublicKey?: PublicKey | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateRealtimeLogConfigResult {
  RealtimeLogConfig?: RealtimeLogConfig | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface CreateStreamingDistributionWithTagsResult {
  StreamingDistribution?: StreamingDistribution | null;
  Location?: string | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface DeleteMonitoringSubscriptionResult {
}

// refs: 1 - tags: named, output
export interface GetCachePolicyResult {
  CachePolicy?: CachePolicy | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCachePolicyConfigResult {
  CachePolicyConfig?: CachePolicyConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetCloudFrontOriginAccessIdentityConfigResult {
  CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDistributionResult {
  Distribution?: Distribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetDistributionConfigResult {
  DistributionConfig?: DistributionConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetFieldLevelEncryptionResult {
  FieldLevelEncryption?: FieldLevelEncryption | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetFieldLevelEncryptionConfigResult {
  FieldLevelEncryptionConfig?: FieldLevelEncryptionConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetFieldLevelEncryptionProfileResult {
  FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetFieldLevelEncryptionProfileConfigResult {
  FieldLevelEncryptionProfileConfig?: FieldLevelEncryptionProfileConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetInvalidationResult {
  Invalidation?: Invalidation | null;
}

// refs: 1 - tags: named, output
export interface GetKeyGroupResult {
  KeyGroup?: KeyGroup | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetKeyGroupConfigResult {
  KeyGroupConfig?: KeyGroupConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetMonitoringSubscriptionResult {
  MonitoringSubscription?: MonitoringSubscription | null;
}

// refs: 1 - tags: named, output
export interface GetOriginRequestPolicyResult {
  OriginRequestPolicy?: OriginRequestPolicy | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetOriginRequestPolicyConfigResult {
  OriginRequestPolicyConfig?: OriginRequestPolicyConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPublicKeyResult {
  PublicKey?: PublicKey | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetPublicKeyConfigResult {
  PublicKeyConfig?: PublicKeyConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetRealtimeLogConfigResult {
  RealtimeLogConfig?: RealtimeLogConfig | null;
}

// refs: 1 - tags: named, output
export interface GetStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface GetStreamingDistributionConfigResult {
  StreamingDistributionConfig?: StreamingDistributionConfig | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface ListCachePoliciesResult {
  CachePolicyList?: CachePolicyList | null;
}

// refs: 1 - tags: named, output
export interface ListCloudFrontOriginAccessIdentitiesResult {
  CloudFrontOriginAccessIdentityList?: CloudFrontOriginAccessIdentityList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsResult {
  DistributionList?: DistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByCachePolicyIdResult {
  DistributionIdList?: DistributionIdList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByKeyGroupResult {
  DistributionIdList?: DistributionIdList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByOriginRequestPolicyIdResult {
  DistributionIdList?: DistributionIdList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByRealtimeLogConfigResult {
  DistributionList?: DistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListDistributionsByWebACLIdResult {
  DistributionList?: DistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListFieldLevelEncryptionConfigsResult {
  FieldLevelEncryptionList?: FieldLevelEncryptionList | null;
}

// refs: 1 - tags: named, output
export interface ListFieldLevelEncryptionProfilesResult {
  FieldLevelEncryptionProfileList?: FieldLevelEncryptionProfileList | null;
}

// refs: 1 - tags: named, output
export interface ListInvalidationsResult {
  InvalidationList?: InvalidationList | null;
}

// refs: 1 - tags: named, output
export interface ListKeyGroupsResult {
  KeyGroupList?: KeyGroupList | null;
}

// refs: 1 - tags: named, output
export interface ListOriginRequestPoliciesResult {
  OriginRequestPolicyList?: OriginRequestPolicyList | null;
}

// refs: 1 - tags: named, output
export interface ListPublicKeysResult {
  PublicKeyList?: PublicKeyList | null;
}

// refs: 1 - tags: named, output
export interface ListRealtimeLogConfigsResult {
  RealtimeLogConfigs?: RealtimeLogConfigs | null;
}

// refs: 1 - tags: named, output
export interface ListStreamingDistributionsResult {
  StreamingDistributionList?: StreamingDistributionList | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResult {
  Tags: Tags;
}

// refs: 1 - tags: named, output
export interface UpdateCachePolicyResult {
  CachePolicy?: CachePolicy | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateCloudFrontOriginAccessIdentityResult {
  CloudFrontOriginAccessIdentity?: CloudFrontOriginAccessIdentity | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateDistributionResult {
  Distribution?: Distribution | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateFieldLevelEncryptionConfigResult {
  FieldLevelEncryption?: FieldLevelEncryption | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateFieldLevelEncryptionProfileResult {
  FieldLevelEncryptionProfile?: FieldLevelEncryptionProfile | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateKeyGroupResult {
  KeyGroup?: KeyGroup | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateOriginRequestPolicyResult {
  OriginRequestPolicy?: OriginRequestPolicy | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdatePublicKeyResult {
  PublicKey?: PublicKey | null;
  ETag?: string | null;
}

// refs: 1 - tags: named, output
export interface UpdateRealtimeLogConfigResult {
  RealtimeLogConfig?: RealtimeLogConfig | null;
}

// refs: 1 - tags: named, output
export interface UpdateStreamingDistributionResult {
  StreamingDistribution?: StreamingDistribution | null;
  ETag?: string | null;
}

// refs: 7 - tags: input, named, interface, output
export interface CachePolicyConfig {
  Comment?: string | null;
  Name: string;
  DefaultTTL?: number | null;
  MaxTTL?: number | null;
  MinTTL: number;
  ParametersInCacheKeyAndForwardedToOrigin?: ParametersInCacheKeyAndForwardedToOrigin | null;
}
function CachePolicyConfig_Serialize(data: CachePolicyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(data["ParametersInCacheKeyAndForwardedToOrigin"])},
  ]};
}
function CachePolicyConfig_Parse(node: xmlP.XmlNode): CachePolicyConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    ParametersInCacheKeyAndForwardedToOrigin: node.first("ParametersInCacheKeyAndForwardedToOrigin", false, ParametersInCacheKeyAndForwardedToOrigin_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface ParametersInCacheKeyAndForwardedToOrigin {
  EnableAcceptEncodingGzip: boolean;
  EnableAcceptEncodingBrotli?: boolean | null;
  HeadersConfig: CachePolicyHeadersConfig;
  CookiesConfig: CachePolicyCookiesConfig;
  QueryStringsConfig: CachePolicyQueryStringsConfig;
}
function ParametersInCacheKeyAndForwardedToOrigin_Serialize(data: ParametersInCacheKeyAndForwardedToOrigin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "EnableAcceptEncodingGzip", content: data["EnableAcceptEncodingGzip"]?.toString()},
    {name: "EnableAcceptEncodingBrotli", content: data["EnableAcceptEncodingBrotli"]?.toString()},
    {name: "HeadersConfig", ...CachePolicyHeadersConfig_Serialize(data["HeadersConfig"])},
    {name: "CookiesConfig", ...CachePolicyCookiesConfig_Serialize(data["CookiesConfig"])},
    {name: "QueryStringsConfig", ...CachePolicyQueryStringsConfig_Serialize(data["QueryStringsConfig"])},
  ]};
}
function ParametersInCacheKeyAndForwardedToOrigin_Parse(node: xmlP.XmlNode): ParametersInCacheKeyAndForwardedToOrigin {
  return {
    EnableAcceptEncodingGzip: node.first("EnableAcceptEncodingGzip", true, x => x.content === 'true'),
    EnableAcceptEncodingBrotli: node.first("EnableAcceptEncodingBrotli", false, x => x.content === 'true'),
    HeadersConfig: node.first("HeadersConfig", true, CachePolicyHeadersConfig_Parse),
    CookiesConfig: node.first("CookiesConfig", true, CachePolicyCookiesConfig_Parse),
    QueryStringsConfig: node.first("QueryStringsConfig", true, CachePolicyQueryStringsConfig_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface CachePolicyHeadersConfig {
  HeaderBehavior: CachePolicyHeaderBehavior;
  Headers?: Headers | null;
}
function CachePolicyHeadersConfig_Serialize(data: CachePolicyHeadersConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderBehavior", content: data["HeaderBehavior"]?.toString()},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
  ]};
}
function CachePolicyHeadersConfig_Parse(node: xmlP.XmlNode): CachePolicyHeadersConfig {
  return {
    HeaderBehavior: node.first("HeaderBehavior", true, x => (x.content ?? '') as CachePolicyHeaderBehavior),
    Headers: node.first("Headers", false, Headers_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type CachePolicyHeaderBehavior =
| "none"
| "whitelist"
| cmnP.UnexpectedEnumValue;

// refs: 36 - tags: input, named, interface, output
export interface Headers {
  Quantity: number;
  Items: string[];
}
function Headers_Serialize(data: Headers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function Headers_Parse(node: xmlP.XmlNode): Headers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface CachePolicyCookiesConfig {
  CookieBehavior: CachePolicyCookieBehavior;
  Cookies?: CookieNames | null;
}
function CachePolicyCookiesConfig_Serialize(data: CachePolicyCookiesConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CookieBehavior", content: data["CookieBehavior"]?.toString()},
    {name: "Cookies", ...CookieNames_Serialize(data["Cookies"])},
  ]};
}
function CachePolicyCookiesConfig_Parse(node: xmlP.XmlNode): CachePolicyCookiesConfig {
  return {
    CookieBehavior: node.first("CookieBehavior", true, x => (x.content ?? '') as CachePolicyCookieBehavior),
    Cookies: node.first("Cookies", false, CookieNames_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type CachePolicyCookieBehavior =
| "none"
| "whitelist"
| "allExcept"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 36 - tags: input, named, interface, output
export interface CookieNames {
  Quantity: number;
  Items: string[];
}
function CookieNames_Serialize(data: CookieNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function CookieNames_Parse(node: xmlP.XmlNode): CookieNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface CachePolicyQueryStringsConfig {
  QueryStringBehavior: CachePolicyQueryStringBehavior;
  QueryStrings?: QueryStringNames | null;
}
function CachePolicyQueryStringsConfig_Serialize(data: CachePolicyQueryStringsConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryStringBehavior", content: data["QueryStringBehavior"]?.toString()},
    {name: "QueryStrings", ...QueryStringNames_Serialize(data["QueryStrings"])},
  ]};
}
function CachePolicyQueryStringsConfig_Parse(node: xmlP.XmlNode): CachePolicyQueryStringsConfig {
  return {
    QueryStringBehavior: node.first("QueryStringBehavior", true, x => (x.content ?? '') as CachePolicyQueryStringBehavior),
    QueryStrings: node.first("QueryStrings", false, QueryStringNames_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type CachePolicyQueryStringBehavior =
| "none"
| "whitelist"
| "allExcept"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 14 - tags: input, named, interface, output
export interface QueryStringNames {
  Quantity: number;
  Items: string[];
}
function QueryStringNames_Serialize(data: QueryStringNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringNames_Parse(node: xmlP.XmlNode): QueryStringNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface CloudFrontOriginAccessIdentityConfig {
  CallerReference: string;
  Comment: string;
}
function CloudFrontOriginAccessIdentityConfig_Serialize(data: CloudFrontOriginAccessIdentityConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function CloudFrontOriginAccessIdentityConfig_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentityConfig {
  return node.strings({
    required: {"CallerReference":true,"Comment":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface DistributionConfig {
  CallerReference: string;
  Aliases?: Aliases | null;
  DefaultRootObject?: string | null;
  Origins: Origins;
  OriginGroups?: OriginGroups | null;
  DefaultCacheBehavior: DefaultCacheBehavior;
  CacheBehaviors?: CacheBehaviors | null;
  CustomErrorResponses?: CustomErrorResponses | null;
  Comment: string;
  Logging?: LoggingConfig | null;
  PriceClass?: PriceClass | null;
  Enabled: boolean;
  ViewerCertificate?: ViewerCertificate | null;
  Restrictions?: Restrictions | null;
  WebACLId?: string | null;
  HttpVersion?: HttpVersion | null;
  IsIPV6Enabled?: boolean | null;
}
function DistributionConfig_Serialize(data: DistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "DefaultRootObject", content: data["DefaultRootObject"]?.toString()},
    {name: "Origins", ...Origins_Serialize(data["Origins"])},
    {name: "OriginGroups", ...OriginGroups_Serialize(data["OriginGroups"])},
    {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(data["DefaultCacheBehavior"])},
    {name: "CacheBehaviors", ...CacheBehaviors_Serialize(data["CacheBehaviors"])},
    {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(data["CustomErrorResponses"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...LoggingConfig_Serialize(data["Logging"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "ViewerCertificate", ...ViewerCertificate_Serialize(data["ViewerCertificate"])},
    {name: "Restrictions", ...Restrictions_Serialize(data["Restrictions"])},
    {name: "WebACLId", content: data["WebACLId"]?.toString()},
    {name: "HttpVersion", content: data["HttpVersion"]?.toString()},
    {name: "IsIPV6Enabled", content: data["IsIPV6Enabled"]?.toString()},
  ]};
}
function DistributionConfig_Parse(node: xmlP.XmlNode): DistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
      optional: {"DefaultRootObject":true,"WebACLId":true},
    }),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    OriginGroups: node.first("OriginGroups", false, OriginGroups_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", false, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", false, CustomErrorResponses_Parse),
    Logging: node.first("Logging", false, LoggingConfig_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", false, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", false, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", false, x => (x.content ?? '') as HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", false, x => x.content === 'true'),
  };
}

// refs: 20 - tags: input, named, interface, output
export interface Aliases {
  Quantity: number;
  Items: string[];
}
function Aliases_Serialize(data: Aliases | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CNAME", content: x}))},
  ]};
}
function Aliases_Parse(node: xmlP.XmlNode): Aliases {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CNAME").map(x => x.content ?? ''),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface Origins {
  Quantity: number;
  Items: Origin[];
}
function Origins_Serialize(data: Origins | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Origin", ...Origin_Serialize(x)}))},
  ]};
}
function Origins_Parse(node: xmlP.XmlNode): Origins {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Origin").map(Origin_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface Origin {
  Id: string;
  DomainName: string;
  OriginPath?: string | null;
  CustomHeaders?: CustomHeaders | null;
  S3OriginConfig?: S3OriginConfig | null;
  CustomOriginConfig?: CustomOriginConfig | null;
  ConnectionAttempts?: number | null;
  ConnectionTimeout?: number | null;
  OriginShield?: OriginShield | null;
}
function Origin_Serialize(data: Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginPath", content: data["OriginPath"]?.toString()},
    {name: "CustomHeaders", ...CustomHeaders_Serialize(data["CustomHeaders"])},
    {name: "S3OriginConfig", ...S3OriginConfig_Serialize(data["S3OriginConfig"])},
    {name: "CustomOriginConfig", ...CustomOriginConfig_Serialize(data["CustomOriginConfig"])},
    {name: "ConnectionAttempts", content: data["ConnectionAttempts"]?.toString()},
    {name: "ConnectionTimeout", content: data["ConnectionTimeout"]?.toString()},
    {name: "OriginShield", ...OriginShield_Serialize(data["OriginShield"])},
  ]};
}
function Origin_Parse(node: xmlP.XmlNode): Origin {
  return {
    ...node.strings({
      required: {"Id":true,"DomainName":true},
      optional: {"OriginPath":true},
    }),
    CustomHeaders: node.first("CustomHeaders", false, CustomHeaders_Parse),
    S3OriginConfig: node.first("S3OriginConfig", false, S3OriginConfig_Parse),
    CustomOriginConfig: node.first("CustomOriginConfig", false, CustomOriginConfig_Parse),
    ConnectionAttempts: node.first("ConnectionAttempts", false, x => parseInt(x.content ?? '0')),
    ConnectionTimeout: node.first("ConnectionTimeout", false, x => parseInt(x.content ?? '0')),
    OriginShield: node.first("OriginShield", false, OriginShield_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface CustomHeaders {
  Quantity: number;
  Items: OriginCustomHeader[];
}
function CustomHeaders_Serialize(data: CustomHeaders | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginCustomHeader", ...OriginCustomHeader_Serialize(x)}))},
  ]};
}
function CustomHeaders_Parse(node: xmlP.XmlNode): CustomHeaders {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginCustomHeader").map(OriginCustomHeader_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginCustomHeader {
  HeaderName: string;
  HeaderValue: string;
}
function OriginCustomHeader_Serialize(data: OriginCustomHeader | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderName", content: data["HeaderName"]?.toString()},
    {name: "HeaderValue", content: data["HeaderValue"]?.toString()},
  ]};
}
function OriginCustomHeader_Parse(node: xmlP.XmlNode): OriginCustomHeader {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

// refs: 11 - tags: input, named, interface, output
export interface S3OriginConfig {
  OriginAccessIdentity: string;
}
function S3OriginConfig_Serialize(data: S3OriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3OriginConfig_Parse(node: xmlP.XmlNode): S3OriginConfig {
  return node.strings({
    required: {"OriginAccessIdentity":true},
  });
}

// refs: 11 - tags: input, named, interface, output
export interface CustomOriginConfig {
  HTTPPort: number;
  HTTPSPort: number;
  OriginProtocolPolicy: OriginProtocolPolicy;
  OriginSslProtocols?: OriginSslProtocols | null;
  OriginReadTimeout?: number | null;
  OriginKeepaliveTimeout?: number | null;
}
function CustomOriginConfig_Serialize(data: CustomOriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HTTPPort", content: data["HTTPPort"]?.toString()},
    {name: "HTTPSPort", content: data["HTTPSPort"]?.toString()},
    {name: "OriginProtocolPolicy", content: data["OriginProtocolPolicy"]?.toString()},
    {name: "OriginSslProtocols", ...OriginSslProtocols_Serialize(data["OriginSslProtocols"])},
    {name: "OriginReadTimeout", content: data["OriginReadTimeout"]?.toString()},
    {name: "OriginKeepaliveTimeout", content: data["OriginKeepaliveTimeout"]?.toString()},
  ]};
}
function CustomOriginConfig_Parse(node: xmlP.XmlNode): CustomOriginConfig {
  return {
    HTTPPort: node.first("HTTPPort", true, x => parseInt(x.content ?? '0')),
    HTTPSPort: node.first("HTTPSPort", true, x => parseInt(x.content ?? '0')),
    OriginProtocolPolicy: node.first("OriginProtocolPolicy", true, x => (x.content ?? '') as OriginProtocolPolicy),
    OriginSslProtocols: node.first("OriginSslProtocols", false, OriginSslProtocols_Parse),
    OriginReadTimeout: node.first("OriginReadTimeout", false, x => parseInt(x.content ?? '0')),
    OriginKeepaliveTimeout: node.first("OriginKeepaliveTimeout", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 11 - tags: input, named, enum, output
export type OriginProtocolPolicy =
| "http-only"
| "match-viewer"
| "https-only"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface OriginSslProtocols {
  Quantity: number;
  Items: SslProtocol[];
}
function OriginSslProtocols_Serialize(data: OriginSslProtocols | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "SslProtocol", content: x}))},
  ]};
}
function OriginSslProtocols_Parse(node: xmlP.XmlNode): OriginSslProtocols {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "SslProtocol").map(x => (x.content ?? '') as SslProtocol),
  };
}

// refs: 11 - tags: input, named, enum, output
export type SslProtocol =
| "SSLv3"
| "TLSv1"
| "TLSv1.1"
| "TLSv1.2"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface OriginShield {
  Enabled: boolean;
  OriginShieldRegion?: string | null;
}
function OriginShield_Serialize(data: OriginShield | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "OriginShieldRegion", content: data["OriginShieldRegion"]?.toString()},
  ]};
}
function OriginShield_Parse(node: xmlP.XmlNode): OriginShield {
  return {
    ...node.strings({
      optional: {"OriginShieldRegion":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginGroups {
  Quantity: number;
  Items: OriginGroup[];
}
function OriginGroups_Serialize(data: OriginGroups | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginGroup", ...OriginGroup_Serialize(x)}))},
  ]};
}
function OriginGroups_Parse(node: xmlP.XmlNode): OriginGroups {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginGroup").map(OriginGroup_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginGroup {
  Id: string;
  FailoverCriteria: OriginGroupFailoverCriteria;
  Members: OriginGroupMembers;
}
function OriginGroup_Serialize(data: OriginGroup | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "FailoverCriteria", ...OriginGroupFailoverCriteria_Serialize(data["FailoverCriteria"])},
    {name: "Members", ...OriginGroupMembers_Serialize(data["Members"])},
  ]};
}
function OriginGroup_Parse(node: xmlP.XmlNode): OriginGroup {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    FailoverCriteria: node.first("FailoverCriteria", true, OriginGroupFailoverCriteria_Parse),
    Members: node.first("Members", true, OriginGroupMembers_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginGroupFailoverCriteria {
  StatusCodes: StatusCodes;
}
function OriginGroupFailoverCriteria_Serialize(data: OriginGroupFailoverCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StatusCodes", ...StatusCodes_Serialize(data["StatusCodes"])},
  ]};
}
function OriginGroupFailoverCriteria_Parse(node: xmlP.XmlNode): OriginGroupFailoverCriteria {
  return {
    StatusCodes: node.first("StatusCodes", true, StatusCodes_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface StatusCodes {
  Quantity: number;
  Items: number[];
}
function StatusCodes_Serialize(data: StatusCodes | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "StatusCode", content: x.toString()}))},
  ]};
}
function StatusCodes_Parse(node: xmlP.XmlNode): StatusCodes {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StatusCode").map(x => parseInt(x.content ?? '0')),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginGroupMembers {
  Quantity: number;
  Items: OriginGroupMember[];
}
function OriginGroupMembers_Serialize(data: OriginGroupMembers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginGroupMember", ...OriginGroupMember_Serialize(x)}))},
  ]};
}
function OriginGroupMembers_Parse(node: xmlP.XmlNode): OriginGroupMembers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginGroupMember").map(OriginGroupMember_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface OriginGroupMember {
  OriginId: string;
}
function OriginGroupMember_Serialize(data: OriginGroupMember | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginId", content: data["OriginId"]?.toString()},
  ]};
}
function OriginGroupMember_Parse(node: xmlP.XmlNode): OriginGroupMember {
  return node.strings({
    required: {"OriginId":true},
  });
}

// refs: 11 - tags: input, named, interface, output
export interface DefaultCacheBehavior {
  TargetOriginId: string;
  TrustedSigners?: TrustedSigners | null;
  TrustedKeyGroups?: TrustedKeyGroups | null;
  ViewerProtocolPolicy: ViewerProtocolPolicy;
  AllowedMethods?: AllowedMethods | null;
  SmoothStreaming?: boolean | null;
  Compress?: boolean | null;
  LambdaFunctionAssociations?: LambdaFunctionAssociations | null;
  FieldLevelEncryptionId?: string | null;
  RealtimeLogConfigArn?: string | null;
  CachePolicyId?: string | null;
  OriginRequestPolicyId?: string | null;
  ForwardedValues?: ForwardedValues | null;
  MinTTL?: number | null;
  DefaultTTL?: number | null;
  MaxTTL?: number | null;
}
function DefaultCacheBehavior_Serialize(data: DefaultCacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "TrustedKeyGroups", ...TrustedKeyGroups_Serialize(data["TrustedKeyGroups"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
    {name: "FieldLevelEncryptionId", content: data["FieldLevelEncryptionId"]?.toString()},
    {name: "RealtimeLogConfigArn", content: data["RealtimeLogConfigArn"]?.toString()},
    {name: "CachePolicyId", content: data["CachePolicyId"]?.toString()},
    {name: "OriginRequestPolicyId", content: data["OriginRequestPolicyId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
  ]};
}
function DefaultCacheBehavior_Parse(node: xmlP.XmlNode): DefaultCacheBehavior {
  return {
    ...node.strings({
      required: {"TargetOriginId":true},
      optional: {"FieldLevelEncryptionId":true,"RealtimeLogConfigArn":true,"CachePolicyId":true,"OriginRequestPolicyId":true},
    }),
    TrustedSigners: node.first("TrustedSigners", false, TrustedSigners_Parse),
    TrustedKeyGroups: node.first("TrustedKeyGroups", false, TrustedKeyGroups_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as ViewerProtocolPolicy),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
    ForwardedValues: node.first("ForwardedValues", false, ForwardedValues_Parse),
    MinTTL: node.first("MinTTL", false, x => parseInt(x.content ?? '0')),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 31 - tags: input, named, interface, output
export interface TrustedSigners {
  Enabled: boolean;
  Quantity: number;
  Items: string[];
}
function TrustedSigners_Serialize(data: TrustedSigners | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "AwsAccountNumber", content: x}))},
  ]};
}
function TrustedSigners_Parse(node: xmlP.XmlNode): TrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "AwsAccountNumber").map(x => x.content ?? ''),
  };
}

// refs: 22 - tags: input, named, interface, output
export interface TrustedKeyGroups {
  Enabled: boolean;
  Quantity: number;
  Items: string[];
}
function TrustedKeyGroups_Serialize(data: TrustedKeyGroups | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "KeyGroup", content: x}))},
  ]};
}
function TrustedKeyGroups_Parse(node: xmlP.XmlNode): TrustedKeyGroups {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroup").map(x => x.content ?? ''),
  };
}

// refs: 22 - tags: input, named, enum, output
export type ViewerProtocolPolicy =
| "allow-all"
| "https-only"
| "redirect-to-https"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, interface, output
export interface AllowedMethods {
  Quantity: number;
  Items: Method[];
  CachedMethods?: CachedMethods | null;
}
function AllowedMethods_Serialize(data: AllowedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
    {name: "CachedMethods", ...CachedMethods_Serialize(data["CachedMethods"])},
  ]};
}
function AllowedMethods_Parse(node: xmlP.XmlNode): AllowedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as Method),
    CachedMethods: node.first("CachedMethods", false, CachedMethods_Parse),
  };
}

// refs: 44 - tags: input, named, enum, output
export type Method =
| "GET"
| "HEAD"
| "POST"
| "PUT"
| "PATCH"
| "OPTIONS"
| "DELETE"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, interface, output
export interface CachedMethods {
  Quantity: number;
  Items: Method[];
}
function CachedMethods_Serialize(data: CachedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
  ]};
}
function CachedMethods_Parse(node: xmlP.XmlNode): CachedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as Method),
  };
}

// refs: 22 - tags: input, named, interface, output
export interface LambdaFunctionAssociations {
  Quantity: number;
  Items: LambdaFunctionAssociation[];
}
function LambdaFunctionAssociations_Serialize(data: LambdaFunctionAssociations | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "LambdaFunctionAssociation", ...LambdaFunctionAssociation_Serialize(x)}))},
  ]};
}
function LambdaFunctionAssociations_Parse(node: xmlP.XmlNode): LambdaFunctionAssociations {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "LambdaFunctionAssociation").map(LambdaFunctionAssociation_Parse),
  };
}

// refs: 22 - tags: input, named, interface, output
export interface LambdaFunctionAssociation {
  LambdaFunctionARN: string;
  EventType: EventType;
  IncludeBody?: boolean | null;
}
function LambdaFunctionAssociation_Serialize(data: LambdaFunctionAssociation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaFunctionARN", content: data["LambdaFunctionARN"]?.toString()},
    {name: "EventType", content: data["EventType"]?.toString()},
    {name: "IncludeBody", content: data["IncludeBody"]?.toString()},
  ]};
}
function LambdaFunctionAssociation_Parse(node: xmlP.XmlNode): LambdaFunctionAssociation {
  return {
    ...node.strings({
      required: {"LambdaFunctionARN":true},
    }),
    EventType: node.first("EventType", true, x => (x.content ?? '') as EventType),
    IncludeBody: node.first("IncludeBody", false, x => x.content === 'true'),
  };
}

// refs: 22 - tags: input, named, enum, output
export type EventType =
| "viewer-request"
| "viewer-response"
| "origin-request"
| "origin-response"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, interface, output
export interface ForwardedValues {
  QueryString: boolean;
  Cookies: CookiePreference;
  Headers?: Headers | null;
  QueryStringCacheKeys?: QueryStringCacheKeys | null;
}
function ForwardedValues_Serialize(data: ForwardedValues | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryString", content: data["QueryString"]?.toString()},
    {name: "Cookies", ...CookiePreference_Serialize(data["Cookies"])},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
    {name: "QueryStringCacheKeys", ...QueryStringCacheKeys_Serialize(data["QueryStringCacheKeys"])},
  ]};
}
function ForwardedValues_Parse(node: xmlP.XmlNode): ForwardedValues {
  return {
    QueryString: node.first("QueryString", true, x => x.content === 'true'),
    Cookies: node.first("Cookies", true, CookiePreference_Parse),
    Headers: node.first("Headers", false, Headers_Parse),
    QueryStringCacheKeys: node.first("QueryStringCacheKeys", false, QueryStringCacheKeys_Parse),
  };
}

// refs: 22 - tags: input, named, interface, output
export interface CookiePreference {
  Forward: ItemSelection;
  WhitelistedNames?: CookieNames | null;
}
function CookiePreference_Serialize(data: CookiePreference | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Forward", content: data["Forward"]?.toString()},
    {name: "WhitelistedNames", ...CookieNames_Serialize(data["WhitelistedNames"])},
  ]};
}
function CookiePreference_Parse(node: xmlP.XmlNode): CookiePreference {
  return {
    Forward: node.first("Forward", true, x => (x.content ?? '') as ItemSelection),
    WhitelistedNames: node.first("WhitelistedNames", false, CookieNames_Parse),
  };
}

// refs: 22 - tags: input, named, enum, output
export type ItemSelection =
| "none"
| "whitelist"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 22 - tags: input, named, interface, output
export interface QueryStringCacheKeys {
  Quantity: number;
  Items: string[];
}
function QueryStringCacheKeys_Serialize(data: QueryStringCacheKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringCacheKeys_Parse(node: xmlP.XmlNode): QueryStringCacheKeys {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface CacheBehaviors {
  Quantity: number;
  Items: CacheBehavior[];
}
function CacheBehaviors_Serialize(data: CacheBehaviors | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CacheBehavior", ...CacheBehavior_Serialize(x)}))},
  ]};
}
function CacheBehaviors_Parse(node: xmlP.XmlNode): CacheBehaviors {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CacheBehavior").map(CacheBehavior_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface CacheBehavior {
  PathPattern: string;
  TargetOriginId: string;
  TrustedSigners?: TrustedSigners | null;
  TrustedKeyGroups?: TrustedKeyGroups | null;
  ViewerProtocolPolicy: ViewerProtocolPolicy;
  AllowedMethods?: AllowedMethods | null;
  SmoothStreaming?: boolean | null;
  Compress?: boolean | null;
  LambdaFunctionAssociations?: LambdaFunctionAssociations | null;
  FieldLevelEncryptionId?: string | null;
  RealtimeLogConfigArn?: string | null;
  CachePolicyId?: string | null;
  OriginRequestPolicyId?: string | null;
  ForwardedValues?: ForwardedValues | null;
  MinTTL?: number | null;
  DefaultTTL?: number | null;
  MaxTTL?: number | null;
}
function CacheBehavior_Serialize(data: CacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PathPattern", content: data["PathPattern"]?.toString()},
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "TrustedKeyGroups", ...TrustedKeyGroups_Serialize(data["TrustedKeyGroups"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
    {name: "FieldLevelEncryptionId", content: data["FieldLevelEncryptionId"]?.toString()},
    {name: "RealtimeLogConfigArn", content: data["RealtimeLogConfigArn"]?.toString()},
    {name: "CachePolicyId", content: data["CachePolicyId"]?.toString()},
    {name: "OriginRequestPolicyId", content: data["OriginRequestPolicyId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
  ]};
}
function CacheBehavior_Parse(node: xmlP.XmlNode): CacheBehavior {
  return {
    ...node.strings({
      required: {"PathPattern":true,"TargetOriginId":true},
      optional: {"FieldLevelEncryptionId":true,"RealtimeLogConfigArn":true,"CachePolicyId":true,"OriginRequestPolicyId":true},
    }),
    TrustedSigners: node.first("TrustedSigners", false, TrustedSigners_Parse),
    TrustedKeyGroups: node.first("TrustedKeyGroups", false, TrustedKeyGroups_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as ViewerProtocolPolicy),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
    ForwardedValues: node.first("ForwardedValues", false, ForwardedValues_Parse),
    MinTTL: node.first("MinTTL", false, x => parseInt(x.content ?? '0')),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface CustomErrorResponses {
  Quantity: number;
  Items: CustomErrorResponse[];
}
function CustomErrorResponses_Serialize(data: CustomErrorResponses | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CustomErrorResponse", ...CustomErrorResponse_Serialize(x)}))},
  ]};
}
function CustomErrorResponses_Parse(node: xmlP.XmlNode): CustomErrorResponses {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CustomErrorResponse").map(CustomErrorResponse_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface CustomErrorResponse {
  ErrorCode: number;
  ResponsePagePath?: string | null;
  ResponseCode?: string | null;
  ErrorCachingMinTTL?: number | null;
}
function CustomErrorResponse_Serialize(data: CustomErrorResponse | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorCode", content: data["ErrorCode"]?.toString()},
    {name: "ResponsePagePath", content: data["ResponsePagePath"]?.toString()},
    {name: "ResponseCode", content: data["ResponseCode"]?.toString()},
    {name: "ErrorCachingMinTTL", content: data["ErrorCachingMinTTL"]?.toString()},
  ]};
}
function CustomErrorResponse_Parse(node: xmlP.XmlNode): CustomErrorResponse {
  return {
    ...node.strings({
      optional: {"ResponsePagePath":true,"ResponseCode":true},
    }),
    ErrorCode: node.first("ErrorCode", true, x => parseInt(x.content ?? '0')),
    ErrorCachingMinTTL: node.first("ErrorCachingMinTTL", false, x => parseInt(x.content ?? '0')),
  };
}

// refs: 8 - tags: input, named, interface, output
export interface LoggingConfig {
  Enabled: boolean;
  IncludeCookies: boolean;
  Bucket: string;
  Prefix: string;
}
function LoggingConfig_Serialize(data: LoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "IncludeCookies", content: data["IncludeCookies"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function LoggingConfig_Parse(node: xmlP.XmlNode): LoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    IncludeCookies: node.first("IncludeCookies", true, x => x.content === 'true'),
  };
}

// refs: 20 - tags: input, named, enum, output
export type PriceClass =
| "PriceClass_100"
| "PriceClass_200"
| "PriceClass_All"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface ViewerCertificate {
  CloudFrontDefaultCertificate?: boolean | null;
  IAMCertificateId?: string | null;
  ACMCertificateArn?: string | null;
  SSLSupportMethod?: SSLSupportMethod | null;
  MinimumProtocolVersion?: MinimumProtocolVersion | null;
  Certificate?: string | null;
  CertificateSource?: CertificateSource | null;
}
function ViewerCertificate_Serialize(data: ViewerCertificate | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CloudFrontDefaultCertificate", content: data["CloudFrontDefaultCertificate"]?.toString()},
    {name: "IAMCertificateId", content: data["IAMCertificateId"]?.toString()},
    {name: "ACMCertificateArn", content: data["ACMCertificateArn"]?.toString()},
    {name: "SSLSupportMethod", content: data["SSLSupportMethod"]?.toString()},
    {name: "MinimumProtocolVersion", content: data["MinimumProtocolVersion"]?.toString()},
    {name: "Certificate", content: data["Certificate"]?.toString()},
    {name: "CertificateSource", content: data["CertificateSource"]?.toString()},
  ]};
}
function ViewerCertificate_Parse(node: xmlP.XmlNode): ViewerCertificate {
  return {
    ...node.strings({
      optional: {"IAMCertificateId":true,"ACMCertificateArn":true,"Certificate":true},
    }),
    CloudFrontDefaultCertificate: node.first("CloudFrontDefaultCertificate", false, x => x.content === 'true'),
    SSLSupportMethod: node.first("SSLSupportMethod", false, x => (x.content ?? '') as SSLSupportMethod),
    MinimumProtocolVersion: node.first("MinimumProtocolVersion", false, x => (x.content ?? '') as MinimumProtocolVersion),
    CertificateSource: node.first("CertificateSource", false, x => (x.content ?? '') as CertificateSource),
  };
}

// refs: 11 - tags: input, named, enum, output
export type SSLSupportMethod =
| "sni-only"
| "vip"
| "static-ip"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type MinimumProtocolVersion =
| "SSLv3"
| "TLSv1"
| "TLSv1_2016"
| "TLSv1.1_2016"
| "TLSv1.2_2018"
| "TLSv1.2_2019"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type CertificateSource =
| "cloudfront"
| "iam"
| "acm"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, interface, output
export interface Restrictions {
  GeoRestriction: GeoRestriction;
}
function Restrictions_Serialize(data: Restrictions | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "GeoRestriction", ...GeoRestriction_Serialize(data["GeoRestriction"])},
  ]};
}
function Restrictions_Parse(node: xmlP.XmlNode): Restrictions {
  return {
    GeoRestriction: node.first("GeoRestriction", true, GeoRestriction_Parse),
  };
}

// refs: 11 - tags: input, named, interface, output
export interface GeoRestriction {
  RestrictionType: GeoRestrictionType;
  Quantity: number;
  Items: string[];
}
function GeoRestriction_Serialize(data: GeoRestriction | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RestrictionType", content: data["RestrictionType"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Location", content: x}))},
  ]};
}
function GeoRestriction_Parse(node: xmlP.XmlNode): GeoRestriction {
  return {
    RestrictionType: node.first("RestrictionType", true, x => (x.content ?? '') as GeoRestrictionType),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Location").map(x => x.content ?? ''),
  };
}

// refs: 11 - tags: input, named, enum, output
export type GeoRestrictionType =
| "blacklist"
| "whitelist"
| "none"
| cmnP.UnexpectedEnumValue;

// refs: 11 - tags: input, named, enum, output
export type HttpVersion =
| "http1.1"
| "http2"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface DistributionConfigWithTags {
  DistributionConfig: DistributionConfig;
  Tags: Tags;
}
function DistributionConfigWithTags_Serialize(data: DistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DistributionConfig", ...DistributionConfig_Serialize(data["DistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

// refs: 4 - tags: input, named, interface, output
export interface Tags {
  Items: Tag[];
}
function Tags_Serialize(data: Tags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}
function Tags_Parse(node: xmlP.XmlNode): Tags {
  return {
    Items: node.getList("Items", "Tag").map(Tag_Parse),
  };
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value?: string | null;
}
function Tag_Serialize(data: Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

// refs: 6 - tags: input, named, interface, output
export interface FieldLevelEncryptionConfig {
  CallerReference: string;
  Comment?: string | null;
  QueryArgProfileConfig?: QueryArgProfileConfig | null;
  ContentTypeProfileConfig?: ContentTypeProfileConfig | null;
}
function FieldLevelEncryptionConfig_Serialize(data: FieldLevelEncryptionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(data["QueryArgProfileConfig"])},
    {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(data["ContentTypeProfileConfig"])},
  ]};
}
function FieldLevelEncryptionConfig_Parse(node: xmlP.XmlNode): FieldLevelEncryptionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true},
      optional: {"Comment":true},
    }),
    QueryArgProfileConfig: node.first("QueryArgProfileConfig", false, QueryArgProfileConfig_Parse),
    ContentTypeProfileConfig: node.first("ContentTypeProfileConfig", false, ContentTypeProfileConfig_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface QueryArgProfileConfig {
  ForwardWhenQueryArgProfileIsUnknown: boolean;
  QueryArgProfiles?: QueryArgProfiles | null;
}
function QueryArgProfileConfig_Serialize(data: QueryArgProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ForwardWhenQueryArgProfileIsUnknown", content: data["ForwardWhenQueryArgProfileIsUnknown"]?.toString()},
    {name: "QueryArgProfiles", ...QueryArgProfiles_Serialize(data["QueryArgProfiles"])},
  ]};
}
function QueryArgProfileConfig_Parse(node: xmlP.XmlNode): QueryArgProfileConfig {
  return {
    ForwardWhenQueryArgProfileIsUnknown: node.first("ForwardWhenQueryArgProfileIsUnknown", true, x => x.content === 'true'),
    QueryArgProfiles: node.first("QueryArgProfiles", false, QueryArgProfiles_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface QueryArgProfiles {
  Quantity: number;
  Items: QueryArgProfile[];
}
function QueryArgProfiles_Serialize(data: QueryArgProfiles | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "QueryArgProfile", ...QueryArgProfile_Serialize(x)}))},
  ]};
}
function QueryArgProfiles_Parse(node: xmlP.XmlNode): QueryArgProfiles {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "QueryArgProfile").map(QueryArgProfile_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface QueryArgProfile {
  QueryArg: string;
  ProfileId: string;
}
function QueryArgProfile_Serialize(data: QueryArgProfile | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryArg", content: data["QueryArg"]?.toString()},
    {name: "ProfileId", content: data["ProfileId"]?.toString()},
  ]};
}
function QueryArgProfile_Parse(node: xmlP.XmlNode): QueryArgProfile {
  return node.strings({
    required: {"QueryArg":true,"ProfileId":true},
  });
}

// refs: 7 - tags: input, named, interface, output
export interface ContentTypeProfileConfig {
  ForwardWhenContentTypeIsUnknown: boolean;
  ContentTypeProfiles?: ContentTypeProfiles | null;
}
function ContentTypeProfileConfig_Serialize(data: ContentTypeProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ForwardWhenContentTypeIsUnknown", content: data["ForwardWhenContentTypeIsUnknown"]?.toString()},
    {name: "ContentTypeProfiles", ...ContentTypeProfiles_Serialize(data["ContentTypeProfiles"])},
  ]};
}
function ContentTypeProfileConfig_Parse(node: xmlP.XmlNode): ContentTypeProfileConfig {
  return {
    ForwardWhenContentTypeIsUnknown: node.first("ForwardWhenContentTypeIsUnknown", true, x => x.content === 'true'),
    ContentTypeProfiles: node.first("ContentTypeProfiles", false, ContentTypeProfiles_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface ContentTypeProfiles {
  Quantity: number;
  Items: ContentTypeProfile[];
}
function ContentTypeProfiles_Serialize(data: ContentTypeProfiles | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "ContentTypeProfile", ...ContentTypeProfile_Serialize(x)}))},
  ]};
}
function ContentTypeProfiles_Parse(node: xmlP.XmlNode): ContentTypeProfiles {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "ContentTypeProfile").map(ContentTypeProfile_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface ContentTypeProfile {
  Format: Format;
  ProfileId?: string | null;
  ContentType: string;
}
function ContentTypeProfile_Serialize(data: ContentTypeProfile | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "ProfileId", content: data["ProfileId"]?.toString()},
    {name: "ContentType", content: data["ContentType"]?.toString()},
  ]};
}
function ContentTypeProfile_Parse(node: xmlP.XmlNode): ContentTypeProfile {
  return {
    ...node.strings({
      required: {"ContentType":true},
      optional: {"ProfileId":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as Format),
  };
}

// refs: 7 - tags: input, named, enum, output
export type Format =
| "URLEncoded"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface FieldLevelEncryptionProfileConfig {
  Name: string;
  CallerReference: string;
  Comment?: string | null;
  EncryptionEntities: EncryptionEntities;
}
function FieldLevelEncryptionProfileConfig_Serialize(data: FieldLevelEncryptionProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "EncryptionEntities", ...EncryptionEntities_Serialize(data["EncryptionEntities"])},
  ]};
}
function FieldLevelEncryptionProfileConfig_Parse(node: xmlP.XmlNode): FieldLevelEncryptionProfileConfig {
  return {
    ...node.strings({
      required: {"Name":true,"CallerReference":true},
      optional: {"Comment":true},
    }),
    EncryptionEntities: node.first("EncryptionEntities", true, EncryptionEntities_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface EncryptionEntities {
  Quantity: number;
  Items: EncryptionEntity[];
}
function EncryptionEntities_Serialize(data: EncryptionEntities | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "EncryptionEntity", ...EncryptionEntity_Serialize(x)}))},
  ]};
}
function EncryptionEntities_Parse(node: xmlP.XmlNode): EncryptionEntities {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "EncryptionEntity").map(EncryptionEntity_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface EncryptionEntity {
  PublicKeyId: string;
  ProviderId: string;
  FieldPatterns: FieldPatterns;
}
function EncryptionEntity_Serialize(data: EncryptionEntity | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PublicKeyId", content: data["PublicKeyId"]?.toString()},
    {name: "ProviderId", content: data["ProviderId"]?.toString()},
    {name: "FieldPatterns", ...FieldPatterns_Serialize(data["FieldPatterns"])},
  ]};
}
function EncryptionEntity_Parse(node: xmlP.XmlNode): EncryptionEntity {
  return {
    ...node.strings({
      required: {"PublicKeyId":true,"ProviderId":true},
    }),
    FieldPatterns: node.first("FieldPatterns", true, FieldPatterns_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface FieldPatterns {
  Quantity: number;
  Items: string[];
}
function FieldPatterns_Serialize(data: FieldPatterns | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "FieldPattern", content: x}))},
  ]};
}
function FieldPatterns_Parse(node: xmlP.XmlNode): FieldPatterns {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldPattern").map(x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface InvalidationBatch {
  Paths: Paths;
  CallerReference: string;
}
function InvalidationBatch_Serialize(data: InvalidationBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Paths", ...Paths_Serialize(data["Paths"])},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
  ]};
}
function InvalidationBatch_Parse(node: xmlP.XmlNode): InvalidationBatch {
  return {
    ...node.strings({
      required: {"CallerReference":true},
    }),
    Paths: node.first("Paths", true, Paths_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface Paths {
  Quantity: number;
  Items: string[];
}
function Paths_Serialize(data: Paths | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Path", content: x}))},
  ]};
}
function Paths_Parse(node: xmlP.XmlNode): Paths {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Path").map(x => x.content ?? ''),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface KeyGroupConfig {
  Name: string;
  Items: string[];
  Comment?: string | null;
}
function KeyGroupConfig_Serialize(data: KeyGroupConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "PublicKey", content: x}))},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function KeyGroupConfig_Parse(node: xmlP.XmlNode): KeyGroupConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    Items: node.getList("Items", "PublicKey").map(x => x.content ?? ''),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface MonitoringSubscription {
  RealtimeMetricsSubscriptionConfig?: RealtimeMetricsSubscriptionConfig | null;
}
function MonitoringSubscription_Serialize(data: MonitoringSubscription | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RealtimeMetricsSubscriptionConfig", ...RealtimeMetricsSubscriptionConfig_Serialize(data["RealtimeMetricsSubscriptionConfig"])},
  ]};
}
function MonitoringSubscription_Parse(node: xmlP.XmlNode): MonitoringSubscription {
  return {
    RealtimeMetricsSubscriptionConfig: node.first("RealtimeMetricsSubscriptionConfig", false, RealtimeMetricsSubscriptionConfig_Parse),
  };
}

// refs: 3 - tags: input, named, interface, output
export interface RealtimeMetricsSubscriptionConfig {
  RealtimeMetricsSubscriptionStatus: RealtimeMetricsSubscriptionStatus;
}
function RealtimeMetricsSubscriptionConfig_Serialize(data: RealtimeMetricsSubscriptionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RealtimeMetricsSubscriptionStatus", content: data["RealtimeMetricsSubscriptionStatus"]?.toString()},
  ]};
}
function RealtimeMetricsSubscriptionConfig_Parse(node: xmlP.XmlNode): RealtimeMetricsSubscriptionConfig {
  return {
    RealtimeMetricsSubscriptionStatus: node.first("RealtimeMetricsSubscriptionStatus", true, x => (x.content ?? '') as RealtimeMetricsSubscriptionStatus),
  };
}

// refs: 3 - tags: input, named, enum, output
export type RealtimeMetricsSubscriptionStatus =
| "Enabled"
| "Disabled"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface OriginRequestPolicyConfig {
  Comment?: string | null;
  Name: string;
  HeadersConfig: OriginRequestPolicyHeadersConfig;
  CookiesConfig: OriginRequestPolicyCookiesConfig;
  QueryStringsConfig: OriginRequestPolicyQueryStringsConfig;
}
function OriginRequestPolicyConfig_Serialize(data: OriginRequestPolicyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(data["HeadersConfig"])},
    {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(data["CookiesConfig"])},
    {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(data["QueryStringsConfig"])},
  ]};
}
function OriginRequestPolicyConfig_Parse(node: xmlP.XmlNode): OriginRequestPolicyConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    HeadersConfig: node.first("HeadersConfig", true, OriginRequestPolicyHeadersConfig_Parse),
    CookiesConfig: node.first("CookiesConfig", true, OriginRequestPolicyCookiesConfig_Parse),
    QueryStringsConfig: node.first("QueryStringsConfig", true, OriginRequestPolicyQueryStringsConfig_Parse),
  };
}

// refs: 7 - tags: input, named, interface, output
export interface OriginRequestPolicyHeadersConfig {
  HeaderBehavior: OriginRequestPolicyHeaderBehavior;
  Headers?: Headers | null;
}
function OriginRequestPolicyHeadersConfig_Serialize(data: OriginRequestPolicyHeadersConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderBehavior", content: data["HeaderBehavior"]?.toString()},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
  ]};
}
function OriginRequestPolicyHeadersConfig_Parse(node: xmlP.XmlNode): OriginRequestPolicyHeadersConfig {
  return {
    HeaderBehavior: node.first("HeaderBehavior", true, x => (x.content ?? '') as OriginRequestPolicyHeaderBehavior),
    Headers: node.first("Headers", false, Headers_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type OriginRequestPolicyHeaderBehavior =
| "none"
| "whitelist"
| "allViewer"
| "allViewerAndWhitelistCloudFront"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface OriginRequestPolicyCookiesConfig {
  CookieBehavior: OriginRequestPolicyCookieBehavior;
  Cookies?: CookieNames | null;
}
function OriginRequestPolicyCookiesConfig_Serialize(data: OriginRequestPolicyCookiesConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CookieBehavior", content: data["CookieBehavior"]?.toString()},
    {name: "Cookies", ...CookieNames_Serialize(data["Cookies"])},
  ]};
}
function OriginRequestPolicyCookiesConfig_Parse(node: xmlP.XmlNode): OriginRequestPolicyCookiesConfig {
  return {
    CookieBehavior: node.first("CookieBehavior", true, x => (x.content ?? '') as OriginRequestPolicyCookieBehavior),
    Cookies: node.first("Cookies", false, CookieNames_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type OriginRequestPolicyCookieBehavior =
| "none"
| "whitelist"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 7 - tags: input, named, interface, output
export interface OriginRequestPolicyQueryStringsConfig {
  QueryStringBehavior: OriginRequestPolicyQueryStringBehavior;
  QueryStrings?: QueryStringNames | null;
}
function OriginRequestPolicyQueryStringsConfig_Serialize(data: OriginRequestPolicyQueryStringsConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryStringBehavior", content: data["QueryStringBehavior"]?.toString()},
    {name: "QueryStrings", ...QueryStringNames_Serialize(data["QueryStrings"])},
  ]};
}
function OriginRequestPolicyQueryStringsConfig_Parse(node: xmlP.XmlNode): OriginRequestPolicyQueryStringsConfig {
  return {
    QueryStringBehavior: node.first("QueryStringBehavior", true, x => (x.content ?? '') as OriginRequestPolicyQueryStringBehavior),
    QueryStrings: node.first("QueryStrings", false, QueryStringNames_Parse),
  };
}

// refs: 7 - tags: input, named, enum, output
export type OriginRequestPolicyQueryStringBehavior =
| "none"
| "whitelist"
| "all"
| cmnP.UnexpectedEnumValue;

// refs: 6 - tags: input, named, interface, output
export interface PublicKeyConfig {
  CallerReference: string;
  Name: string;
  EncodedKey: string;
  Comment?: string | null;
}
function PublicKeyConfig_Serialize(data: PublicKeyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "EncodedKey", content: data["EncodedKey"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function PublicKeyConfig_Parse(node: xmlP.XmlNode): PublicKeyConfig {
  return node.strings({
    required: {"CallerReference":true,"Name":true,"EncodedKey":true},
    optional: {"Comment":true},
  });
}

// refs: 6 - tags: input, named, interface, output
export interface EndPoint {
  StreamType: string;
  KinesisStreamConfig?: KinesisStreamConfig | null;
}
function EndPoint_Serialize(data: EndPoint | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamType", content: data["StreamType"]?.toString()},
    {name: "KinesisStreamConfig", ...KinesisStreamConfig_Serialize(data["KinesisStreamConfig"])},
  ]};
}
function EndPoint_Parse(node: xmlP.XmlNode): EndPoint {
  return {
    ...node.strings({
      required: {"StreamType":true},
    }),
    KinesisStreamConfig: node.first("KinesisStreamConfig", false, KinesisStreamConfig_Parse),
  };
}

// refs: 6 - tags: input, named, interface, output
export interface KinesisStreamConfig {
  RoleARN: string;
  StreamARN: string;
}
function KinesisStreamConfig_Serialize(data: KinesisStreamConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RoleARN", content: data["RoleARN"]?.toString()},
    {name: "StreamARN", content: data["StreamARN"]?.toString()},
  ]};
}
function KinesisStreamConfig_Parse(node: xmlP.XmlNode): KinesisStreamConfig {
  return node.strings({
    required: {"RoleARN":true,"StreamARN":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface StreamingDistributionConfig {
  CallerReference: string;
  S3Origin: S3Origin;
  Aliases?: Aliases | null;
  Comment: string;
  Logging?: StreamingLoggingConfig | null;
  TrustedSigners: TrustedSigners;
  PriceClass?: PriceClass | null;
  Enabled: boolean;
}
function StreamingDistributionConfig_Serialize(data: StreamingDistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "S3Origin", ...S3Origin_Serialize(data["S3Origin"])},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...StreamingLoggingConfig_Serialize(data["Logging"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}
function StreamingDistributionConfig_Parse(node: xmlP.XmlNode): StreamingDistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
    }),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Logging: node.first("Logging", false, StreamingLoggingConfig_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 9 - tags: input, named, interface, output
export interface S3Origin {
  DomainName: string;
  OriginAccessIdentity: string;
}
function S3Origin_Serialize(data: S3Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3Origin_Parse(node: xmlP.XmlNode): S3Origin {
  return node.strings({
    required: {"DomainName":true,"OriginAccessIdentity":true},
  });
}

// refs: 8 - tags: input, named, interface, output
export interface StreamingLoggingConfig {
  Enabled: boolean;
  Bucket: string;
  Prefix: string;
}
function StreamingLoggingConfig_Serialize(data: StreamingLoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function StreamingLoggingConfig_Parse(node: xmlP.XmlNode): StreamingLoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: input, named, interface
export interface StreamingDistributionConfigWithTags {
  StreamingDistributionConfig: StreamingDistributionConfig;
  Tags: Tags;
}
function StreamingDistributionConfigWithTags_Serialize(data: StreamingDistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(data["StreamingDistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

// refs: 2 - tags: input, named, enum, output
export type CachePolicyType =
| "managed"
| "custom"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum, output
export type OriginRequestPolicyType =
| "managed"
| "custom"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: input, named, interface
export interface TagKeys {
  Items?: string[] | null;
}
function TagKeys_Serialize(data: TagKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Key", content: x}))},
  ]};
}

// refs: 4 - tags: output, named, interface
export interface CachePolicy {
  Id: string;
  LastModifiedTime: Date | number;
  CachePolicyConfig: CachePolicyConfig;
}
function CachePolicy_Parse(node: xmlP.XmlNode): CachePolicy {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    CachePolicyConfig: node.first("CachePolicyConfig", true, CachePolicyConfig_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentity {
  Id: string;
  S3CanonicalUserId: string;
  CloudFrontOriginAccessIdentityConfig?: CloudFrontOriginAccessIdentityConfig | null;
}
function CloudFrontOriginAccessIdentity_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentity {
  return {
    ...node.strings({
      required: {"Id":true,"S3CanonicalUserId":true},
    }),
    CloudFrontOriginAccessIdentityConfig: node.first("CloudFrontOriginAccessIdentityConfig", false, CloudFrontOriginAccessIdentityConfig_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface Distribution {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  InProgressInvalidationBatches: number;
  DomainName: string;
  ActiveTrustedSigners?: ActiveTrustedSigners | null;
  ActiveTrustedKeyGroups?: ActiveTrustedKeyGroups | null;
  DistributionConfig: DistributionConfig;
  AliasICPRecordals: AliasICPRecordal[];
}
function Distribution_Parse(node: xmlP.XmlNode): Distribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    InProgressInvalidationBatches: node.first("InProgressInvalidationBatches", true, x => parseInt(x.content ?? '0')),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", false, ActiveTrustedSigners_Parse),
    ActiveTrustedKeyGroups: node.first("ActiveTrustedKeyGroups", false, ActiveTrustedKeyGroups_Parse),
    DistributionConfig: node.first("DistributionConfig", true, DistributionConfig_Parse),
    AliasICPRecordals: node.getList("AliasICPRecordals", "AliasICPRecordal").map(AliasICPRecordal_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface ActiveTrustedSigners {
  Enabled: boolean;
  Quantity: number;
  Items: Signer[];
}
function ActiveTrustedSigners_Parse(node: xmlP.XmlNode): ActiveTrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Signer").map(Signer_Parse),
  };
}

// refs: 8 - tags: output, named, interface
export interface Signer {
  AwsAccountNumber?: string | null;
  KeyPairIds?: KeyPairIds | null;
}
function Signer_Parse(node: xmlP.XmlNode): Signer {
  return {
    ...node.strings({
      optional: {"AwsAccountNumber":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

// refs: 12 - tags: output, named, interface
export interface KeyPairIds {
  Quantity: number;
  Items: string[];
}
function KeyPairIds_Parse(node: xmlP.XmlNode): KeyPairIds {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyPairId").map(x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface ActiveTrustedKeyGroups {
  Enabled: boolean;
  Quantity: number;
  Items: KGKeyPairIds[];
}
function ActiveTrustedKeyGroups_Parse(node: xmlP.XmlNode): ActiveTrustedKeyGroups {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroup").map(KGKeyPairIds_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface KGKeyPairIds {
  KeyGroupId?: string | null;
  KeyPairIds?: KeyPairIds | null;
}
function KGKeyPairIds_Parse(node: xmlP.XmlNode): KGKeyPairIds {
  return {
    ...node.strings({
      optional: {"KeyGroupId":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

// refs: 7 - tags: output, named, interface
export interface AliasICPRecordal {
  CNAME?: string | null;
  ICPRecordalStatus?: ICPRecordalStatus | null;
}
function AliasICPRecordal_Parse(node: xmlP.XmlNode): AliasICPRecordal {
  return {
    ...node.strings({
      optional: {"CNAME":true},
    }),
    ICPRecordalStatus: node.first("ICPRecordalStatus", false, x => (x.content ?? '') as ICPRecordalStatus),
  };
}

// refs: 7 - tags: output, named, enum
export type ICPRecordalStatus =
| "APPROVED"
| "SUSPENDED"
| "PENDING"
| cmnP.UnexpectedEnumValue;

// refs: 3 - tags: output, named, interface
export interface FieldLevelEncryption {
  Id: string;
  LastModifiedTime: Date | number;
  FieldLevelEncryptionConfig: FieldLevelEncryptionConfig;
}
function FieldLevelEncryption_Parse(node: xmlP.XmlNode): FieldLevelEncryption {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    FieldLevelEncryptionConfig: node.first("FieldLevelEncryptionConfig", true, FieldLevelEncryptionConfig_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface FieldLevelEncryptionProfile {
  Id: string;
  LastModifiedTime: Date | number;
  FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig;
}
function FieldLevelEncryptionProfile_Parse(node: xmlP.XmlNode): FieldLevelEncryptionProfile {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    FieldLevelEncryptionProfileConfig: node.first("FieldLevelEncryptionProfileConfig", true, FieldLevelEncryptionProfileConfig_Parse),
  };
}

// refs: 2 - tags: output, named, interface
export interface Invalidation {
  Id: string;
  Status: string;
  CreateTime: Date | number;
  InvalidationBatch: InvalidationBatch;
}
function Invalidation_Parse(node: xmlP.XmlNode): Invalidation {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
    InvalidationBatch: node.first("InvalidationBatch", true, InvalidationBatch_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface KeyGroup {
  Id: string;
  LastModifiedTime: Date | number;
  KeyGroupConfig: KeyGroupConfig;
}
function KeyGroup_Parse(node: xmlP.XmlNode): KeyGroup {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    KeyGroupConfig: node.first("KeyGroupConfig", true, KeyGroupConfig_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface OriginRequestPolicy {
  Id: string;
  LastModifiedTime: Date | number;
  OriginRequestPolicyConfig: OriginRequestPolicyConfig;
}
function OriginRequestPolicy_Parse(node: xmlP.XmlNode): OriginRequestPolicy {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    OriginRequestPolicyConfig: node.first("OriginRequestPolicyConfig", true, OriginRequestPolicyConfig_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface PublicKey {
  Id: string;
  CreatedTime: Date | number;
  PublicKeyConfig: PublicKeyConfig;
}
function PublicKey_Parse(node: xmlP.XmlNode): PublicKey {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    PublicKeyConfig: node.first("PublicKeyConfig", true, PublicKeyConfig_Parse),
  };
}

// refs: 4 - tags: output, named, interface
export interface RealtimeLogConfig {
  ARN: string;
  Name: string;
  SamplingRate: number;
  EndPoints: EndPoint[];
  Fields: string[];
}
function RealtimeLogConfig_Parse(node: xmlP.XmlNode): RealtimeLogConfig {
  return {
    ...node.strings({
      required: {"ARN":true,"Name":true},
    }),
    SamplingRate: node.first("SamplingRate", true, x => parseInt(x.content ?? '0')),
    EndPoints: node.getList("EndPoints", "member").map(EndPoint_Parse),
    Fields: node.getList("Fields", "Field").map(x => x.content ?? ''),
  };
}

// refs: 4 - tags: output, named, interface
export interface StreamingDistribution {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime?: Date | number | null;
  DomainName: string;
  ActiveTrustedSigners: ActiveTrustedSigners;
  StreamingDistributionConfig: StreamingDistributionConfig;
}
function StreamingDistribution_Parse(node: xmlP.XmlNode): StreamingDistribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", false, x => xmlP.parseTimestamp(x.content)),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    StreamingDistributionConfig: node.first("StreamingDistributionConfig", true, StreamingDistributionConfig_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CachePolicyList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: CachePolicySummary[];
}
function CachePolicyList_Parse(node: xmlP.XmlNode): CachePolicyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CachePolicySummary").map(CachePolicySummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CachePolicySummary {
  Type: CachePolicyType;
  CachePolicy: CachePolicy;
}
function CachePolicySummary_Parse(node: xmlP.XmlNode): CachePolicySummary {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as CachePolicyType),
    CachePolicy: node.first("CachePolicy", true, CachePolicy_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentityList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: CloudFrontOriginAccessIdentitySummary[];
}
function CloudFrontOriginAccessIdentityList_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentityList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface CloudFrontOriginAccessIdentitySummary {
  Id: string;
  S3CanonicalUserId: string;
  Comment: string;
}
function CloudFrontOriginAccessIdentitySummary_Parse(node: xmlP.XmlNode): CloudFrontOriginAccessIdentitySummary {
  return node.strings({
    required: {"Id":true,"S3CanonicalUserId":true,"Comment":true},
  });
}

// refs: 3 - tags: output, named, interface
export interface DistributionList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: DistributionSummary[];
}
function DistributionList_Parse(node: xmlP.XmlNode): DistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionSummary").map(DistributionSummary_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface DistributionSummary {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  DomainName: string;
  Aliases: Aliases;
  Origins: Origins;
  OriginGroups?: OriginGroups | null;
  DefaultCacheBehavior: DefaultCacheBehavior;
  CacheBehaviors: CacheBehaviors;
  CustomErrorResponses: CustomErrorResponses;
  Comment: string;
  PriceClass: PriceClass;
  Enabled: boolean;
  ViewerCertificate: ViewerCertificate;
  Restrictions: Restrictions;
  WebACLId: string;
  HttpVersion: HttpVersion;
  IsIPV6Enabled: boolean;
  AliasICPRecordals: AliasICPRecordal[];
}
function DistributionSummary_Parse(node: xmlP.XmlNode): DistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true,"WebACLId":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    OriginGroups: node.first("OriginGroups", false, OriginGroups_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", true, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", true, CustomErrorResponses_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", true, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", true, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", true, x => (x.content ?? '') as HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", true, x => x.content === 'true'),
    AliasICPRecordals: node.getList("AliasICPRecordals", "AliasICPRecordal").map(AliasICPRecordal_Parse),
  };
}

// refs: 3 - tags: output, named, interface
export interface DistributionIdList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: string[];
}
function DistributionIdList_Parse(node: xmlP.XmlNode): DistributionIdList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionId").map(x => x.content ?? ''),
  };
}

// refs: 1 - tags: output, named, interface
export interface FieldLevelEncryptionList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: FieldLevelEncryptionSummary[];
}
function FieldLevelEncryptionList_Parse(node: xmlP.XmlNode): FieldLevelEncryptionList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldLevelEncryptionSummary").map(FieldLevelEncryptionSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface FieldLevelEncryptionSummary {
  Id: string;
  LastModifiedTime: Date | number;
  Comment?: string | null;
  QueryArgProfileConfig?: QueryArgProfileConfig | null;
  ContentTypeProfileConfig?: ContentTypeProfileConfig | null;
}
function FieldLevelEncryptionSummary_Parse(node: xmlP.XmlNode): FieldLevelEncryptionSummary {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    QueryArgProfileConfig: node.first("QueryArgProfileConfig", false, QueryArgProfileConfig_Parse),
    ContentTypeProfileConfig: node.first("ContentTypeProfileConfig", false, ContentTypeProfileConfig_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface FieldLevelEncryptionProfileList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: FieldLevelEncryptionProfileSummary[];
}
function FieldLevelEncryptionProfileList_Parse(node: xmlP.XmlNode): FieldLevelEncryptionProfileList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldLevelEncryptionProfileSummary").map(FieldLevelEncryptionProfileSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface FieldLevelEncryptionProfileSummary {
  Id: string;
  LastModifiedTime: Date | number;
  Name: string;
  EncryptionEntities: EncryptionEntities;
  Comment?: string | null;
}
function FieldLevelEncryptionProfileSummary_Parse(node: xmlP.XmlNode): FieldLevelEncryptionProfileSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true},
      optional: {"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    EncryptionEntities: node.first("EncryptionEntities", true, EncryptionEntities_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface InvalidationList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: InvalidationSummary[];
}
function InvalidationList_Parse(node: xmlP.XmlNode): InvalidationList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface InvalidationSummary {
  Id: string;
  CreateTime: Date | number;
  Status: string;
}
function InvalidationSummary_Parse(node: xmlP.XmlNode): InvalidationSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface KeyGroupList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: KeyGroupSummary[];
}
function KeyGroupList_Parse(node: xmlP.XmlNode): KeyGroupList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroupSummary").map(KeyGroupSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface KeyGroupSummary {
  KeyGroup: KeyGroup;
}
function KeyGroupSummary_Parse(node: xmlP.XmlNode): KeyGroupSummary {
  return {
    KeyGroup: node.first("KeyGroup", true, KeyGroup_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface OriginRequestPolicyList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: OriginRequestPolicySummary[];
}
function OriginRequestPolicyList_Parse(node: xmlP.XmlNode): OriginRequestPolicyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginRequestPolicySummary").map(OriginRequestPolicySummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface OriginRequestPolicySummary {
  Type: OriginRequestPolicyType;
  OriginRequestPolicy: OriginRequestPolicy;
}
function OriginRequestPolicySummary_Parse(node: xmlP.XmlNode): OriginRequestPolicySummary {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as OriginRequestPolicyType),
    OriginRequestPolicy: node.first("OriginRequestPolicy", true, OriginRequestPolicy_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PublicKeyList {
  NextMarker?: string | null;
  MaxItems: number;
  Quantity: number;
  Items: PublicKeySummary[];
}
function PublicKeyList_Parse(node: xmlP.XmlNode): PublicKeyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "PublicKeySummary").map(PublicKeySummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface PublicKeySummary {
  Id: string;
  Name: string;
  CreatedTime: Date | number;
  EncodedKey: string;
  Comment?: string | null;
}
function PublicKeySummary_Parse(node: xmlP.XmlNode): PublicKeySummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"EncodedKey":true},
      optional: {"Comment":true},
    }),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

// refs: 1 - tags: output, named, interface
export interface RealtimeLogConfigs {
  MaxItems: number;
  Items: RealtimeLogConfig[];
  IsTruncated: boolean;
  Marker: string;
  NextMarker?: string | null;
}
function RealtimeLogConfigs_Parse(node: xmlP.XmlNode): RealtimeLogConfigs {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "member").map(RealtimeLogConfig_Parse),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
  };
}

// refs: 1 - tags: output, named, interface
export interface StreamingDistributionList {
  Marker: string;
  NextMarker?: string | null;
  MaxItems: number;
  IsTruncated: boolean;
  Quantity: number;
  Items: StreamingDistributionSummary[];
}
function StreamingDistributionList_Parse(node: xmlP.XmlNode): StreamingDistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
  };
}

// refs: 1 - tags: output, named, interface
export interface StreamingDistributionSummary {
  Id: string;
  ARN: string;
  Status: string;
  LastModifiedTime: Date | number;
  DomainName: string;
  S3Origin: S3Origin;
  Aliases: Aliases;
  TrustedSigners: TrustedSigners;
  Comment: string;
  PriceClass: PriceClass;
  Enabled: boolean;
}
function StreamingDistributionSummary_Parse(node: xmlP.XmlNode): StreamingDistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}
