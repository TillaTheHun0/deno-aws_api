// Autogenerated API client for: Amazon CloudFront

interface RequestConfig {
  abortSignal?: AbortSignal;
}

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export default class CloudFront {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(CloudFront.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2020-05-31",
    "endpointPrefix": "cloudfront",
    "globalEndpoint": "cloudfront.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "CloudFront",
    "serviceFullName": "Amazon CloudFront",
    "serviceId": "CloudFront",
    "signatureVersion": "v4",
    "uid": "cloudfront-2020-05-31"
  };

  async createCachePolicy(
    {abortSignal, ...params}: RequestConfig & s.CreateCachePolicyRequest,
  ): Promise<s.CreateCachePolicyResult> {
    const inner = params["CachePolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "CachePolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "DefaultTTL", content: inner["DefaultTTL"]?.toString()},
        {name: "MaxTTL", content: inner["MaxTTL"]?.toString()},
        {name: "MinTTL", content: inner["MinTTL"]?.toString()},
        {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(inner["ParametersInCacheKeyAndForwardedToOrigin"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCachePolicy2020_05_31",
      requestUri: "/2020-05-31/cache-policy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async createCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.CreateCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.CreateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateCloudFrontOriginAccessIdentity2020_05_31",
      requestUri: "/2020-05-31/origin-access-identity/cloudfront",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async createDistribution(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionRequest,
  ): Promise<s.CreateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "OriginGroups", ...OriginGroups_Serialize(inner["OriginGroups"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistribution2020_05_31",
      requestUri: "/2020-05-31/distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & s.CreateDistributionWithTagsRequest,
  ): Promise<s.CreateDistributionWithTagsResult> {
    const inner = params["DistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "DistributionConfig", ...DistributionConfig_Serialize(inner["DistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDistributionWithTags2020_05_31",
      requestUri: "/2020-05-31/distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async createFieldLevelEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateFieldLevelEncryptionConfigRequest,
  ): Promise<s.CreateFieldLevelEncryptionConfigResult> {
    const inner = params["FieldLevelEncryptionConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(inner["QueryArgProfileConfig"])},
        {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(inner["ContentTypeProfileConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFieldLevelEncryptionConfig2020_05_31",
      requestUri: "/2020-05-31/field-level-encryption",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async createFieldLevelEncryptionProfile(
    {abortSignal, ...params}: RequestConfig & s.CreateFieldLevelEncryptionProfileRequest,
  ): Promise<s.CreateFieldLevelEncryptionProfileResult> {
    const inner = params["FieldLevelEncryptionProfileConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionProfileConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "EncryptionEntities", ...EncryptionEntities_Serialize(inner["EncryptionEntities"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateFieldLevelEncryptionProfile2020_05_31",
      requestUri: "/2020-05-31/field-level-encryption-profile",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async createInvalidation(
    {abortSignal, ...params}: RequestConfig & s.CreateInvalidationRequest,
  ): Promise<s.CreateInvalidationResult> {
    const inner = params["InvalidationBatch"];
    const body = inner ? xmlP.stringify({
      name: "InvalidationBatch",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Paths", ...Paths_Serialize(inner["Paths"])},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateInvalidation2020_05_31",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async createKeyGroup(
    {abortSignal, ...params}: RequestConfig & s.CreateKeyGroupRequest,
  ): Promise<s.CreateKeyGroupResult> {
    const inner = params["KeyGroupConfig"];
    const body = inner ? xmlP.stringify({
      name: "KeyGroupConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "Items", children: inner["Items"]?.map(x => ({name: "PublicKey", content: x}))},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateKeyGroup2020_05_31",
      requestUri: "/2020-05-31/key-group",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async createMonitoringSubscription(
    {abortSignal, ...params}: RequestConfig & s.CreateMonitoringSubscriptionRequest,
  ): Promise<s.CreateMonitoringSubscriptionResult> {
    const inner = params["MonitoringSubscription"];
    const body = inner ? xmlP.stringify({
      name: "MonitoringSubscription",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "RealtimeMetricsSubscriptionConfig", ...RealtimeMetricsSubscriptionConfig_Serialize(inner["RealtimeMetricsSubscriptionConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateMonitoringSubscription2020_05_31",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    MonitoringSubscription: MonitoringSubscription_Parse(xml),
  };
  }

  async createOriginRequestPolicy(
    {abortSignal, ...params}: RequestConfig & s.CreateOriginRequestPolicyRequest,
  ): Promise<s.CreateOriginRequestPolicyResult> {
    const inner = params["OriginRequestPolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "OriginRequestPolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(inner["HeadersConfig"])},
        {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(inner["CookiesConfig"])},
        {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(inner["QueryStringsConfig"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateOriginRequestPolicy2020_05_31",
      requestUri: "/2020-05-31/origin-request-policy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async createPublicKey(
    {abortSignal, ...params}: RequestConfig & s.CreatePublicKeyRequest,
  ): Promise<s.CreatePublicKeyResult> {
    const inner = params["PublicKeyConfig"];
    const body = inner ? xmlP.stringify({
      name: "PublicKeyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "EncodedKey", content: inner["EncodedKey"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePublicKey2020_05_31",
      requestUri: "/2020-05-31/public-key",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async createRealtimeLogConfig(
    {abortSignal, ...params}: RequestConfig & s.CreateRealtimeLogConfigRequest,
  ): Promise<s.CreateRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "CreateRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "EndPoints", children: params["EndPoints"]?.map(x => ({name: "member", ...EndPoint_Serialize(x)}))},
        {name: "Fields", children: params["Fields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "SamplingRate", content: params["SamplingRate"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/realtime-log-config",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async createStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamingDistributionRequest,
  ): Promise<s.CreateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistribution2020_05_31",
      requestUri: "/2020-05-31/streaming-distribution",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async createStreamingDistributionWithTags(
    {abortSignal, ...params}: RequestConfig & s.CreateStreamingDistributionWithTagsRequest,
  ): Promise<s.CreateStreamingDistributionWithTagsResult> {
    const inner = params["StreamingDistributionConfigWithTags"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfigWithTags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(inner["StreamingDistributionConfig"])},
        {name: "Tags", ...Tags_Serialize(inner["Tags"])},
      ]}) : "";
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateStreamingDistributionWithTags2020_05_31",
      requestUri: "/2020-05-31/streaming-distribution?WithTags",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Location: resp.headers.get("Location"),
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async deleteCachePolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteCachePolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCachePolicy2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.DeleteCloudFrontOriginAccessIdentityRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteCloudFrontOriginAccessIdentity2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteDistribution(
    {abortSignal, ...params}: RequestConfig & s.DeleteDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteDistribution2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteFieldLevelEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteFieldLevelEncryptionConfigRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFieldLevelEncryptionConfig2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteFieldLevelEncryptionProfile(
    {abortSignal, ...params}: RequestConfig & s.DeleteFieldLevelEncryptionProfileRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteFieldLevelEncryptionProfile2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteKeyGroup(
    {abortSignal, ...params}: RequestConfig & s.DeleteKeyGroupRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteKeyGroup2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteMonitoringSubscription(
    {abortSignal, ...params}: RequestConfig & s.DeleteMonitoringSubscriptionRequest,
  ): Promise<s.DeleteMonitoringSubscriptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "DeleteMonitoringSubscription2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    return {
    };
  }

  async deleteOriginRequestPolicy(
    {abortSignal, ...params}: RequestConfig & s.DeleteOriginRequestPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteOriginRequestPolicy2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deletePublicKey(
    {abortSignal, ...params}: RequestConfig & s.DeletePublicKeyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeletePublicKey2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async deleteRealtimeLogConfig(
    {abortSignal, ...params}: RequestConfig & s.DeleteRealtimeLogConfigRequest = {},
  ): Promise<void> {
    const body = xmlP.stringify({
      name: "DeleteRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/delete-realtime-log-config/",
      responseCode: 204,
    });
  }

  async deleteStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.DeleteStreamingDistributionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers,
      action: "DeleteStreamingDistribution2020_05_31",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}`,
      responseCode: 204,
    });
  }

  async getCachePolicy(
    {abortSignal, ...params}: RequestConfig & s.GetCachePolicyRequest,
  ): Promise<s.GetCachePolicyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCachePolicy2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async getCachePolicyConfig(
    {abortSignal, ...params}: RequestConfig & s.GetCachePolicyConfigRequest,
  ): Promise<s.GetCachePolicyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCachePolicyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicyConfig: CachePolicyConfig_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.GetCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.GetCloudFrontOriginAccessIdentityResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentity2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async getCloudFrontOriginAccessIdentityConfig(
    {abortSignal, ...params}: RequestConfig & s.GetCloudFrontOriginAccessIdentityConfigRequest,
  ): Promise<s.GetCloudFrontOriginAccessIdentityConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetCloudFrontOriginAccessIdentityConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig_Parse(xml),
  };
  }

  async getDistribution(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionRequest,
  ): Promise<s.GetDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistribution2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async getDistributionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetDistributionConfigRequest,
  ): Promise<s.GetDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetDistributionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    DistributionConfig: DistributionConfig_Parse(xml),
  };
  }

  async getFieldLevelEncryption(
    {abortSignal, ...params}: RequestConfig & s.GetFieldLevelEncryptionRequest,
  ): Promise<s.GetFieldLevelEncryptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryption2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async getFieldLevelEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetFieldLevelEncryptionConfigRequest,
  ): Promise<s.GetFieldLevelEncryptionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionConfig: FieldLevelEncryptionConfig_Parse(xml),
  };
  }

  async getFieldLevelEncryptionProfile(
    {abortSignal, ...params}: RequestConfig & s.GetFieldLevelEncryptionProfileRequest,
  ): Promise<s.GetFieldLevelEncryptionProfileResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionProfile2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async getFieldLevelEncryptionProfileConfig(
    {abortSignal, ...params}: RequestConfig & s.GetFieldLevelEncryptionProfileConfigRequest,
  ): Promise<s.GetFieldLevelEncryptionProfileConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetFieldLevelEncryptionProfileConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig_Parse(xml),
  };
  }

  async getInvalidation(
    {abortSignal, ...params}: RequestConfig & s.GetInvalidationRequest,
  ): Promise<s.GetInvalidationResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetInvalidation2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Invalidation: Invalidation_Parse(xml),
  };
  }

  async getKeyGroup(
    {abortSignal, ...params}: RequestConfig & s.GetKeyGroupRequest,
  ): Promise<s.GetKeyGroupResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetKeyGroup2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async getKeyGroupConfig(
    {abortSignal, ...params}: RequestConfig & s.GetKeyGroupConfigRequest,
  ): Promise<s.GetKeyGroupConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetKeyGroupConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroupConfig: KeyGroupConfig_Parse(xml),
  };
  }

  async getMonitoringSubscription(
    {abortSignal, ...params}: RequestConfig & s.GetMonitoringSubscriptionRequest,
  ): Promise<s.GetMonitoringSubscriptionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetMonitoringSubscription2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributions/${params["DistributionId"]}/monitoring-subscription`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    MonitoringSubscription: MonitoringSubscription_Parse(xml),
  };
  }

  async getOriginRequestPolicy(
    {abortSignal, ...params}: RequestConfig & s.GetOriginRequestPolicyRequest,
  ): Promise<s.GetOriginRequestPolicyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetOriginRequestPolicy2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async getOriginRequestPolicyConfig(
    {abortSignal, ...params}: RequestConfig & s.GetOriginRequestPolicyConfigRequest,
  ): Promise<s.GetOriginRequestPolicyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetOriginRequestPolicyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicyConfig: OriginRequestPolicyConfig_Parse(xml),
  };
  }

  async getPublicKey(
    {abortSignal, ...params}: RequestConfig & s.GetPublicKeyRequest,
  ): Promise<s.GetPublicKeyResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPublicKey2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async getPublicKeyConfig(
    {abortSignal, ...params}: RequestConfig & s.GetPublicKeyConfigRequest,
  ): Promise<s.GetPublicKeyConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetPublicKeyConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKeyConfig: PublicKeyConfig_Parse(xml),
  };
  }

  async getRealtimeLogConfig(
    {abortSignal, ...params}: RequestConfig & s.GetRealtimeLogConfigRequest = {},
  ): Promise<s.GetRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "GetRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/get-realtime-log-config/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async getStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.GetStreamingDistributionRequest,
  ): Promise<s.GetStreamingDistributionResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistribution2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  async getStreamingDistributionConfig(
    {abortSignal, ...params}: RequestConfig & s.GetStreamingDistributionConfigRequest,
  ): Promise<s.GetStreamingDistributionConfigResult> {

    const resp = await this.#client.performRequest({
      abortSignal,
      action: "GetStreamingDistributionConfig2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistributionConfig: StreamingDistributionConfig_Parse(xml),
  };
  }

  async listCachePolicies(
    {abortSignal, ...params}: RequestConfig & s.ListCachePoliciesRequest = {},
  ): Promise<s.ListCachePoliciesResult> {
    const query = new URLSearchParams;
    if (params["Type"] != null) query.set("Type", params["Type"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCachePolicies2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/cache-policy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CachePolicyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CachePolicySummary").map(CachePolicySummary_Parse),
      },
  };
  }

  async listCloudFrontOriginAccessIdentities(
    {abortSignal, ...params}: RequestConfig & s.ListCloudFrontOriginAccessIdentitiesRequest = {},
  ): Promise<s.ListCloudFrontOriginAccessIdentitiesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListCloudFrontOriginAccessIdentities2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/origin-access-identity/cloudfront",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    CloudFrontOriginAccessIdentityList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
      },
  };
  }

  async listDistributions(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsRequest = {},
  ): Promise<s.ListDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributions2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByCachePolicyId(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByCachePolicyIdRequest,
  ): Promise<s.ListDistributionsByCachePolicyIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByCachePolicyId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByCachePolicyId/${params["CachePolicyId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByKeyGroup(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByKeyGroupRequest,
  ): Promise<s.ListDistributionsByKeyGroupResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByKeyGroup2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByKeyGroupId/${params["KeyGroupId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByOriginRequestPolicyId(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByOriginRequestPolicyIdRequest,
  ): Promise<s.ListDistributionsByOriginRequestPolicyIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByOriginRequestPolicyId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByOriginRequestPolicyId/${params["OriginRequestPolicyId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionIdList: DistributionIdList_Parse(xml),
  };
  }

  async listDistributionsByRealtimeLogConfig(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByRealtimeLogConfigRequest = {},
  ): Promise<s.ListDistributionsByRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "ListDistributionsByRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Marker", content: params["Marker"]?.toString()},
        {name: "MaxItems", content: params["MaxItems"]?.toString()},
        {name: "RealtimeLogConfigName", content: params["RealtimeLogConfigName"]?.toString()},
        {name: "RealtimeLogConfigArn", content: params["RealtimeLogConfigArn"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDistributionsByRealtimeLogConfig2020_05_31",
      requestUri: "/2020-05-31/distributionsByRealtimeLogConfig/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listDistributionsByWebACLId(
    {abortSignal, ...params}: RequestConfig & s.ListDistributionsByWebACLIdRequest,
  ): Promise<s.ListDistributionsByWebACLIdResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListDistributionsByWebACLId2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distributionsByWebACLId/${params["WebACLId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    DistributionList: DistributionList_Parse(xml),
  };
  }

  async listFieldLevelEncryptionConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListFieldLevelEncryptionConfigsRequest = {},
  ): Promise<s.ListFieldLevelEncryptionConfigsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFieldLevelEncryptionConfigs2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/field-level-encryption",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    FieldLevelEncryptionList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "FieldLevelEncryptionSummary").map(FieldLevelEncryptionSummary_Parse),
      },
  };
  }

  async listFieldLevelEncryptionProfiles(
    {abortSignal, ...params}: RequestConfig & s.ListFieldLevelEncryptionProfilesRequest = {},
  ): Promise<s.ListFieldLevelEncryptionProfilesResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListFieldLevelEncryptionProfiles2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/field-level-encryption-profile",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    FieldLevelEncryptionProfileList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "FieldLevelEncryptionProfileSummary").map(FieldLevelEncryptionProfileSummary_Parse),
      },
  };
  }

  async listInvalidations(
    {abortSignal, ...params}: RequestConfig & s.ListInvalidationsRequest,
  ): Promise<s.ListInvalidationsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListInvalidations2020_05_31",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["DistributionId"]}/invalidation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    InvalidationList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
      },
  };
  }

  async listKeyGroups(
    {abortSignal, ...params}: RequestConfig & s.ListKeyGroupsRequest = {},
  ): Promise<s.ListKeyGroupsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListKeyGroups2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/key-group",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    KeyGroupList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "KeyGroupSummary").map(KeyGroupSummary_Parse),
      },
  };
  }

  async listOriginRequestPolicies(
    {abortSignal, ...params}: RequestConfig & s.ListOriginRequestPoliciesRequest = {},
  ): Promise<s.ListOriginRequestPoliciesResult> {
    const query = new URLSearchParams;
    if (params["Type"] != null) query.set("Type", params["Type"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListOriginRequestPolicies2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/origin-request-policy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    OriginRequestPolicyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "OriginRequestPolicySummary").map(OriginRequestPolicySummary_Parse),
      },
  };
  }

  async listPublicKeys(
    {abortSignal, ...params}: RequestConfig & s.ListPublicKeysRequest = {},
  ): Promise<s.ListPublicKeysResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListPublicKeys2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/public-key",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    PublicKeyList: {
        ...xml.strings({
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "PublicKeySummary").map(PublicKeySummary_Parse),
      },
  };
  }

  async listRealtimeLogConfigs(
    {abortSignal, ...params}: RequestConfig & s.ListRealtimeLogConfigsRequest = {},
  ): Promise<s.ListRealtimeLogConfigsResult> {
    const query = new URLSearchParams;
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListRealtimeLogConfigs2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/realtime-log-config",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    RealtimeLogConfigs: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "member").map(RealtimeLogConfig_Parse),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
      },
  };
  }

  async listStreamingDistributions(
    {abortSignal, ...params}: RequestConfig & s.ListStreamingDistributionsRequest = {},
  ): Promise<s.ListStreamingDistributionsResult> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListStreamingDistributions2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/streaming-distribution",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    StreamingDistributionList: {
        ...xml.strings({
          required: {"Marker":true},
          optional: {"NextMarker":true},
        }),
        MaxItems: xml.first("MaxItems", true, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
        Quantity: xml.first("Quantity", true, x => parseInt(x.content ?? '0')),
        Items: xml.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
      },
  };
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResult> {
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query,
      action: "ListTagsForResource2020_05_31",
      method: "GET",
      requestUri: "/2020-05-31/tagging",
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    Tags: Tags_Parse(xml),
  };
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & s.TagResourceRequest,
  ): Promise<void> {
    const inner = params["Tags"];
    const body = inner ? xmlP.stringify({
      name: "Tags",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "TagResource2020_05_31",
      requestUri: "/2020-05-31/tagging?Operation=Tag",
      responseCode: 204,
    });
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & s.UntagResourceRequest,
  ): Promise<void> {
    const inner = params["TagKeys"];
    const body = inner ? xmlP.stringify({
      name: "TagKeys",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Items", children: inner["Items"]?.map(x => ({name: "Key", content: x}))},
      ]}) : "";
    const query = new URLSearchParams;
    query.set("Resource", params["Resource"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      abortSignal, query, body,
      action: "UntagResource2020_05_31",
      requestUri: "/2020-05-31/tagging?Operation=Untag",
      responseCode: 204,
    });
  }

  async updateCachePolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateCachePolicyRequest,
  ): Promise<s.UpdateCachePolicyResult> {
    const inner = params["CachePolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "CachePolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "DefaultTTL", content: inner["DefaultTTL"]?.toString()},
        {name: "MaxTTL", content: inner["MaxTTL"]?.toString()},
        {name: "MinTTL", content: inner["MinTTL"]?.toString()},
        {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(inner["ParametersInCacheKeyAndForwardedToOrigin"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCachePolicy2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/cache-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CachePolicy: CachePolicy_Parse(xml),
  };
  }

  async updateCloudFrontOriginAccessIdentity(
    {abortSignal, ...params}: RequestConfig & s.UpdateCloudFrontOriginAccessIdentityRequest,
  ): Promise<s.UpdateCloudFrontOriginAccessIdentityResult> {
    const inner = params["CloudFrontOriginAccessIdentityConfig"];
    const body = inner ? xmlP.stringify({
      name: "CloudFrontOriginAccessIdentityConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateCloudFrontOriginAccessIdentity2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/origin-access-identity/cloudfront/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    CloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity_Parse(xml),
  };
  }

  async updateDistribution(
    {abortSignal, ...params}: RequestConfig & s.UpdateDistributionRequest,
  ): Promise<s.UpdateDistributionResult> {
    const inner = params["DistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "DistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "DefaultRootObject", content: inner["DefaultRootObject"]?.toString()},
        {name: "Origins", ...Origins_Serialize(inner["Origins"])},
        {name: "OriginGroups", ...OriginGroups_Serialize(inner["OriginGroups"])},
        {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(inner["DefaultCacheBehavior"])},
        {name: "CacheBehaviors", ...CacheBehaviors_Serialize(inner["CacheBehaviors"])},
        {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(inner["CustomErrorResponses"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...LoggingConfig_Serialize(inner["Logging"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
        {name: "ViewerCertificate", ...ViewerCertificate_Serialize(inner["ViewerCertificate"])},
        {name: "Restrictions", ...Restrictions_Serialize(inner["Restrictions"])},
        {name: "WebACLId", content: inner["WebACLId"]?.toString()},
        {name: "HttpVersion", content: inner["HttpVersion"]?.toString()},
        {name: "IsIPV6Enabled", content: inner["IsIPV6Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateDistribution2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    Distribution: Distribution_Parse(xml),
  };
  }

  async updateFieldLevelEncryptionConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateFieldLevelEncryptionConfigRequest,
  ): Promise<s.UpdateFieldLevelEncryptionConfigResult> {
    const inner = params["FieldLevelEncryptionConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(inner["QueryArgProfileConfig"])},
        {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(inner["ContentTypeProfileConfig"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFieldLevelEncryptionConfig2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryption: FieldLevelEncryption_Parse(xml),
  };
  }

  async updateFieldLevelEncryptionProfile(
    {abortSignal, ...params}: RequestConfig & s.UpdateFieldLevelEncryptionProfileRequest,
  ): Promise<s.UpdateFieldLevelEncryptionProfileResult> {
    const inner = params["FieldLevelEncryptionProfileConfig"];
    const body = inner ? xmlP.stringify({
      name: "FieldLevelEncryptionProfileConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "EncryptionEntities", ...EncryptionEntities_Serialize(inner["EncryptionEntities"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateFieldLevelEncryptionProfile2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/field-level-encryption-profile/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    FieldLevelEncryptionProfile: FieldLevelEncryptionProfile_Parse(xml),
  };
  }

  async updateKeyGroup(
    {abortSignal, ...params}: RequestConfig & s.UpdateKeyGroupRequest,
  ): Promise<s.UpdateKeyGroupResult> {
    const inner = params["KeyGroupConfig"];
    const body = inner ? xmlP.stringify({
      name: "KeyGroupConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "Items", children: inner["Items"]?.map(x => ({name: "PublicKey", content: x}))},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateKeyGroup2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/key-group/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    KeyGroup: KeyGroup_Parse(xml),
  };
  }

  async updateOriginRequestPolicy(
    {abortSignal, ...params}: RequestConfig & s.UpdateOriginRequestPolicyRequest,
  ): Promise<s.UpdateOriginRequestPolicyResult> {
    const inner = params["OriginRequestPolicyConfig"];
    const body = inner ? xmlP.stringify({
      name: "OriginRequestPolicyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(inner["HeadersConfig"])},
        {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(inner["CookiesConfig"])},
        {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(inner["QueryStringsConfig"])},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateOriginRequestPolicy2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/origin-request-policy/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    OriginRequestPolicy: OriginRequestPolicy_Parse(xml),
  };
  }

  async updatePublicKey(
    {abortSignal, ...params}: RequestConfig & s.UpdatePublicKeyRequest,
  ): Promise<s.UpdatePublicKeyResult> {
    const inner = params["PublicKeyConfig"];
    const body = inner ? xmlP.stringify({
      name: "PublicKeyConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "Name", content: inner["Name"]?.toString()},
        {name: "EncodedKey", content: inner["EncodedKey"]?.toString()},
        {name: "Comment", content: inner["Comment"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdatePublicKey2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/public-key/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    PublicKey: PublicKey_Parse(xml),
  };
  }

  async updateRealtimeLogConfig(
    {abortSignal, ...params}: RequestConfig & s.UpdateRealtimeLogConfigRequest = {},
  ): Promise<s.UpdateRealtimeLogConfigResult> {
    const body = xmlP.stringify({
      name: "UpdateRealtimeLogConfigRequest",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "EndPoints", children: params["EndPoints"]?.map(x => ({name: "member", ...EndPoint_Serialize(x)}))},
        {name: "Fields", children: params["Fields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "ARN", content: params["ARN"]?.toString()},
        {name: "SamplingRate", content: params["SamplingRate"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateRealtimeLogConfig2020_05_31",
      method: "PUT",
      requestUri: "/2020-05-31/realtime-log-config/",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RealtimeLogConfig: xml.first("RealtimeLogConfig", false, RealtimeLogConfig_Parse),
    };
  }

  async updateStreamingDistribution(
    {abortSignal, ...params}: RequestConfig & s.UpdateStreamingDistributionRequest,
  ): Promise<s.UpdateStreamingDistributionResult> {
    const inner = params["StreamingDistributionConfig"];
    const body = inner ? xmlP.stringify({
      name: "StreamingDistributionConfig",
      attributes: {"xmlns":"http://cloudfront.amazonaws.com/doc/2020-05-31/"},
      children: [
        {name: "CallerReference", content: inner["CallerReference"]?.toString()},
        {name: "S3Origin", ...S3Origin_Serialize(inner["S3Origin"])},
        {name: "Aliases", ...Aliases_Serialize(inner["Aliases"])},
        {name: "Comment", content: inner["Comment"]?.toString()},
        {name: "Logging", ...StreamingLoggingConfig_Serialize(inner["Logging"])},
        {name: "TrustedSigners", ...TrustedSigners_Serialize(inner["TrustedSigners"])},
        {name: "PriceClass", content: inner["PriceClass"]?.toString()},
        {name: "Enabled", content: inner["Enabled"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    const resp = await this.#client.performRequest({
      abortSignal, headers, body,
      action: "UpdateStreamingDistribution2020_05_31",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-05-31/streaming-distribution/${params["Id"]}/config`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
  return {
    ETag: resp.headers.get("ETag"),
    StreamingDistribution: StreamingDistribution_Parse(xml),
  };
  }

  // Resource State Waiters

  /**
   * Wait until a distribution is deployed.
   * Checks state up to 35 times, 60 seconds apart (about 35 minutes max wait time).
   */
  async waitForDistributionDeployed(
    params: RequestConfig & s.GetDistributionRequest,
  ): Promise<s.GetDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state DistributionDeployed';
    for (let i = 0; i < 35; i++) {
      const resp = await this.getDistribution(params);
      if (resp?.Distribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until an invalidation has completed.
   * Checks state up to 30 times, 20 seconds apart (about 10 minutes max wait time).
   */
  async waitForInvalidationCompleted(
    params: RequestConfig & s.GetInvalidationRequest,
  ): Promise<s.GetInvalidationResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state InvalidationCompleted';
    for (let i = 0; i < 30; i++) {
      const resp = await this.getInvalidation(params);
      if (resp?.Invalidation?.Status === "Completed") return resp;
      await new Promise(r => setTimeout(r, 20000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a streaming distribution is deployed.
   * Checks state up to 25 times, 60 seconds apart (about 25 minutes max wait time).
   */
  async waitForStreamingDistributionDeployed(
    params: RequestConfig & s.GetStreamingDistributionRequest,
  ): Promise<s.GetStreamingDistributionResult> {
    const errMessage = 'ResourceNotReady: Resource is not in the state StreamingDistributionDeployed';
    for (let i = 0; i < 25; i++) {
      const resp = await this.getStreamingDistribution(params);
      if (resp?.StreamingDistribution?.Status === "Deployed") return resp;
      await new Promise(r => setTimeout(r, 60000));
    }
    throw new Error(errMessage);
  }

}

function CachePolicyConfig_Serialize(data: s.CachePolicyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "ParametersInCacheKeyAndForwardedToOrigin", ...ParametersInCacheKeyAndForwardedToOrigin_Serialize(data["ParametersInCacheKeyAndForwardedToOrigin"])},
  ]};
}
function CachePolicyConfig_Parse(node: xmlP.XmlNode): s.CachePolicyConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
    MinTTL: node.first("MinTTL", true, x => parseInt(x.content ?? '0')),
    ParametersInCacheKeyAndForwardedToOrigin: node.first("ParametersInCacheKeyAndForwardedToOrigin", false, ParametersInCacheKeyAndForwardedToOrigin_Parse),
  };
}

function ParametersInCacheKeyAndForwardedToOrigin_Serialize(data: s.ParametersInCacheKeyAndForwardedToOrigin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "EnableAcceptEncodingGzip", content: data["EnableAcceptEncodingGzip"]?.toString()},
    {name: "EnableAcceptEncodingBrotli", content: data["EnableAcceptEncodingBrotli"]?.toString()},
    {name: "HeadersConfig", ...CachePolicyHeadersConfig_Serialize(data["HeadersConfig"])},
    {name: "CookiesConfig", ...CachePolicyCookiesConfig_Serialize(data["CookiesConfig"])},
    {name: "QueryStringsConfig", ...CachePolicyQueryStringsConfig_Serialize(data["QueryStringsConfig"])},
  ]};
}
function ParametersInCacheKeyAndForwardedToOrigin_Parse(node: xmlP.XmlNode): s.ParametersInCacheKeyAndForwardedToOrigin {
  return {
    EnableAcceptEncodingGzip: node.first("EnableAcceptEncodingGzip", true, x => x.content === 'true'),
    EnableAcceptEncodingBrotli: node.first("EnableAcceptEncodingBrotli", false, x => x.content === 'true'),
    HeadersConfig: node.first("HeadersConfig", true, CachePolicyHeadersConfig_Parse),
    CookiesConfig: node.first("CookiesConfig", true, CachePolicyCookiesConfig_Parse),
    QueryStringsConfig: node.first("QueryStringsConfig", true, CachePolicyQueryStringsConfig_Parse),
  };
}

function CachePolicyHeadersConfig_Serialize(data: s.CachePolicyHeadersConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderBehavior", content: data["HeaderBehavior"]?.toString()},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
  ]};
}
function CachePolicyHeadersConfig_Parse(node: xmlP.XmlNode): s.CachePolicyHeadersConfig {
  return {
    HeaderBehavior: node.first("HeaderBehavior", true, x => (x.content ?? '') as s.CachePolicyHeaderBehavior),
    Headers: node.first("Headers", false, Headers_Parse),
  };
}

function Headers_Serialize(data: s.Headers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function Headers_Parse(node: xmlP.XmlNode): s.Headers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function CachePolicyCookiesConfig_Serialize(data: s.CachePolicyCookiesConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CookieBehavior", content: data["CookieBehavior"]?.toString()},
    {name: "Cookies", ...CookieNames_Serialize(data["Cookies"])},
  ]};
}
function CachePolicyCookiesConfig_Parse(node: xmlP.XmlNode): s.CachePolicyCookiesConfig {
  return {
    CookieBehavior: node.first("CookieBehavior", true, x => (x.content ?? '') as s.CachePolicyCookieBehavior),
    Cookies: node.first("Cookies", false, CookieNames_Parse),
  };
}

function CookieNames_Serialize(data: s.CookieNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function CookieNames_Parse(node: xmlP.XmlNode): s.CookieNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function CachePolicyQueryStringsConfig_Serialize(data: s.CachePolicyQueryStringsConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryStringBehavior", content: data["QueryStringBehavior"]?.toString()},
    {name: "QueryStrings", ...QueryStringNames_Serialize(data["QueryStrings"])},
  ]};
}
function CachePolicyQueryStringsConfig_Parse(node: xmlP.XmlNode): s.CachePolicyQueryStringsConfig {
  return {
    QueryStringBehavior: node.first("QueryStringBehavior", true, x => (x.content ?? '') as s.CachePolicyQueryStringBehavior),
    QueryStrings: node.first("QueryStrings", false, QueryStringNames_Parse),
  };
}

function QueryStringNames_Serialize(data: s.QueryStringNames | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringNames_Parse(node: xmlP.XmlNode): s.QueryStringNames {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function CloudFrontOriginAccessIdentityConfig_Serialize(data: s.CloudFrontOriginAccessIdentityConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function CloudFrontOriginAccessIdentityConfig_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentityConfig {
  return node.strings({
    required: {"CallerReference":true,"Comment":true},
  });
}

function DistributionConfig_Serialize(data: s.DistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "DefaultRootObject", content: data["DefaultRootObject"]?.toString()},
    {name: "Origins", ...Origins_Serialize(data["Origins"])},
    {name: "OriginGroups", ...OriginGroups_Serialize(data["OriginGroups"])},
    {name: "DefaultCacheBehavior", ...DefaultCacheBehavior_Serialize(data["DefaultCacheBehavior"])},
    {name: "CacheBehaviors", ...CacheBehaviors_Serialize(data["CacheBehaviors"])},
    {name: "CustomErrorResponses", ...CustomErrorResponses_Serialize(data["CustomErrorResponses"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...LoggingConfig_Serialize(data["Logging"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "ViewerCertificate", ...ViewerCertificate_Serialize(data["ViewerCertificate"])},
    {name: "Restrictions", ...Restrictions_Serialize(data["Restrictions"])},
    {name: "WebACLId", content: data["WebACLId"]?.toString()},
    {name: "HttpVersion", content: data["HttpVersion"]?.toString()},
    {name: "IsIPV6Enabled", content: data["IsIPV6Enabled"]?.toString()},
  ]};
}
function DistributionConfig_Parse(node: xmlP.XmlNode): s.DistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
      optional: {"DefaultRootObject":true,"WebACLId":true},
    }),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    OriginGroups: node.first("OriginGroups", false, OriginGroups_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", false, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", false, CustomErrorResponses_Parse),
    Logging: node.first("Logging", false, LoggingConfig_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", false, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", false, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", false, x => (x.content ?? '') as s.HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", false, x => x.content === 'true'),
  };
}

function Aliases_Serialize(data: s.Aliases | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CNAME", content: x}))},
  ]};
}
function Aliases_Parse(node: xmlP.XmlNode): s.Aliases {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CNAME").map(x => x.content ?? ''),
  };
}

function Origins_Serialize(data: s.Origins | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Origin", ...Origin_Serialize(x)}))},
  ]};
}
function Origins_Parse(node: xmlP.XmlNode): s.Origins {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Origin").map(Origin_Parse),
  };
}

function Origin_Serialize(data: s.Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginPath", content: data["OriginPath"]?.toString()},
    {name: "CustomHeaders", ...CustomHeaders_Serialize(data["CustomHeaders"])},
    {name: "S3OriginConfig", ...S3OriginConfig_Serialize(data["S3OriginConfig"])},
    {name: "CustomOriginConfig", ...CustomOriginConfig_Serialize(data["CustomOriginConfig"])},
    {name: "ConnectionAttempts", content: data["ConnectionAttempts"]?.toString()},
    {name: "ConnectionTimeout", content: data["ConnectionTimeout"]?.toString()},
    {name: "OriginShield", ...OriginShield_Serialize(data["OriginShield"])},
  ]};
}
function Origin_Parse(node: xmlP.XmlNode): s.Origin {
  return {
    ...node.strings({
      required: {"Id":true,"DomainName":true},
      optional: {"OriginPath":true},
    }),
    CustomHeaders: node.first("CustomHeaders", false, CustomHeaders_Parse),
    S3OriginConfig: node.first("S3OriginConfig", false, S3OriginConfig_Parse),
    CustomOriginConfig: node.first("CustomOriginConfig", false, CustomOriginConfig_Parse),
    ConnectionAttempts: node.first("ConnectionAttempts", false, x => parseInt(x.content ?? '0')),
    ConnectionTimeout: node.first("ConnectionTimeout", false, x => parseInt(x.content ?? '0')),
    OriginShield: node.first("OriginShield", false, OriginShield_Parse),
  };
}

function CustomHeaders_Serialize(data: s.CustomHeaders | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginCustomHeader", ...OriginCustomHeader_Serialize(x)}))},
  ]};
}
function CustomHeaders_Parse(node: xmlP.XmlNode): s.CustomHeaders {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginCustomHeader").map(OriginCustomHeader_Parse),
  };
}

function OriginCustomHeader_Serialize(data: s.OriginCustomHeader | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderName", content: data["HeaderName"]?.toString()},
    {name: "HeaderValue", content: data["HeaderValue"]?.toString()},
  ]};
}
function OriginCustomHeader_Parse(node: xmlP.XmlNode): s.OriginCustomHeader {
  return node.strings({
    required: {"HeaderName":true,"HeaderValue":true},
  });
}

function S3OriginConfig_Serialize(data: s.S3OriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3OriginConfig_Parse(node: xmlP.XmlNode): s.S3OriginConfig {
  return node.strings({
    required: {"OriginAccessIdentity":true},
  });
}

function CustomOriginConfig_Serialize(data: s.CustomOriginConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HTTPPort", content: data["HTTPPort"]?.toString()},
    {name: "HTTPSPort", content: data["HTTPSPort"]?.toString()},
    {name: "OriginProtocolPolicy", content: data["OriginProtocolPolicy"]?.toString()},
    {name: "OriginSslProtocols", ...OriginSslProtocols_Serialize(data["OriginSslProtocols"])},
    {name: "OriginReadTimeout", content: data["OriginReadTimeout"]?.toString()},
    {name: "OriginKeepaliveTimeout", content: data["OriginKeepaliveTimeout"]?.toString()},
  ]};
}
function CustomOriginConfig_Parse(node: xmlP.XmlNode): s.CustomOriginConfig {
  return {
    HTTPPort: node.first("HTTPPort", true, x => parseInt(x.content ?? '0')),
    HTTPSPort: node.first("HTTPSPort", true, x => parseInt(x.content ?? '0')),
    OriginProtocolPolicy: node.first("OriginProtocolPolicy", true, x => (x.content ?? '') as s.OriginProtocolPolicy),
    OriginSslProtocols: node.first("OriginSslProtocols", false, OriginSslProtocols_Parse),
    OriginReadTimeout: node.first("OriginReadTimeout", false, x => parseInt(x.content ?? '0')),
    OriginKeepaliveTimeout: node.first("OriginKeepaliveTimeout", false, x => parseInt(x.content ?? '0')),
  };
}

function OriginSslProtocols_Serialize(data: s.OriginSslProtocols | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "SslProtocol", content: x}))},
  ]};
}
function OriginSslProtocols_Parse(node: xmlP.XmlNode): s.OriginSslProtocols {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "SslProtocol").map(x => (x.content ?? '') as s.SslProtocol),
  };
}

function OriginShield_Serialize(data: s.OriginShield | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "OriginShieldRegion", content: data["OriginShieldRegion"]?.toString()},
  ]};
}
function OriginShield_Parse(node: xmlP.XmlNode): s.OriginShield {
  return {
    ...node.strings({
      optional: {"OriginShieldRegion":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

function OriginGroups_Serialize(data: s.OriginGroups | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginGroup", ...OriginGroup_Serialize(x)}))},
  ]};
}
function OriginGroups_Parse(node: xmlP.XmlNode): s.OriginGroups {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginGroup").map(OriginGroup_Parse),
  };
}

function OriginGroup_Serialize(data: s.OriginGroup | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "FailoverCriteria", ...OriginGroupFailoverCriteria_Serialize(data["FailoverCriteria"])},
    {name: "Members", ...OriginGroupMembers_Serialize(data["Members"])},
  ]};
}
function OriginGroup_Parse(node: xmlP.XmlNode): s.OriginGroup {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    FailoverCriteria: node.first("FailoverCriteria", true, OriginGroupFailoverCriteria_Parse),
    Members: node.first("Members", true, OriginGroupMembers_Parse),
  };
}

function OriginGroupFailoverCriteria_Serialize(data: s.OriginGroupFailoverCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StatusCodes", ...StatusCodes_Serialize(data["StatusCodes"])},
  ]};
}
function OriginGroupFailoverCriteria_Parse(node: xmlP.XmlNode): s.OriginGroupFailoverCriteria {
  return {
    StatusCodes: node.first("StatusCodes", true, StatusCodes_Parse),
  };
}

function StatusCodes_Serialize(data: s.StatusCodes | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "StatusCode", content: x.toString()}))},
  ]};
}
function StatusCodes_Parse(node: xmlP.XmlNode): s.StatusCodes {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StatusCode").map(x => parseInt(x.content ?? '0')),
  };
}

function OriginGroupMembers_Serialize(data: s.OriginGroupMembers | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "OriginGroupMember", ...OriginGroupMember_Serialize(x)}))},
  ]};
}
function OriginGroupMembers_Parse(node: xmlP.XmlNode): s.OriginGroupMembers {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginGroupMember").map(OriginGroupMember_Parse),
  };
}

function OriginGroupMember_Serialize(data: s.OriginGroupMember | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OriginId", content: data["OriginId"]?.toString()},
  ]};
}
function OriginGroupMember_Parse(node: xmlP.XmlNode): s.OriginGroupMember {
  return node.strings({
    required: {"OriginId":true},
  });
}

function DefaultCacheBehavior_Serialize(data: s.DefaultCacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "TrustedKeyGroups", ...TrustedKeyGroups_Serialize(data["TrustedKeyGroups"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
    {name: "FieldLevelEncryptionId", content: data["FieldLevelEncryptionId"]?.toString()},
    {name: "RealtimeLogConfigArn", content: data["RealtimeLogConfigArn"]?.toString()},
    {name: "CachePolicyId", content: data["CachePolicyId"]?.toString()},
    {name: "OriginRequestPolicyId", content: data["OriginRequestPolicyId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
  ]};
}
function DefaultCacheBehavior_Parse(node: xmlP.XmlNode): s.DefaultCacheBehavior {
  return {
    ...node.strings({
      required: {"TargetOriginId":true},
      optional: {"FieldLevelEncryptionId":true,"RealtimeLogConfigArn":true,"CachePolicyId":true,"OriginRequestPolicyId":true},
    }),
    TrustedSigners: node.first("TrustedSigners", false, TrustedSigners_Parse),
    TrustedKeyGroups: node.first("TrustedKeyGroups", false, TrustedKeyGroups_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as s.ViewerProtocolPolicy),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
    ForwardedValues: node.first("ForwardedValues", false, ForwardedValues_Parse),
    MinTTL: node.first("MinTTL", false, x => parseInt(x.content ?? '0')),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
  };
}

function TrustedSigners_Serialize(data: s.TrustedSigners | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "AwsAccountNumber", content: x}))},
  ]};
}
function TrustedSigners_Parse(node: xmlP.XmlNode): s.TrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "AwsAccountNumber").map(x => x.content ?? ''),
  };
}

function TrustedKeyGroups_Serialize(data: s.TrustedKeyGroups | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "KeyGroup", content: x}))},
  ]};
}
function TrustedKeyGroups_Parse(node: xmlP.XmlNode): s.TrustedKeyGroups {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroup").map(x => x.content ?? ''),
  };
}

function AllowedMethods_Serialize(data: s.AllowedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
    {name: "CachedMethods", ...CachedMethods_Serialize(data["CachedMethods"])},
  ]};
}
function AllowedMethods_Parse(node: xmlP.XmlNode): s.AllowedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as s.Method),
    CachedMethods: node.first("CachedMethods", false, CachedMethods_Parse),
  };
}

function CachedMethods_Serialize(data: s.CachedMethods | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Method", content: x}))},
  ]};
}
function CachedMethods_Parse(node: xmlP.XmlNode): s.CachedMethods {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Method").map(x => (x.content ?? '') as s.Method),
  };
}

function LambdaFunctionAssociations_Serialize(data: s.LambdaFunctionAssociations | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "LambdaFunctionAssociation", ...LambdaFunctionAssociation_Serialize(x)}))},
  ]};
}
function LambdaFunctionAssociations_Parse(node: xmlP.XmlNode): s.LambdaFunctionAssociations {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "LambdaFunctionAssociation").map(LambdaFunctionAssociation_Parse),
  };
}

function LambdaFunctionAssociation_Serialize(data: s.LambdaFunctionAssociation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LambdaFunctionARN", content: data["LambdaFunctionARN"]?.toString()},
    {name: "EventType", content: data["EventType"]?.toString()},
    {name: "IncludeBody", content: data["IncludeBody"]?.toString()},
  ]};
}
function LambdaFunctionAssociation_Parse(node: xmlP.XmlNode): s.LambdaFunctionAssociation {
  return {
    ...node.strings({
      required: {"LambdaFunctionARN":true},
    }),
    EventType: node.first("EventType", true, x => (x.content ?? '') as s.EventType),
    IncludeBody: node.first("IncludeBody", false, x => x.content === 'true'),
  };
}

function ForwardedValues_Serialize(data: s.ForwardedValues | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryString", content: data["QueryString"]?.toString()},
    {name: "Cookies", ...CookiePreference_Serialize(data["Cookies"])},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
    {name: "QueryStringCacheKeys", ...QueryStringCacheKeys_Serialize(data["QueryStringCacheKeys"])},
  ]};
}
function ForwardedValues_Parse(node: xmlP.XmlNode): s.ForwardedValues {
  return {
    QueryString: node.first("QueryString", true, x => x.content === 'true'),
    Cookies: node.first("Cookies", true, CookiePreference_Parse),
    Headers: node.first("Headers", false, Headers_Parse),
    QueryStringCacheKeys: node.first("QueryStringCacheKeys", false, QueryStringCacheKeys_Parse),
  };
}

function CookiePreference_Serialize(data: s.CookiePreference | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Forward", content: data["Forward"]?.toString()},
    {name: "WhitelistedNames", ...CookieNames_Serialize(data["WhitelistedNames"])},
  ]};
}
function CookiePreference_Parse(node: xmlP.XmlNode): s.CookiePreference {
  return {
    Forward: node.first("Forward", true, x => (x.content ?? '') as s.ItemSelection),
    WhitelistedNames: node.first("WhitelistedNames", false, CookieNames_Parse),
  };
}

function QueryStringCacheKeys_Serialize(data: s.QueryStringCacheKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Name", content: x}))},
  ]};
}
function QueryStringCacheKeys_Parse(node: xmlP.XmlNode): s.QueryStringCacheKeys {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Name").map(x => x.content ?? ''),
  };
}

function CacheBehaviors_Serialize(data: s.CacheBehaviors | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CacheBehavior", ...CacheBehavior_Serialize(x)}))},
  ]};
}
function CacheBehaviors_Parse(node: xmlP.XmlNode): s.CacheBehaviors {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CacheBehavior").map(CacheBehavior_Parse),
  };
}

function CacheBehavior_Serialize(data: s.CacheBehavior | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PathPattern", content: data["PathPattern"]?.toString()},
    {name: "TargetOriginId", content: data["TargetOriginId"]?.toString()},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "TrustedKeyGroups", ...TrustedKeyGroups_Serialize(data["TrustedKeyGroups"])},
    {name: "ViewerProtocolPolicy", content: data["ViewerProtocolPolicy"]?.toString()},
    {name: "AllowedMethods", ...AllowedMethods_Serialize(data["AllowedMethods"])},
    {name: "SmoothStreaming", content: data["SmoothStreaming"]?.toString()},
    {name: "Compress", content: data["Compress"]?.toString()},
    {name: "LambdaFunctionAssociations", ...LambdaFunctionAssociations_Serialize(data["LambdaFunctionAssociations"])},
    {name: "FieldLevelEncryptionId", content: data["FieldLevelEncryptionId"]?.toString()},
    {name: "RealtimeLogConfigArn", content: data["RealtimeLogConfigArn"]?.toString()},
    {name: "CachePolicyId", content: data["CachePolicyId"]?.toString()},
    {name: "OriginRequestPolicyId", content: data["OriginRequestPolicyId"]?.toString()},
    {name: "ForwardedValues", ...ForwardedValues_Serialize(data["ForwardedValues"])},
    {name: "MinTTL", content: data["MinTTL"]?.toString()},
    {name: "DefaultTTL", content: data["DefaultTTL"]?.toString()},
    {name: "MaxTTL", content: data["MaxTTL"]?.toString()},
  ]};
}
function CacheBehavior_Parse(node: xmlP.XmlNode): s.CacheBehavior {
  return {
    ...node.strings({
      required: {"PathPattern":true,"TargetOriginId":true},
      optional: {"FieldLevelEncryptionId":true,"RealtimeLogConfigArn":true,"CachePolicyId":true,"OriginRequestPolicyId":true},
    }),
    TrustedSigners: node.first("TrustedSigners", false, TrustedSigners_Parse),
    TrustedKeyGroups: node.first("TrustedKeyGroups", false, TrustedKeyGroups_Parse),
    ViewerProtocolPolicy: node.first("ViewerProtocolPolicy", true, x => (x.content ?? '') as s.ViewerProtocolPolicy),
    AllowedMethods: node.first("AllowedMethods", false, AllowedMethods_Parse),
    SmoothStreaming: node.first("SmoothStreaming", false, x => x.content === 'true'),
    Compress: node.first("Compress", false, x => x.content === 'true'),
    LambdaFunctionAssociations: node.first("LambdaFunctionAssociations", false, LambdaFunctionAssociations_Parse),
    ForwardedValues: node.first("ForwardedValues", false, ForwardedValues_Parse),
    MinTTL: node.first("MinTTL", false, x => parseInt(x.content ?? '0')),
    DefaultTTL: node.first("DefaultTTL", false, x => parseInt(x.content ?? '0')),
    MaxTTL: node.first("MaxTTL", false, x => parseInt(x.content ?? '0')),
  };
}

function CustomErrorResponses_Serialize(data: s.CustomErrorResponses | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "CustomErrorResponse", ...CustomErrorResponse_Serialize(x)}))},
  ]};
}
function CustomErrorResponses_Parse(node: xmlP.XmlNode): s.CustomErrorResponses {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CustomErrorResponse").map(CustomErrorResponse_Parse),
  };
}

function CustomErrorResponse_Serialize(data: s.CustomErrorResponse | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorCode", content: data["ErrorCode"]?.toString()},
    {name: "ResponsePagePath", content: data["ResponsePagePath"]?.toString()},
    {name: "ResponseCode", content: data["ResponseCode"]?.toString()},
    {name: "ErrorCachingMinTTL", content: data["ErrorCachingMinTTL"]?.toString()},
  ]};
}
function CustomErrorResponse_Parse(node: xmlP.XmlNode): s.CustomErrorResponse {
  return {
    ...node.strings({
      optional: {"ResponsePagePath":true,"ResponseCode":true},
    }),
    ErrorCode: node.first("ErrorCode", true, x => parseInt(x.content ?? '0')),
    ErrorCachingMinTTL: node.first("ErrorCachingMinTTL", false, x => parseInt(x.content ?? '0')),
  };
}

function LoggingConfig_Serialize(data: s.LoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "IncludeCookies", content: data["IncludeCookies"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function LoggingConfig_Parse(node: xmlP.XmlNode): s.LoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    IncludeCookies: node.first("IncludeCookies", true, x => x.content === 'true'),
  };
}

function ViewerCertificate_Serialize(data: s.ViewerCertificate | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CloudFrontDefaultCertificate", content: data["CloudFrontDefaultCertificate"]?.toString()},
    {name: "IAMCertificateId", content: data["IAMCertificateId"]?.toString()},
    {name: "ACMCertificateArn", content: data["ACMCertificateArn"]?.toString()},
    {name: "SSLSupportMethod", content: data["SSLSupportMethod"]?.toString()},
    {name: "MinimumProtocolVersion", content: data["MinimumProtocolVersion"]?.toString()},
    {name: "Certificate", content: data["Certificate"]?.toString()},
    {name: "CertificateSource", content: data["CertificateSource"]?.toString()},
  ]};
}
function ViewerCertificate_Parse(node: xmlP.XmlNode): s.ViewerCertificate {
  return {
    ...node.strings({
      optional: {"IAMCertificateId":true,"ACMCertificateArn":true,"Certificate":true},
    }),
    CloudFrontDefaultCertificate: node.first("CloudFrontDefaultCertificate", false, x => x.content === 'true'),
    SSLSupportMethod: node.first("SSLSupportMethod", false, x => (x.content ?? '') as s.SSLSupportMethod),
    MinimumProtocolVersion: node.first("MinimumProtocolVersion", false, x => (x.content ?? '') as s.MinimumProtocolVersion),
    CertificateSource: node.first("CertificateSource", false, x => (x.content ?? '') as s.CertificateSource),
  };
}

function Restrictions_Serialize(data: s.Restrictions | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "GeoRestriction", ...GeoRestriction_Serialize(data["GeoRestriction"])},
  ]};
}
function Restrictions_Parse(node: xmlP.XmlNode): s.Restrictions {
  return {
    GeoRestriction: node.first("GeoRestriction", true, GeoRestriction_Parse),
  };
}

function GeoRestriction_Serialize(data: s.GeoRestriction | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RestrictionType", content: data["RestrictionType"]?.toString()},
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Location", content: x}))},
  ]};
}
function GeoRestriction_Parse(node: xmlP.XmlNode): s.GeoRestriction {
  return {
    RestrictionType: node.first("RestrictionType", true, x => (x.content ?? '') as s.GeoRestrictionType),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Location").map(x => x.content ?? ''),
  };
}

function DistributionConfigWithTags_Serialize(data: s.DistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DistributionConfig", ...DistributionConfig_Serialize(data["DistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

function Tags_Serialize(data: s.Tags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}
function Tags_Parse(node: xmlP.XmlNode): s.Tags {
  return {
    Items: node.getList("Items", "Tag").map(Tag_Parse),
  };
}

function Tag_Serialize(data: s.Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true},
    optional: {"Value":true},
  });
}

function FieldLevelEncryptionConfig_Serialize(data: s.FieldLevelEncryptionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "QueryArgProfileConfig", ...QueryArgProfileConfig_Serialize(data["QueryArgProfileConfig"])},
    {name: "ContentTypeProfileConfig", ...ContentTypeProfileConfig_Serialize(data["ContentTypeProfileConfig"])},
  ]};
}
function FieldLevelEncryptionConfig_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true},
      optional: {"Comment":true},
    }),
    QueryArgProfileConfig: node.first("QueryArgProfileConfig", false, QueryArgProfileConfig_Parse),
    ContentTypeProfileConfig: node.first("ContentTypeProfileConfig", false, ContentTypeProfileConfig_Parse),
  };
}

function QueryArgProfileConfig_Serialize(data: s.QueryArgProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ForwardWhenQueryArgProfileIsUnknown", content: data["ForwardWhenQueryArgProfileIsUnknown"]?.toString()},
    {name: "QueryArgProfiles", ...QueryArgProfiles_Serialize(data["QueryArgProfiles"])},
  ]};
}
function QueryArgProfileConfig_Parse(node: xmlP.XmlNode): s.QueryArgProfileConfig {
  return {
    ForwardWhenQueryArgProfileIsUnknown: node.first("ForwardWhenQueryArgProfileIsUnknown", true, x => x.content === 'true'),
    QueryArgProfiles: node.first("QueryArgProfiles", false, QueryArgProfiles_Parse),
  };
}

function QueryArgProfiles_Serialize(data: s.QueryArgProfiles | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "QueryArgProfile", ...QueryArgProfile_Serialize(x)}))},
  ]};
}
function QueryArgProfiles_Parse(node: xmlP.XmlNode): s.QueryArgProfiles {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "QueryArgProfile").map(QueryArgProfile_Parse),
  };
}

function QueryArgProfile_Serialize(data: s.QueryArgProfile | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryArg", content: data["QueryArg"]?.toString()},
    {name: "ProfileId", content: data["ProfileId"]?.toString()},
  ]};
}
function QueryArgProfile_Parse(node: xmlP.XmlNode): s.QueryArgProfile {
  return node.strings({
    required: {"QueryArg":true,"ProfileId":true},
  });
}

function ContentTypeProfileConfig_Serialize(data: s.ContentTypeProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ForwardWhenContentTypeIsUnknown", content: data["ForwardWhenContentTypeIsUnknown"]?.toString()},
    {name: "ContentTypeProfiles", ...ContentTypeProfiles_Serialize(data["ContentTypeProfiles"])},
  ]};
}
function ContentTypeProfileConfig_Parse(node: xmlP.XmlNode): s.ContentTypeProfileConfig {
  return {
    ForwardWhenContentTypeIsUnknown: node.first("ForwardWhenContentTypeIsUnknown", true, x => x.content === 'true'),
    ContentTypeProfiles: node.first("ContentTypeProfiles", false, ContentTypeProfiles_Parse),
  };
}

function ContentTypeProfiles_Serialize(data: s.ContentTypeProfiles | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "ContentTypeProfile", ...ContentTypeProfile_Serialize(x)}))},
  ]};
}
function ContentTypeProfiles_Parse(node: xmlP.XmlNode): s.ContentTypeProfiles {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "ContentTypeProfile").map(ContentTypeProfile_Parse),
  };
}

function ContentTypeProfile_Serialize(data: s.ContentTypeProfile | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "ProfileId", content: data["ProfileId"]?.toString()},
    {name: "ContentType", content: data["ContentType"]?.toString()},
  ]};
}
function ContentTypeProfile_Parse(node: xmlP.XmlNode): s.ContentTypeProfile {
  return {
    ...node.strings({
      required: {"ContentType":true},
      optional: {"ProfileId":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as s.Format),
  };
}

function FieldLevelEncryptionProfileConfig_Serialize(data: s.FieldLevelEncryptionProfileConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "EncryptionEntities", ...EncryptionEntities_Serialize(data["EncryptionEntities"])},
  ]};
}
function FieldLevelEncryptionProfileConfig_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionProfileConfig {
  return {
    ...node.strings({
      required: {"Name":true,"CallerReference":true},
      optional: {"Comment":true},
    }),
    EncryptionEntities: node.first("EncryptionEntities", true, EncryptionEntities_Parse),
  };
}

function EncryptionEntities_Serialize(data: s.EncryptionEntities | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "EncryptionEntity", ...EncryptionEntity_Serialize(x)}))},
  ]};
}
function EncryptionEntities_Parse(node: xmlP.XmlNode): s.EncryptionEntities {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "EncryptionEntity").map(EncryptionEntity_Parse),
  };
}

function EncryptionEntity_Serialize(data: s.EncryptionEntity | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "PublicKeyId", content: data["PublicKeyId"]?.toString()},
    {name: "ProviderId", content: data["ProviderId"]?.toString()},
    {name: "FieldPatterns", ...FieldPatterns_Serialize(data["FieldPatterns"])},
  ]};
}
function EncryptionEntity_Parse(node: xmlP.XmlNode): s.EncryptionEntity {
  return {
    ...node.strings({
      required: {"PublicKeyId":true,"ProviderId":true},
    }),
    FieldPatterns: node.first("FieldPatterns", true, FieldPatterns_Parse),
  };
}

function FieldPatterns_Serialize(data: s.FieldPatterns | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "FieldPattern", content: x}))},
  ]};
}
function FieldPatterns_Parse(node: xmlP.XmlNode): s.FieldPatterns {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldPattern").map(x => x.content ?? ''),
  };
}

function InvalidationBatch_Serialize(data: s.InvalidationBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Paths", ...Paths_Serialize(data["Paths"])},
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
  ]};
}
function InvalidationBatch_Parse(node: xmlP.XmlNode): s.InvalidationBatch {
  return {
    ...node.strings({
      required: {"CallerReference":true},
    }),
    Paths: node.first("Paths", true, Paths_Parse),
  };
}

function Paths_Serialize(data: s.Paths | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Quantity", content: data["Quantity"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "Path", content: x}))},
  ]};
}
function Paths_Parse(node: xmlP.XmlNode): s.Paths {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Path").map(x => x.content ?? ''),
  };
}

function KeyGroupConfig_Serialize(data: s.KeyGroupConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Items", children: data["Items"]?.map(x => ({name: "PublicKey", content: x}))},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function KeyGroupConfig_Parse(node: xmlP.XmlNode): s.KeyGroupConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    Items: node.getList("Items", "PublicKey").map(x => x.content ?? ''),
  };
}

function MonitoringSubscription_Serialize(data: s.MonitoringSubscription | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RealtimeMetricsSubscriptionConfig", ...RealtimeMetricsSubscriptionConfig_Serialize(data["RealtimeMetricsSubscriptionConfig"])},
  ]};
}
function MonitoringSubscription_Parse(node: xmlP.XmlNode): s.MonitoringSubscription {
  return {
    RealtimeMetricsSubscriptionConfig: node.first("RealtimeMetricsSubscriptionConfig", false, RealtimeMetricsSubscriptionConfig_Parse),
  };
}

function RealtimeMetricsSubscriptionConfig_Serialize(data: s.RealtimeMetricsSubscriptionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RealtimeMetricsSubscriptionStatus", content: data["RealtimeMetricsSubscriptionStatus"]?.toString()},
  ]};
}
function RealtimeMetricsSubscriptionConfig_Parse(node: xmlP.XmlNode): s.RealtimeMetricsSubscriptionConfig {
  return {
    RealtimeMetricsSubscriptionStatus: node.first("RealtimeMetricsSubscriptionStatus", true, x => (x.content ?? '') as s.RealtimeMetricsSubscriptionStatus),
  };
}

function OriginRequestPolicyConfig_Serialize(data: s.OriginRequestPolicyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "HeadersConfig", ...OriginRequestPolicyHeadersConfig_Serialize(data["HeadersConfig"])},
    {name: "CookiesConfig", ...OriginRequestPolicyCookiesConfig_Serialize(data["CookiesConfig"])},
    {name: "QueryStringsConfig", ...OriginRequestPolicyQueryStringsConfig_Serialize(data["QueryStringsConfig"])},
  ]};
}
function OriginRequestPolicyConfig_Parse(node: xmlP.XmlNode): s.OriginRequestPolicyConfig {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"Comment":true},
    }),
    HeadersConfig: node.first("HeadersConfig", true, OriginRequestPolicyHeadersConfig_Parse),
    CookiesConfig: node.first("CookiesConfig", true, OriginRequestPolicyCookiesConfig_Parse),
    QueryStringsConfig: node.first("QueryStringsConfig", true, OriginRequestPolicyQueryStringsConfig_Parse),
  };
}

function OriginRequestPolicyHeadersConfig_Serialize(data: s.OriginRequestPolicyHeadersConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HeaderBehavior", content: data["HeaderBehavior"]?.toString()},
    {name: "Headers", ...Headers_Serialize(data["Headers"])},
  ]};
}
function OriginRequestPolicyHeadersConfig_Parse(node: xmlP.XmlNode): s.OriginRequestPolicyHeadersConfig {
  return {
    HeaderBehavior: node.first("HeaderBehavior", true, x => (x.content ?? '') as s.OriginRequestPolicyHeaderBehavior),
    Headers: node.first("Headers", false, Headers_Parse),
  };
}

function OriginRequestPolicyCookiesConfig_Serialize(data: s.OriginRequestPolicyCookiesConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CookieBehavior", content: data["CookieBehavior"]?.toString()},
    {name: "Cookies", ...CookieNames_Serialize(data["Cookies"])},
  ]};
}
function OriginRequestPolicyCookiesConfig_Parse(node: xmlP.XmlNode): s.OriginRequestPolicyCookiesConfig {
  return {
    CookieBehavior: node.first("CookieBehavior", true, x => (x.content ?? '') as s.OriginRequestPolicyCookieBehavior),
    Cookies: node.first("Cookies", false, CookieNames_Parse),
  };
}

function OriginRequestPolicyQueryStringsConfig_Serialize(data: s.OriginRequestPolicyQueryStringsConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QueryStringBehavior", content: data["QueryStringBehavior"]?.toString()},
    {name: "QueryStrings", ...QueryStringNames_Serialize(data["QueryStrings"])},
  ]};
}
function OriginRequestPolicyQueryStringsConfig_Parse(node: xmlP.XmlNode): s.OriginRequestPolicyQueryStringsConfig {
  return {
    QueryStringBehavior: node.first("QueryStringBehavior", true, x => (x.content ?? '') as s.OriginRequestPolicyQueryStringBehavior),
    QueryStrings: node.first("QueryStrings", false, QueryStringNames_Parse),
  };
}

function PublicKeyConfig_Serialize(data: s.PublicKeyConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
    {name: "EncodedKey", content: data["EncodedKey"]?.toString()},
    {name: "Comment", content: data["Comment"]?.toString()},
  ]};
}
function PublicKeyConfig_Parse(node: xmlP.XmlNode): s.PublicKeyConfig {
  return node.strings({
    required: {"CallerReference":true,"Name":true,"EncodedKey":true},
    optional: {"Comment":true},
  });
}

function EndPoint_Serialize(data: s.EndPoint | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamType", content: data["StreamType"]?.toString()},
    {name: "KinesisStreamConfig", ...KinesisStreamConfig_Serialize(data["KinesisStreamConfig"])},
  ]};
}
function EndPoint_Parse(node: xmlP.XmlNode): s.EndPoint {
  return {
    ...node.strings({
      required: {"StreamType":true},
    }),
    KinesisStreamConfig: node.first("KinesisStreamConfig", false, KinesisStreamConfig_Parse),
  };
}

function KinesisStreamConfig_Serialize(data: s.KinesisStreamConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RoleARN", content: data["RoleARN"]?.toString()},
    {name: "StreamARN", content: data["StreamARN"]?.toString()},
  ]};
}
function KinesisStreamConfig_Parse(node: xmlP.XmlNode): s.KinesisStreamConfig {
  return node.strings({
    required: {"RoleARN":true,"StreamARN":true},
  });
}

function StreamingDistributionConfig_Serialize(data: s.StreamingDistributionConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CallerReference", content: data["CallerReference"]?.toString()},
    {name: "S3Origin", ...S3Origin_Serialize(data["S3Origin"])},
    {name: "Aliases", ...Aliases_Serialize(data["Aliases"])},
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Logging", ...StreamingLoggingConfig_Serialize(data["Logging"])},
    {name: "TrustedSigners", ...TrustedSigners_Serialize(data["TrustedSigners"])},
    {name: "PriceClass", content: data["PriceClass"]?.toString()},
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}
function StreamingDistributionConfig_Parse(node: xmlP.XmlNode): s.StreamingDistributionConfig {
  return {
    ...node.strings({
      required: {"CallerReference":true,"Comment":true},
    }),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", false, Aliases_Parse),
    Logging: node.first("Logging", false, StreamingLoggingConfig_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", false, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

function S3Origin_Serialize(data: s.S3Origin | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DomainName", content: data["DomainName"]?.toString()},
    {name: "OriginAccessIdentity", content: data["OriginAccessIdentity"]?.toString()},
  ]};
}
function S3Origin_Parse(node: xmlP.XmlNode): s.S3Origin {
  return node.strings({
    required: {"DomainName":true,"OriginAccessIdentity":true},
  });
}

function StreamingLoggingConfig_Serialize(data: s.StreamingLoggingConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function StreamingLoggingConfig_Parse(node: xmlP.XmlNode): s.StreamingLoggingConfig {
  return {
    ...node.strings({
      required: {"Bucket":true,"Prefix":true},
    }),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}

function StreamingDistributionConfigWithTags_Serialize(data: s.StreamingDistributionConfigWithTags | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "StreamingDistributionConfig", ...StreamingDistributionConfig_Serialize(data["StreamingDistributionConfig"])},
    {name: "Tags", ...Tags_Serialize(data["Tags"])},
  ]};
}

function TagKeys_Serialize(data: s.TagKeys | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Items", children: data["Items"]?.map(x => ({name: "Key", content: x}))},
  ]};
}

function CachePolicy_Parse(node: xmlP.XmlNode): s.CachePolicy {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    CachePolicyConfig: node.first("CachePolicyConfig", true, CachePolicyConfig_Parse),
  };
}

function CloudFrontOriginAccessIdentity_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentity {
  return {
    ...node.strings({
      required: {"Id":true,"S3CanonicalUserId":true},
    }),
    CloudFrontOriginAccessIdentityConfig: node.first("CloudFrontOriginAccessIdentityConfig", false, CloudFrontOriginAccessIdentityConfig_Parse),
  };
}

function Distribution_Parse(node: xmlP.XmlNode): s.Distribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    InProgressInvalidationBatches: node.first("InProgressInvalidationBatches", true, x => parseInt(x.content ?? '0')),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", false, ActiveTrustedSigners_Parse),
    ActiveTrustedKeyGroups: node.first("ActiveTrustedKeyGroups", false, ActiveTrustedKeyGroups_Parse),
    DistributionConfig: node.first("DistributionConfig", true, DistributionConfig_Parse),
    AliasICPRecordals: node.getList("AliasICPRecordals", "AliasICPRecordal").map(AliasICPRecordal_Parse),
  };
}

function ActiveTrustedSigners_Parse(node: xmlP.XmlNode): s.ActiveTrustedSigners {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "Signer").map(Signer_Parse),
  };
}

function Signer_Parse(node: xmlP.XmlNode): s.Signer {
  return {
    ...node.strings({
      optional: {"AwsAccountNumber":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

function KeyPairIds_Parse(node: xmlP.XmlNode): s.KeyPairIds {
  return {
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyPairId").map(x => x.content ?? ''),
  };
}

function ActiveTrustedKeyGroups_Parse(node: xmlP.XmlNode): s.ActiveTrustedKeyGroups {
  return {
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroup").map(KGKeyPairIds_Parse),
  };
}

function KGKeyPairIds_Parse(node: xmlP.XmlNode): s.KGKeyPairIds {
  return {
    ...node.strings({
      optional: {"KeyGroupId":true},
    }),
    KeyPairIds: node.first("KeyPairIds", false, KeyPairIds_Parse),
  };
}

function AliasICPRecordal_Parse(node: xmlP.XmlNode): s.AliasICPRecordal {
  return {
    ...node.strings({
      optional: {"CNAME":true},
    }),
    ICPRecordalStatus: node.first("ICPRecordalStatus", false, x => (x.content ?? '') as s.ICPRecordalStatus),
  };
}

function FieldLevelEncryption_Parse(node: xmlP.XmlNode): s.FieldLevelEncryption {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    FieldLevelEncryptionConfig: node.first("FieldLevelEncryptionConfig", true, FieldLevelEncryptionConfig_Parse),
  };
}

function FieldLevelEncryptionProfile_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionProfile {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    FieldLevelEncryptionProfileConfig: node.first("FieldLevelEncryptionProfileConfig", true, FieldLevelEncryptionProfileConfig_Parse),
  };
}

function Invalidation_Parse(node: xmlP.XmlNode): s.Invalidation {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
    InvalidationBatch: node.first("InvalidationBatch", true, InvalidationBatch_Parse),
  };
}

function KeyGroup_Parse(node: xmlP.XmlNode): s.KeyGroup {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    KeyGroupConfig: node.first("KeyGroupConfig", true, KeyGroupConfig_Parse),
  };
}

function OriginRequestPolicy_Parse(node: xmlP.XmlNode): s.OriginRequestPolicy {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    OriginRequestPolicyConfig: node.first("OriginRequestPolicyConfig", true, OriginRequestPolicyConfig_Parse),
  };
}

function PublicKey_Parse(node: xmlP.XmlNode): s.PublicKey {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
    PublicKeyConfig: node.first("PublicKeyConfig", true, PublicKeyConfig_Parse),
  };
}

function RealtimeLogConfig_Parse(node: xmlP.XmlNode): s.RealtimeLogConfig {
  return {
    ...node.strings({
      required: {"ARN":true,"Name":true},
    }),
    SamplingRate: node.first("SamplingRate", true, x => parseInt(x.content ?? '0')),
    EndPoints: node.getList("EndPoints", "member").map(EndPoint_Parse),
    Fields: node.getList("Fields", "Field").map(x => x.content ?? ''),
  };
}

function StreamingDistribution_Parse(node: xmlP.XmlNode): s.StreamingDistribution {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", false, x => xmlP.parseTimestamp(x.content)),
    ActiveTrustedSigners: node.first("ActiveTrustedSigners", true, ActiveTrustedSigners_Parse),
    StreamingDistributionConfig: node.first("StreamingDistributionConfig", true, StreamingDistributionConfig_Parse),
  };
}

function CachePolicyList_Parse(node: xmlP.XmlNode): s.CachePolicyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CachePolicySummary").map(CachePolicySummary_Parse),
  };
}

function CachePolicySummary_Parse(node: xmlP.XmlNode): s.CachePolicySummary {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as s.CachePolicyType),
    CachePolicy: node.first("CachePolicy", true, CachePolicy_Parse),
  };
}

function CloudFrontOriginAccessIdentityList_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentityList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "CloudFrontOriginAccessIdentitySummary").map(CloudFrontOriginAccessIdentitySummary_Parse),
  };
}

function CloudFrontOriginAccessIdentitySummary_Parse(node: xmlP.XmlNode): s.CloudFrontOriginAccessIdentitySummary {
  return node.strings({
    required: {"Id":true,"S3CanonicalUserId":true,"Comment":true},
  });
}

function DistributionList_Parse(node: xmlP.XmlNode): s.DistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionSummary").map(DistributionSummary_Parse),
  };
}

function DistributionSummary_Parse(node: xmlP.XmlNode): s.DistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true,"WebACLId":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    Origins: node.first("Origins", true, Origins_Parse),
    OriginGroups: node.first("OriginGroups", false, OriginGroups_Parse),
    DefaultCacheBehavior: node.first("DefaultCacheBehavior", true, DefaultCacheBehavior_Parse),
    CacheBehaviors: node.first("CacheBehaviors", true, CacheBehaviors_Parse),
    CustomErrorResponses: node.first("CustomErrorResponses", true, CustomErrorResponses_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
    ViewerCertificate: node.first("ViewerCertificate", true, ViewerCertificate_Parse),
    Restrictions: node.first("Restrictions", true, Restrictions_Parse),
    HttpVersion: node.first("HttpVersion", true, x => (x.content ?? '') as s.HttpVersion),
    IsIPV6Enabled: node.first("IsIPV6Enabled", true, x => x.content === 'true'),
    AliasICPRecordals: node.getList("AliasICPRecordals", "AliasICPRecordal").map(AliasICPRecordal_Parse),
  };
}

function DistributionIdList_Parse(node: xmlP.XmlNode): s.DistributionIdList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "DistributionId").map(x => x.content ?? ''),
  };
}

function FieldLevelEncryptionList_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldLevelEncryptionSummary").map(FieldLevelEncryptionSummary_Parse),
  };
}

function FieldLevelEncryptionSummary_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionSummary {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    QueryArgProfileConfig: node.first("QueryArgProfileConfig", false, QueryArgProfileConfig_Parse),
    ContentTypeProfileConfig: node.first("ContentTypeProfileConfig", false, ContentTypeProfileConfig_Parse),
  };
}

function FieldLevelEncryptionProfileList_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionProfileList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "FieldLevelEncryptionProfileSummary").map(FieldLevelEncryptionProfileSummary_Parse),
  };
}

function FieldLevelEncryptionProfileSummary_Parse(node: xmlP.XmlNode): s.FieldLevelEncryptionProfileSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true},
      optional: {"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    EncryptionEntities: node.first("EncryptionEntities", true, EncryptionEntities_Parse),
  };
}

function InvalidationList_Parse(node: xmlP.XmlNode): s.InvalidationList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "InvalidationSummary").map(InvalidationSummary_Parse),
  };
}

function InvalidationSummary_Parse(node: xmlP.XmlNode): s.InvalidationSummary {
  return {
    ...node.strings({
      required: {"Id":true,"Status":true},
    }),
    CreateTime: node.first("CreateTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function KeyGroupList_Parse(node: xmlP.XmlNode): s.KeyGroupList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "KeyGroupSummary").map(KeyGroupSummary_Parse),
  };
}

function KeyGroupSummary_Parse(node: xmlP.XmlNode): s.KeyGroupSummary {
  return {
    KeyGroup: node.first("KeyGroup", true, KeyGroup_Parse),
  };
}

function OriginRequestPolicyList_Parse(node: xmlP.XmlNode): s.OriginRequestPolicyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "OriginRequestPolicySummary").map(OriginRequestPolicySummary_Parse),
  };
}

function OriginRequestPolicySummary_Parse(node: xmlP.XmlNode): s.OriginRequestPolicySummary {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as s.OriginRequestPolicyType),
    OriginRequestPolicy: node.first("OriginRequestPolicy", true, OriginRequestPolicy_Parse),
  };
}

function PublicKeyList_Parse(node: xmlP.XmlNode): s.PublicKeyList {
  return {
    ...node.strings({
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "PublicKeySummary").map(PublicKeySummary_Parse),
  };
}

function PublicKeySummary_Parse(node: xmlP.XmlNode): s.PublicKeySummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"EncodedKey":true},
      optional: {"Comment":true},
    }),
    CreatedTime: node.first("CreatedTime", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function RealtimeLogConfigs_Parse(node: xmlP.XmlNode): s.RealtimeLogConfigs {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "member").map(RealtimeLogConfig_Parse),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
  };
}

function StreamingDistributionList_Parse(node: xmlP.XmlNode): s.StreamingDistributionList {
  return {
    ...node.strings({
      required: {"Marker":true},
      optional: {"NextMarker":true},
    }),
    MaxItems: node.first("MaxItems", true, x => parseInt(x.content ?? '0')),
    IsTruncated: node.first("IsTruncated", true, x => x.content === 'true'),
    Quantity: node.first("Quantity", true, x => parseInt(x.content ?? '0')),
    Items: node.getList("Items", "StreamingDistributionSummary").map(StreamingDistributionSummary_Parse),
  };
}

function StreamingDistributionSummary_Parse(node: xmlP.XmlNode): s.StreamingDistributionSummary {
  return {
    ...node.strings({
      required: {"Id":true,"ARN":true,"Status":true,"DomainName":true,"Comment":true},
    }),
    LastModifiedTime: node.first("LastModifiedTime", true, x => xmlP.parseTimestamp(x.content)),
    S3Origin: node.first("S3Origin", true, S3Origin_Parse),
    Aliases: node.first("Aliases", true, Aliases_Parse),
    TrustedSigners: node.first("TrustedSigners", true, TrustedSigners_Parse),
    PriceClass: node.first("PriceClass", true, x => (x.content ?? '') as s.PriceClass),
    Enabled: node.first("Enabled", true, x => x.content === 'true'),
  };
}
