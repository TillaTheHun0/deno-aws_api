// Autogenerated API client for: Amazon Timestream Write

import type { ServiceClient, ApiFactory, ApiMetadata } from '../../client/common.ts';
interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";

export default class TimestreamWrite {
  #client: ServiceClient;
  constructor(apiFactory: ApiFactory) {
    this.#client = apiFactory.buildServiceClient(TimestreamWrite.ApiMetadata);
  }

  static ApiMetadata: ApiMetadata = {
    "apiVersion": "2018-11-01",
    "endpointPrefix": "ingest.timestream",
    "jsonVersion": "1.0",
    "protocol": "json",
    "serviceAbbreviation": "Timestream Write",
    "serviceFullName": "Amazon Timestream Write",
    "serviceId": "Timestream Write",
    "signatureVersion": "v4",
    "signingName": "timestream",
    "targetPrefix": "Timestream_20181101",
    "uid": "timestream-write-2018-11-01"
  };

  async createDatabase(
    {abortSignal, ...params}: RequestConfig & CreateDatabaseRequest,
  ): Promise<CreateDatabaseResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      KmsKeyId: params["KmsKeyId"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Database": toDatabase,
      },
    }, await resp.json());
  }

  async createTable(
    {abortSignal, ...params}: RequestConfig & CreateTableRequest,
  ): Promise<CreateTableResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      RetentionProperties: fromRetentionProperties(params["RetentionProperties"]),
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTable,
      },
    }, await resp.json());
  }

  async deleteDatabase(
    {abortSignal, ...params}: RequestConfig & DeleteDatabaseRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteDatabase",
    });
  }

  async deleteTable(
    {abortSignal, ...params}: RequestConfig & DeleteTableRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeleteTable",
    });
  }

  async describeDatabase(
    {abortSignal, ...params}: RequestConfig & DescribeDatabaseRequest,
  ): Promise<DescribeDatabaseResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Database": toDatabase,
      },
    }, await resp.json());
  }

  async describeEndpoints(
    {abortSignal, ...params}: RequestConfig & DescribeEndpointsRequest = {},
  ): Promise<DescribeEndpointsResponse> {
    const body: jsonP.JSONObject = {
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeEndpoints",
    });
    return jsonP.readObj({
      required: {
        "Endpoints": [toEndpoint],
      },
      optional: {},
    }, await resp.json());
  }

  async describeTable(
    {abortSignal, ...params}: RequestConfig & DescribeTableRequest,
  ): Promise<DescribeTableResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTable,
      },
    }, await resp.json());
  }

  async listDatabases(
    {abortSignal, ...params}: RequestConfig & ListDatabasesRequest = {},
  ): Promise<ListDatabasesResponse> {
    const body: jsonP.JSONObject = {
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListDatabases",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Databases": [toDatabase],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTables(
    {abortSignal, ...params}: RequestConfig & ListTablesRequest = {},
  ): Promise<ListTablesResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTables",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tables": [toTable],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    {abortSignal, ...params}: RequestConfig & ListTagsForResourceRequest,
  ): Promise<ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": [toTag],
      },
    }, await resp.json());
  }

  async tagResource(
    {abortSignal, ...params}: RequestConfig & TagResourceRequest,
  ): Promise<TagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      Tags: params["Tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "TagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async untagResource(
    {abortSignal, ...params}: RequestConfig & UntagResourceRequest,
  ): Promise<UntagResourceResponse> {
    const body: jsonP.JSONObject = {
      ResourceARN: params["ResourceARN"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UntagResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async updateDatabase(
    {abortSignal, ...params}: RequestConfig & UpdateDatabaseRequest,
  ): Promise<UpdateDatabaseResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      KmsKeyId: params["KmsKeyId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateDatabase",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Database": toDatabase,
      },
    }, await resp.json());
  }

  async updateTable(
    {abortSignal, ...params}: RequestConfig & UpdateTableRequest,
  ): Promise<UpdateTableResponse> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      RetentionProperties: fromRetentionProperties(params["RetentionProperties"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "UpdateTable",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Table": toTable,
      },
    }, await resp.json());
  }

  async writeRecords(
    {abortSignal, ...params}: RequestConfig & WriteRecordsRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      DatabaseName: params["DatabaseName"],
      TableName: params["TableName"],
      CommonAttributes: fromRecord(params["CommonAttributes"]),
      Records: params["Records"]?.map(x => fromRecord(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "WriteRecords",
    });
  }

}

// refs: 1 - tags: named, input
export interface CreateDatabaseRequest {
  DatabaseName: string;
  KmsKeyId?: string | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface CreateTableRequest {
  DatabaseName: string;
  TableName: string;
  RetentionProperties?: RetentionProperties | null;
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, input
export interface DeleteDatabaseRequest {
  DatabaseName: string;
}

// refs: 1 - tags: named, input
export interface DeleteTableRequest {
  DatabaseName: string;
  TableName: string;
}

// refs: 1 - tags: named, input
export interface DescribeDatabaseRequest {
  DatabaseName: string;
}

// refs: 1 - tags: named, input
export interface DescribeEndpointsRequest {
}

// refs: 1 - tags: named, input
export interface DescribeTableRequest {
  DatabaseName: string;
  TableName: string;
}

// refs: 1 - tags: named, input
export interface ListDatabasesRequest {
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTablesRequest {
  DatabaseName?: string | null;
  NextToken?: string | null;
  MaxResults?: number | null;
}

// refs: 1 - tags: named, input
export interface ListTagsForResourceRequest {
  ResourceARN: string;
}

// refs: 1 - tags: named, input
export interface TagResourceRequest {
  ResourceARN: string;
  Tags: Tag[];
}

// refs: 1 - tags: named, input
export interface UntagResourceRequest {
  ResourceARN: string;
  TagKeys: string[];
}

// refs: 1 - tags: named, input
export interface UpdateDatabaseRequest {
  DatabaseName: string;
  KmsKeyId: string;
}

// refs: 1 - tags: named, input
export interface UpdateTableRequest {
  DatabaseName: string;
  TableName: string;
  RetentionProperties: RetentionProperties;
}

// refs: 1 - tags: named, input
export interface WriteRecordsRequest {
  DatabaseName: string;
  TableName: string;
  CommonAttributes?: Record | null;
  Records: Record[];
}

// refs: 1 - tags: named, output
export interface CreateDatabaseResponse {
  Database?: Database | null;
}

// refs: 1 - tags: named, output
export interface CreateTableResponse {
  Table?: Table | null;
}

// refs: 1 - tags: named, output
export interface DescribeDatabaseResponse {
  Database?: Database | null;
}

// refs: 1 - tags: named, output
export interface DescribeEndpointsResponse {
  Endpoints: Endpoint[];
}

// refs: 1 - tags: named, output
export interface DescribeTableResponse {
  Table?: Table | null;
}

// refs: 1 - tags: named, output
export interface ListDatabasesResponse {
  Databases?: Database[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTablesResponse {
  Tables?: Table[] | null;
  NextToken?: string | null;
}

// refs: 1 - tags: named, output
export interface ListTagsForResourceResponse {
  Tags?: Tag[] | null;
}

// refs: 1 - tags: named, output
export interface TagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UntagResourceResponse {
}

// refs: 1 - tags: named, output
export interface UpdateDatabaseResponse {
  Database?: Database | null;
}

// refs: 1 - tags: named, output
export interface UpdateTableResponse {
  Table?: Table | null;
}

// refs: 4 - tags: input, named, interface, output
export interface Tag {
  Key: string;
  Value: string;
}
function fromTag(input?: Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): Tag {
  return jsonP.readObj({
    required: {
      "Key": "s",
      "Value": "s",
    },
    optional: {},
  }, root);
}

// refs: 6 - tags: input, named, interface, output
export interface RetentionProperties {
  MemoryStoreRetentionPeriodInHours: number;
  MagneticStoreRetentionPeriodInDays: number;
}
function fromRetentionProperties(input?: RetentionProperties | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    MemoryStoreRetentionPeriodInHours: input["MemoryStoreRetentionPeriodInHours"],
    MagneticStoreRetentionPeriodInDays: input["MagneticStoreRetentionPeriodInDays"],
  }
}
function toRetentionProperties(root: jsonP.JSONValue): RetentionProperties {
  return jsonP.readObj({
    required: {
      "MemoryStoreRetentionPeriodInHours": "n",
      "MagneticStoreRetentionPeriodInDays": "n",
    },
    optional: {},
  }, root);
}

// refs: 2 - tags: input, named, interface
export interface Record {
  Dimensions?: Dimension[] | null;
  MeasureName?: string | null;
  MeasureValue?: string | null;
  MeasureValueType?: MeasureValueType | null;
  Time?: string | null;
  TimeUnit?: TimeUnit | null;
}
function fromRecord(input?: Record | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Dimensions: input["Dimensions"]?.map(x => fromDimension(x)),
    MeasureName: input["MeasureName"],
    MeasureValue: input["MeasureValue"],
    MeasureValueType: input["MeasureValueType"],
    Time: input["Time"],
    TimeUnit: input["TimeUnit"],
  }
}

// refs: 2 - tags: input, named, interface
export interface Dimension {
  Name: string;
  Value: string;
  DimensionValueType?: DimensionValueType | null;
}
function fromDimension(input?: Dimension | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Name: input["Name"],
    Value: input["Value"],
    DimensionValueType: input["DimensionValueType"],
  }
}

// refs: 2 - tags: input, named, enum
export type DimensionValueType =
| "VARCHAR"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type MeasureValueType =
| "DOUBLE"
| "BIGINT"
| "VARCHAR"
| "BOOLEAN"
| cmnP.UnexpectedEnumValue;

// refs: 2 - tags: input, named, enum
export type TimeUnit =
| "MILLISECONDS"
| "SECONDS"
| "MICROSECONDS"
| "NANOSECONDS"
| cmnP.UnexpectedEnumValue;

// refs: 4 - tags: output, named, interface
export interface Database {
  Arn?: string | null;
  DatabaseName?: string | null;
  TableCount?: number | null;
  KmsKeyId?: string | null;
  CreationTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
}
function toDatabase(root: jsonP.JSONValue): Database {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "DatabaseName": "s",
      "TableCount": "n",
      "KmsKeyId": "s",
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

// refs: 4 - tags: output, named, interface
export interface Table {
  Arn?: string | null;
  TableName?: string | null;
  DatabaseName?: string | null;
  TableStatus?: TableStatus | null;
  RetentionProperties?: RetentionProperties | null;
  CreationTime?: Date | number | null;
  LastUpdatedTime?: Date | number | null;
}
function toTable(root: jsonP.JSONValue): Table {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "TableName": "s",
      "DatabaseName": "s",
      "TableStatus": (x: jsonP.JSONValue) => cmnP.readEnum<TableStatus>(x),
      "RetentionProperties": toRetentionProperties,
      "CreationTime": "d",
      "LastUpdatedTime": "d",
    },
  }, root);
}

// refs: 4 - tags: output, named, enum
export type TableStatus =
| "ACTIVE"
| "DELETING"
| cmnP.UnexpectedEnumValue;

// refs: 1 - tags: output, named, interface
export interface Endpoint {
  Address: string;
  CachePeriodInMinutes: number;
}
function toEndpoint(root: jsonP.JSONValue): Endpoint {
  return jsonP.readObj({
    required: {
      "Address": "s",
      "CachePeriodInMinutes": "n",
    },
    optional: {},
  }, root);
}
