// Autogenerated API client for: AWS Data Pipeline

interface RequestConfig {
  abortSignal?: AbortSignal;
}

import * as cmnP from "../../encoding/common.ts";
import * as client from "../../client/common.ts";
import type * as s from "./structs.ts";
import * as jsonP from "../../encoding/json.ts";

export default class DataPipeline {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(DataPipeline.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-10-29",
    "endpointPrefix": "datapipeline",
    "jsonVersion": "1.1",
    "serviceFullName": "AWS Data Pipeline",
    "serviceId": "Data Pipeline",
    "signatureVersion": "v4",
    "targetPrefix": "DataPipeline",
    "protocol": "json",
    "uid": "datapipeline-2012-10-29"
  };

  async activatePipeline(
    {abortSignal, ...params}: RequestConfig & s.ActivatePipelineInput,
  ): Promise<s.ActivatePipelineOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      parameterValues: params["parameterValues"]?.map(x => fromParameterValue(x)),
      startTimestamp: jsonP.serializeDate_unixTimestamp(params["startTimestamp"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ActivatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async addTags(
    {abortSignal, ...params}: RequestConfig & s.AddTagsInput,
  ): Promise<s.AddTagsOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "AddTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async createPipeline(
    {abortSignal, ...params}: RequestConfig & s.CreatePipelineInput,
  ): Promise<s.CreatePipelineOutput> {
    const body: jsonP.JSONObject = {
      name: params["name"],
      uniqueId: params["uniqueId"],
      description: params["description"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "CreatePipeline",
    });
    return jsonP.readObj({
      required: {
        "pipelineId": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async deactivatePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeactivatePipelineInput,
  ): Promise<s.DeactivatePipelineOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      cancelActive: params["cancelActive"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeactivatePipeline",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async deletePipeline(
    {abortSignal, ...params}: RequestConfig & s.DeletePipelineInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DeletePipeline",
    });
  }

  async describeObjects(
    {abortSignal, ...params}: RequestConfig & s.DescribeObjectsInput,
  ): Promise<s.DescribeObjectsOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      objectIds: params["objectIds"],
      evaluateExpressions: params["evaluateExpressions"],
      marker: params["marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribeObjects",
    });
    return jsonP.readObj({
      required: {
        "pipelineObjects": [toPipelineObject],
      },
      optional: {
        "marker": "s",
        "hasMoreResults": "b",
      },
    }, await resp.json());
  }

  async describePipelines(
    {abortSignal, ...params}: RequestConfig & s.DescribePipelinesInput,
  ): Promise<s.DescribePipelinesOutput> {
    const body: jsonP.JSONObject = {
      pipelineIds: params["pipelineIds"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "DescribePipelines",
    });
    return jsonP.readObj({
      required: {
        "pipelineDescriptionList": [toPipelineDescription],
      },
      optional: {},
    }, await resp.json());
  }

  async evaluateExpression(
    {abortSignal, ...params}: RequestConfig & s.EvaluateExpressionInput,
  ): Promise<s.EvaluateExpressionOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      objectId: params["objectId"],
      expression: params["expression"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "EvaluateExpression",
    });
    return jsonP.readObj({
      required: {
        "evaluatedExpression": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getPipelineDefinition(
    {abortSignal, ...params}: RequestConfig & s.GetPipelineDefinitionInput,
  ): Promise<s.GetPipelineDefinitionOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      version: params["version"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "GetPipelineDefinition",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pipelineObjects": [toPipelineObject],
        "parameterObjects": [toParameterObject],
        "parameterValues": [toParameterValue],
      },
    }, await resp.json());
  }

  async listPipelines(
    {abortSignal, ...params}: RequestConfig & s.ListPipelinesInput = {},
  ): Promise<s.ListPipelinesOutput> {
    const body: jsonP.JSONObject = {
      marker: params["marker"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ListPipelines",
    });
    return jsonP.readObj({
      required: {
        "pipelineIdList": [toPipelineIdName],
      },
      optional: {
        "marker": "s",
        "hasMoreResults": "b",
      },
    }, await resp.json());
  }

  async pollForTask(
    {abortSignal, ...params}: RequestConfig & s.PollForTaskInput,
  ): Promise<s.PollForTaskOutput> {
    const body: jsonP.JSONObject = {
      workerGroup: params["workerGroup"],
      hostname: params["hostname"],
      instanceIdentity: fromInstanceIdentity(params["instanceIdentity"]),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PollForTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "taskObject": toTaskObject,
      },
    }, await resp.json());
  }

  async putPipelineDefinition(
    {abortSignal, ...params}: RequestConfig & s.PutPipelineDefinitionInput,
  ): Promise<s.PutPipelineDefinitionOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      pipelineObjects: params["pipelineObjects"]?.map(x => fromPipelineObject(x)),
      parameterObjects: params["parameterObjects"]?.map(x => fromParameterObject(x)),
      parameterValues: params["parameterValues"]?.map(x => fromParameterValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "PutPipelineDefinition",
    });
    return jsonP.readObj({
      required: {
        "errored": "b",
      },
      optional: {
        "validationErrors": [toValidationError],
        "validationWarnings": [toValidationWarning],
      },
    }, await resp.json());
  }

  async queryObjects(
    {abortSignal, ...params}: RequestConfig & s.QueryObjectsInput,
  ): Promise<s.QueryObjectsOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      query: fromQuery(params["query"]),
      sphere: params["sphere"],
      marker: params["marker"],
      limit: params["limit"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "QueryObjects",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ids": ["s"],
        "marker": "s",
        "hasMoreResults": "b",
      },
    }, await resp.json());
  }

  async removeTags(
    {abortSignal, ...params}: RequestConfig & s.RemoveTagsInput,
  ): Promise<s.RemoveTagsOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "RemoveTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async reportTaskProgress(
    {abortSignal, ...params}: RequestConfig & s.ReportTaskProgressInput,
  ): Promise<s.ReportTaskProgressOutput> {
    const body: jsonP.JSONObject = {
      taskId: params["taskId"],
      fields: params["fields"]?.map(x => fromField(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReportTaskProgress",
    });
    return jsonP.readObj({
      required: {
        "canceled": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async reportTaskRunnerHeartbeat(
    {abortSignal, ...params}: RequestConfig & s.ReportTaskRunnerHeartbeatInput,
  ): Promise<s.ReportTaskRunnerHeartbeatOutput> {
    const body: jsonP.JSONObject = {
      taskrunnerId: params["taskrunnerId"],
      workerGroup: params["workerGroup"],
      hostname: params["hostname"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ReportTaskRunnerHeartbeat",
    });
    return jsonP.readObj({
      required: {
        "terminate": "b",
      },
      optional: {},
    }, await resp.json());
  }

  async setStatus(
    {abortSignal, ...params}: RequestConfig & s.SetStatusInput,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      objectIds: params["objectIds"],
      status: params["status"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetStatus",
    });
  }

  async setTaskStatus(
    {abortSignal, ...params}: RequestConfig & s.SetTaskStatusInput,
  ): Promise<s.SetTaskStatusOutput> {
    const body: jsonP.JSONObject = {
      taskId: params["taskId"],
      taskStatus: params["taskStatus"],
      errorId: params["errorId"],
      errorMessage: params["errorMessage"],
      errorStackTrace: params["errorStackTrace"],
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "SetTaskStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {},
    }, await resp.json());
  }

  async validatePipelineDefinition(
    {abortSignal, ...params}: RequestConfig & s.ValidatePipelineDefinitionInput,
  ): Promise<s.ValidatePipelineDefinitionOutput> {
    const body: jsonP.JSONObject = {
      pipelineId: params["pipelineId"],
      pipelineObjects: params["pipelineObjects"]?.map(x => fromPipelineObject(x)),
      parameterObjects: params["parameterObjects"]?.map(x => fromParameterObject(x)),
      parameterValues: params["parameterValues"]?.map(x => fromParameterValue(x)),
    };
    const resp = await this.#client.performRequest({
      abortSignal, body,
      action: "ValidatePipelineDefinition",
    });
    return jsonP.readObj({
      required: {
        "errored": "b",
      },
      optional: {
        "validationErrors": [toValidationError],
        "validationWarnings": [toValidationWarning],
      },
    }, await resp.json());
  }

}

function fromParameterValue(input?: s.ParameterValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    stringValue: input["stringValue"],
  }
}
function toParameterValue(root: jsonP.JSONValue): s.ParameterValue {
  return jsonP.readObj({
    required: {
      "id": "s",
      "stringValue": "s",
    },
    optional: {},
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    value: input["value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {
      "key": "s",
      "value": "s",
    },
    optional: {},
  }, root);
}

function fromInstanceIdentity(input?: s.InstanceIdentity | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    document: input["document"],
    signature: input["signature"],
  }
}

function fromPipelineObject(input?: s.PipelineObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    name: input["name"],
    fields: input["fields"]?.map(x => fromField(x)),
  }
}
function toPipelineObject(root: jsonP.JSONValue): s.PipelineObject {
  return jsonP.readObj({
    required: {
      "id": "s",
      "name": "s",
      "fields": [toField],
    },
    optional: {},
  }, root);
}

function fromField(input?: s.Field | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    stringValue: input["stringValue"],
    refValue: input["refValue"],
  }
}
function toField(root: jsonP.JSONValue): s.Field {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "stringValue": "s",
      "refValue": "s",
    },
  }, root);
}

function fromParameterObject(input?: s.ParameterObject | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    id: input["id"],
    attributes: input["attributes"]?.map(x => fromParameterAttribute(x)),
  }
}
function toParameterObject(root: jsonP.JSONValue): s.ParameterObject {
  return jsonP.readObj({
    required: {
      "id": "s",
      "attributes": [toParameterAttribute],
    },
    optional: {},
  }, root);
}

function fromParameterAttribute(input?: s.ParameterAttribute | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    key: input["key"],
    stringValue: input["stringValue"],
  }
}
function toParameterAttribute(root: jsonP.JSONValue): s.ParameterAttribute {
  return jsonP.readObj({
    required: {
      "key": "s",
      "stringValue": "s",
    },
    optional: {},
  }, root);
}

function fromQuery(input?: s.Query | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    selectors: input["selectors"]?.map(x => fromSelector(x)),
  }
}

function fromSelector(input?: s.Selector | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    fieldName: input["fieldName"],
    operator: fromOperator(input["operator"]),
  }
}

function fromOperator(input?: s.Operator | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    type: input["type"],
    values: input["values"],
  }
}

function toPipelineDescription(root: jsonP.JSONValue): s.PipelineDescription {
  return jsonP.readObj({
    required: {
      "pipelineId": "s",
      "name": "s",
      "fields": [toField],
    },
    optional: {
      "description": "s",
      "tags": [toTag],
    },
  }, root);
}

function toPipelineIdName(root: jsonP.JSONValue): s.PipelineIdName {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "name": "s",
    },
  }, root);
}

function toTaskObject(root: jsonP.JSONValue): s.TaskObject {
  return jsonP.readObj({
    required: {},
    optional: {
      "taskId": "s",
      "pipelineId": "s",
      "attemptId": "s",
      "objects": x => jsonP.readMap(String, toPipelineObject, x),
    },
  }, root);
}

function toValidationError(root: jsonP.JSONValue): s.ValidationError {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "errors": ["s"],
    },
  }, root);
}

function toValidationWarning(root: jsonP.JSONValue): s.ValidationWarning {
  return jsonP.readObj({
    required: {},
    optional: {
      "id": "s",
      "warnings": ["s"],
    },
  }, root);
}
